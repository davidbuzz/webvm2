receive is done on the transmit wire. The Swap option allows the RX and TX pins to be swapped on STM32F7 based boards.
    // @Bitmask: 0:InvertRX, 1:InvertTX, 2:HalfDuplex, 3:SwapTXRX, 4: RX_PullDown, 5: RX_PullUp, 6: TX_PullDown, 7: TX_PullUp, 8: RX_NoDMA, 9: TX_NoDMA, 10: Don't forward mavlink to/from, 11: DisableFIFO, 12: Ignore Streamrate
    // @User: Advanced
    // @RebootRequired: True
    AP_GROUPINFO("1_OPTIONS",  14, AP_SerialManager, state[1].options, DEFAULT_SERIAL1_OPTIONS),
#endif

#if HAL_HAVE_SERIAL2
    // @Param: 2_OPTIONS
    // @CopyFieldsFrom: SERIAL1_OPTIONS
    // @DisplayName: Telem2 options
    AP_GROUPINFO("2_OPTIONS",  15, AP_SerialManager, state[2].options, DEFAULT_SERIAL2_OPTIONS),
#endif

#if HAL_HAVE_SERIAL3
    // @Param: 3_OPTIONS
    // @CopyFieldsFrom: SERIAL1_OPTIONS
    // @DisplayName: Serial3 options
    AP_GROUPINFO("3_OPTIONS",  16, AP_SerialManager, state[3].options, DEFAULT_SERIAL3_OPTIONS),
#endif

#if HAL_HAVE_SERIAL4
    // @Param: 4_OPTIONS
    // @CopyFieldsFrom: SERIAL1_OPTIONS
    // @DisplayName: Serial4 options
    AP_GROUPINFO("4_OPTIONS",  17, AP_SerialManager, state[4].options, DEFAULT_SERIAL4_OPTIONS),
#endif

#if HAL_HAVE_SERIAL5
    // @Param: 5_OPTIONS
    // @CopyFieldsFrom: SERIAL1_OPTIONS
    // @DisplayName: Serial5 options
    AP_GROUPINFO("5_OPTIONS",  18, AP_SerialManager, state[5].options, DEFAULT_SERIAL5_OPTIONS),
#endif

#if HAL_HAVE_SERIAL6
    // @Param: 6_OPTIONS
    // @CopyFieldsFrom: SERIAL1_OPTIONS
    // @DisplayName: Serial6 options
    AP_GROUPINFO("6_OPTIONS",  19, AP_SerialManager, state[6].options, DEFAULT_SERIAL6_OPTIONS),
#endif

    // @Param: _PASS1
    // @DisplayName: Serial passthru first port
    // @Description: This sets one side of pass-through between two serial ports. Once both sides are set then all data received on either port will be passed to the other port
    // @Values: -1:Disabled,0:Serial0,1:Serial1,2:Serial2,3:Serial3,4:Serial4,5:Serial5,6:Serial6
    // @User: Advanced
    AP_GROUPINFO("_PASS1",  20, AP_SerialManager, passthru_port1, 0),

    // @Param: _PASS2
    // @DisplayName: Serial passthru second port
    // @Description: This sets one side of pass-through between two serial ports. Once both sides are set then all data received on either port will be passed to the other port
    // @Values: -1:Disabled,0:Serial0,1:Serial1,2:Serial2,3:Serial3,4:Serial4,5:Serial5,6:Serial6
    // @User: Advanced
    AP_GROUPINFO("_PASS2",  21, AP_SerialManager, passthru_port2, -1),

    // @Param: _PASSTIMO
    // @DisplayName: Serial passthru timeout
    // @Description: This sets a timeout for serial pass-through in seconds. When the pass-through is enabled by setting the SERIAL_PASS1 and SERIAL_PASS2 parameters then it remains in effect until no data comes from the first port for SERIAL_PASSTIMO seconds. This allows the port to revent to its normal usage (such as MAVLink connection to a GCS) when it is no longer needed. A value of 0 means no timeout.
    // @Range: 0 120
    // @Units: s
    // @User: Advanced
    AP_GROUPINFO("_PASSTIMO",  22, AP_SerialManager, passthru_timeout, 15),

#if HAL_HAVE_SERIAL7
    // @Param: 7_PROTOCOL
    // @CopyFieldsFrom: SERIAL1_PROTOCOL
    // @DisplayName: Serial7 protocol selection
    // @Description: Control what protocol Serial7 port should be used for. Note that the Frsky options require external converter hardware. See the wiki for details.
    AP_GROUPINFO("7_PROTOCOL",  23, AP_SerialManager, state[7].protocol, DEFAULT_SERIAL7_PROTOCOL),

    // @Param: 7_BAUD
    // @CopyFieldsFrom: SERIAL1_BAUD
    // @DisplayName: Serial 7 Baud Rate
    // @Description: The baud rate used for Serial7. Most stm32-based boards can support rates of up to 1500. If you setup a rate you cannot support and then can't connect to your board you should load a firmware from a different vehicle type. That will reset all your parameters to defaults.
    AP_GROUPINFO("7_BAUD", 24, AP_SerialManager, state[7].baud, DEFAULT_SERIAL7_BAUD),

    // @Param: 7_OPTIONS
    // @CopyFieldsFrom: SERIAL1_OPTIONS
    // @DisplayName: Serial7 options
    AP_GROUPINFO("7_OPTIONS",  25, AP_SerialManager, state[7].options, 0),
#endif

#if HAL_HAVE_SERIAL8
    // @Param: 8_PROTOCOL
    // @CopyFieldsFrom: SERIAL1_PROTOCOL
    // @DisplayName: Serial8 protocol selection
    // @Description: Control what protocol Serial8 port should be used for. Note that the Frsky options require external converter hardware. See the wiki for details.
    AP_GROUPINFO("8_PROTOCOL",  26, AP_SerialManager, state[8].protocol, DEFAULT_SERIAL8_PROTOCOL),

    // @Param: 8_BAUD
    // @CopyFieldsFrom: SERIAL1_BAUD
    // @DisplayName: Serial 8 Baud Rate
    // @Description: The baud rate used for Serial8. Most stm32-based boards can support rates of up to 1500. If you setup a rate you cannot support and then can't connect to your board you should load a firmware from a different vehicle type. That will reset all your parameters to defaults.
    AP_GROUPINFO("8_BAUD", 27, AP_SerialManager, state[8].baud, DEFAULT_SERIAL8_BAUD),

    // @Param: 8_OPTIONS
    // @CopyFieldsFrom: SERIAL1_OPTIONS
    // @DisplayName: Serial8 options
    AP_GROUPINFO("8_OPTIONS",  28, AP_SerialManager, state[8].options, 0),
#endif

#if HAL_HAVE_SERIAL9
    // @Param: 9_PROTOCOL
    // @CopyFieldsFrom: SERIAL1_PROTOCOL
    // @DisplayName: Serial9 protocol selection
    // @Description: Control what protocol Serial9 port should be used for. Note that the Frsky options require external converter hardware. See the wiki for details.
    AP_GROUPINFO("9_PROTOCOL",  29, AP_SerialManager, state[9].protocol, DEFAULT_SERIAL9_PROTOCOL),

    // @Param: 9_BAUD
    // @CopyFieldsFrom: SERIAL1_BAUD
    // @DisplayName: Serial 9 Baud Rate
    // @Description: The baud rate used for Serial8. Most stm32-based boards can support rates of up to 1500. If you setup a rate you cannot support and then can't connect to your board you should load a firmware from a different vehicle type. That will reset all your parameters to defaults.
    AP_GROUPINFO("9_BAUD", 30, AP_SerialManager, state[9].baud, DEFAULT_SERIAL9_BAUD),

    // @Param: 9_OPTIONS
    // @CopyFieldsFrom: SERIAL1_OPTIONS
    // @DisplayName: Serial9 options
    AP_GROUPINFO("9_OPTIONS",  31, AP_SerialManager, state[9].options, DEFAULT_SERIAL9_OPTIONS),
#endif

    AP_GROUPEND
};

// singleton instance
AP_SerialManager *AP_SerialManager::_singleton;

// Constructor
AP_SerialManager::AP_SerialManager()
{
    _singleton = this;
    // setup parameter defaults
    AP_Param::setup_object_defaults(this, var_info);
}

// init_console - initialise console at default baud rate
void AP_SerialManager::init_console()
{
    // initialise console immediately at default size and baud
#if SERIALMANAGER_NUM_PORTS > 0
    if (!init_console_done) {
        init_console_done = true;
        hal.serial(0)->begin(DEFAULT_SERIAL0_BAUD,
                             AP_SERIALMANAGER_CONSOLE_BUFSIZE_RX,
                             AP_SERIALMANAGER_CONSOLE_BUFSIZE_TX);
    }
#endif
}

// init - // init - initialise serial ports
void AP_SerialManager::init()
{
    // always reset passthru port2 on boot
    passthru_port2.set_and_save_ifchanged(-1);

#ifdef HAL_OTG1_CONFIG
    /*
      prevent users from changing USB protocol to other than
      MAVLink. This fixes an issue where users trying to get SLCAN
      change SERIAL0_PROTOCOL to 22 and find they can no longer connect
     */
    if (state[0].protocol != SerialProtocol_MAVLink &&
        state[0].protocol != SerialProtocol_MAVLink2) {
        state[0].protocol.set(SerialProtocol_MAVLink2);
    }
#endif

    init_console();

    // initialise serial ports
    for (uint8_t i=1; i<SERIALMANAGER_NUM_PORTS; i++) {
        auto *uart = hal.serial(i);

        state[i].idx = i;

        if (uart != nullptr) {
            set_options(i);
            switch (state[i].protocol) {
                case SerialProtocol_None:
#if HAL_GCS_ENABLED
                    // disable RX and TX pins in case they are shared
                    // with another peripheral (eg. RCIN pin). We
                    // don't do this if GCS is not enabled as in that
                    // case we don't have serialmanager parameters and
                    // this would prevent AP_Periph from using a GPS
                    uart->disable_rxtx();
#endif
                    break;
                case SerialProtocol_Console:
                case SerialProtocol_MAVLink:
                case SerialProtocol_MAVLink2:
                case SerialProtocol_MAVLinkHL:
                    uart->begin(state[i].baudrate(),
                                         AP_SERIALMANAGER_MAVLINK_BUFSIZE_RX,
                                         AP_SERIALMANAGER_MAVLINK_BUFSIZE_TX);
                    break;
                case SerialProtocol_FrSky_D:
                    // Note baudrate is hardcoded to 9600
                    state[i].baud.set_and_default(AP_SERIALMANAGER_FRSKY_D_BAUD/1000); // update baud param in case user looks at it
                    // begin is handled by AP_Frsky_telem library
                    break;
                case SerialProtocol_FrSky_SPort:
                case SerialProtocol_FrSky_SPort_Passthrough:
                    // Note baudrate is hardcoded to 57600
                    state[i].baud.set_and_default(AP_SERIALMANAGER_FRSKY_SPORT_BAUD/1000); // update baud param in case user looks at it
                    // begin is handled by AP_Frsky_telem library
                    break;
                case SerialProtocol_GPS:
                case SerialProtocol_GPS2:
                    uart->begin(state[i].baudrate(),
                                         AP_SERIALMANAGER_GPS_BUFSIZE_RX,
                                         AP_SERIALMANAGER_GPS_BUFSIZE_TX);
                    break;
                case SerialProtocol_AlexMos:
                    // Note baudrate is hardcoded to 115200
                    state[i].baud.set_and_default(AP_SERIALMANAGER_ALEXMOS_BAUD / 1000);   // update baud param in case user looks at it
                    uart->begin(AP_SERIALMANAGER_ALEXMOS_BAUD,
                                         AP_SERIALMANAGER_ALEXMOS_BUFSIZE_RX,
                                         AP_SERIALMANAGER_ALEXMOS_BUFSIZE_TX);
                    break;
                case SerialProtocol_Gimbal:
                    // Note baudrate is hardcoded to 115200
                    state[i].baud.set_and_default(AP_SERIALMANAGER_GIMBAL_BAUD / 1000);     // update baud param in case user looks at it
                    uart->begin(state[i].baudrate(),
                                         AP_SERIALMANAGER_GIMBAL_BUFSIZE_RX,
                                         AP_SERIALMANAGER_GIMBAL_BUFSIZE_TX);
                    break;
                case SerialProtocol_Aerotenna_USD1:
                    state[i].protocol.set_and_save(SerialProtocol_Rangefinder);
                    break;
                case SerialProtocol_Volz:
                    // Note baudrate is hardcoded to 115200
                    state[i].baud.set_and_default(AP_SERIALMANAGER_VOLZ_BAUD);   // update baud param in case user looks at it
                    break;
                case SerialProtocol_Sbus1:
                    state[i].baud.set_and_default(AP_SERIALMANAGER_SBUS1_BAUD / 1000);   // update baud param in case user looks at it
                    uart->begin(state[i].baudrate(),
                                         AP_SERIALMANAGER_SBUS1_BUFSIZE_RX,
                                         AP_SERIALMANAGER_SBUS1_BUFSIZE_TX);
                    uart->configure_parity(2);    // enable even parity
                    uart->set_stop_bits(2);
                    uart->set_unbuffered_writes(true);
                    uart->set_flow_control(AP_HAL::UARTDriver::FLOW_CONTROL_DISABLE);
                    break;

                case SerialProtocol_ESCTelemetry:
                    // ESC telemetry protocol from BLHeli32 ESCs. Note that baudrate is hardcoded to 115200
                    state[i].baud.set_and_default(115200 / 1000);
                    uart->begin(state[i].baudrate(), 30, 30);
                    uart->set_flow_control(AP_HAL::UARTDriver::FLOW_CONTROL_DISABLE);
                    break;

                case SerialProtocol_Robotis:
                    uart->begin(state[i].baudrate(),
                                         AP_SERIALMANAGER_ROBOTIS_BUFSIZE_RX,
                                         AP_SERIALMANAGER_ROBOTIS_BUFSIZE_TX);
                    uart->set_unbuffered_writes(true);
                    uart->set_flow_control(AP_HAL::UARTDriver::FLOW_CONTROL_DISABLE);
                    break;

                case SerialProtocol_SLCAN:
                    uart->begin(state[i].baudrate(),
                                         AP_SERIALMANAGER_SLCAN_BUFSIZE_RX,
                                         AP_SERIALMANAGER_SLCAN_BUFSIZE_TX);
                    break;

#if AP_RCPROTOCOL_ENABLED
                case SerialProtocol_RCIN:
                    if (!AP::RC().has_uart()) {
                        AP::RC().add_uart(uart);
                    } else {
                        GCS_SEND_TEXT(MAV_SEVERITY_WARNING, "SERIAL%u_PROTOCOL: duplicate RCIN not permitted", i);
                    }

                    break;
#endif
                    
                case SerialProtocol_EFI:
                    state[i].baud.set_default(AP_SERIALMANAGER_EFI_MS_BAUD);
                    uart->begin(state[i].baudrate(),
                                         AP_SERIALMANAGER_EFI_MS_BUFSIZE_RX,
                                         AP_SERIALMANAGER_EFI_MS_BUFSIZE_TX);
                    uart->set_flow_control(AP_HAL::UARTDriver::FLOW_CONTROL_DISABLE);
                    break;

                case SerialProtocol_Generator:
                    break;
#if HAL_MSP_ENABLED                    
                case SerialProtocol_MSP:
                case SerialProtocol_DJI_FPV:
                case SerialProtocol_MSP_DisplayPort:
                    // baudrate defaults to 115200
                    state[i].baud.set_default(AP_SERIALMANAGER_MSP_BAUD/1000);
                    uart->begin(state[i].baudrate(),
                                         AP_SERIALMANAGER_MSP_BUFSIZE_RX,
                                         AP_SERIALMANAGER_MSP_BUFSIZE_TX);
                    uart->set_flow_control(AP_HAL::UARTDriver::FLOW_CONTROL_DISABLE);
                    // Note init is handled by AP_MSP
                    break;
#endif

#if AP_SERIALMANAGER_IMUOUT_ENABLED
                case SerialProtocol_IMUOUT:
                    uart->begin(state[i].baudrate(),
                                AP_SERIALMANAGER_IMUOUT_BUFSIZE_RX,
                                AP_SERIALMANAGER_IMUOUT_BUFSIZE_TX);
                    AP::ins().set_imu_out_uart(uart);
                    uart->set_unbuffered_writes(true);
                    break;
#endif
#if AP_NETWORKING_BACKEND_PPP
                case SerialProtocol_PPP:
                    uart->begin(state[i].baudrate(),
                                         AP_SERIALMANAGER_PPP_BUFSIZE_RX,
                                         AP_SERIALMANAGER_PPP_BUFSIZE_TX);
                    break;
#endif
                    
                default:
                    uart->begin(state[i].baudrate());
            }
        }
    }
}


const AP_SerialManager::UARTState *AP_SerialManager::find_protocol_instance(enum SerialProtocol protocol, uint8_t instance) const
{
    uint8_t found_instance = 0;

    // search for matching protocol
    for(uint8_t i=0; i<SERIALMANAGER_NUM_PORTS; i++) {
        if (protocol_match(protocol, (enum SerialProtocol)state[i].protocol.get())) {
            if (found_instance == instance) {
                return &state[i];
            }
            found_instance++;
        }
    }

#if AP_SERIALMANAGER_REGISTER_ENABLED
    for (auto p = registered_ports; p; p = p->next) {
        if (protocol_match(protocol, (enum SerialProtocol)p->state.protocol.get())) {
            if (found_instance == instance) {
                return &p->state;
            }
            found_instance++;
        }
    }
#endif

    // if we got this far we did not find the uart
    return nullptr;
}

// find_serial - searches available serial ports for the first instance that allows the given protocol
//  instance should be zero if searching for the first instance, 1 for the second, etc
//  returns uart on success, nullptr if a serial port cannot be found
AP_HAL::UARTDriver *AP_SerialManager::find_serial(enum SerialProtocol protocol, uint8_t instance) const
{
    const struct UARTState *_state = find_protocol_instance(protocol, instance);
    if (_state == nullptr) {
        return nullptr;
    }
    const uint8_t serial_idx = _state->idx;

    // set options before any user does begin()
    AP_HAL::UARTDriver *port = hal.serial(serial_idx);

#if AP_SERIALMANAGER_REGISTER_ENABLED
    if (port == nullptr) {
        // look for a registered port
        for (auto p = registered_ports; p; p = p->next) {
            if (p->state.idx == serial_idx) {
                port = p;
                break;
            }
        }
    }
#endif

    if (port) {
        port->set_options(_state->options);
    }
    return port;
}

// have_serial - return true if we have the given serial protocol configured
bool AP_SerialManager::have_serial(enum SerialProtocol protocol, uint8_t instance) const
{
    return find_protocol_instance(protocol, instance) != nullptr;
}

// find_baudrate - searches available serial ports for the first instance that allows the given protocol
//  instance should be zero if searching for the first instance, 1 for the second, etc
//  returns baudrate on success, 0 if a serial port cannot be found
uint32_t AP_SerialManager::find_baudrate(enum SerialProtocol protocol, uint8_t instance) const
{
    const struct UARTState *_state = find_protocol_instance(protocol, instance);
    if (_state == nullptr) {
        return 0;
    }
    return _state->baudrate();
}

// find_portnum - find port number (SERIALn index) for a protocol and instance, -1 for not found
int8_t AP_SerialManager::find_portnum(enum SerialProtocol protocol, uint8_t instance) const
{
    const struct UARTState *_state = find_protocol_instance(protocol, instance);
    if (_state == nullptr) {
        return -1;
    }
    return int8_t(_state->idx);
}

// get_serial_by_id - gets serial by serial id
AP_HAL::UARTDriver *AP_SerialManager::get_serial_by_id(uint8_t id)
{
    if (id < SERIALMANAGER_NUM_PORTS) {
        return hal.serial(id);
    }
#if AP_SERIALMANAGER_REGISTER_ENABLED
    for (auto p = registered_ports; p; p = p->next) {
        if (p->state.idx == id) {
            return (AP_HAL::UARTDriver *)p;
        }
    }
#endif
    return nullptr;
}

/*
  get a UARTState by index
*/
const AP_SerialManager::UARTState *AP_SerialManager::get_state_by_id(uint8_t id) const
{
    if (id < SERIALMANAGER_NUM_PORTS) {
        return &state[id];
    }
#if AP_SERIALMANAGER_REGISTER_ENABLED
    for (auto p = registered_ports; p; p = p->next) {
        if (p->state.idx == id) {
            return &p->state;
        }
    }
#endif
    return nullptr;
}

/*
 *  map from a 16 bit EEPROM baud rate to a real baud rate.  For
 *  stm32-based boards we can do 1.5MBit, although 921600 is more
 *  reliable.
 */
uint32_t AP_SerialManager::map_baudrate(int32_t rate)
{
    if (rate <= 0) {
        rate = 57;
    }
    switch (rate) {
    case 1:    return 1200;
    case 2:    return 2400;
    case 4:    return 4800;
    case 9:    return 9600;
    case 19:   return 19200;
    case 38:   return 38400;
    case 57:   return 57600;
    case 100:  return 100000;
    case 111:  return 111100;
    case 115:  return 115200;
    case 230:  return 230400;
    case 256:  return 256000;
    case 460:  return 460800;
    case 500:  return 500000;
    case 921:  return 921600;
    case 1500:  return 1500000;
    case 2000:  return 2000000;
    }

    if (rate > 2000) {
        // assume it is a direct baudrate. This allows for users to
        // set an exact baudrate as long as it is over 2000 baud
        return (uint32_t)rate;
    }

    // otherwise allow any other kbaud rate
    return rate*1000;
}

// protocol_match - returns true if the protocols match
bool AP_SerialManager::protocol_match(enum SerialProtocol protocol1, enum SerialProtocol protocol2) const
{
    // check for obvious match
    if (protocol1 == protocol2) {
        return true;
    }

    // mavlink match
    if (((protocol1 == SerialProtocol_MAVLink) || (protocol1 == SerialProtocol_MAVLink2) || (protocol1 == SerialProtocol_MAVLinkHL)) &&
        ((protocol2 == SerialProtocol_MAVLink) || (protocol2 == SerialProtocol_MAVLink2) || (protocol2 == SerialProtocol_MAVLinkHL))) {
        return true;
    }

    // gps match
    if (((protocol1 == SerialProtocol_GPS) || (protocol1 == SerialProtocol_GPS2)) &&
        ((protocol2 == SerialProtocol_GPS) || (protocol2 == SerialProtocol_GPS2))) {
        return true;
    }

    return false;
}

// setup any special options
void AP_SerialManager::set_options(uint16_t i)
{
    struct UARTState &opt = state[i];
    // pass through to HAL
    if (!hal.serial(i)->set_options(opt.options)) {
        DEV_PRINTF("Unable to setup options for Serial%u\n", i);
    }
}

// get the passthru ports if enabled
bool AP_SerialManager::get_passthru(AP_HAL::UARTDriver *&port1, AP_HAL::UARTDriver *&port2, uint8_t &timeout_s,
                                    uint32_t &baud1, uint32_t &baud2)
{
    if (passthru_port2 < 0 ||
        passthru_port1 < 0) {
        return false;
    }
    port1 = get_serial_by_id(passthru_port1);
    port2 = get_serial_by_id(passthru_port2);
    if (port1 == nullptr || port2 == nullptr) {
        return false;
    }
    const auto *state1 = get_state_by_id(passthru_port1);
    const auto *state2 = get_state_by_id(passthru_port2);
    if (!state1 || !state2) {
        return false;
    }
    baud1 = state1->baudrate();
    baud2 = state2->baudrate();
    timeout_s = MAX(passthru_timeout, 0);
    return true;
}

// disable passthru by settings SERIAL_PASS2 to -1
void AP_SerialManager::disable_passthru(void)
{
    passthru_port2.set_and_notify(-1);
}

// accessor for AP_Periph to set baudrate and type
void AP_SerialManager::set_protocol_and_baud(uint8_t sernum, enum SerialProtocol protocol, uint32_t baudrate)
{
    if (sernum < SERIALMANAGER_NUM_PORTS) {
        state[sernum].protocol.set(protocol);
        state[sernum].baud.set(baudrate);
    }
}

#if AP_SERIALMANAGER_REGISTER_ENABLED
/*
  register an external network port. It is up to the caller to use a unique id field
  using AP_SERIALMANAGER_NET_PORT_1 as the base id for NET_P1_*
 */
void AP_SerialManager::register_port(RegisteredPort *port)
{
    const auto idx = port->state.idx;
    WITH_SEMAPHORE(port_sem);
    /*
      maintain the list in ID order
     */
    if (registered_ports == nullptr ||
        registered_ports->state.idx >= idx) {
        port->next = registered_ports;
        registered_ports = port;
        return;
    }
    for (auto p = registered_ports; p; p = p->next) {
        if (p->next == nullptr || p->next->state.idx >= idx) {
            port->next = p->next;
            p->next = port;
            break;
        }
    }
}
#endif // AP_SERIALMANAGER_REGISTER_ENABLED

namespace AP {

AP_SerialManager &serialmanager()
{
    return *AP_SerialManager::get_singleton();
}

}

#endif  // AP_SERIALMANAGER_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  /*
   Please contribute your ideas! See https://ardupilot.org/dev for details

   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
/*
  SerialManager allows defining the protocol and baud rates for the available
  serial ports and provides helper functions so objects (like a gimbal) can
  find which serial port they should use
 */
#pragma once

#include "AP_SerialManager_config.h"

#if AP_SERIALMANAGER_ENABLED

#include <AP_Param/AP_Param.h>

class AP_SerialManager {
public:
    AP_SerialManager();

    /* Do not allow copies */
    CLASS_NO_COPY(AP_SerialManager);

    enum SerialProtocol {
        SerialProtocol_None = -1,
        SerialProtocol_Console = 0, // unused
        SerialProtocol_MAVLink = 1,
        SerialProtocol_MAVLink2 = 2,                 // do not use - use MAVLink and provide instance of 1
        SerialProtocol_FrSky_D = 3,                  // FrSky D protocol (D-receivers)
        SerialProtocol_FrSky_SPort = 4,              // FrSky SPort protocol (X-receivers)
        SerialProtocol_GPS = 5,
        SerialProtocol_GPS2 = 6,                     // do not use - use GPS and provide instance of 1
        SerialProtocol_AlexMos = 7,
        SerialProtocol_Gimbal = 8,                   // SToRM32, Siyi custom serial protocols
        SerialProtocol_Rangefinder = 9,
        SerialProtocol_FrSky_SPort_Passthrough = 10, // FrSky SPort Passthrough (OpenTX) protocol (X-receivers)
        SerialProtocol_Lidar360 = 11,                // Lightware SF40C, TeraRanger Tower or RPLidarA2
        SerialProtocol_Aerotenna_USD1      = 12, // USD1 support - deprecated, users should use Rangefinder
        SerialProtocol_Beacon = 13,
        SerialProtocol_Volz = 14,                    // Volz servo protocol
        SerialProtocol_Sbus1 = 15,
        SerialProtocol_ESCTelemetry = 16,
        SerialProtocol_Devo_Telem = 17,
        SerialProtocol_OpticalFlow = 18,
        SerialProtocol_Robotis = 19,
        SerialProtocol_NMEAOutput = 20,
        SerialProtocol_WindVane = 21,
        SerialProtocol_SLCAN = 22,
        SerialProtocol_RCIN = 23,
        SerialProtocol_EFI = 24,                   // EFI serial protocol
        SerialProtocol_LTM_Telem = 25,
        SerialProtocol_RunCam = 26,
        SerialProtocol_Hott = 27,
        SerialProtocol_Scripting = 28,
        SerialProtocol_CRSF = 29,
        SerialProtocol_Generator = 30,
        SerialProtocol_Winch = 31,
        SerialProtocol_MSP = 32,
        SerialProtocol_DJI_FPV = 33,
        SerialProtocol_AirSpeed = 34,
        SerialProtocol_ADSB = 35,
        SerialProtocol_AHRS = 36,
        SerialProtocol_SmartAudio = 37,
        SerialProtocol_FETtecOneWire = 38,
        SerialProtocol_Torqeedo = 39,
        SerialProtocol_AIS = 40,
        SerialProtocol_CoDevESC = 41,
        SerialProtocol_MSP_DisplayPort = 42,
        SerialProtocol_MAVLinkHL = 43,
        SerialProtocol_Tramp = 44,
        SerialProtocol_DDS_XRCE = 45,
        SerialProtocol_IMUOUT = 46,
        // Reserving Serial Protocol 47 for SerialProtocol_IQ
        SerialProtocol_PPP = 48,
        SerialProtocol_IBUS_Telem = 49,                // i-BUS telemetry data, ie via sensor port of FS-iA6B
        SerialProtocol_NumProtocols                    // must be the last value
    };

    // get singleton instance
    static AP_SerialManager *get_singleton(void) {
        return _singleton;
    }

    // init_console - initialise console at default baud rate
    void init_console();

    // init - initialise serial ports
    void init();

    // find_serial - searches available serial ports that allows the given protocol
    //  instance should be zero if searching for the first instance, 1 for the second, etc
    //  returns uart on success, nullptr if a serial port cannot be found
    // note that the SERIALn_OPTIONS are applied if the port is found
    AP_HAL::UARTDriver *find_serial(enum SerialProtocol protocol, uint8_t instance) const;

    // have_serial - return true if we have the corresponding serial protocol configured
    bool have_serial(enum SerialProtocol protocol, uint8_t instance) const;
    
    // find_baudrate - searches available serial ports for the first instance that allows the given protocol
    //  instance should be zero if searching for the first instance, 1 for the second, etc
    //  returns the baudrate of that protocol on success, 0 if a serial port cannot be found
    uint32_t find_baudrate(enum SerialProtocol protocol, uint8_t instance) const;

    // find_portnum - find port number (SERIALn index) for a protocol and instance, -1 for not found
    int8_t find_portnum(enum SerialProtocol protocol, uint8_t instance) const;

    // get the passthru ports if enabled
    bool get_passthru(AP_HAL::UARTDriver *&port1, AP_HAL::UARTDriver *&port2, uint8_t &timeout_s,
                      uint32_t &baud1, uint32_t &baud2);

    // disable passthru by settings SERIAL_PASS2 to -1
    void disable_passthru(void);

    // get Serial Port
    AP_HAL::UARTDriver *get_serial_by_id(uint8_t id);

    // accessors for AP_Periph to set baudrate and type
    void set_protocol_and_baud(uint8_t sernum, enum SerialProtocol protocol, uint32_t baudrate);

    static uint32_t map_baudrate(int32_t rate);

    // parameter var table
    static const struct AP_Param::GroupInfo var_info[];

    class UARTState {
        friend class AP_SerialManager;
    public:
        bool option_enabled(uint16_t option) const {
            return (options & option) == option;
        }
        // returns a baudrate such as 9600.  May map from a special
        // parameter value like "57" to "57600":
        uint32_t baudrate() const {
            return AP_SerialManager::map_baudrate(baud);
        }
        AP_SerialManager::SerialProtocol get_protocol() const {
            return AP_SerialManager::SerialProtocol(protocol.get());
        }
        AP_Int32 baud;
        AP_Int16 options;
        AP_Int8 protocol;

        // serial index number
        uint8_t idx;
    };

    // get a state from serial index
    const UARTState *get_state_by_id(uint8_t id) const;

    // search through managed serial connections looking for the
    // instance-nth UART which is running protocol protocol.
    // protocol_match is used to determine equivalence of one protocol
    // to another, e.g. MAVLink2 is considered MAVLink1 for finding
    // mavlink1 protocol instances.
    const UARTState *find_protocol_instance(enum SerialProtocol protocol,
                                            uint8_t instance) const;

#if AP_SERIALMANAGER_REGISTER_ENABLED
    /*
      a class for a externally registered port
      used by AP_Networking
     */
    class RegisteredPort : public AP_HAL::UARTDriver {
    public:
        RegisteredPort *next;
        UARTState state;
    };
    RegisteredPort *registered_ports;
    HAL_Semaphore port_sem;

    // register an externally managed port
    void register_port(RegisteredPort *port);

#endif // AP_SERIALMANAGER_REGISTER_ENABLED


private:
    static AP_SerialManager *_singleton;

    // array of uart info. See comment above about
    // SERIALMANAGER_MAX_PORTS
    UARTState state[SERIALMANAGER_MAX_PORTS];

    // pass-through serial support
    AP_Int8 passthru_port1;
    AP_Int8 passthru_port2;
    AP_Int8 passthru_timeout;

    // protocol_match - returns true if the protocols match
    bool protocol_match(enum SerialProtocol protocol1, enum SerialProtocol protocol2) const;

    // setup any special options
    void set_options(uint16_t i);

    bool init_console_done;
};

namespace AP {
    AP_SerialManager &serialmanager();
};

#endif  // AP_SERIALMANAGER_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              /*
   Please contribute your ideas! See https://ardupilot.org/dev for details

   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
/*
  SerialManager configuration defines
 */
#pragma once

#include <AP_HAL/AP_HAL.h>
#include <AP_Networking/AP_Networking_Config.h>
#include <AP_InertialSensor/AP_InertialSensor_config.h>

#ifdef HAL_UART_NUM_SERIAL_PORTS
#if HAL_UART_NUM_SERIAL_PORTS >= 4
#define SERIALMANAGER_NUM_PORTS HAL_UART_NUM_SERIAL_PORTS
#else
// we want a minimum of 4 as the default GPS port is SERIAL3
#define SERIALMANAGER_NUM_PORTS 4
#endif
#else
// assume max 8 ports
#define SERIALMANAGER_NUM_PORTS 8
#endif

#ifndef HAL_NUM_SERIAL_PORTS
#define HAL_NUM_SERIAL_PORTS SERIALMANAGER_NUM_PORTS
#endif

#ifndef AP_SERIALMANAGER_ENABLED
#define AP_SERIALMANAGER_ENABLED 1
#endif

/*
  array size for state[]. This needs to be at least
  SERIALMANAGER_NUM_PORTS, but we want it to be the same length on
  similar boards to get the ccache efficiency up. This wastes a small
  amount of memory, but makes a huge difference to the build times
 */
#if SERIALMANAGER_NUM_PORTS > 10 || SERIALMANAGER_NUM_PORTS < 5
#define SERIALMANAGER_MAX_PORTS SERIALMANAGER_NUM_PORTS
#else
#define SERIALMANAGER_MAX_PORTS 10
#endif


#ifndef AP_SERIALMANAGER_REGISTER_ENABLED
#define AP_SERIALMANAGER_REGISTER_ENABLED BOARD_FLASH_SIZE > 1024 && (AP_NETWORKING_ENABLED || HAL_ENABLE_DRONECAN_DRIVERS)
#endif

#ifndef AP_SERIALMANAGER_IMUOUT_ENABLED
#define AP_SERIALMANAGER_IMUOUT_ENABLED (CONFIG_HAL_BOARD == HAL_BOARD_SITL) && AP_INERTIALSENSOR_ENABLED
#endif

// serial ports registered by AP_Networking will use IDs starting at 21 for the first port
#define AP_SERIALMANAGER_NET_PORT_1         21 // NET_P1_*

// serial ports registered by AP_DroneCAN will use IDs starting at 41/51 for the first port
#define AP_SERIALMANAGER_CAN_D1_PORT_1         41 // CAN_D1_UC_S1_*
#define AP_SERIALMANAGER_CAN_D2_PORT_1         51 // CAN_D2_UC_S1_*

// serial device simulation ports registered by AP_Scripting will use IDs starting at 61 for the first port
#define AP_SERIALMANAGER_SCR_PORT_1         61 // SCR_SDEV1_*

 // console default baud rates and buffer sizes
#ifdef DEFAULT_SERIAL0_BAUD
#define AP_SERIALMANAGER_CONSOLE_BAUD          DEFAULT_SERIAL0_BAUD
#else
#define AP_SERIALMANAGER_CONSOLE_BAUD          115200
#endif
#define AP_SERIALMANAGER_CONSOLE_BUFSIZE_RX    128
#define AP_SERIALMANAGER_CONSOLE_BUFSIZE_TX    512

// mavlink default baud rates and buffer sizes
#define AP_SERIALMANAGER_MAVLINK_BAUD           57600
#define AP_SERIALMANAGER_MAVLINK_BUFSIZE_RX     128
#define AP_SERIALMANAGER_MAVLINK_BUFSIZE_TX     256

// LTM buffer sizes
#define AP_SERIALMANAGER_LTM_BUFSIZE_RX         0
#define AP_SERIALMANAGER_LTM_BUFSIZE_TX         32

// FrSky default baud rates, use default buffer sizes
#define AP_SERIALMANAGER_FRSKY_D_BAUD           9600
#define AP_SERIALMANAGER_FRSKY_SPORT_BAUD       57600
#define AP_SERIALMANAGER_FRSKY_BUFSIZE_RX       0
#define AP_SERIALMANAGER_FRSKY_BUFSIZE_TX       0

// GPS default baud rates and buffer sizes
// we need a 256 byte buffer for some GPS types (eg. UBLOX)
#define AP_SERIALMANAGER_GPS_BAUD               230400
#define AP_SERIALMANAGER_GPS_BUFSIZE_RX         256
#define AP_SERIALMANAGER_GPS_BUFSIZE_TX         16

// AlexMos Gimbal protocol default baud rates and buffer sizes
#define AP_SERIALMANAGER_ALEXMOS_BAUD           115200
#define AP_SERIALMANAGER_ALEXMOS_BUFSIZE_RX     128
#define AP_SERIALMANAGER_ALEXMOS_BUFSIZE_TX     128

#define AP_SERIALMANAGER_GIMBAL_BAUD            115200
#define AP_SERIALMANAGER_GIMBAL_BUFSIZE_RX      128
#define AP_SERIALMANAGER_GIMBAL_BUFSIZE_TX      128

#define AP_SERIALMANAGER_VOLZ_BAUD           115

#define AP_SERIALMANAGER_ROBOTIS_BUFSIZE_RX  128
#define AP_SERIALMANAGER_ROBOTIS_BUFSIZE_TX  128

// MegaSquirt EFI protocol
#define AP_SERIALMANAGER_EFI_MS_BAUD           115
#define AP_SERIALMANAGER_EFI_MS_BUFSIZE_RX     512
#define AP_SERIALMANAGER_EFI_MS_BUFSIZE_TX     16

// SBUS servo outputs
#define AP_SERIALMANAGER_SBUS1_BAUD           100000
#define AP_SERIALMANAGER_SBUS1_BUFSIZE_RX     16
#define AP_SERIALMANAGER_SBUS1_BUFSIZE_TX     32

#define AP_SERIALMANAGER_SLCAN_BAUD             115200
#define AP_SERIALMANAGER_SLCAN_BUFSIZE_RX       128
#define AP_SERIALMANAGER_SLCAN_BUFSIZE_TX       128

// MSP protocol default buffer sizes
#define AP_SERIALMANAGER_MSP_BUFSIZE_RX     128
#define AP_SERIALMANAGER_MSP_BUFSIZE_TX     256
#define AP_SERIALMANAGER_MSP_BAUD           115200

// IMU OUT protocol
#define AP_SERIALMANAGER_IMUOUT_BAUD           921600
#define AP_SERIALMANAGER_IMUOUT_BUFSIZE_RX     128
#define AP_SERIALMANAGER_IMUOUT_BUFSIZE_TX     2048

// PPP protocol
#define AP_SERIALMANAGER_PPP_BAUD           921600
#define AP_SERIALMANAGER_PPP_BUFSIZE_RX     4096
#define AP_SERIALMANAGER_PPP_BUFSIZE_TX     4096

#ifndef HAL_HAVE_SERIAL0
#define HAL_HAVE_SERIAL0 HAL_NUM_SERIAL_PORTS > 0
#endif
#ifndef HAL_HAVE_SERIAL1
#define HAL_HAVE_SERIAL1 HAL_NUM_SERIAL_PORTS > 1
#endif
#ifndef HAL_HAVE_SERIAL2
#define HAL_HAVE_SERIAL2 HAL_NUM_SERIAL_PORTS > 2
#endif
#ifndef HAL_HAVE_SERIAL3
#define HAL_HAVE_SERIAL3 HAL_NUM_SERIAL_PORTS > 3
#endif
#ifndef HAL_HAVE_SERIAL4
#define HAL_HAVE_SERIAL4 HAL_NUM_SERIAL_PORTS > 4
#endif
#ifndef HAL_HAVE_SERIAL5
#define HAL_HAVE_SERIAL5 HAL_NUM_SERIAL_PORTS > 5
#endif
#ifndef HAL_HAVE_SERIAL6
#define HAL_HAVE_SERIAL6 HAL_NUM_SERIAL_PORTS > 6
#endif
#ifndef HAL_HAVE_SERIAL7
#define HAL_HAVE_SERIAL7 HAL_NUM_SERIAL_PORTS > 7
#endif
#ifndef HAL_HAVE_SERIAL8
#define HAL_HAVE_SERIAL8 HAL_NUM_SERIAL_PORTS > 8
#endif
#ifndef HAL_HAVE_SERIAL9
#define HAL_HAVE_SERIAL9 HAL_NUM_SERIAL_PORTS > 9
#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             /*
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
/*
 *   AP_ServoRelayEvents - handle servo and relay MAVLink events
 */

#include "AP_ServoRelayEvents_config.h"

#if AP_SERVORELAYEVENTS_ENABLED

#include <AP_HAL/AP_HAL.h>
#include <AP_Common/AP_Common.h>
#include "AP_ServoRelayEvents.h"
#include <RC_Channel/RC_Channel.h>
#include <SRV_Channel/SRV_Channel.h>
#include <GCS_MAVLink/GCS.h>

extern const AP_HAL::HAL& hal;

bool AP_ServoRelayEvents::do_set_servo(uint8_t _channel, uint16_t pwm)
{
    SRV_Channel *c = SRV_Channels::srv_channel(_channel-1);
    if (c == nullptr) {
        return false;
    }
    switch(c->get_function())
    {
    case SRV_Channel::k_none:
    case SRV_Channel::k_manual:
    case SRV_Channel::k_sprayer_pump:
    case SRV_Channel::k_sprayer_spinner:
    case SRV_Channel::k_gripper:
    case SRV_Channel::k_rcin1 ... SRV_Channel::k_rcin16: // rc pass-thru
        break;
    case SRV_Channel::k_rcin1_mapped ... SRV_Channel::k_rcin16_mapped: {
        // mapped channels are set up with a -/+ 4500 angle range by
        // SRV_Channel::aux_servo_function_setup
        int16_t angle_scaled = constrain_uint16(pwm, 1000, 2000);
        angle_scaled = (angle_scaled - 1500) * 9; // 1000 ... 2000 -> -500 ... 500 -> -4500 ... 4500
        pwm = c->pwm_from_scaled_value(angle_scaled);
        break;
    }
    default:
        GCS_SEND_TEXT(MAV_SEVERITY_INFO, "ServoRelayEvent: Channel %d is already in use", _channel);
        return false;
    }
    if (type == EVENT_TYPE_SERVO && 
        channel == _channel) {
        // cancel previous repeat
        repeat = 0;
    }
    c->set_output_pwm(pwm);
    c->ignore_small_rcin_changes();
    return true;
}

#if AP_RELAY_ENABLED
bool AP_ServoRelayEvents::do_set_relay(uint8_t relay_num, uint8_t state)
{
    AP_Relay *relay = AP::relay();
    if (relay == nullptr) {
        return false;
    }

    if (!relay->enabled(relay_num)) {
        return false;
    }
    if (type == EVENT_TYPE_RELAY && 
        channel == relay_num) {
        // cancel previous repeat
        repeat = 0;
    }
    if (state == 1) {
        relay->on(relay_num);
    } else if (state == 0) {
        relay->off(relay_num);
    } else {
        relay->toggle(relay_num);
    }
    return true;
}
#endif

bool AP_ServoRelayEvents::do_repeat_servo(uint8_t _channel, uint16_t _servo_value, 
                                          int16_t _repeat, uint16_t _delay_ms)
{
    SRV_Channel *c = SRV_Channels::srv_channel(_channel-1);
    if (c == nullptr) {
        return false;
    }
    switch(c->get_function())
    {
    case SRV_Channel::k_none:
    case SRV_Channel::k_manual:
    case SRV_Channel::k_sprayer_pump:
    case SRV_Channel::k_sprayer_spinner:
    case SRV_Channel::k_gripper:
    case SRV_Channel::k_rcin1 ... SRV_Channel::k_rcin16: // rc pass-thru
        break;
    case SRV_Channel::k_rcin1_mapped ... SRV_Channel::k_rcin16_mapped: {
        // mapped channels are set up with a -/+ 4500 angle range by
        // SRV_Channel::aux_servo_function_setup
        int16_t angle_scaled = constrain_uint16(_servo_value, 1000, 2000);
        angle_scaled = (angle_scaled - 1500) * 9; // 1000 ... 2000 -> -500 ... 500 -> -4500 ... 4500
        _servo_value = c->pwm_from_scaled_value(angle_scaled);
        break;
    }
    default:
        GCS_SEND_TEXT(MAV_SEVERITY_INFO, "ServoRelayEvent: Channel %d is already in use", _channel);
        return false;
    }
    channel = _channel;
    type = EVENT_TYPE_SERVO;

    start_time_ms  = 0;
    delay_ms    = _delay_ms / 2;
    repeat      = _repeat * 2;
    servo_value = _servo_value;
    update_events();
    return true;
}

#if AP_RELAY_ENABLED
bool AP_ServoRelayEvents::do_repeat_relay(uint8_t relay_num, int16_t _repeat, uint32_t _delay_ms)
{
    AP_Relay *relay = AP::relay();
    if (relay == nullptr) {
        return false;
    }
    if (!relay->enabled(relay_num)) {
        return false;
    }
    type = EVENT_TYPE_RELAY;
    channel = relay_num;
    start_time_ms  = 0;
    delay_ms        = _delay_ms/2; // half cycle time
    repeat          = _repeat*2;  // number of full cycles
    update_events();
    return true;
}
#endif


/*
  update state for MAV_CMD_DO_REPEAT_SERVO and MAV_CMD_DO_REPEAT_RELAY
*/
void AP_ServoRelayEvents::update_events(void)
{
    if (repeat == 0 || (AP_HAL::millis() - start_time_ms) < delay_ms) {
        return;
    }

    start_time_ms = AP_HAL::millis();

    switch (type) {
    case EVENT_TYPE_SERVO: {
        SRV_Channel *c = SRV_Channels::srv_channel(channel-1);
        if (c != nullptr) {
            if (repeat & 1) {
                c->set_output_pwm(c->get_trim());
            } else {
                c->set_output_pwm(servo_value);
                c->ignore_small_rcin_changes();
            }
        }
        break;
    }

#if AP_RELAY_ENABLED
    case EVENT_TYPE_RELAY: {
        AP_Relay *relay = AP::relay();
        if (relay != nullptr) {
            relay->toggle(channel);
        }
        break;
    }
#endif
    }
    if (repeat > 0) {
        repeat--;
    } else {
        // toggle bottom bit so servos flip in value
        repeat ^= 1;
    }
}

// singleton instance
AP_ServoRelayEvents *AP_ServoRelayEvents::_singleton;

namespace AP {

AP_ServoRelayEvents *servorelayevents()
{
    return AP_ServoRelayEvents::get_singleton();
}

}

#endif  // AP_SERVORELAYEVENTS_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       /*
 * AP_ServoRelayEvent.h
 *
 * handle DO_SET_SERVO, DO_REPEAT_SERVO, DO_SET_RELAY and
 * DO_REPEAT_RELAY commands
 */
#pragma once

#include "AP_ServoRelayEvents_config.h"

#if AP_SERVORELAYEVENTS_ENABLED

#include <AP_Param/AP_Param.h>
#include <AP_Relay/AP_Relay.h>

class AP_ServoRelayEvents {
public:
    AP_ServoRelayEvents()
#if AP_RELAY_ENABLED
        : type(EVENT_TYPE_RELAY)
#endif
    {
        _singleton = this;
    }

    /* Do not allow copies */
    CLASS_NO_COPY(AP_ServoRelayEvents);

    // get singleton instance
    static AP_ServoRelayEvents *get_singleton() {
        return _singleton;
    }

    bool do_set_servo(uint8_t channel, uint16_t pwm);
#if AP_RELAY_ENABLED
    bool do_set_relay(uint8_t relay_num, uint8_t state);
#endif
    bool do_repeat_servo(uint8_t channel, uint16_t servo_value, int16_t repeat, uint16_t delay_time_ms);
    bool do_repeat_relay(uint8_t relay_num, int16_t count, uint32_t period_ms);
    void update_events(void);

private:

    static AP_ServoRelayEvents *_singleton;

    // event control state
    enum event_type { 
#if AP_RELAY_ENABLED
        EVENT_TYPE_RELAY=0,
#endif
        EVENT_TYPE_SERVO=1
    };

    enum event_type type;

	// when the event was started in ms
    uint32_t start_time_ms;

	// how long to delay the next firing of event in millis
    uint16_t delay_ms;

	// how many times to cycle : -1 (or -2) = forever, 2 = do one cycle, 4 = do two cycles
    int16_t repeat;

    // RC channel for servos, relay number for relays
    uint8_t channel;

	// PWM for servos
	uint16_t servo_value;
};

namespace AP {
    AP_ServoRelayEvents *servorelayevents();
};

#endif  // AP_SERVORELAYEVENTS_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  #pragma once

#include <AP_HAL/AP_HAL_Boards.h>

#ifndef AP_SERVORELAYEVENTS_ENABLED
#define AP_SERVORELAYEVENTS_ENABLED 1
#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              /*
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "AP_SmartRTL.h"

#include <AP_AHRS/AP_AHRS.h>
#include <AP_Logger/AP_Logger.h>
#include <GCS_MAVLink/GCS.h>

extern const AP_HAL::HAL& hal;

const AP_Param::GroupInfo AP_SmartRTL::var_info[] = {
    // @Param: ACCURACY
    // @DisplayName: SmartRTL accuracy
    // @Description: SmartRTL accuracy. The minimum distance between points.
    // @Units: m
    // @Range: 0 10
    // @User: Advanced
    AP_GROUPINFO("ACCURACY", 0, AP_SmartRTL, _accuracy, SMARTRTL_ACCURACY_DEFAULT),

    // @Param: POINTS
    // @DisplayName: SmartRTL maximum number of points on path
    // @Description: SmartRTL maximum number of points on path. Set to 0 to disable SmartRTL.  100 points consumes about 3k of memory.
    // @Range: 0 500
    // @User: Advanced
    // @RebootRequired: True
    AP_GROUPINFO("POINTS", 1, AP_SmartRTL, _points_max, SMARTRTL_POINTS_DEFAULT),

    // @Param: OPTIONS
    // @DisplayName: SmartRTL options
    // @Description: Bitmask of SmartRTL options.
    // @Bitmask: 2:Ignore pilot yaw
    // @User: Standard
    AP_GROUPINFO("OPTIONS", 2, AP_SmartRTL, _options, 0),

    AP_GROUPEND
};

/*
*    This library is used for the Safe Return-to-Launch feature. The vehicle's
*    position (aka "bread crumbs") are stored into an array in memory at
*    regular intervals.  After a certain number of bread crumbs have been
*    stored and space within the array is low, clean-up algorithms are run to
*    reduce the total number of points.  When Safe-RTL is initiated by the
*    vehicle code, a more thorough cleanup runs and the resulting path is fed
*    into navigation controller to return the vehicle to home.
*
*    The cleanup consists of two parts, pruning and simplification:
*
*    1. Pruning calculates the closest distance between two line segments formed
*    by two pairs of sequential points, and then cuts out anything between two
*    points when their line segments get close. This algorithm will never
*    compare two consecutive line segments. Obviously the segments (p1,p2) and
*    (p2,p3) will get very close (they touch), but there would be nothing to
*    trim between them.
*
*    2. Simplification uses the Ramer-Douglas-Peucker algorithm. See Wikipedia
*    for a more complete description.
*
*    The simplification and pruning algorithms run in the background and do not
*    alter the path in memory.  Two definitions, SMARTRTL_SIMPLIFY_TIME_US and
*    SMARTRTL_PRUNING_LOOP_TIME_US are used to limit how long each algorithm will
*    be run before they save their state and return.
*
*    Both algorithms are "anytime algorithms" meaning they can be interrupted
*    before they complete which is helpful when memory is filling up and we just
*    need to quickly identify a handful of points which can be deleted.
*
*    Once the algorithms have completed the simplify.complete and
*    prune.complete flags are set to true.  The "thorough cleanup" procedure,
*    which is run as the vehicle initiates the SmartRTL flight mode, waits for
*    these flags to become true.  This can force the vehicle to pause for a few
*    seconds before initiating the return journey.
*/

AP_SmartRTL::AP_SmartRTL(bool example_mode) :
    _example_mode(example_mode)
{
    AP_Param::setup_object_defaults(this, var_info);
    _simplify.bitmask.setall();
}

// initialise safe rtl including setting up background processes
void AP_SmartRTL::init()
{
    // protect against repeated call to init
    if (_path != nullptr) {
        return;
    }

    // constrain the path length, in case the user decided to make the path unreasonably long.
    _points_max.set(constrain_int16(_points_max, 0, SMARTRTL_POINTS_MAX));

    // check if user has disabled SmartRTL
    if (_points_max == 0 || !is_positive(_accuracy)) {
        return;
    }

    // allocate arrays
    _path = (Vector3f*)calloc(_points_max, sizeof(Vector3f));

    _prune.loops_max = _points_max * SMARTRTL_PRUNING_LOOP_BUFFER_LEN_MULT;
    _prune.loops = (prune_loop_t*)calloc(_prune.loops_max, sizeof(prune_loop_t));

    _simplify.stack_max = _points_max * SMARTRTL_SIMPLIFY_STACK_LEN_MULT;
    _simplify.stack = (simplify_start_finish_t*)calloc(_simplify.stack_max, sizeof(simplify_start_finish_t));

    // check if memory allocation failed
    if (_path == nullptr || _prune.loops == nullptr || _simplify.stack == nullptr) {
        log_action(Action::DEACTIVATED_INIT_FAILED);
        GCS_SEND_TEXT(MAV_SEVERITY_WARNING, "SmartRTL deactivated: init failed");
        free(_path);
        free(_prune.loops);
        free(_simplify.stack);
        return;
    }

    _path_points_max = _points_max;

    // when running the example sketch, we want the cleanup tasks to run when we tell them to, not in the background (so that they can be timed.)
    if (!_example_mode){
        // register background cleanup to run in IO thread
        hal.scheduler->register_io_process(FUNCTOR_BIND_MEMBER(&AP_SmartRTL::run_background_cleanup, void));
    }
}

// returns number of points on the path
uint16_t AP_SmartRTL::get_num_points() const
{
    return _path_points_count;
}

// get next point on the path to home, returns true on success
bool AP_SmartRTL::pop_point(Vector3f& point)
{
    // check we are active
    if (!_active) {
        return false;
    }

    // get semaphore
    if (!_path_sem.take_nonblocking()) {
        log_action(Action::POP_FAILED_NO_SEMAPHORE);
        return false;
    }

    // check we have another point
    if (_path_points_count == 0) {
        _path_sem.give();
        return false;
    }

    // return last point and remove from path
    point = _path[--_path_points_count];

    // record count of last point popped
    _path_points_completed_limit = _path_points_count;

    _path_sem.give();
    return true;
}

// peek at next point on the path without removing it form the path. Returns true on success
bool AP_SmartRTL::peek_point(Vector3f& point)
{
    // check we are active
    if (!_active) {
        return false;
    }

    // get semaphore
    if (!_path_sem.take_nonblocking()) {
        log_action(Action::PEEK_FAILED_NO_SEMAPHORE);
        return false;
    }

    // check we have another point
    if (_path_points_count == 0) {
        _path_sem.give();
        return false;
    }

    // return last point
    point = _path[_path_points_count-1];

    _path_sem.give();
    return true;
}

// clear return path and set home location.  This should be called as part of the arming procedure
void AP_SmartRTL::set_home(bool position_ok)
{
    Vector3f current_pos;
    position_ok &= AP::ahrs().get_relative_position_NED_origin(current_pos);
    set_home(position_ok, current_pos);
}

void AP_SmartRTL::set_home(bool position_ok, const Vector3f& current_pos)
{
    if (_path == nullptr) {
        return;
    }

    // clear path
    _path_points_count = 0;

    // reset simplification and pruning.  These functions access members that should normally only
    // be touched by the background thread but it will not be running because active should be false
    reset_simplification();
    reset_pruning();

    // don't continue if no position at take-off
    if (!position_ok) {
        return;
    }

    // save current position as first point in path
    if (!add_point(current_pos)) {
        return;
    }

    // successfully added point and reset path
    const uint32_t now = AP_HAL::millis();
    _last_good_position_ms = now;
    _last_position_save_ms = now;
    _active = true;
    _home_saved = true;
}

// call this at 3hz (or higher) regardless of what mode the vehicle is in
void AP_SmartRTL::update(bool position_ok, bool save_position)
{
    // try to save home if not already saved
    if (position_ok && !_home_saved) {
        set_home(true);
    }

    if (!_active || !save_position) {
        return;
    }

    Vector3f current_pos;
    position_ok &= AP::ahrs().get_relative_position_NED_origin(current_pos);
    update(position_ok, current_pos);
}

void AP_SmartRTL::update(bool position_ok, const Vector3f& current_pos)
{
    if (!_active) {
        return;
    }

    if (position_ok) {
        const uint32_t now = AP_HAL::millis();
        _last_good_position_ms = now;
        // add the point
        if (add_point(current_pos)) {
            _last_position_save_ms = now;
        } else if (AP_HAL::millis() - _last_position_save_ms > SMARTRTL_TIMEOUT) {
            // deactivate after timeout due to failure to save points to path (most likely due to buffer filling up)
            deactivate(Action::DEACTIVATED_PATH_FULL_TIMEOUT, "buffer full");
        }
    } else {
        // check for timeout due to bad position
        if (AP_HAL::millis() - _last_good_position_ms > SMARTRTL_TIMEOUT) {
            deactivate(Action::DEACTIVATED_BAD_POSITION_TIMEOUT, "bad position");
            return;
        }
    }
}

// request thorough cleanup including simplification, pruning and removal of all unnecessary points
// returns true if the thorough cleanup was completed, false if it has not yet completed
// this method should be called repeatedly until it returns true before initiating the return journey
bool AP_SmartRTL::request_thorough_cleanup(ThoroughCleanupType clean_type)
{
    // this should never happen but just in case
    if (!_active) {
        return false;
    }

    // request thorough cleanup
    if (_thorough_clean_request_ms == 0) {
        _thorough_clean_request_ms = AP_HAL::millis();
        if (clean_type != THOROUGH_CLEAN_DEFAULT) {
            _thorough_clean_type = clean_type;
        }
        return false;
    }

    // check if background thread has completed request
    if (_thorough_clean_complete_ms == _thorough_clean_request_ms) {
        _thorough_clean_request_ms = 0;
        return true;
    }

    return false;
}

// cancel request for thorough cleanup
void AP_SmartRTL::cancel_request_for_thorough_cleanup()
{
    _thorough_clean_request_ms = 0;
}

//
// Private methods
//

// add point to end of path (if necessary), returns true on success
bool AP_SmartRTL::add_point(const Vector3f& point)
{
    // get semaphore
    if (!_path_sem.take_nonblocking()) {
        log_action(Action::ADD_FAILED_NO_SEMAPHORE, point);
        return false;
    }

    // check if we have traveled far enough
    if (_path_points_count > 0) {
        const Vector3f& last_pos = _path[_path_points_count-1];
        if (last_pos.distance_squared(point) < sq(_accuracy.get())) {
            _path_sem.give();
            return true;
        }
    }

    // check we have space in the path
    if (_path_points_count >= _path_points_max) {
        _path_sem.give();
        log_action(Action::ADD_FAILED_PATH_FULL, point);
        return false;
    }

    // add point to path
    _path[_path_points_count++] = point;
    log_action(Action::POINT_ADD, point);

    _path_sem.give();
    return true;
}

// run background cleanup - should be run regularly from the IO thread
void AP_SmartRTL::run_background_cleanup()
{
    if (!_active) {
        return;
    }

    // get semaphore
    if (!_path_sem.take_nonblocking()) {
        return;
    }
    // local copy of _path_points_count and _path_points_completed_limit
    const uint16_t path_points_count = _path_points_count;
    const uint16_t path_points_completed_limit = _path_points_completed_limit;
    _path_points_completed_limit = SMARTRTL_POINTS_MAX;
    _path_sem.give();

    // check if thorough cleanup is required
    if (_thorough_clean_request_ms > 0) {
        // check if we have already completed the request
        if (_thorough_clean_complete_ms != _thorough_clean_request_ms) {
            if (thorough_cleanup(path_points_count, _thorough_clean_type)) {
                // record completion
                _thorough_clean_complete_ms = _thorough_clean_request_ms;
            }
        }
        // we do not perform any further detection or cleanup until the requester acknowledges
        // they have what they need by setting _thorough_clean_request_ms back to zero
        return;
    }

    // ensure clean complete time is zero
    _thorough_clean_complete_ms = 0;

    // perform routine cleanup which removes 10 to 50 points if possible
    routine_cleanup(path_points_count, path_points_completed_limit);

    // warn if buffer is about to be filled
    uint32_t now_ms = AP_HAL::millis();
    if ((path_points_count >0) && (path_points_count >= _path_points_max - 9) && (now_ms - _last_low_space_notify_ms > 10000)) {
        GCS_SEND_TEXT(MAV_SEVERITY_INFO, "SmartRTL Low on space!");
       _last_low_space_notify_ms = now_ms;
    }

}

// routine cleanup is called regularly from run_background_cleanup
//   simplifies the path after SMARTRTL_CLEANUP_POINT_TRIGGER points (50 points) have been added OR
//   SMARTRTL_CLEANUP_POINT_MIN (10 points) have been added and the path has less than SMARTRTL_CLEANUP_START_MARGIN spaces (10 spaces) remaining
//   prunes the path if the path has less than SMARTRTL_CLEANUP_START_MARGIN spaces (10 spaces) remaining
void AP_SmartRTL::routine_cleanup(uint16_t path_points_count, uint16_t path_points_completed_limit)
{
    // if simplify is running, let it run to completion
    if (!_simplify.complete) {
        detect_simplifications();
        return;
    }

    // remove simplified from path if required
    if (_simplify.removal_required) {
        remove_points_by_simplify_bitmask();
        return;
    }

    // if necessary restart detect_pruning up to last point simplified
    if (_prune.complete) {
        restart_pruning_if_new_points();
    }
    // if pruning is running, let it run to completion
    if (!_prune.complete) {
        detect_loops();
        return;
    }

    // detect path shrinkage and reduce simplify and prune path_points_completed count
    if (_simplify.path_points_completed > path_points_completed_limit) {
        _simplify.path_points_completed = path_points_completed_limit;
    }
    if (_prune.path_points_completed > path_points_completed_limit) {
        _prune.path_points_completed = path_points_completed_limit;
    }

    // calculate the number of points we could simplify
    const uint16_t points_to_simplify = (path_points_count > _simplify.path_points_completed) ? (path_points_count - _simplify.path_points_completed) : 0 ;
    const bool low_on_space = (_path_points_max - path_points_count) <= SMARTRTL_CLEANUP_START_MARGIN;

    // if 50 points can be simplified or we are low on space and at least 10 points can be simplified
    if ((points_to_simplify >= SMARTRTL_CLEANUP_POINT_TRIGGER) || (low_on_space && (points_to_simplify >= SMARTRTL_CLEANUP_POINT_MIN))) {
        restart_simplification(path_points_count);
        return;
    }

    // we are low on space, prune
    if (low_on_space) {
        // remove at least 10 points
        remove_points_by_loops(SMARTRTL_CLEANUP_POINT_MIN);
    }
}

// thorough cleanup simplifies and prunes all loops.  returns true if the cleanup was completed.
// path_points_count is _path_points_count but passed in to avoid having to take the semaphore
bool AP_SmartRTL::thorough_cleanup(uint16_t path_points_count, ThoroughCleanupType clean_type)
{
    if (clean_type != THOROUGH_CLEAN_PRUNE_ONLY) {
        // restart simplify if new points have appeared on path
        if (_simplify.complete) {
            restart_simplify_if_new_points(path_points_count);
        }
        // if simplification is not complete, run it
        if (!_simplify.complete) {
            detect_simplifications();
            return false;
        }
        // remove simplified points from path if required
        if (_simplify.removal_required) {
            remove_points_by_simplify_bitmask();
            return false;
        }
    }

    if (clean_type != THOROUGH_CLEAN_SIM1127 -0.01095992 0.002973198 -0.1237286 -0.007652163 0.00171864 -0.1234138 -0.005327284 0.001510858 -0.1236679 -0.007199466 0.001694798 -0.1149224 -0.009205102 0.002388536 -0.1315962 0.00310254 5.09908e-5 -0.127531 -0.004275679 0.001109898 -0.1262113 9.17713e-4 5.68245e-4 -0.1294583 -0.003450036 9.1258e-4 -0.127928 0.001220107 4.63631e-4 -0.131183 -0.00233066 7.14242e-4 -0.1295163 0.001663327 3.54694e-4 -0.132411 -7.98636e-4 4.70449e-4 -0.1290518 -0.005832254 0.001121401 -0.1300889 -0.005387425 0.001011312 -0.1300824 -0.005366504 0.001016438 -0.1317074 -0.003592133 7.92748e-4 -0.1299397 -0.004925072 0.001014471 -0.1300552 -0.005281448 0.001022279 -0.1279458 -0.005916297 0.001237452 -0.1329172 -0.001782476 5.23021e-4 -0.1311475 0.005318522 -2.04695e-4 -0.1303788 0.005768775 -2.41608e-4 -0.127323 0.006900131 -2.61186e-4 -0.1299774 0.005843579 -2.1668e-4 -0.1291904 0.005423545 -1.0857e-4 -0.1303656 0.005188584 -1.37799e-4 -0.1314381 0.004904747 -1.55519e-4 -0.1214557 0.008929967 -5.32167e-4 -0.1214548 0.00893563 -5.3736e-4 -0.1214544 0.00893712 -5.41952e-4 -0.1156352 0.01013928 -7.30673e-4 -0.1098158 0.01133984 -9.13249e-4 -0.1098159 0.01134026 -9.14303e-4 -0.1098162 0.01134145 -9.1744e-4 -0.1098162 0.01134139 -9.19384e-4 -0.1098157 0.01133954 -9.12974e-4 -0.109815 0.01133519 -9.08841e-4 -0.1098141 0.01133036 -9.04205e-4 -0.1214594 0.008905649 -5.19941e-4 -0.1098042 0.01127415 -8.76882e-4 -0.1098111 0.01131379 -8.96145e-4 -0.1298838 0.006000161 -2.43876e-4 -0.1271965 0.007199347 -3.17707e-4 -0.1094525 0.00917679 -3.87582e-4 -0.1096814 0.01054573 -6.84778e-4 -0.1215363 0.008359432 -3.91598e-4 -0.1097112 0.01072341 -7.23355e-4 -0.1248897 0.006098926 -7.54767e-5 -0.1278486 0.005648732 -8.72775e-5 -0.1308016 0.002315998 2.14288e-4 -0.1328251 0.001011908 1.93665e-4 -0.1081653 0.001439154 0.001043975 -0.1314374 0.004903137 -1.83875e-4 -0.1214547 0.008934915 -5.41202e-4 -0.1278468 0.005639255 -1.86046e-4 -0.1214736 0.008798718 -5.17235e-4 -0.1215348 0.008351683 -4.54633e-4 -0.1273221 0.006895899 -3.06772e-4 -0.109816 0.01134043 -9.1838e-4 -0.1098157 0.01133882 -9.17682e-4 -0.1098156 0.01133799 -9.173e-4 -0.1098143 0.01133036 -9.15677e-4 -0.1098117 0.01131474 -9.12348e-4 -0.1214591 0.00890398 -5.34046e-4 -0.1098085 0.01129543 -9.0824e-4 -0.1097977 0.01123094 -8.94497e-4 -0.1217898 0.006488084 -2.12388e-4 -0.1248869 0.006085634 -1.97796e-4 -0.1268981 0.007391154 -3.60133e-4 -0.1268113 0.007424414 -3.62866e-4 -0.1264634 0.007554113 -3.73878e-4 -0.1257619 0.007798373 -3.96373e-4 -0.1269846 0.007357597 -3.57408e-4 -0.126963 0.007366001 -3.58088e-4 -0.1243094 0.008123695 -4.46968e-4 -0.1214556 0.008929133 -5.39067e-4 -0.1271591 0.007285416 -3.50925e-4 -0.1271663 0.007268428 -3.48036e-4 -0.1296899 0.006132721 -2.67826e-4 -0.1297724 0.006090164 -2.64771e-4 -0.1298401 0.006018161 -2.59803e-4 -0.1298341 0.006058096 -2.62462e-4 -0.1298136 0.006068825 -2.63233e-4 -0.1295245 0.006217062 -2.73863e-4 -0.1291922 0.006382942 -2.85659e-4 -0.1299763 0.005841314 -2.42175e-4 -0.1271961 0.00719738 -3.38965e-4 -0.1097898 0.01118403 -8.84502e-4 -0.1291878 0.005415737 -1.88481e-4 -0.1269413 0.007374405 -3.5877e-4 -0.1269522 0.007370233 -3.58429e-4 -0.1285219 0.006702601 -3.08366e-4 -0.1271569 0.007283091 -3.51283e-4 -0.1098151 0.01133507 -9.1668e-4 -0.1303634 0.005183577 -1.93042e-4 -0.1298444 0.006052732 -2.62075e-4 -0.1097842 0.01115036 -8.7841e-4 -0.05850678 -0.01101976 0.003883063 -0.05922901 -0.007878422 0.003110408 -0.07113158 -0.008171021 0.003040254 -0.02050727 -0.004389166 0.001948058 -0.02293896 -0.004521906 0.001990318 -0.02476084 -0.008209526 0.003911972 -0.02606791 -0.004267156 0.001982688 -0.03151756 -0.003823399 0.001969337 -0.03034502 -0.008390069 0.004205107 -0.03167986 -0.003798544 0.001963078 -0.03612577 -0.008373975 0.004178285 -0.03752607 -0.002903699 0.001735866 -0.04435956 -0.001857697 0.001470386 -0.04769283 -0.007968127 0.003481805 -0.04928094 -0.001175343 0.001248478 -0.05347597 -0.007827222 0.003210663 -0.05516004 -3.6021e-4 9.83398e-4 -0.05539411 -3.27752e-4 9.72843e-4 -0.04710984 -0.01063972 0.00422132 -0.03568542 -0.01032513 0.00473833 -0.02990061 -0.01054453 0.004695355 -0.02988475 -0.01073819 0.004665791 -0.0243026 -0.01010322 0.004165589 -0.01881307 -0.009110033 0.003466546 -0.02440154 -0.009521782 0.004238188 -0.02432006 -0.009948313 0.004217028 -0.01879066 -0.009228348 0.003395318 -0.02998107 -0.01001286 0.004663765 -0.03556555 -0.01097315 0.004823386 -0.03553074 -0.01121079 0.004819571 -0.1008777 -0.007491469 0.002632617 -0.09494322 -0.007854104 0.002746939 -0.08304405 -0.008169531 0.002887904 -0.01925259 -0.007700443 0.003415107 -0.01890021 -0.008773744 0.003546833 -0.1009799 -2.5452e-4 0.001399219 -0.09622991 -2.23444e-4 0.001362562 -0.08450847 -1.46759e-4 0.001272141 -0.0727753 -6.99954e-5 0.001181602 -0.06774395 -3.70787e-5 0.001142799 -0.0610463 -1.94718e-4 0.001050591 0.08799529 -0.004192054 6.64969e-4 0.01241469 0.00205177 0.001057565 0.09380561 -0.004077136 7.0878e-4 0.01230382 0.002047419 0.001060724 0.05972647 -0.00470674 1.43614e-4 0.064713 -0.004618167 2.50624e-4 0.07635879 -0.00441116 5.00542e-4 0.08186793 -0.00431323 6.18767e-4 0.01790672 0.001579761 8.26196e-4 0.02051836 0.00135529 7.16144e-4 0.02349424 7.13727e-4 6.2306e-4 0.02934223 -5.47026e-4 4.40139e-4 0.0408411 -0.003026008 8.04639e-5 0.04115468 -0.003074645 7.17281e-5 0.04712766 -0.00400108 -9.46657e-5 0.04952126 -0.004372298 -1.61346e-4 0.05306774 -0.004488527 -5.53671e-5 0.05888688 -0.004679262 1.18524e-4 0.01420485 -0.001952648 -0.002488613 0.0838629 -0.0137189 -0.001563966 0.08957314 -0.01332777 -0.001338303 0.08957368 -0.01335728 -0.001315236 0.09527814 -0.01291978 -0.001083791 0.09526115 -0.0128231 -0.001044094 0.08955109 -0.01323968 -0.001251339 0.09519028 -0.01240789 -9.2445e-4 0.05352795 -0.01388257 -0.003317117 0.05377668 -0.01389509 -0.003300607 0.0522632 -0.01364916 -0.003393352 0.05529218 -0.01397103 -0.003200054 0.04333198 -0.01167613 -0.003912985 0.04478287 -0.01216286 -0.003838121 0.04550957 -0.01238852 -0.003758788 0.04548138 -0.01239722 -0.003802061 0.04625821 -0.01254063 -0.003755211 0.04919797 -0.01309949 -0.003454864 0.05076372 -0.01337236 -0.003483712 0.05526483 -0.01387554 -0.003140389 0.05151247 -0.01351058 -0.003438591 0.05188751 -0.01357978 -0.003416001 0.04776012 -0.01281791 -0.003664731 0.04926335 -0.01309537 -0.003574132 0.0432763 -0.01172918 -0.003836989 0.03752791 -0.009728848 -0.004212498 0.03747636 -0.009711682 -0.004093825 0.03637355 -0.009341537 -0.004272043 0.03174442 -0.007498264 -0.004311859 0.03179633 -0.007568299 -0.004457533 0.02661526 -0.005561053 -0.00466746 0.02324575 -0.004250586 -0.00462383 0.02608478 -0.005354762 -0.004660606 0.02593082 -0.005166172 -0.004270672 0.03167527 -0.007373094 -0.004119217 0.03742414 -0.009586215 -0.003942072 0.04323863 -0.01161295 -0.003726959 0.02004206 -0.002771914 -0.003537297 0.01713454 -0.002245664 -0.003089487 0.01746511 -0.002807736 -0.003972351 0.01451581 -0.002484798 -0.003393948 0.01439183 -0.002257227 -0.002980113 0.01574701 -0.00251621 -0.003680408 0.020406 -0.003306686 -0.004472136 0.02113801 -0.003430902 -0.004596531 0.02288001 -0.003667831 -0.003740489 0.03017842 -0.003087162 -8.57812e-4 0.04265552 -0.009365439 -0.002518534 0.04196399 -0.006517827 -0.001287877 0.04865282 -0.0108124 -0.002472579 0.01367068 -9.31912e-4 -0.00132364 0.01656955 -0.001188039 -0.001810193 0.0194385 -0.001654565 -0.002186954 0.02224576 -0.002447724 -0.002367258 0.02508431 -0.003442108 -0.002376854 0.03092426 -0.005394756 -0.002383053 0.09489178 -0.01063388 -5.19804e-4 0.07767677 -0.01153492 -0.001079261 0.06619131 -0.01189213 -0.00158596 0.06044232 -0.01187402 -0.001891255 0.08915591 -0.01096463 -6.8147e-4 0.09528261 -0.01293987 -0.001104176 0.09528309 -0.01293671 -0.001112639 0.09570837 -0.01290762 -0.001095831 0.09528237 -0.01294225 -0.001098811 0.0895738 -0.01336306 -0.001310765 0.07814878 -0.01395231 -0.001859724 0.0810061 -0.01384371 -0.001708209 0.07814908 -0.01403623 -0.001815736 0.08333015 -0.01375538 -0.001585006 0.08386266 -0.01372218 -0.001554846 0.08947515 -0.0128085 -0.001121282 0.07803833 -0.013466 -0.001590311 0.08956933 -0.01333987 -0.001294434 0.07812386 -0.01391631 -0.001741945 0.06659609 -0.01385432 -0.002178668 0.07814913 -0.01404422 -0.001811563 0.07814419 -0.01402044 -0.001792371 0.06671404 -0.01441472 -0.002411603 0.06669151 -0.01431018 -0.002353727 0.06098157 -0.01417064 -0.002763271 0.0638597 -0.01445162 -0.002623558 0.06493985 -0.01445436 -0.002560019 0.06671953 -0.01443004 -0.002438426 0.06671977 -0.01438671 -0.002465665 0.06671947 -0.01443821 -0.002433538 0.06100851 -0.01425743 -0.002820849 0.06086874 -0.01381957 -0.002524197 0.05514776 -0.01350164 -0.002900481 0.04908949 -0.01266157 -0.003226995 0.04311305 -0.01116412 -0.003427624 0.03726989 -0.00913763 -0.003553748 0.0257073 -0.004789233 -0.003739118 0.03148752 -0.0069471 -0.00364536 0.05469924 -0.01160496 -0.00223118 0.08955407 -0.01324421 -0.001294434 0.07812672 -0.01391357 -0.001796722 0.08386176 -0.01371467 -0.001558482 0.01455819 -0.002444207 -0.003550529 0.03467786 -0.008692324 -0.00443989 0.03183054 -0.007588922 -0.004583477 0.03184264 -0.007582485 -0.004630506 0.04330468 -0.01177304 -0.003936886 0.04040026 -0.01082658 -0.004117667 0.04039931 -0.01082855 -0.004112303 0.03752708 -0.009786963 -0.004270493 0.04477137 -0.01219135 -0.003863215 0.04477185 -0.01220047 -0.0038594 0.04330319 -0.01175773 -0.003956258 0.04330182 -0.01174283 -0.003959894 0.04476791 -0.01216202 -0.003867447 0.04040187 -0.01081544 -0.004132091 0.04040098 -0.01082372 -0.004122793 0.03753042 -0.009784579 -0.004285931 0.03469222 -0.008579313 -0.004560232 0.0318607 -0.00749439 -0.004741311 0.03186058 -0.007442355 -0.004767894 0.04039436 -0.01072162 -0.004161536 0.04328787 -0.01164597 -0.003962755 0.04329651 -0.01170194 -0.003963708 0.0375207 -0.009579837 -0.004375278 0.04327577 -0.01157468 -0.003957033 0.03752899 -0.009647309 -0.004367113 0.04623645 -0.01249146 -0.003769516 0.02621042 -0.005246996 -0.00508368 0.02340036 -0.004116237 -0.005104362 0.02620238 -0.005289554 -0.005043268 0.02050435 -0.003257572 -0.0048846 0.02613931 -0.005364596 -0.004825532 0.02337187 -0.004169464 -0.004996955 0.0261771 -0.005346536 -0.004945516 0.02619129 -0.005322813 -0.004997193 0.03185778 -0.007535159 -0.004709482 0.0346933 -0.008626043 -0.004537522 0.03753405 -0.00970149 -0.004354 0.0145992 -0.002412259 -0.00381422 0.04918479 -0.01295781 -0.003535985 0.04040199 -0.01080369 -0.004140317 0.03753471 -0.009770035 -0.00431329 0.04040127 -0.01078844 -0.00414735 0.03753572 -0.009757816 -0.004325211 0.04039978 -0.01076972 -0.004153251 0.03753596 -0.009742379 -0.004335999 0.03469121 -0.008660435 -0.004509806 0.034689 -0.008673012 -0.00449413 0.03468602 -0.008682489 -0.004477202 0.03753292 -0.009778916 -0.004300177 0.04330378 -0.01176893 -0.003951549 0.05539196 -0.01375776 -0.003111958 0.05521827 -0.01374751 -0.003116965 0.0455085 -0.01240509 -0.003803789 0.04477292 -0.01220053 -0.003852546 0.04477155 -0.01220589 -0.003854513 0.04330253 -0.01178061 -0.003938674 0.04330354 -0.01177656 -0.003945648 0.03753757 -0.009777069 -0.004243373 0.03752303 -0.009786188 -0.004254043 0.04039686 -0.01083004 -0.004100799 0.04330378 -0.01177322 -0.003948748 0.03185176 -0.007564544 -0.004672527 0.02045881 -0.003254473 -0.004681289 0.01751309 -0.002723991 -0.004212915 0.01754295 -0.002713859 -0.004356205 0.01458483 -0.002442061 -0.003692269 0.0233305 -0.004187524 -0.00486648 0.02049458 -0.003238499 -0.004820466 0.01755446 -0.002679288 -0.004475653 0.0318154 -0.007583975 -0.004531562 0.04184693 -0.01128756 -0.00405097 0.04184758 -0.01130086 -0.004045069 0.0418474 -0.01131057 -0.004038095 0.04184705 -0.01131409 -0.004034221 0.04184645 -0.01131677 -0.004029989 0.09526383 -0.01282978 -0.001082599 0.09527891 -0.01291978 -0.001101851 0.060997 -0.01420575 -0.002808272 0.06669425 -0.01429855 -0.002419114 -0.007458627 -0.002181291 -0.004976391 -0.004428684 -0.003930628 -0.004976391 -0.001398682 -0.002181291 -0.004976391 -0.001398682 0.001317322 -0.004976391 -0.004428684 0.003066718 -0.004976391 -0.007458627 0.001317322 -0.004976391 -0.003129601 3.18027e-4 0.005023539 -0.003678679 8.67064e-4 0.005023539 -0.004428684 0.001067996 0.005023539 -0.005178689 8.67064e-4 0.005023539 -0.005727708 3.18027e-4 0.005023539 -0.005928635 -4.31974e-4 0.005023539 -0.005727708 -0.00118196 0.005023539 -0.005178689 -0.001730978 0.005023539 -0.004428684 -0.001931965 0.005023539 -0.003678679 -0.001730978 0.005023539 -0.003129601 -0.00118196 0.005023539 -0.002928674 -4.31974e-4 0.005023539 -0.005178689 -0.001730978 -0.002355098 -0.004428684 -0.003815174 -0.002355098 -0.005727708 -0.00118196 -0.002355098 -0.00735861 -0.002123534 -0.002355098 -0.001498699 0.001259624 -0.002355098 -0.001498699 -0.002123534 -0.002355098 -0.002928674 -4.31974e-4 -0.002355098 -0.00735861 0.001259624 -0.002355098 -0.005727708 3.18027e-4 -0.002355098 -0.005928635 -4.31974e-4 -0.002355098 -0.003129601 3.18027e-4 -0.002355098 -0.003678679 8.67064e-4 -0.002355098 -0.004428684 0.002951204 -0.002355098 -0.004428684 0.001067996 -0.002355098 -0.005178689 8.67064e-4 -0.002355098 -0.004428684 -0.001931965 -0.002355098 -0.003678679 -0.001730978 -0.002355098 -0.003129601 -0.00118196 -0.002355098 -0.001498699 -0.002123534 -0.004876375 -0.001498699 0.001259624 -0.004876375 -0.004428684 0.002951204 -0.004876375 -0.00735861 0.001259624 -0.004876375 -0.00735861 -0.002123534 -0.004876375 -0.004428684 -0.003815174 -0.004876375 -0.001491069 0.001264035 -0.004914641 -0.001483857 -0.002132117 -0.004925429 -0.001491069 -0.002127945 -0.004914641 -0.001485288 0.001267373 -0.004926383 -0.001466989 0.001277923 -0.004944682 -0.001469433 -0.002140462 -0.004947125 -0.00144869 0.001288473 -0.00496298 -0.001447737 -0.002152979 -0.00496155 -0.001436293 0.001295626 -0.004966318 -0.001436948 -0.002159178 -0.004968762 -0.004428684 0.002960026 -0.004914641 -0.004428684 0.00298506 -0.004947125 -0.004428684 0.003022491 -0.004968762 -0.00736624 0.001264035 -0.004914641 -0.007387936 0.001276552 -0.004947125 -0.007420361 0.001295268 -0.004968762 -0.00736624 -0.002127945 -0.004914641 -0.007387936 -0.002140462 -0.004947125 -0.007420361 -0.002159178 -0.004968762 -0.004428684 -0.003823995 -0.004914641 -0.004428684 -0.003849029 -0.004947125 -0.004428684 -0.003886461 -0.004968762 -0.02341556 0.001580238 -0.003550529 -0.04353523 0.007828354 -0.00443989 -0.04068791 0.006725013 -0.004583477 -0.04070001 0.006718516 -0.004630506 -0.05216205 0.01090908 -0.003936886 -0.05218935 0.01081216 -0.003912985 -0.04638528 0.008864879 -0.004212498 -0.04925763 0.009962618 -0.004117667 -0.04925668 0.009964644 -0.004112303 -0.04638445 0.008923053 -0.004270493 -0.05362874 0.01132738 -0.003863215 -0.05511558 0.01167672 -0.003755211 -0.05362921 0.0113365 -0.0038594 -0.05216056 0.01089376 -0.003956258 -0.05215919 0.01087886 -0.003959894 -0.05362528 0.01129806 -0.003867447 -0.04925924 0.009951472 -0.004132091 -0.04925835 0.009959757 -0.004122793 -0.04638779 0.008920609 -0.004285931 -0.02937394 0.002350389 -0.004933655 -0.05214524 0.010782 -0.003962755 -0.05213314 0.01071071 -0.003957033 -0.05804216 0.01209384 -0.003535985 -0.04637807 0.008715867 -0.004375278 -0.04071795 0.006578445 -0.004767894 -0.03225773 0.003252327 -0.005104362 -0.03506779 0.004383087 -0.00508368 -0.03505975 0.004425644 -0.005043268 -0.03499668 0.004500627 -0.004825532 -0.03222918 0.003305494 -0.004996955 -0.03503447 0.004482567 -0.004945516 -0.03504866 0.004458844 -0.004997193 -0.04071515 0.00667119 -0.004709482 -0.04071807 0.00663042 -0.004741311 -0.04355067 0.007762074 -0.004537522 -0.04354959 0.007715404 -0.004560232 -0.04639142 0.008837521 -0.004354 -0.04638636 0.00878334 -0.004367113 -0.04925173 0.009857654 -0.004161536 -0.02345657 0.00154829 -0.00381422 -0.05509382 0.01162755 -0.003769516 -0.05812072 0.0122314 -0.003574132 -0.05661749 0.01195394 -0.003664731 -0.04925936 0.00993973 -0.004140317 -0.04639208 0.008906066 -0.00431329 -0.04925864 0.00992453 -0.00414735 -0.04639309 0.008893907 -0.004325211 -0.04925715 0.009905755 -0.004153251 -0.04639333 0.008878409 -0.004335999 -0.04354858 0.007796466 -0.004509806 -0.04354637 0.007809042 -0.00449413 -0.04354339 0.007818579 -0.004477202 -0.04639029 0.008914947 -0.004300177 -0.05216115 0.01090502 -0.003951549 -0.06424933 0.01289379 -0.003111958 -0.06414955 0.01310706 -0.003200054 -0.06263405 0.01303112 -0.003300607 -0.06074488 0.012715                                                                                	    ?Z1L	eV<ee3\ae^s    ?Z1L	e^se3\ae>e_    ?Z1L	e^se>e_e)w_    ?Z1L	e$yedre^s    ?Z1L	e^sedreB^(k    ?Z1L	e^seB^(keV<e    ?Z1L	eUe 6e^s    ?Z1L	e^se 6ey    ?Z1L	e^seye$y    ?Z1L	e(eKKe^s    ?Z1L	e^seKKeK    ?Z1L	e^seKeU    ?Z1L	emete^s    ?Z1L	e^seteH!{    ?Z1L	e^seH!{e(    ?Z1L	e)w_ekQbe^s    ?Z1L	e^sekQbez:g    ?Z1L	e^sez:gem    ZL	1"kQb")w_"^s    ZL	1"^s")w_">e_    ZL	1"^s">e_"3\a    ZL	1"t"m"^s    ZL	1"^s"m"z:g    ZL	1"^s"z:g"kQb    ZL	1"KK"("^s    ZL	1"^s"("H!{    ZL	1"^s"H!{"t    ZL	1" 6"U"^s    ZL	1"^s"U"K    ZL	1"^s"K"KK    ZL	1"dr"$y"^s    ZL	1"^s"$y"y    ZL	1"^s"y" 6    ZL	1"3\a"V<e"^s    ZL	1"^s"V<e"B^(k    ZL	1"^s"B^(k"dr  LW.;>p?">e_e3\a"3\a  2gl?V?"3\ae3\aeV<e  !0#?D?"3\aeV<e"V<e  C1rL???"V<eeV<eeB^(k  7]?\?"V<eeB^(k"B^(k  +#"t?j>"B^(keB^(kedr   LV1W{?6>"B^(kedr"dr  N;?=PV"dredre$y  R?1Q|? -"dre$y"$y  vk?M"$ye$yey  s(O^?"$yey"y  >:;?."yeye 6  7|%?QC"ye 6" 6  &1s>d" 6e 6eU  8M*1Hh>$p" 6eU"U  <00=f~"UeUeK  $PO;A"UeK"K   -)Vfpy"KeKeKK  LW;p"KeKK"KK  2g1lV"KKeKKe(  !#D"KKe("(  CrL?"(e(eH!{  71]\"(eH!{"H!{  +#1"tj"H!{eH!{et   LVW{6"H!{et"t  N1;=PV="tetem  R?Q| ->"tem"m  v1kM>"memez:g  s(1O^>"mez:g"z:g  >/:;.?"z:gez:gekQb  71|%QC?"z:gekQb"kQb  &sd?"kQbekQbe)w_  8M*Hh$p?"kQbe)w_")w_  <0f~?")w_e)w_e>e_  $P0OA?")w_e>e_">e_   )Vf>py?">e_e>e_e3\a  } ?!XGbWbwx  } ?!XGwxWbv(b  } ?!XGwxv(bwb  ^gbC6?Rbwxx  =v>Bfxwxw,=v  .bP>rmxw,=v,=v  Iil0h>Jy,=vw,=vwf  dl>|,=vwff  V0;,fwfw&o  KZ@_fw&o&o  v,^Zy&ow&ow]uz$  
h`t&ow]uz$]uz$  e0
4g]uz$w]uz$wP  N^]uz$wPP  =	HPwPw%   2rkX;-B|<Pw% %   F Yuw>e_>e_wb  n060Q+ewb>e_b  180wbbwB^(k  %1dUVkwB^(kbB^(k  Ux;swB^(kB^(kw{u  p2k|w{uB^(k{u  K2uY>w{u{uwy  Q+e50>wy{uy  G108?wyyw  1VkdU?wy  <;sVx?wwK  01k|p?wKK  F .Y>u?wKKwy  n60>Q+e?wyKy  8?0?wyywH!{  %dU?Vk?wH!{yH!{  1Ux?;s>wH!{H!{wq  2p?2k|=wqH!{q  Ku?Ywqqwz:g  1Q+e?50wz:gqz:g  G0?8wz:gz:gw`  Vk?dUw`z:g`  <1;s>Vxw``w>e_  1k|=pw>e_`>e_  A?0'<3O3<3O3`<E:  A?0'w<3Ov(<3Ow`<E:  A?0'w`<E:v(<3OW<3O  A?0'<3O3`<E:W<3O  D/(R?@W<3O3`<E:w`<E:  'rk?w`<E:3`<E:3UC<[:  z}_u?lUw`<E:3UC<[:wUC<[:  ?gwUC<[:3UC<[:3M<Wy;  ?<wUC<[:3M<Wy;wM<Wy;  J-Ry?Yh>wM<Wy;3M<Wy;3hf<I<  h1 q?>wM<Wy;3hf<I<whf<I<  n+[?$J?whf<I<3hf<I<3k<R@<  ;YL??whf<I<3k<R@<wk<R@<  [:?	/?3k<R@<3v:<wk<R@<  [:?	/?wk<R@<3v:<wv:<  }(?P@?wv:<3v:<32(<  ~$K?bP?wv:<32(<w2(<  N	gR3>i?w2(<32(<3+t=  tJ,3>S%s?w2(<3+t=w+t=  h-a{=1/~?w+t=3+t=3xQB=  <?w+t=3xQB=wxQB=  F Yuw=C:;3=C:;wGB;;  n060Q+ewGB;;3=C:;3GB;;  180wGB;;3GB;;w1;da;  %1dUVkw1;da;3GB;;31;da;  Ux;sw1;da;31;da;w;,C  p2k|w;,C31;da;3;,C  K2uY>w;,C3;,Cw;GB  Q+e50>w;GB3;,C3;GB  G108?w;GB3;GBw]a;-  1VkdU?w]a;-3;GB3]a;-  <;sVx?w]a;-3]a;-w+C  01k|p?w+C3]a;-3+C  F .Y>u?w+C3+CwGB  n60>Q+e?wGB3+C3GB  8?0?wGB3GBw/fa  %dU?Vk?w/fa3GB3/fa  1Ux?;s>w/fa3/faw+C:  2p?2k|=w+C:3/fa3+C:  Ku?Yw+C:3+C:wGB;  1Q+e?50wGB;3+C:3GB;  G0?8wGB;3GB;wYa,;  Vk?dUwYa,;3GB;3Ya,;  <1;s>VxwYa,;3Ya,;w=C:;  1k|=pw=C:;3Ya,;3=C:;  0Ts1>wxQB=3xQB=wpe><  0Ts1>wpe><3xQB=3pe><  1	/?:eVL:!8:pWR	<S  1	/?:3R	<S3<3O<3O  1	/?:WL&0xPL&  1	/?:L&0xPlqq  1	/?:L&lqq>L&  1	/?:u2 'd/WL&  1	/?:l-0xP87=,  1	/?:87=,0xPWL&  1	/?:87=,WL&e-  1	/?:e-WL& 'd/  1	/?:l-'d/0xP  1	/?:0xP'd/u2  1	/?:0xPu2VS`  1	/?:VS`u2CP5  1	/?:VS`CP5ld/7  1	/?:88ed/7WVS`  1	/?:WVS`ed/7 CP5  1	/?:8/>`VS`WVS`  1	/?:WVS`VS`ld/7  1	/?:WVS`ld/788  1	/?: }EH?[DWb  1	/?: }EH?[WbeJy  1	/?:DbA4  1	/?:A4bVS`  1	/?:A4VS`l?p  1	/?:l?pVS`8/>`  1	/?:D A4WVS`  1	/?:WVS` A4e?p  1	/?:WVS`e?p8/>`  1	/?:D}EH?[b  1	/?:b}EH?[lJy  1	/?:blJyWb  1	/?:WblJy8JK  1	/?:Wb8JKeJy  1	/?:DWVS`Wb  1	/?:WbWVS`&A4  1	/?:Wb&A4D  1	/?:*}EH?[Dwb  1	/?:wbDwVS`  1	/?:D*A4wVS`  1	/?:wVS`*A4?p  1	/?:wVS`?pv(VS`  1	/?:v(VS`?pv(/>`  1	/?:v(VS`v(/>`WVS`  1	/?:WVS`v(/>`Iv?p  1	/?:WVS`Iv?p&A4  1	/?:D&}EH?[Wb  1	/?:Wb&}EH?[IvJy  1	/?:WbIvJyv(b  1	/?:v(bIvJyv(JK  1	/?:v(bv(JKwb  1	/?:wbv(JKJy  1	/?:wbJy*}EH?[  1	/?:&'d/u2WL&  1	/?:WL&u2WVS`  1	/?:WL&WVS`u2  1	/?:u2WVS` CP5  1	/?:u2&CP5WVS`  1	/?:WVS`&CP5Ivd/7  1	/?:WVS`Ivd/7v(VS`  1	/?:v(VS`Ivd/7v(8  1	/?:v(VS`v(8wVS`  1	/?:wVS`v(8d/7  1	/?:d/7*CP5wVS`  1	/?:wVS`*CP5u2  1	/?:wVS`u2wL&  1	/?:u2*'d/wL&  1	/?:wL&*'d/-  1	/?:wL&-v(L&  1	/?:v(L&-v(7=,  1	/?:v(L&v(7=,WL&  1	/?:WL&v(7=,Iv-  1	/?:WL&Iv-&'d/  1	/?:WR	<S&X<92(  1	/?:WR	<S2(WL&  1	/?:2(&pFXWL&  1	/?:WL&&pFXIv<0  1	/?:WL&Iv<0v(L&  1	/?:v(L&Iv<0v(o  1	/?:v(L&v(owL&  1	/?:wL&v(o<0  1	/?:wR	<SVL:!v(R	<S  1	/?:v(R	<SVL:!v(:p  1	/?:v(R	<Sv(:pWR	<S  1	/?:WR	<Sv(:pIvVL:!  1	/?:WR	<SIvVL:!&X<9  1	/?:<0*pFXwL&  1	/?:wL&*pFX2(  1	/?:wL&2(wR	<S  1	/?:wR	<S2(*X<9  1	/?:wR	<S*X<9VL:!  1	/?:R	<SX<92(  1	/?:WR	<S8:pR	<S  1	/?:R	<S8:plVL:!  1	/?:R	<SlVL:!X<9  1	/?:3q"'3R	<S>L&  1	/?:>L&3R	<SR	<S  1	/?:>L&R	<SL&  1	/?:L&R	<S2(  1	/?:2(pFXL&  1	/?:L&pFXl<0  1	/?:L&l<0WL&  1	/?:WL&l<08o  1	/?:WL&8oe<0  1	/?:e<0 pFXWL&  1	/?:WL& pFX2(  1	/?:WL&2(WR	<S  1	/?:WR	<S2( X<9  1	/?:WR	<S X<9eVL:!  1	/?:3R	<S<3OR	<S  1	/?:R	<S<3OW<3O  1	/?:R	<SW<3OWR	<S  1	/?:WR	<SW<3Ov(<3O  1	/?:WR	<Sv(<3Ov(R	<S  1	/?:v(R	<Sv(<3Ow<3O  1	/?:v(R	<Sw<3OwR	<S    ?Z1L	w,H_<wk<R@<wv:<    ?Z1L	wxQB=wpe><w+t=    ?Z1L	w+t=wpe><w,H_<    ?Z1L	w+t=w,H_<w2(<    ?Z1L	w2(<w,H_<wv:<    ?Z1L	wRdwH!{whrn    ?Z1L	whrnwH!{wq    ?Z1L	wyw&owK    ?Z1L	wKw&owf    ?Z1L	wKwfw    ?Z1L	wL&wB^(kwVS`    ?Z1L	wVS`wB^(kw{u    ?Z1L	wVS`w{uwb    ?Z1L	wbw{uwy    ?Z1L	wbwywx    ?Z1L	wxwyw    ?Z1L	wxww,=v    ?Z1L	w,=vwwf    ?Z1L	wRdw% wH!{    ?Z1L	wH!{w% wP    ?Z1L	wH!{wPwy    ?Z1L	wywPw]uz$    ?Z1L	wyw]uz$w&o    ?Z1L	wqwz:gwhrn    ?Z1L	whrnwz:gw`    ?Z1L	whrnw`w7i"w    ?Z1L	w7i"ww`w>e_    ?Z1L	w7i"ww>e_wb    ?Z1L	wGB;w,H_<w)    ?Z1L	wB^(kwGBw/fa    ?Z1L	wGB;wYa,;w,H_<    ?Z1L	w,H_<wYa,;w=C:;    ?Z1L	w,H_<w=C:;wk<R@<    ?Z1L	wk<R@<w=C:;wGB;;    ?Z1L	wk<R@<wGB;;whf<I<    ?Z1L	whf<I<wGB;;w1;da;    ?Z1L	whf<I<w1;da;wM<Wy;    ?Z1L	wbwB^(kw7i"w    ?Z1L	w7i"wwB^(kw/fa    ?Z1L	w7i"ww/faw)    ?Z1L	w)w/faw+C:    ?Z1L	w)w+C:wGB;    ?Z1L	wGBwB^(kw+C    ?Z1L	w+CwB^(kwL&    ?Z1L	w+CwL&w]a;-    ?Z1L	w]a;-wL&wR	<S    ?Z1L	w]a;-wR	<Sw;GB    ?Z1L	w;GBwR	<Sw<3O    ?Z1L	w;GBw<3Ow;,C    ?Z1L	w;,Cw<3Ow`<E:    ?Z1L	w;,Cw`<E:w1;da;    ?Z1L	w1;da;w`<E:wUC<[:    ?Z1L	w1;da;wUC<[:wM<Wy;  [0:	/Rd% WRd  [0:	/WRd% w%   [0:	/WRdw% v(Rd  [0:	/v(Rdw% wRd    ZL	1hrn7i"w`    ZL	1H!{Rdq    ZL	1qRdhrn    ZL	1qhrnz:g    ZL	1z:ghrn`    ZL	1y{uVS`    ZL	1VS`{u0xP    ZL	10xP{uB^(k    ZL	10xPB^(kmR    ZL	1mRB^(kb    ZL	1mRb7i"w    ZL	17i"wb>e_    ZL	17i"w>e_`    ZL	1&oyK    ZL	1&o]uz$y    ZL	1y]uz$P    ZL	1yPH!{    ZL	1H!{P%     ZL	1H!{% Rd    ZL	1VS`by    ZL	1ybx    ZL	1yx    ZL	1x,=v    ZL	1,=vK    ZL	1K,=vf    ZL	1Kf&o  53S3q"'>)  5>)3q"'>L&  5>)>L&|=L  5|=L>L&lqq  5|=LlqqmR  5mRlqq0xP    ZL	13,H_<3pe><3xQB=    ZL	13xQB=3+t=3,H_<    ZL	13,H_<3+t=32(<    ZL	13,H_<32(<3v:<    ZL	13S3+C:3/fa    ZL	13S3/fa3q"'    ZL	13hf<I<31;da;3k<R@<    ZL	13k<R@<31;da;3GB;;    ZL	13k<R@<3GB;;3v:<    ZL	13v:<3GB;;3=C:;    ZL	13v:<3=C:;3,H_<    ZL	13,H_<3=C:;3Ya,;    ZL	13,H_<3Ya,;3S    ZL	13S3Ya,;3GB;    ZL	13S3GB;3+C:    ZL	13/fa3GB3q"'    ZL	13q"'3GB3+C    ZL	13q"'3+C3R	<S    ZL	13R	<S3+C3]a;-    ZL	13R	<S3]a;-3<3O    ZL	13<3O3]a;-3;GB    ZL	13<3O3;GB3`<E:    ZL	13`<E:3;GB3;,C    ZL	13`<E:3;,C3UC<[:    ZL	13UC<[:3;,C31;da;    ZL	13UC<[:31;da;3M<Wy;    ZL	13M<Wy;31;da;3hf<I<  [0:	/v(,H_<w,H_<wpe><  [0:	/3pe><3,H_<,H_<  [0:	/3pe><,H_<wpe><  [0:	/wpe><,H_<W,H_<  [0:	/wpe><W,H_<v(,H_<  /g8?;o,?8JK8AF9eJy  %m/?_$?eJy8AF9edn8  2$2R?J?eJyedn8 }EH?[  gD>> }EH?[edn8 OL 6  fpk>p> }EH?[ OL 6D  0|k >=D OL 62  0|k D2 A4  fpkp A42 }6%/  gD A4 }6%/e?p  2$3RJe?p }6%/eh-  %m/_$e?peh-8/>`  /g8:o,8/>`eh-8,  />g8;o,8/>`8,l?p  >%m/_$l?p8,lh-  2$?2RJl?plh-A4  gD?A4lh-}6%/  fp?kpA4}6%/D  0|?k D}6%/2  0|?k >=D2}EH?[  fp?k>p>}EH?[2OL 6  gD?>>}EH?[OL 6lJy  2$?3R?J?lJyOL 6ldn8  >%m/?_$?lJyldn88JK  />g8?:o,?8JKldn88AF9  /g8?;o,?888z_?ied/7  %m/?_$?ed/78z_?iex>)  2$2R?J?ed/7ex>) CP5  gD>> CP5ex>) <@6  fpk>p> CP5 <@6u2  0|k >=u2 <@68  0|k u28 'd/  fpkp 'd/8 
I5  gD 'd/ 
I5e-  2$3RJe- 
I5e2  %m/_$e-e287=,  /g8:o,87=,e28<1N  />g8;o,87=,8<1Nl-  >%m/_$l-8<1Nl2  2$?2RJl-l2'd/  gD?'d/l2
I5  fp?kp'd/
I5u2  0|?k u2
I58  0|?k >=u28CP5  fp?k>p>CP58<@6  gD?>>CP5<@6ld/7  2$?3R?J?ld/7<@6lx>)  >%m/?_$?ld/7lx>)88  />g8?:o,?88lx>)8z_?i  /g8?;o,?v(JKv(AF9Jy  %m/?_$?Jyv(AF9dn8  2$2R?J?Jydn8*}EH?[  gD>>*}EH?[dn8*OL 6  fpk>p>*}EH?[*OL 6D  0|k >=D*OL 62  0|k D2*A4  fpkp*A42*}6%/  gD*A4*}6%/?p  2$3RJ?p*}6%/h-  %m/_$?ph-v(/>`  /g8:o,v(/>`h-v(,  />g8;o,v(/>`v(,Iv?p  >%m/_$Iv?pv(,Ivh-  2$?2RJIv?pIvh-&A4  gD?&A4Ivh-&}6%/  fp?kp&A4&}6%/D  0|?k D&}6%/2  0|?k >=D2&}EH?[  fp?k>p>&}EH?[2&OL 6  gD?>>&}EH?[&OL 6IvJy  2$?3R?J?IvJy&OL 6Ivdn8  >%m/?_$?IvJyIvdn8v(JK  />g8?:o,?v(JKIvdn8v(AF9  /g8?;o,?v(8v(z_?id/7  %m/?_$?d/7v(z_?ix>)  2$2R?J?d/7x>)*CP5  gD>>*CP5x>)*<@6  fpk>p>*CP5*<@6u2  0|k >=u2*<@68  0|k u28*'d/  fpkp*'d/8*
I5  gD*'d/*
I5-  2$3RJ-*
I52  %m/_$-2v(7=,  /g8:o,v(7=,2v(<1N  />g8;o,v(7=,v(<1NIv-  >%m/_$Iv-v(<1NIv2  2$?2RJIv-Iv2&'d/  gD?&'d/Iv2&
I5  fp?kp&'d/&
I5u2  0|?k u2&
I58  0|?k >=u28&CP5  fp?k>p>&CP58&<@6  gD?>>&CP5&<@6Ivd/7  2$?3R?J?Ivd/7&<@6Ivx>)  >%m/?_$?Ivd/7Ivx>)v(8  />g8?:o,?v(8Ivx>)v(z_?i  /g8?;o,?8o8w!Oe<0  %m/?_$?e<08w!Oe  2$2R?J?e<0e pFX  gD>> pFXe y$  fpk>p> pFX y$2(  0|k >=2( y$e(D:  0|k 2(e(D: X<9  fpkp X<9e(D: ;J:  gD X<9 ;J:eVL:!  2$3RJeVL:! ;J:e]Z;  %m/_$eVL:!e]Z;8:p  /g8:o,8:pe]Z;8;  />g8;o,8:p8;lVL:!  >%m/_$lVL:!8;l]Z;  2$?2RJlVL:!l]Z;X<9  gD?X<9l]Z;;J:  fp?kpX<9;J:2(  0|?k 2(;J:e(D:  0|?k >=2(e(D:pFX  fp?k>p>pFXe(D:y$  gD?>>pFXy$l<0  2$?3R?J?l<0y$l  >%m/?_$?l<0l8o  />g8?:o,?8ol8w!O  /g8?;o,?v(ov(w!O<0  %m/?_$?<0v(w!O  2$2R?J?<0*pFX  gD>>*pFX*y$  fpk>p>*pFX*y$2(  0|k >=2(*y$e(D:  0|k 2(e(D:*X<9  fpkp*X<9e(D:*;J:  gD*X<9*;J:VL:!  2$3RJVL:!*;J:]Z;  %m/_$VL:!]Z;v(:p  /g8:o,v(:p]Z;v(;  />g8;o,v(:pv(;IvVL:!  >%m/_$IvVL:!v(;Iv]Z;  2$?2RJIvVL:!Iv]Z;&X<9  gD?&X<9Iv]Z;&;J:  fp?kp&X<9&;J:2(  0|?k 2(&;J:e(D:  0|?k >=2(e(D:&pFX  fp?k>p>&pFXe(D:&y$  gD?>>&pFX&y$Iv<0  2$?3R?J?Iv<0&y$Iv  >%m/?_$?Iv<0Ivv(o  />g8?:o,?v(oIvv(w!O  	/:?e8w!OW)  	/:?hrnRdWRd  	/:?ldn8hrn8AF9  	/:?8AF9hrnWhrn  	/:?8AF9Whrnedn8  	/:?7i"wlh-W7i"w  	/:?W7i"wlh-8,  	/:?W7i"w8,eh-  	/:?ldn8OL 6hrn  	/:?hrnOL 62  	/:?hrn27i"w  	/:?7i"w2}6%/  	/:?7i"w}6%/lh-  	/:?eh- }6%/W7i"w  	/:?W7i"w }6%/2  	/:?W7i"w2Whrn  	/:?Whrn2 OL 6  	/:?Whrn OL 6edn8  	/:?mRW)|=L  	/:?|=LW))  	/:?|=L)>)  	/:?e2 
I5W)  	/:?W7i"w8 <@6  	/:?8mR<@6  	/:?<@6mR7i"w  	/:? <@6ex>)W7i"w  	/:?W7i"wex>)8z_?i  	/:?W7i"w8z_?i7i"w  	/:?7i"w8z_?ilx>)  	/:?7i"wlx>)<@6  	/:?8
I5mR  	/:?mR
I5l2  	/:?mRl2W)  	/:?W)l28<1N  	/:?W)8<1Ne2  	/:?,H_<3,H_<3S  	/:?*}6%/2w7i"w  	/:?w7i"w2whrn  	/:?2*OL 6whrn  	/:?whrn*OL 6dn8  	/:?whrndn8v(hrn  	/:?v(hrndn8v(AF9  	/:?v(hrnv(AF9Whrn  	/:?Whrnv(AF9Ivdn8  	/:?W7i"wIvh-v(7i"w  	/:?v(7i"wIvh-v(,  	/:?v(7i"wv(,w7i"w  	/:?w7i"wv(,h-  	/:?w7i"wh-*}6%/  	/:?Ivdn8&OL 6Whrn  	/:?Whrn&OL 62  	/:?Whrn2W7i"w  	/:?W7i"w2&}6%/  	/:?W7i"w&}6%/Ivh-  	/:?*
I58w)  	/:?w)8w7i"w  	/:?8*<@6w7i"w  	/:?w7i"w*<@6x>)  	/:?w7i"wx>)v(7i"w  	/:?v(7i"wx>)v(z_?i  	/:?v(7i"wv(z_?iW7i"w  	/:?W7i"wv(z_?iIvx>)  	/:?W7i"wIvx>)&<@6  	/:? 
I58W)  	/:?W)8W7i"w  	/:?W)W7i"w8  	/:?8W7i"w&<@6  	/:?8&
I5W)  	/:?W)&
I5Iv2  	/:?W)Iv2v()  	/:?v()Iv2v(<1N  	/:?v()v(<1Nw)  	/:?w)v(<1N2  	/:?w)2*
I5  	/:?w)w,H_<e(D:  	/:?e(D:w,H_<*;J:  	/:?e(D:*y$w)  	/:?w)*y$  	/:?w)v()  	/:?v()v(w!O  	/:?v()v(w!OW)  	/:?W)v(w!OIv  	/:?W,H_<Iv]Z;v(,H_<  	/:?v(,H_<Iv]Z;v(;  	/:?v(,H_<v(;w,H_<  	/:?w,H_<v(;]Z;  	/:?w,H_<]Z;*;J:  	/:?Iv&y$W)  	/:?W)&y$e(D:  	/:?W)e(D:W,H_<  	/:?W,H_<e(D:&;J:  	/:?W,H_<&;J:Iv]Z;  	/:?W)8w!O)  	/:?)8w!Ol  	/:?)ly$  	/:?y$e(D:)  	/:?)e(D:,H_<  	/:?),H_<>)  	/:?>),H_<3S  	/:?e(D:;J:,H_<  	/:?,H_<;J:l]Z;  	/:?,H_<l]Z;W,H_<  	/:?W,H_<l]Z;8;  	/:?W,H_<8;e]Z;  	/:?e]Z; ;J:W,H_<  	/:?W,H_< ;J:e(D:  	/:?W,H_<e(D:W)  	/:?W)e(D: y$  	/:?W) y$e  	/:?hrnWRdWhrn  	/:?WhrnWRdv(Rd  	/:?Whrnv(Rdv(hrn  	/:?v(hrnv(RdwRd  	/:?v(hrnwRdwhrn  5E4?l.%kA=]v%A=]'4>  <	A(]mQ]RZzR  S<sVG]4~G]|I  )8;5I4?V$?=l.%kA=7>  Y*8;<<-?7>l.%kA=]'4>  Y;)G7 ?7>]'4>9:?  R;+My?9:?]'4>]<?  D <ti#>]QBF7(B]3!aA  "< d,>]3!aAF7(BWo{]A  =	<_
>]3!aAWo{]A]j[@  xBo<[-?]j[@Wo{]AV@  V;<V%?]j[@V@]<?  B<VUY?]<?V@{U=M?  /<R4?]<?{U=M?9:?  h<?Mz.[V>]pnEFbND]]JD  N<lxd>|>]]JDbND&B5D  ^<v>]]JD&B5D]>D  <[t>]>D&B5D&|C  D<(rm>]>D&|C]QB  \<o>]QB&|CkUB  k!<gl>]QBkUBF7(B  %Y=kUM=]4~GsVGL *G  <8~zc=]4~GL *G]pnEF  6=}o=]pnEFL *Gso=F  (<|0>]pnEFso=FbND   <}]f`fK6sAJ]|I  V&=~]|I6sAJsFI  .=(]|IsFIsVG  
W<&^s]Sl,PdvP]O  PI=Vb]OdvPCN  <Wg4]OCN]N  oD=k]NCN]M  '8<Vo$J]N]M]2,M  z?=Wor
]2,M]M ,)M  {<v]2,M ,)M]_K  V7=XxKt]_K ,)M ]YK  <z
O]_K ]YK]f`fK  /={.9]f`fK ]YKr)[kJ  =+=^|Ap ]f`fKr)[kJ6sAJ  7Q=eF ZzRQ]mQ  O=^SN]mQQ+F:Q  <T*]mQ+F:Q]Sl,P  YN=uW\]Sl,P+F:QN\P  L=?[]Sl,PN\PdvP  V7XxKt2(M_KDf`6ZK  z	ODf`6ZK_Kf`fK  X/{;99Df`6ZKf`fK^soJ  5E4?v%A=iV$?='4>  N*8<<-?'4>iV$?=B>  /8H'?'4>B><?  |>Rie>sO&BQB.	\A  		gy>.	\AQB3!aA  #pL_@>.	\A3!aAEX1#@  C6[>?EX1#@3!aAj[@  BC<VU?EX1#@j[@G=c?  r<U?G=c?j[@<?  /R4?G=c?<?8.?  &MR?8.?<?B>  l!hl>sO&BoBQB  oo>QBoB~UIC  ?q>QB~UIC>D  *U t>>D~UICgA)D  ^v>>DgA)D]JD  x<8|>]JDgA)DZpMkD  hMzTV>]JDZpMkDpnEF  ,G|0>pnEFZpMkD)p=F  -K{~P=pnEF)p=F4~G  ~m9=4~G)p=FKVG  7|_W=KVG2JoG4~G  Oa%4~G2JoG|I  -(|I2JoG-?s~I  
4~|I-?s~If`fK  'Sf}`gf`fK-?s~IzWK{DJ  e,O|'f`fKzWK{DJ^soJ  i?Ro/ZMN2(M  %qw2(MN2,M  }v2(M2,M_K  8zBlgZM3#NN  ]DkoN3#Nq?N  Wg4Nq?NO  PIVbOq?NUw P  W&^sOUw