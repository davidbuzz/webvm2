     sbuf = self.buf[self.buf_index : 3 + self.buf_index]
            (magic, self.expected_length, incompat_flags) = cast(
                ${type_tuple_int_int_int_cast},
                self.mav20_h3_unpacker.unpack(sbuf),
            )
            if magic == PROTOCOL_MARKER_V2 and (incompat_flags & MAVLINK_IFLAG_SIGNED):
                self.expected_length += MAVLINK_SIGNATURE_BLOCK_LEN
            self.expected_length += header_len + 2
        if self.expected_length >= (header_len + 2) and self.buf_len() >= self.expected_length:
            mbuf = self.buf[self.buf_index : self.buf_index + self.expected_length]
            self.buf_index += self.expected_length
            self.expected_length = header_len + 2
            if self.robust_parsing:
                try:
                    if magic == PROTOCOL_MARKER_V2 and (incompat_flags & ~MAVLINK_IFLAG_SIGNED) != 0:
                        raise MAVError("invalid incompat_flags 0x%x 0x%x %u" % (incompat_flags, magic, self.expected_length))
                    m = self.decode(mbuf)
                except MAVError as reason:
                    m = MAVLink_bad_data(mbuf, reason.message)
                    self.total_receive_errors += 1
            else:
                if magic == PROTOCOL_MARKER_V2 and (incompat_flags & ~MAVLINK_IFLAG_SIGNED) != 0:
                    raise MAVError("invalid incompat_flags 0x%x 0x%x %u" % (incompat_flags, magic, self.expected_length))
                m = self.decode(mbuf)
            return m
        return None

    def parse_buffer(self, s${type_intseq})${type_optional_mavlink_message_list_ret}:
        """input some data bytes, possibly returning a list of new messages"""
        m = self.parse_char(s)
        if m is None:
            return None
        ret = [m]
        while True:
            m = self.parse_char(b"")
            if m is None:
                return ret
            ret.append(m)

    def check_signature(self, msgbuf${type_bytearray}, srcSystem${type_int}, srcComponent${type_int})${type_bool_ret}:
        """check signature on incoming message"""
        assert self.signing.secret_key is not None

        timestamp_buf = msgbuf[-12:-6]
        link_id = msgbuf[-13]
        (tlow, thigh) = cast(
            ${type_tuple_int_int_cast},
            self.mav_sign_unpacker.unpack(timestamp_buf),
        )
        timestamp = tlow + (thigh << 32)

        # see if the timestamp is acceptable
        stream_key = (link_id, srcSystem, srcComponent)
        if stream_key in self.signing.stream_timestamps:
            if timestamp <= self.signing.stream_timestamps[stream_key]:
                # reject old timestamp
                logger.info("old timestamp")
                return False
        else:
            # a new stream has appeared. Accept the timestamp if it is at most
            # one minute behind our current timestamp
            if timestamp + 6000 * 1000 < self.signing.timestamp:
                logger.info("bad new stream %s %s", timestamp / (100.0 * 1000 * 60 * 60 * 24 * 365), self.signing.timestamp / (100.0 * 1000 * 60 * 60 * 24 * 365))
                return False
            self.signing.stream_timestamps[stream_key] = timestamp
            logger.info("new stream")

        h = hashlib.new("sha256")
        h.update(self.signing.secret_key)
        h.update(msgbuf[:-6])
        sig1 = h.digest()[:6]
        sig2 = msgbuf[-6:]
        if sig1 != sig2:
            logger.info("sig mismatch")
            return False

        # the timestamp we next send with is the max of the received timestamp and
        # our current timestamp
        self.signing.timestamp = max(self.signing.timestamp, timestamp)
        return True

    def decode(self, msgbuf${type_bytearray})${type_mavlink_message_ret}:
        """decode a buffer as a MAVLink message"""
        # decode the header
        if msgbuf[0] != PROTOCOL_MARKER_V1:
            headerlen = 10
            try:
                magic, mlen, incompat_flags, compat_flags, seq, srcSystem, srcComponent, msgIdlow, msgIdhigh = cast(
                    ${type_tuple_bytes_eight_int_cast},
                    self.mav20_unpacker.unpack(msgbuf[:headerlen]),
                )
            except struct.error as emsg:
                raise MAVError("Unable to unpack MAVLink header: %s" % emsg)
            msgId = msgIdlow | (msgIdhigh << 16)
            mapkey = msgId
        else:
            headerlen = 6
            try:
                magic, mlen, seq, srcSystem, srcComponent, msgId = cast(
                    ${type_tuple_bytes_five_int_cast},
                    self.mav10_unpacker.unpack(msgbuf[:headerlen]),
                )
                incompat_flags = 0
                compat_flags = 0
            except struct.error as emsg:
                raise MAVError("Unable to unpack MAVLink header: %s" % emsg)
            mapkey = msgId
        if (incompat_flags & MAVLINK_IFLAG_SIGNED) != 0:
            signature_len = MAVLINK_SIGNATURE_BLOCK_LEN
        else:
            signature_len = 0

        if ord(magic) != PROTOCOL_MARKER_V1 and ord(magic) != PROTOCOL_MARKER_V2:
            raise MAVError("invalid MAVLink prefix '{}'".format(hex(ord(magic))))
        if mlen != len(msgbuf) - (headerlen + 2 + signature_len):
            raise MAVError("invalid MAVLink message length. Got %u expected %u, msgId=%u headerlen=%u" % (len(msgbuf) - (headerlen + 2 + signature_len), mlen, msgId, headerlen))

        if mapkey not in mavlink_map:
            return MAVLink_unknown(msgId, msgbuf)

        # decode the payload
        msgtype = mavlink_map[mapkey]
        order_map = msgtype.orders
        len_map = msgtype.lengths
        crc_extra = msgtype.crc_extra

        # decode the checksum
        try:
            (crc,) = cast(
                ${type_tuple_int_cast},
                self.mav_csum_unpacker.unpack(msgbuf[-(2 + signature_len) :][:2]),
            )
        except struct.error as emsg:
            raise MAVError("Unable to unpack MAVLink CRC: %s" % emsg)
        crcbuf = msgbuf[1 : -(2 + signature_len)]
        if ${crc_extra}:
            # using CRC extra
            crcbuf.append(crc_extra)
        crc2 = x25crc(crcbuf)
        if crc != crc2.crc and not MAVLINK_IGNORE_CRC:
            raise MAVError("invalid MAVLink CRC in msgID %u 0x%04x should be 0x%04x" % (msgId, crc, crc2.crc))

        sig_ok = False
        if signature_len == MAVLINK_SIGNATURE_BLOCK_LEN:
            self.signing.sig_count += 1
        if self.signing.secret_key is not None:
            accept_signature = False
            if signature_len == MAVLINK_SIGNATURE_BLOCK_LEN:
                sig_ok = self.check_signature(msgbuf, srcSystem, srcComponent)
                accept_signature = sig_ok
                if sig_ok:
                    self.signing.goodsig_count += 1
                else:
                    self.signing.badsig_count += 1
                if not accept_signature and self.signing.allow_unsigned_callback is not None:
                    accept_signature = self.signing.allow_unsigned_callback(self, msgId)
                    if accept_signature:
                        self.signing.unsigned_count += 1
                    else:
                        self.signing.reject_count += 1
            elif self.signing.allow_unsigned_callback is not None:
                accept_signature = self.signing.allow_unsigned_callback(self, msgId)
                if accept_signature:
                    self.signing.unsigned_count += 1
                else:
                    self.signing.reject_count += 1
            if not accept_signature:
                raise MAVError("Invalid signature")

        csize = msgtype.unpacker.size
        mbuf = msgbuf[headerlen : -(2 + signature_len)]
        if len(mbuf) < csize:
            # zero pad to give right size
            mbuf.extend([0] * (csize - len(mbuf)))
        if len(mbuf) < csize:
            raise MAVError("Bad message of type %s length %u needs %s" % (msgtype, len(mbuf), csize))
        mbuf = mbuf[:csize]
        try:
            t = cast(
                ${type_tuple_bytes_int_float_repeat_cast},
                msgtype.unpacker.unpack(mbuf),
            )
        except struct.error as emsg:
            raise MAVError("Unable to unpack MAVLink payload type=%s payloadLength=%u: %s" % (msgtype, len(mbuf), emsg))

        tlist${type_mavlink_message_assign_attr_list} = list(t)
        # handle sorted fields
        if ${sort_fields}:
            if sum(len_map) == len(len_map):
                # message has no arrays in it
                for i in range(0, len(tlist)):
                    tlist[i] = t[order_map[i]]
            else:
                # message has some arrays
                tlist = []
                for i in range(0, len(order_map)):
                    order = order_map[i]
                    L = len_map[order]
                    tip = sum(len_map[:order])
                    field = t[tip]
                    if L == 1 or isinstance(field, bytes):
                        tlist.append(field)
                    else:
                        tlist.append(cast(${type_intseq_floatseq_cast}, list(t[tip : (tip + L)])))

        # terminate any strings
        for i, elem in enumerate(tlist):
            if isinstance(elem, bytes):
                tlist[i] = elem.rstrip(b"\\x00")

        # construct the message object
        try:
            # Note that initializers don't follow the Liskov Substitution Principle
            # therefore it can't be typechecked
            m = msgtype(*tlist)  # type: ignore
        except Exception as emsg:
            raise MAVError("Unable to instantiate MAVLink message of type %s : %s" % (msgtype, emsg))
        m._signed = sig_ok
        if m._signed:
            m._link_id = msgbuf[-13]
        m._msgbuf = msgbuf
        m._payload = msgbuf[6 : -(2 + signature_len)]
        m._crc = crc
        m._header = MAVLink_header(msgId, incompat_flags, compat_flags, mlen, seq, srcSystem, srcComponent)
        return m
''',
        xml,
    )


def generate_methods(outf, msgs, enable_type_annotations):
    print("Generating methods")

    def field_descriptions(fields):
        ret = ""
        for f in fields:
            field_info = ""
            if f.units:
                field_info += "%s " % f.units
            field_info += "(type:%s" % f.type
            if f.enum:
                field_info += ", values:%s" % f.enum
            field_info += ")"
            ret += "        %-18s        : %s %s\n" % (
                f.name,
                f.description.strip(),
                field_info,
            )
        return ret

    wrapper = textwrap.TextWrapper(initial_indent="", subsequent_indent="        ")

    for m in msgs:
        comment = "%s\n\n%s" % (wrapper.fill(m.description.strip()), field_descriptions(m.fields))

        field_names = []
        for i in range(len(m.fields)):
            f = m.fields[i]
            if enable_type_annotations:
                python_type = mavpytype(f)
                if f.omit_arg:
                    field_names.append("%s: %s = %s" % (f.name, python_type, f.const_value))
                elif m.extensions_start is not None and i >= m.extensions_start:
                    fdefault = m.fielddefaults[i]
                    field_names.append("%s: %s = %s" % (f.name, python_type, fdefault))
                else:
                    field_names.append("%s: %s" % (f.name, python_type))
            else:
                if f.omit_arg:
                    field_names.append("%s=%s" % (f.name, f.const_value))
                elif m.extensions_start is not None and i >= m.extensions_start:
                    fdefault = m.fielddefaults[i]
                    field_names.append("%s=%s" % (f.name, fdefault))
                else:
                    field_names.append("%s" % f.name)

        self_ret_type = ""
        if enable_type_annotations:
            self_ret_type = " -> MAVLink_" + m.name.lower() + "_message"

        t.write(
            outf,
            '''

    def ${NAMELOWER}_encode(self, ${ARG_FIELDNAMES})${self_ret_type}:
        """
        ${COMMENT}
        """
        return MAVLink_${NAMELOWER}_message(${FIELDNAMES})

    def ${NAMELOWER}_send(self, ${ARG_FIELDNAMES}, force_mavlink1${type_bool_default})${type_none_ret}:
        """
        ${COMMENT}
        """
        self.send(self.${NAMELOWER}_encode(${FIELDNAMES}), force_mavlink1=force_mavlink1)
''',
            extend_with_type_info(
                {
                    "NAMELOWER": m.name.lower(),
                    "ARG_FIELDNAMES": ", ".join(field_names),
                    "COMMENT": comment,
                    "FIELDNAMES": ", ".join(m.fieldnames),
                    "self_ret_type": self_ret_type,
                },
                enable_type_annotations,
            ),
        )


def generate(basename, xml, enable_type_annotations=False):
    """generate complete python implementation"""
    if basename.endswith(".py"):
        filename = basename
    else:
        filename = basename + ".py"

    msgs = []
    enums = []
    filelist = []
    for x in xml:
        msgs.extend(x.message)
        enums.extend(x.enum)
        filelist.append(os.path.basename(x.filename))

    for m in msgs:
        m.fielddefaults = []
        if xml[0].little_endian:
            m.fmtstr = "<"
        else:
            m.fmtstr = ">"
        m.native_fmtstr = m.fmtstr
        m.instance_field = None
        for f in m.ordered_fields:
            m.fmtstr += mavfmt(f)
            m.fielddefaults.append(mavdefault(f))
            m.native_fmtstr += native_mavfmt(f)
            if f.instance:
                m.instance_field = f.name
        m.order_map = [0] * len(m.fieldnames)
        m.len_map = [0] * len(m.fieldnames)
        m.array_len_map = [0] * len(m.fieldnames)
        for i in range(0, len(m.fieldnames)):
            m.order_map[i] = m.ordered_fieldnames.index(m.fieldnames[i])
            m.array_len_map[i] = m.ordered_fields[i].array_length
        for i in range(0, len(m.fieldnames)):
            n = m.order_map[i]
            m.len_map[n] = m.fieldlengths[i]

    print("Generating %s" % filename)
    outf = open(filename, "w")
    xml = extend_with_type_info(xml[0].__dict__, enable_type_annotations)
    generate_preamble(outf, msgs, basename, filelist, xml)
    generate_enums(outf, enums, enable_type_annotations)
    generate_message_ids(outf, msgs)
    generate_classes(outf, msgs, enable_type_annotations)
    generate_mavlink_class(outf, msgs, xml)
    generate_methods(outf, msgs, enable_type_annotations)
    outf.close()
    print("Generated %s OK" % filename)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         #!/usr/bin/env python
"""
Parse a MAVLink protocol XML file and generate Swift implementation

Copyright Max Odnovolyk 2015
Released under GNU GPL version 3 or later
"""
from __future__ import print_function

import os
from . import mavparse, mavtemplate

abbreviations = ["MAV", "PX4", "UDB", "PPZ", "PIXHAWK", "SLUGS", "FP", "ASLUAV", "VTOL", "ROI", "UART", "UDP", "IMU", "IMU2", "3D", "RC", "GPS", "GPS1", "GPS2", "NED", "RTK", "ADSB"]
swift_keywords = ["associatedtype", "class", "deinit", "enum", "extension", "fileprivate", "func", "import", "init", "inout", "internal", "let", "open", "operator", "private", "protocol",
                  "public", "static", "struct", "subscript", "typealias", "var", "break" "case", "continue", "default", "defer", "do", "else", "fallthrough", "for", "guard", "if", "in", "repeat", "return", "switch",
                  "where", "while", "Any", "catch", "false", "is", "nil", "rethrows", "super", "self", "Self", "throw", "throws", "true", "try"]
swift_types = {'char' : ("String", '"\\0"', "string(at: %u, length: %u)", "set(%s, at: %u, length: %u)"),
               'uint8_t' : ("UInt8", 0, "number(at: %u)", "set(%s, at: %u)"),
               'int8_t' : ("Int8", 0, "number(at: %u)", "set(%s, at: %u)"),
               'uint16_t' : ("UInt16", 0, "number(at: %u)", "set(%s, at: %u)"),
               'int16_t' : ("Int16", 0, "number(at: %u)", "set(%s, at: %u)"),
               'uint32_t' : ("UInt32", 0, "number(at: %u)", "set(%s, at: %u)"),
               'int32_t' : ("Int32", 0, "number(at: %u)", "set(%s, at: %u)"),
               'uint64_t' : ("UInt64", 0, "number(at: %u)", "set(%s, at: %u)"),
               'int64_t' : ("Int64", 0, "number(at: %u)", "set(%s, at: %u)"),
               'float' : ("Float", 0, "number(at: %u)", "set(%s, at: %u)"),
               'double' : ("Double", 0, "number(at: %u)", "set(%s, at: %u)"),
               'uint8_t_mavlink_version' : ("UInt8", 0, "number(at: %u)", "set(%s, at: %u)")}

t = mavtemplate.MAVTemplate()

def generate_mavlink(directory, filelist, xml_list, msgs):
    print("Generating MAVLink.swift file")

    mavparse.mkdir_p(directory)
    filename = 'MAVLink.swift'
    filepath = os.path.join(directory, filename)
    outf = open(filepath, "w")
    generate_header(outf, filelist, xml_list, filename)
    append_static_code('MAVLink.swift', outf)
    generate_message_mappings_array(outf, msgs)
    generate_message_lengths_array(outf, msgs)
    generate_message_crc_extra_array(outf, msgs)
    outf.close()

def generate_header(outf, filelist, xml_list, filename):
    """Generate Swift file header with source files list and creation date"""

    t.write(outf, """
//
//  ${FILENAME}
//  MAVLink Protocol Swift Library
//
//  Generated from ${FILELIST} on ${PARSE_TIME} by mavgen_swift.py 
//  https://github.com/modnovolyk/MAVLinkSwift
//

""", {'FILENAME' : filename,
      'FILELIST' : ", ".join(filelist),
      'PARSE_TIME' : xml_list[0].parse_time})

def generate_enums(directory, filelist, xml_list, enums):
    """Iterate through all enums and create Swift equivalents"""

    print("Generating Enumerations")

    for enum in enums:
        if enum.is_a_bitmask:
            continue
        filename = "%s%sEnum.swift" % (enum.swift_name, enum.basename)
        filepath = os.path.join(directory, filename)
        outf = open(filepath, "w")
        generate_header(outf, filelist, xml_list, filename)
        t.write(outf, """
${formatted_description}public enum ${swift_name}: ${raw_value_type} {
${{entry:${formatted_description}\tcase ${swift_name} = ${value}\n}}
}

extension ${swift_name}: Enumeration {
    public static var typeName = "${name}"
    public static var typeDescription = "${entity_description}"
    public static var allMembers = [${all_entities}]
    public static var membersDescriptions = [${entities_info}]
    public static var enumEnd = UInt(${enum_end})
}
""", enum)
        outf.close()

def generate_optionsets(directory, filelist, xml_list, enums):
    """Iterate through all enums and create Swift equivalents"""

    print("Generating Enumerations")

    for enum in enums:
        if not enum.is_a_bitmask:
            continue
        for entry in enum.entry:
            entry.parent_swift_name = enum.swift_name
        filename = "%s%sOptionSet.swift" % (enum.swift_name, enum.basename)
        filepath = os.path.join(directory, filename)
        outf = open(filepath, "w")
        generate_header(outf, filelist, xml_list, filename)
        t.write(outf, """
${formatted_description}public struct ${swift_name}: OptionSet {
\tpublic let rawValue: ${raw_value_type}

\tpublic init(rawValue: ${raw_value_type}) {
\t\tself.rawValue = rawValue
\t}
${{entry:${formatted_description}\tpublic static let ${swift_name} = ${parent_swift_name}(rawValue: ${value})\n}}
}

extension ${swift_name}: MAVLinkBitmask {
    public static var typeName = "${name}"
    public static var typeDescription = "${entity_description}"
    public static var allMembers = [${all_entities}]
    public static var membersDescriptions = [${entities_info}]
    public static var enumEnd = UInt(${enum_end})
}
""", enum)
        outf.close()

def get_enum_raw_type(enum, msgs):
    """Search appropirate raw type for enums in messages fields"""

    for msg in msgs:
        for field in msg.fields:
            if  field.enum == enum.name:
                return swift_types[field.type][0]
    return "Int"

def generate_messages(directory, filelist, xml_list, msgs):
    """Generate Swift structs to represent all MAVLink messages"""

    print("Generating Messages")

    for msg in msgs:
        filename = "%s%sMsg.swift" % (msg.swift_name, msg.basename)
        filepath = os.path.join(directory, filename)
        outf = open(filepath, "w")
        generate_header(outf, filelist, xml_list, filename)
        t.write(outf, """
import Foundation

${formatted_description}public struct ${swift_name} {
${{fields:${formatted_description}\tpublic let ${swift_name}: ${return_type}\n}}
}

extension ${swift_name}: Message {
    public static let id = UInt8(${id})
    public static var typeName = "${name}"
    public static var typeDescription = "${message_description}"
    public static var fieldDefinitions: [FieldDefinition] = [${fields_info}]

    public init(data: Data) throws {
${{ordered_fields:\t\t${init_accessor} = ${initial_value}\n}}
    }

    public func pack() throws -> Data {
        var payload = Data(count: ${wire_length})
${{ordered_fields:\t\ttry payload.${payload_setter}\n}}
        return payload
    }
}
""", msg)
        outf.close()

def append_static_code(filename, outf):
    """Open and copy static code from specified file"""

    basepath = os.path.dirname(os.path.realpath(__file__))
    filepath = os.path.join(basepath, 'swift/%s' % filename)
    
    print("Appending content of %s" % filename)
    
    with open(filepath) as inf:
        for line in inf:
            outf.write(line) 

def generate_message_mappings_array(outf, msgs):
    """Create array for mapping message Ids to proper structs"""

    classes = []
    for msg in msgs:
        classes.append("%u: %s.self" % (msg.id, msg.swift_name))
    t.write(outf, """

/// Array for mapping message id to proper struct
private let messageIdToClass: [UInt8: Message.Type] = [${ARRAY_CONTENT}]
""", {'ARRAY_CONTENT' : ", ".join(classes)})

def generate_message_lengths_array(outf, msgs):
    """Create array with message lengths to validate known message lengths"""

    # form message lengths array
    lengths = []
    for msg in msgs:
        lengths.append("%u: %u" % (msg.id, msg.wire_length))

    t.write(outf, """

/// Message lengths array for known messages length validation
private let messageLengths: [UInt8: UInt8] = [${ARRAY_CONTENT}]
""", {'ARRAY_CONTENT' : ", ".join(lengths)})

def generate_message_crc_extra_array(outf, msgs):
    """Add array with CRC extra values to detect incompatible XML changes"""

    crcs = []
    for msg in msgs:
        crcs.append("%u: %u" % (msg.id, msg.crc_extra))

    t.write(outf, """

/// Message CRSs extra for detection incompatible XML changes
private let messageCRCsExtra: [UInt8: UInt8] = [${ARRAY_CONTENT}]
""", {'ARRAY_CONTENT' : ", ".join(crcs)})

def camel_case_from_underscores(string):
    """Generate a CamelCase string from an underscore_string"""

    components = string.split('_')
    string = ''

    for component in components:
        if component in abbreviations:
            string += component
        else:
            string += component[0].upper() + component[1:].lower()

    return string

def lower_camel_case_from_underscores(string):
    """Generate a lower-cased camelCase string from an underscore_string"""

    components = string.split('_')
    string = components[0].lower()
    for component in components[1:]:
        string += component[0].upper() + component[1:].lower()

    return string

def contains_a_bitmask(enums, enumName):
    for enum in enums:
        if enum.name == enumName:
            return enum.is_a_bitmask
    return False

def enum_is_a_bitmask(enum):
    values = []
    for entry in enum.entry:
        values.append(entry.value)
    values.sort()
    for i, value in enumerate(values):
        if 2 ** i != value:
            return False
    return True


def generate_enums_type_info(enums, msgs):
    """Add camel case swift names for enums an entries, descriptions and sort enums alphabetically"""

    for enum in enums:
        enum.swift_name = camel_case_from_underscores(enum.name)
        enum.raw_value_type = get_enum_raw_type(enum, msgs)

        enum.formatted_description = ""
        if enum.description:
            enum.description = " ".join(enum.description.split())
            enum.formatted_description = "/// %s\n" % enum.description

        for index, entry in enumerate(enum.entry):
            if entry.name.endswith("_ENUM_END"):
                enum.enum_end = entry.value
                del enum.entry[index]

        all_entities = []
        entities_info = []

        for entry in enum.entry:
            name = entry.name.replace(enum.name + '_', '')
            """Ensure that enums entry name does not start from digit"""
            if name[0].isdigit():
                name = "MAV_" + name
            entry.swift_name = lower_camel_case_from_underscores(name)

            """Ensure that enums entry name does not match any swift keyword"""
            if entry.swift_name in swift_keywords:
                entry.swift_name = lower_camel_case_from_underscores("MAV_" + name)

            entry.formatted_description = ""
            if entry.description:
                entry.description = " ".join(entry.description.split())
                entry.formatted_description = "\n\t/// " + entry.description + "\n"

            all_entities.append(entry.swift_name)
            entities_info.append('("%s", "%s")' % (entry.name, entry.description.replace('"','\\"')))

        enum.all_entities = ", ".join(all_entities)
        enum.entities_info = ", ".join(entities_info)
        enum.entity_description = enum.description.replace('"','\\"')
        enum.is_a_bitmask = enum_is_a_bitmask(enum)

    enums.sort(key = lambda enum : enum.swift_name)

def generate_messages_type_info(msgs, enums):
    """Add proper formatted variable names, initializers and type names to use in templates"""

    for msg in msgs:
        msg.swift_name = camel_case_from_underscores(msg.name)

        msg.formatted_description = ""
        if msg.description:
            msg.description = " ".join(msg.description.split())
            msg.formatted_description = "/// %s\n" % " ".join(msg.description.split())
        msg.message_description = msg.description.replace('"','\\"')

        for field in msg.ordered_fields:
            field.swift_name = lower_camel_case_from_underscores(field.name)
            field.init_accessor = field.swift_name if field.swift_name != "data" else "self.%s" % field.swift_name
            field.pack_accessor = field.swift_name if field.swift_name != "payload" else "self.%s" % field.swift_name
            field.return_type = swift_types[field.type][0]
            
            # configure fields initializers
            if field.enum:
                # handle enums


                field.return_type = camel_case_from_underscores(field.enum)
                if contains_a_bitmask(enums, field.enum):
                    field.initial_value = "try data.bitmask(at: %u)" % field.wire_offset
                else:
                    field.initial_value = "try data.enumeration(at: %u)" % field.wire_offset
                field.payload_setter = "set(%s, at: %u)" % (field.pack_accessor, field.wire_offset)
            elif field.array_length > 0:
                if field.return_type == "String":
                    # handle strings
                    field.initial_value = "try data." + swift_types[field.type][2] % (field.wire_offset, field.array_length)
                    field.payload_setter = swift_types[field.type][3] % (field.pack_accessor, field.wire_offset, field.array_length)
                else:
                    # other array types
                    field.return_type = "[%s]" % field.return_type
                    field.initial_value = "try data.array(at: %u, capacity: %u)" % (field.wire_offset, field.array_length)
                    field.payload_setter = "set(%s, at: %u, capacity: %u)" % (field.pack_accessor, field.wire_offset, field.array_length)
            else:
                # simple type field
                field.initial_value = "try data." + swift_types[field.type][2] % field.wire_offset
                field.payload_setter = swift_types[field.type][3] % (field.pack_accessor, field.wire_offset)

            field.formatted_description = ""
            if field.description:
                field.description = " ".join(field.description.split())
                field.formatted_description = "\n\t/// " + field.description + "\n"
         
        fields_info = ['("%s", %u, "%s", %u, "%s")' % (field.swift_name, field.wire_offset, field.return_type, field.array_length, field.description.replace('"','\\"')) for field in msg.fields]
        msg.fields_info = ", ".join(fields_info)

    msgs.sort(key = lambda msg : msg.id)

def generate(basename, xml_list):
    """Generate complete MAVLink Swift implementation"""

    msgs = []
    enums = []
    filelist = []

    for xml in xml_list:
        for msg in xml.message: msg.basename = xml.basename.title()
        for enum in xml.enum: enum.basename = xml.basename.title()

        msgs.extend(xml.message)
        enums.extend(xml.enum)
        filelist.append(os.path.basename(xml.filename))
    
    generate_enums_type_info(enums, msgs)
    generate_messages_type_info(msgs, enums)

    generate_mavlink(basename, filelist, xml_list, msgs)
    generate_enums(basename, filelist, xml_list, enums)
    generate_optionsets(basename, filelist, xml_list, enums)
    generate_messages(basename, filelist, xml_list, msgs)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          #!/usr/bin/env python
"""
parse a MAVLink protocol XML file and generate a Node.js typescript module implementation

Based on original work Copyright Andrew Tridgell 2011
Released under GNU GPL version 3 or later
"""
from __future__ import print_function

import os
from . import mavtemplate

t = mavtemplate.MAVTemplate()


def camelcase(str):
    parts = str.split('_')
    result = ''
    for part in parts:
        result += part.lower().capitalize()
    return result


def generate_enums(dir, enums):
    print("Generating enums")

    if not os.path.isdir(dir):
        os.mkdir(dir)
        
    for e in enums:
        filename = e.name.replace('_', '-')
        filename = filename.lower()
        with open('{}/{}.ts'.format(dir, filename), "w") as f:
            f.write("export enum {} {{\n".format(camelcase(e.name)))
            for entry in e.entry:
                f.write(
                    "\t{} = {}, // {}\n".format(entry.name, entry.value, entry.description.rstrip("\r").rstrip("\n")))
            f.write("}")


def generate_classes(dir, registry, msgs, xml):
    print("Generating class definitions")

    ts_types = {"uint8_t": "number", "uint16_t": "number", "uint32_t": "number", "uint64_t": "number",
                "int8_t": "number", "int16_t": "number", "int32_t": "number", "int64_t": "number",
                "float": "number", "double": "number", "char": "string"}

    if not os.path.isdir(dir):
        os.mkdir(dir)

    with open(registry, "w") as registry_f:
        registry_f.write("import {MAVLinkMessage} from 'node-mavlink';\n")
        for m in msgs:
            filename = m.name.replace('_', '-')
            filename = filename.lower()

            m.order_map = [0] * len(m.fieldnames)
            for i in range(0, len(m.fieldnames)):
                m.order_map[i] = m.ordered_fieldnames.index(m.fieldnames[i])

            with open('{}/{}.ts'.format(dir, filename), "w") as f:
                if xml.wire_protocol_version == '1.0':
                    raise Exception('WireProtocolException', 'Please use WireProtocol = 2.0 only.')

                f.write("import {MAVLinkMessage} from 'node-mavlink';\n")
                f.write("import {readInt64LE, readUInt64LE} from 'node-mavlink';\n")
                registry_f.write("import {{{}}} from './messages/{}';\n".format(camelcase(m.name), filename))
                imported_enums = []
                for enum in [field.enum for field in m.fields if field.enum != '']:
                    if enum not in imported_enums:
                        f.write("import {{{}}} from '../enums/{}';\n".format(camelcase(enum),
                                                                             enum.replace('_', '-').lower()))
                        imported_enums.append(enum)

                f.write("/*\n{}\n*/\n".format(m.description.strip()))
                for field in m.fields:
                    f.write("// {} {} {}\n".format(field.name, field.description.strip(), field.type))

                f.write("export class {} extends MAVLinkMessage {{\n".format(camelcase(m.name)))

                for field in m.fields:
                    if field.enum:
                        f.write("\tpublic {}!: {};\n".format(field.name, camelcase(field.enum)))
                    else:
                        f.write("\tpublic {}!: {};\n".format(field.name, ts_types[field.type]))

                f.write("\tpublic _message_id: number = {};\n".format(m.id))
                f.write("\tpublic _message_name: string = '{}';\n".format(m.name))
                f.write("\tpublic _crc_extra: number = {};\n".format(m.crc_extra))

                i = 0
                f.write("\tpublic _message_fields: [string, string, boolean][] = [\n")
                for fieldname in m.ordered_fieldnames:
                    field = next(field for field in m.fields if field.name == fieldname)
                    if m.extensions_start is not None and i >= m.extensions_start:
                        extension = 'true'
                    else:
                        extension = 'false'
                    f.write("\t\t['{}', '{}', {}],\n".format(field.name, field.type, extension))
                    i += 1
                f.write("\t];\n".format("', '".join(m.ordered_fieldnames)))

                f.write("}")

        registry_f.write(
            "export const messageRegistry: Array<[number, new (system_id: number, component_id: number) "
            "=> MAVLinkMessage]> = [\n")
        for m in msgs:
            registry_f.write("\t[{}, {}],\n".format(m.id, camelcase(m.name)))
        registry_f.write("];")


def generate_tsconfig(basename):
    with open('{}/tsconfig.json'.format(basename), "w") as f:
        f.write(
            "{\n  \"compilerOptions\": {\n    \"target\": \"es5\",\n    \"module\": \"commonjs\","
            "\n    \"declaration\": true,\n    \"declarationMap\": true,\n    \"sourceMap\": true,"
            "\n    \"outDir\": \"./\",\n    \"strict\": true,\n    \"esModuleInterop\": true\n  },"
            "\n  \"include\": [\n    \"./\"\n  ],\n  \"exclude\": [\n    \"**/*.d.ts\","
            "\n    \"**/*.d.ts.map\",\n    \"**/*.js\",\n    \"**/*.js.map\"\n  ]\n}")


def generate(basename, xml):
    enums_dir = basename + '/enums'
    messages_dir = basename + '/messages'
    message_registry = basename + '/message-registry.ts'

    msgs = []
    enums = []
    filelist = []
    for x in xml:
        msgs.extend(x.message)
        enums.extend(x.enum)
        filelist.append(os.path.basename(x.filename))

    generate_enums(enums_dir, enums)
    generate_classes(messages_dir, message_registry, msgs, xml[0])
    generate_tsconfig(basename)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   '''
parse a MAVLink protocol XML file and generate a Wireshark Lua dissector

Example usage on Linux or macOS:

# assuming you have cloned the mavlink repo to /mavlink
MXML="/mavlink/message_definitions/v1.0/ardupilotmega.xml"
# Wireshark -> About Wireshark -> Folders -> Personal Lua Plugins
WIRESHARK_PLUGINS="~/.local/lib/wireshark/plugins"
mkdir -p $WIRESHARK_PLUGINS
mavgen.py --lang=WLua $MXML -o $WIRESHARK_PLUGINS/mavlink.lua

After doing this, Wireshark should be able to show details of MAVLink packets.

---

Copyright Holger Steinhaus 2012
Released under GNU GPL version 3 or later
'''
from __future__ import print_function

from builtins import range

import os
from math import ceil
from . import mavparse, mavtemplate

t = mavtemplate.MAVTemplate()

def get_field_info(field):
    mavlink_type = field.type
    size = field.type_length
    count = field.array_length if field.array_length > 0 else 1

    if mavlink_type == "char":
        # char (string) types
        field_type = "ftypes.STRING"
        tvb_func = "string"
        size = count
        count = 1
    elif "int" in mavlink_type:
        # (u)int types
        field_type = "ftypes." + mavlink_type.replace("_t", "").upper()
        tvb_func = "le_" + ("u" if "u" in mavlink_type else "") + "int" + ("64" if "64" in mavlink_type else "")
    else:
        # float/double
        field_type = "ftypes." + mavlink_type.upper()
        tvb_func = "le_" + mavlink_type

    return mavlink_type, field_type, tvb_func, size, count


def generate_preamble(outf):
    print("Generating preamble")
    t.write(outf, 
"""
-- Wireshark dissector for the MAVLink protocol (please see https://mavlink.io/en for details)

unknownFrameBeginOffset = 0
mavlink_proto = Proto("mavlink_proto", "MAVLink protocol")
f = mavlink_proto.fields

-- from http://lua-users.org/wiki/TimeZone
local function get_timezone()
    local now = os.time()
    return os.difftime(now, os.time(os.date("!*t", now)))
end
local signature_time_ref = get_timezone() + os.time{year=2015, month=1, day=1, hour=0}

-- threshold to decide if time is absolute or relative (some time in 2005)
time_usec_threshold = UInt64.new(0,0x40000)
-- function to append human-readable time onto unix_time_us fields
local function time_usec_decode(value)
    if value > time_usec_threshold then
        d = os.date("%Y-%m-%d %H:%M:%S",value:tonumber() / 1000000.0)
        us = value % 1000000
        us = string.format("%06d",us:tonumber())
        tz = os.date(" %Z",value:tonumber() / 1000000.0)
        return " (" .. d .. "." .. us .. tz .. ")"
    elseif value < 1000000 then
        return ""
    elseif type(value) == "number" then
        return string.format(" (%.6f s)",value / 1000000.0)
    else
        return string.format(" (%.6f s)",value:tonumber() / 1000000.0)
    end
end

payload_fns = {}

protocolVersions = {
    [0xfd] = "MAVLink 2.0",
    [0xfe] = "MAVLink 1.0",
    [0x55] = "MAVLink 0.9"
}

""" )
    
    
def generate_body_fields(outf):
    t.write(outf, 
"""
f.magic = ProtoField.uint8("mavlink_proto.magic", "Magic value / version", base.HEX, protocolVersions)
f.length = ProtoField.uint8("mavlink_proto.length", "Payload length")
f.incompatibility_flag = ProtoField.uint8("mavlink_proto.incompatibility_flag", "Incompatibility flag", base.HEX_DEC)
f.compatibility_flag = ProtoField.uint8("mavlink_proto.compatibility_flag", "Compatibility flag", base.HEX_DEC)
f.sequence = ProtoField.uint8("mavlink_proto.sequence", "Packet sequence")
f.sysid = ProtoField.uint8("mavlink_proto.sysid", "System id", base.DEC)
f.compid = ProtoField.uint8("mavlink_proto.compid", "Component id", base.DEC, enumEntryName.MAV_COMPONENT)
f.msgid = ProtoField.uint24("mavlink_proto.msgid", "Message id", base.DEC, messageName)
f.payload = ProtoField.uint8("mavlink_proto.payload", "Payload", base.DEC, messageName)
f.crc = ProtoField.uint16("mavlink_proto.crc", "Message CRC", base.HEX)
f.signature_link = ProtoField.uint8("mavlink_proto.signature_link", "Link id", base.DEC)
f.signature_time = ProtoField.absolute_time("mavlink_proto.signature_time", "Time")
f.signature_signature = ProtoField.bytes("mavlink_proto.signature_signature", "Signature")
f.rawheader = ProtoField.bytes("mavlink_proto.rawheader", "Unparsable header fragment")
f.rawpayload = ProtoField.bytes("mavlink_proto.rawpayload", "Unparsable payload")
""")


def generate_msg_table(outf, msgs):
    t.write(outf, """
messageName = {
""")
    for msg in msgs:
        assert isinstance(msg, mavparse.MAVType)
        t.write(outf, """
    [${msgid}] = '${msgname}',
""", {'msgid':msg.id, 'msgname':msg.name})

    t.write(outf, """
}

""")


def is_power_of_2(n):
    assert isinstance(n, int)
    return (n & (n-1) == 0) and n != 0


def generate_enum_table(outf, enums):
    t.write(outf, """
local enumEntryName = {
""")
    for enum in enums:
        assert isinstance(enum, mavparse.MAVEnum)
        t.write(outf, """
    ["${enumname}"] = {
""", {'enumname': enum.name})

        for entry in enum.entry:
            if not entry.name.endswith("_ENUM_END"):
                t.write(outf, """
        [${entryvalue}] = "${entryname}",
""", {'entryvalue': entry.value, 'entryname': entry.name})

        t.write(outf, """
    },
""")

    t.write(outf, """
}
""")


def generate_field_or_param(outf, field_or_param, name, label, physical_type, field_type, enums):
    assert isinstance(field_or_param, mavparse.MAVEnumParam) or isinstance(field_or_param, mavparse.MAVField)
    values = "nil"
    enum_obj = None
    if field_or_param.enum:
        enum_obj = next((enum for enum in enums if enum.name == field_or_param.enum), None)

    if field_or_param.enum:
        # display name of enum instead of base type
        display_type = field_or_param.enum
        # show enum values for non-flags enums
        if not enum_obj.bitmask:
            values = "enumEntryName." + field_or_param.enum
        else:
            values = values + ", base.HEX_DEC"
        # force display type of enums to uint32 so we can show the names
        if field_type in ("ftypes.FLOAT", "ftypes.DOUBLE", "ftypes.INT32"):
            field_type = "ftypes.UINT32"
    else:
        display_type = physical_type
        if isinstance(field_or_param, mavparse.MAVField) and field_or_param.display == "bitmask":
            values = values + ", base.HEX_DEC"
    unitstr = " " + field_or_param.units if field_or_param.units else ""
    t.write(outf,
"""
f.${fname} = ProtoField.new("${flabel} (${ftypename})${unitname}", "mavlink_proto.${fname}", ${ftype}, ${fvalues})
""", {'fname': name, 'flabel': label, 'ftypename': display_type, 'ftype': field_type, 'fvalues': values, 'unitname': unitstr})

    # generate flag enum subfields
    if enum_obj and enum_obj.bitmask:
        physical_bits = max(entry.value.bit_length() for entry in enum_obj.entry)
        physical_bits = ceil(physical_bits/4)*4
        for entry in enum_obj.entry:
            if not is_power_of_2(entry.value) or entry.name.endswith("_ENUM_END"):
                # omit flag enums have values like "0: None"
                continue

            t.write(outf,
"""
f.${fname}_flag${ename} = ProtoField.bool("mavlink_proto.${fname}.${ename}", "${ename}", ${fbits}, nil, ${evalue})
""", {'fname': name, 'ename': entry.name, 'fbits': physical_bits, 'evalue': entry.value})


def generate_msg_fields(outf, msg, enums):
    assert isinstance(msg, mavparse.MAVType)
    for f in msg.fields:
        assert isinstance(f, mavparse.MAVField)
        mavlink_type, field_type, _, _, count = get_field_info(f)

        for i in range(0,count):
            if count>1: 
                array_text = '[' + str(i) + ']'
                index_text = '_' + str(i)
            else:
                array_text = ''
                index_text = ''

            name = t.substitute("${fmsg}_${fname}${findex}", {'fmsg':msg.name, 'fname':f.name, 'findex':index_text})
            label = t.substitute("${fname}${farray}", {'fname':f.name, 'farray':array_text, 'ftypename': mavlink_type})
            generate_field_or_param(outf, f, name, label, mavlink_type, field_type, enums)

    t.write(outf, '\n\n')


def generate_cmd_params(outf, cmd, enums):
    assert isinstance(cmd, mavparse.MAVEnumEntry)

    for p in cmd.param:
        assert isinstance(p, mavparse.MAVEnumParam)
        # only save params that have a label
        if p.label:
            name = t.substitute("cmd_${pcname}_param${pindex}", {'pcname': cmd.name, 'pindex': p.index})
            label = t.substitute("param${pindex}: ${pname}", {'pindex': p.index, 'pname': p.label})
            generate_field_or_param(outf, p, name, label, "float", "ftypes.FLOAT", enums)
            pindex = int(p.index)
            if pindex >= 5:
                # On COMMAND_INT and MISSION_ITEM_INT, params 5,6,7 are named x,y,z ...
                intname = chr(pindex+115)
                name = t.substitute("cmd_${pcname}_${intname}", {'pcname': cmd.name, 'intname': intname})
                label = t.substitute("${intname}: ${pname}", {'intname': intname, 'pname': p.label})
                # ... and the x and y fields are integers
                if pindex == 5 or pindex == 6:
                    generate_field_or_param(outf, p, name, label, "int32_t", "ftypes.INT32", enums)
                else:
                    generate_field_or_param(outf, p, name, label, "float", "ftypes.FLOAT", enums)

    t.write(outf, '\n\n')


def generate_flag_enum_dissector(outf, enum):
    assert isinstance(enum, mavparse.MAVEnum)
    t.write(outf,
"""
-- dissect flag field
function dissect_flags_${enumname}(tree, name, tvbrange, value)
""", {'enumname': enum.name})

    for entry in enum.entry:
        if is_power_of_2(entry.value) and not entry.name.endswith("_ENUM_END"):
            t.write(outf,
"""
    tree:add_le(f[name .. "_flag${entryname}"], tvbrange, value)
""", {'entryname': entry.name})

    t.write(outf,
"""
end
""")

unit_decoder_mapping = {
    'degE7': 'string.format(\" (%.7f deg)\",value/1E7)',
    'us': 'time_usec_decode(value)',
    'rad': 'string.format(\" (%g deg)\",value*180/math.pi)',
    'rad/s': 'string.format(\" (%g deg/s)\",value*180/math.pi)'
}

def generate_field_dissector(outf, msg, field, offset, enums, cmd=None, param=None):
    # field is the PHYSICAL type
    # but param may have a different LOGICAL type
    assert isinstance(field, mavparse.MAVField)
    assert cmd is None or isinstance(cmd, mavparse.MAVEnumEntry)
    assert param is None or isinstance(param, mavparse.MAVEnumParam)

    mavlink_type, _, tvb_func, size, count = get_field_info(field)

    enum_name = param.enum if param else field.enum
    enum_obj = enum_name and next((e for e in enums if e.name == enum_name), None)

    # handle arrays, but not strings

    for i in range(0,count):
        if count>1:
            index_text = '_' + str(i)
        else:
            index_text = ''

        if param is not None:
            if msg.name.endswith("_INT") and int(param.index) >= 5:
                field_var = t.substitute("cmd_${cname}_${intname}", {'cname': cmd.name, 'intname': chr(int(param.index)+115)})
            else:
                field_var = t.substitute("cmd_${cname}_param${pindex}", {'cname': cmd.name, 'pindex': param.index})
        else:
            field_var = t.substitute("${fmsg}_${fname}${findex}", {'fmsg': msg.name, 'fname': field.name, 'findex': index_text})

        t.write(outf,
"""
    tvbrange = padded(offset + ${foffset}, ${fbytes})
    value = tvbrange:${ftvbfunc}()
    subtree = tree:add_le(f.${fvar}, tvbrange, value)
""", {'foffset': offset + i * size, 'fbytes': size, 'ftvbfunc': tvb_func, 'fvar': field_var})

        unit = field.units.replace("[","").replace("]","")
        global unit_decoder_mapping
        if unit in unit_decoder_mapping:
            t.write(outf,"    subtree:append_text(" + unit_decoder_mapping[unit] + ")\n")

        if enum_obj and enum_obj.bitmask:
            valuemethod = ":tonumber()" if tvb_func == "le_uint64" else ""
            t.write(outf,
"""
    dissect_flags_${enumname}(subtree, "${fvar}", tvbrange, value${vmeth})
""", {'enumname': enum_name, 'fvar': field_var, 'vmeth': valuemethod})


def generate_payload_dissector(outf, msg, cmds, enums, cmd=None):
    # detect command messages (but not in already command-specific dissectors)
    has_commands = cmds and msg.name in ("COMMAND_INT", "COMMAND_LONG", "COMMAND_ACK", "COMMAND_CANCEL","MISSION_ITEM","MISSION_ITEM_INT") and "command" in msg.field_offsets
    has_args = has_commands and msg.name in ("COMMAND_INT", "COMMAND_LONG","MISSION_ITEM","MISSION_ITEM_INT")

    # for command messages with args, generate command-specific dissectors
    if has_args:
        for subcmd in cmds:
            generate_payload_dissector(outf, msg, None,enums, cmd=subcmd)

    # function header
    if cmd is not None:
        t.write(outf, 
"""
-- dissect payload of message type ${msgname} with command ${cmdname}
function payload_fns.payload_${msgid}_cmd${cmdid}(buffer, tree, msgid, offset, limit, pinfo)
""", {'msgid': msg.id, 'msgname': msg.name, 'cmdid': cmd.value, 'cmdname': cmd.name})
    else:
        t.write(outf, 
"""
-- dissect payload of message type ${msgname}
function payload_fns.payload_${msgid}(buffer, tree, msgid, offset, limit, pinfo)
""", {'msgid': msg.id, 'msgname': msg.name})

    # validate and pad payload if necessary
    t.write(outf, 
"""
    local padded, field_offset, value, subtree, tvbrange
    if (offset + ${msgbytes} > limit) then
        padded = buffer(0, limit):bytes()
        padded:set_size(offset + ${msgbytes})
        padded = padded:tvb("Untruncated payload")
    else
        padded = buffer
    end
""", {'msgbytes': msg.wire_length})

    # for all command messages, show the command name in the info field
    if has_commands:
        t.write(outf,
"""
    local cmd_id = padded(offset + ${foffset}, 2):le_uint()
    local cmd_name = enumEntryName.MAV_CMD[cmd_id]
    if cmd_name ~= nil then
        pinfo.cols.info:append(": " .. cmd_name)
    end
""", {'foffset': msg.field_offsets['command']})

    # for command messages with args, call command-specific dissector if known
    if has_args:
        t.write(outf,
"""
    local cmd_fn = payload_fns["payload_${msgid}_cmd" .. tostring(cmd_id)]
    if cmd_fn ~= nil then
        cmd_fn(buffer, tree, msgid, offset, limit, pinfo)
        return
    end
""", {'msgid': msg.id})
    
    for field in msg.fields:
        # detect command params
        param = None
        if cmd is not None:
            param_index = {'param1': 1, 'param2': 2, 'param3': 3, 'param4': 4, 'param5': 5, 'param6': 6, 'param7': 7, 'x': 5, 'y': 6, 'z': 7}.get(field.name)

            for p in cmd.param:
                if int(p.index) == param_index:
                    param = p
                    break
            if param_index is not None:
                param = next((p for p in cmd.param if int(p.index) == param_index and p.label), None)

        generate_field_dissector(outf, msg, field, msg.field_offsets[field.name], enums, cmd, param)

    t.write(outf, 
"""
end
""")
    

def generate_packet_dis(outf):
    t.write(outf, 
"""
-- dissector function
function mavlink_proto.dissector(buffer,pinfo,tree)
    local offset = 0
    local msgCount = 0
    
    -- loop through the buffer to extract all the messages in the buffer
    while (offset < buffer:len()) 
    do
        msgCount = msgCount + 1
        local subtree = tree:add (mavlink_proto, buffer(), "MAVLink Protocol ("..buffer:len()..")")

        -- decode protocol version first
        local version = buffer(offset,1):uint()
        local protocolString = ""
    
    	while (true)
		do
            protocolString = protocolVersions[version]
            if (protocolString ~= nil) then
                break
            else
                protocolString = "unknown"
                -- some unknown data found, record the begin offset
                if (unknownFrameBeginOffset == 0) then
                    unknownFrameBeginOffset = offset
                end
               
                offset = offset + 1
                
                if (offset < buffer:len()) then
                    version = buffer(offset,1):uint()
                else
                    -- no magic value found in the whole buffer. print the raw data and exit
                    if (unknownFrameBeginOffset ~= 0) then
                        if (msgCount == 1) then
                            pinfo.cols.info:set("Unknown message")
                        else
                            pinfo.cols.info:append("  Unknown message")
                        end
                        size = offset - unknownFrameBeginOffset
                        subtree:add(f.rawpayload, buffer(unknownFrameBeginOffset,size))
                        unknownFrameBeginOffset = 0
                    end
                    return
                end
            end	
        end
        
        if (unknownFrameBeginOffset ~= 0) then
            pinfo.cols.info:append("Unknown message")
            size = offset - unknownFrameBeginOffset
            subtree:add(f.rawpayload, buffer(unknownFrameBeginOffset,size))
            unknownFrameBeginOffset = 0
            -- jump to next loop
            break
        end
        
        -- some Wireshark decoration
        pinfo.cols.protocol = protocolString

        -- HEADER ----------------------------------------
    
        local msgid
        local length
        local incompatibility_flag

        if (version == 0xfe) then
            if (buffer:len() - 2 - offset > 6) then
                -- normal header
                local header = subtree:add(buffer(offset, 6), "Header")
                header:add(f.magic, buffer(offset,1), version)
                offset = offset + 1
            
                length = buffer(offset,1)
                header:add(f.length, length)
                offset = offset + 1
            
                local sequence = buffer(offset,1)
                header:add(f.sequence, sequence)
                offset = offset + 1
            
                local sysid = buffer(offset,1)
                header:add(f.sysid, sysid)
                offset = offset + 1
        
                local compid = buffer(offset,1)
                header:add(f.compid, compid)
                offset = offset + 1
            
                pinfo.cols.src = "System: "..tostring(sysid:uint())..', Component: '..tostring(compid:uint())
        
                msgid = buffer(offset,1):uint()
                header:add(f.msgid, buffer(offset,1), msgid)
                offset = offset + 1
            else 
                -- handle truncated header
                local hsize = buffer:len() - 2 - offset
                subtree:add(f.rawheader, buffer(offset, hsize))
                offset = offset + hsize
            end
        elseif (version == 0xfd) then
            if (buffer:len() - 2 - offset > 10) then
                -- normal header
                local header = subtree:add(buffer(offset, 10), "Header")
                header:add(f.magic, buffer(offset,1), version)
                offset = offset + 1
                length = buffer(offset,1)
                header:add(f.length, length)
                offset = offset + 1
                incompatibility_flag = buffer(offset,1):uint()
                header:add(f.incompatibility_flag, buffer(offset,1), incompatibility_flag)
                offset = offset + 1
                local compatibility_flag = buffer(offset,1)
                header:add(f.compatibility_flag, compatibility_flag)
                offset = offset + 1
                local sequence = buffer(offset,1)
                header:add(f.sequence, sequence)
                offset = offset + 1
                local sysid = buffer(offset,1)
                header:add(f.sysid, sysid)
                offset = offset + 1
                local compid = buffer(offset,1)
                header:add(f.compid, compid)
                offset = offset + 1
                pinfo.cols.src = "System: "..tostring(sysid:uint())..', Component: '..tostring(compid:uint())
                msgid = buffer(offset,3):le_uint()
                header:add(f.msgid, buffer(offset,3), msgid)
                offset = offset + 3
            else 
                -- handle truncated header
                local hsize = buffer:len() - 2 - offset
                subtree:add(f.rawheader, buffer(offset, hsize))
                offset = offset + hsize
            end
        end


        -- BODY ----------------------------------------
    
        -- dynamically call the type-specific payload dissector    
        local msgnr = msgid
        local dissect_payload_fn = "payload_"..tostring(msgnr)
        local fn = payload_fns[dissect_payload_fn]
        local limit = buffer:len() - 2

        if (length) then
            length = length:uint()
        else
            length = 0
        end

        if (offset + length < limit) then
            limit = offset + length
        end
    
        if (fn == nil) then
            pinfo.cols.info:append ("Unknown message type   ")
            subtree:add_expert_info(PI_MALFORMED, PI_ERROR, "Unknown message type")
            size = buffer:len() - 2 - offset
            subtree:add(f.rawpayload, buffer(offset,size))
            offset = offset + size
        else
            local payload = subtree:add(f.payload, buffer(offset, limit - offset), msgid)
            pinfo.cols.dst:set(messageName[msgid])
            if (msgCount == 1) then
            -- first message should over write the TCP/UDP info
                pinfo.cols.info = messageName[msgid]
            else
                pinfo.cols.info:append("   "..messageName[msgid])
            end
            fn(buffer, payload, msgid, offset, limit, pinfo)
            offset = limit
        end

        -- CRC ----------------------------------------

        local crc = buffer(offset,2)
        subtree:add_le(f.crc, crc)
        offset = offset + 2

        -- SIGNATURE ----------------------------------

        if (version == 0xfd and incompatibility_flag == 0x01) then
            local signature = subtree:add("Signature")

            local link = buffer(offset,1)
            signature:add(f.signature_link, link)
            offset = offset + 1

            local signature_time = buffer(offset,6):le_uint64()
            local time_secs = signature_time / 100000
            local time_nsecs = (signature_time - (time_secs * 100000)) * 10000
            signature:add(f.signature_time, buffer(offset,6), NSTime.new(signature_time_ref + time_secs:tonumber(), time_nsecs:tonumber()))
            offset = offset + 6

            local signature_signature = buffer(offset,6)
            signature:add(f.signature_signature, signature_signature)
            offset = offset + 6
        end

    end
end


""")
    


def generate_epilog(outf):
    print("Generating epilog")
    t.write(outf, 
"""   
-- bind protocol dissector to USER0 linktype

wtap_encap = DissectorTable.get("wtap_encap")
wtap_encap:add(wtap.USER0, mavlink_proto)

-- bind protocol dissector to ports: 14550, 14580, 18570

local udp_dissector_table = DissectorTable.get("udp.port")
udp_dissector_table:add(14550, mavlink_proto)
udp_dissector_table:add(14580, mavlink_proto)
udp_dissector_table:add(18570, mavlink_proto)

-- register common Mavlink TCP ports

DissectorTable.get("tcp.port"):add("5760-5763", mavlink_proto)

""")

def generate(basename, xml):
    '''generate complete lua implemenation'''
    if basename.endswith('.lua'):
        filename = basename
    else:
        filename = basename + '.lua'

    msgs = []
    enums = []
    filelist = []
    for x in xml:
        msgs.extend(x.message)
        enums.extend(x.enum)
        filelist.append(os.path.basename(x.filename))

    # find the MAV_CMD enum
    cmds = next((enum.entry for enum in enums if enum.name == "MAV_CMD"), [])

    for m in msgs:
        m.order_map = [ 0 ] * len(m.fieldnames)
        for i in range(0, len(m.fieldnames)):
            m.order_map[i] = m.ordered_fieldnames.index(m.fieldnames[i])

    print("Generating %s" % filename)
    outf = open(filename, "w")
    generate_preamble(outf)
    generate_msg_table(outf, msgs)
    generate_enum_table(outf, enums)
    generate_body_fields(outf)

    for c in cmds:
        generate_cmd_params(outf, c, enums)
    
    for m in msgs:
        generate_msg_fields(outf, m, enums)

    for e in enums:
        if e.bitmask:
            generate_flag_enum_dissector(outf, e)
    
    for m in msgs:
        generate_payload_dissector(outf, m, cmds, enums)
    
    generate_packet_dis(outf)
#    generate_enums(outf, enums)
#    generate_message_ids(outf, msgs)
#    generate_classes(outf, msgs)
#    generate_mavlink_class(outf, msgs, xml[0])
#    generate_methods(outf, msgs)
    generate_epilog(outf)
    outf.close()
    print("Generated %s OK" % filename)

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                #!/usr/bin/env python
'''
mavlink python parse functions

Copyright Andrew Tridgell 2011
Released under GNU GPL version 3 or later
'''
from __future__ import print_function
from builtins import range
from builtins import object

import errno
import operator
import os
import sys
import time
import xml.parsers.expat

PROTOCOL_0_9 = "0.9"
PROTOCOL_1_0 = "1.0"
PROTOCOL_2_0 = "2.0"

# message flags
FLAG_HAVE_TARGET_SYSTEM    = 1
FLAG_HAVE_TARGET_COMPONENT = 2

class MAVParseError(Exception):
    def __init__(self, message, inner_exception=None):
        self.message = message
        self.inner_exception = inner_exception
        self.exception_info = sys.exc_info()
    def __str__(self):
        return self.message

class MAVField(object):
    def __init__(self, name, type, print_format, xml, description='', enum='', display='', units='', instance=False):
        self.name = name
        self.name_upper = name.upper()
        self.description = description
        self.array_length = 0
        self.enum = enum
        self.display = display
        self.units = units
        self.omit_arg = False
        self.const_value = None
        self.print_format = print_format
        self.instance = instance
        lengths = {
        'float'    : 4,
        'double'   : 8,
        'char'     : 1,
        'int8_t'   : 1,
        'uint8_t'  : 1,
        'uint8_t_mavlink_version'  : 1,
        'int16_t'  : 2,
        'uint16_t' : 2,
        'int32_t'  : 4,
        'uint32_t' : 4,
        'int64_t'  : 8,
        'uint64_t' : 8,
        }

        if type=='uint8_t_mavlink_version':
            type = 'uint8_t'
            self.omit_arg = True
            self.const_value = xml.version

        aidx = type.find("[")
        if aidx != -1:
            assert type[-1:] == ']'
            self.array_length = int(type[aidx+1:-1])
            type = type[0:aidx]
            if type == 'array':
                type = 'int8_t'
        if type in lengths:
            self.type_length = lengths[type]
            self.type = type
        elif (type+"_t") in lengths:
            self.type_length = lengths[type+"_t"]
            self.type = type+'_t'
        else:
            raise MAVParseError("unknown type '%s'" % type)
        if self.array_length != 0:
            self.wire_length = self.array_length * self.type_length
        else:
            self.wire_length = self.type_length
        self.type_upper = self.type.upper()

    def gen_test_value(self, i):
        '''generate a testsuite value for a MAVField'''
        if self.const_value:
            return self.const_value
        elif self.type == 'float':
            return 17.0 + self.wire_offset*7 + i
        elif self.type == 'double':
            return 123.0 + self.wire_offset*7 + i
        elif self.type == 'char':
            return chr(ord('A') + (self.wire_offset + i)%26)
        elif self.type in [ 'int8_t', 'uint8_t' ]:
            return (5 + self.wire_offset*67 + i) & 0xFF
        elif self.type in ['int16_t', 'uint16_t']:
            return (17235 + self.wire_offset*52 + i) & 0xFFFF
        elif self.type in ['int32_t', 'uint32_t']:
            return (963497464 + self.wire_offset*52 + i)&0xFFFFFFFF
        elif self.type in ['int64_t', 'uint64_t']:
            return 93372036854775807 + self.wire_offset*63 + i
        else:
            raise MAVParseError('unknown type %s' % self.type)

    def set_test_value(self):
        '''set a testsuite value for a MAVField'''
        if self.array_length:
            self.test_value = []
            for i in range(self.array_length):
                self.test_value.append(self.gen_test_value(i))
        else:
                self.test_value = self.gen_test_value(0)
        if self.type == 'char' and self.array_length:
            v = ""
            for c in self.test_value:
                v += c
            self.test_value = v[:-1]


class MAVType(object):
    def __init__(self, name, id, linenumber, description=''):
        self.name = name
        self.name_lower = name.lower()
        self.linenumber = linenumber
        self.id = int(id)
        self.description = description
        self.fields = []
        self.fieldnames = []
        self.extensions_start = None
        self.needs_pack = False

    def base_fields(self):
        '''return number of non-extended fields'''
        if self.extensions_start is None:
            return len(self.fields)
        return len(self.fields[:self.extensions_start])

class MAVEnumParam(object):
    def __init__(self, index, description='', label='', units='', enum='', increment='', minValue='', maxValue='', reserved=False, default=''):
        self.index = index
        self.description = description
        self.label = label
        self.units = units
        self.enum = enum
        self.increment = increment
        self.minValue = minValue
        self.maxValue = maxValue
        self.reserved = reserved
        self.default = default
        if self.reserved and not self.default:
            self.default = '0'
        self.set_description(description)

    def set_description(self, description):
        if not description.strip() and self.reserved:
            self.description = 'Reserved (default:%s)' % self.default
        else:
            self.description = description

class MAVEnumEntry(object):
    def __init__(self, name, value, description='', end_marker=False, autovalue=False, origin_file='', origin_line=0, has_location=False):
        self.name = name
        self.value = value
        self.description = description
        self.param = []
        self.end_marker = end_marker
        self.autovalue = autovalue  # True if value was *not* specified in XML
        self.origin_file = origin_file
        self.origin_line = origin_line
        self.has_location = has_location

class MAVEnum(object):
    def __init__(self, name, linenumber, description='', bitmask=False):
        self.name = name
        self.description = description
        self.entry = []
        self.start_value = None
        self.highest_value = 0
        self.linenumber = linenumber
        self.bitmask = bitmask

class MAVXML(object):
    '''parse a mavlink XML file'''
    def __init__(self, filename, wire_protocol_version=PROTOCOL_0_9):
        self.filename = filename
        self.basename = os.path.basename(filename)
        if self.basename.lower().endswith(".xml"):
            self.basename = self.basename[:-4]
        self.basename_upper = self.basename.upper()
        self.message = []
        self.enum = []
        # we use only the day for the parse_time, as otherwise
        # it causes a lot of unnecessary cache misses with ccache
        self.parse_time = time.strftime("%a %b %d %Y")
        self.version = 2
        self.include = []
        self.wire_protocol_version = wire_protocol_version

        # setup the protocol features for the requested protocol version
        if wire_protocol_version == PROTOCOL_0_9:
            self.protocol_marker = ord('U')
            self.sort_fields = False
            self.little_endian = False
            self.crc_extra = False
            self.crc_struct = False
            self.command_24bit = False
            self.allow_extensions = False
        elif wire_protocol_version == PROTOCOL_1_0:
            self.protocol_marker = 0xFE
            self.sort_fields = True
            self.little_endian = True
            self.crc_extra = True
            self.crc_struct = False
            self.command_24bit = False
            self.allow_extensions = False
        elif wire_protocol_version == PROTOCOL_2_0:
            self.protocol_marker = 0xFD
            self.sort_fields = True
            self.little_endian = True
            self.crc_extra = True
            self.crc_struct = True
            self.command_24bit = True
            self.allow_extensions = True
        else:
            print("Unknown wire protocol version")
            print("Available versions are: %s %s %s" % (PROTOCOL_0_9, PROTOCOL_1_0, PROTOCOL_2_0))
            raise MAVParseError('Unknown MAVLink wire protocol version %s' % wire_protocol_version)

        in_element_list = []

        def check_attrs(attrs, check, where):
            for c in check:
                if c not in attrs:
                    raise MAVParseError('expected missing %s "%s" attribute at %s:%u' % (
                        where, c, filename, p.CurrentLineNumber))

        def start_element(name, attrs):
            in_element_list.append(name)
            in_element = '.'.join(in_element_list)
            #print in_element
            if in_element == "mavlink.messages.message":
                check_attrs(attrs, ['name', 'id'], 'message')
                self.message.append(MAVType(attrs['name'], attrs['id'], p.CurrentLineNumber))
            elif in_element == "mavlink.messages.message.extensions":
                self.message[-1].extensions_start = len(self.message[-1].fields)
            elif in_element == "mavlink.messages.message.field":
                check_attrs(attrs, ['name', 'type'], 'field')
                print_format = attrs.get('print_format', None)
                enum = attrs.get('enum', '')
                display = attrs.get('display', '')
                units = attrs.get('units', '')
                if units:
                    units = '[' + units + ']'
                instance = attrs.get('instance', False)
                new_field = MAVField(attrs['name'], attrs['type'], print_format, self, enum=enum, display=display, units=units, instance=instance)
                if self.message[-1].extensions_start is None or self.allow_extensions:
                    self.message[-1].fields.append(new_field)
            elif in_element == "mavlink.enums.enum":
                check_attrs(attrs, ['name'], 'enum')
                bitmask = 'bitmask' in attrs and attrs['bitmask'] == 'true'
                self.enum.append(MAVEnum(attrs['name'], p.CurrentLineNumber, bitmask=bitmask))
            elif in_element == "mavlink.enums.enum.entry":
                check_attrs(attrs, ['name'], 'enum entry')
                # determine value and if it was automatically assigned (for possible merging later)
                if 'value' in attrs:
                    value = eval(attrs['value'])
                    autovalue = False
                else:
                    value = self.enum[-1].highest_value + 1
                    autovalue = True
                # check lowest value
                if (self.enum[-1].start_value is None or value < self.enum[-1].start_value):
                    self.enum[-1].start_value = value
                # check highest value
                if (value > self.enum[-1].highest_value):
                    self.enum[-1].highest_value = value
                has_location = attrs.get('hasLocation', False)
                if has_location == 'true':
                    has_location = True
                elif has_location == 'false':
                    has_location = False
                if type(has_location) != bool:
                    raise MAVParseError("invalid has_location value %s" % has_location)
                # append the new entry
                self.enum[-1].entry.append(MAVEnumEntry(attrs['name'], value, '', False, autovalue, self.filename, p.CurrentLineNumber, has_location=has_location))
            elif in_element == "mavlink.enums.enum.entry.param":
                check_attrs(attrs, ['index'], 'enum param')
                self.enum[-1].entry[-1].param.append(
                                                MAVEnumParam(attrs['index'], 
                                                        label=attrs.get('label', ''), units=attrs.get('units', ''), 
                                                        enum=attrs.get('enum', ''), increment=attrs.get('increment', ''), 
                                                        minValue=attrs.get('minValue', ''), 
                                                        maxValue=attrs.get('maxValue', ''), default=attrs.get('default', '0'), 
                                                        reserved=attrs.get('reserved', False) ))

        def is_target_system_field(m, f):
            if f.name == 'target_system':
                return True
            if m.name == "MANUAL_CONTROL" and f.name == "target":
                return True
            return False

        def end_element(name):
            in_element_list.pop()

        def char_data(data):
            in_element = '.'.join(in_element_list)
            if in_element == "mavlink.messages.message.description":
                self.message[-1].description += data
            elif in_element == "mavlink.messages.message.field":
                if self.message[-1].extensions_start is None or self.allow_extensions:
                    self.message[-1].fields[-1].description += data
            elif in_element == "mavlink.enums.enum.description":
                self.enum[-1].description += data
            elif in_element == "mavlink.enums.enum.entry.description":
                self.enum[-1].entry[-1].description += data
            elif in_element == "mavlink.enums.enum.entry.param":
                self.enum[-1].entry[-1].param[-1].description += data
            elif in_element == "mavlink.version":
                self.version = int(data)
            elif in_element == "mavlink.include":
                self.include.append(data)

        f = open(filename, mode='rb')
        p = xml.parsers.expat.ParserCreate()
        p.StartElementHandler = start_element
        p.EndElementHandler = end_element
        p.CharacterDataHandler = char_data
        p.ParseFile(f)
        f.close()
   

        #Post process to add reserved params (for docs)
        for current_enum in self.enum:
            if not 'MAV_CMD' in current_enum.name:
                continue
            for enum_entry in current_enum.entry:
                if len(enum_entry.param) == 7:
                    continue
                params_dict=dict()
                for param_index in range (1,8):
                    params_dict[param_index] = MAVEnumParam(param_index, label='', units='', enum='', increment='', 
                                                        minValue='', maxValue='', default='0', reserved='True')

                for a_param in enum_entry.param:
                    params_dict[int(a_param.index)] = a_param
                enum_entry.param=params_dict.values()
                


        self.message_lengths = {}
        self.message_min_lengths = {}
        self.message_flags = {}
        self.message_target_system_ofs = {}
        self.message_target_component_ofs = {}
        self.message_crcs = {}
        self.message_names = {}
        self.largest_payload = 0

        if not self.command_24bit:
            # remove messages with IDs > 255
            m2 = []
            for m in self.message:
                if m.id <= 255:
                    m2.append(m)
            self.message = m2

        for m in self.message:
            if not self.command_24bit and m.id > 255:
                continue

            m.wire_length = 0
            m.wire_min_length = 0
            m.fieldnames = []
            m.fieldlengths = []
            m.ordered_fieldnames = []
            m.ordered_fieldtypes = []
            m.fieldtypes = []
            m.message_flags = 0
            m.target_system_ofs = 0
            m.target_component_ofs = 0
            m.field_offsets = {}
            
            if self.sort_fields:
                # when we have extensions we only sort up to the first extended field
                sort_end = m.base_fields()
                m.ordered_fields = sorted(m.fields[:sort_end],
                                                   key=operator.attrgetter('type_length'),
                                                   reverse=True)
                m.ordered_fields.extend(m.fields[sort_end:])
            else:
                m.ordered_fields = m.fields
            for f in m.fields:
                m.fieldnames.append(f.name)
                L = f.array_length
                if L == 0:
                    m.fieldlengths.append(1)
                elif L > 1 and f.type == 'char':
                    m.fieldlengths.append(1)
                else:
                    m.fieldlengths.append(L)
                m.fieldtypes.append(f.type)
            for i in range(len(m.ordered_fields)):
                f = m.ordered_fields[i]
                f.wire_offset = m.wire_length
                m.field_offsets[f.name] = f.wire_offset
                m.wire_length += f.wire_length
                field_el_length = f.wire_length
                if f.array_length > 1:
                    field_el_length = f.wire_length / f.array_length
                if f.wire_offset % field_el_length != 0:
                    # misaligned field, structure will need packing in C
                    m.needs_pack = True
                if m.extensions_start is None or i < m.extensions_start:
                    m.wire_min_length = m.wire_length
                m.ordered_fieldnames.append(f.name)
                m.ordered_fieldtypes.append(f.type)
                f.set_test_value()
                if f.name.find('[') != -1:
                    raise MAVParseError("invalid field name with array descriptor %s" % f.name)
                # having flags for target_system and target_component helps a lot for routing code
                if is_target_system_field(m, f):
                    m.message_flags |= FLAG_HAVE_TARGET_SYSTEM
                    m.target_system_ofs = f.wire_offset
                elif f.name == 'target_component':
                    m.message_flags |= FLAG_HAVE_TARGET_COMPONENT
                    m.target_component_ofs = f.wire_offset
            m.num_fields = len(m.fieldnames)
            if m.num_fields > 64:
                raise MAVParseError("num_fields=%u : Maximum number of field names allowed is %u" % (
                    m.num_fields, 64))
            m.crc_extra = message_checksum(m)

            key = m.id
            self.message_crcs[key] = m.crc_extra
            self.message_lengths[key] = m.wire_length
            self.message_min_lengths[key] = m.wire_min_length
            self.message_names[key] = m.name
            self.message_flags[key] = m.message_flags
            self.message_target_system_ofs[key] = m.target_system_ofs
            self.message_target_component_ofs[key] = m.target_component_ofs

            if m.wire_length > self.largest_payload:
                self.largest_payload = m.wire_length

    def __str__(self):
        return "MAVXML for %s from %s (%u message, %u enums)" % (
            self.basename, self.filename, len(self.message), len(self.enum))


def message_checksum(msg):
    '''calculate CRC-16/MCRF4XX checksum of the key fields of a message, so we
       can detect incompatible XML changes'''
    from .mavcrc import x25crc
    crc = x25crc()
    crc.accumulate_str(msg.name + ' ')
    # in order to allow for extensions the crc does not include
    # any field extensions
    crc_end = msg.base_fields()
    for i in range(crc_end):
        f = msg.ordered_fields[i]
        crc.accumulate_str(f.type + ' ')
        crc.accumulate_str(f.name + ' ')
        if f.array_length:
            crc.accumulate([f.array_length])
    return (crc.crc&0xFF) ^ (crc.crc>>8)

def merge_enums(xml):
    '''merge enums between XML files'''
    emap = {}
    for x in xml:
        newenums = []
        for enum in x.enum:
            if enum.name in emap:
                emapitem = emap[enum.name]
                # check for possible conflicting auto-assigned values after merge
                if (emapitem.start_value <= enum.highest_value and emapitem.highest_value >= enum.start_value):
                    for entry in emapitem.entry:
                        # correct the value if necessary, but only if it was auto-assigned to begin with
                        if entry.value <= enum.highest_value and entry.autovalue is True:
                            entry.value = enum.highest_value + 1
                            enum.highest_value = entry.value
                # merge the entries
                emapitem.entry.extend(enum.entry)
                if not emapitem.description:
                    emapitem.description = enum.description
                print("Merged enum %s" % enum.name)
            else:
                newenums.append(enum)
                emap[enum.name] = enum
        x.enum = newenums
    for e in emap:
        # sort by value
        emap[e].entry = sorted(emap[e].entry,
                               key=operator.attrgetter('value'),
                               reverse=False)
        # add a ENUM_END
        emap[e].entry.append(MAVEnumEntry("%s_ENUM_END" % emap[e].name,
                                            emap[e].entry[-1].value+1, end_marker=True))

def check_duplicates(xml):
    '''check for duplicate message IDs'''

    merge_enums(xml)

    msgmap = {}
    msg_name_map = {}
    enummap = {}
    for x in xml:
        for m in x.message:
            key = m.id
            if key in msgmap:
                print("ERROR: Duplicate message id %u for %s (%s:%u) also used by %s" % (
                    m.id,
                    m.name,
                    x.filename, m.linenumber,
                    msgmap[key]))
                return True
            fieldset = set()
            for f in m.fields:
                if f.name in fieldset:
                    print("ERROR: Duplicate field %s in message %s (%s:%u)" % (
                        f.name, m.name,
                        x.filename, m.linenumber))
                    return True
                fieldset.add(f.name)
            msgmap[key] = '%s (%s:%u)' % (m.name, x.filename, m.linenumber)
            # Check for duplicate message names
            if m.name in msg_name_map:
                print("ERROR: Duplicate message name %s for id:%u (%s:%u) also used by %s" % (
                    m.name,
                    m.id,
                    x.filename, m.linenumber,
                    msg_name_map[m.name]))
                return True
            msg_name_map[m.name] = '%s (%s:%u)' % (m.id, x.filename, m.linenumber)
        for enum in x.enum:
            for entry in enum.entry:
                if entry.autovalue is True and "common.xml" not in entry.origin_file:
                    print("Note: An enum value was auto-generated: %s = %u" % (entry.name, entry.value))
                s1 = "%s.%s" % (enum.name, entry.name)
                s2 = "%s.%s" % (enum.name, entry.value)
                if s1 in enummap or s2 in enummap:
                    print("ERROR: Duplicate enum %s:\n\t%s = %s @ %s:%u\n\t%s" % (
                        "names" if s1 in enummap else "values",
                        s1, entry.value, entry.origin_file, entry.origin_line,
                        enummap.get(s1) or enummap.get(s2)))
                    return True
                enummap[s1] = enummap[s2] = "%s.%s = %s @ %s:%u" % (enum.name, entry.name, entry.value, entry.origin_file, entry.origin_line)

    return False

def check_missing_enum(xml):
    '''check for enum fields pointing to invalid enums'''

    all_enums = set()
    for x in xml:
        for enum in x.enum:
            all_enums.add(enum.name)
    for x in xml:
        for m in x.message:
            for f in m.fields:
                if f.enum and f.enum not in all_enums:
                    print('Enum %s in %s.%s does not exist' % (f.enum, m.name, f.name))
                    return True
    return False



def total_msgs(xml):
    '''count total number of msgs'''
    count = 0
    for x in xml:
        count += len(x.message)
    return count

def mkdir_p(dir):
    try:
        os.makedirs(dir)
    except OSError as exc:
        if exc.errno != errno.EEXIST:
            raise

# check version consistent
# add test.xml
# finish test suite
# printf style error macro, if defined call errors
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <?xml version="1.0" encoding="ISO-8859-1" ?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">

<!-- definition of simple elements -->
<xs:element name="include" type="xs:anyURI"/>
<xs:element name="version" type="xs:unsignedByte"/>
<xs:element name="dialect" type="xs:unsignedByte"/>
<xs:element name="description" type="xs:string"/>


<!-- definition of attributes -->
<xs:attribute name="name"> <!-- used in enum,entry,message,field elements -->
  <xs:simpleType>
    <xs:restriction base="xs:string">
        <xs:pattern value="[\w_]+"/> <!-- Force only word characters in names (a-zA-Z0-9_ and many unicode). No whitespace -->
    </xs:restriction>
  </xs:simpleType>

</xs:attribute>
<xs:attribute name="id" type="mavlinkMsgId"/> <!-- used in message elements -->
<xs:attribute name="print_format" type="xs:string"/> <!-- used in field elements -->
<xs:attribute name="enum" type="xs:string"/> <!-- used in field,param elements -->
<xs:attribute name="display" type="xs:string"/> <!-- used in field elements -->
<xs:attribute name="units" type="SI_Unit"/> <!-- this will get changed on the fly to xs:string if no strict-units command line option is used -->
<xs:attribute name="instance" type="xs:boolean"/>
<xs:attribute name="invalid" type="xs:string"/> <!-- used in message field elements -->
<xs:attribute name="value"> <!-- used in entry elements -->
  <xs:simpleType>
    <xs:restriction base="xs:string">
        <xs:pattern value="\d{1,20}"/> <!-- base 10 int -->
        <xs:pattern value="0[xX][0-9a-fA-F]{1,16}"/> <!-- base 16 -->
        <xs:pattern value="0[bB][0-1]{1,64}"/> <!-- base 2 -->
        <xs:pattern value="2\*\*\d{1,2}"/> <!-- power of 2 -->
    </xs:restriction>
  </xs:simpleType>
</xs:attribute>
<xs:attribute name="default"> <!-- used in enum field elements -->
  <xs:simpleType>
    <xs:restriction base="xs:string">
        <xs:pattern value="\d{1,20}"/> <!-- base 10 int -->
        <xs:pattern value="0[xX][0-9a-fA-F]{1,16}"/> <!-- base 16 -->
        <xs:pattern value="0[bB][0-1]{1,64}"/> <!-- base 2 -->
        <xs:pattern value="2\*\*\d{1,2}"/> <!-- power of 2 -->
        <xs:pattern value="NaN"/> <!-- Allow not-a-number as a default (for params) -->
    </xs:restriction>
  </xs:simpleType>
</xs:attribute>
<xs:attribute name="type"> <!-- used in field elements -->
  <xs:simpleType>
    <xs:restriction base="xs:string">
        <xs:pattern value="float(\[([0-9])+\])?"/>
        <xs:pattern value="double(\[([0-9])+\])?"/>
        <xs:pattern value="char(\[([0-9])+\])?"/>
        <xs:pattern value="int8_t(\[([0-9])+\])?"/>
        <xs:pattern value="uint8_t(\[([0-9])+\])?"/>
        <xs:pattern value="uint8_t_mavlink_version"/>
        <xs:pattern value="int16_t(\[([0-9])+\])?"/>
        <xs:pattern value="uint16_t(\[([0-9])+\])?"/>
        <xs:pattern value="int32_t(\[([0-9])+\])?"/>
        <xs:pattern value="uint32_t(\[([0-9])+\])?"/>
        <xs:pattern value="int64_t(\[([0-9])+\])?"/>
        <xs:pattern value="uint64_t(\[([0-9])+\])?"/>
        <xs:pattern value="array\[[0-9]+\]"/> <!-- 0.9 compatibility -->
    </xs:restriction>
  </xs:simpleType>
</xs:attribute>
<xs:attribute name="since"> <!-- used in deprecated elements -->
  <xs:simpleType>
    <xs:restriction base="xs:string">
      <xs:pattern value="(20)\d{2}-(0[1-9]|1[012])"/>  <!-- restrict dates to 20YY-MM format -->
    </xs:restriction>
  </xs:simpleType>
</xs:attribute>
<xs:attribute name="replaced_by" type="xs:string"/> <!-- used in deprecated elements -->

<!-- mavlink message IDs are unsigned 24-bit values. -->
<xs:simpleType name="mavlinkMsgId" id="mavlinkMsgId">
  <xs:restriction base="xs:unsignedInt">
    <xs:maxInclusive value="16777215" id="mavlinkMsgId.maxInclusive"/>
  </xs:restriction>
</xs:simpleType>

<xs:simpleType name="SI_Unit">
  <xs:restriction base="xs:string">
    <!-- time -->
    <xs:enumeration value="s"/>        <!-- seconds -->
    <xs:enumeration value="ds"/>       <!-- deciseconds -->
    <xs:enumeration value="cs"/>       <!-- centiseconds -->
    <xs:enumeration value="ms"/>       <!-- milliseconds -->
    <xs:enumeration value="us"/>       <!-- microseconds -->
    <xs:enumeration value="ns"/>       <!-- nanoseconds -->
    <xs:enumeration value="Hz"/>       <!-- Herz -->
    <xs:enumeration value="MHz"/>      <!-- Mega-Herz -->
    <!-- distance -->
    <xs:enumeration value="km"/>       <!-- kilometres -->
    <xs:enumeration value="dam"/>      <!-- decametres -->
    <xs:enumeration value="m"/>        <!-- metres -->
    <xs:enumeration value="m/s"/>      <!-- metres per second -->
    <xs:enumeration value="m/s/s"/>    <!-- metres per second per second -->
    <xs:enumeration value="m/s*5"/>    <!-- metres per second * 5 required from dagar for HIGH_LATENCY2 message -->
    <xs:enumeration value="dm"/>       <!-- decimetres -->
    <xs:enumeration value="dm/s"/>     <!-- decimetres per second -->
    <xs:enumeration value="cm"/>       <!-- centimetres -->
    <xs:enumeration value="cm^2"/>     <!-- centimetres squared (typically used in variance) -->
    <xs:enumeration value="cm/s"/>     <!-- centimetres per second -->
    <xs:enumeration value="mm"/>       <!-- millimetres -->
    <xs:enumeration value="mm/s"/>     <!-- millimetres per second -->
    <xs:enumeration value="mm/h"/>     <!-- millimetres per hour -->
    <!-- temperature -->
    <xs:enumeration value="K"/>        <!-- Kelvin -->
    <xs:enumeration value="degC"/>     <!-- degrees Celsius -->
    <xs:enumeration value="cdegC"/>    <!-- centi degrees Celsius -->
    <!-- angle -->
    <xs:enumeration value="rad"/>      <!-- radians -->
    <xs:enumeration value="rad/s"/>    <!-- radians per second -->
    <xs:enumeration value="mrad/s"/>   <!-- milli-radians per second -->
    <xs:enumeration value="deg"/>      <!-- degrees -->
    <xs:enumeration value="deg/2"/>    <!-- degrees/2 required from dagar for HIGH_LATENCY2 message-->
    <xs:enumeration value="deg/s"/>    <!-- degrees per second -->
    <xs:enumeration value="cdeg"/>     <!-- centidegrees -->
    <xs:enumeration value="cdeg/s"/>   <!-- centidegrees per second -->
    <xs:enumeration value="degE5"/>    <!-- degrees * 1E5 -->
    <xs:enumeration value="degE7"/>    <!-- degrees * 1E7 -->
    <xs:enumeration value="rpm"/>      <!-- rotations per minute -->
    <!-- electricity -->
    <xs:enumeration value="V"/>        <!-- Volt -->
    <xs:enumeration value="cV"/>       <!-- centi-Volt -->
    <xs:enumeration value="mV"/>       <!-- milli-Volt -->
    <xs:enumeration value="A"/>        <!-- Ampere -->
    <xs:enumeration value="cA"/>       <!-- centi-Ampere -->
    <xs:enumeration value="mA"/>       <!-- milli-Ampere -->
    <xs:enumeration value="mAh"/>      <!-- milli-Ampere hour -->
    <xs:enumeration value="Ah"/>       <!-- Ampere hour -->
    <!-- magnetism -->
    <xs:enumeration value="mT"/>       <!-- milli-Tesla -->
    <xs:enumeration value="gauss"/>    <!-- Gauss -->
    <xs:enumeration value="mgauss"/>   <!-- milli-Gauss -->
    <!-- energy -->
    <xs:enumeration value="hJ"/>       <!-- hecto-Joule -->
    <!-- power -->
    <xs:enumeration value="W"/>        <!-- Watt -->
    <!-- force -->
    <xs:enumeration value="mG"/>       <!-- milli-G -->
    <!-- mass -->
    <xs:enumeration value="g"/>        <!-- grams -->
    <xs:enumeration value="kg"/>       <!-- kilograms -->
    <!-- pressure -->
    <xs:enumeration value="Pa"/>       <!-- Pascal -->
    <xs:enumeration value="hPa"/>      <!-- hecto-Pascal -->
    <xs:enumeration value="kPa"/>      <!-- kilo-Pascal -->
    <xs:enumeration value="mbar"/>     <!-- millibar -->
    <!-- ratio -->
    <xs:enumeration value="%"/>        <!-- percent -->
    <xs:enumeration value="d%"/>       <!-- decipercent -->
    <xs:enumeration value="c%"/>       <!-- centipercent -->
    <xs:enumeration value="dB"/>       <!-- Deci-Bell -->
    <xs:enumeration value="dBm"/>      <!-- Deci-Bell-milliwatts-->
    <!-- digital -->
    <xs:enumeration value="KiB"/>      <!-- Kibibyte (1024 bytes) -->
    <xs:enumeration value="KiB/s"/>    <!-- Kibibyte (1024 bytes) per second -->
    <xs:enumeration value="MiB"/>      <!-- Mebibyte (1024*1024 bytes) -->
    <xs:enumeration value="MiB/s"/>    <!-- Mebibyte (1024*1024 bytes) per second -->
    <xs:enumeration value="bytes"/>    <!-- bytes -->
    <xs:enumeration value="bytes/s"/>  <!-- bytes per second-->
    <xs:enumeration value="bits/s"/>   <!-- bits per second -->
    <xs:enumeration value="pix"/>      <!-- pixels -->
    <xs:enumeration value="dpix"/>     <!-- decipixels -->
    <!-- flow -->
    <xs:enumeration value="g/min"/>    <!-- grams/minute -->
    <xs:enumeration value="cm^3/min"/> <!-- cubic centimetres/minute -->
    <!-- volume -->
    <xs:enumeration value="cm^3"/>     <!-- cubic centimetres -->
    <xs:enumeration value="l"/>        <!-- litres -->
  </xs:restriction>
</xs:simpleType>

<!-- definition param elements attributes (like the ones used on MAV_CMD for example) -->
<xs:attribute name="index" type="xs:unsignedByte"/>                    <!-- parameter index -->
<xs:attribute name="label" type="xs:string"/>                          <!-- parameter label (name) -->
<xs:attribute name="decimalPlaces" type="xs:unsignedByte"/>            <!-- parameter number of decimal places to be displayed in the GUI -->
<xs:attribute name="increment" type="xs:float"/>                       <!-- parameter increment -->
<xs:attribute name="minValue" type="xs:float"/>                        <!-- parameter minimum value -->
<xs:attribute name="maxValue" type="xs:float"/>                        <!-- parameter maximum value -->
<xs:attribute name="reserved" type="xs:boolean" default="false"/>      <!-- parameter is reserved -->

<!-- definition entry elements attributes (like the ones used on MAV_CMD for example) -->
<xs:attribute name="hasLocation" type="xs:boolean" default="true"/>    <!-- entry has lat/lon/alt location -->
<xs:attribute name="isDestination" type="xs:boolean" default="true"/>  <!-- entry is a destination -->
<xs:attribute name="missionOnly" type="xs:boolean" default="true"/>  <!-- entry only makes sense in missions, not commands -->

<!-- definition of complex elements -->
<xs:element name="param">
    <xs:complexType mixed="true">
        <xs:attribute ref="index" use="required"/>
        <xs:attribute ref="label"/>
        <xs:attribute ref="units"/>
        <xs:attribute ref="instance"/>
        <xs:attribute ref="enum" />
        <xs:attribute ref="decimalPlaces"/>
        <xs:attribute ref="increment"/>
        <xs:attribute ref="minValue"/>
        <xs:attribute ref="maxValue"/>
        <xs:attribute ref="reserved"/>
        <xs:attribute ref="default"/>
    </xs:complexType>
</xs:element>

<xs:element name="deprecated">
    <xs:complexType mixed="true">
        <xs:sequence>
            <xs:element ref="description" minOccurs="0"/>
        </xs:sequence>
        <xs:attribute ref="since" use="required"/>
        <xs:attribute ref="replaced_by" use="required"/>
    </xs:complexType>
</xs:element>

<xs:element name="wip">
    <xs:complexType mixed="true">
        <xs:sequence>
            <xs:element ref="description" minOccurs="0"/>
        </xs:sequence>
        <xs:attribute ref="since" />
    </xs:complexType>
</xs:element>

<xs:element name="field">
    <xs:complexType mixed="true">
        <xs:sequence>
            <xs:element ref="description" minOccurs="0"/>
        </xs:sequence>
        <xs:attribute ref="type" use="required"/>
        <xs:attribute ref="name" use="required"/>
        <xs:attribute ref="print_format" />
        <xs:attribute ref="enum" />
        <xs:attribute ref="display" />
        <xs:attribute ref="units" />
        <xs:attribute ref="increment"/>
        <xs:attribute ref="minValue"/>
        <xs:attribute ref="maxValue"/>        
        <xs:attribute ref="default" />
        <xs:attribute ref="instance" />
        <xs:attribute ref="invalid" />
    </xs:complexType>
</xs:element>

<xs:element name="extensions">
</xs:element>

<xs:element name="entry">
    <xs:complexType>
        <xs:sequence>
            <xs:choice minOccurs="0" maxOccurs="1">
                <xs:element ref="deprecated"/>
                <xs:element ref="wip"/>
            </xs:choice>
            <xs:element ref="description" minOccurs="0"/>
            <xs:element ref="param" minOccurs="0" maxOccurs="unbounded" />
        </xs:sequence>
        <xs:attribute ref="value" />
        <xs:attribute ref="name" use="required"/>
        <xs:attribute ref="hasLocation"/>
        <xs:attribute ref="isDestination"/>
        <xs:attribute ref="missionOnly"/>
    </xs:complexType>
</xs:element>

<!-- definition entry elements attributes (like the ones used on MAV_CMD for example) -->
<xs:attribute name="bitmask" type="xs:boolean" default="false"/>

<xs:element name="enum">
    <xs:complexType>
        <xs:sequence>
            <xs:choice minOccurs="0" maxOccurs="1">
                <xs:element ref="deprecated"/>
                <xs:element ref="wip"/>
            </xs:choice>
            <xs:element ref="description" minOccurs="0"/>
            <xs:element ref="entry" maxOccurs="unbounded"/>
        </xs:sequence>
        <xs:attribute ref="name" use="required"/>
        <xs:attribute ref="bitmask"/>
    </xs:complexType>
</xs:element>

<xs:element name="message">
    <xs:complexType>
        <xs:sequence>
            <xs:sequence minOccurs="1" maxOccurs="1">
                <xs:choice minOccurs="0" maxOccurs="1">
                    <xs:element ref="deprecated"/>
                    <xs:element ref="wip"/>
                </xs:choice>
                <xs:element ref="description" minOccurs="1" maxOccurs="1"/>
                <xs:element ref="field" minOccurs="1" maxOccurs="unbounded"/>
            </xs:sequence>
            <!-- MavLink 2.0 extensions are optional hence minOccurs="0" -->
            <xs:sequence minOccurs="0" maxOccurs="1">
                <xs:element ref="extensions" minOccurs="1" maxOccurs="1"/>
                <xs:element ref="field" minOccurs="1" maxOccurs="unbounded"/>
            </xs:sequence>
        </xs:sequence>
        <xs:attribute ref="id" use="required"/>
        <xs:attribute ref="name" use="required"/>
    </xs:complexType>
</xs:element>

<xs:element name="enums">
    <xs:complexType>
        <xs:sequence>
            <xs:element ref="enum" maxOccurs="unbounded" minOccurs="0"/>
        </xs:sequence>
    </xs:complexType>
</xs:element>

<xs:element name="messages">
    <xs:complexType>
        <xs:sequence>
            <xs:element ref="message" maxOccurs="unbounded" minOccurs="0"/>
        </xs:sequence>
    </xs:complexType>
</xs:element>

<xs:element name="mavlink">
    <xs:complexType>
        <xs:sequence>
            <xs:element ref="include" minOccurs="0" maxOccurs="unbounded"/>
            <xs:element ref="version" minOccurs="0"/>
            <xs:element ref="dialect" minOccurs="0"/>
            <xs:element ref="enums" minOccurs="0"/>
            <xs:element ref="messages"/>
        </xs:sequence>
        <xs:attribute name="file" type="xs:anyURI"/>
    </xs:complexType>
</xs:element>

</xs:schema>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      #!/usr/bin/env python
'''
simple templating system for mavlink generator

Copyright Andrew Tridgell 2011
Released under GNU GPL version 3 or later
'''

from builtins import object

from .mavparse import MAVParseError

class MAVTemplate(object):
    '''simple templating system'''
    def __init__(self,
                 start_var_token="${", 
                 end_var_token="}", 
                 start_rep_token="${{", 
                 end_rep_token="}}",
                 trim_leading_lf=True,
                 checkmissing=True):
        self.start_var_token = start_var_token
        self.end_var_token = end_var_token
        self.start_rep_token = start_rep_token
        self.end_rep_token = end_rep_token
        self.trim_leading_lf = trim_leading_lf
        self.checkmissing = checkmissing

    def find_end(self, text, start_token, end_token, ignore_end_token=None):
        '''find the of a token.
        Returns the offset in the string immediately after the matching end_token'''
        if not text.startswith(start_token):
            raise MAVParseError("invalid token start")
        offset = len(start_token)
        nesting = 1
        while nesting > 0:
            idx1 = text[offset:].find(start_token)
            idx2 = text[offset:].find(end_token)
            # Check for false positives due to another similar token
            # For example, make sure idx2 points to the second '}' in ${{field: ${name}}}
            if ignore_end_token:
                combined_token = ignore_end_token + end_token
                if text[offset+idx2:offset+idx2+len(combined_token)] == combined_token:
                    idx2 += len(ignore_end_token)
            if idx1 == -1 and idx2 == -1:
                raise MAVParseError("token nesting error")
            if idx1 == -1 or idx1 > idx2:
                offset += idx2 + len(end_token)
                nesting -= 1
            else:
                offset += idx1 + len(start_token)
                nesting += 1
        return offset

    def find_var_end(self, text):
        '''find the of a variable'''
        return self.find_end(text, self.start_var_token, self.end_var_token)

    def find_rep_end(self, text):
        '''find the of a repitition'''
        return self.find_end(text, self.start_rep_token, self.end_rep_token, ignore_end_token=self.end_var_token)

    def substitute(self, text, subvars={},
                   trim_leading_lf=None, checkmissing=None):
        '''substitute variables in a string'''

        if trim_leading_lf is None:
            trim_leading_lf = self.trim_leading_lf
        if checkmissing is None:
            checkmissing = self.checkmissing

        # handle repititions
        while True:
            subidx = text.find(self.start_rep_token)
            if subidx == -1:
                break
            endidx = self.find_rep_end(text[subidx:])
            if endidx == -1:
                raise MAVParseError("missing end macro in %s" % text[subidx:])
            part1 = text[0:subidx]
            part2 = text[subidx+len(self.start_rep_token):subidx+(endidx-len(self.end_rep_token))]
            part3 = text[subidx+endidx:]
            a = part2.split(':')
            field_name = a[0]
            rest = ':'.join(a[1:])
            v = None
            if isinstance(subvars, dict):
                v = subvars.get(field_name, None)
            else:
                v = getattr(subvars, field_name, None)
            if v is None:
                raise MAVParseError('unable to find field %s' % field_name)
            t1 = part1
            for f in v:
                t1 += self.substitute(rest, f, trim_leading_lf=False, checkmissing=False)
            if len(v) != 0 and t1[-1] in ["\n", ","]:
                t1 = t1[:-1]
            t1 += part3
            text = t1
                
        if trim_leading_lf:
            if text[0] == '\n':
                text = text[1:]
        while True:
            idx = text.find(self.start_var_token)
            if idx == -1:
                return text
            endidx = text[idx:].find(self.end_var_token)
            if endidx == -1:
                raise MAVParseError('missing end of variable: %s' % text[idx:idx+10])
            varname = text[idx+2:idx+endidx]
            if isinstance(subvars, dict):
                if not varname in subvars:
                    if checkmissing:
                        raise MAVParseError("unknown variable in '%s%s%s'" % (
                            self.start_var_token, varname, self.end_var_token))
                    return text[0:idx+endidx] + self.substitute(text[idx+endidx:], subvars,
                                                                trim_leading_lf=False, checkmissing=False)
                value = subvars[varname]
            else:
                value = getattr(subvars, varname, None)
                if value is None:
                    if checkmissing:
                        raise MAVParseError("unknown variable in '%s%s%s'" % (
                            self.start_var_token, varname, self.end_var_token))
                    return text[0:idx+endidx] + self.substitute(text[idx+endidx:], subvars,
                                                                trim_leading_lf=False, checkmissing=False)
            text = text.replace("%s%s%s" % (self.start_var_token, varname, self.end_var_token), str(value))
        return text

    def write(self, file, text, subvars={}, trim_leading_lf=True):
        '''write to a file with variable substitution'''
        file.write(self.substitute(text, subvars=subvars, trim_leading_lf=trim_leading_lf))
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      import Foundation

/// Common protocol for all MAVLink entities which describes types
/// metadata properties.
public protocol MAVLinkEntity: CustomStringConvertible, CustomDebugStringConvertible {
    
    /// Original MAVLink enum name (from declarations xml)
    static var typeName: String { get }
    
    /// Compact type description
    static var typeDescription: String { get }
    
    /// Verbose type description
    static var typeDebugDescription: String { get }
}

// MARK: - Enumeration protocol

/// Enumeration protocol description with common for all MAVLink enums
/// properties requirements.
public protocol Enumeration: RawRepresentable, Equatable, MAVLinkEntity {
    
    /// Array with all members of current enum
    static var allMembers: [Self] { get }
    
    // Array with `Name` - `Description` tuples (values from declarations xml file)
    static var membersDescriptions: [(String, String)] { get }
    
    /// `ENUM_END` flag for checking if enum case value is valid
    static var enumEnd: UInt { get }
    
    /// Original MAVLinks enum member name (as declared in definition's xml file)
    var memberName: String { get }
    
    /// Specific member description from definitions xml
    var memberDescription: String { get }
}

/// Enumeration protocol default behaviour implementation.
extension Enumeration {
    public static var typeDebugDescription: String {
        let cases = allMembers.map({ $0.debugDescription }).joined(separator: "\\n\\t")
        return "Enum \(typeName): \(typeDescription)\\nMembers:\\n\\t\(cases)"
    }
    
    public var description: String {
        return memberName
    }
    
    public var debugDescription: String {
        return "\(memberName): \(memberDescription)"
    }
    
    public var memberName: String {
        return Self.membersDescriptions[Self.allMembers.index(of: self)!].0
    }
    
    public var memberDescription: String {
        return Self.membersDescriptions[Self.allMembers.index(of: self)!].1
    }
}

// MARK: - MAVLinkBitmask protocol

public protocol MAVLinkBitmask: OptionSet, MAVLinkEntity {
    /// Array with all members of current bitmask
    static var allMembers: [Self.Element] { get }

    // Array with `Name` - `Description` tuples (values from declarations xml file)
    static var membersDescriptions: [(String, String)] { get }

    /// `ENUM_END` flag for checking if enum case value is valid
    static var enumEnd: UInt { get }

    /// Original MAVLinks enum member name (as declared in definition's xml file)
    var usedMemberName: [String] { get }

    /// Specific member description from definitions xml
    var usedMemberDescriptions: [String] { get }
}

/// MAVLinkBitmask protocol default behaviour implementation.
extension MAVLinkBitmask {
    public static var typeDebugDescription: String {
        let cases = membersDescriptions.map { "\($0.0): \($0.1)" }.joined(separator: "\\n\\t")
        return "Bitmask \(typeName): \(typeDescription)\\nMembers:\\n\\t\(cases)"
    }

    public var description: String {
        return metadataForUsedMembers().map { $0.1 }.joined(separator:", ")
    }

    public var debugDescription: String {
        let usedValuesExplained = metadataForUsedMembers().map {
            "\($0.0): \($0.1)"
            }.joined(separator: "\n")

        return usedValuesExplained
    }

    public var usedMemberName: [String] {
        return metadataForUsedMembers().map { $0.0 }
    }

    public var usedMemberDescriptions: [String] {
        return metadataForUsedMembers().map { $0.1 }
    }

    private func metadataForUsedMembers() -> [(String, String)] {
        return zip(Self.allMembers, Self.membersDescriptions).filter {
                self.contains($0.0)
            }.map {
                $0.1
            }
    }
}

// MARK: - Message protocol

/// Message field definition tuple.
public typealias FieldDefinition = (name: String, offset: Int, type: String, length: UInt, description: String)

/// Message protocol describes all common MAVLink messages properties and
/// methods requirements.
public protocol Message: MAVLinkEntity {
    static var id: UInt8 { get }
    
    static var payloadLength: UInt8 { get }
    
    /// Array of tuples with field definition info
    static var fieldDefinitions: [FieldDefinition] { get }
    
    /// All field's names and values of current Message
    var allFields: [(String, Any)] { get }
    
    /// Initialize Message from received data.
    ///
    /// - parameter data: Data to decode.
    ///
    /// - throws: Throws `ParseError` or `ParseEnumError` if any parsing errors
    /// occur.
    init(data: Data) throws
    
    /// Returns `Data` representation of current `Message` struct guided
    /// by format from `fieldDefinitions`.
    ///
    /// - throws: Throws `PackError` if any of message fields do not comply
    /// format from `fieldDefinitions`.
    ///
    /// - returns: Receiver's `Data` representation
    func pack() throws -> Data
}

/// Message protocol default behaviour implementation.
extension Message {
    public static var payloadLength: UInt8 {
        return messageLengths[id] ?? Packet.Constant.maxPayloadLength
    }
    
    public static var typeDebugDescription: String {
        let fields = fieldDefinitions.map({ "\($0.name): \($0.type): \($0.description)" }).joined(separator: "\n\t")
        return "Struct \(typeName): \(typeDescription)\nFields:\n\t\(fields)"
    }
    
    public var description: String {
        let describeField: ((String, Any)) -> String = { (arg) in
            let (name, value) = arg
            let valueString = value is String ? "\"\(value)\"" : value
            return "\(name): \(valueString)"
        }
        let fieldsDescription = allFields.map(describeField).joined(separator: ", ")
        return "\(type(of: self))(\(fieldsDescription))"
    }
    
    public var debugDescription: String {
        let describeFieldVerbose: ((String, Any)) -> String = { (arg) in
            let (name, value) = arg
            let valueString = value is String ? "\"\(value)\"" : value
            let (_, _, _, _, description) = Self.fieldDefinitions.filter { $0.name == name }.first!
            return "\(name) = \(valueString) : \(description)"
        }
        let fieldsDescription = allFields.map(describeFieldVerbose).joined(separator: "\n\t")
        return "\(Self.typeName): \(Self.typeDescription)\nFields:\n\t\(fieldsDescription)"
    }
    
    public var allFields: [(String, Any)] {
        var result: [(String, Any)] = []
        let mirror = Mirror(reflecting: self)
        for case let (label?, value) in mirror.children {
            result.append((label, value))
        }
        return result
    }
}

// MARK: - Type aliases

public typealias Channel = UInt8

// MARK: - Errors

public protocol MAVLinkError: Error, CustomStringConvertible, CustomDebugStringConvertible { }

// MARK: Parsing error enumeration

/// Parsing errors
public enum ParseError: MAVLinkError {
    
    /// Size of expected number is larger than receiver's data length.
    /// - offset:     Expected number offset in received data.
    /// - size:       Expected number size in bytes.
    /// - upperBound: The number of bytes in the data.
    case valueSizeOutOfBounds(offset: Int, size: Int, upperBound: Int)
    
    /// Data contains non ASCII characters.
    /// - offset: String offset in received data.
    /// - length: Expected length of string to read.
    case invalidStringEncoding(offset: Int, length: Int)
    
    /// Length check of payload for known `messageId` did fail.
    /// - messageId:      Id of expected `Message` type.
    /// - receivedLength: Received payload length.
    /// - properLength:   Expected payload length for `Message` type.
    case invalidPayloadLength(messageId: UInt8, receivedLength: UInt8, expectedLength: UInt8)
    
    /// Received `messageId` was not recognized so we can't create appropriate
    /// `Message`.
    /// - messageId: Id of the message that was not found in the known message
    /// list (`messageIdToClass` array).
    case unknownMessageId(messageId: UInt8)
    
    /// Checksum check failed. Message id is known but calculated CRC bytes
    /// do not match received CRC value.
    /// - messageId: Id of expected `Message` type.
    case badCRC(messageId: UInt8)
}

extension ParseError {
    
    /// Textual representation used when written to output stream.
    public var description: String {
        switch self {
        case .valueSizeOutOfBounds:
            return "ParseError.valueSizeOutOfBounds"
        case .invalidStringEncoding:
            return "ParseError.invalidStringEncoding"
        case .invalidPayloadLength:
            return "ParseError.invalidPayloadLength"
        case .unknownMessageId:
            return "ParseError.unknownMessageId"
        case .badCRC:
            return "ParseError.badCRC"
        }
    }
    
    /// Debug textual representation used when written to output stream, which
    /// includes all associated values and their labels.
    public var debugDescription: String {
        switch self {
        case let .valueSizeOutOfBounds(offset, size, upperBound):
            return "ParseError.valueSizeOutOfBounds(offset: \(offset), size: \(size), upperBound: \(upperBound))"
        case let .invalidStringEncoding(offset, length):
            return "ParseError.invalidStringEncoding(offset: \(offset), length: \(length))"
        case let .invalidPayloadLength(messageId, receivedLength, expectedLength):
            return "ParseError.invalidPayloadLength(messageId: \(messageId), receivedLength: \(receivedLength), expectedLength: \(expectedLength))"
        case let .unknownMessageId(messageId):
            return "ParseError.unknownMessageId(messageId: \(messageId))"
        case let .badCRC(messageId):
            return "ParseError.badCRC(messageId: \(messageId))"
        }
    }
}

// MARK: Parsing enumeration error

/// Special error type for returning Enum parsing errors with details in associated
/// values (types of these values are not compatible with `ParseError` enum).
public enum ParseEnumError<T: RawRepresentable>: MAVLinkError {
    
    /// Enumeration case with `rawValue` at `valueOffset` was not found in
    /// `enumType` enumeration.
    /// - enumType: Type of expected enumeration.
    /// - rawValue: Raw value that was not found in `enumType`.
    /// - valueOffset: Value offset in received payload data.
    case unknownValue(enumType: T.Type, rawValue: T.RawValue, valueOffset: Int)
}

extension ParseEnumError {
    
    /// Textual representation used when written to the output stream.
    public var description: String {
        switch self {
        case .unknownValue:
            return "ParseEnumError.unknownValue"
        }
    }
    
    /// Debug textual representation used when written to the output stream, which
    /// includes all associated values and their labels.
    public var debugDescription: String {
        switch self {
        case let .unknownValue(enumType, rawValue, valueOffset):
            return "ParseEnumError.unknownValue(enumType: \(enumType), rawValue: \(rawValue), valueOffset: \(valueOffset))"
        }
    }
}

// MARK: Packing errors

/// Errors that can occur while packing `Message` for sending.
public enum PackError: MAVLinkError {
    
    /// Size of received value (together with offset) is out of receiver's length.
    /// - offset:     Expected value offset in payload.
    /// - size:       Provided field value size in bytes.
    /// - upperBound: Available payload length.
    case valueSizeOutOfBounds(offset: Int, size: Int, upperBound: Int)
    
    /// Length check for provided field value did fail.
    /// - offset:              Expected value offset in payload.
    /// - providedValueLength: Count of elements (characters) in provided value.
    /// - allowedLength:       Maximum number of elements (characters) allowed in field.
    case invalidValueLength(offset: Int, providedValueLength: Int, allowedLength: Int)
    
    /// String field contains non ASCII characters.
    /// - offset: Expected value offset in payload.
    /// - string: Original string.
    case invalidStringEncoding(offset: Int, string: String)
    
 