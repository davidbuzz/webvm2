aximum_line_length), expected_output)

    def test_create_doc_dict(self):
        # Mock XML data
        xml_data = '''
        <root>
            <param name="PARAM1" humanName="Param 1" documentation="Documentation for Param 1">
                <field name="Field1">Value1</field>
                <field name="Field2">Value2</field>
                <values>
                    <value code="Code1">Value1</value>
                    <value code="Code2">Value2</value>
                </values>
            </param>
            <param name="PARAM2" humanName="Param 2" documentation="Documentation for Param 2">
                <field name="Units">m/s</field>
                <field name="UnitText">meters per second</field>
                <values>
                    <value code="Code3">Value3</value>
                    <value code="Code4">Value4</value>
                </values>
            </param>
        </root>
        '''
        root = ET.fromstring(xml_data)

        # Expected output
        expected_output = {
            "PARAM1": {
                "humanName": "Param 1",
                "documentation": ["Documentation for Param 1"],
                "fields": {"Field1": "Value1", "Field2": "Value2"},
                "values": {"Code1": "Value1", "Code2": "Value2"}
            },
            "PARAM2": {
                "humanName": "Param 2",
                "documentation": ["Documentation for Param 2"],
                "fields": {"Units": "m/s (meters per second)"},
                "values": {"Code3": "Value3", "Code4": "Value4"}
            }
        }

        # Call the function with the mock XML data
        result = create_doc_dict(root, "VehicleType")

        # Check the result
        self.assertEqual(result, expected_output)

    def test_format_columns(self):
        # Define the input
        values = {
            "Key1": "Value1",
            "Key2": "Value2",
            "Key3": "Value3",
            "Key4": "Value4",
            "Key5": "Value5",
            "Key6": "Value6",
            "Key7": "Value7",
            "Key8": "Value8",
            "Key9": "Value9",
            "Key10": "Value10",
            "Key11": "Value11",
            "Key12": "Value12",
        }

        # Define the expected output
        expected_output = [
            'Key1: Value1                                         Key7: Value7',
            'Key2: Value2                                         Key8: Value8',
            'Key3: Value3                                         Key9: Value9',
            'Key4: Value4                                         Key10: Value10',
            'Key5: Value5                                         Key11: Value11',
            'Key6: Value6                                         Key12: Value12',
        ]

        # Call the function with the input
        result = format_columns(values)

        # Check the result
        self.assertEqual(result, expected_output)

        self.assertEqual(format_columns({}), [])

    def test_update_parameter_documentation(self):
        # Write some initial content to the temporary file
        with open(self.temp_file.name, "w", encoding="utf-8") as file:
            file.write("PARAM1 100\n")

        # Call the function with the temporary file
        update_parameter_documentation(self.doc_dict, self.temp_file.name)

        # Read the updated content from the temporary file
        with open(self.temp_file.name, "r", encoding="utf-8") as file:
            updated_content = file.read()

        # Check if the file has been updated correctly
        self.assertIn("Param 1", updated_content)
        self.assertIn("Documentation for Param 1", updated_content)
        self.assertIn("Field1: Value1", updated_content)
        self.assertIn("Field2: Value2", updated_content)
        self.assertIn("Code1: Value1", updated_content)
        self.assertIn("Code2: Value2", updated_content)

    def test_update_parameter_documentation_sorting_none(self):
        # Write some initial content to the temporary file
        # With stray leading and trailing whitespaces
        with open(self.temp_file.name, "w", encoding="utf-8") as file:
            file.write("PARAM2 100\n PARAM_1 100 \nPARAM3 3\nPARAM4 4\nPARAM5 5\nPARAM1 100\n")

        # Call the function with the temporary file
        update_parameter_documentation(self.doc_dict, self.temp_file.name)

        # Read the updated content from the temporary file
        with open(self.temp_file.name, "r", encoding="utf-8") as file:
            updated_content = file.read()

        expected_content = '''# Param 2
# Documentation for Param 2
# Field3: Value3
# Field4: Value4
# Code3: Value3
# Code4: Value4
PARAM2 100

# Param _ 1
# Documentation for Param_1
# Field_1: Value_1
# Field_2: Value_2
# Code_1: Value_1
# Code_2: Value_2
PARAM_1 100
PARAM3 3
PARAM4 4
PARAM5 5

# Param 1
# Documentation for Param 1
# Field1: Value1
# Field2: Value2
# Code1: Value1
# Code2: Value2
PARAM1 100
'''
        self.assertEqual(updated_content, expected_content)

    def test_update_parameter_documentation_sorting_missionplanner(self):
        # Write some initial content to the temporary file
        with open(self.temp_file.name, "w", encoding="utf-8") as file:
            file.write("PARAM2 100 # ignore, me\nPARAM_1\t100\nPARAM1,100\n")

        # Call the function with the temporary file
        update_parameter_documentation(self.doc_dict, self.temp_file.name, "missionplanner")

        # Read the updated content from the temporary file
        with open(self.temp_file.name, "r", encoding="utf-8") as file:
            updated_content = file.read()

        expected_content = '''# Param _ 1
# Documentation for Param_1
# Field_1: Value_1
# Field_2: Value_2
# Code_1: Value_1
# Code_2: Value_2
PARAM_1\t100

# Param 1
# Documentation for Param 1
# Field1: Value1
# Field2: Value2
# Code1: Value1
# Code2: Value2
PARAM1,100

# Param 2
# Documentation for Param 2
# Field3: Value3
# Field4: Value4
# Code3: Value3
# Code4: Value4
PARAM2 100 # ignore, me
'''
        self.assertEqual(updated_content, expected_content)

    def test_update_parameter_documentation_sorting_mavproxy(self):
        # Write some initial content to the temporary file
        with open(self.temp_file.name, "w", encoding="utf-8") as file:
            file.write("PARAM2 100\nPARAM_1\t100\nPARAM1,100\n")

        # Call the function with the temporary file
        update_parameter_documentation(self.doc_dict, self.temp_file.name, "mavproxy")

        # Read the updated content from the temporary file
        with open(self.temp_file.name, "r", encoding="utf-8") as file:
            updated_content = file.read()

        expected_content = '''# Param 1
# Documentation for Param 1
# Field1: Value1
# Field2: Value2
# Code1: Value1
# Code2: Value2
PARAM1,100

# Param 2
# Documentation for Param 2
# Field3: Value3
# Field4: Value4
# Code3: Value3
# Code4: Value4
PARAM2 100

# Param _ 1
# Documentation for Param_1
# Field_1: Value_1
# Field_2: Value_2
# Code_1: Value_1
# Code_2: Value_2
PARAM_1\t100
'''
        self.assertEqual(updated_content, expected_content)

    def test_update_parameter_documentation_invalid_line_format(self):
        # Write some initial content to the temporary file with an invalid line format
        with open(self.temp_file.name, "w", encoding="utf-8") as file:
            file.write("%INVALID_LINE_FORMAT\n")

        # Call the function with the temporary file
        with self.assertRaises(SystemExit) as cm:
            update_parameter_documentation(self.doc_dict, self.temp_file.name)

        # Check if the SystemExit exception contains the expected message
        self.assertEqual(cm.exception.code, "Invalid line in input file")

    @patch('logging.Logger.info')
    def test_print_read_only_params(self, mock_info):
        # Mock XML data
        xml_data = '''
        <root>
            <param name="PARAM1" humanName="Param 1" documentation="Documentation for Param 1">
                <field name="ReadOnly">True</field>
                <field name="Field1">Value1</field>
                <field name="Field2">Value2</field>
                <values>
                    <value code="Code1">Value1</value>
                    <value code="Code2">Value2</value>
                </values>
            </param>
            <param name="PARAM2" humanName="Param 2" documentation="Documentation for Param 2">
                <field name="Field3">Value3</field>
                <field name="Field4">Value4</field>
                <values>
                    <value code="Code3">Value3</value>
                    <value code="Code4">Value4</value>
                </values>
            </param>
        </root>
        '''
        root = ET.fromstring(xml_data)
        doc_dict = create_doc_dict(root, "VehicleType")

        # Call the function with the mock XML data
        print_read_only_params(doc_dict)

        # Check if the parameter name was logged
        mock_info.assert_has_calls([mock.call('ReadOnly parameters:'), mock.call('PARAM1')])

    def test_update_parameter_documentation_invalid_target(self):
        # Call the function with an invalid target
        with self.assertRaises(ValueError):
            update_parameter_documentation(self.doc_dict, "invalid_target")

    def test_invalid_parameter_name(self):
        # Write some initial content to the temporary file
        with open(self.temp_file.name, "w", encoding="utf-8") as file:
            file.write("INVALID_$PARAM 100\n")

        # Call the function with the temporary file
        with self.assertRaises(SystemExit):
            update_parameter_documentation(self.doc_dict, self.temp_file.name)

    def test_update_parameter_documentation_too_long_parameter_name(self):
        # Write some initial content to the temporary file
        with open(self.temp_file.name, "w", encoding="utf-8") as file:
            file.write("TOO_LONG_PARAMETER_NAME 100\n")

        # Call the function with the temporary file
        with self.assertRaises(SystemExit):
            update_parameter_documentation(self.doc_dict, self.temp_file.name)

    @patch('logging.Logger.warning')
    def test_missing_parameter_documentation(self, mock_warning):
        # Write some initial content to the temporary file
        with open(self.temp_file.name, "w", encoding="utf-8") as file:
            file.write("MISSING_DOC_PARA 100\n")

        # Call the function with the temporary file
        update_parameter_documentation(self.doc_dict, self.temp_file.name)

        # Check if the warnings were logged
        mock_warning.assert_has_calls([
            mock.call('Read file %s with %d parameters, but only %s of which got documented', self.temp_file.name, 1, 0),
            mock.call('No documentation found for: %s', 'MISSING_DOC_PARA')
        ])

    def test_empty_parameter_file(self):
        # Call the function with the temporary file
        update_parameter_documentation(self.doc_dict, self.temp_file.name)

        # Read the updated content from the temporary file
        with open(self.temp_file.name, "r", encoding="utf-8") as file:
            updated_content = file.read()

        # Check if the file is still empty
        self.assertEqual(updated_content, "")


if __name__ == '__main__':
    unittest.main()
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      #!/usr/bin/python3

'''
Extracts parameter default values from an ArduPilot .bin log file. Unittests.

AP_FLAKE8_CLEAN

Amilcar do Carmo Lucas, IAV GmbH
'''

import unittest
from unittest.mock import patch, MagicMock
from extract_param_defaults import extract_parameter_default_values, missionplanner_sort, \
                                   mavproxy_sort, sort_params, output_params, parse_arguments, \
                                   NO_DEFAULT_VALUES_MESSAGE, MAVLINK_SYSID_MAX, MAVLINK_COMPID_MAX


class TestArgParseParameters(unittest.TestCase):
    def test_command_line_arguments_combinations(self):
        # Check the 'format' and 'sort' default parameters
        args = parse_arguments(['dummy.bin'])
        self.assertEqual(args.format, 'missionplanner')
        self.assertEqual(args.sort, 'missionplanner')

        # Check the 'format' and 'sort' parameters to see if 'sort' can be explicitly overwritten
        args = parse_arguments(['-s', 'none', 'dummy.bin'])
        self.assertEqual(args.format, 'missionplanner')
        self.assertEqual(args.sort, 'none')

        # Check the 'format' and 'sort' parameters to see if 'sort' can be implicitly overwritten (mavproxy)
        args = parse_arguments(['-f', 'mavproxy', 'dummy.bin'])
        self.assertEqual(args.format, 'mavproxy')
        self.assertEqual(args.sort, 'mavproxy')

        # Check the 'format' and 'sort' parameters to see if 'sort' can be implicitly overwritten (qgcs)
        args = parse_arguments(['-f', 'qgcs', 'dummy.bin'])
        self.assertEqual(args.format, 'qgcs')
        self.assertEqual(args.sort, 'qgcs')

        # Check the 'format' and 'sort' parameters
        args = parse_arguments(['-f', 'mavproxy', '-s', 'none', 'dummy.bin'])
        self.assertEqual(args.format, 'mavproxy')
        self.assertEqual(args.sort, 'none')

        # Assert that a SystemExit is raised when --sysid is used without --format set to qgcs
        with self.assertRaises(SystemExit):
            with patch('builtins.print') as mock_print:
                parse_arguments(['-f', 'mavproxy', '-i', '7', 'dummy.bin'])
                mock_print.assert_called_once_with("--sysid parameter is only relevant if --format is qgcs")

        # Assert that a SystemExit is raised when --compid is used without --format set to qgcs
        with self.assertRaises(SystemExit):
            with patch('builtins.print') as mock_print:
                parse_arguments(['-f', 'missionplanner', '-c', '3', 'dummy.bin'])
                mock_print.assert_called_once_with("--compid parameter is only relevant if --format is qgcs")

        # Assert that a valid sysid and compid are parsed correctly
        args = parse_arguments(['-f', 'qgcs', '-i', '7', '-c', '3', 'dummy.bin'])
        self.assertEqual(args.format, 'qgcs')
        self.assertEqual(args.sort, 'qgcs')
        self.assertEqual(args.sysid, 7)
        self.assertEqual(args.compid, 3)


class TestExtractParameterDefaultValues(unittest.TestCase):

    @patch('extract_param_defaults.mavutil.mavlink_connection')
    def test_logfile_does_not_exist(self, mock_mavlink_connection):
        # Mock the mavlink connection to raise an exception
        mock_mavlink_connection.side_effect = Exception("Test exception")

        # Call the function with a dummy logfile path
        with self.assertRaises(SystemExit) as cm:
            extract_parameter_default_values('dummy.bin')

        # Check the error message
        self.assertEqual(str(cm.exception), "Error opening the dummy.bin logfile: Test exception")

    @patch('extract_param_defaults.mavutil.mavlink_connection')
    def test_extract_parameter_default_values(self, mock_mavlink_connection):
        # Mock the mavlink connection and the messages it returns
        mock_mlog = MagicMock()
        mock_mavlink_connection.return_value = mock_mlog
        mock_mlog.recv_match.side_effect = [
            MagicMock(Name='PARAM1', Default=1.1),
            MagicMock(Name='PARAM2', Default=2.0),
            None  # End of messages
        ]

        # Call the function with a dummy logfile path
        defaults = extract_parameter_default_values('dummy.bin')

        # Check if the defaults dictionary contains the correct parameters and values
        self.assertEqual(defaults, {'PARAM1': 1.1, 'PARAM2': 2.0})

    @patch('extract_param_defaults.mavutil.mavlink_connection')
    def test_no_parameters(self, mock_mavlink_connection):
        # Mock the mavlink connection to return no parameter messages
        mock_mlog = MagicMock()
        mock_mavlink_connection.return_value = mock_mlog
        mock_mlog.recv_match.return_value = None  # No PARM messages

        # Call the function with a dummy logfile path and assert SystemExit is raised with the correct message
        with self.assertRaises(SystemExit) as cm:
            extract_parameter_default_values('dummy.bin')
        self.assertEqual(str(cm.exception), NO_DEFAULT_VALUES_MESSAGE)

    @patch('extract_param_defaults.mavutil.mavlink_connection')
    def test_no_parameter_defaults(self, mock_mavlink_connection):
        # Mock the mavlink connection to simulate no parameter default values in the .bin file
        mock_mlog = MagicMock()
        mock_mavlink_connection.return_value = mock_mlog
        mock_mlog.recv_match.return_value = None  # No PARM messages

        # Call the function with a dummy logfile path and assert SystemExit is raised with the correct message
        with self.assertRaises(SystemExit) as cm:
            extract_parameter_default_values('dummy.bin')
        self.assertEqual(str(cm.exception), NO_DEFAULT_VALUES_MESSAGE)

    @patch('extract_param_defaults.mavutil.mavlink_connection')
    def test_invalid_parameter_name(self, mock_mavlink_connection):
        # Mock the mavlink connection to simulate an invalid parameter name
        mock_mlog = MagicMock()
        mock_mavlink_connection.return_value = mock_mlog
        mock_mlog.recv_match.return_value = MagicMock(Name='INVALID_NAME%', Default=1.0)

        # Call the function with a dummy logfile path
        with self.assertRaises(SystemExit):
            extract_parameter_default_values('dummy.bin')

    @patch('extract_param_defaults.mavutil.mavlink_connection')
    def test_long_parameter_name(self, mock_mavlink_connection):
        # Mock the mavlink connection to simulate a too long parameter name
        mock_mlog = MagicMock()
        mock_mavlink_connection.return_value = mock_mlog
        mock_mlog.recv_match.return_value = MagicMock(Name='TOO_LONG_PARAMETER_NAME', Default=1.0)

        # Call the function with a dummy logfile path
        with self.assertRaises(SystemExit):
            extract_parameter_default_values('dummy.bin')


class TestSortFunctions(unittest.TestCase):
    def test_missionplanner_sort(self):
        # Define a list of parameter names
        params = ['PARAM_GROUP1_PARAM1', 'PARAM_GROUP2_PARAM2', 'PARAM_GROUP1_PARAM2']

        # Sort the parameters using the missionplanner_sort function
        sorted_params = sorted(params, key=missionplanner_sort)

        # Check if the parameters were sorted correctly
        self.assertEqual(sorted_params, ['PARAM_GROUP1_PARAM1', 'PARAM_GROUP1_PARAM2', 'PARAM_GROUP2_PARAM2'])

        # Test with a parameter name that doesn't contain an underscore
        params = ['PARAM1', 'PARAM3', 'PARAM2']
        sorted_params = sorted(params, key=missionplanner_sort)
        self.assertEqual(sorted_params, ['PARAM1', 'PARAM2', 'PARAM3'])

    def test_mavproxy_sort(self):
        # Define a list of parameter names
        params = ['PARAM_GROUP1_PARAM1', 'PARAM_GROUP2_PARAM2', 'PARAM_GROUP1_PARAM2']

        # Sort the parameters using the mavproxy_sort function
        sorted_params = sorted(params, key=mavproxy_sort)

        # Check if the parameters were sorted correctly
        self.assertEqual(sorted_params, ['PARAM_GROUP1_PARAM1', 'PARAM_GROUP1_PARAM2', 'PARAM_GROUP2_PARAM2'])

        # Test with a parameter name that doesn't contain an underscore
        params = ['PARAM1', 'PARAM3', 'PARAM2']
        sorted_params = sorted(params, key=mavproxy_sort)
        self.assertEqual(sorted_params, ['PARAM1', 'PARAM2', 'PARAM3'])


class TestOutputParams(unittest.TestCase):

    @patch('extract_param_defaults.print')
    def test_output_params(self, mock_print):
        # Prepare a dummy defaults dictionary
        defaults = {'PARAM2': 1.0, 'PARAM1': 2.0}

        # Call the function with the dummy dictionary, 'missionplanner' format type
        output_params(defaults, 'missionplanner')

        # Check if the print function was called with the correct parameters
        expected_calls = [unittest.mock.call('PARAM2,1'), unittest.mock.call('PARAM1,2')]
        mock_print.assert_has_calls(expected_calls, any_order=False)

    @patch('extract_param_defaults.print')
    def test_output_params_missionplanner_non_numeric(self, mock_print):
        # Prepare a dummy defaults dictionary
        defaults = {'PARAM1': 'non-numeric'}

        # Call the function with the dummy dictionary, 'missionplanner' format type
        output_params(defaults, 'missionplanner')

        # Check if the print function was called with the correct parameters
        expected_calls = [unittest.mock.call('PARAM1,non-numeric')]
        mock_print.assert_has_calls(expected_calls, any_order=False)

    @patch('extract_param_defaults.print')
    def test_output_params_mavproxy(self, mock_print):
        # Prepare a dummy defaults dictionary
        defaults = {'PARAM2': 2.0, 'PARAM1': 1.0}

        # Call the function with the dummy dictionary, 'mavproxy' format type and 'mavproxy' sort type
        defaults = sort_params(defaults, 'mavproxy')
        output_params(defaults, 'mavproxy')

        # Check if the print function was called with the correct parameters
        expected_calls = [unittest.mock.call("%-15s %.6f" % ('PARAM1', 1.0)),
                          unittest.mock.call("%-15s %.6f" % ('PARAM2', 2.0))]
        mock_print.assert_has_calls(expected_calls, any_order=False)

    @patch('extract_param_defaults.print')
    def test_output_params_qgcs(self, mock_print):
        # Prepare a dummy defaults dictionary
        defaults = {'PARAM2': 2.0, 'PARAM1': 1.0}

        # Call the function with the dummy dictionary, 'qgcs' format type and 'qgcs' sort type
        defaults = sort_params(defaults, 'qgcs')
        output_params(defaults, 'qgcs')

        # Check if the print function was called with the correct parameters
        expected_calls = [unittest.mock.call("\n# # Vehicle-Id Component-Id Name Value Type\n"),
                          unittest.mock.call("%u %u %-15s %.6f %u" % (1, 1, 'PARAM1', 1.0, 9)),
                          unittest.mock.call("%u %u %-15s %.6f %u" % (1, 1, 'PARAM2', 2.0, 9))]
        mock_print.assert_has_calls(expected_calls, any_order=False)

    @patch('extract_param_defaults.print')
    def test_output_params_qgcs_2_4(self, mock_print):
        # Prepare a dummy defaults dictionary
        defaults = {'PARAM2': 2.0, 'PARAM1': 1.0}

        # Call the function with the dummy dictionary, 'qgcs' format type and 'qgcs' sort type
        defaults = sort_params(defaults, 'qgcs')
        output_params(defaults, 'qgcs', 2, 4)

        # Check if the print function was called with the correct parameters
        expected_calls = [unittest.mock.call("\n# # Vehicle-Id Component-Id Name Value Type\n"),
                          unittest.mock.call("%u %u %-15s %.6f %u" % (2, 4, 'PARAM1', 1.0, 9)),
                          unittest.mock.call("%u %u %-15s %.6f %u" % (2, 4, 'PARAM2', 2.0, 9))]
        mock_print.assert_has_calls(expected_calls, any_order=False)

    @patch('extract_param_defaults.print')
    def test_output_params_qgcs_SYSID_THISMAV(self, mock_print):
        # Prepare a dummy defaults dictionary
        defaults = {'PARAM2': 2.0, 'PARAM1': 1.0, 'SYSID_THISMAV': 3.0}

        # Call the function with the dummy dictionary, 'qgcs' format type and 'qgcs' sort type
        defaults = sort_params(defaults, 'qgcs')
        output_params(defaults, 'qgcs', -1, 7)

        # Check if the print function was called with the correct parameters
        expected_calls = [unittest.mock.call("\n# # Vehicle-Id Component-Id Name Value Type\n"),
                          unittest.mock.call("%u %u %-15s %.6f %u" % (3, 7, 'PARAM1', 1.0, 9)),
                          unittest.mock.call("%u %u %-15s %.6f %u" % (3, 7, 'PARAM2', 2.0, 9)),
                          unittest.mock.call("%u %u %-15s %.6f %u" % (3, 7, 'SYSID_THISMAV', 3.0, 9))]
        mock_print.assert_has_calls(expected_calls, any_order=False)

    @patch('extract_param_defaults.print')
    def test_output_params_qgcs_SYSID_INVALID(self, mock_print):
        # Prepare a dummy defaults dictionary
        defaults = {'PARAM2': 2.0, 'PARAM1': 1.0, 'SYSID_THISMAV': -1.0}

        # Assert that a SystemExit is raised with the correct message when an invalid sysid is used
        with self.assertRaises(SystemExit) as cm:
            defaults = sort_params(defaults, 'qgcs')
            output_params(defaults, 'qgcs', -1, 7)
        self.assertEqual(str(cm.exception), "Invalid system ID parameter -1 must not be negative")

        # Assert that a SystemExit is raised with the correct message when an invalid sysid is used
        with self.assertRaises(SystemExit) as cm:
            defaults = sort_params(defaults, 'qgcs')
            output_params(defaults, 'qgcs', MAVLINK_SYSID_MAX+2, 7)
        self.assertEqual(str(cm.exception), f"Invalid system ID parameter 16777218 must be smaller than {MAVLINK_SYSID_MAX}")

    @patch('extract_param_defaults.print')
    def test_output_params_qgcs_COMPID_INVALID(self, mock_print):
        # Prepare a dummy defaults dictionary
        defaults = {'PARAM2': 2.0, 'PARAM1': 1.0}

        # Assert that a SystemExit is raised with the correct message when an invalid compid is used
        with self.assertRaises(SystemExit) as cm:
            defaults = sort_params(defaults, 'qgcs')
            output_params(defaults, 'qgcs', -1, -3)
        self.assertEqual(str(cm.exception), "Invalid component ID parameter -3 must not be negative")

        # Assert that a SystemExit is raised with the correct message when an invalid compid is used
        with self.assertRaises(SystemExit) as cm:
            defaults = sort_params(defaults, 'qgcs')
            output_params(defaults, 'qgcs', 1, MAVLINK_COMPID_MAX+3)
        self.assertEqual(str(cm.exception), f"Invalid component ID parameter 259 must be smaller than {MAVLINK_COMPID_MAX}")

    @patch('extract_param_defaults.print')
    def test_output_params_integer(self, mock_print):
        # Prepare a dummy defaults dictionary with an integer value
        defaults = {'PARAM1': 1.01, 'PARAM2': 2.00}

        # Call the function with the dummy dictionary, 'missionplanner' format type and 'missionplanner' sort type
        defaults = sort_params(defaults, 'missionplanner')
        output_params(defaults, 'missionplanner')

        # Check if the print function was called with the correct parameters
        expected_calls = [unittest.mock.call('PARAM1,1.01'), unittest.mock.call('PARAM2,2')]
        mock_print.assert_has_calls(expected_calls, any_order=False)


if __name__ == '__main__':
    unittest.main()
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               #!/usr/bin/env python

'''
Check Tools/bootloader/board_types.txt for problems

AP_FLAKE8_CLEAN

'''

import re


class ValidateBoardList(object):

    class BoardType(object):
        def __init__(self, name, board_id):
            self.name = name
            self.board_id = board_id

    def __init__(self):
        self.filepath = "Tools/AP_Bootloader/board_types.txt"

    def read_filepath(self, filepath):
        '''return contents of filepath'''
        content = ""
        with open(filepath) as fh:
            content += fh.read()
            fh.close()
        return content

    def parse_filepath_content(self, filepath):
        '''read contents of filepath, returns a list of (id, name) tuples'''
        content = self.read_filepath(filepath)
        ret = []
        for line in content.split("\n"):
            # strip comments:
            line = re.sub("#.*", "", line)
            # remove empty lines:
            if not len(line) or line.isspace():
                continue
            # remove trailing whitespace
            line = line.rstrip()
            m = re.match(r"^(.*?)\s+(\d+)$", line)
            if m is None:
                raise ValueError("Failed to match (%s)" % line)
            print("line: (%s)" % str(line))
            ret.append((int(m.group(2)), m.group(1)))
        return ret

    def validate_filepath_content(self, tuples):
        '''validate a list of (id, name) tuples'''

        # a list of board IDs which can map to multiple names for
        # historical reasons:
        board_id_whitelist = frozenset([
            9,  # fmuv2 and fmuv3
            10, # TARGET_HW_PX4_FMU_V4_PRO and TARGET_HW_PX4_PIO_V3
            13, # TARGET_HW_PX4_FMU_V4_PRO and TARGET_HW_PX4_PIO_V3
            29, # TARGET_HW_AV_V1 and TARGET_HW_AV_X_V1
            51, # TARGET_HW_PX4_FMU_V5X and Reserved  PX4 [BL] FMU v5X.x
            52, # TARGET_HW_PX4_FMU_V6 and Reserved "PX4 [BL] FMU v6.x"
            53, # TARGET_HW_PX4_FMU_V6X and Reserved "PX4 [BL] FMU v6X.x"
            57, # TARGET_HW_ARK_FMU_V6X and Reserved "ARK [BL] FMU v6X.x"
            80, # TARGET_HW_ARK_CAN_FLOW and Reserved "ARK CAN FLOW"
            20, # TARGET_HW_UVIFY_CORE and AP_HW_F4BY
        ])

        dict_by_id = {}
        dict_by_name = {}
        for (board_id, name) in tuples:
            print("Checking (%u, %s)" % (board_id, name))
            if board_id in dict_by_id and board_id not in board_id_whitelist:
                raise ValueError("Duplicate ID %s in file for (%s) and (%s)" %
                                 (board_id, dict_by_id[board_id], name))
            if name in dict_by_name:
                raise ValueError("Duplicate name %s in file for (%s) and (%s)" %
                                 (name, dict_by_name[name], board_id))
            dict_by_name[name] = board_id
            dict_by_id[board_id] = name

    def run(self):
        parsed = self.parse_filepath_content(self.filepath)
        self.validate_filepath_content(parsed)
        return 0


if __name__ == '__main__':
    validator = ValidateBoardList()
    validator.run()
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               '''
Common base class for each of the autotest suites

AP_FLAKE8_CLEAN

'''
from __future__ import print_function

import abc
import copy
import errno
import glob
import math
import os
import re
import shutil
import signal
import sys
import time
import traceback
from datetime import datetime
from typing import List
from typing import Tuple
from typing import Dict
import importlib.util

import pexpect
import fnmatch
import operator
import numpy
import socket
import struct
import random
import tempfile
import threading
import enum
from inspect import currentframe, getframeinfo
from pathlib import Path

from MAVProxy.modules.lib import mp_util
from MAVProxy.modules.lib import mp_elevation

from pymavlink import mavparm
from pymavlink import mavwp, mavutil, DFReader
from pymavlink import mavextra
from pymavlink.rotmat import Vector3
from pymavlink import quaternion
from pymavlink.generator import mavgen

from pysim import util, vehicleinfo

try:
    import queue as Queue
except ImportError:
    import Queue


# Enumeration convenience class for mavlink POSITION_TARGET_TYPEMASK
class MAV_POS_TARGET_TYPE_MASK(enum.IntEnum):
    POS_IGNORE = (mavutil.mavlink.POSITION_TARGET_TYPEMASK_X_IGNORE |
                  mavutil.mavlink.POSITION_TARGET_TYPEMASK_Y_IGNORE |
                  mavutil.mavlink.POSITION_TARGET_TYPEMASK_Z_IGNORE)
    VEL_IGNORE = (mavutil.mavlink.POSITION_TARGET_TYPEMASK_VX_IGNORE |
                  mavutil.mavlink.POSITION_TARGET_TYPEMASK_VY_IGNORE |
                  mavutil.mavlink.POSITION_TARGET_TYPEMASK_VZ_IGNORE)
    ACC_IGNORE = (mavutil.mavlink.POSITION_TARGET_TYPEMASK_AX_IGNORE |
                  mavutil.mavlink.POSITION_TARGET_TYPEMASK_AY_IGNORE |
                  mavutil.mavlink.POSITION_TARGET_TYPEMASK_AZ_IGNORE)
    FORCE_SET  = mavutil.mavlink.POSITION_TARGET_TYPEMASK_FORCE_SET
    YAW_IGNORE = mavutil.mavlink.POSITION_TARGET_TYPEMASK_YAW_IGNORE
    YAW_RATE_IGNORE = mavutil.mavlink.POSITION_TARGET_TYPEMASK_YAW_RATE_IGNORE
    POS_ONLY   = VEL_IGNORE | ACC_IGNORE | YAW_IGNORE | YAW_RATE_IGNORE
    LAST_BYTE  = 0xF000


MAV_FRAMES_TO_TEST = [
    mavutil.mavlink.MAV_FRAME_GLOBAL,
    mavutil.mavlink.MAV_FRAME_GLOBAL_INT,
    mavutil.mavlink.MAV_FRAME_GLOBAL_RELATIVE_ALT,
    mavutil.mavlink.MAV_FRAME_GLOBAL_RELATIVE_ALT_INT,
    mavutil.mavlink.MAV_FRAME_GLOBAL_TERRAIN_ALT,
    mavutil.mavlink.MAV_FRAME_GLOBAL_TERRAIN_ALT_INT
]

# get location of scripts
testdir = os.path.dirname(os.path.realpath(__file__))

# Check python version for abstract base class
if sys.version_info[0] >= 3 and sys.version_info[1] >= 4:
    ABC = abc.ABC
else:
    ABC = abc.ABCMeta('ABC', (), {})

if sys.version_info[0] >= 3:
    import io as StringIO  # srsly, we just did that.
else:
    import StringIO

try:
    from itertools import izip as zip
except ImportError:
    # probably python2
    pass


class ErrorException(Exception):
    """Base class for other exceptions"""
    pass


class AutoTestTimeoutException(ErrorException):
    pass


if sys.version_info[0] < 3:
    ConnectionResetError = AutoTestTimeoutException


class WaitModeTimeout(AutoTestTimeoutException):
    """Thrown when fails to achieve given mode change."""
    pass


class WaitAltitudeTimout(AutoTestTimeoutException):
    """Thrown when fails to achieve given altitude range."""
    pass


class WaitGroundSpeedTimeout(AutoTestTimeoutException):
    """Thrown when fails to achieve given ground speed range."""
    pass


class WaitRollTimeout(AutoTestTimeoutException):
    """Thrown when fails to achieve given roll in degrees."""
    pass


class WaitPitchTimeout(AutoTestTimeoutException):
    """Thrown when fails to achieve given pitch in degrees."""
    pass


class WaitHeadingTimeout(AutoTestTimeoutException):
    """Thrown when fails to achieve given heading."""
    pass


class WaitDistanceTimeout(AutoTestTimeoutException):
    """Thrown when fails to attain distance"""
    pass


class WaitLocationTimeout(AutoTestTimeoutException):
    """Thrown when fails to attain location"""
    pass


class WaitWaypointTimeout(AutoTestTimeoutException):
    """Thrown when fails to attain waypoint ranges"""
    pass


class SetRCTimeout(AutoTestTimeoutException):
    """Thrown when fails to send RC commands"""
    pass


class MsgRcvTimeoutException(AutoTestTimeoutException):
    """Thrown when fails to receive an expected message"""
    pass


class NotAchievedException(ErrorException):
    """Thrown when fails to achieve a goal"""
    pass


class OldpymavlinkException(ErrorException):
    """Thrown when a new feature is required from pymavlink"""
    pass


class YawSpeedNotAchievedException(NotAchievedException):
    """Thrown when fails to achieve given yaw speed."""
    pass


class SpeedVectorNotAchievedException(NotAchievedException):
    """Thrown when fails to achieve given speed vector."""
    pass


class PreconditionFailedException(ErrorException):
    """Thrown when a precondition for a test is not met"""
    pass


class ArmedAtEndOfTestException(ErrorException):
    """Created when test left vehicle armed"""
    pass


class Context(object):
    def __init__(self):
        self.parameters = []
        self.sitl_commandline_customised = False
        self.reboot_sitl_was_done = False
        self.message_hooks = []
        self.collections = {}
        self.heartbeat_interval_ms = 1000
        self.original_heartbeat_interval_ms = None
        self.installed_scripts = []
        self.installed_modules = []
        self.overridden_message_rates = {}


# https://stackoverflow.com/questions/616645/how-do-i-duplicate-sys-stdout-to-a-log-file-in-python
class TeeBoth(object):
    def __init__(self, name, mode, mavproxy_logfile, suppress_stdout=False):
        self.suppress_stdout = suppress_stdout
        self.file = open(name, mode)
        self.stdout = sys.stdout
        self.stderr = sys.stderr
        self.mavproxy_logfile = mavproxy_logfile
        self.mavproxy_logfile.set_fh(self)
        sys.stdout = self
        sys.stderr = self

    def close(self):
        sys.stdout = self.stdout
        sys.stderr = self.stderr
        self.mavproxy_logfile.set_fh(None)
        self.mavproxy_logfile = None
        self.file.close()
        self.file = None

    def write(self, data):
        if isinstance(data, bytes):
            data = data.decode('ascii')
        self.file.write(data)
        if not self.suppress_stdout:
            self.stdout.write(data)

    def flush(self):
        self.file.flush()


class MAVProxyLogFile(object):
    def __init__(self):
        self.fh = None

    def close(self):
        pass

    def set_fh(self, fh):
        self.fh = fh

    def write(self, data):
        if self.fh is not None:
            self.fh.write(data)
        else:
            sys.stdout.write(data)

    def flush(self):
        if self.fh is not None:
            self.fh.flush()
        else:
            sys.stdout.flush()


class Telem(object):
    def __init__(self, destination_address, progress_function=None, verbose=False):
        self.destination_address = destination_address
        self.progress_function = progress_function
        self.verbose = verbose

        self.buffer = bytes()
        self.connected = False
        self.port = None
        self.progress_log = ""

    def progress(self, message):
        message = "%s: %s" % (self.progress_tag(), message)
        if self.progress_function is not None:
            self.progress_function(message)
            return
        if not self.verbose:
            self.progress_log += message
            return
        print(message)

    def connect(self):
        try:
            self.connected = False
            self.progress("Connecting to (%s:%u)" % self.destination_address)
            if self.port is not None:
                try:
                    self.port.close() # might be reopening
                except Exception:
                    pass
            self.port = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.port.connect(self.destination_address)
            self.port.setblocking(False)
            self.port.setsockopt(socket.SOL_TCP, socket.TCP_NODELAY, 1)
            self.connected = True
            self.progress("Connected")
        except IOError as e:
            self.progress("Failed to connect: %s" % str(e))
            time.sleep(0.5)
            return False
        return True

    def do_read(self):
        try:
            data = self.port.recv(1024)
        except socket.error as e:
            if e.errno not in [errno.EAGAIN, errno.EWOULDBLOCK]:
                self.progress("Exception: %s" % str(e))
                self.connected = False
            return bytes()
        if len(data) == 0:
            self.progress("EOF")
            self.connected = False
            return bytes()
#        self.progress("Read %u bytes" % len(data))
        return data

    def do_write(self, some_bytes):
        try:
            written = self.port.send(some_bytes)
        except socket.error as e:
            if e.errno in [errno.EAGAIN, errno.EWOULDBLOCK]:
                return 0
            self.progress("Exception: %s" % str(e))
            raise
        if written != len(some_bytes):
            raise ValueError("Short write")

    def update(self):
        if not self.connected:
            if not self.connect():
                return
        return self.update_read()


class IBusMessage(object):
    def checksum_bytes(self, out):
        checksum = 0xFFFF
        for b in iter(out):
            checksum -= b
        return checksum


class IBusResponse(IBusMessage):
    def __init__(self, some_bytes):
        self.len = some_bytes[0]
        checksum = self.checksum_bytes(some_bytes[:self.len-2])
        if checksum >> 8 != some_bytes[self.len-1]:
            raise ValueError("Checksum bad (-1)")
        if checksum & 0xff != some_bytes[self.len-2]:
            raise ValueError("Checksum bad (-2)")
        self.address = some_bytes[1] & 0x0F
        self.handle_payload_bytes(some_bytes[2:self.len-2])


class IBusResponse_DISCOVER(IBusResponse):
    def handle_payload_bytes(self, payload_bytes):
        if len(payload_bytes):
            raise ValueError("Not expecting payload bytes (%u)" %
                             (len(payload_bytes), ))


class IBusResponse_GET_SENSOR_TYPE(IBusResponse):
    def handle_payload_bytes(self, payload_bytes):
        if len(payload_bytes) != 2:
            raise ValueError("Expected 2 payload bytes")
        self.sensor_type = payload_bytes[0]
        self.sensor_length = payload_bytes[1]


class IBusResponse_GET_SENSOR_VALUE(IBusResponse):
    def handle_payload_bytes(self, payload_bytes):
        self.sensor_value = payload_bytes

    def get_sensor_value(self):
        '''returns an integer based off content'''
        ret = 0
        for i in range(len(self.sensor_value)):
            x = self.sensor_value[i]
            if sys.version_info.major < 3:
                x = ord(x)
            ret = ret | (x << (i*8))
        return ret


class IBusRequest(IBusMessage):
    def __init__(self, command, address):
        self.command = command
        self.address = address

    def payload_bytes(self):
        '''most requests don't have a payload'''
        return bytearray()

    def for_wire(self):
        out = bytearray()
        payload_bytes = self.payload_bytes()
        payload_length = len(payload_bytes)
        length = 1 + 1 + payload_length + 2  # len+cmd|adr+payloadlen+cksum
        format_string = '<BB' + ('B' * payload_length)
        out.extend(struct.pack(format_string,
                               length,
                               (self.command << 4) | self.address,
                               *payload_bytes,
                               ))
        checksum = self.checksum_bytes(out)
        out.extend(struct.pack("<BB", checksum & 0xff, checksum >> 8))
        return out


class IBusRequest_DISCOVER(IBusRequest):
    def __init__(self, address):
        super(IBusRequest_DISCOVER, self).__init__(0x08, address)


class IBusRequest_GET_SENSOR_TYPE(IBusRequest):
    def __init__(self, address):
        super(IBusRequest_GET_SENSOR_TYPE, self).__init__(0x09, address)


class IBusRequest_GET_SENSOR_VALUE(IBusRequest):
    def __init__(self, address):
        super(IBusRequest_GET_SENSOR_VALUE, self).__init__(0x0A, address)


class IBus(Telem):
    def __init__(self, destination_address):
        super(IBus, self).__init__(destination_address)

    def progress_tag(self):
        return "IBus"

    def packet_from_buffer(self, buffer):
        t = buffer[1] >> 4
        if sys.version_info.major < 3:
            t = ord(t)
        if t == 0x08:
            return IBusResponse_DISCOVER(buffer)
        if t == 0x09:
            return IBusResponse_GET_SENSOR_TYPE(buffer)
        if t == 0x0A:
            return IBusResponse_GET_SENSOR_VALUE(buffer)
        raise ValueError("Unknown response type (%u)" % t)

    def update_read(self):
        self.buffer += self.do_read()
        while len(self.buffer):
            msglen = self.buffer[0]
            if sys.version_info.major < 3:
                msglen = ord(msglen)
            if len(self.buffer) < msglen:
                return
            packet = self.packet_from_buffer(self.buffer[:msglen])
            self.buffer = self.buffer[msglen:]
            return packet


class WaitAndMaintain(object):
    def __init__(self,
                 test_suite,
                 minimum_duration=None,
                 progress_print_interval=1,
                 timeout=30,
                 ):
        self.test_suite = test_suite
        self.minimum_duration = minimum_duration
        self.achieving_duration_start = None
        self.timeout = timeout
        self.last_progress_print = 0
        self.progress_print_interval = progress_print_interval

    def run(self):
        self.announce_test_start()

        tstart = self.test_suite.get_sim_time_cached()
        while True:
            now = self.test_suite.get_sim_time_cached()
            current_value = self.get_current_value()
            if now - self.last_progress_print > self.progress_print_interval:
                self.print_progress(now, current_value)
                self.last_progress_print = now

            # check for timeout
            if now - tstart > self.timeout:
                self.print_failure_text(now, current_value)
                raise self.timeoutexception()

            # handle the case where we are are achieving our value:
            if self.validate_value(current_value):
                if self.achieving_duration_start is None:
                    self.achieving_duration_start = now
                if (self.minimum_duration is None or
                        now - self.achieving_duration_start > self.minimum_duration):
                    self.announce_success()
                    return True
                continue

            # handle the case where we are not achieving our value:
            self.achieving_duration_start = None

    def progress(self, text):
        self.test_suite.progress(text)

    def announce_test_start(self):
        self.progress(self.announce_start_text())

    def announce_success(self):
        self.progress(self.success_text())

    def print_progress(self, now, value):
        text = self.progress_text(value)
        if self.achieving_duration_start is not None:
            delta = now - self.achieving_duration_start
            text += f" (maintain={delta:.1f}/{self.minimum_duration})"
        self.progress(text)

    def print_failure_text(self, now, value):
        '''optionally print a more detailed error string'''
        pass

    def progress_text(self, value):
        return f"want={self.get_target_value()} got={value}"

    def validate_value(self, value):
        return value == self.get_target_value()

    def timeoutexception(self):
        return AutoTestTimeoutException("Failed to attain or maintain value")

    def success_text(self):
        return f"{type(self)} Success"


class WaitAndMaintainLocation(WaitAndMaintain):
    def __init__(self, test_suite, target, accuracy=5, height_accuracy=1, **kwargs):
        super(WaitAndMaintainLocation, self).__init__(test_suite, **kwargs)
        self.target = target
        self.height_accuracy = height_accuracy
        self.accuracy = accuracy

    def announce_start_text(self):
        t = self.target
        if self.height_accuracy is not None:
            return ("Waiting for distance to Location (%.4f, %.4f, %.2f) (h_err<%f, v_err<%.2f " %
                    (t.lat, t.lng, t.alt*0.01, self.accuracy, self.height_accuracy))
        return ("Waiting for distance to Location (%.4f, %.4f) (h_err<%f" %
                (t.lat, t.lng, self.accuracy))

    def get_target_value(self):
        return self.loc

    def get_current_value(self):
        return self.test_suite.mav.location()

    def horizontal_error(self, value):
        return self.test_suite.get_distance(value, self.target)

    def vertical_error(self, value):
        return math.fabs(value.alt*0.01 - self.target.alt*0.01)

    def validate_value(self, value):
        if self.horizontal_error(value) > self.accuracy:
            return False

        if self.height_accuracy is None:
            return True

        if self.vertical_error(value) > self.height_accuracy:
            return False

        return True

    def success_text(self):
        return "Reached location"

    def timeoutexception(self):
        return AutoTestTimeoutException("Failed to attain location")

    def progress_text(self, current_value):
        if self.height_accuracy is not None:
            return (f"Want=({self.target.lat:.7f},{self.target.lng:.7f},{self.target.alt:.2f}) Got=({current_value.lat:.7f},{current_value.lng:.7f},{current_value.alt:.2f}) dist={self.horizontal_error(current_value):.2f} vdist={self.vertical_error(current_value):.2f}")  # noqa

        return (f"Want=({self.target.lat},{self.target.lng}) distance={self.horizontal_error(current_value)}")


class WaitAndMaintainEKFFlags(WaitAndMaintain):
    '''Waits for EKF status flags to include required_flags and have
    error_bits *not* set.'''
    def __init__(self, test_suite, required_flags, error_bits, **kwargs):
        super(WaitAndMaintainEKFFlags, self).__init__(test_suite, **kwargs)
        self.required_flags = required_flags
        self.error_bits = error_bits
        self.last_EKF_STATUS_REPORT = None

    def announce_start_text(self):
        return f"Waiting for EKF value {self.required_flags}"

    def get_current_value(self):
        self.last_EKF_STATUS_REPORT = self.test_suite.assert_receive_message('EKF_STATUS_REPORT', timeout=10)
        return self.last_EKF_STATUS_REPORT.flags

    def validate_value(self, value):
        if value & self.error_bits:
            return False

        if (value & self.required_flags) != self.required_flags:
            return False

        return True

    def success_text(self):
        return "EKF Flags OK"

    def timeoutexception(self):
        self.progress("Last EKF status report:")
        self.progress(self.test_suite.dump_message_verbose(self.last_EKF_STATUS_REPORT))

        return AutoTestTimeoutException(f"Failed to get EKF.flags={self.required_flags}")

    def progress_text(self, current_value):
        error_bits = current_value & self.error_bits
        return (f"Want={self.required_flags} got={current_value} errors={error_bits}")

    def ekf_flags_string(self, bits):
        ret = []
        for i in range(0, 16):
            bit = 1 << i
            try:
                if not bits & bit:
                    continue
                name = mavutil.mavlink.enums["ESTIMATOR_STATUS_FLAGS"][bit].name
                trimmed_name = name.removeprefix("ESTIMATOR_")
                ret.append(trimmed_name)
            except KeyError:
                ret.append(str(bit))
        return "|".join(ret)

    def failure_text(self, now, current_value):
        components = []
        components.append(("want", self.ekf_flags_string(self.required_flags)))

        missing_bits = self.required_flags & ~current_value
        if missing_bits:
            components.append(("missing", self.ekf_flags_string(missing_bits)))

        error_bits = current_value & self.error_bits
        if error_bits:
            components.append(("errors", self.ekf_flags_string(error_bits)))

        return " ".join([f"{n}={v}" for (n, v) in components])

    def print_failure_text(self, now, current_value):
        self.progress(self.failure_text(now, current_value))


class WaitAndMaintainArmed(WaitAndMaintain):
    def get_current_value(self):
        return self.test_suite.armed()

    def get_target_value(self):
        return True

    def announce_start_text(self):
        return "Ensuring vehicle remains armed"


class MSP_Generic(Telem):
    def __init__(self, destination_address):
        super(MSP_Generic, self).__init__(destination_address)

        self.callback = None

        self.STATE_IDLE = "IDLE"
        self.STATE_WANT_HEADER_DOLLARS = "WANT_DOLLARS"
        self.STATE_WANT_HEADER_M = "WANT_M"
        self.STATE_WANT_HEADER_GT = "WANT_GT"
        self.STATE_WANT_DATA_SIZE = "WANT_DATA_SIZE"
        self.STATE_WANT_COMMAND = "WANT_COMMAND"
        self.STATE_WANT_DATA = "WANT_DATA"
        self.STATE_WANT_CHECKSUM = "WANT_CHECKSUM"

        self.state = self.STATE_IDLE

    def progress(self, message):
        print("MSP: %s" % message)

    def set_state(self, state):
        # self.progress("Moving to state (%s)" % state)
        self.state = state

    def init_checksum(self, b):
        self.checksum = 0
        self.add_to_checksum(b)

    def add_to_checksum(self, b):
        self.checksum ^= (b & 0xFF)

    def process_command(self, cmd, data):
        if self.callback is not None:
            self.callback(cmd, data)
        else:
            print("cmd=%s" % str(cmd))

    def update_read(self):
        for byte in self.do_read():
            if sys.version_info[0] < 3:
                c = byte[0]
                byte = ord(c)
            else:
                c = chr(byte)
            # print("Got (0x%02x) (%s) (%s) state=%s" % (byte, chr(byte), str(type(byte)), self.state))
            if self.state == self.STATE_IDLE:
                # reset state
                self.set_state(self.STATE_WANT_HEADER_DOLLARS)
                # deliberate fallthrough right here
            if self.state == self.STATE_WANT_HEADER_DOLLARS:
                if c == '$':
                    self.set_state(self.STATE_WANT_HEADER_M)
                continue
            if self.state == self.STATE_WANT_HEADER_M:
                if c != 'M':
                    raise Exception("Malformed packet")
                self.set_state(self.STATE_WANT_HEADER_GT)
                continue
            if self.state == self.STATE_WANT_HEADER_GT:
                if c != '>':
                    raise Exception("Malformed packet")
                self.set_state(self.STATE_WANT_DATA_SIZE)
                continue
            if self.state == self.STATE_WANT_DATA_SIZE:
                self.data_size = byte
                self.set_state(self.STATE_WANT_COMMAND)
                self.data = bytearray()
                self.checksum = 0
                self.add_to_checksum(byte)
                continue
            if self.state == self.STATE_WANT_COMMAND:
                self.command = byte
                self.add_to_checksum(byte)
                if self.data_size != 0:
                    self.set_state(self.STATE_WANT_DATA)
                else:
                    self.set_state(self.STATE_WANT_CHECKSUM)
                continue
            if self.state == self.STATE_WANT_DATA:
                self.add_to_checksum(byte)
                self.data.append(byte)
                if len(self.data) == self.data_size:
                    self.set_state(self.STATE_WANT_CHECKSUM)
                continue
            if self.state == self.STATE_WANT_CHECKSUM:
                if self.checksum != byte:
                    raise Exception("Checksum fail (want=0x%02x calced=0x%02x" %
                                    (byte, self.checksum))
                self.process_command(self.command, self.data)
                self.set_state(self.STATE_IDLE)


class MSP_DJI(MSP_Generic):
    FRAME_GPS_RAW  = 106
    FRAME_ATTITUDE = 108

    def __init__(self, destination_address):
        super(MSP_DJI, self).__init__(destination_address)
        self.callback = self.command_callback
        self.frames = {}

    class Frame(object):
        def __init__(self, data):
            self.data = data

        def intn(self, offset, count):
            ret = 0
            for i in range(offset, offset+count):
                ret = ret | (ord(self.data[i]) << ((i-offset)*8))
            return ret

        def int32(self, offset):
            t = struct.unpack("<i", self.data[offset:offset+4])
            return t[0]

        def int16(self, offset):
            t = struct.unpack("<h", self.data[offset:offset+2])
            return t[0]

    class FrameATTITUDE(Frame):
        def roll(self):
            '''roll in degrees'''
            return self.int16(0) * 10

        def pitch(self):
            '''pitch in degrees'''
            return self.int16(2) * 10

        def yaw(self):
            '''yaw in degrees'''
            return self.int16(4)

    class FrameGPS_RAW(Frame):
        '''see gps_state_s'''
        def fix_type(self):
            return self.uint8(0)

        def num_sats(self):
            return self.uint8(1)

        def lat(self):
            return self.int32(2) / 1e7

        def lon(self):
            return self.int32(6) / 1e7

        def LocationInt(self):
            # other fields are available, I'm just lazy
            return LocationInt(self.int32(2), self.int32(6), 0, 0)

    def command_callback(self, frametype, data):
        # print("X: %s %s" % (str(frametype), str(data)))
        if frametype == MSP_DJI.FRAME_ATTITUDE:
            frame = MSP_DJI.FrameATTITUDE(data)
        elif frametype == MSP_DJI.FRAME_GPS_RAW:
            frame = MSP_DJI.FrameGPS_RAW(data)
        else:
            return
        self.frames[frametype] = frame

    def get_frame(self, frametype):
        return self.frames[frametype]


class LTM(Telem):
    def __init__(self, destination_address):
        super(LTM, self).__init__(destination_address)

        self.HEADER1 = 0x24
        self.HEADER2 = 0x54

        self.FRAME_G = 0x47
        self.FRAME_A = 0x41
        self.FRAME_S = 0x53

        self.frame_lengths = {
            self.FRAME_G: 18,
            self.FRAME_A: 10,
            self.FRAME_S: 11,
        }
        self.frame_lengths = {
            self.FRAME_G: 18,
            self.FRAME_A: 10,
            self.FRAME_S: 11,
        }

        self.data_by_id = {}
        self.frames = {}

    def g(self):
        return self.frames.get(self.FRAME_G, None)

    def a(self):
        return self.frames.get(self.FRAME_A, None)

    def s(self):
        return self.frames.get(self.FRAME_S, None)

    def progress_tag(self):
        return "LTM"

    def handle_data(self, dataid, value):
        self.progress("%u=%u" % (dataid, value))
        self.data_by_id[dataid] = value

    def consume_frame(self):
        b2 = self.buffer[2]
        if sys.version_info.major < 3:
            b2 = ord(b2)
        frame_type = b2
        frame_length = self.frame_lengths[frame_type]
        # check frame CRC
        crc = 0
        count = 0
        for c in self.buffer[3:frame_length-1]:
            if sys.version_info.major < 3:
                c = ord(c)
            crc ^= c
            count += 1
        buffer_crc = self.buffer[frame_length-1]
        if sys.version_info.major < 3:
            buffer_crc = ord(buffer_crc)
        if crc != buffer_crc:
            raise NotAchievedException("Invalid checksum on frame type %s" % str(chr(frame_type)))
#        self.progress("Received valid %s frame" % str(chr(frame_type)))

        class Frame(object):
            def __init__(self, buffer):
                self.buffer = buffer

            def intn(self, offset, count):
                ret = 0
                for i in range(offset, offset+count):
                    ret = ret | (ord(self.buffer[i]) << ((i-offset)*8))
                return ret

            def int32(self, offset):
                t = struct.unpack("<i", self.buffer[offset:offset+4])
                return t[0]
#                return self.intn(offset, 4)

            def int16(self, offset):
                t = struct.unpack("<h", self.buffer[offset:offset+2])
                return t[0]
#                return self.intn(offset, 2)

        class FrameG(Frame):
            def __init__(self, buffer):
                super(FrameG, self,).__init__(buffer)

            def lat(self):
                return self.int32(3)

            def lon(self):
                return self.int32(7)

            def gndspeed(self):
                ret = self.buffer[11]
                if sys.version_info.major < 3:
                    ret = ord(ret)
                return ret

            def alt(self):
                return self.int32(12)

            def sats(self):
                s = self.buffer[16]
                if sys.version_info.major < 3:
                    s = ord(s)
                return (s >> 2)

            def fix_type(self):
                s = self.buffer[16]
                if sys.version_info.major < 3:
                    s = ord(s)
                return s & 0b11

        class FrameA(Frame):
            def __init__(self, buffer):
                super(FrameA, self,).__init__(buffer)

            def pitch(self):
                return self.int16(3)

            def roll(self):
                return self.int16(5)

            def hdg(self):
                return self.int16(7)

        class FrameS(Frame):
            def __init__(self, buffer):
                super(FrameS, self,).__init__(buffer)

        if frame_type == self.FRAME_G:
            frame = FrameG(self.buffer[0:frame_length-1])
        elif frame_type == self.FRAME_A:
            frame = FrameA(self.buffer[0:frame_length-1])
        elif frame_type == self.FRAME_S:
            frame = FrameS(self.buffer[0:frame_length-1])
        else:
            raise NotAchievedException("Bad frame?!?!?!")
        self.buffer = self.buffer[frame_length:]
        self.frames[frame_type] = frame

    def update_read(self):
        self.buffer += self.do_read()
        while len(self.buffer):
            if len(self.buffer) == 0:
                break
            b0 = self.buffer[0]
            if sys.version_info.major < 3:
                b0 = ord(b0)
            if b0 != self.HEADER1:
                self.bad_chars += 1
                self.buffer = self.buffer[1:]
                continue
            b1 = self.buffer[1]
            if sys.version_info.major < 3:
                b1 = ord(b1)
            if b1 != self.HEADER2:
                self.bad_chars += 1
                self.buffer = self.buffer[1:]
                continue
            b2 = self.buffer[2]
            if sys.version_info.major < 3:
                b2 = ord(b2)
            if b2 not in [self.FRAME_G, self.FRAME_A, self.FRAME_S]:
                self.bad_chars += 1
                self.buffer = self.buffer[1:]
                continue
            frame_len = self.frame_lengths[b2]
            if len(self.buffer) < frame_len:
                continue
            self.consume_frame()

    def get_data(self, dataid):
        try:
            return self.data_by_id[dataid]
        except KeyError:
            pass
        return None


class CRSF(Telem):
    def __init__(self, destination_address):
        super(CRSF, self).__init__(destination_address)

        self.dataid_vtx_frame = 0
        self.dataid_vtx_telem = 1
        self.dataid_vtx_unknown = 2

        self.data_id_map = {
            self.dataid_vtx_frame: bytearray([0xC8, 0x8, 0xF, 0xCE, 0x30, 0x8, 0x16, 0xE9, 0x0, 0x5F]),
            self.dataid_vtx_telem: bytearray([0xC8, 0x7, 0x10, 0xCE, 0xE, 0x16, 0x65, 0x0, 0x1B]),
            self.dataid_vtx_unknown: bytearray([0xC8, 0x9, 0x8, 0x0, 0x9E, 0x0, 0x0, 0x0, 0x0, 0x0, 0x95]),
        }

    def write_data_id(self, dataid):
        self.do_write(self.data_id_map[dataid])

    def progress_tag(self):
        return "CRSF"


class DEVO(Telem):
    def __init__(self, destination_address):
        super(DEVO, self).__init__(destination_address)

        self.HEADER = 0xAA
        self.frame_length = 20

        # frame is 'None' until we receive a frame with VALID header and checksum
        self.frame = None
        self.bad_chars = 0

    def progress_tag(self):
        return "DEVO"

    def consume_frame(self):
        # check frame checksum
        checksum = 0
        for c in self.buffer[:self.frame_length-1]:
            if sys.version_info.major < 3:
                c = ord(c)
            checksum += c
        checksum &= 0xff    # since we receive 8 bit checksum
        buffer_checksum = self.buffer[self.frame_length-1]
        if sys.version_info.major < 3:
            buffer_checksum = ord(buffer_checksum)
        if checksum != buffer_checksum:
            raise NotAchievedException("Invalid checksum")

        class FRAME(object):
            def __init__(self, buffer):
                self.buffer = buffer

            def int32(self, offset):
                t = struct.unpack("<i", self.buffer[offset:offset+4])
                return t[0]

            def int16(self, offset):
                t = struct.unpack("<h", self.buffer[offset:offset+2])
                return t[0]

            def lon(self):
                return self.int32(1)

            def lat(self):
                return self.int32(5)

            def alt(self):
                return self.int32(9)

            def speed(self):
                return self.int16(13)

            def temp(self):
                return self.int16(15)

            def volt(self):
                return self.int16(17)

        self.frame = FRAME(self.buffer[0:self.frame_length-1])
        self.buffer = self.buffer[self.frame_length:]

    def update_read(self):
        self.buffer += self.do_read()
        while len(self.buffer):
            if len(self.buffer) == 0:
                break
            b0 = self.buffer[0]
            if sys.version_info.major < 3:
                b0 = ord(b0)
            if b0 != self.HEADER:
                self.bad_chars += 1
                self.buffer = self.buffer[1:]
                continue
            if len(self.buffer) < self.frame_length:
                continue
            self.consume_frame()


class FRSky(Telem):
    def __init__(self, destination_address, verbose=False):
        super(FRSky, self).__init__(destination_address, verbose=verbose)

        self.dataid_GPS_ALT_BP          = 0x01
        self.dataid_TEMP1               = 0x02
        self.dataid_FUEL                = 0x04
        self.dataid_TEMP2               = 0x05
        self.dataid_GPS_ALT_AP          = 0x09
        self.dataid_BARO_ALT_BP         = 0x10
        self.dataid_GPS_SPEED_BP        = 0x11
        self.dataid_GPS_LONG_BP         = 0x12
        self.dataid_GPS_LAT_BP          = 0x13
        self.dataid_GPS_COURS_BP        = 0x14
        self.dataid_GPS_SPEED_AP        = 0x19
        self.dataid_GPS_LONG_AP         = 0x1A
        self.dataid_GPS_LAT_AP          = 0x1B
        self.dataid_BARO_ALT_AP         = 0x21
        self.dataid_GPS_LONG_EW         = 0x22
        self.dataid_GPS_LAT_NS          = 0x23
        self.dataid_CURRENT             = 0x28
        self.dataid_VFAS                = 0x39


class FRSkyD(FRSky):
    def __init__(self, destination_address):
        super(FRSkyD, self).__init__(destination_address)

        self.state_WANT_START_STOP_D = 16,
        self.state_WANT_ID = 17
        self.state_WANT_BYTE1 = 18
        self.state_WANT_BYTE2 = 19

        self.START_STOP_D = 0x5E
        self.BYTESTUFF_D = 0x5D

        self.state = self.state_WANT_START_STOP_D

        self.data_by_id = {}
        self.bad_chars = 0

    def progress_tag(self):
        return "FRSkyD"

    def handle_data(self, dataid, value):
        self.progress("%u=%u" % (dataid, value))
        self.data_by_id[dataid] = value

    def update_read(self):
        self.buffer += self.do_read()
        consume = None
        while len(self.buffer):
            if consume is not None:
                self.buffer = self.buffer[consume:]
            if len(self.buffer) == 0:
                break
            consume = 1
            if sys.version_info.major >= 3:
                b = self.buffer[0]
            else:
                b = ord(self.buffer[0])
            if self.state == self.state_WANT_START_STOP_D:
                if b != self.START_STOP_D:
                    # we may come into a stream mid-way, so we can't judge
                    self.bad_chars += 1
                    continue
                self.state = self.state_WANT_ID
                continue
            elif self.state == self.state_WANT_ID:
                self.dataid = b
                self.state = self.state_WANT_BYTE1
                continue
            elif self.state in [self.state_WANT_BYTE1, self.state_WANT_BYTE2]:
                if b == 0x5D:
                    # byte-stuffed
                    if len(self.buffer) < 2:
                        # try again in a little while
                        consume = 0
                        return
                    if ord(self.buffer[1]) == 0x3E:
                        b = self.START_STOP_D
                    elif ord(self.buffer[1]) == 0x3D:
                        b = self.BYTESTUFF_D
                    else:
                        raise ValueError("Unknown stuffed byte")
                    consume = 2
                if self.state == self.state_WANT_BYTE1:
                    self.b1 = b
                    self.state = self.state_WANT_BYTE2
                    continue

                data = self.b1 | b << 8
                self.handle_data(self.dataid, data)
                self.state = self.state_WANT_START_STOP_D

    def get_data(self, dataid):
        try:
            return self.data_by_id[dataid]
        except KeyError:
            pass
        return None


class SPortPacket(object):
    def __init__(self):
        self.START_STOP_SPORT = 0x7E
        self.BYTESTUFF_SPORT  = 0x7D


class SPortUplinkPacket(SPortPacket):
    def __init__(self, appid0, appid1, data0, data1, data2, data3):
        super(SPortUplinkPacket, self).__init__()
        self.appid0 = appid0
        self.appid1 = appid1
        self.data0 = data0
        self.data1 = data1
        self.data2 = data2
        self.data3 = data3
        self.SENSOR_ID_UPLINK_ID         = 0x0D
        self.SPORT_UPLINK_FRAME          = 0x30
        self.uplink_id = self.SENSOR_ID_UPLINK_ID
        self.frame = self.SPORT_UPLINK_FRAME

    def packed(self):
        return struct.pack(
            '<BBBBBBBB',
            self.uplink_id,
            self.frame,
            self.appid0 & 0xff,
            self.appid1 & 0xff,
            self.data0 & 0xff,
            self.data1 & 0xff,
            self.data2 & 0xff,
            self.data3 & 0xff,
        )

    def update_checksum(self, byte):
        self.checksum += byte
        self.checksum += self.checksum >> 8
        self.checksum &= 0xFF

    def checksum(self):
        self.checksum = 0
        self.update_checksum(self.frame & 0xff)
        self.update_checksum(self.appid0 & 0xff)
        self.update_checksum(self.appid1 & 0xff)
        self.update_checksum(self.data0 & 0xff)
        self.update_checksum(self.data1 & 0xff)
        self.update_checksum(self.data2 & 0xff)
        self.update_checksum(self.data3 & 0xff)
        self.checksum = 0xff - ((self.checksum & 0xff) + (self.checksum >> 8))
        return self.checksum & 0xff

    def for_wire(self):
        out = bytearray()
        out.extend(self.packed())
        out.extend(struct.pack('<B', self.checksum()))
        stuffed = bytearray()
        stuffed.extend(struct.pack('<B', self.START_STOP_SPORT))
        for pbyte in out:
            if pbyte in [self.BYTESTUFF_SPORT,
                         self.START_STOP_SPORT]:
                # bytestuff
                stuffed.append(self.BYTESTUFF_SPORT)
                stuffed.append(pbyte ^ self.SPORT_FRAME_XOR)
            else:
                stuffed.append(pbyte)
        return stuffed


class SPortPollPacket(SPortPacket):
    def __init__(self, sensor):
        super(SPortPollPacket, self).__init__()
        self.sensor = sensor

    def for_wire(self):
        return struct.pack(
            '<BB',
            self.START_STOP_SPORT,
            self.sensor & 0xff,
        )


class MAVliteMessage(object):
    def __init__(self, msgid, body):
        self.msgid = msgid
        self.body = body
        self.SENSOR_ID_UPLINK_ID         = 0x0D
        self.SPORT_UPLINK_FRAME          = 0x30

    def checksum_bytes(self, some_bytes):
        checksum = 0
        for b in some_bytes:
            checksum += b
            checksum += checksum >> 8
            checksum &= 0xFF
        return checksum

    def to_sport_packets(self):
        ret = []
        all_bytes = bytearray([len(self.body), self.msgid])
        all_bytes.extend(self.body)

        # insert sequence numbers:
        seq = 0
        sequenced = bytearray()
        while len(all_bytes):
            chunk = all_bytes[0:5]
            all_bytes = all_bytes[5:]
            sequenced.append(seq)
            sequenced.extend(chunk)
            seq += 1

        # we may need another sport packet just for the checksum:
        if len(sequenced) % 6 == 0:
            sequenced.append(seq)
            seq += 1

        checksum = self.checksum_bytes(sequenced)
        sequenced.append(checksum)

        while len(sequenced):
            chunk = sequenced[0:6]
            sequenced = sequenced[6:]
            chunk.extend([0] * (6-len(chunk))) # pad to 6
            packet = SPortUplinkPacket(
                *chunk
            )
            ret.append(packet)
        return ret


class SPortToMAVlite(object):
    def __init__(self):
        self.state_WANT_LEN = "want len"
        self.state_WANT_MSGID = "want msgid"
        self.state_WANT_PAYLOAD = "want payload"
        self.state_WANT_CHECKSUM = "want checksum"
        self.state_MESSAGE_RECEIVED = "message received"

        self.reset()

    def progress(self, message):
        print("SPortToMAVLite: %s" % message)

    def reset(self):
        self.want_seq = 0
        self.all_bytes = bytearray()
        self.payload = bytearray()
        self.state = self.state_WANT_LEN

    def checksum_bytes(self, some_bytes):
        checksum = 0
        for b in some_bytes:
            checksum += b
            checksum += checksum >> 8
            checksum &= 0xFF
        return checksum

    def downlink_handler(self, some_bytes):
        '''adds some_bytes into a mavlite message'''
        if some_bytes[0] == 0x00:
            self.reset()
        if some_bytes[0] != self.want_seq:
            raise NotAchievedException("Unexpected seqno; want=%u got=%u" %
                                       (self.want_seq, some_bytes[0]))
        self.all_bytes.append(some_bytes[0])
        self.want_seq += 1
        for byte in some_bytes[1:]:
            if self.state == self.state_WANT_LEN:
                self.payload_len = byte
                self.all_bytes.append(byte)
                self.state = self.state_WANT_MSGID
                continue
            if self.state == self.state_WANT_MSGID:
                self.msgid = byte
                self.all_bytes.append(byte)
                if self.payload_len == 0:
                    self.state = self.state_WANT_CHECKSUM
                else:
                    self.state = self.state_WANT_PAYLOAD
                continue
            if self.state == self.state_WANT_PAYLOAD:
                self.payload.append(byte)
                self.all_bytes.append(byte)
                if len(self.payload) == self.payload_len:
                    self.state = self.state_WANT_CHECKSUM
                continue
            if self.state == self.state_WANT_CHECKSUM:
                calculated_checksum = self.checksum_bytes(self.all_bytes)
                if calculated_checksum != byte:
                    raise Exception("Checksum failure (calc=%u) (recv=%u)" % (calculated_checksum, byte))
                self.state = self.state_MESSAGE_RECEIVED
                break

    def get_message(self):
        if self.state != self.state_MESSAGE_RECEIVED:
            raise Exception("Wrong state")
        return MAVliteMessage(self.msgid, self.payload)


class FRSkySPort(FRSky):
    def __init__(self, destination_address, verbose=True, get_time=time.time):
        super(FRSkySPort, self).__init__(
            destination_address,
            verbose=verbose
        )

        self.get_time = get_time

        self.state_SEND_POLL = "sendpoll"
        self.state_WANT_FRAME_TYPE = "want_frame_type"
        self.state_WANT_ID1 = "want_id1"
        self.state_WANT_ID2 = "want id2"
        self.state_WANT_DATA = "want data"
        self.state_WANT_CRC = "want crc"

        self.START_STOP_SPORT     = 0x7E
        self.BYTESTUFF_SPORT      = 0x7D
        self.SPORT_DATA_FRAME     = 0x10
        self.SPORT_DOWNLINK_FRAME = 0x32
        self.SPORT_FRAME_XOR      = 0x20

        self.SENSOR_ID_VARIO             = 0x00 # Sensor ID  0
        self.SENSOR_ID_FAS               = 0x22 # Sensor ID  2
        self.SENSOR_ID_GPS               = 0x83 # Sensor ID  3
        self.SENSOR_ID_RPM               = 0xE4 # Sensor ID  4
        self.SENSOR_ID_SP2UR             = 0xC6 # Sensor ID  6
        self.SENSOR_ID_27                = 0x1B # Sensor ID 27

        # MAVlite support:
        self.SENSOR_ID_DOWNLINK1_ID      = 0x34
        self.SENSOR_ID_DOWNLINK2_ID      = 0x67
        self.SENSOR_ID_UPLINK_ID         = 0x0D

        self.state = self.state_WANT_FRAME_TYPE

        self.data_by_id = {}
        self.dataid_counts = {}
        self.bad_chars = 0

        self.poll_sent = 0
        self.sensor_id_poll_counts = {}

        self.id_descriptions = {
            0x5000: "status text (dynamic)",
            0x5006: "Attitude and range (dynamic)",
            0x800: "GPS lat or lon (600 with 1 sensor)",
            0x5005: "Vel and Yaw",
            0x5001: "AP status",
            0x5002: "GPS Status",
            0x5004: "Home",
            0x5008: "Battery 2 status",
            0x5003: "Battery 1 status",
            0x5007: "parameters",
            0x500A: "rpm",
            0x500B: "terrain",
            0x500C: "wind",

            # SPort non-passthrough:
            0x082F: "GALT", # gps altitude integer cm
            0x040F: "TMP1", # Tmp1
            0x060F: "Fuel", # fuel % 0-100
            0x041F: "TMP2", # Tmp2
            0x010F: "ALT",  # baro alt cm
            0x083F: "GSPD", # gps speed integer mm/s
            0x084F: "HDG",  # yaw in cd
            0x020F: "CURR", # current dA
            0x011F: "VSPD", # vertical speed cm/s
            0x021F: "VFAS", # battery 1 voltage cV
            # 0x800: "GPS", ## comments as duplicated dictrionary key
            0x050E: "RPM1",

            0x34: "DOWNLINK1_ID",
            0x67: "DOWNLINK2_ID",
            0x0D: "UPLINK_ID",
        }

        self.sensors_to_poll = [
            self.SENSOR_ID_VARIO,
            self.SENSOR_ID_FAS,
            self.SENSOR_ID_GPS,
            self.SENSOR_ID_RPM,
            self.SENSOR_ID_SP2UR,
        ]
        self.next_sensor_id_to_poll = 0 # offset into sensors_to_poll

        self.data_downlink_handler = None

        self.last_poll_sensor = None
        self.last_data_time = None

    def progress_tag(self):
        return "FRSkySPort"

    def handle_data_downlink(self, some_bytes):
        self.progress("DOWNLINK %s" % (str(some_bytes),))
        if self.data_downlink_handler is not None:
            self.data_downlink_handler(some_bytes)
        self.last_data_time = self.get_time()

    def handle_data(self, dataid, value):
        if dataid not in self.id_descriptions:
            raise KeyError("dataid 0x%02x" % dataid)
        self.progress("%s (0x%x)=%u" % (self.id_descriptions[dataid], dataid, value))
        self.data_by_id[dataid] = value
        if dataid not in self.dataid_counts:
            self.dataid_counts[dataid] = 0
        self.dataid_counts[dataid] += 1
        self.last_data_time = self.get_time()

    def dump_dataid_counts_as_progress_messages(self):
        for dataid in self.dataid_counts:
            self.progress("0x%x: %u  (%s)" % (dataid, self.dataid_counts[dataid], self.id_descriptions[dataid]))

    def dump_sensor_id_poll_counts_as_progress_messages(self):
        for sensor_id in self.sensor_id_poll_counts:
            self.progress("(0x%x): %u" % (sensor_id, self.sensor_id_poll_counts[sensor_id]))

    def read_bytestuffed_byte(self):
        if sys.version_info.major >= 3:
            b = self.buffer[0]
        else:
            b = ord(self.buffer[0])
        if b == 0x7D:
            # byte-stuffed
            if len(self.buffer) < 2:
                self.consume = 0
                return None
            self.consume = 2
            if sys.version_info.major >= 3:
                b2 = self.buffer[1]
            else:
                b2 = ord(self.buffer[1])
            if b2 == 0x5E:
                return self.START_STOP_SPORT
            if b2 == 0x5D:
                return self.BYTESTUFF_SPORT
            raise ValueError("Unknown stuffed byte (0x%02x)" % b2)
        return b

    def calc_crc(self, byte):
        self.crc += byte
        self.crc += self.crc >> 8
        self.crc &= 0xFF

    def next_sensor(self):
        ret = self.sensors_to_poll[self.next_sensor_id_to_poll]
        self.next_sensor_id_to_poll += 1
        if self.next_sensor_id_to_poll >= len(self.sensors_to_poll):
            self.next_sensor_id_to_poll = 0
        return ret

    def check_poll(self):
        now = self.get_time()
        # self.progress("check poll (%u)" % now)

        # sometimes ArduPilot will not respond to a poll - for
        # example, if you poll an unhealthy RPM sensor then we will
        # *never* get a response back.  So we must re-poll (which
        # moves onto the next sensor):
        if now - self.poll_sent > 5:
            if self.last_poll_sensor is None:
                self.progress("Re-polling (last poll sensor was None)")
            else:
                msg = ("Re-polling (last_poll_sensor=0x%02x state=%s)" %
                       (self.last_poll_sensor, self.state))
                self.progress(msg)
            if self.state != self.state_WANT_FRAME_TYPE:
                raise ValueError("Expected to be wanting a frame type when repolling (state=%s)" % str(self.state))
            self.state = self.state_SEND_POLL

        if self.state == self.state_SEND_POLL:
            sensor_id = self.next_sensor()
            self.progress("Sending poll for 0x%02x" % sensor_id)
            self.last_poll_sensor = sensor_id
            if sensor_id not in self.sensor_id_poll_counts:
                self.sensor_id_poll_counts[sensor_id] = 0
            self.sensor_id_poll_counts[sensor_id] += 1
            packet = SPortPollPacket(sensor_id)
            self.send_sport_packet(packet)
            self.state = self.state_WANT_FRAME_TYPE
            self.poll_sent = now

    def send_sport_packets(self, packets):
        for packet in packets:
            self.send_sport_packet(packet)

    def send_sport_packet(self, packet):
        stuffed = packet.for_wire()
        self.progress("Sending (%s) (%u)" %
                      (["0x%02x" % x for x in bytearray(stuffed)], len(stuffed)))
        self.port.sendall(stuffed)

    def send_mavlite_param_request_read(self, parameter_name):
        mavlite_msg = MAVliteMessage(
            mavutil.mavlink.MAVLINK_MSG_ID_PARAM_REQUEST_READ,
            bytearray(parameter_name.encode())
        )

        packets = mavlite_msg.to_sport_packets()

        self.send_sport_packets(packets)

    def send_mavlite_param_set(self, parameter_name, value):
        out = bytearray(struct.pack("<f", value))
        out.extend(parameter_name.encode())

        mavlite_msg = MAVliteMessage(
            mavutil.mavlink.MAVLINK_MSG_ID_PARAM_SET,
            out
        )

        packets = mavlite_msg.to_sport_packets()

        self.send_sport_packets(packets)

    def send_mavlite_command_long(
            self,
            command,
            p1=None,
            p2=None,
            p3=None,
            p4=None,
            p5=None,
            p6=None,
            p7=None,
    ):
        params = bytearray()
        seen_none = False
        for p in p1, p2, p3, p4, p5, p6, p7:
            if p is None:
                seen_none = True
                continue
            if seen_none:
                raise ValueError("Can't have values after Nones!")
            params.extend(bytearray(struct.pack("<f", p)))

        out = bytearray(struct.pack("<H", command))  # first two bytes are command-id
        options = len(params) // 4  # low-three-bits is parameter count
        out.extend(bytearray(struct.pack("<B", options)))  # second byte is options
        out.extend(params)  # then the float values

        mavlite_msg = MAVliteMessage(
            mavutil.mavlink.MAVLINK_MSG_ID_COMMAND_LONG,
            out
        )

        packets = mavlite_msg.to_sport_packets()

        self.send_sport_packets(packets)

    def update(self):
        if not self.connected:
            if not self.connect():
                self.progress("Failed to connect")
                return
        self.check_poll()
        self.do_sport_read()

    def do_sport_read(self):
        self.buffer += self.do_read()
        self.consume = None
        while len(self.buffer):
            if self.consume is not None:
                self.buffer = self.buffer[self.consume:]
            if len(self.buffer) == 0:
                break
            self.consume = 1
            if sys.version_info.major >= 3:
                b = self.buffer[0]
            else:
                b = ord(self.buffer[0])
#            self.progress("Have (%s) bytes state=%s b=0x%02x" % (str(len(self.buffer)), str(self.state), b));
            if self.state == self.state_WANT_FRAME_TYPE:
                if b in [self.SPORT_DATA_FRAME, self.SPORT_DOWNLINK_FRAME]:
                    self.frame = b
                    self.crc = 0
                    self.calc_crc(b)
                    self.state = self.state_WANT_ID1
                    continue
                # we may come into a stream mid-way, so we can't judge
                self.progress("############# Bad char %x" % b)
                raise ValueError("Bad char (0x%02x)" % b)
                self.bad_chars += 1
                continue
            elif self.state == self.state_WANT_ID1:
                self.id1 = self.read_bytestuffed_byte()
                if self.id1 is None:
                    break
                self.calc_crc(self.id1)
                self.state = self.state_WANT_ID2
                continue
            elif self.state == self.state_WANT_ID2:
                self.id2 = self.read_bytestuffed_byte()
                if self.id2 is None:
                    break
                self.calc_crc(self.id2)
                self.state = self.state_WANT_DATA
                self.data_bytes = []
                self.data = 0
                continue
            elif self.state == self.state_WANT_DATA:
                data_byte = self.read_bytestuffed_byte()
                if data_byte is None:
                    break
                self.calc_crc(data_byte)
                self.data = self.data | (data_byte << (8*(len(self.data_bytes))))
                self.data_bytes.append(data_byte)
                if len(self.data_bytes) == 4:
                    self.state = self.state_WANT_CRC
                continue
            elif self.state == self.state_WANT_CRC:
                crc = self.read_bytestuffed_byte()
                if crc is None:
                    break
                self.crc = 0xFF - self.crc
                dataid = (self.id2 << 8) | self.id1
                if self.crc != crc:
                    self.progress("Incorrect frsky checksum (received=%02x calculated=%02x id=0x%x)" % (crc, self.crc, dataid))
#                    raise ValueError("Incorrect frsky checksum (want=%02x got=%02x id=0x%x)" % (crc, self.crc, dataid))
                else:
                    if self.frame == self.SPORT_DOWNLINK_FRAME:
                        self.handle_data_downlink([
                            self.id1,
                            self.id2,
                            self.data_bytes[0],
                            self.data_bytes[1],
                            self.data_bytes[2],
                            self.data_bytes[3]]
                        )
                    else:
                        self.handle_data(dataid, self.data)
                self.state = self.state_SEND_POLL
            elif self.state == self.state_SEND_POLL:
                # this is done in check_poll
                self.progress("in send_poll state")
                pass
            else:
                raise ValueError("Unknown state (%s)" % self.state)

    def get_data(self, dataid):
        try:
            return self.data_by_id[dataid]
        except KeyError:
            pass
        return None


class FRSkyPassThrough(FRSkySPort):
    def __init__(self, destination_address, get_time=time.time):
        super(FRSkyPassThrough, self).__init__(destination_address,
                                               get_time=get_time)

        self.sensors_to_poll = [self.SENSOR_ID_27]

    def progress_tag(self):
        return "FRSkyPassthrough"


class LocationInt(object):
    def __init__(self, lat, lon, alt, yaw):
        self.lat = lat
        self.lon = lon
        self.alt = alt
        self.yaw = yaw


class Test(object):
    '''a test definition - information about a test'''
    def __init__(self, function, kwargs={}, attempts=1, speedup=None):
        self.name = function.__name__
        self.description = function.__doc__
        if self.description is None:
            raise ValueError("%s is missing a docstring" % self.name)
        self.function = function
        self.kwargs = kwargs
        self.attempts = attempts
        self.speedup = speedup


class Result(object):
    '''a test result - pass, fail, exception, runtime, ....'''
    def __init__(self, test):
        self.test = test
        self.reason = None
        self.exception = None
        self.debug_filename = None
        self.time_elapsed = 0.0
        # self.passed = False

    def __str__(self):
        ret = "  %s (%s)" % (self.test.name, self.test.description)
        if self.passed:
            return f"{ret} OK"
        if self.reason is not None:
            ret += f" ({self.reason} )"
        if self.exception is not None:
            ret += f" ({str(self.exception)})"
        if self.debug_filename is not None:
            ret += f" (see {self.debug_filename})"
        if self.time_elapsed is not None:
            ret += f" (duration {self.time_elapsed} s)"
        return ret


class ValgrindFailedResult(Result):
    '''a custom Result to allow passing of Vaglrind failures around'''
    def __init__(self):
        super(ValgrindFailedResult, self).__init__(None)
        self.passed = False

    def __str__(self):
        return "Valgrind error detected"


class TestSuite(ABC):
    """Base abstract class.
    It implements the common function for all vehicle types.
    """
    def __init__(self,
                 binary,
                 valgrind=False,
                 callgrind=False,
                 gdb=False,
                 gdb_no_tui=False,
                 speedup=None,
                 frame=None,
                 params=None,
                 gdbserver=False,
                 lldb=False,
                 breakpoints=[],
                 disable_breakpoints=False,
                 viewerip=None,
                 use_map=False,
                 _show_test_timings=False,
                 logs_dir=None,
                 force_ahrs_type=None,
                 replay=False,
                 sup_binaries=[],
                 reset_after_every_test=False,
                 force_32bit=False,
                 ubsan=False,
                 ubsan_abort=False,
                 num_aux_imus=0,
                 dronecan_tests=False,
                 generate_junit=False,
                 build_opts={}):

        self.start_time = time.time()

        if binary is None:
            raise ValueError("Should always have a binary")

        self.binary = binary
        self.valgrind = valgrind
        self.callgrind = callgrind
        self.gdb = gdb
        self.gdb_no_tui = gdb_no_tui
        self.lldb = lldb
        self.frame = frame
        self.params = params
        self.gdbserver = gdbserver
        self.breakpoints = breakpoints
        self.disable_breakpoints = disable_breakpoints
        self.speedup = speedup
        if self.speedup is None:
            self.speedup = self.default_speedup()
        self.sup_binaries = sup_binaries
        self.reset_after_every_test = reset_after_every_test
        self.force_32bit = force_32bit
        self.ubsan = ubsan
        self.ubsan_abort = ubsan_abort
        self.build_opts = build_opts
        self.num_aux_imus = num_aux_imus
        self.generate_junit = generate_junit
        if generate_junit:
            try:
                spec = importlib.util.find_spec("junitparser")
                if spec is None:
                    raise ImportError
            except ImportError as e:
                raise ImportError(f"Junit export need junitparser package.\n {e} \nTry: python3 -m pip install junitparser")

        self.mavproxy = None
        self._mavproxy = None  # for auto-cleanup on failed tests
        self.mav = None
        self.viewerip = viewerip
        self.use_map = use_map
        self.contexts = []
        self.context_push()
        self.buildlog = None
        self.copy_tlog = False
        self.logfile = None
        self.max_set_rc_timeout = 0
        self.last_wp_load = 0
        self.forced_post_test_sitl_reboots = 0
        self.run_tests_called = False
        self._show_test_timings = _show_test_timings
        self.test_timings = dict()
        self.total_waiting_to_arm_time = 0
        self.waiting_to_arm_count = 0
        self.force_ahrs_type = force_ahrs_type
        self.replay = replay
        if self.force_ahrs_type is not None:
            self.force_ahrs_type = int(self.force_ahrs_type)
        self.logs_dir = logs_dir
        self.timesync_number = 137
        self.last_progress_sent_as_statustext = None
        self.last_heartbeat_time_ms = None
        self.last_heartbeat_time_wc_s = 0
        self.in_drain_mav = False
        self.tlog = None

        self.rc_thread = None
        self.rc_thread_should_quit = False
        self.rc_queue = Queue.Queue()

        self.expect_list = []

        self.start_mavproxy_count = 0

        self.last_sim_time_cached = 0
        self.last_sim_time_cached_wallclock = 0

        # to autopilot we do not want to go to the internet for tiles,
        # usually.  Set this to False to gather tiles from internet in
        # the cae there are new tiles required, then add them to the
        # repo and set this back to false:
        self.terrain_in_offline_mode = True
        self.elevationmodel = mp_elevation.ElevationModel(
            cachedir=util.reltopdir("Tools/autotest/tilecache/srtm"),
            offline=self.terrain_in_offline_mode
        )
        self.terrain_data_messages_sent = 0  # count of messages back
        self.dronecan_tests = dronecan_tests
        self.statustext_id = 1
        self.message_hooks = []  # functions or MessageHook instances

    def __del__(self):
        if self.rc_thread is not None:
            self.progress("Joining RC thread in __del__")
            self.rc_thread_should_quit = True
            self.rc_thread.join()
            self.rc_thread = None

    def default_speedup(self):
        return 8

    def progress(self, text, send_statustext=True):
        """Display autotest progress text."""
        delta_time = time.time() - self.start_time
        formatted_text = "AT-%06.1f: %s" % (delta_time, text)
        print(formatted_text)
        if (send_statustext and
                self.mav is not None and
                self.mav.port is not None and
                self.last_progress_sent_as_statustext != text):
            self.send_statustext(formatted_text)
            self.last_progress_sent_as_statustext = text

    # following two functions swiped from autotest.py:
    @staticmethod
    def buildlogs_dirpath():
        return os.getenv("BUILDLOGS", util.reltopdir("../buildlogs"))

    def sitl_home(self):
        HOME = self.sitl_start_location()
        return "%f,%f,%u,%u" % (HOME.lat,
                                HOME.lng,
                                HOME.alt,
                       @charset "utf-8";
/* CSS Document */

/* Background-Styles */
body {
	font-family:Helvetica;
	margin:0px;
	padding:0px;
	background-color: #fff;
	background-image: url(../images/bg.png);
}

#logo {
	background-image:url(../images/logo.png);
	background-repeat:no-repeat;
    height: 140px;
	width: 420px;
	-moz-box-shadow: 2px 2px 5px #888;
	-webkit-box-shadow: 2px 2px 5px #888;
	box-shadow: 2px 2px 5px #888;
	background-color: #000;
}
  
h2 {
	text-shadow: #ccc 0px 1px 0px;
	text-decoration:none;
	color:#D14836;
	padding-top: 0px;
	padding-right: 5px;
	padding-bottom: 5px;
	padding-left: 5px;
}

#git {
	background-color: #FFF;
	font-size: 15px;
	display: auto;
	padding: 10px;
	border: 1px solid #CCC;
	position: relative;
	-moz-box-shadow: 2px 2px 5px #888;
	-webkit-box-shadow: 2px 2px 5px #888;
	box-shadow: 2px 2px 5px #888;
}

#git a {
	color:#00F;
	font-weight: normal;
	}
	
#git a:hover {
	color:#D14836;
}

.passed-text {
	color:green;
}

.failed-text {
	color:red;
}


#main {
	padding-top:0px;
	min-width: 420px;
	margin-top: 0;
	margin-right: auto;
	margin-bottom: 0;
	margin-left: auto;
	padding-right: 20px;
	padding-bottom: 50px;
	padding-left: 20px;
}
  
ul#testresults {
	background-color: #FFF;
	display: block;
	padding: 10px;
	border: 1px solid #CCC;
	list-style-type: none;
	position: relative;
    -moz-box-shadow: 2px 2px 5px #888;
    -webkit-box-shadow: 2px 2px 5px #888;
    box-shadow: 2px 2px 5px #888;
}

ul#testresults li {
	list-style-type: none;
	display: block;
	background-color: #eef1f1;
	margin: 5px;
	padding: 5px;
		}

ul#testlogs {
	background-color: #FFF;
	display: block;
	padding: 10px;
	border: 1px solid #CCC;
	list-style-type: none;
	position: relative;
    -moz-box-shadow: 2px 2px 5px #888;
    -webkit-box-shadow: 2px 2px 5px #888;
    box-shadow: 2px 2px 5px #888;
}

ul#testlogs li {
	text-decoration:none;
	list-style-type: none;
	display: block;
	background-color: #eef1f1;
	margin: 5px;
	padding: 5px;
	font-size: 15px;
		}
		

ul#testlogs li a {
	text-decoration:none;
	color:#8aa19c;
	font-weight: bold;
	font-size: 12px;
	}
	
ul#testlogs li a:hover {
	color:#D14836;
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              JFIF  d d   C 		
	

	 C		  |                	                     2     UK;      T[g<      S[n     '     \*y      9WwUq      p=Vs     wCy    ky>5y   "wWE3    u+l.f@   *~r<  h!>w6i6d   Zj|2d        "           0@"  _"V+ol^|7w9iw>q[6iTm8jU?#b3|O>fW#e\"~|VKR^~CbX2cMin8HdkIN*+L?q_F%|o(Cz&<Cq`jBn]<MJu)(bpTW1{?               !01@Ppq ?Sc\Ap (FwE)               @01A!QP ?C1P!eU
T ] %:n7+ %1/" = 		       !1"@AQa#0Rq2Bb$DSTdrt  ?2jZ% VebhG>ni-yoiJY:),6H5_ gp9&!?mEk8$VV0j=q^	1d6p35+m6Yex_Z2?J]K3BnxZ  v"a=9&._y]TRM&lecF]2oA8q9sh#G Jaqd#-`_NGN 7=mZH}:tH/}Y=a62*-3/$9TrtS%4M)iyL.d}]_`jgE<N(/ F6U4TTNS}6S.
a,so)i	VA+!Kvl_7|<I!vEh]izdZ;eaQ/7~cjLN r /2/;`\	,9O%4ni	p;"jhNOD7)k &         !1AQa0@q  ?!u!-zJpe?G{&Z`A}x]+	.D=P` n_?%p8?jcOf=#X%7#0rwD
`nRZvTxPR[bvD@qb,(
*)Q	UhYxa??{F:!I8%W'jk`Dnx)_3e@gZ:k*mJ6Z
I%s?Sd+No	VP	?{BW\G^o}Kf9-NlIqKb                                  @                     	    t    !X    Zq<    L   @,V    0     H$               !@01APQ ?&>JidyZ"D1qXv(#):)"&ce0FK{            !1@0APQ ?8x#wST7q5 ~} V%d[Y} rF%S. &        !10@AQqa   ?A
q&]D{+H?5 	 .vI^0"g_/kv9q5
Edtdl7{.i]STG u	B9=$e>z!
	<.;F5
-RO(
6 U#*. xf,'"52)wJ1[8q+MTX9x6Spz34GpR(*d_ xkcH
xA178nlXvaMUxA'FB";~1w ?.f	`l)}^CA4IasI!+R^l	HX_*ns481UT"
 0'I HUAPoz22d2                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                PNG

   IHDR  |      1   bKGD      	vpAg  |    z,   IDATxwusON`	 $J$-QV,Y`o{v{Wy`%+'R"@D"sWTwcf3]:s::::::::::::::::::::::';A  EQCu9J8{:xt:xtw3nUQzUSO>YQzY	EIO@;A\9e c>$IBA [!W :Aid2(JYE*|Or9T*TUl6v\g{{l6&S)_g&'>Chfx+
VR(HBdi7ou({AUW37nH[NTO:mf_*e$F_"eZ0+	MSuUYBHW66~ht}?(2A^CA;6lSO=\ofDQt;3AMfLH}eZ0IMS4UUTE$	0 qFXb.y>wB!YN:X	\c6$(w>7k$G>.b[o<0(B@%$I 	3bC~g?s+
y@ @^u=\;$zi};3S>DQH2D40$<E-F\	D.IYd,,~uxE
=7T:d!:xeC JWW{cbt.do:m/0zMS6M=gj0fZLDQGLN.O?KR#BR1 Aripz$Q.DU-dYe3_;T4JssTvx@SEw(z{W]FsCL'IR@3GHMSY"WUY$	!AA^35lOld2xmAU,l;^%`Y|fvX/kSjm{.M"E;
w_c?|~Z3h"K"pA7R.N^= A$D3r6OK`a(PZZ|IhXs_T~t.q,:AW zz|{o}y|)-.|z~@@@b*	TU)a(B<lWl/X{hW6sTEL$4(p_xr/Y(:2c\uHrt/rl6LSd_6_(_EGAW ^}v,/7i[lQ;@6I 00#?=W+dmmoZF\+/Gk]7zP5mG,Ww/5OwoLgV2s 4Zd2NI65i8q|:O|"1JNAW r$nZ.<9OOwdB+FqzedYePT.KR}|b".x^0"1UUFd)(BU}zswVkeWUmu<lk\c~(J w,SJB{w8R^9uf>3[j8V[xvKwMB3U!vS)SUUYd	 D^P)5W3b9.<4>an}z^~\ktQ.7gv?K8CC]umJw+qWJ|-AO#@XsDQ1=+~k{%gQBDAW0%
-=d}]}j^~\ae_wtDU+BuB*o45Kf_:m$F"4jeCMhj(J>@3<gYQU U$O ;be@"?r=/h_s\^veo4zTBX+M%[t!: I @4e82 mwy|ri\?0~omWox{64UD;rq I@\AP(Cn:Zc{K]mwpgZKFP'&G6\H6/:AWuu(2z}#zV][nf#dib~nj=|/  ;aW%I @</`zHFKvlk,-UmE
 %D+]BkNFj8`MNz}3g()B@4+5K-[dSO1XVsX*4e	MaT|59Mj'6mHve{{3L'IRF*eRf_XM//.VmG~&na#<{rW<:AWR80a~HfGwz/_udAT
r1aeydk4J^TKR9^Qlq
*y<[TOAw795<To?4RVZJDsXerSw?})$Ctp/be(4>u%:B}sw}{TEW:EQ	-v}.oDpWI=CuPUEeIH U(m2Mv9}f^X'V@}Z~"!:yS?rc}*e"Sr63^78CU)i O}}zJ^sk<zVux$IuwU DnY6e-t(:k!	$hwKQQk{fzKK?_37DCtp_o$	,,Vf+^7#AP{3i )W(&4MF7>]R`"we[U {IS=O] +aFQ~`yqm-4,g^wg~v4'+T}J~b!:2BN>6,wH2,kI:P*5<zyN/Tq|</V22Ce|?T8Y$
SQFAc{K.6,wyr+kTnRebb\t$$~\)zD7NuuAIaue-;9Ui= Zk=q|s&m(.SXb#S kh\km	I29} <E"8H(s9uO|fWkvayVXXTlGhvp!BR4EKud>53f{jf)J^*B7\;>Iw+D5t/%3E-Is{)\fb0n}{O44adTUMiuUUeIb7L)c5SgDBgmZ(
YXcO~r^:Ofz3zP.Mg3Ffh=j)}t)U%#)!)O' -#WI\r?|tnj:LM=L
!0w?!L4f*xW}y
biA}|;x~$zL*K'^PTCPuO>ESzMU9-rRVdCR$U$!&@RdVjh]l_}"0EII$K%IRH&s	S<g]l,C}exxEYy%Dtuz5O Qv=J :r!Hl"7KS93mJQhJ)*geUNlJ$		,!\p#_E66mfgI|)J*~c_$I	Y$d'B~I]@F!
Ifd4TUbE7%jLD ?n\/Kr(p\wOPW6wrC537L37Rzfj=9-+rBRd]V$b"l&PGdxya~6]E8?xDS9TR%W~d2}W-(L!iZu=<#Usa(;CC2ydI2}?|*cFB3M)8wT;255e2aFazaaV0a~Z]y}mu!^|-}[J)fT*"?"jl9we-W}$$F#88yOi6GT:k8y F8@nN7{B,[6nt
!Im_0UkqL&y_OE:uvuTJdQ111@?JqN87b.cc[cJwl"m/yTF=C_KeA@v{7Jt Q&} R(K9`lz7jq9=@Yq(]pl;/DR"x!,#k FO8DaD"ir7q(ss9z2EHatuao,/O8$c15+wS4MkoLL^:5m-q|=(hOjUd|=G'.w}<I^]e<sQ->J-u(x^La
9=HU!uWYq=AS-UJ:qd.@[z
QD6A+]"-oy|_eyovhP(,sIR$w_;<S| q?,d2Y}l&{IYb2eTYB7%$!Kf.w`A No6znf7&s)JeBH0?a	j94\jueogWNH<U "{:mH]M`4RJ%PdX<DOo7zxgx=@LAgs>+,S7x'8}f=__rmSSGd9$MA&mi|s5G$}r]}/%B;xY<]slH$!Q!Ia")!3eit;SXZ(4		($"N8)<r8}](;9@<"s}pQ|*u!DUUfvo^fN<7C&2c71~t_(""""0"!aAH?if+OmDbOr!~TH.)rFlSr+\7oR9219xrgt7	u,g`quIVAp8b,O?NW! 	)~\/ bjPo?yNu[m+B+^aVExB4=EazzG>A${c|4clttl.AH?a$HR\PTL6:}}}}}q
	,~=zC TILYM"!z%IB4@wSBS?b`Q!74?YQ<K$"iX?wb9&&c?h|!2K*":dDN;^,Y}Ea>0|XBHBadzC__/w7~;`fz
CC}b[\hA2i`&x3d2dYATTUESU4MCQfffPUMr8qL:e5s7
!$];cB!^]Q$IfP+*k@=B<B  t^CQq^rpHt"d}G9P$J_(
Z7:I+9J4f`d?p m!EQC`>i;6o'o|#}sE#*bb|&:$IS:cff;r-J0dNPYPU%opjg(
;V?9O$Q(II{|3*O&KU> r^cL&G"B!-Hk,m`:t*QZrEr6$<3gdd8=88[@m\X&N:-v}<{JNh4b	`[64QqPTw?^Elihuzd3EB|9/dF":nv{$I"e-U,I4RH2]"E8[ <<Yb;sX,:g?^}/>466YFHOMN`YiYC|0-jiNgHuTUoDu_oi;@l^>H+sk+}BKm/WT~)nme)SAQUT#IdYaFI4be$|!I|#;GBPklij:zKfgl_+U5JIQeL*$FY),/u9g88qi>'J&iiR!f:.A/=Hd4$Vy\y8*7qBFqFyw)
HB`m04$[YY*WcFDXk%^{W(77_7i}oNTb2e\7"$lb|L,=wgd~~+>QHlw?/9C/2e9\YA@>,$eYBXE+?y!"EabTW6E`h*lp.`9xK(>E%4$y'wq{[nLo{WB	
fcc8!8}fb]<w:sOq:~
K9}
4V	 CC{W]u{w":d~e9"#IRJ2zVH[EOQy+l:ML Qc;/,2~fO""C
7q\D:GD<:YU2j@YllFh
rFsU?cskI&SBrgaaI:ieeJ
Oa$a@RE$FD"|~~Ba96ntI\&ed':/xW]}=V%TUiR+R,gV *Wh6\0$Nl4q)j:
L^lGhm8nN!,jB	YDxk(/I~GP
 F8X>=G_Ljnv)&0/RT	I(j,].c"rHa!Ilroo^C ""0{Ad\$Ir+r@]zYuFJX/y]WsM355 |_,M!L`}w~~mTjZXwe8o	-?CY1f$
$E 0L5<!pLNL155M$	k5,B8}"PU?sp	^w=jm'|o$;f]-\=
yMw/	I0$e4Mkji:i{tC]OgLOOj?=g[V7$T*f\.grwWA	m}?wI#(E7=ff9{8Kl>g2>>gexEoewUUin!\{5x>Ks<
*	|0"?"I^xY: $S9#"|= !d%l.&O8s49O^~MhKKKd2=[DnV.AAShtT%l[n}7E>wu~6tQTTUSdYR`,.-M7zW<7W,Gr]]dHfwoo3kl6+e3aMp+Y$HTktiD?S#N}|'BKb4ZQVk_e>/~?d||reEd(J(lE~m6RPTBH$PZ[fSw}uyS|qzuwG]B&2 O CF4dEXw|TS=93,:I@Q"zXG2s(Wj5R4kwbpp|y~&}D%YBedYBWeL]Ekn$oiE~ElohvL$^07_Xjx;sr5O=}F{~RmGdzo't]75MTUTU,'9_{<=#L";nO8Cn8?dejj*1u4I_`U1>>N&a9rH$P}(XZZ^>Crwu}}}T*i2z<c;Pl.9py;brEqJVe	%QJT]T(Ae]Ls~JD<JskWfBltMT,EI1R,.377k&"4#XZ+EW>|N^*|K\.m7_caaK_LaWd.|>.mHf` 9N1L}u5-iT*<=+|O+WoZi7p^j~7&q_(tGVI)0' 9_o~;,[onr,|}{oes$!v
!n<Ou!?wv(mI</N{T*8&(X\\D$t]o0^wu>tE"ik&o|}@Dz'O'`mlqxY^^>1pL,jZ1%g(d
d3U;,>L=,VejL!S.noF6om!1q"J?s]^$If;uDr_uX|Vl^[/UUt=iumLn8lr I*27M=gjZUSTUd0 (jk6Kv~e(\qP0\|w]j5v,ssvm%"r,uzzz"N{{yj?EQT.u>u,RQ	!(+(i8jPeUg%V.00;F__O3???~vMJ&aYL&;n?>J"NswfiGy!N%
^|%h;O$qJJPDTk8"HAGT^So4VT*U
RRBRZQ78K"@e&y>`8}yk##E~[:C
\-ox}x1w=RHOwEmOA&z_;vtgzij9R*EMeg<mll]\| $!7sUY{J/s#7QFldmR.(,_`JeV5fy?HwwYJx~>DO^'Bjul6O:]r~fmi2~@vQuy^z H~e$eYfqqxGu5]-#C/q~W~7{~}/O<8_745099IX'	;A ziB(<GQ6kVk4,q\md#(
;HS>}
UUBl^cM!"P5X^cYdWW{3=B**##FWc]}q0"Gk~NVZWLm;X{A2D\Wm"jHz4|/=?KdLIp du]Kk+,	R$CCGvbb]13y#Uq6b(d\<.*<H$g'HW[7tc24BD:Thv-e].Ct]_GyH#bT:%=<y4V{L,kVEQ4d2A:40"pd"gxyS:qU-U?-h
<=CV=*'+,7S	:xK>m[<u#8CX`seYFSd|YNHdv?-%@fnn}k^~I<p`7\&dT+jE|(BXz'<Y>x8x+w\~e;zTrZZX,/K{)*pMKy8CsY,yoPuYZZBe4M0LD4Yv
BuF7pIfN'Ib[Lm[7rN#oPz/wA?.~U$iUu5_ymw{)>rw~;5hT*e^_[f3XohiTAbU4qRnEXE>f\7HNj}dkw=@qXmsuzIU3C'}0e'&"!\d%)`n[n"dYnlcq1V2qwuK
sUNMaR\j|\_\Z'&*g&rE9=\uZj/B&N1<4@Xbh4%A,lc:NOP*Wf3tww~'B  4P:M\%B24GgM,wAUWm%IwATUmo7i|#;n!&{gy;_u+7Cynzzyg_5<#Cy[4u2<4uR"DjUyUrjeY,:9B<cjv^A^s|;fYZZM	F7hzRO.AQ U	Q5H&$C0eCA:2g"R LyxT+GaWo?jXHt:=[wL<V;s3h8sqdX\\/Vmo>h[ccB3'J"+&?kw/r^`6j0[+i:7o??~/}k/Bq^^s87\I0j*MUU4ZN>e<tdL5ul	?$
#L?sO\u6>CT<{!_l8w 4z'y{YZR.RUU*c<	|#[ Bh5^|u%Am$(]@OB$zZia~TU ?u[CQTb>X>c/z V+ )H$6)h\AAg;G4N,"!	t<_sULT#h[b;jI0FbO6oqsjl'OftLTL&>Y_py/5up>@2UKv=baJ-W`h!;{c$qSH;~Woc~zzzAf(K)z{3//0Yng34m~Vm_,B033__1q8~d{'9v<p\c+|G~lFuInd	,silak?#0R.Md,mb>+US5'uR)siu5o[xeuM[ORI
lE'4as &d]y!DL4B #"|Bx%[79]T.[T*6:;K:!a:m9aYm4O8qhS7grdn&z2k)*J{mUf652.!K65X4XzY+W!~p,I(,L?0D&\\ZEV`UCQM&eeBwmE<b0G[kk'mVkbQ_AR0M;wfY\\h0qFb	e14z|~}/Q291mKE05H$\tND*^9Zq~2oWIxyX79hgL~8eLEAJ%yw>VJ dqqI*fbB1zVm0H|/  Bp.2~$|_0TOZ]|.txwojS!kD"A&A[]{]GQi^287u^w-j5z\Jx+\/J$@:m,Ss/[qE333i=/76l6we|\W0X&KnbY 6:z6bSl4Jnn.3<!v4M_r%vg\9t]0FibmgM9u9trBRnV}\)#
($2Nr3K]HzSlpZl~V=daB
#r
#".77G~8$KkkU_};?oni$FMgi\!at+,/|<cb	CIGU'G4\K>LD(!I:b:c*(*Z~^{TH%yw|I$:$If#<OaiV7dn5"X)N"i%2-a[E}h13n]JMzI	m[xG?|7w/;$NH$I$H3W/|fe_,319#tsAsR|Q^4195ON),<x<1vQT^@-t/ TU\$IiE+ 4; " +2Iy,xZcqHkR`g	=&p(5VSk"^`sf-\hddw~v9EPfnf+TT]kVE&'o&Ic:Yeu6F1~T:_uuwgze/fi</Rl$xo~YzbAww>I3RfT+f}"Nk56N{61$O+GGah0z	v\s=g7*AOoPVU+GlD"TV!=831`tn:4McqqjJqxH& sYL|<ub2Pk5mG/-Zm$IbgqRIkij/$A+M7'9iM+0lGk%b	k".H$&v~x$GQD\fb|REH'K=wB2Zt*O.Ph16S,/0FxJE$(JD?'i3IiUBDLO?>+|+A/Nim!>3}CC=$:	S0[d2Flu=u:[lX=y>bs9,S{=uF_"$IJ~7^Y
SG TDaH>s]\,<e|}{DQ*2B\k\K\wMD77kC4jeb*iZ[.y)P7hXtCE \P^`j},,HCdb\\$ m<\ysGQql"L@SK+R)xZZ*01>AR4rtqn\ 7sJ><111M74)n"Xr)J.JRm9S:l&MH_v!YpxuC_h7iEHaFa^Pw=bxKONN<Om4x*"pyM:e3Hx*L>GYV<[UUqmynp[}C,^wdMtqygyK|aEU;faaChqHDeYk5rI$LAL;GWa_z"D6Hbt6/_WI$	qX^^&JssLMNX6	X=#
J:e!b&+/-MSaU=$R=ap\MfEPu*4|o{mIr$[8Kok'.==8[Rfd.a0)]m8r/=P,wRBxLe|bGl+GGQ(,wvq6{/	m70#I;|lH|3`)T)dH*BeF7!Dww7$s2,>qvVgNBT_LRA#IoVqIZn$og~~I@vnG8T*5rzb,ISIt3-}eUPBNn 3k k4b(P4I.j9dMFOsfy	%q\	s)
d2&yH)t}ubLMNFSN380Bz;:RZ-N&sEU0tDB'2L	ur[ijQ_600GH==/jie6%ALD$H $	EUPx?S4[|Qjx'C//l+WoCQ&/cF FVK_Gn:?x^C#d;v[V%'E<{{'`N 6E;yfpEQ};b#S`{4b(pXsTu6n@zbvLnYV%sG6QEK3i+_"/Pnw7M20Yf(+ejL`F>3l`|JU[&D+gZ ?mvVB^|zi/S3U4U%J*,e;.TtD74DL5x54<rZ=:}]`K|j&:5{?SVcbbWUsTV/l\mEVV:6Enu-GZ$
}}M[!K-?;H&L{9";mb'OHvcz,_T5]7y?DU9^\DQ<eZy(xPvtyEP
i7meky<~C	H2to @Qtx?(B3TWm\).3"A~0"4Apq+kk[2ZA\u=&&q]$l|F*4Uc(EY2Ih;&s?fQdClCJa!er`y^la[}?a9Xr^i4%k{H%3av_,u}>xo~?(74TWU0$C?s7,jxF^bkbq<<'B $\6`AowO*$Y\ZyRSXZRum8^c$	D4+_*xu7:}UL4	U`qA{ta]Ao[*iIku]"Gz{9}4Q0n\.O;S\4dMTg4c/~_E*RYdyC^S)W*eJ2rRLZT4P{^l6s;zsUd{{<q<z[a%''Y.),),ejh]7@%
G__bm]a=|hMQ&$fhHt]EUF*]NVZsjfinwnciSsi?`iqxh03WXi1a2r!RdTH0Q V<!o{;?3N*Z?D7L|w?Qaaz{{w/Clv5'u1ZiN<Eu@DY~IhXu	JFoXb8:-GInX]4St
 bGUcKK2	L/Gy.7{*^Bd39t|qIW:jrJ\TP,)+T*Uj*G9u0b^2idB'NZwnf.ds,,U%OX)p,jRJ$,LLM/zTk0Oo_d\6{gbyzlDTTMYHj=*vsEZY.^A+"+ ?y?%zo*e*'mu#z^
\Q}<<@W>k*ChIVm|G)Ub[u ENB =yP7;dsMc!IcGJq_$p_zd;L{xX4|CW)ff3,,.5
|9>I$dnqZ N]jl602	ef0PV/B$>qq*P$k*;e>ybDT\R%sq5bVVo\ K%uzeflbal|kJhi&0BLMY*TyrAlJj/{#CRt0p]D&sTUj)4n;!248F~3,zK2gSg\3h[rqQ7XhijYUAeqv,`x+DSBnu;'8~?p5o},8'OM}DlF[-=DuF{~f8<#o`a`zzYNlV4yB0 4R0==u:ystwc6d5mi4xm.xtw1:xBHa!xErKbd/@uRF-~kp.Jd*E~&T,m7|N+4Md
0Xc! O !2@$|I{>~-@A%0"4Sk>|_>8.L/*D.kO5=j60;[dlC/?cse@|Srk#78~t*As[r=Y,==ii}yXS^RH|	*Q7;b:|DhvN(\qfZ+~YLN|2\xW?Owtd"UVN>05qZ[?aw(Jeclo!Sgr1a=y:= 7\Q485u\2ovnqY8"<Ps L!lvz&Vktww	>o2"m{8w\dZ3V3XZ*u2UxXD$SI@QQ_>h+D":j=\;z^!N/=?A;Ai$7p/q"0tL O"`bjY745zwi
=14yf+R|]K`h#J(0`vB"K2<KMj,T$6>p}<qL76&,\$C7TaZB#{4j]Fuc0I%Afss~E+_-a)K?Leoz3iro|X6^yB9lc"+,,~'0~~I?,Kj0DI"(@/,@_*7o311UT4h>,ZjvW{ER1?@Z}ry&%E6o6W a`j&UzCFZG"v5	w}$ox;m\&{&sO43g|tL&d2&IF:@:e$S:3w4OOwg)hl-umax]4iMIMjq7f%:&aYuW3/a9n5<k6RhJB]7oAlQ(Avm{M,6I/wq3 ;NUTZ&M8o3qCD+%$$O21947LLLsmqmQNq]}g`O395m7]MwwK.aqkIW>"z>vm|Vj|ZynW:di-JZ8Nl9kOOO7\cEQMHIB"MmnK)9LMvakv'|a%IM#},9RW&a1:q\3Kr&]$"S;lv[c|FH.u}$W_wKx TXTkZnqLOOm	E!?|([6 QwFx~e{\<ztyr+kKs3exzW8oGbnn~yx0gS[uBzH'S||[rQ^OjL`&eda@_7{Nf8r7g#UY r.J[v|936lWXto}K"aIIzslrS3,,,att.*m5ZuZl=4Mk7 ]gul&J7LL*Eo_?f"w)Vt2MT?}vMzUW1:Ve
ynFjRe`0c76`dIj7ceAKg2W~Z0ezW?irY	M)m.ITS?4S'4"]Gv%33UbYnhnm"5UYXy6opzT2m"7WkV13])*9#!/nDbq'$

%{z?2
}W,?g>tie	gcci?8B.jbQLYTUat,\#nR1 6_H6'NAR3q~
Ea{iI4\OCYvn4f|_o&R=n+ym2Zt&79l1=5>U(#`l&K|n_"f4$YBVertne!s!@V%]F5T0zZHID$@%0L.lEQz3{Cv'ILJy!$ov^e>^&;nm'-8N|?35SaaQ^gnBIg$S&=}1PV7Z2_UY+n[}]7dQ*d2U
+Sa!C$)$4GJRlE:VR~`Pe|bqn{RC9$zGK'7Fg_5w%G}?m??{`L&MPd`Ykz$:rL"	XZ0]xGNhXuOxw^ed2D|o'Oaeyi9,khNL`	V7s.%C78ZD"s!2W+(V2YIPQQd pl?l6U8|oUox
r.lHBbfi3{