Settings packet
 *
 * The eeprom settings packet contains information on the non-volatile ECU
 * settings stored in eeprom. In particular, it provides a checksum of the
 * settings data for easy comparison of settings between different ECUs. Send a
 * zero length packet to request this data.
 * \param _pg_pkt points to the packet being decoded by this function
 * \param eepromVersion receives Version of the EEPROM data
 * \param eepromSize receives Number of bytes of the EEPROM data
 * \param eepromChecksum receives Fletcher's checksum of the EEPROM data
 * \param compileOptions receives ECU compilation options
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeECU_eepromSettingsPacket(const void* _pg_pkt, uint8_t* eepromVersion, uint16_t* eepromSize, uint16_t* eepromChecksum, ECU_CompileOptions_t* compileOptions)
{
    int _pg_byteindex = 0;
    const uint8_t* _pg_data = getECUPacketDataConst(_pg_pkt);
    int _pg_numbytes = getECUPacketSize(_pg_pkt);

    // Verify the packet identifier
    if(getECUPacketID(_pg_pkt) != getECU_eepromSettingsPacketID())
        return 0;

    if(_pg_numbytes < getECU_eepromSettingsMinDataLength())
        return 0;

    // Version of the EEPROM data
    // Range of eepromVersion is 0 to 255.
    (*eepromVersion) = uint8FromBytes(_pg_data, &_pg_byteindex);

    // Number of bytes of the EEPROM data
    // Range of eepromSize is 0 to 65535.
    (*eepromSize) = uint16FromBeBytes(_pg_data, &_pg_byteindex);

    // Fletcher's checksum of the EEPROM data
    // Range of eepromChecksum is 0 to 65535.
    (*eepromChecksum) = uint16FromBeBytes(_pg_data, &_pg_byteindex);

    // ECU compilation options
    if(decodeECU_CompileOptions_t(_pg_data, &_pg_byteindex, compileOptions) == 0)
        return 0;

    return 1;

}// decodeECU_eepromSettingsPacket

/*!
 * \brief Create the ECU_CHTLoopSettings packet
 *
 * Control loop settings for the CHT control loop
 * \param _pg_pkt points to the packet which will be created by this function
 * \param _pg_user points to the user data that will be encoded in _pg_pkt
 */
void encodeECU_CHTLoopSettingsPacketStructure(void* _pg_pkt, const ECU_CHTLoopSettings_t* _pg_user)
{
    uint8_t* _pg_data = getECUPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    _pg_data[_pg_byteindex] = 0;

    // Filter value for derivative term
    // Range of dTermFilter is 0 to 31.
    _pg_data[_pg_byteindex] |= (uint8_t)limitMax(_pg_user->dTermFilter, 31) << 1;

    // CHT control loop enabled
    _pg_data[_pg_byteindex] |= (uint8_t)((_pg_user->enabled == true) ? 1 : 0);
    _pg_byteindex += 1; // close bit field


    // Target CHT temperature
    // Range of targetTemp is 0 to 255.
    uint8ToBytes(_pg_user->targetTemp, _pg_data, &_pg_byteindex);

    // Proportaional gain Kp
    // Range of Kp is 0.0f to 65.535f.
    float32ScaledTo2UnsignedBeBytes(_pg_user->Kp, _pg_data, &_pg_byteindex, 0.0f, 1000.0f);

    // Proportaional gain Ki
    // Range of Ki is 0.0f to 65.535f.
    float32ScaledTo2UnsignedBeBytes(_pg_user->Ki, _pg_data, &_pg_byteindex, 0.0f, 1000.0f);

    // Proportaional gain Kd
    // Range of Kd is 0.0f to 65.535f.
    float32ScaledTo2UnsignedBeBytes(_pg_user->Kd, _pg_data, &_pg_byteindex, 0.0f, 1000.0f);

    // complete the process of creating the packet
    finishECUPacket(_pg_pkt, _pg_byteindex, getECU_CHTLoopSettingsPacketID());

}// encodeECU_CHTLoopSettingsPacketStructure

/*!
 * \brief Decode the ECU_CHTLoopSettings packet
 *
 * Control loop settings for the CHT control loop
 * \param _pg_pkt points to the packet being decoded by this function
 * \param _pg_user receives the data decoded from the packet
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeECU_CHTLoopSettingsPacketStructure(const void* _pg_pkt, ECU_CHTLoopSettings_t* _pg_user)
{
    int _pg_numbytes;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data;

    // Verify the packet identifier
    if(getECUPacketID(_pg_pkt) != getECU_CHTLoopSettingsPacketID())
        return 0;

    // Verify the packet size
    _pg_numbytes = getECUPacketSize(_pg_pkt);
    if(_pg_numbytes < getECU_CHTLoopSettingsMinDataLength())
        return 0;

    // The raw data from the packet
    _pg_data = getECUPacketDataConst(_pg_pkt);

    // Filter value for derivative term
    // Range of dTermFilter is 0 to 31.
    _pg_user->dTermFilter = ((_pg_data[_pg_byteindex] >> 1) & 0x1F);

    // CHT control loop enabled
    _pg_user->enabled = (((_pg_data[_pg_byteindex]) & 0x1)) ? true : false;
    _pg_byteindex += 1; // close bit field

    // Target CHT temperature
    // Range of targetTemp is 0 to 255.
    _pg_user->targetTemp = uint8FromBytes(_pg_data, &_pg_byteindex);

    // Proportaional gain Kp
    // Range of Kp is 0.0f to 65.535f.
    _pg_user->Kp = float32ScaledFrom2UnsignedBeBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/1000.0f);

    // Proportaional gain Ki
    // Range of Ki is 0.0f to 65.535f.
    _pg_user->Ki = float32ScaledFrom2UnsignedBeBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/1000.0f);

    // Proportaional gain Kd
    // Range of Kd is 0.0f to 65.535f.
    _pg_user->Kd = float32ScaledFrom2UnsignedBeBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/1000.0f);

    return 1;

}// decodeECU_CHTLoopSettingsPacketStructure

/*!
 * \brief Create the ECU_CHTLoopSettings packet
 *
 * Control loop settings for the CHT control loop
 * \param _pg_pkt points to the packet which will be created by this function
 * \param dTermFilter is Filter value for derivative term
 * \param enabled is CHT control loop enabled
 * \param targetTemp is Target CHT temperature
 * \param Kp is Proportaional gain Kp
 * \param Ki is Proportaional gain Ki
 * \param Kd is Proportaional gain Kd
 */
void encodeECU_CHTLoopSettingsPacket(void* _pg_pkt, uint8_t dTermFilter, bool enabled, uint8_t targetTemp, float Kp, float Ki, float Kd)
{
    uint8_t* _pg_data = getECUPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    _pg_data[_pg_byteindex] = 0;

    // Filter value for derivative term
    // Range of dTermFilter is 0 to 31.
    _pg_data[_pg_byteindex] |= (uint8_t)limitMax(dTermFilter, 31) << 1;

    // CHT control loop enabled
    _pg_data[_pg_byteindex] |= (uint8_t)((enabled == true) ? 1 : 0);
    _pg_byteindex += 1; // close bit field

    // Target CHT temperature
    // Range of targetTemp is 0 to 255.
    uint8ToBytes(targetTemp, _pg_data, &_pg_byteindex);

    // Proportaional gain Kp
    // Range of Kp is 0.0f to 65.535f.
    float32ScaledTo2UnsignedBeBytes(Kp, _pg_data, &_pg_byteindex, 0.0f, 1000.0f);

    // Proportaional gain Ki
    // Range of Ki is 0.0f to 65.535f.
    float32ScaledTo2UnsignedBeBytes(Ki, _pg_data, &_pg_byteindex, 0.0f, 1000.0f);

    // Proportaional gain Kd
    // Range of Kd is 0.0f to 65.535f.
    float32ScaledTo2UnsignedBeBytes(Kd, _pg_data, &_pg_byteindex, 0.0f, 1000.0f);

    // complete the process of creating the packet
    finishECUPacket(_pg_pkt, _pg_byteindex, getECU_CHTLoopSettingsPacketID());

}// encodeECU_CHTLoopSettingsPacket

/*!
 * \brief Decode the ECU_CHTLoopSettings packet
 *
 * Control loop settings for the CHT control loop
 * \param _pg_pkt points to the packet being decoded by this function
 * \param dTermFilter receives Filter value for derivative term
 * \param enabled receives CHT control loop enabled
 * \param targetTemp receives Target CHT temperature
 * \param Kp receives Proportaional gain Kp
 * \param Ki receives Proportaional gain Ki
 * \param Kd receives Proportaional gain Kd
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeECU_CHTLoopSettingsPacket(const void* _pg_pkt, uint8_t* dTermFilter, bool* enabled, uint8_t* targetTemp, float* Kp, float* Ki, float* Kd)
{
    int _pg_byteindex = 0;
    const uint8_t* _pg_data = getECUPacketDataConst(_pg_pkt);
    int _pg_numbytes = getECUPacketSize(_pg_pkt);

    // Verify the packet identifier
    if(getECUPacketID(_pg_pkt) != getECU_CHTLoopSettingsPacketID())
        return 0;

    if(_pg_numbytes < getECU_CHTLoopSettingsMinDataLength())
        return 0;

    // Filter value for derivative term
    // Range of dTermFilter is 0 to 31.
    (*dTermFilter) = ((_pg_data[_pg_byteindex] >> 1) & 0x1F);

    // CHT control loop enabled
    (*enabled) = (((_pg_data[_pg_byteindex]) & 0x1)) ? true : false;
    _pg_byteindex += 1; // close bit field

    // Target CHT temperature
    // Range of targetTemp is 0 to 255.
    (*targetTemp) = uint8FromBytes(_pg_data, &_pg_byteindex);

    // Proportaional gain Kp
    // Range of Kp is 0.0f to 65.535f.
    (*Kp) = float32ScaledFrom2UnsignedBeBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/1000.0f);

    // Proportaional gain Ki
    // Range of Ki is 0.0f to 65.535f.
    (*Ki) = float32ScaledFrom2UnsignedBeBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/1000.0f);

    // Proportaional gain Kd
    // Range of Kd is 0.0f to 65.535f.
    (*Kd) = float32ScaledFrom2UnsignedBeBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/1000.0f);

    return 1;

}// decodeECU_CHTLoopSettingsPacket

/*!
 * \brief Create the ECU_DualPumpControlTelemetry packet
 *
 * Dual pump control telemetry. Send a zero-length packet with this identifier
 * to the ECU to poll (request) this packet.
 * \param _pg_pkt points to the packet which will be created by this function
 * \param _pg_user points to the user data that will be encoded in _pg_pkt
 */
void encodeECU_DualPumpControlTelemetryPacketStructure(void* _pg_pkt, const ECU_DualPumpControlTelemetry_t* _pg_user)
{
    uint8_t* _pg_data = getECUPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    uint8ToBytes((uint8_t)(0xBB), _pg_data, &_pg_byteindex);

    // Current pump mode (which pump is running). Refer to the DualFuelPumpMode enumeration.
    // Range of mode is 0 to 7.
    _pg_data[_pg_byteindex] = (uint8_t)limitMax(_pg_user->mode, 7) << 5;

    // Current pump state machine state. Refer to the DualFuelPumpState enumeration.
    // Range of state is 0 to 7.
    _pg_data[_pg_byteindex] |= (uint8_t)limitMax(_pg_user->state, 7) << 2;
    _pg_byteindex += 1; // close bit field


    // Time spent in current state
    // Range of stateTimer is 0 to 65535.
    uint16ToBeBytes(_pg_user->stateTimer, _pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finishECUPacket(_pg_pkt, _pg_byteindex, getECU_DualPumpControlTelemetryPacketID());

}// encodeECU_DualPumpControlTelemetryPacketStructure

/*!
 * \brief Decode the ECU_DualPumpControlTelemetry packet
 *
 * Dual pump control telemetry. Send a zero-length packet with this identifier
 * to the ECU to poll (request) this packet.
 * \param _pg_pkt points to the packet being decoded by this function
 * \param _pg_user receives the data decoded from the packet
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeECU_DualPumpControlTelemetryPacketStructure(const void* _pg_pkt, ECU_DualPumpControlTelemetry_t* _pg_user)
{
    int _pg_numbytes;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data;

    // Verify the packet identifier
    if(getECUPacketID(_pg_pkt) != getECU_DualPumpControlTelemetryPacketID())
        return 0;

    // Verify the packet size
    _pg_numbytes = getECUPacketSize(_pg_pkt);
    if(_pg_numbytes < getECU_DualPumpControlTelemetryMinDataLength())
        return 0;

    // The raw data from the packet
    _pg_data = getECUPacketDataConst(_pg_pkt);

    if (uint8FromBytes(_pg_data, &_pg_byteindex) != (uint8_t) 0xBB)
        return 0;

    // Current pump mode (which pump is running). Refer to the DualFuelPumpMode enumeration.
    // Range of mode is 0 to 7.
    _pg_user->mode = (_pg_data[_pg_byteindex] >> 5);

    // Current pump state machine state. Refer to the DualFuelPumpState enumeration.
    // Range of state is 0 to 7.
    _pg_user->state = ((_pg_data[_pg_byteindex] >> 2) & 0x7);
    _pg_byteindex += 1; // close bit field

    // Time spent in current state
    // Range of stateTimer is 0 to 65535.
    _pg_user->stateTimer = uint16FromBeBytes(_pg_data, &_pg_byteindex);

    return 1;

}// decodeECU_DualPumpControlTelemetryPacketStructure

/*!
 * \brief Create the ECU_DualPump_SetTelemetryPeriod packet
 *
 * Set the telemetry period for dual-pump messages
 * \param _pg_pkt points to the packet which will be created by this function
 * \param period is Telemetry period (0 = Off)
 */
void encodeECU_DualPump_SetTelemetryPeriodPacket(void* _pg_pkt, uint8_t period)
{
    uint8_t* _pg_data = getECUPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    uint8ToBytes((uint8_t)(0xBB), _pg_data, &_pg_byteindex);

    // Telemetry period (0 = Off)
    // Range of period is 0 to 255.
    uint8ToBytes(period, _pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finishECUPacket(_pg_pkt, _pg_byteindex, getECU_DualPump_SetTelemetryPeriodPacketID());

}// encodeECU_DualPump_SetTelemetryPeriodPacket

/*!
 * \brief Decode the ECU_DualPump_SetTelemetryPeriod packet
 *
 * Set the telemetry period for dual-pump messages
 * \param _pg_pkt points to the packet being decoded by this function
 * \param period receives Telemetry period (0 = Off)
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeECU_DualPump_SetTelemetryPeriodPacket(const void* _pg_pkt, uint8_t* period)
{
    int _pg_byteindex = 0;
    const uint8_t* _pg_data = getECUPacketDataConst(_pg_pkt);
    int _pg_numbytes = getECUPacketSize(_pg_pkt);

    // Verify the packet identifier
    if(getECUPacketID(_pg_pkt) != getECU_DualPump_SetTelemetryPeriodPacketID())
        return 0;

    if(_pg_numbytes < getECU_DualPump_SetTelemetryPeriodMinDataLength())
        return 0;

    if (uint8FromBytes(_pg_data, &_pg_byteindex) != (uint8_t) 0xBB)
        return 0;

    // Telemetry period (0 = Off)
    // Range of period is 0 to 255.
    (*period) = uint8FromBytes(_pg_data, &_pg_byteindex);

    return 1;

}// decodeECU_DualPump_SetTelemetryPeriodPacket

/*!
 * \brief Create the ECU_DualPump_SelectPump packet
 *
 * Command to manually select a given pump mode.
 * \param _pg_pkt points to the packet which will be created by this function
 * \param pump is Pump selection (see DualFuelPumpMode enumeration)
 */
void encodeECU_DualPump_SelectPumpPacket(void* _pg_pkt, uint8_t pump)
{
    uint8_t* _pg_data = getECUPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    uint8ToBytes((uint8_t)(0xCC), _pg_data, &_pg_byteindex);

    uint8ToBytes((uint8_t)(ECU_DUAL_PUMP_CMD_SET_PUMP), _pg_data, &_pg_byteindex);

    // Pump selection (see DualFuelPumpMode enumeration)
    // Range of pump is 0 to 255.
    uint8ToBytes(pump, _pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finishECUPacket(_pg_pkt, _pg_byteindex, getECU_DualPump_SelectPumpPacketID());

}// encodeECU_DualPump_SelectPumpPacket

/*!
 * \brief Decode the ECU_DualPump_SelectPump packet
 *
 * Command to manually select a given pump mode.
 * \param _pg_pkt points to the packet being decoded by this function
 * \param pump receives Pump selection (see DualFuelPumpMode enumeration)
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeECU_DualPump_SelectPumpPacket(const void* _pg_pkt, uint8_t* pump)
{
    int _pg_byteindex = 0;
    const uint8_t* _pg_data = getECUPacketDataConst(_pg_pkt);
    int _pg_numbytes = getECUPacketSize(_pg_pkt);

    // Verify the packet identifier
    if(getECUPacketID(_pg_pkt) != getECU_DualPump_SelectPumpPacketID())
        return 0;

    if(_pg_numbytes < getECU_DualPump_SelectPumpMinDataLength())
        return 0;

    if (uint8FromBytes(_pg_data, &_pg_byteindex) != (uint8_t) 0xCC)
        return 0;

    if (uint8FromBytes(_pg_data, &_pg_byteindex) != (uint8_t) ECU_DUAL_PUMP_CMD_SET_PUMP)
        return 0;

    // Pump selection (see DualFuelPumpMode enumeration)
    // Range of pump is 0 to 255.
    (*pump) = uint8FromBytes(_pg_data, &_pg_byteindex);

    return 1;

}// decodeECU_DualPump_SelectPumpPacket

/*!
 * \brief Create the ECU_DualPump_TestPump packet
 *
 * Command to temporarily run a particular pump in test mode. ECU will revert
 * to OTHER pump when test expires
 * \param _pg_pkt points to the packet which will be created by this function
 * \param _pg_user points to the user data that will be encoded in _pg_pkt
 */
void encodeECU_DualPump_TestPumpPacketStructure(void* _pg_pkt, const ECU_DualPump_TestPump_t* _pg#pragma once

#include "AP_RangeFinder_config.h"

#if AP_RANGEFINDER_LUA_ENABLED

#include "AP_RangeFinder_Backend.h"

// Data timeout
#define AP_RANGEFINDER_LUA_TIMEOUT_MS 500

class AP_RangeFinder_Lua : public AP_RangeFinder_Backend
{
public:

    // constructor
    AP_RangeFinder_Lua(RangeFinder::RangeFinder_State &_state, AP_RangeFinder_Params &_params);

    // update state
    void update(void) override;

    // Get update from Lua script
    bool handle_script_msg(float dist_m) override;
    bool handle_script_msg(const RangeFinder::RangeFinder_State &state_arg) override;

    MAV_DISTANCE_SENSOR _get_mav_distance_sensor_type() const override {
        return MAV_DISTANCE_SENSOR_UNKNOWN;
    }

private:

    RangeFinder::RangeFinder_State _state_pending = {};
};

#endif  // AP_RANGEFINDER_LUA_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             /*
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include "AP_RangeFinder_MAVLink.h"

#if AP_RANGEFINDER_MAVLINK_ENABLED

#include <AP_HAL/AP_HAL.h>

/*
   Set the distance based on a MAVLINK message
*/
void AP_RangeFinder_MAVLink::handle_msg(const mavlink_message_t &msg)
{
    mavlink_distance_sensor_t packet;
    mavlink_msg_distance_sensor_decode(&msg, &packet);

    // only accept distances for the configured orientation
    if (packet.orientation == orientation()) {
        state.last_reading_ms = AP_HAL::millis();
        distance_cm = packet.current_distance;
        _max_distance_cm = packet.max_distance;
        _min_distance_cm = packet.min_distance;
        sensor_type = (MAV_DISTANCE_SENSOR)packet.type;
        signal_quality = packet.signal_quality;
        if (signal_quality == 0) {
            // MAVLink's 0 means invalid/unset, so we map it to -1
            signal_quality = RangeFinder::SIGNAL_QUALITY_UNKNOWN;
        } else if (signal_quality == 1) {
            // Map 1 to 0 as that is what ardupilot uses as the worst signal quality
            signal_quality = RangeFinder::SIGNAL_QUALITY_MIN;
        }
    }
}

int16_t AP_RangeFinder_MAVLink::max_distance_cm() const
{
    if (_max_distance_cm == 0 && _min_distance_cm == 0) {
        // we assume if both of these are zero that we ignore both
        return params.max_distance_cm;
    }

    if (params.max_distance_cm < _max_distance_cm) {
        return params.max_distance_cm;
    }
    return _max_distance_cm;
}
int16_t AP_RangeFinder_MAVLink::min_distance_cm() const
{
    if (_max_distance_cm == 0 && _min_distance_cm == 0) {
        // we assume if both of these are zero that we ignore both
        return params.min_distance_cm;
    }
    if (params.min_distance_cm > _min_distance_cm) {
        return params.min_distance_cm;
    }
    return _min_distance_cm;
}

/*
   update the state of the sensor
*/
void AP_RangeFinder_MAVLink::update(void)
{
    //Time out on incoming data; if we don't get new
    //data in 500ms, dump it
    if (AP_HAL::millis() - state.last_reading_ms > AP_RANGEFINDER_MAVLINK_TIMEOUT_MS) {
        set_status(RangeFinder::Status::NoData);
        state.distance_m = 0.0f;
        state.signal_quality_pct = RangeFinder::SIGNAL_QUALITY_UNKNOWN;
    } else {
        state.distance_m = distance_cm * 0.01f;
        state.signal_quality_pct = signal_quality;
        update_status();
    }
}

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             #pragma once

#include "AP_RangeFinder_config.h"

#if AP_RANGEFINDER_MAXSONARI2CXL_ENABLED

#include "AP_RangeFinder.h"
#include "AP_RangeFinder_Backend.h"

#include <AP_HAL/I2CDevice.h>

#define AP_RANGE_FINDER_MAXSONARI2CXL_DEFAULT_ADDR   0x70
#define AP_RANGE_FINDER_MAXSONARI2CXL_COMMAND_TAKE_RANGE_READING 0x51

class AP_RangeFinder_MaxsonarI2CXL : public AP_RangeFinder_Backend
{
public:
    // static detection function
    static AP_RangeFinder_Backend *detect(RangeFinder::RangeFinder_State &_state,
                                          AP_RangeFinder_Params &_params,
                                          AP_HAL::OwnPtr<AP_HAL::I2CDevice> dev);

    // update state
    void update(void) override;

protected:

    MAV_DISTANCE_SENSOR _get_mav_distance_sensor_type() const override {
        return MAV_DISTANCE_SENSOR_ULTRASOUND;
    }

private:
    // constructor
    AP_RangeFinder_MaxsonarI2CXL(RangeFinder::RangeFinder_State &_state,
    								AP_RangeFinder_Params &_params,
                                 AP_HAL::OwnPtr<AP_HAL::I2CDevice> dev);

    bool _init(void);
    void _timer(void);

    uint16_t distance;
    bool new_distance;
    
    // start a reading
    bool start_reading(void);
    bool get_reading(uint16_t &reading_cm);
    AP_HAL::OwnPtr<AP_HAL::I2CDevice> _dev;
};

#endif  // AP_RANGEFINDER_MAXSONARI2CXL_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         /*
 * Copyright (C) 2016  Intel Corporation. All rights reserved.
 *
 * This file is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This file is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include "AP_RangeFinder_MaxsonarSerialLV.h"

#if AP_RANGEFINDER_MAXBOTIX_SERIAL_ENABLED

#include <AP_HAL/AP_HAL.h>
#include <ctype.h>

#define MAXSONAR_SERIAL_LV_BAUD_RATE 9600

extern const AP_HAL::HAL& hal;

AP_RangeFinder_MaxsonarSerialLV::AP_RangeFinder_MaxsonarSerialLV(
    RangeFinder::RangeFinder_State &_state,
    AP_RangeFinder_Params &_params):
    AP_RangeFinder_Backend_Serial(_state, _params)
{
    params.scaling.set_default(0.0254f);
}

// read - return last value measured by sensor
bool AP_RangeFinder_MaxsonarSerialLV::get_reading(float &reading_m)
{
    if (uart == nullptr) {
        return false;
    }

    int32_t sum = 0;
    uint16_t count = 0;

    for (auto i=0; i<8192; i++) {
        uint8_t c;
        if (!uart->read(c)) {
            break;
        }
        if (c == '\r') {
            linebuf[linebuf_len] = 0;
            sum += (int)atoi(linebuf);
            count++;
            linebuf_len = 0;
        } else if (isdigit(c)) {
            linebuf[linebuf_len++] = c;
            if (linebuf_len == sizeof(linebuf)) {
                // too long, discard the line
                linebuf_len = 0;
            }
        }
    }

    if (count == 0) {
        return false;
    }

    // This sonar gives the metrics in inches, so we have to transform this to meters
    reading_m = params.scaling * (float(sum) / count);

    return true;
}

#endif  // AP_RANGEFINDER_MAXBOTIX_SERIAL_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            #pragma once

#include "AP_RangeFinder_config.h"

#if AP_RANGEFINDER_MAXBOTIX_SERIAL_ENABLED

#include "AP_RangeFinder.h"
#include "AP_RangeFinder_Backend_Serial.h"

class AP_RangeFinder_MaxsonarSerialLV : public AP_RangeFinder_Backend_Serial
{

public:

    static AP_RangeFinder_Backend_Serial *create(
        RangeFinder::RangeFinder_State &_state,
        AP_RangeFinder_Params &_params) {
        return NEW_NOTHROW AP_RangeFinder_MaxsonarSerialLV(_state, _params);
    }

protected:

    MAV_DISTANCE_SENSOR _get_mav_distance_sensor_type() const override {
        return MAV_DISTANCE_SENSOR_ULTRASOUND;
    }

private:

    AP_RangeFinder_MaxsonarSerialLV(RangeFinder::RangeFinder_State &_state, AP_RangeFinder_Params &_params);

    // get a reading
    bool get_reading(float &reading_m) override;

    uint16_t read_timeout_ms() const override { return 500; }

    char linebuf[10];
    uint8_t linebuf_len = 0;
};

#endif  // AP_RANGEFINDER_MAXBOTIX_SERIAL_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               /*
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * RDS02UF Note:
 * Sensor range scope 1.5m~20.0m
 * Azimuth Coverage ±17°,Elevation Coverage ±3°
 * Frame Rate 20Hz
 */

#include "AP_RangeFinder_config.h"

#if AP_RANGEFINDER_RDS02UF_ENABLED

#include "AP_RangeFinder_RDS02UF.h"
#include <AP_HAL/AP_HAL.h>

#define RDS02_HEAD                  0x55
#define RDS02_END                   0xAA
#define RDS02UF_PRE_DATA_LEN        6
#define RDS02_TARGET_INFO_FC        0x070C
#define RDS02UF_IGNORE_ID_BYTE      0x0F0F
#define RDS02UF_UAV_PRODUCTS_ID     0x03FF
#define RDS02UF_IGNORE_CRC          0xFF
#define RDS02UF_NO_ERR              0x00

bool AP_RangeFinder_RDS02UF::get_reading(float &distance_m)
{
    if (uart == nullptr) {
        return false;
    }

    const uint32_t nbytes = uart->read(&u.parse_buffer[body_length],
                                 ARRAY_SIZE(u.parse_buffer)-body_length);
    if (nbytes == 0) {
        return false;
    }
    body_length += nbytes;

    move_header_in_buffer(0);

    // header byte 1 is correct.
    if (body_length < ARRAY_SIZE(u.parse_buffer)) {
        // need a full buffer to have a valid message...
        return false;
    }

    if (u.packet.headermagic2 != RDS02_HEAD) {
        move_header_in_buffer(1);
        return false;
    }

    const uint16_t read_len = u.packet.length_h << 8 | u.packet.length_l;
    if (read_len != RDS02UF_DATA_LEN) {
        // we can only accept the fixed length message
        move_header_in_buffer(1);
        return false;
    }

    // check for the footer signatures:
    if (u.packet.footermagic1 != RDS02_END) {
        move_header_in_buffer(1);
        return false;
    }
    if (u.packet.footermagic2 != RDS02_END) {
        move_header_in_buffer(1);
        return false;
    }

    // calculate checksum
    const uint8_t checksum = crc8_rds02uf(&u.parse_buffer[2], RDS02UF_PRE_DATA_LEN + RDS02UF_DATA_LEN);
    if (u.packet.checksum != checksum && u.packet.checksum != RDS02UF_IGNORE_CRC) {
        move_header_in_buffer(1);
        return false;
    }

    const uint16_t fc_code = (u.packet.fc_high << 8 | u.packet.fc_low);
    if (fc_code == RDS02UF_UAV_PRODUCTS_ID && u.packet.error_code == RDS02UF_NO_ERR) {
        // get target information
        const uint16_t read_info_fc = (u.packet.data[1] << 8 | u.packet.data[0]);
        if ((read_info_fc & RDS02UF_IGNORE_ID_BYTE) == RDS02_TARGET_INFO_FC) {
            // read_info_fc = 0x70C + ID * 0x10, ID: 0~0xF
            distance_m = (u.packet.data[6] * 256 + u.packet.data[5]) * 0.01f;
            state.last_reading_ms = AP_HAL::millis();
        }
    }

    // reset buffer
    body_length = 0;
    return true;
}

// find a RDS02UF message in the buffer, starting at
// initial_offset.  If found, that message (or partial message) will
// be moved to the start of the buffer.
void AP_RangeFinder_RDS02UF::move_header_in_buffer(uint8_t initial_offset)
{
    uint8_t* header_ptr = (uint8_t*)memchr(&u.parse_buffer[initial_offset], RDS02_HEAD, body_length - initial_offset);
    if (header_ptr != nullptr) {
        size_t header_offset = header_ptr - &u.parse_buffer[0];
        if (header_offset != 0) {
            // header was found, but not at index 0; move it back to start of array
            memmove(u.parse_buffer, header_ptr, body_length - header_offset);
            body_length -= header_offset;
        }
    } else {
        // no header found; reset buffer
        body_length = 0;
    }
}

#endif  // AP_RANGEFINDER_RDS02UF_ENABLED

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     /*
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#pragma once

#include "AP_RangeFinder_config.h"

#if AP_RANGEFINDER_RDS02UF_ENABLED

#include "AP_RangeFinder.h"
#include "AP_RangeFinder_Backend_Serial.h"

#define RDS02_BUFFER_SIZE           50
#define RDS02UF_DIST_MAX_CM         2000
#define RDS02UF_DIST_MIN_CM         150
#define RDS02UF_DATA_LEN            10

class AP_RangeFinder_RDS02UF : public AP_RangeFinder_Backend_Serial
{

public:

    static AP_RangeFinder_Backend_Serial *create(
        RangeFinder::RangeFinder_State &_state,
        AP_RangeFinder_Params &_params) {
        return NEW_NOTHROW AP_RangeFinder_RDS02UF(_state, _params);
    }

protected:

    MAV_DISTANCE_SENSOR _get_mav_distance_sensor_type() const override {
        return MAV_DISTANCE_SENSOR_RADAR;
    }

private:
    using AP_RangeFinder_Backend_Serial::AP_RangeFinder_Backend_Serial;

    // find a RDS02UF message in the buffer, starting at
    // initial_offset.  If found, that message (or partial message) will
    // be moved to the start of the buffer.
    void move_header_in_buffer(uint8_t initial_offset);

    // get a distance reading
    bool get_reading(float &reading_m) override;
    uint16_t read_timeout_ms() const override { return 500; }

    // make sure readings go out-of-range when necessary
    int16_t max_distance_cm()const override  { return MIN(params.max_distance_cm, RDS02UF_DIST_MAX_CM); }
    int16_t min_distance_cm() const override { return MAX(params.min_distance_cm, RDS02UF_DIST_MIN_CM); }

     // Data Format for Benewake Rds02UF
    // ===============================
    // 21 bytes total per message:
    // 1) 0x55
    // 2) 0x55
    // 3) address
    // 4) error_code
    // 5) FC_CODE_L (low 8bit)
    // 6) FC_CODE_H (high 8bit)
    // 7) LENGTH_L (low 8bit)
    // 8) LENGTH_H (high 8bit)
    // 9) REAL_DATA (10Byte)
    // 10) CRC8
    // 11) END_1 0xAA
    // 12) END_2 0xAA
    struct PACKED RDS02UFPacket {
        uint8_t headermagic1;
        uint8_t headermagic2;
        uint8_t address;
        uint8_t error_code;
        uint8_t fc_low;
        uint8_t fc_high;
        uint8_t length_l;
        uint8_t length_h;
        uint8_t data[RDS02UF_DATA_LEN];
        uint8_t checksum;
        uint8_t footermagic1;
        uint8_t footermagic2;
    };

    union RDS02UF_Union {
        uint8_t parse_buffer[21];
        struct RDS02UFPacket packet;
    };
    RDS02UF_Union u;

    // number of bytes currently in the buffer
    uint8_t body_length;
};
#endif  // AP_RANGEFINDER_RDS02UF_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        /*
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
#include "AP_RangeFinder_SITL.h"

#if AP_RANGEFINDER_SIM_ENABLED

#include <AP_HAL/AP_HAL.h>
#include <SITL/SITL.h>

/*
  constructor - registers instance at top RangeFinder driver
 */
AP_RangeFinder_SITL::AP_RangeFinder_SITL(RangeFinder::RangeFinder_State &_state, AP_RangeFinder_Params &_params, uint8_t instance) :
    AP_RangeFinder_Backend(_state, _params),
    _instance(instance)
{}

/*
  update distance_cm
 */
void AP_RangeFinder_SITL::update(void)
{
    const float dist = AP::sitl()->get_rangefinder(_instance);

    // nan distance means nothing is connected
    if (isnan(dist) || isinf(dist)) {
        state.status = RangeFinder::Status::NoData;
        return;
    }

    state.distance_m = MAX(0, dist);
    state.last_reading_ms = AP_HAL::millis();

    // update range_valid state based on distance measured
    update_status();
}

#endif  // AP_RANGEFINDER_SIM_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              /*
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
#pragma once

#include "AP_RangeFinder_config.h"

#if AP_RANGEFINDER_SIM_ENABLED

#include "AP_RangeFinder_Backend.h"

class AP_RangeFinder_SITL : public AP_RangeFinder_Backend {
public:
    // constructor. This incorporates initialisation as well.
    AP_RangeFinder_SITL(RangeFinder::RangeFinder_State &_state, AP_RangeFinder_Params &_params, uint8_t instance);

    // update the state structure
    void update() override;

protected:

    MAV_DISTANCE_SENSOR _get_mav_distance_sensor_type() const override {
        return MAV_DISTANCE_SENSOR_UNKNOWN;
    }

    uint8_t _instance;

};

#endif  // AP_RANGEFINDER_SIM_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 /*
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include "AP_RangeFinder_TOFSenseF_I2C.h"

#if AP_RANGEFINDER_TOFSENSEF_I2C_ENABLED

#define TOFSENSEP_I2C_COMMAND_TAKE_RANGE_READING 0x24
#define TOFSENSEP_I2C_COMMAND_SIGNAL_STATUS 0x28

#include <utility>

#include <AP_HAL/AP_HAL.h>
#include <AP_HAL/utility/sparse-endian.h>

extern const AP_HAL::HAL& hal;

AP_RangeFinder_TOFSenseF_I2C::AP_RangeFinder_TOFSenseF_I2C(RangeFinder::RangeFinder_State &_state,
                                                           AP_RangeFinder_Params &_params,
                                                           AP_HAL::OwnPtr<AP_HAL::I2CDevice> dev)
    : AP_RangeFinder_Backend(_state, _params)
    , _dev(std::move(dev))
{
}

// detect if a TOFSenseP rangefinder is connected. We'll detect by
// trying to take a reading on I2C. If we get a result the sensor is
// there.
AP_RangeFinder_Backend *AP_RangeFinder_TOFSenseF_I2C::detect(RangeFinder::RangeFinder_State &_state,
																AP_RangeFinder_Params &_params,
                                                             AP_HAL::OwnPtr<AP_HAL::I2CDevice> dev)
{
    if (!dev) {
        return nullptr;
    }

    AP_RangeFinder_TOFSenseF_I2C *sensor
        = NEW_NOTHROW AP_RangeFinder_TOFSenseF_I2C(_state, _params, std::move(dev));
    if (!sensor) {
        return nullptr;
    }

    if (!sensor->init()) {
        delete sensor;
        return nullptr;
    }

    return sensor;
}

// initialise sensor
bool AP_RangeFinder_TOFSenseF_I2C::init(void)
{
    _dev->get_semaphore()->take_blocking();

    if (!start_reading()) {
        _dev->get_semaphore()->give();
        return false;
    }

    // give time for the sensor to process the request
    hal.scheduler->delay(100);

    uint32_t reading_mm;
    uint16_t status;
    uint16_t signal_strength;

    if (!get_reading(reading_mm, signal_strength, status)) {
        _dev->get_semaphore()->give();
        return false;
    }

    _dev->get_semaphore()->give();

    _dev->register_periodic_callback(100000,
                                     FUNCTOR_BIND_MEMBER(&AP_RangeFinder_TOFSenseF_I2C::timer, void));

    return true;
}

// start_reading() - ask sensor to make a range reading
bool AP_RangeFinder_TOFSenseF_I2C::start_reading()
{
    uint8_t cmd[] = {TOFSENSEP_I2C_COMMAND_TAKE_RANGE_READING, TOFSENSEP_I2C_COMMAND_SIGNAL_STATUS};

    // send command to take reading
    return _dev->transfer(cmd, sizeof(cmd), nullptr, 0);
}

// read - return last value measured by sensor
bool AP_RangeFinder_TOFSenseF_I2C::get_reading(uint32_t &reading_mm, uint16_t &signal_strength, uint16_t &status)
{

    struct PACKED {
        uint32_t distance_mm;
        uint32_t signal_strength_and_status;
    } packet;

    // take range reading and read back results
    const bool ret = _dev->transfer(nullptr, 0, (uint8_t *) &packet, sizeof(packet));

    if (ret) {
        // combine results into distance
        reading_mm = packet.distance_mm;
        signal_strength = (uint16_t)(packet.signal_strength_and_status >> 16);
        status = (uint16_t)(packet.signal_strength_and_status);
    }

    // trigger a new reading
    start_reading();

    return ret;
}

//  timer called at 10Hz
void AP_RangeFinder_TOFSenseF_I2C::timer(void)
{
    uint32_t dist_mm;
    uint16_t status;
    uint16_t signal_strength;

    if (get_reading(dist_mm, signal_strength, status)) {
        WITH_SEMAPHORE(_sem);
        if (status == 1) {
            // healthy data
            distance_mm = dist_mm;
            new_distance = true;
            state.last_reading_ms = AP_HAL::millis();
        }
    }
}

// update the state of the sensor
void AP_RangeFinder_TOFSenseF_I2C::update(void)
{
    WITH_SEMAPHORE(_sem);
    if (new_distance) {
        state.distance_m = distance_mm * 0.001f;
        new_distance = false;
        update_status();
    } else if (AP_HAL::millis() - state.last_reading_ms > 300) {
        // if no updates for 0.3 seconds set no-data
        set_status(RangeFinder::Status::NoData);
    }
}

#endif  // AP_RANGEFINDER_TOFSENSEF_I2C_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    #pragma once

#include "AP_RangeFinder_config.h"

#if AP_RANGEFINDER_TOFSENSEF_I2C_ENABLED

#include "AP_RangeFinder.h"
#include "AP_RangeFinder_Backend.h"

#include <AP_HAL/I2CDevice.h>

#define TOFSENSEP_I2C_DEFAULT_ADDR   0x08

class AP_RangeFinder_TOFSenseF_I2C : public AP_RangeFinder_Backend
{
public:
    // static detection function
    static AP_RangeFinder_Backend *detect(RangeFinder::RangeFinder_State &_state,
                                          AP_RangeFinder_Params &_params,
                                          AP_HAL::OwnPtr<AP_HAL::I2CDevice> dev);

    // update state
    void update(void) override;

protected:

    MAV_DISTANCE_SENSOR _get_mav_distance_sensor_type() const override {
        return MAV_DISTANCE_SENSOR_LASER;
    }

private:
    // constructor
    AP_RangeFinder_TOFSenseF_I2C(RangeFinder::RangeFinder_State &_state,
    								AP_RangeFinder_Params &_params,
                                 AP_HAL::OwnPtr<AP_HAL::I2CDevice> dev);

    bool init(void);
    void timer(void);

    uint32_t distance_mm;
    bool new_distance; // true if we have a new distance

    // get a reading
    bool start_reading(void);
    bool get_reading(uint32_t &reading_mm, uint16_t &signal_strength, uint16_t &status);
    AP_HAL::OwnPtr<AP_HAL::I2CDevice> _dev;
};

#endif  // AP_RANGEFINDER_TOFSENSEF_I2C_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          #include "AP_RangeFinder_config.h"

#if AP_RANGEFINDER_TOFSENSEP_CAN_ENABLED

#include "AP_RangeFinder_TOFSenseP_CAN.h"
#include <AP_BoardConfig/AP_BoardConfig.h>
#include <AP_HAL/utility/sparse-endian.h>
#include <AP_HAL/AP_HAL.h>

// handler for incoming frames. These come in at 10-30Hz
bool AP_RangeFinder_TOFSenseP_CAN::handle_frame(AP_HAL::CANFrame &frame)
{
    WITH_SEMAPHORE(_sem);
    const uint32_t id = frame.id - 0x200U;

    if (!is_correct_id(id)) {
        return false;
    }

    const int32_t dist_mm = (int32_t)(frame.data[0] << 8U | frame.data[1] << 16U | frame.data[2] << 24U) >> 8;
    const uint8_t status = frame.data[3];
    const uint16_t snr = le16toh_ptr(&frame.data[4]);

    if ((snr_min != 0 && snr < uint16_t(snr_min.get())) || status > 0) {
        // too low signal strength or bad status
        return false;
    }

    accumulate_distance_m(dist_mm * 0.001);
    return true;
}

#endif  // AP_RANGEFINDER_TOFSenseP_CAN_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           #pragma once
#include "AP_RangeFinder_config.h"

#if AP_RANGEFINDER_TOFSENSEP_CAN_ENABLED

#include "AP_RangeFinder_Backend_CAN.h"

class AP_RangeFinder_TOFSenseP_CAN : public AP_RangeFinder_Backend_CAN {
public:
    AP_RangeFinder_TOFSenseP_CAN(RangeFinder::RangeFinder_State &_state, AP_RangeFinder_Params &_params) :
        AP_RangeFinder_Backend_CAN(_state, _params, AP_CAN::Protocol::TOFSenseP, "tofsensep")
    {
    }

    // handler for incoming frames
    bool handle_frame(AP_HAL::CANFrame &frame) override;

    static const struct AP_Param::GroupInfo var_info[];
};

#endif  // AP_RANGEFINDER_USD1_CAN_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 /*
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include "AP_RangeFinder_Wasp.h"

#if AP_RANGEFINDER_WASP_ENABLED

#include <AP_HAL/AP_HAL.h>
#include <ctype.h>

extern const AP_HAL::HAL& hal;

const AP_Param::GroupInfo AP_RangeFinder_Wasp::var_info[] = {
    // @Param: WSP_MAVG
    // @DisplayName: Moving Average Range
    // @Description: Sets the number of historic range results to use for calculating the current range result. When MAVG is greater than 1, the current range result will be the current measured value averaged with the N-1 previous results
    // @Range: 0 255
    // @User: Advanced
    AP_GROUPINFO("WSP_MAVG", 1, AP_RangeFinder_Wasp, mavg, 4),

    // @Param: WSP_MEDF
    // @DisplayName: Moving Median Filter
    // @Description: Sets the window size for the real-time median filter. When MEDF is greater than 0 the median filter is active
    // @Range: 0 255
    // @User: Advanced
    AP_GROUPINFO("WSP_MEDF", 2, AP_RangeFinder_Wasp, medf, 4),

    // @Param: WSP_FRQ
    // @DisplayName: Frequency
    // @Description: Sets the repetition frequency of the ranging operation in Hertz. Upon entering the desired frequency the system will calculate the nearest frequency that it can handle according to the resolution of internal timers.
    // @Range: 0 10000
    // @User: Advanced
    AP_GROUPINFO("WSP_FRQ", 3, AP_RangeFinder_Wasp, frq, 20),

    // @Param: WSP_AVG
    // @DisplayName: Multi-pulse averages
    // @Description: Sets the number of pulses to be used in multi-pulse averaging mode. In this mode, a sequence of rapid fire ranges are taken and then averaged to improve the accuracy of the measurement
    // @Range: 0 255
    // @User: Advanced
    AP_GROUPINFO("WSP_AVG", 4, AP_RangeFinder_Wasp, avg, 2),

    // @Param: WSP_THR
    // @DisplayName: Sensitivity threshold
    // @Description: Sets the system sensitivity. Larger values of THR represent higher sensitivity. The system may limit the maximum value of THR to prevent excessive false alarm rates based on settings made at the factory. Set to -1 for automatic threshold adjustments
    // @Range: -1 255
    // @User: Advanced
    AP_GROUPINFO("WSP_THR", 5, AP_RangeFinder_Wasp, thr, -1),

    // @Param: WSP_BAUD
    // @DisplayName: Baud rate
    // @Description: Desired baud rate
    // @Values: 0:Low Speed,1:High Speed
    // @User: Advanced
    AP_GROUPINFO("WSP_BAUD", 6, AP_RangeFinder_Wasp, baud, 0),

    AP_GROUPEND
};

AP_RangeFinder_Wasp::AP_RangeFinder_Wasp(RangeFinder::RangeFinder_State &_state,
                                         AP_RangeFinder_Params &_params) :
    AP_RangeFinder_Backend_Serial(_state, _params)
{
    AP_Param::setup_object_defaults(this, var_info);

    state.var_info = var_info;
}

// read - return last value measured by sensor
bool AP_RangeFinder_Wasp::get_reading(float &reading_m) {
    if (uart == nullptr) {
        return false;
    }

    // read any available lines from the lidar
    float sum = 0;
    uint16_t count = 0;
    for (auto i=0; i<8192; i++) {
        uint8_t c;
        if (!uart->read(c)) {
            break;
        }
        if (c == '\n') {
            linebuf[linebuf_len] = 0;
            linebuf_len = 0;
            state.last_reading_ms = AP_HAL::millis();
            if (isalpha(linebuf[0])) {
                parse_response();
            } else {
                float read_value = strtof(linebuf, NULL);
                if (read_value > 0) {
                    sum += read_value;
                    count++;
                }
            }
        } else if (isalnum(c) || c == '.' || c == '-') {
            linebuf[linebuf_len++] = c;
        }

        // discard excessively long buffers
        if (linebuf_len == sizeof(linebuf)) {
            linebuf_len = 0;
        }
    }

    if (configuration_state == WASP_CFG_RATE && uart->tx_pending() == 0) {
        configuration_state = WASP_CFG_ENCODING;
    }

    if (count == 0) {
        return false;
    }

    reading_m = sum / count;
    set_status(RangeFinder::Status::Good);

    return true;
}

#define COMMAND_BUFFER_LEN 15

void AP_RangeFinder_Wasp::update(void) {
    if (!get_reading(state.distance_m)) {
        set_status(RangeFinder::Status::NoData);
    }

    if (AP_HAL::millis() - state.last_reading_ms > 500) {
        // attempt to reconfigure on the assumption this was a bad baud setting
        configuration_state = WASP_CFG_RATE;
    }

    char command[COMMAND_BUFFER_LEN] = {};

    switch (configuration_state) {
        case WASP_CFG_RATE:
            hal.util->snprintf(command, COMMAND_BUFFER_LEN, ">BAUD %s\n", baud > 0 ? "HIGH" : "LOW");
            break;
        case WASP_CFG_ENCODING:
            uart->end();
            uart->begin(baud > 0 ? 921600 : 115200);
            hal.util->snprintf(command, COMMAND_BUFFER_LEN, ">LBE LITTLE\n");
            break;
        case WASP_CFG_PROTOCOL:
            hal.util->snprintf(command, COMMAND_BUFFER_LEN, ">FMT ASCII\n");
            break;
        case WASP_CFG_FRQ:
            hal.util->snprintf(command, COMMAND_BUFFER_LEN, ">FRQ %d\n", constrain_int16(frq, 20, baud > 0 ? 10000 : 1440));
            break;
        case WASP_CFG_GO:
            hal.util->snprintf(command, COMMAND_BUFFER_LEN, ">GO\n");
            break;
        case WASP_CFG_AUT:
            hal.util->snprintf(command, COMMAND_BUFFER_LEN, ">AUT %d\n", thr >= 0 ? 0 : 1);
            break;
        case WASP_CFG_THR:
            if (thr >= 0) {
                hal.util->snprintf(command, COMMAND_BUFFER_LEN, ">THR %d\n", constrain_int16(thr, 0,255));
            } else {
                configuration_state = WASP_CFG_MAVG;
            }
            break;
        case WASP_CFG_MAVG:
            hal.util->snprintf(command, COMMAND_BUFFER_LEN, ">MAVG %d\n", constrain_int16(mavg, 0, 255));
            break;
        case WASP_CFG_MEDF:
            hal.util->snprintf(command, COMMAND_BUFFER_LEN, ">MEDF %d\n", constrain_int16(medf, 0, 255));
            break;
        case WASP_CFG_AVG:
            hal.util->snprintf(command, COMMAND_BUFFER_LEN, ">AVG %d\n", constrain_int16(avg, 0, 255));
            break;
        case WASP_CFG_AUV:
            hal.util->snprintf(command, COMMAND_BUFFER_LEN, ">AUV 1\n");
            break;
        case WASP_CFG_DONE:
            return;
    }

    if (command[0] != 0) {
        uart->write((uint8_t *)command, strlen(command));
    }
}

void AP_RangeFinder_Wasp::parse_response(void) {
    switch (configuration_state) {
        case WASP_CFG_RATE:
            configuration_state = WASP_CFG_ENCODING;
            break;
        case WASP_CFG_ENCODING:
            if (strncmp(linebuf, "LBE", 3) == 0) {
                configuration_state = WASP_CFG_PROTOCOL;
            }
            break;
        case WASP_CFG_PROTOCOL:
            if (strncmp(linebuf, "FMT", 3) == 0) {
                configuration_state = WASP_CFG_FRQ;
            }
            break;
        case WASP_CFG_FRQ:
            if (strncmp(linebuf, "FRQ", 3) == 0) {
                configuration_state = WASP_CFG_GO;
            }
            break;
        case WASP_CFG_GO:
            if (strncmp(linebuf, "GO", 2) == 0) {
                configuration_state = WASP_CFG_AUT;
            }
            break;
        case WASP_CFG_AUT:
            if (strncmp(linebuf, "AUT", 3) == 0) {
                configuration_state = WASP_CFG_THR;
            }
            break;
        case WASP_CFG_THR:
            if (strncmp(linebuf, "THR", 3) == 0) {
                configuration_state = WASP_CFG_MAVG;
            }
            break;
        case WASP_CFG_MAVG:
            if (strncmp(linebuf, "MAVG", 4) == 0) {
                configuration_state = WASP_CFG_MEDF;
            }
            break;
        case WASP_CFG_MEDF:
            if (strncmp(linebuf, "MEDF", 4) == 0) {
                configuration_state = WASP_CFG_AVG;
            }
            break;
        case WASP_CFG_AVG:
            if (strncmp(linebuf, "AVG", 3) == 0) {
                configuration_state = WASP_CFG_AUV;
            }
            break;
        case WASP_CFG_AUV:
            if (strncmp(linebuf, "AUV", 3) == 0) {
                configuration_state = WASP_CFG_DONE;
            }
            break;
        case WASP_CFG_DONE:
            return;
    }
}

#endif  // AP_RANGEFINDER_WASP_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   #pragma once

#include "AP_RangeFinder_config.h"

#if AP_RANGEFINDER_WASP_ENABLED

#include "AP_RangeFinder.h"
#include "AP_RangeFinder_Backend_Serial.h"

// WASP 200 LRF
// http://www.attolloengineering.com/wasp-200-lrf.html

class AP_RangeFinder_Wasp : public AP_RangeFinder_Backend_Serial {

public:

    static AP_RangeFinder_Backend_Serial *create(
        RangeFinder::RangeFinder_State &_state,
        AP_RangeFinder_Params &_params) {
        return NEW_NOTHROW AP_RangeFinder_Wasp(_state, _params);
    }

    void update(void) override;

    static const struct AP_Param::GroupInfo var_info[];

protected:

    // Wasp is always 115200
    uint32_t initial_baudrate(uint8_t serial_instance) const override {
        return 115200;
    }

    MAV_DISTANCE_SENSOR _get_mav_distance_sensor_type() const override {
        return MAV_DISTANCE_SENSOR_LASER;
    }

private:

    AP_RangeFinder_Wasp(RangeFinder::RangeFinder_State &_state,
                        AP_RangeFinder_Params &_params);

    enum wasp_configuration_stage {
        WASP_CFG_RATE,     // set the baudrate
        WASP_CFG_ENCODING, // set the encoding to LBE
        WASP_CFG_PROTOCOL, // set the protocol type used
        WASP_CFG_FRQ,      // set the update frequency
        WASP_CFG_GO,       // start/resume readings
        WASP_CFG_AUT,      // set the auto sensitivity threshold
        WASP_CFG_THR,      // set the sensitivity threshold
        WASP_CFG_MAVG,     // set the moving average filter
        WASP_CFG_MEDF,     // set the median filter windows size
        WASP_CFG_AVG,      // set the multi-pulse averages
        WASP_CFG_AUV,      // enforce auto voltage
        WASP_CFG_DONE      // done configuring
    };

    wasp_configuration_stage configuration_state = WASP_CFG_PROTOCOL;

    bool get_reading(float &reading_m) override;

    void parse_response(void);

    char linebuf[10];
    uint8_t linebuf_len;
    AP_Int16 mavg;
    AP_Int16 medf;
    AP_Int16 frq;
    AP_Int16 avg;
    AP_Int16 thr;
    AP_Int8  baud;
};

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       /*
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/*
 *   AP_RangeFinder_analog.cpp - rangefinder for analog source
 *
 */

#include "AP_RangeFinder_analog.h"

#if AP_RANGEFINDER_ANALOG_ENABLED

#include <AP_HAL/AP_HAL.h>
#include <AP_Common/AP_Common.h>
#include <AP_Math/AP_Math.h>
#include "AP_RangeFinder.h"
#include "AP_RangeFinder_Params.h"

extern const AP_HAL::HAL& hal;

/* 
   The constructor also initialises the rangefinder. Note that this
   constructor is not called until detect() returns true, so we
   already know that we should setup the rangefinder
*/
AP_RangeFinder_analog::AP_RangeFinder_analog(RangeFinder::RangeFinder_State &_state, AP_RangeFinder_Params &_params) :
    AP_RangeFinder_Backend(_state, _params)
{
    source = hal.analogin->channel(_params.pin);
    if (source == nullptr) {
        // failed to allocate a ADC channel? This shouldn't happen
        set_status(RangeFinder::Status::NotConnected);
        return;
    }
    set_status(RangeFinder::Status::NoData);
}

/* 
   detect if an analog rangefinder is connected. The only thing we
   can do is check if the pin number is valid. If it is, then assume
   that the device is connected
*/
bool AP_RangeFinder_analog::detect(AP_RangeFinder_Params &_params)
{
    if (_params.pin != -1) {
        return true;
    }
    return false;
}


/*
  update raw voltage state
 */
void AP_RangeFinder_analog::update_voltage(void)
{
   if (source == nullptr || !source->set_pin(params.pin)) {
       state.voltage_mv = 0;
       set_status(RangeFinder::Status::NotConnected);
       return;
   }
   if (params.ratiometric) {
       state.voltage_mv = source->voltage_average_ratiometric() * 1000U;
   } else {
       state.voltage_mv = source->voltage_average() * 1000U;
   }
}

/*
  update distance_cm 
 */
void AP_RangeFinder_analog::update(void)
{
    update_voltage();
    float v = state.voltage_mv * 0.001f;
    float dist_m = 0;
    float scaling = params.scaling;
    float offset  = params.offset;
    RangeFinder::Function function = (RangeFinder::Function)params.function.get();
    int16_t _max_distance_cm = params.max_distance_cm;

    switch (function) {
    case RangeFinder::Function::LINEAR:
        dist_m = (v - offset) * scaling;
        break;
	  
    case RangeFinder::Function::INVERTED:
        dist_m = (offset - v) * scaling;
        break;

    case RangeFinder::Function::HYPERBOLA:
        if (v <= offset) {
            dist_m = 0;
        } else {
            dist_m = scaling / (v - offset);
        }
        if (dist_m > _max_distance_cm * 0.01f) {
            dist_m = _max_distance_cm * 0.01f;
        }
        break;
    }
    if (dist_m < 0) {
        dist_m = 0;
    }
    state.distance_m = dist_m;
    state.last_reading_ms = AP_HAL::millis();

    // update range_valid state based on distance measured
    update_status();
}

#endif  // AP_RANGEFINDER_ANALOG_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           #pragma once

#include "AP_RangeFinder_config.h"

#if AP_RANGEFINDER_ANALOG_ENABLED

#include "AP_RangeFinder.h"
#include "AP_RangeFinder_Backend.h"
#include "AP_RangeFinder_Params.h"

class AP_RangeFinder_analog : public AP_RangeFinder_Backend
{
public:
    // constructor
    AP_RangeFinder_analog(RangeFinder::RangeFinder_State &_state, AP_RangeFinder_Params &_params);

    // static detection function
    static bool detect(AP_RangeFinder_Params &_params);

    // update state
    void update(void) override;

protected:

    MAV_DISTANCE_SENSOR _get_mav_distance_sensor_type() const override {
        return MAV_DISTANCE_SENSOR_UNKNOWN;
    }

private:
    // update raw voltage
    void update_voltage(void);

    AP_HAL::AnalogSource *source;
};

#endif  // AP_RANGEFINDER_ANALOG_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 #pragma once

#include <AP_HAL/AP_HAL_Boards.h>
#include <AP_MSP/AP_MSP_config.h>
#include <AP_Scripting/AP_Scripting_config.h>
#include <AP_CANManager/AP_CANManager_config.h>
#include <AP_MSP/AP_MSP_config.h>
#include <GCS_MAVLink/GCS_config.h>

#ifndef AP_RANGEFINDER_ENABLED
#define AP_RANGEFINDER_ENABLED 1
#endif

#ifndef AP_RANGEFINDER_BACKEND_DEFAULT_ENABLED
#define AP_RANGEFINDER_BACKEND_DEFAULT_ENABLED AP_RANGEFINDER_ENABLED
#endif

#ifndef AP_RANGEFINDER_BACKEND_CAN_ENABLED
#define AP_RANGEFINDER_BACKEND_CAN_ENABLED AP_RANGEFINDER_ENABLED && HAL_MAX_CAN_PROTOCOL_DRIVERS
#endif

#ifndef AP_RANGEFINDER_ANALOG_ENABLED
#define AP_RANGEFINDER_ANALOG_ENABLED AP_RANGEFINDER_BACKEND_DEFAULT_ENABLED
#endif

#ifndef AP_RANGEFINDER_BBB_PRU_ENABLED
#define AP_RANGEFINDER_BBB_PRU_ENABLED (AP_RANGEFINDER_BACKEND_DEFAULT_ENABLED && CONFIG_HAL_BOARD_SUBTYPE == HAL_BOARD_SUBTYPE_LINUX_BBBMINI)
#endif

#ifndef AP_RANGEFINDER_BENEWAKE_ENABLED
#define AP_RANGEFINDER_BENEWAKE_ENABLED AP_RANGEFINDER_ENABLED
#endif

#ifndef AP_RANGEFINDER_BENEWAKE_CAN_ENABLED
#define AP_RANGEFINDER_BENEWAKE_CAN_ENABLED (HAL_MAX_CAN_PROTOCOL_DRIVERS && AP_RANGEFINDER_BACKEND_DEFAULT_ENABLED)
#endif

#ifndef AP_RANGEFINDER_BENEWAKE_TF02_ENABLED
#define AP_RANGEFINDER_BENEWAKE_TF02_ENABLED (AP_RANGEFINDER_BENEWAKE_ENABLED && AP_RANGEFINDER_BACKEND_DEFAULT_ENABLED)
#endif

#ifndef AP_RANGEFINDER_BENEWAKE_TF03_ENABLED
#define AP_RANGEFINDER_BENEWAKE_TF03_ENABLED (AP_RANGEFINDER_BENEWAKE_ENABLED && AP_RANGEFINDER_BACKEND_DEFAULT_ENABLED)
#endif

#ifndef AP_RANGEFINDER_BENEWAKE_TFMINI_ENABLED
#define AP_RANGEFINDER_BENEWAKE_TFMINI_ENABLED (AP_RANGEFINDER_BENEWAKE_ENABLED && AP_RANGEFINDER_BACKEND_DEFAULT_ENABLED)
#endif

#ifndef AP_RANGEFINDER_BENEWAKE_TFMINIPLUS_ENABLED
#define AP_RANGEFINDER_BENEWAKE_TFMINIPLUS_ENABLED AP_RANGEFINDER_BACKEND_DEFAULT_ENABLED
#endif

#ifndef AP_RANGEFINDER_BLPING_ENABLED
#define AP_RANGEFINDER_BLPING_ENABLED AP_RANGEFINDER_BACKEND_DEFAULT_ENABLED
#endif

#ifndef AP_RANGEFINDER_BEBOP_ENABLED
#define AP_RANGEFINDER_BEBOP_ENABLED \
    AP_RANGEFINDER_BACKEND_DEFAULT_ENABLED &&                           \
    (CONFIG_HAL_BOARD_SUBTYPE == HAL_BOARD_SUBTYPE_LINUX_BEBOP ||       \
     CONFIG_HAL_BOARD_SUBTYPE == HAL_BOARD_SUBTYPE_LINUX_DISCO) &&      \
    defined(HAVE_LIBIIO)
#endif

#ifndef AP_RANGEFINDER_DRONECAN_ENABLED
#define AP_RANGEFINDER_DRONECAN_ENABLED (HAL_ENABLE_DRONECAN_DRIVERS && AP_RANGEFINDER_BACKEND_DEFAULT_ENABLED)
#endif

#ifndef AP_RANGEFINDER_GYUS42V2_ENABLED
#define AP_RANGEFINDER_GYUS42V2_ENABLED AP_RANGEFINDER_BACKEND_DEFAULT_ENABLED
#endif

#ifndef AP_RANGEFINDER_HC_SR04_ENABLED
#define AP_RANGEFINDER_HC_SR04_ENABLED AP_RANGEFINDER_BACKEND_DEFAULT_ENABLED
#endif

#ifndef AP_RANGEFINDER_LANBAO_ENABLED
#define AP_RANGEFINDER_LANBAO_ENABLED AP_RANGEFINDER_BACKEND_DEFAULT_ENABLED
#endif

#ifndef AP_RANGEFINDER_LEDDARONE_ENABLED
#define AP_RANGEFINDER_LEDDARONE_ENABLED AP_RANGEFINDER_BACKEND_DEFAULT_ENABLED
#endif

#ifndef AP_RANGEFINDER_LEDDARVU8_ENABLED
#define AP_RANGEFINDER_LEDDARVU8_ENABLED AP_RANGEFINDER_BACKEND_DEFAULT_ENABLED
#endif

#ifndef AP_RANGEFINDER_LWI2C_ENABLED
#define AP_RANGEFINDER_LWI2C_ENABLED AP_RANGEFINDER_BACKEND_DEFAULT_ENABLED
#endif

#ifndef AP_RANGEFINDER_LIGHTWARE_SERIAL_ENABLED
#define AP_RANGEFINDER_LIGHTWARE_SERIAL_ENABLED AP_RANGEFINDER_BACKEND_DEFAULT_ENABLED
#endif

#ifndef AP_RANGEFINDER_LUA_ENABLED
#define AP_RANGEFINDER_LUA_ENABLED AP_RANGEFINDER_BACKEND_DEFAULT_ENABLED && AP_SCRIPTING_ENABLED
#endif

#ifndef AP_RANGEFINDER_MAVLINK_ENABLED
#define AP_RANGEFINDER_MAVLINK_ENABLED AP_RANGEFINDER_BACKEND_DEFAULT_ENABLED && HAL_GCS_ENABLED
#endif

#ifndef AP_RANGEFINDER_MAXBOTIX_SERIAL_ENABLED
#define AP_RANGEFINDER_MAXBOTIX_SERIAL_ENABLED AP_RANGEFINDER_BACKEND_DEFAULT_ENABLED
#endif

#ifndef AP_RANGEFINDER_MAXSONARI2CXL_ENABLED
#define AP_RANGEFINDER_MAXSONARI2CXL_ENABLED AP_RANGEFINDER_BACKEND_DEFAULT_ENABLED
#endif

#ifndef HAL_MSP_RANGEFINDER_ENABLED
#define HAL_MSP_RANGEFINDER_ENABLED AP_RANGEFINDER_BACKEND_DEFAULT_ENABLED && HAL_MSP_ENABLED
#endif

#ifndef AP_RANGEFINDER_NMEA_ENABLED
#define AP_RANGEFINDER_NMEA_ENABLED AP_RANGEFINDER_BACKEND_DEFAULT_ENABLED
#endif

#ifndef AP_RANGEFINDER_NOOPLOOP_ENABLED
#define AP_RANGEFINDER_NOOPLOOP_ENABLED AP_RANGEFINDER_BACKEND_DEFAULT_ENABLED && BOARD_FLASH_SIZE > 1024
#endif

#ifndef AP_RANGEFINDER_NRA24_CAN_ENABLED
#define AP_RANGEFINDER_NRA24_CAN_ENABLED (HAL_MAX_CAN_PROTOCOL_DRIVERS && AP_RANGEFINDER_BACKEND_DEFAULT_ENABLED)
#endif

#ifndef AP_RANGEFINDER_PWM_ENABLED
#define AP_RANGEFINDER_PWM_ENABLED (CONFIG_HAL_BOARD == HAL_BOARD_CHIBIOS && AP_RANGEFINDER_BACKEND_DEFAULT_ENABLED)
#endif

#ifndef AP_RANGEFINDER_PULSEDLIGHTLRF_ENABLED
#define AP_RANGEFINDER_PULSEDLIGHTLRF_ENABLED AP_RANGEFINDER_BACKEND_DEFAULT_ENABLED
#endif

#ifndef AP_RANGEFINDER_RDS02UF_ENABLED
#define AP_RANGEFINDER_RDS02UF_ENABLED AP_RANGEFINDER_BACKEND_DEFAULT_ENABLED && BOARD_FLASH_SIZE > 1024
#endif

#ifndef AP_RANGEFINDER_SIM_ENABLED
#define AP_RANGEFINDER_SIM_ENABLED (CONFIG_HAL_BOARD == HAL_BOARD_SITL && AP_RANGEFINDER_BACKEND_DEFAULT_ENABLED)
#endif

#ifndef HAL_MSP_RANGEFINDER_ENABLED
#define HAL_MSP_RANGEFINDER_ENABLED (AP_RANGEFINDER_BACKEND_DEFAULT_ENABLED && HAL_MSP_ENABLED)
#endif

#ifndef AP_RANGEFINDER_TERARANGER_SERIAL_ENABLED
#define AP_RANGEFINDER_TERARANGER_SERIAL_ENABLED AP_RANGEFINDER_BACKEND_DEFAULT_ENABLED
#endif

#ifndef AP_RANGEFINDER_TOFSENSEP_CAN_ENABLED
#define AP_RANGEFINDER_TOFSENSEP_CAN_ENABLED AP_RANGEFINDER_BACKEND_DEFAULT_ENABLED && AP_RANGEFINDER_BACKEND_CAN_ENABLED
#endif

#ifndef AP_RANGEFINDER_TOFSENSEF_I2C_ENABLED
#define AP_RANGEFINDER_TOFSENSEF_I2C_ENABLED AP_RANGEFINDER_BACKEND_DEFAULT_ENABLED && BOARD_FLASH_SIZE > 1024
#endif

#ifndef AP_RANGEFINDER_TRI2C_ENABLED
#define AP_RANGEFINDER_TRI2C_ENABLED AP_RANGEFINDER_BACKEND_DEFAULT_ENABLED
#endif

#ifndef AP_RANGEFINDER_USD1_CAN_ENABLED
#define AP_RANGEFINDER_USD1_CAN_ENABLED AP_RANGEFINDER_BACKEND_DEFAULT_ENABLED && AP_RANGEFINDER_BACKEND_CAN_ENABLED
#endif

#ifndef AP_RANGEFINDER_USD1_SERIAL_ENABLED
#define AP_RANGEFINDER_USD1_SERIAL_ENABLED AP_RANGEFINDER_BACKEND_DEFAULT_ENABLED
#endif

#ifndef AP_RANGEFINDER_VL53L0X_ENABLED
#define AP_RANGEFINDER_VL53L0X_ENABLED AP_RANGEFINDER_BACKEND_DEFAULT_ENABLED
#endif

#ifndef AP_RANGEFINDER_VL53L1X_ENABLED
#define AP_RANGEFINDER_VL53L1X_ENABLED AP_RANGEFINDER_BACKEND_DEFAULT_ENABLED
#endif

#ifndef AP_RANGEFINDER_WASP_ENABLED
#define AP_RANGEFINDER_WASP_ENABLED AP_RANGEFINDER_BACKEND_DEFAULT_ENABLED
#endif

#ifndef AP_RANGEFINDER_JRE_SERIAL_ENABLED
#define AP_RANGEFINDER_JRE_SERIAL_ENABLED AP_RANGEFINDER_BACKEND_DEFAULT_ENABLED && BOARD_FLASH_SIZE > 1024
#endif

#ifndef AP_RANGEFINDER_AINSTEIN_LR_D1_ENABLED
#define AP_RANGEFINDER_AINSTEIN_LR_D1_ENABLED AP_RANGEFINDER_BACKEND_DEFAULT_ENABLED && BOARD_FLASH_SIZE > 1024
#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            /*
 *  RangeFinder test code
 */

#include <AP_HAL/AP_HAL.h>
#include <AP_RangeFinder/AP_RangeFinder_Backend.h>
#include <GCS_MAVLink/GCS_Dummy.h>

const struct AP_Param::GroupInfo        GCS_MAVLINK_Parameters::var_info[] = {
    AP_GROUPEND
};
GCS_Dummy _gcs;

void setup();
void loop();

const AP_HAL::HAL& hal = AP_HAL::get_HAL();

static AP_SerialManager serial_manager;
static RangeFinder sonar;

void setup()
{
    // print welcome message
    hal.console->printf("Range Finder library test\n");

    // setup for analog pin 13
    AP_Param::set_object_value(&sonar, sonar.var_info, "_TYPE", (uint8_t)RangeFinder::Type::PLI2C);
    AP_Param::set_object_value(&sonar, sonar.var_info, "_PIN", -1.0f);
    AP_Param::set_object_value(&sonar, sonar.var_info, "_SCALING", 1.0f);

    // initialise sensor, delaying to make debug easier
    hal.scheduler->delay(2000);
    sonar.init(ROTATION_PITCH_270);
    hal.console->printf("RangeFinder: %d devices detected\n", sonar.num_sensors());
}

void loop()
{
    // Delay between reads
    hal.scheduler->delay(100);
    sonar.update();

    bool had_data = false;
    for (uint8_t i=0; i<sonar.num_sensors(); i++) {
        AP_RangeFinder_Backend *sensor = sonar.get_backend(i);
        if (sensor == nullptr) {
            continue;
        }
        if (!sensor->has_data()) {
            continue;
        }
        hal.console->printf("All: device_%u type %d status %d distance_cm %d\n",
                            i,
                            (int)sensor->type(),
                            (int)sensor->status(),
                            sensor->distance_cm());
        had_data = true;
    }
    if (!had_data) {
        hal.console->printf("All: no data on any sensor\n");
    }

}
AP_HAL_MAIN();
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                /*
  generic object to allow a script to use a serial driver stream from both
  driver and device perspectives
 */

#include "AP_Scripting_config.h"
#include "AP_Scripting.h"
#include "AP_Scripting_SerialAccess.h"

#if AP_SCRIPTING_ENABLED

#if AP_SCRIPTING_SERIALDEVICE_ENABLED
#define check_is_device_port() (is_device_port)
#define ON_DEVICE_PORT(func, ...) (((AP_Scripting_SerialDevice::Port*)stream)->device_##func (__VA_ARGS__))
#else
#define check_is_device_port() (false)
#define ON_DEVICE_PORT(...) (0) // not executed
#endif

void AP_Scripting_SerialAccess::begin(uint32_t baud)
{
    if (!check_is_device_port()) {
        stream->begin(baud);
    }
}

size_t AP_Scripting_SerialAccess::write(uint8_t c)
{
    return write(&c, 1);
}

size_t AP_Scripting_SerialAccess::write(const uint8_t *buffer, size_t size)
{
    if (!check_is_device_port()) {
        return stream->write(buffer, size);
    }
    return ON_DEVICE_PORT(write, buffer, size);
}

int16_t AP_Scripting_SerialAccess::read(void)
{
    uint8_t c;
    if (read(&c, 1) != 1) {
        return -1;
    }
    return c;
}

ssize_t AP_Scripting_SerialAccess::read(uint8_t* buffer, uint16_t count)
{
    if (!check_is_device_port()) {
        return stream->read(buffer, count);
    }
    return ON_DEVICE_PORT(read, buffer, count);
}

uint32_t AP_Scripting_SerialAccess::available(void)
{
    if (!check_is_device_port()) {
        return stream->available();
    }
    return ON_DEVICE_PORT(available);
}

void AP_Scripting_SerialAccess::set_flow_control(enum AP_HAL::UARTDriver::flow_control fcs)
{
    if (!check_is_device_port()) {
        stream->set_flow_control(fcs);
    }
}

#endif // AP_SCRIPTING_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             --[[ perform simple aerobatic manoeuvres in AUTO mode
cmd = 1: axial rolls, arg1 = roll rate dps, arg2 = number of rolls
cmd = 2: loops or 180deg return, arg1 = pitch rate dps, arg2 = number of loops, if zero do a 1/2 cuban8-like return
cmd = 3: rolling circle, arg1 = yaw rate, arg2 = roll rate
cmd = 4: knife edge at any angle, arg1 = roll angle to hold, arg2 = duration
cmd = 5: pause, holding heading and alt to allow stabilization after a move, arg1 = duration in seconds
]]--
-- luacheck: only 0
---@diagnostic disable: param-type-mismatch
---@diagnostic disable: need-check-nil
---@diagnostic disable: cast-local-type
---@diagnostic disable: undefined-global

DO_JUMP = 177
k_throttle = 70
MODE_AUTO = 10
-- setup param block for aerobatics, reserving 30 params beginning with AERO_
local PARAM_TABLE_KEY = 72
local PARAM_TABLE_PREFIX = "AEROR_"
assert(param:add_table(PARAM_TABLE_KEY, "AEROR_", 30), 'could not add param table')

-- add a parameter and bind it to a variable
function bind_add_param(name, idx, default_value)
    assert(param:add_param(PARAM_TABLE_KEY, idx, name, default_value), string.format('could not add param %s', name))
    return Parameter(PARAM_TABLE_PREFIX .. name)
end

local HGT_P = bind_add_param('HGT_P',1,1) -- height P gain
local HGT_I = bind_add_param("HGT_I",2,1) -- height I gain
local HGT_KE_BIAS = bind_add_param("KE_ADD",3,20) -- height knifeedge addition for pitch
local THR_PIT_FF = bind_add_param("PIT_FF",4,80) -- throttle FF from pitch
local SPD_P = bind_add_param("SPD_P",5,5) -- speed P gain
local SPD_I = bind_add_param("SPD_I",6,25) -- speed I gain
local TRIM_THROTTLE = Parameter("TRIM_THROTTLE")
local RLL2SRV_TCONST = Parameter("RLL2SRV_TCONST")
local PITCH_TCONST = Parameter("PTCH2SRV_TCONST")

local last_roll_err = 0.0
local last_id = 0
local initial_yaw_deg = 0
local wp_yaw_deg = 0
local initial_height = 0
local repeat_count = 0
local running = false
local trick_stage = 0

local function TrickDef(id, arg1, arg2, arg3, arg4)
   local self = {}
   self.id = id
   self.args = {arg1, arg2, arg3, arg4}
   return self
end


--[[
   Aerobatic tricks on a switch support - allows for tricks to be initiated outside AUTO mode
--]]
-- 2nd param table for tricks on a switch
local PARAM_TABLE_KEY2 = 73
local PARAM_TABLE_PREFIX2 = "TRIKR"
assert(param:add_table(PARAM_TABLE_KEY2, PARAM_TABLE_PREFIX2, 63), 'could not add param table2')

-- add a parameter and bind it to a variable in table2
function bind_add_param2(name, idx, default_value)
    assert(param:add_param(PARAM_TABLE_KEY2, idx, name, default_value), string.format('could not add param %s', name))
    return Parameter(PARAM_TABLE_PREFIX2 .. name)
end
local TRICKS = nil
local TRIK_SEL_FN = nil
local TRIK_ACT_FN = nil
local TRIK_COUNT  = nil

-- constrain a value between limits
function constrain(v, vmin, vmax)
   if v < vmin then
      v = vmin
   end
   if v > vmax then
      v = vmax
   end
   return v
end


-- setup parameters for tricks
TRIK_SEL_FN = bind_add_param2("_SEL_FN", 2, 301)
TRIK_ACT_FN = bind_add_param2("_ACT_FN", 3, 300)
TRIK_COUNT  = bind_add_param2("_COUNT",  4, 3)
TRICKS = {}
local last_trick_action_state = rc:get_aux_cached(TRIK_ACT_FN:get())


function tricks_exist()
   if rc:find_channel_for_option(TRIK_SEL_FN:get())  
            and math.floor(TRIK_COUNT:get()) then
      return true
   else
      return false
   end
end   
   
-- setup parameters for tricks
count = math.floor(TRIK_COUNT:get())
count = constrain(count,0,11)
if tricks_exist() then
   for i = 1, count do
      local k = 5*i
      local prefix = string.format("%u", i)
      TRICKS[i] = TrickDef(bind_add_param2(prefix .. "_ID",   k+0, i),
                          bind_add_param2(prefix .. "_ARG1", k+1, 30),
                           bind_add_param2(prefix .. "_ARG2", k+2, 0),
                           bind_add_param2(prefix .. "_ARG3", k+3, 0),
                           bind_add_param2(prefix .. "_ARG4", k+4, 0))
   end
   gcs:send_text(5, string.format("Enabled %u aerobatic tricks", count))   
end


-- roll angle error 180 wrap to cope with errors while in inverted segments
function roll_angle_error_wrap(roll_angle_error)
   if math.abs(roll_angle_error) > 180 then
    if roll_angle_error > 0 then
       roll_angle_error = roll_angle_error - 360
    else 
       roll_angle_error= roll_angle_error +360
    end 
   end
   return roll_angle_error
end
    
--roll controller to keep wings level in earth frame. if arg is 0 then level is at only 0 deg, otherwise its at 180/-180 roll also for loops
function earth_frame_wings_level(arg)
   local roll_deg = math.deg(ahrs:get_roll())
   local roll_angle_error = 0.0
   if (roll_deg > 90 or roll_deg < -90) and arg ~= 0 then
    roll_angle_error = 180 - roll_deg
   else
    roll_angle_error = - roll_deg
   end
   return roll_angle_error_wrap(roll_angle_error)/(RLL2SRV_TCONST:get())
end


function wrap_360(angle)
   local res = math.fmod(angle, 360.0)
    if res < 0 then
        res = res + 360.0
    end
    return res
end

function wrap_180(angle) 
    local res = wrap_360(angle)
    if res > 180 then
       res = res - 360
    end
    return res
end

-- a PI controller implemented as a Lua object
local function PI_controller(kP,kI,iMax)
   -- the new instance. You can put public variables inside this self
   -- declaration if you want to
   local self = {}

   -- private fields as locals
   local _kP = kP or 0.0
   local _kI = kI or 0.0
   local _kD = kD or 0.0
   local _iMax = iMax
   local _last_t = nil
   local _I = 0
   local _P = 0
   local _total = 0
   local _counter = 0
   local _target = 0
   local _current = 0

   -- update the controller.
   function self.update(target, current)
      local now = millis():tofloat() * 0.001
      if not _last_t then
         _last_t = now
      end
      local dt = now - _last_t
      _last_t = now
      local err = target - current
      _counter = _counter + 1

      local P = _kP * err
      _I = _I + _kI * err * dt
      if _iMax then
         _I = constrain(_I, -_iMax, iMax)
      end
      local I = _I
      local ret = P + I

      _target = target
      _current = current
      _P = P
      _total = ret
      return ret
   end

   -- reset integrator to an initial value
   function self.reset(integrator)
      _I = integrator
   end

   function self.set_I(I)
      _kI = I
   end

   function self.set_P(P)
      _kP = P
   end
   
   function self.set_Imax(Imax)
      _iMax = Imax
   end
   
   -- log the controller internals
   function self.log(name, add_total)
      -- allow for an external addition to total
      logger.write(name,'Targ,Curr,P,I,Total,Add','ffffff',_target,_current,_P,_I,_total,add_total)
   end
   -- return the instance
   return self
end

local function height_controller(kP_param,kI_param,KnifeEdge_param,Imax)
   local self = {}
   local kP = kP_param
   local kI = kI_param
   local KnifeEdge = KnifeEdge_param
   local PI = PI_controller(kP:get(), kI:get(), Imax)

   function self.update(target)
      local target_pitch = PI.update(target, ahrs:get_position():alt()*0.01)
      local roll_rad = ahrs:get_roll()
      local ke_add = math.abs(math.sin(roll_rad)) * KnifeEdge:get()
      target_pitch = target_pitch + ke_add
      PI.log("HPI", ke_add)
      return target_pitch
   end

   function self.reset()
      PI.reset(math.max(math.deg(ahrs:get_pitch()), 3.0))
      PI.set_P(kP:get())
      PI.set_I(kI:get())
   end

   return self
end

local height_PI = height_controller(HGT_P, HGT_I, HGT_KE_BIAS, 20.0)
local speed_PI = PI_controller(SPD_P:get(), SPD_I:get(), 100.0)

-- a controller to target a zero pitch angle and zero heading change, used in a roll
-- output is a body frame pitch rate, with convergence over time tconst in seconds
function pitch_controller(target_pitch_deg, target_yaw_deg, tconst)
   local roll_deg = math.deg(ahrs:get_roll())
   local pitch_deg = math.deg(ahrs:get_pitch())
   local yaw_deg = math.deg(ahrs:get_yaw())

   -- get earth frame pitch and yaw rates
   local ef_pitch_rate = (target_pitch_deg - pitch_deg) / tconst
   local ef_yaw_rate = wrap_180(target_yaw_deg - yaw_deg) / tconst

   local bf_pitch_rate = math.sin(math.rad(roll_deg)) * ef_yaw_rate + math.cos(math.rad(roll_deg)) * ef_pitch_rate
   local bf_yaw_rate   = math.cos(math.rad(roll_deg)) * ef_yaw_rate - math.sin(math.rad(roll_deg)) * ef_pitch_rate
   return bf_pitch_rate, bf_yaw_rate
end

-- a controller for throttle to account for pitch
function throttle_controller()
   local pitch_rad = ahrs:get_pitch()
   local thr_ff = THR_PIT_FF:get()
   local throttle = TRIM_THROTTLE:get() + math.sin(pitch_rad) * thr_ff
   return constrain(throttle, 0, 100.0)
end

-- recover entry altitude
function recover_alt()
       local target_pitch = height_PI.update(initial_height)
       local pitch_rate, yaw_rate = pitch_controller(target_pitch, wp_yaw_deg, PITCH_TCONST:get())
       return target_pitch, pitch_rate, yaw_rate
end

function set_rate_targets(throttle, roll_rate, pitch_rate, yaw_rate)
   -- we don't want a rudder offset, and we do want yaw rate
   vehicle:set_rudder_offset(0, true)
   vehicle:set_target_throttle_rate_rpy(throttle, roll_rate, pitch_rate, yaw_rate)
end

--  start of trick routines---------------------------------------------------------------------------------
function do_axial_roll(arg1, arg2)
   -- constant roll rate axial roll, arg1 roll rate, arg2 is number of rolls
   if not running then
      running = true
      roll_num = 1
      repeat_count = arg2 -1
      trick_stage = 0
      height_PI.reset()
      gcs:send_text(5, string.format("Starting %d Roll(s)", arg2))
   end
   local roll_rate = arg1
   local pitch_deg = math.deg(ahrs:get_pitch())
   local roll_deg = math.deg(ahrs:get_roll())

   if trick_stage == 0 then
      if roll_deg > 45 then
         trick_stage = 1
      end
   elseif trick_stage == 1 then
      if roll_deg > -5 and roll_deg < 5 then
         -- we're done with a roll
         gcs:send_text(5, string.format("Finished Roll %d", roll_num))
         if repeat_count > 0 then
            trick_stage = 0
            repeat_count = repeat_count - 1
            roll_num = roll_num + 1
         else
         running = false
         trick = 0
         if vehicle:get_mode() == MODE_AUTO then
            vehicle:nav_script_time_done(last_id)
         else
            vehicle:nav_scripting_enable(255)
         end
         trick_stage = 2
         return
         end
      end
   end
   if trick_stage < 2 then
      throttle = throttle_controller()
      target_pitch = height_PI.update(initial_height)
      pitch_rate, yaw_rate = pitch_controller(target_pitch, wp_yaw_deg, PITCH_TCONST:get())
      set_rate_targets(throttle, roll_rate, pitch_rate, yaw_rate)
   end
end


local target_vel

function do_loop(arg1, arg2)
   -- do one loop with controllable pitch rate arg1 is pitch rate, arg2 number of loops, 0 or less indicates 1/2 cuban8 reversal style turnaround
   if not running then
      running = true
      trick_stage = 0 
      loop_number = 1
      repeat_count = arg2 -1  
      target_vel = ahrs:get_velocity_NED():length()
      if arg2 > 0 then
         gcs:send_text(5, string.format("Starting %d Loop(s)",arg2))
      else
        gcs:send_text(5, string.format("Starting Turnaround"))
      end
   end

   local throttle = throttle_controller()
   local pitch_deg = math.deg(ahrs:get_pitch())
   local roll_deg = math.deg(ahrs:get_roll())
   local vel = ahrs:get_velocity_NED():length()
   local pitch_rate = arg1
   local pitch_rate = pitch_rate * (1+ 2*((vel/target_vel)-1)) --increase/decrease rate based on velocity to round loop
   pitch_rate = constrain(pitch_rate,.5 * arg1, 3 * arg1)
   
   if trick_stage == 0 then
      if pitch_deg > 60 then
         trick_stage = 1
      end
   elseif trick_stage == 1 then
      if (math.abs(roll_deg) < 90 and pitch_deg > -5 and pitch_deg < 5 and repeat_count >= 0) then 
         -- we're done with loop
         gcs:send_text(5, string.format("Finished Loop %d", loop_number))
         trick_stage = 2  --now recover stage
         height_PI.reset()
      elseif (math.abs(roll_deg) > 90 and pitch_deg > -5 and pitch_deg < 5 and repeat_count < 0) then
         gcs:send_text(5, string.format("Finished Turnaround ")) 
         tri