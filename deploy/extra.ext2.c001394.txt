 (type_in == ControlType::RANGE) {
        control_in = pwm_to_range();
    } else {
        // ControlType::ANGLE
        control_in = pwm_to_angle();
    }

    return true;
}

/*
  return the center stick position expressed as a control_in value
  used for thr_mid in copter
 */
int16_t RC_Channel::get_control_mid() const
{
    if (type_in == ControlType::RANGE) {
        int16_t r_in = (radio_min.get() + radio_max.get())/2;

        int16_t radio_trim_low  = radio_min + dead_zone;

        return (((int32_t)(high_in) * (int32_t)(r_in - radio_trim_low)) / (int32_t)(radio_max - radio_trim_low));
    } else {
        return 0;
    }
}

/*
  return an "angle in centidegrees" (normally -4500 to 4500) from
  the current radio_in value using the specified dead_zone
 */
int16_t RC_Channel::pwm_to_angle_dz_trim(uint16_t _dead_zone, uint16_t _trim) const
{
    int16_t radio_trim_high = _trim + _dead_zone;
    int16_t radio_trim_low  = _trim - _dead_zone;

    int16_t reverse_mul = (reversed?-1:1);

    // don't allow out of range values
    int16_t r_in = constrain_int16(radio_in, radio_min.get(), radio_max.get());

    if (r_in > radio_trim_high && radio_max != radio_trim_high) {
        return reverse_mul * ((int32_t)high_in * (int32_t)(r_in - radio_trim_high)) / (int32_t)(radio_max  - radio_trim_high);
    } else if (r_in < radio_trim_low && radio_trim_low != radio_min) {
        return reverse_mul * ((int32_t)high_in * (int32_t)(r_in - radio_trim_low)) / (int32_t)(radio_trim_low - radio_min);
    } else {
        return 0;
    }
}

/*
  return an "angle in centidegrees" (normally -4500 to 4500) from
  the current radio_in value using the specified dead_zone
 */
int16_t RC_Channel::pwm_to_angle_dz(uint16_t _dead_zone) const
{
    return pwm_to_angle_dz_trim(_dead_zone, radio_trim);
}

/*
  return an "angle in centidegrees" (normally -4500 to 4500) from
  the current radio_in value
 */
int16_t RC_Channel::pwm_to_angle() const
{
    return pwm_to_angle_dz(dead_zone);
}


/*
  convert a pulse width modulation value to a value in the configured
  range, using the specified deadzone
 */
int16_t RC_Channel::pwm_to_range_dz(uint16_t _dead_zone) const
{
    int16_t r_in = constrain_int16(radio_in, radio_min.get(), radio_max.get());

    if (reversed) {
        r_in = radio_max.get() - (r_in - radio_min.get());
    }

    int16_t radio_trim_low  = radio_min + _dead_zone;

    if (r_in > radio_trim_low) {
        return (((int32_t)(high_in) * (int32_t)(r_in - radio_trim_low)) / (int32_t)(radio_max - radio_trim_low));
    }
    return 0;
}

/*
  convert a pulse width modulation value to a value in the configured
  range
 */
int16_t RC_Channel::pwm_to_range() const
{
    return pwm_to_range_dz(dead_zone);
}


int16_t RC_Channel::get_control_in_zero_dz(void) const
{
    if (type_in == ControlType::RANGE) {
        return pwm_to_range_dz(0);
    }
    return pwm_to_angle_dz(0);
}

// ------------------------------------------

float RC_Channel::norm_input() const
{
    float ret;
    int16_t reverse_mul = (reversed?-1:1);
    if (radio_in < radio_trim) {
        if (radio_min >= radio_trim) {
            return 0.0f;
        }
        ret = reverse_mul * (float)(radio_in - radio_trim) / (float)(radio_trim - radio_min);
    } else {
        if (radio_max <= radio_trim) {
            return 0.0f;
        }
        ret = reverse_mul * (float)(radio_in - radio_trim) / (float)(radio_max  - radio_trim);
    }
    return constrain_float(ret, -1.0f, 1.0f);
}

float RC_Channel::norm_input_dz() const
{
    int16_t dz_min = radio_trim - dead_zone;
    int16_t dz_max = radio_trim + dead_zone;
    float ret;
    int16_t reverse_mul = (reversed?-1:1);
    if (radio_in < dz_min && dz_min > radio_min) {
        ret = reverse_mul * (float)(radio_in - dz_min) / (float)(dz_min - radio_min);
    } else if (radio_in > dz_max && radio_max > dz_max) {
        ret = reverse_mul * (float)(radio_in - dz_max) / (float)(radio_max  - dz_max);
    } else {
        ret = 0;
    }
    return constrain_float(ret, -1.0f, 1.0f);
}

// return a normalised input for a channel, in range -1 to 1,
// ignores trim and deadzone
float RC_Channel::norm_input_ignore_trim() const
{
    // sanity check min and max to avoid divide by zero
    if (radio_max <= radio_min) {
        return 0.0f;
    }
    const float ret = (reversed ? -2.0f : 2.0f) * (((float)(radio_in - radio_min) / (float)(radio_max - radio_min)) - 0.5f);
    return constrain_float(ret, -1.0f, 1.0f);
}

/*
  get percentage input from 0 to 100. This ignores the trim value.
 */
uint8_t RC_Channel::percent_input() const
{
    if (radio_in <= radio_min) {
        return reversed?100:0;
    }
    if (radio_in >= radio_max) {
        return reversed?0:100;
    }
    uint8_t ret = 100.0f * (radio_in - radio_min) / (float)(radio_max - radio_min);
    if (reversed) {
        ret = 100 - ret;
    }
    return ret;
}

/*
  return true if input is within deadzone of trim
*/
bool RC_Channel::in_trim_dz() const
{
    return is_bounded_int32(radio_in, radio_trim - dead_zone, radio_trim + dead_zone);
}


/*
   return trues if input is within deadzone of min
*/
bool RC_Channel::in_min_dz() const
{
    return radio_in < radio_min + dead_zone;
}

void RC_Channel::set_override(const uint16_t v, const uint32_t timestamp_ms)
{
    if (!rc().gcs_overrides_enabled()) {
        return;
    }

    last_override_time = timestamp_ms != 0 ? timestamp_ms : AP_HAL::millis();
    override_value = v;
    rc().new_override_received();
}

void RC_Channel::clear_override()
{
    last_override_time = 0;
    override_value = 0;
}

bool RC_Channel::has_override() const
{
    if (override_value == 0) {
        return false;
    }

    uint32_t override_timeout_ms;
    if (!rc().get_override_timeout_ms(override_timeout_ms)) {
        // timeouts are disabled
        return true;
    }

    if (override_timeout_ms == 0) {
        // overrides are explicitly disabled by a zero value
        return false;
    }

    return (AP_HAL::millis() - last_override_time < override_timeout_ms);
}

/*
  perform stick mixing on one channel
  This type of stick mixing reduces the influence of the auto
  controller as it increases the influence of the users stick input,
  allowing the user full deflection if needed
 */
float RC_Channel::stick_mixing(const float servo_in)
{
    float ch_inf = (float)(radio_in - radio_trim);
    ch_inf = fabsf(ch_inf);
    ch_inf = MIN(ch_inf, 400.0f);
    ch_inf = ((400.0f - ch_inf) / 400.0f);

    float servo_out = servo_in;
    servo_out *= ch_inf;
    servo_out += control_in;

    return servo_out;
}

//
// support for auxiliary switches:
//

void RC_Channel::reset_mode_switch()
{
    switch_state.current_position = -1;
    switch_state.debounce_position = -1;
    read_mode_switch();
}

// read a 6 position switch
bool RC_Channel::read_6pos_switch(int8_t& position)
{
    // calculate position of 6 pos switch
    const uint16_t pulsewidth = get_radio_in();
    if (pulsewidth <= RC_MIN_LIMIT_PWM || pulsewidth >= RC_MAX_LIMIT_PWM) {
        return false;  // This is an error condition
    }

    if (pulsewidth < 1231) {
        position = 0;
    } else if (pulsewidth < 1361) {
        position = 1;
    } else if (pulsewidth < 1491) {
        position = 2;
    } else if (pulsewidth < 1621) {
        position = 3;
    } else if (pulsewidth < 1750) {
        position = 4;
    } else {
        position = 5;
    }

    if (!debounce_completed(position)) {
        return false;
    }

    return true;
}

void RC_Channel::read_mode_switch()
{
    int8_t position;
    if (read_6pos_switch(position)) {
        // set flight mode and simple mode setting
        mode_switch_changed(modeswitch_pos_t(position));
    }
}

bool RC_Channel::debounce_completed(int8_t position)
{
    // switch change not detected
    if (switch_state.current_position == position) {
        // reset debouncing
        switch_state.debounce_position = position;
    } else {
        // switch change detected
        const uint32_t tnow_ms = AP_HAL::millis();

        // position not established yet
        if (switch_state.debounce_position != position) {
            switch_state.debounce_position = position;
            switch_state.last_edge_time_ms = tnow_ms;
        } else if (tnow_ms - switch_state.last_edge_time_ms >= SWITCH_DEBOUNCE_TIME_MS) {
            // position estabilished; debounce completed
            switch_state.current_position = position;
            return true;
        }
    }

    return false;
}

//
// support for auxiliary switches:
//

// init_aux_switch_function - initialize aux functions
void RC_Channel::init_aux_function(const AUX_FUNC ch_option, const AuxSwitchPos ch_flag)
{
    // init channel options
    switch (ch_option) {
    // the following functions do not need to be initialised:
    case AUX_FUNC::ARMDISARM:
    case AUX_FUNC::ARMDISARM_AIRMODE:
#if AP_BATTERY_ENABLED
    case AUX_FUNC::BATTERY_MPPT_ENABLE:
#endif
#if AP_CAMERA_ENABLED
    case AUX_FUNC::CAMERA_TRIGGER:
#endif
    case AUX_FUNC::CLEAR_WP:
    case AUX_FUNC::COMPASS_LEARN:
    case AUX_FUNC::DISARM:
    case AUX_FUNC::DO_NOTHING:
#if AP_LANDINGGEAR_ENABLED
    case AUX_FUNC::LANDING_GEAR:
#endif
    case AUX_FUNC::LOST_VEHICLE_SOUND:
#if AP_SERVORELAYEVENTS_ENABLED && AP_RELAY_ENABLED
    case AUX_FUNC::RELAY:
    case AUX_FUNC::RELAY2:
    case AUX_FUNC::RELAY3:
    case AUX_FUNC::RELAY4:
    case AUX_FUNC::RELAY5:
    case AUX_FUNC::RELAY6:
#endif
#if HAL_VISUALODOM_ENABLED
    case AUX_FUNC::VISODOM_ALIGN:
#endif
    case AUX_FUNC::EKF_LANE_SWITCH:
    case AUX_FUNC::EKF_YAW_RESET:
#if HAL_GENERATOR_ENABLED
    case AUX_FUNC::GENERATOR: // don't turn generator on or off initially
#endif
    case AUX_FUNC::EKF_POS_SOURCE:
#if HAL_TORQEEDO_ENABLED
    case AUX_FUNC::TORQEEDO_CLEAR_ERR:
#endif
#if AP_SCRIPTING_ENABLED
    case AUX_FUNC::SCRIPTING_1:
    case AUX_FUNC::SCRIPTING_2:
    case AUX_FUNC::SCRIPTING_3:
    case AUX_FUNC::SCRIPTING_4:
    case AUX_FUNC::SCRIPTING_5:
    case AUX_FUNC::SCRIPTING_6:
    case AUX_FUNC::SCRIPTING_7:
    case AUX_FUNC::SCRIPTING_8:
#endif
#if AP_VIDEOTX_ENABLED
    case AUX_FUNC::VTX_POWER:
#endif
#if AP_OPTICALFLOW_CALIBRATOR_ENABLED
    case AUX_FUNC::OPTFLOW_CAL:
#endif
    case AUX_FUNC::TURBINE_START:
#if HAL_MOUNT_ENABLED
    case AUX_FUNC::MOUNT1_ROLL:
    case AUX_FUNC::MOUNT1_PITCH:
    case AUX_FUNC::MOUNT1_YAW:
    case AUX_FUNC::MOUNT2_ROLL:
    case AUX_FUNC::MOUNT2_PITCH:
    case AUX_FUNC::MOUNT2_YAW:
#endif
    case AUX_FUNC::LOWEHEISER_STARTER:
    case AUX_FUNC::MAG_CAL:
#if AP_CAMERA_ENABLED
    case AUX_FUNC::CAMERA_IMAGE_TRACKING:
#endif
#if HAL_MOUNT_ENABLED
    case AUX_FUNC::MOUNT_LRF_ENABLE:
#endif
        break;

    // not really aux functions:
    case AUX_FUNC::LOWEHEISER_THROTTLE:
        break;
#if HAL_ADSB_ENABLED
    case AUX_FUNC::AVOID_ADSB:
#endif
    case AUX_FUNC::AVOID_PROXIMITY:
#if AP_FENCE_ENABLED
    case AUX_FUNC::FENCE:
#endif
#if AP_GPS_ENABLED
    case AUX_FUNC::GPS_DISABLE:
    case AUX_FUNC::GPS_DISABLE_YAW:
#endif
#if AP_GRIPPER_ENABLED
    case AUX_FUNC::GRIPPER:
#endif
#if AP_INERTIALSENSOR_KILL_IMU_ENABLED
    case AUX_FUNC::KILL_IMU1:
    case AUX_FUNC::KILL_IMU2:
    case AUX_FUNC::KILL_IMU3:
#endif
    case AUX_FUNC::MISSION_RESET:
    case AUX_FUNC::MOTOR_ESTOP:
    case AUX_FUNC::RC_OVERRIDE_ENABLE:
#if HAL_RUNCAM_ENABLED
    case AUX_FUNC::RUNCAM_CONTROL:
    case AUX_FUNC::RUNCAM_OSD_CONTROL:
#endif
#if HAL_SPRAYER_ENABLED
    case AUX_FUNC::SPRAYER:
#endif
    case AUX_FUNC::DISABLE_AIRSPEED_USE:
    case AUX_FUNC::FFT_NOTCH_TUNE:
#if HAL_MOUNT_ENABLED
    case AUX_FUNC::RETRACT_MOUNT1:
    case AUX_FUNC::RETRACT_MOUNT2:
    case AUX_FUNC::MOUNT_LOCK:
#endif
#if HAL_LOGGING_ENABLED
    case AUX_FUNC::LOG_PAUSE:
#endif
    case AUX_FUNC::ARM_EMERGENCY_STOP:
#if AP_CAMERA_ENABLED
    case AUX_FUNC::CAMERA_REC_VIDEO:
    case AUX_FUNC::CAMERA_ZOOM:
    case AUX_FUNC::CAMERA_MANUAL_FOCUS:
    case AUX_FUNC::CAMERA_AUTO_FOCUS:
    case AUX_FUNC::CAMERA_LENS:
#endif
    case AUX_FUNC::AHRS_TYPE:
        run_aux_function(ch_option, ch_flag, AuxFuncTriggerSource::INIT);
        break;
    default:
        GCS_SEND_TEXT(MAV_SEVERITY_WARNING, "Failed to init: RC%u_OPTION: %u\n",
                        (unsigned)(this->ch_in+1), (unsigned)ch_option);
#if CONFIG_HAL_BOARD == HAL_BOARD_SITL
        AP_BoardConfig::config_error("Failed to init: RC%u_OPTION: %u",
                                     (unsigned)(this->ch_in+1), (unsigned)ch_option);
#endif
        break;
    }
}

#if AP_RC_CHANNEL_AUX_FUNCTION_STRINGS_ENABLED

const RC_Channel::LookupTable RC_Channel::lookuptable[] = {
    { AUX_FUNC::SAVE_WP,"SaveWaypoint"},
    { AUX_FUNC::CAMERA_TRIGGER,"CameraTrigger"},
    { AUX_FUNC::RANGEFINDER,"Rangefinder"},
    { AUX_FUNC::FENCE,"Fence"},
    { AUX_FUNC::SPRAYER,"Sprayer"},
    { AUX_FUNC::PARACHUTE_ENABLE,"ParachuteEnable"},
    { AUX_FUNC::PARACHUTE_RELEASE,"ParachuteRelease"},
    { AUX_FUNC::PARACHUTE_3POS,"Parachute3Position"},
    { AUX_FUNC::MISSION_RESET,"MissionReset"},
#if HAL_MOUNT_ENABLED
    { AUX_FUNC::RETRACT_MOUNT1,"RetractMount1"},
    { AUX_FUNC::RETRACT_MOUNT2,"RetractMount2"},
#endif
    { AUX_FUNC::RELAY,"Relay1"},
    { AUX_FUNC::MOTOR_ESTOP,"MotorEStop"},
    { AUX_FUNC::MOTOR_INTERLOCK,"MotorInterlock"},
    { AUX_FUNC::RELAY2,"Relay2"},
    { AUX_FUNC::RELAY3,"Relay3"},
    { AUX_FUNC::RELAY4,"Relay4"},
    { AUX_FUNC::PRECISION_LOITER,"PrecisionLoiter"},
    { AUX_FUNC::AVOID_PROXIMITY,"AvoidProximity"},
    { AUX_FUNC::WINCH_ENABLE,"WinchEnable"},
    { AUX_FUNC::WINCH_CONTROL,"WinchControl"},
    { AUX_FUNC::CLEAR_WP,"ClearWaypoint"},
    { AUX_FUNC::COMPASS_LEARN,"CompassLearn"},
    { AUX_FUNC::SAILBOAT_TACK,"SailboatTack"},
    { AUX_FUNC::GPS_DISABLE,"GPSDisable"},
    { AUX_FUNC::GPS_DISABLE_YAW,"GPSDisableYaw"},
    { AUX_FUNC::DISABLE_AIRSPEED_USE,"DisableAirspeedUse"},
    { AUX_FUNC::RELAY5,"Relay5"},
    { AUX_FUNC::RELAY6,"Relay6"},
    { AUX_FUNC::SAILBOAT_MOTOR_3POS,"SailboatMotor"},
    { AUX_FUNC::SURFACE_TRACKING,"SurfaceTracking"},
    { AUX_FUNC::RUNCAM_CONTROL,"RunCamControl"},
    { AUX_FUNC::RUNCAM_OSD_CONTROL,"RunCamOSDControl"},
    { AUX_FUNC::VISODOM_ALIGN,"VisOdomAlign"},
    { AUX_FUNC::AIRMODE, "AirMode"},
    { AUX_FUNC::CAM_MODE_TOGGLE,"CamModeToggle"},
    { AUX_FUNC::GENERATOR,"Generator"},
    { AUX_FUNC::BATTERY_MPPT_ENABLE,"Battery MPPT Enable"},
    { AUX_FUNC::ARSPD_CALIBRATE,"Calibrate Airspeed"},
    { AUX_FUNC::TORQEEDO_CLEAR_ERR, "Torqeedo Clear Err"},
    { AUX_FUNC::EMERGENCY_LANDING_EN, "Emergency Landing"},
    { AUX_FUNC::WEATHER_VANE_ENABLE, "Weathervane"},
    { AUX_FUNC::TURBINE_START, "Turbine Start"},
    { AUX_FUNC::FFT_NOTCH_TUNE, "FFT Notch Tuning"},
    { AUX_FUNC::MOUNT_LOCK, "MountLock"},
    { AUX_FUNC::LOG_PAUSE, "Pause Stream Logging"},
    { AUX_FUNC::CAMERA_REC_VIDEO, "Camera Record Video"},
    { AUX_FUNC::CAMERA_ZOOM, "Camera Zoom"},
    { AUX_FUNC::CAMERA_MANUAL_FOCUS, "Camera Manual Focus"},
    { AUX_FUNC::CAMERA_AUTO_FOCUS, "Camera Auto Focus"},
    { AUX_FUNC::CAMERA_IMAGE_TRACKING, "Camera Image Tracking"},
    { AUX_FUNC::CAMERA_LENS, "Camera Lens"},
    { AUX_FUNC::MOUNT_LRF_ENABLE, "Mount LRF Enable"},
};

/* lookup the announcement for switch change */
const char *RC_Channel::string_for_aux_function(AUX_FUNC function) const
{
    for (const struct LookupTable &entry : lookuptable) {
        if (entry.option == function) {
            return entry.announcement;
        }
    }
    return nullptr;
}

/* find string for postion */
const char *RC_Channel::string_for_aux_pos(AuxSwitchPos pos) const
{
    switch (pos) {
    case AuxSwitchPos::HIGH:
        return "HIGH";
    case AuxSwitchPos::MIDDLE:
        return "MIDDLE";
    case AuxSwitchPos::LOW:
        return "LOW";
    }
    return "";
}

#endif // AP_RC_CHANNEL_AUX_FUNCTION_STRINGS_ENABLED

/*
  read an aux channel. Return true if a switch has changed
 */
bool RC_Channel::read_aux()
{
    const AUX_FUNC _option = (AUX_FUNC)option.get();
    if (_option == AUX_FUNC::DO_NOTHING) {
        // may wish to add special cases for other "AUXSW" things
        // here e.g. RCMAP_ROLL etc once they become options
        return false;
#if AP_VIDEOTX_ENABLED
    } else if (_option == AUX_FUNC::VTX_POWER) {
        int8_t position;
        if (read_6pos_switch(position)) {
            AP::vtx().change_power(position);
            return true;
        }
        return false;
#endif  // AP_VIDEOTX_ENABLED
    }

    AuxSwitchPos new_position;
    if (!read_3pos_switch(new_position)) {
        return false;
    }

    if (!switch_state.initialised) {
        switch_state.initialised = true;
        if (init_position_on_first_radio_read((AUX_FUNC)option.get())) {
            switch_state.current_position = (int8_t)new_position;
            switch_state.debounce_position = (int8_t)new_position;
        }
    }

    if (!debounce_completed((int8_t)new_position)) {
        return false;
    }

#if AP_RC_CHANNEL_AUX_FUNCTION_STRINGS_ENABLED
    // announce the change to the GCS:
    const char *aux_string = string_for_aux_function(_option);
    if (aux_string != nullptr) {
        GCS_SEND_TEXT(MAV_SEVERITY_INFO, "RC%i: %s %s", ch_in+1, aux_string, string_for_aux_pos(new_position));
    }
#endif

    // debounced; undertake the action:
    run_aux_function(_option, new_position, AuxFuncTriggerSource::RC);
    return true;
}

// returns true if the first time we successfully read the
// channel's three-position-switch position we should record that
// position as the current position *without* executing the
// associated auxiliary function.  e.g. do not attempt to arm a
// vehicle when the user turns on their transmitter with the arm
// switch high!
bool RC_Channel::init_position_on_first_radio_read(AUX_FUNC func) const
{
    switch (func) {
    case AUX_FUNC::ARMDISARM_AIRMODE:
    case AUX_FUNC::ARMDISARM:
    case AUX_FUNC::ARM_EMERGENCY_STOP:
    case AUX_FUNC::PARACHUTE_RELEASE:

        // we do not want to process 
        return true;
    default:
        return false;
    }
}

void RC_Channel::do_aux_function_armdisarm(const AuxSwitchPos ch_flag)
{
    // arm or disarm the vehicle
    switch (ch_flag) {
    case AuxSwitchPos::HIGH:
        AP::arming().arm(AP_Arming::Method::AUXSWITCH, true);
        break;
    case AuxSwitchPos::MIDDLE:
        // nothing
        break;
    case AuxSwitchPos::LOW:
        AP::arming().disarm(AP_Arming::Method::AUXSWITCH);
        break;
    }
}

void RC_Channel::do_aux_function_avoid_adsb(const AuxSwitchPos ch_flag)
{
#if HAL_ADSB_ENABLED
    AP_Avoidance *avoidance = AP::ap_avoidance();
    if (avoidance == nullptr) {
        return;
    }
    if (ch_flag == AuxSwitchPos::HIGH) {
        AP_ADSB *adsb = AP::ADSB();
        if (adsb == nullptr) {
            return;
        }
        // try to enable AP_Avoidance
        if (!adsb->enabled() || !adsb->healthy()) {
            GCS_SEND_TEXT(MAV_SEVERITY_CRITICAL, "ADSB not available");
            return;
        }
        avoidance->enable();
        LOGGER_WRITE_EVENT(LogEvent::AVOIDANCE_ADSB_ENABLE);
        GCS_SEND_TEXT(MAV_SEVERITY_CRITICAL, "ADSB Avoidance Enabled");
        return;
    }

    // disable AP_Avoidance
    avoidance->disable();
    LOGGER_WRITE_EVENT(LogEvent::AVOIDANCE_ADSB_DISABLE);
    GCS_SEND_TEXT(MAV_SEVERITY_CRITICAL, "ADSB Avoidance Disabled");
#endif
}

void RC_Channel::do_aux_function_avoid_proximity(const AuxSwitchPos ch_flag)
{
#if AP_AVOIDANCE_ENABLED && !APM_BUILD_TYPE(APM_BUILD_ArduPlane)
    AC_Avoid *avoid = AP::ac_avoid();
    if (avoid == nullptr) {
        return;
    }

    switch (ch_flag) {
    case AuxSwitchPos::HIGH:
        avoid->proximity_avoidance_enable(true);
        break;
    case AuxSwitchPos::MIDDLE:
        // nothing
        break;
    case AuxSwitchPos::LOW:
        avoid->proximity_avoidance_enable(false);
        break;
    }
#endif // !APM_BUILD_ArduPlane
}

#if AP_CAMERA_ENABLED
void RC_Channel::do_aux_function_camera_trigger(const AuxSwitchPos ch_flag)
{
    if (ch_flag == AuxSwitchPos::HIGH) {
        AP_Camera *camera = AP::camera();
        if (camera == nullptr) {
            return;
        }
        camera->take_picture();
    }
}

bool RC_Channel::do_aux_function_record_video(const AuxSwitchPos ch_flag)
{
    AP_Camera *camera = AP::camera();
    if (camera == nullptr) {
        return false;
    }
    return camera->record_video(ch_flag == AuxSwitchP#pragma once

#include "RC_Channel_config.h"

#if AP_RC_CHANNEL_ENABLED

#include "RC_Channel.h"


/*
  this header file is expected to be #included by Vehicle subclasses
  of RC_Channels after defining RC_CHANNELS_SUBCLASS and
  RC_CHANNEL_SUBCLASS - for example, Rover defines
  RC_CHANNELS_SUBCLASS to be RC_Channels_Rover in Rover/RC_Channels.cpp, and then includes this header.

  This scheme reduces code duplicate between the Vehicles, and avoids the chance of things getting out of sync.
*/

const AP_Param::GroupInfo RC_Channels::var_info[] = {
    // @Group: 1_
    // @Path: RC_Channel.cpp
    AP_SUBGROUPINFO(obj_channels[0], "1_",  1, RC_CHANNELS_SUBCLASS, RC_CHANNEL_SUBCLASS),

    // @Group: 2_
    // @Path: RC_Channel.cpp
    AP_SUBGROUPINFO(obj_channels[1], "2_",  2, RC_CHANNELS_SUBCLASS, RC_CHANNEL_SUBCLASS),

    // @Group: 3_
    // @Path: RC_Channel.cpp
    AP_SUBGROUPINFO(obj_channels[2], "3_",  3, RC_CHANNELS_SUBCLASS, RC_CHANNEL_SUBCLASS),

    // @Group: 4_
    // @Path: RC_Channel.cpp
    AP_SUBGROUPINFO(obj_channels[3], "4_",  4, RC_CHANNELS_SUBCLASS, RC_CHANNEL_SUBCLASS),

    // @Group: 5_
    // @Path: RC_Channel.cpp
    AP_SUBGROUPINFO(obj_channels[4], "5_",  5, RC_CHANNELS_SUBCLASS, RC_CHANNEL_SUBCLASS),

    // @Group: 6_
    // @Path: RC_Channel.cpp
    AP_SUBGROUPINFO(obj_channels[5], "6_",  6, RC_CHANNELS_SUBCLASS, RC_CHANNEL_SUBCLASS),

    // @Group: 7_
    // @Path: RC_Channel.cpp
    AP_SUBGROUPINFO(obj_channels[6], "7_",  7, RC_CHANNELS_SUBCLASS, RC_CHANNEL_SUBCLASS),

    // @Group: 8_
    // @Path: RC_Channel.cpp
    AP_SUBGROUPINFO(obj_channels[7], "8_",  8, RC_CHANNELS_SUBCLASS, RC_CHANNEL_SUBCLASS),

    // @Group: 9_
    // @Path: RC_Channel.cpp
    AP_SUBGROUPINFO(obj_channels[8], "9_",  9, RC_CHANNELS_SUBCLASS, RC_CHANNEL_SUBCLASS),

    // @Group: 10_
    // @Path: RC_Channel.cpp
    AP_SUBGROUPINFO(obj_channels[9], "10_", 10, RC_CHANNELS_SUBCLASS, RC_CHANNEL_SUBCLASS),

    // @Group: 11_
    // @Path: RC_Channel.cpp
    AP_SUBGROUPINFO(obj_channels[10], "11_", 11, RC_CHANNELS_SUBCLASS, RC_CHANNEL_SUBCLASS),

    // @Group: 12_
    // @Path: RC_Channel.cpp
    AP_SUBGROUPINFO(obj_channels[11], "12_", 12, RC_CHANNELS_SUBCLASS, RC_CHANNEL_SUBCLASS),

    // @Group: 13_
    // @Path: RC_Channel.cpp
    AP_SUBGROUPINFO(obj_channels[12], "13_", 13, RC_CHANNELS_SUBCLASS, RC_CHANNEL_SUBCLASS),

    // @Group: 14_
    // @Path: RC_Channel.cpp
    AP_SUBGROUPINFO(obj_channels[13], "14_", 14, RC_CHANNELS_SUBCLASS, RC_CHANNEL_SUBCLASS),

    // @Group: 15_
    // @Path: RC_Channel.cpp
    AP_SUBGROUPINFO(obj_channels[14], "15_", 15, RC_CHANNELS_SUBCLASS, RC_CHANNEL_SUBCLASS),

    // @Group: 16_
    // @Path: RC_Channel.cpp
    AP_SUBGROUPINFO(obj_channels[15], "16_", 16, RC_CHANNELS_SUBCLASS, RC_CHANNEL_SUBCLASS),

    // @Param: _OVERRIDE_TIME
    // @DisplayName: RC override timeout
    // @Description: Timeout after which RC overrides will no longer be used, and RC input will resume, 0 will disable RC overrides, -1 will never timeout, and continue using overrides until they are disabled
    // @User: Advanced
    // @Range: 0.0 120.0
    // @Units: s
    AP_GROUPINFO("_OVERRIDE_TIME", 32, RC_CHANNELS_SUBCLASS, _override_timeout, 3.0),

    // @Param: _OPTIONS
    // @DisplayName: RC options
    // @Description: RC input options
    // @User: Advanced
    // @Bitmask: 0:Ignore RC Receiver, 1:Ignore MAVLink Overrides, 2:Ignore Receiver Failsafe bit but allow other RC failsafes if setup, 3:FPort Pad, 4:Log RC input bytes, 5:Arming check throttle for 0 input, 6:Skip the arming check for neutral Roll/Pitch/Yaw sticks, 7:Allow Switch reverse, 8:Use passthrough for CRSF telemetry, 9:Suppress CRSF mode/rate message for ELRS systems,10:Enable multiple receiver support, 11:Use Link Quality for RSSI with CRSF, 12:Annotate CRSF flight mode with * on disarm, 13: Use 420kbaud for ELRS protocol
    AP_GROUPINFO("_OPTIONS", 33, RC_CHANNELS_SUBCLASS, _options, (uint32_t)RC_Channels::Option::ARMING_CHECK_THROTTLE),

    // _PROTOCOLS copied to AP_Periph/Parameters.cpp
    // @Param: _PROTOCOLS
    // @DisplayName: RC protocols enabled
    // @Description: Bitmask of enabled RC protocols. Allows narrowing the protocol detection to only specific types of RC receivers which can avoid issues with incorrect detection. Set to 1 to enable all protocols.
    // @User: Advanced
    // @Bitmask: 0:All,1:PPM,2:IBUS,3:SBUS,4:SBUS_NI,5:DSM,6:SUMD,7:SRXL,8:SRXL2,9:CRSF,10:ST24,11:FPORT,12:FPORT2,13:FastSBUS,14:DroneCAN,15:Ghost,16:MAVRadio
    AP_GROUPINFO("_PROTOCOLS", 34, RC_CHANNELS_SUBCLASS, _protocols, 1),

    // @Param: _FS_TIMEOUT
    // @DisplayName: RC Failsafe timeout
    // @Description: RC failsafe will trigger this many seconds after loss of RC
    // @User: Standard
    // @Range: 0.5 10.0
    // @Units: s
    AP_GROUPINFO_FRAME("_FS_TIMEOUT", 35, RC_CHANNELS_SUBCLASS, _fs_timeout, 1.0, AP_PARAM_FRAME_COPTER),

    AP_GROUPEND
};

#endif  // AP_RC_CHANNEL_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 /*
 *       Example of RC_Channel library.
 *       Based on original sketch by Jason Short. 2010
 */

#include <AP_HAL/AP_HAL.h>
#include <RC_Channel/RC_Channel.h>

// we need a boardconfig created so that the io processor is available
#if HAL_WITH_IO_MCU
#include <AP_BoardConfig/AP_BoardConfig.h>
#include <AP_IOMCU/AP_IOMCU.h>
AP_BoardConfig BoardConfig;
#endif

void setup();
void loop();

const AP_HAL::HAL& hal = AP_HAL::get_HAL();

class RC_Channel_Example : public RC_Channel
{
};

class RC_Channels_Example : public RC_Channels
{
public:

    RC_Channel_Example obj_channels[NUM_RC_CHANNELS];

    RC_Channel_Example *channel(const uint8_t chan) override {
        if (chan >= NUM_RC_CHANNELS) {
            return nullptr;
        }
        return &obj_channels[chan];
    }

protected:

    int8_t flight_mode_channel_number() const override { return 5; }

private:

};

#define RC_CHANNELS_SUBCLASS RC_Channels_Example
#define RC_CHANNEL_SUBCLASS RC_Channel_Example

#include <RC_Channel/RC_Channels_VarInfo.h>

static RC_Channels_Example rc_channels;

static void print_radio_values();

#define RC_CHANNELS_TO_DISPLAY 8

void setup()
{
    hal.console->printf("ArduPilot RC Channel test\n");

#if HAL_WITH_IO_MCU
    BoardConfig.init();
#endif

    rc().init();

    print_radio_values();

    // set type of output, symmetrical angles or a number range;
    rc().channel(CH_1)->set_angle(4500);
    rc().channel(CH_1)->set_default_dead_zone(80);

    rc().channel(CH_2)->set_angle(4500);
    rc().channel(CH_2)->set_default_dead_zone(80);

    rc().channel(CH_3)->set_range(1000);
    rc().channel(CH_3)->set_default_dead_zone(20);

    rc().channel(CH_4)->set_angle(6000);
    rc().channel(CH_4)->set_default_dead_zone(500);

    rc().channel(CH_5)->set_range(1000);

    rc().channel(CH_6)->set_range(800);

    rc().channel(CH_7)->set_range(1000);

    rc().channel(CH_8)->set_range(1000);
}

void loop()
{
    static uint8_t count = 0;

    if (count++ == 0) {
        for (int i=0; i<RC_CHANNELS_TO_DISPLAY; i++) {
            hal.console->printf("Ch %02u ", (unsigned)i+1);
        }
        hal.console->printf("\n");
    }

    rc().read_input();
    for (uint8_t i=0; i<RC_CHANNELS_TO_DISPLAY; i++) {
	    hal.console->printf("%5d ", (int)rc().channel(i)->get_control_in());
	    // hal.console->printf("%4d ", (int)rc().channel(i)->percent_input());
    }
    hal.console->printf("\n");

    hal.scheduler->delay(20);
}


static void print_radio_values()
{
    for (int i=0; i<RC_CHANNELS_TO_DISPLAY; i++) {
	     hal.console->printf("CH%u: %u|%u\n",
			  (unsigned)i+1,
              (unsigned)rc().channel(i)->get_radio_min(),
			  (unsigned)rc().channel(i)->get_radio_max());
    }
}


AP_HAL_MAIN();
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       #pragma once

#include "SIM_SerialDevice.h"

namespace SITL {

class ADSB_Device : public SerialDevice
{
    using SerialDevice::SerialDevice;
};

};  // namespace SITL
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       /*
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
/*
    Dump logged AIS data to the serial port
    ./Tools/autotest/sim_vehicle.py -v Rover -A --serial5=sim:AIS --custom-location 51.58689798356386,-3.9044570193067965,0,0

    param set SERIAL5_PROTOCOL 40
    param set AIS_TYPE 1
*/

#include "SIM_AIS.h"

#if HAL_SIM_AIS_ENABLED

#include <SITL/SITL.h>

#define FORCE_VERSION_H_INCLUDE
#include "ap_version.h"

extern const AP_HAL::HAL& hal;

using namespace SITL;


AIS::AIS() : SerialDevice::SerialDevice()
{
    char* file_path;
    IGNORE_RETURN(asprintf(&file_path, AP_BUILD_ROOT "/libraries/SITL/SIM_AIS_data.txt"));

    file = fopen(file_path,"r");

    if (file == nullptr) {
        AP_HAL::panic("AIS could not open data file");
    }

    // seek past the header line
    char line[100];
    IGNORE_RETURN(fgets(line, sizeof(line), file));
}

void AIS::update()
{
    if (file == nullptr) {
        AP_HAL::panic("AIS lost data file");
    }

    // just send a line of data at 1Hz:
    const uint32_t now = AP_HAL::millis();
    if (now - last_sent_ms < 1000) {
        return;
    }
    last_sent_ms = now;

    char line[100];

    if (!fgets(line, sizeof(line), file)) {
        // got to the end of the file, circle back
        fseek(file,0,SEEK_SET);
        if (!fgets(line, sizeof(line), file)) {
            AP_HAL::panic("AIS lost data file");
        }
        return;
    }

    //hal.console->printf("%s",line);
    write_to_autopilot(line, strlen(line));

}

#endif  // HAL_SIM_AIS_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        /*
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
/*
    Dump logged AIS data to the serial port
    ./Tools/autotest/sim_vehicle.py -v Rover --no-mavproxy -A --serial5=sim:AIS --custom-location 51.58689798356386,-3.9044570193067965,0,0

    param set SERIAL5_PROTOCOL 40
    param set AIS_TYPE 1
*/

#pragma once

#include <AP_HAL/AP_HAL_Boards.h>

#ifndef HAL_SIM_AIS_ENABLED
#define HAL_SIM_AIS_ENABLED (CONFIG_HAL_BOARD == HAL_BOARD_SITL)
#endif

#if HAL_SIM_AIS_ENABLED

#include "SIM_SerialDevice.h"
#include <SITL/SITL.h>

namespace SITL {

class AIS : public SerialDevice {
public:

    AIS();

    void update();

private:
    FILE* file;

    uint32_t last_sent_ms;

};

}

#endif // HAL_SIM_AIS_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               AIS AIVDM data stream captured from a real receiver
!AIVDM,1,1,,B,403Ot`QuvFEfMo@7<0K?fL7028AU,0*60
!AIVDM,2,1,4,B,53aO?TT2C4pe09IP00058dhuN08D4<tp0000,0*0F
!AIVDM,2,2,4,B,0016=H=4;v?Te;1hTmh@000000000000000,2*68
!AIVDM,2,1,5,B,53aB7F02?1U90PdR2208D5Dl4LT>22222222,0*32
!AIVDM,2,2,5,B,2216:08666?S0=ihTmhH888888888888880,2*58
!AIVDM,2,1,6,B,5815;hT2AUU=KMMSR20q??N2v1<E9@4v2222,0*10
!AIVDM,2,2,6,B,221JLP0:P4hd0N43lU850C0Sm8888888880,2*2C
!AIVDM,1,1,,A,3815;hUw00wfUdHMPfQ4s8WT0D`r,0*00
!AIVDM,1,1,,A,33bE4P5000Of3c@MR@=0lBb80000,0*7F
!AIVDM,1,1,,A,33aB7F5000Of4I8MR@T0l`CBP000,0*4B
!AIVDM,2,1,7,B,53bE4P029KAA08Dt000DhU<48E@R0d000000,0*66
!AIVDM,2,2,7,B,00169H=666?i0<ihTmh@000000000000000,2*17
!AIVDM,1,1,,A,33M@D8UP00Of5B8MRBJ6A?vT2DTb,0*09
!AIVDM,2,1,8,B,53aO?TT2C4pe09IP00058dhuN08D4<tp0000,0*03
!AIVDM,2,2,8,B,0016=H=4;v?Te;1hTmh@000000000000000,2*64
!AIVDM,1,1,,A,33bE4P5000Of3c@MR@=Dw2b:0000,0*62
!AIVDM,1,1,,B,33aO?TUP00Of5B`MR?>hUOwF0DfJ,0*5E
!AIVDM,2,1,9,A,53bE4P029KAA08Dt000DhU<48E@R0d000000,0*6B
!AIVDM,2,2,9,A,00169H=666?i0<ihTmh@000000000000000,2*1A
!AIVDM,1,1,,A,33m:7K5000Of4M>MR=S`gWlB0000,0*69
!AIVDM,2,1,0,B,53bU7n02=f5I09`h00058dhuN18E<tiHD000,0*01
!AIVDM,2,2,0,B,0016:0:2<69T0?TmhCTi@@0000000000000,2*65
!AIVDM,1,1,,A,33aO?TUP00Of5BrMR?>PUOwF0Dm:,0*0C
!AIVDM,1,1,,B,33m:7K5000Of4N2MR=WpgWlB0000,0*71
!AIVDM,1,1,,A,33aB7F5000Of4I8MR@T0g`CBP000,0*40
!AIVDM,2,1,1,B,53bE4P029KAA08Dt000DhU<48E@R0d000000,0*60
!AIVDM,2,2,1,B,00169H=666?i0<ihTmh@000000000000000,2*11
!AIVDM,1,1,,B,3815;hU0h1wfUdHMPfQ6B`WT0Dir,0*7F
!AIVDM,1,1,,A,33bU7n5000Of2hDMRB@:CTs00000,0*09
!AIVDM,1,1,,B,33bE4P5000Of3c>MR@=ewRb:0000,0*5E
!AIVDM,2,1,2,A,53bU7n02=f5I09`h00058dhuN18E<tiHD000,0*00
!AIVDM,2,2,2,A,0016:0:2<69T0?TmhCTi@@0000000000000,2*64
!AIVDM,1,1,,B,33aB7F5000Of4L@MR@T0F`CBP000,0*1F
!AIVDM,2,1,3,B,53aO?TT2C4pe09IP00058dhuN08D4<tp0000,0*08
!AIVDM,2,2,3,B,0016=H=4;v?Te;1hTmh@000000000000000,2*6F
!AIVDM,2,1,4,B,53m:7K02;lo<h4PCR20HDDB0PDhLDh4pB222,0*34
!AIVDM,2,2,4,B,22169H?856?j0:1hTmhH888888888888880,2*4E
!AIVDM,1,1,,B,33bU7n5000Of2gBMRB0:CTs00000,0*73
!AIVDM,1,1,,B,33aO?TUP00Of5AtMR?;0egwD0D`b,0*20
!AIVDM,1,1,,B,33bE4P5000Of3c6MR@>M9Rb:0000,0*33
!AIVDM,1,1,,A,33aO?TUP00Of5B>MR?9hegwF0DiJ,0*13
!AIVDM,1,1,,A,3815;hU0P2wfUdHMPfQ888WR0E0J,0*0D
!AIVDM,2,1,5,A,53m:7K02;lo<h4PCR20HDDB0PDhLDh4pB222,0*36
!AIVDM,2,2,5,A,22169H?856?j0:1hTmhH888888888888880,2*4C
!AIVDM,1,1,,B,33aO?TUP00Of5B:MR?<PegwD0Dh:,0*5A
!AIVDM,2,1,6,A,53bU7n02=f5I09`h00058dhuN18E<tiHD000,0*04
!AIVDM,2,2,6,A,0016:0:2<69T0?TmhCTi@@0000000000000,2*60
!AIVDM,1,1,,B,33aB7F5001Of4I8MR@T8h8CBP000,0*1D
!AIVDM,2,1,7,B,53aO?TT2C4pe09IP00058dhuN08D4<tp0000,0*0C
!AIVDM,2,2,7,B,0016=H=4;v?Te;1hTmh@000000000000000,2*6B
!AIVDM,1,1,,A,3815;hU1P0wfUdHMPfQ=r8WV0Dbr,0*2E
!AIVDM,1,1,,B,33bU7n5000Of2glMRBFrCTs20000,0*61
!AIVDM,1,1,,A,33bE4P5000Of3btMR@>M6Bb:0000,0*6C
!AIVDM,1,1,,A,33aB7F5000Of4I8MR@T0v`CDP000,0*57
!AIVDM,1,1,,A,33bU7n5000Of2gTMRB<JCTs20000,0*18
!AIVDM,2,1,8,B,53bU7n02=f5I09`h00058dhuN18E<tiHD000,0*09
!AIVDM,2,2,8,B,0016:0:2<69T0?TmhCTi@@0000000000000,2*6D
!AIVDM,1,1,,A,33aO?TUP00Of5C2MR??0p?wD0Dar,0*3F
!AIVDM,2,1,9,B,53aB7F02?1U90PdR2208D5Dl4LT>22222222,0*3E
!AIVDM,2,2,9,B,2216:08666?S0=ihTmhH888888888888880,2*54
!AIVDM,2,1,0,B,5815;hT2AUU=KMMSR20q??N2v1<E9@4v2222,0*16
!AIVDM,2,2,0,B,221JLP0:P4hd0N43lU850C0Sm8888888880,2*2A
!AIVDM,1,1,,B,33aO?TUP00Of5BDMR?<hp?wF0Dib,0*0A
!AIVDM,1,1,,B,3815;hUwP1wfUdHMPfQ=S`WV0DVr,0*27
!AIVDM,1,1,,A,33m:7K5000Of4MpMR=O8gWlD0000,0*65
!AIVDM,1,1,,A,33aO?TUP00Of5CDMR?=Pp?wD0DjJ,0*18
!AIVDM,2,1,1,B,53aO?TT2C4pe09IP00058dhuN08D4<tp0000,0*0A
!AIVDM,2,2,1,B,0016=H=4;v?Te;1hTmh@000000000000000,2*6D
!AIVDM,2,1,2,A,53aB7F02?1U90PdR2208D5Dl4LT>22222222,0*36
!AIVDM,2,2,2,A,2216:08666?S0=ihTmhH888888888888880,2*5C
!AIVDM,1,1,,A,3815;hUwh1wfUdHMPfQ0j8W`0Djr,0*7A
!AIVDM,2,1,3,B,53m:7K02;lo<h4PCR20HDDB0PDhLDh4pB222,0*33
!AIVDM,2,2,3,B,22169H?856?j0:1hTmhH888888888888880,2*49
!AIVDM,1,1,,A,33aB7F5000Of4I8MR@T7v8CDP000,0*08
!AIVDM,1,1,,B,3815;hUwh0wfUdHMPfQ0e8WT0DMb,0*74
!AIVDM,1,1,,A,33bU7n5000Of2hBMRB<rCTs20000,0*39
!AIVDM,1,1,,B,33bE4P5000Of3c0MR@=JJ2b:0000,0*22
!AIVDM,1,1,,B,33aB7F5000Of4I8MR@T1h`CDP000,0*4B
!AIVDM,2,1,4,A,53aO?TT2C4pe09IP00058dhuN08D4<tp0000,0*0C
!AIVDM,2,2,4,A,0016=H=4;v?Te;1hTmh@000000000000000,2*6B
!AIVDM,2,1,5,B,53aB7F02?1U90PdR2208D5Dl4LT>22222222,0*32
!AIVDM,2,2,5,B,2216:08666?S0=ihTmhH888888888888880,2*58
!AIVDM,1,1,,B,33bU7n5000Of2hFMRB<rCTs20000,0*3E
!AIVDM,1,1,,A,33bE4P5000Of3bvMR@=`Tjb<0000,0*0C
!AIVDM,1,1,,B,33aO?TUP00Of5BLMR?<Pp?wF0Dg:,0*6C
!AIVDM,2,1,6,B,53bE4P029KAA08Dt000DhU<48E@R0d000000,0*67
!AIVDM,2,2,6,B,00169H=666?i0<ihTmh@000000000000000,2*16
!AIVDM,1,1,,B,33bE4P5P@0Of3c0MR@=WaRb<0000,0*62
!AIVDM,2,1,7,B,53aO?TT2C4pe09IP00058dhuN08D4<tp0000,0*0C
!AIVDM,2,2,7,B,0016=H=4;v?Te;1hTmh@000000000000000,2*6B
!AIVDM,2,1,8,A,53aB7F02?1U90PdR2208D5Dl4LT>22222222,0*3C
!AIVDM,2,2,8,A,2216:08666?S0=ihTmhH888888888888880,2*56
!AIVDM,2,1,9,A,5815;hT2AUU=KMMSR20q??N2v1<E9@4v2222,0*1C
!AIVDM,2,2,9,A,221JLP0:P4hd0N43lU850C0Sm8888888880,2*20
!AIVDM,1,1,,A,3815;hU101wfUdHMPfQ;@8Wb0Dsb,0*4E
!AIVDM,1,1,,A,33aB7F5000Of4I8MR@T0?8ADP000,0*44
!AIVDM,1,1,,B,33aO?TUP00Of5C@MR?;@p?wF0D`r,0*39
!AIVDM,2,1,0,A,53bE4P029KAA08Dt000DhU<48E@R0d000000,0*62
!AIVDM,2,2,0,A,00169H=666?i0<ihTmh@000000000000000,2*13
!AIVDM,1,1,,B,3815;hUwh1wfUdHMPfQ6L`WR0DlJ,0*0D
!AIVDM,1,1,,B,33aB7F5000Of4I8MR@T0<`ADP000,0*1C
!AIVDM,2,1,1,A,53aO?TT2C4pe09IP00058dhuN08D4<tp0000,0*09
!AIVDM,2,2,1,A,0016=H=4;v?Te;1hTmh@000000000000000,2*6E
!AIVDM,2,1,2,B,53aB7F02?1U90PdR2208D5Dl4LT>22222222,0*35
!AIVDM,2,2,2,B,2216:08666?S0=ihTmhH888888888888880,2*5F
!AIVDM,2,1,3,B,5815;hT2AUU=KMMSR20q??N2v1<E9@4v2222,0*15
!AIVDM,2,2,3,B,221JLP0:P4hd0N43lU850C0Sm8888888880,2*29
!AIVDM,1,1,,A,3815;hUwh1wfUdHMPfQ1p8Wd0DsJ,0*44
!AIVDM,1,1,,A,33bE4P5000Of3c8MR@=IeRb<0000,0*63
!AIVDM,1,1,,A,33aB7F5000Of4I8MR@T5:8ADP000,0*44
!AIVDM,2,1,4,B,53bE4P029KAA08Dt000DhU<48E@R0d000000,0*65
!AIVDM,2,2,4,B,00169H=666?i0<ihTmh@000000000000000,2*14
!AIVDM,1,1,,B,33bE4P5000Of3c<MR@=70Rb<0000,0*4F
!AIVDM,1,1,,A,33aO?TUP00Of5BrMR?;0p?wH0DW:,0*08
!AIVDM,2,1,5,A,53aB7F02?1U90PdR2208D5Dl4LT>22222222,0*31
!AIVDM,2,2,5,A,2216:08666?S0=ihTmhH888888888888880,2*5B
!AIVDM,1,1,,A,33bE4P5000Of3c>MR@=GQRb<0000,0*5F
!AIVDM,1,1,,B,33aO?TUP00Of5BvMR??@p?wF0De:,0*47
!AIVDM,2,1,6,A,53bE4P029KAA08Dt000DhU<48E@R0d000000,0*64
!AIVDM,2,2,6,A,00169H=666?i0<ihTmh@000000000000000,2*15
!AIVDM,1,1,,B,3815;hU0@1wfUdHMPfQ558WN0E3r,0*3A
!AIVDM,1,1,,B,33aB7F5000Of4I8MR@T=Q8ADP000,0*24
!AIVDM,2,1,7,B,53bE4P029KAA08Dt000DhU<48E@R0d000000,0*66
!AIVDM,2,2,7,B,00169H=666?i0<ihTmh@000000000000000,2*17
!AIVDM,1,1,,B,3815;hU0P1wfUdHMPfQ058WT0Dcr,0*64
!AIVDM,1,1,,B,33aB7F5000Of4I8MR@T6E8ADP000,0*3B
!AIVDM,1,1,,B,33bU7n5000Of2glMRAwJCTs40000,0*6D
!AIVDM,1,1,,A,33bE4P5000Of3c<MR@=B5jb<0000,0*04
!AIVDM,1,1,,B,33aO?TUP00Of5BfMR?:0b?wF0Dk:,0*3E
!AIVDM,1,1,,A,33m:7K5000Of4MlMR=T`gWnF0000,0*3A
!AIVDM,1,1,,B,33bE4P5000Of3c<MR@=S>Rb<0000,0*25
!AIVDM,2,1,8,B,53bU7n02=f5I09`h00058dhuN18E<tiHD000,0*09
!AIVDM,2,2,8,B,0016:0:2<69T0?TmhCTi@@0000000000000,2*6D
!AIVDM,2,1,9,B,53aO?TT2C4pe09IP00058dhuN08D4<tp0000,0*02
!AIVDM,2,2,9,B,0016=H=4;v?Te;1hTmh@000000000000000,2*65
!AIVDM,2,1,0,A,53m:7K02;lo<h4PCR20HDDB0PDhLDh4pB222,0*33
!AIVDM,2,2,0,A,22169H?856?j0:1hTmhH888888888888880,2*49
!AIVDM,1,1,,A,33aB7F5000Of4I8MR@T9M8ADP000,0*3F
!AIVDM,2,1,1,A,53bU7n02=f5I09`h00058dhuN18E<tiHD000,0*03
!AIVDM,2,2,1,A,0016:0:2<69T0?TmhCTi@@0000000000000,2*67
!AIVDM,1,1,,B,33aB7F5000Of4I8MR@T2g8ADP000,0*1D
!AIVDM,2,1,2,A,53aO?TT2C4pe09IP00058dhuN08D4<tp0000,0*0A
!AIVDM,2,2,2,A,0016=H=4;v?Te;1hTmh@000000000000000,2*6D
!AIVDM,1,1,,B,33bU7n5000Of2hBMRB6bCTs40000,0*26
!AIVDM,1,1,,A,33bE4P5000Of3c<MR@=lijb>0000,0*74
!AIVDM,1,1,,B,33bE4P5Oh0Of3c<MR@=nEBb>0000,0*56
!AIVDM,2,1,3,B,53bU7n02=f5I09`h00058dhuN18E<tiHD000,0*02
!AIVDM,2,2,3,B,0016:0:2<69T0?TmhCTi@@0000000000000,2*66
!AIVDM,1,1,,A,33aO?TUP00Of5C8MR?<Pb?wF0Dh:,0*07
!AIVDM,2,1,4,B,53aO?TT2C4pe09IP00058dhuN08D4<tp0000,0*0F
!AIVDM,2,2,4,B,0016=H=4;v?Te;1hTmh@000000000000000,2*68
!AIVDM,1,1,,A,33bE4P5000Of3c>MR@>2ORb>0000,0*35
!AIVDM,1,1,,B,33aO?TUP00Of5BRMR?>hb?wD0Dnb,0*09                                                                                                    /*
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
/*
	Simulator Connector for AirSim
*/

#include "SIM_AirSim.h"

#if HAL_SIM_AIRSIM_ENABLED

#include <stdio.h>
#include <arpa/inet.h>
#include <errno.h>

#include <AP_HAL/AP_HAL.h>
#include <AP_Logger/AP_Logger.h>
#include <AP_HAL/utility/replace.h>

#define UDP_TIMEOUT_MS 100

extern const AP_HAL::HAL& hal;

using namespace SITL;

AirSim::AirSim(const char *frame_str) :
	Aircraft(frame_str),
	sock(true)
{
    if (strstr(frame_str, "-copter")) {
        output_type = OutputType::Copter;
    } else if (strstr(frame_str, "-rover")) {
        output_type = OutputType::Rover;
    } else {
        // default to copter
        output_type = OutputType::Copter;
    }

	printf("Starting SITL Airsim type %u\n", (unsigned)output_type);
}

/*
	Create & set in/out socket
*/
void AirSim::set_interface_ports(const char* address, const int port_in, const int port_out)
{
    static const char *port_in_addr = "0.0.0.0";

    if (!sock.bind(port_in_addr, port_in)) {
		printf("Unable to bind Airsim sensor_in socket at port %u - Error: %s\n",
				 port_in, strerror(errno));
		return;
	}
	printf("Bind SITL sensor input at %s:%u\n", port_in_addr, port_in);
	sock.set_blocking(false);
	sock.reuseaddress();

	airsim_ip = address;
	airsim_control_port = port_out;
	airsim_sensor_port = port_in;

	printf("AirSim control interface set to %s:%u\n", airsim_ip, airsim_control_port);
}

/*
	Decode and send servos
*/
void AirSim::output_copter(const sitl_input& input)
{
    servo_packet pkt;

	for (uint8_t i=0; i<kArduCopterRotorControlCount; i++) {
		pkt.pwm[i] = input.servos[i];
	}

	ssize_t send_ret = sock.sendto(&pkt, sizeof(pkt), airsim_ip, airsim_control_port);
	if (send_ret != sizeof(pkt)) {
		if (send_ret <= 0) {
			printf("Unable to send servo output to %s:%u - Error: %s, Return value: %ld\n",
                   airsim_ip, airsim_control_port, strerror(errno), (long)send_ret);
		} else {
			printf("Sent %ld bytes instead of %lu bytes\n", (long)send_ret, (unsigned long)sizeof(pkt));
		}
	}
}

void AirSim::output_rover(const sitl_input& input)
{
    rover_packet pkt;

    pkt.steering = 2*((input.servos[0]-1000)/1000.0f - 0.5f);
    pkt.throttle = 2*((input.servos[2]-1000)/1000.0f - 0.5f);

    ssize_t send_ret = sock.sendto(&pkt, sizeof(pkt), airsim_ip, airsim_control_port);
    if (send_ret != sizeof(pkt)) {
        if (send_ret <= 0) {
            printf("Unable to send control output to %s:%u - Error: %s, Return value: %ld\n",
                     airsim_ip, airsim_control_port, strerror(errno), (long)send_ret);
        } else {
            printf("Sent %ld bytes instead of %lu bytes\n", (long)send_ret, (unsigned long)sizeof(pkt));
        }
    }
}

/*
    Wrapper function to send servo output
*/
void AirSim::output_servos(const sitl_input& input)
{
    switch (output_type) {
    case OutputType::Copter:
        output_copter(input);
        break;

    case OutputType::Rover:
        output_rover(input);
        break;
    }
}

/*
  very simple JSON parser for sensor data
  called with pointer to one row of sensor data, nul terminated

  This parser does not do any syntax checking, and is not at all
  general purpose
*/
bool AirSim::parse_sensors(const char *json)
{
    // printf("%s\n", json);
    for (uint16_t i=0; i<ARRAY_SIZE(keytable); i++) {
        struct keytable &key = keytable[i];

        /* look for section header */
        const char *p = strstr(json, key.section);
        if (!p) {
            // we don't have this sensor
            continue;
        }
        p += strlen(key.section)+1;

        // find key inside section
        p = strstr(p, key.key);
        if (!p) {
            printf("Failed to find key %s/%s\n", key.section, key.key);
            return false;
        }

        p += strlen(key.key)+3;
        switch (key.type) {
            case DATA_UINT64:
                *((uint64_t *)key.ptr) = strtoul(p, nullptr, 10);
                break;

            case DATA_FLOAT:
                *((float *)key.ptr) = atof(p);
                break;

            case DATA_DOUBLE:
                *((double *)key.ptr) = atof(p);
                break;

            case DATA_VECTOR3F: {
                Vector3f *v = (Vector3f *)key.ptr;
                if (sscanf(p, "[%f, %f, %f]", &v->x, &v->y, &v->z) != 3) {
                    printf("Failed to parse Vector3f for %s/%s\n", key.section, key.key);
                    return false;
                }
                break;
            }

            case DATA_VECTOR3F_ARRAY: {
                // - array of floats that represent [x,y,z] coordinate for each point hit within the range
                //       x0, y0, z0, x1, y1, z1, ..., xn, yn, zn
                // example: [23.1,0.677024,1.4784,-8.97607135772705,-8.976069450378418,-8.642673492431641e-07,]
                if (*p++ != '[') {
                    return false;
                }
                uint16_t n = 0;
                vector3f_array *v = (vector3f_array *)key.ptr;
                while (true) {
                    if (n >= v->length) {
                        Vector3f *d = (Vector3f *)realloc(v->data, sizeof(Vector3f)*(n+1));
                        if (d == nullptr) {
                            return false;
                        }
                        v->data = d;
                        v->length = n+1;
                    }
                    if (sscanf(p, "%f,%f,%f,", &v->data[n].x, &v->data[n].y, &v->data[n].z) != 3) {
                        printf("Failed to parse Vector3f for %s/%s[%u]\n", key.section, key.key, n);
                        return false;
                    }
                    n++;
                    // Goto 3rd occurence of ,
                    p = strchr(p,',');
                    if (!p) {
                        return false;
                    }
                    p++;
                    p = strchr(p,',');
                    if (!p) {
                        return false;
                    }
                    p++;
                    p = strchr(p,',');
                    if (!p) {
                        return false;
                    }
                    p++;
                    // Reached end of point cloud
                    if (p[0] == ']') {
                        break;
                    }
                }
                v->length = n;
                break;
            }

            case DATA_FLOAT_ARRAY: {
                // example: [18.0, 12.694079399108887]
                if (*p++ != '[') {
                    return false;
                }
                uint16_t n = 0;
                float_array *v = (float_array *)key.ptr;
                while (true) {
                    if (n >= v->length) {
                        float *d = (float *)realloc(v->data, sizeof(float)*(n+1));
                        if (d == nullptr) {
                            return false;
                        }
                        v->data = d;
                        v->length = n+1;
                    }
                    v->data[n] = atof(p);
                    n++;
                    p = strchr(p,',');
                    if (!p) {
                        break;
                    }
                    p++;
                }
                v->length = n;
                break;
            }
        }
    }
    return true;
}

/*
	Receive new sensor data from simulator
	This is a blocking function
*/
void AirSim::recv_fdm(const sitl_input& input)
{
    // Receive sensor packet
    ssize_t ret = sock.recv(&sensor_buffer[sensor_buffer_len], sizeof(sensor_buffer)-sensor_buffer_len, UDP_TIMEOUT_MS);
    uint32_t wait_ms = UDP_TIMEOUT_MS;
    while (ret <= 0) {
        // printf("No sensor message received - %s\n", strerror(errno));
        ret = sock.recv(&sensor_buffer[sensor_buffer_len], sizeof(sensor_buffer)-sensor_buffer_len, UDP_TIMEOUT_MS);
        wait_ms += UDP_TIMEOUT_MS;

        // If no sensor message is received after 1 second, resend servos
        // this helps if messages are lost on the way, and both AP & Airsim are waiting for each ther
        if (wait_ms > 1000) {
            wait_ms = 0;
            printf("No sensor message received in last 1s, error - %s, resending servos\n", strerror(errno));
            output_servos(input);
        }
    }

    // convert '\n' into nul
    while (uint8_t *p = (uint8_t *)memchr(&sensor_buffer[sensor_buffer_len], '\n', ret)) {
        *p = 0;
    }
    sensor_buffer_len += ret;

    const uint8_t *p2 = (const uint8_t *)memrchr(sensor_buffer, 0, sensor_buffer_len);
    if (p2 == nullptr || p2 == sensor_buffer) {
        return;
    }
    const uint8_t *p1 = (const uint8_t *)memrchr(sensor_buffer, 0, p2 - sensor_buffer);
    if (p1 == nullptr) {
        return;
    }

    parse_sensors((const char *)(p1+1));

    memmove(sensor_buffer, p2, sensor_buffer_len - (p2 - sensor_buffer));
    sensor_buffer_len = sensor_buffer_len - (p2 - sensor_buffer);

    accel_body = state.imu.linear_acceleration;
    gyro = state.imu.angular_velocity;
    velocity_ef = state.velocity.world_linear_velocity;

    location.lat = state.gps.lat * 1.0e7;
    location.lng = state.gps.lon * 1.0e7;
    location.alt = state.gps.alt * 100.0f;

    position = origin.get_distance_NED_double(location);

    dcm.from_euler(state.pose.roll, state.pose.pitch, state.pose.yaw);

    if (last_timestamp) {
        int deltat = state.timestamp - last_timestamp;
        time_now_us += deltat;

        if (deltat > 0 && deltat < 100000) {
            if (average_frame_time < 1) {
                average_frame_time = deltat;
            }
            average_frame_time = average_frame_time * 0.98 + deltat * 0.02;
        }
    }

    scanner.points = state.lidar.points;

    // Update RC input, max 12 channels
    rcin_chan_count = MIN(state.rc.rc_channels.length, 12);
    for (uint8_t i=0; i < rcin_chan_count; i++) {
        rcin[i] = state.rc.rc_channels.data[i];
    }

    // Update Rangefinder data, max sensors limit as defined
    uint8_t rng_sensor_count = MIN(state.rng.rng_distances.length, ARRAY_SIZE(rangefinder_m));
    for (uint8_t i=0; i<rng_sensor_count; i++) {
        rangefinder_m[i] = state.rng.rng_distances.data[i];
    }

#if 0
// @LoggerMessage: ASM1
// @Description: AirSim simulation data
// @Field: TimeUS: Time since system startup
// @Field: TUS: Simulation's timestamp
// @Field: R: Simulation's roll
// @Field: P: Simulation's pitch
// @Field: Y: Simulation's yaw
// @Field: GX: Simulated gyroscope, X-axis
// @Field: GY: Simulated gyroscope, Y-axis
// @Field: GZ: Simulated gyroscope, Z-axis
    AP::logger().WriteStreaming("ASM1", "TimeUS,TUS,R,P,Y,GX,GY,GZ",
                       "QQffffff",
                       AP_HAL::micros64(),
                       state.timestamp,
                       degrees(state.pose.roll),
                       degrees(state.pose.pitch),
                       degrees(state.pose.yaw),
                       degrees(gyro.x),
                       degrees(gyro.y),
                       degrees(gyro.z));

    Vector3f velocity_bf = dcm.transposed() * velocity_ef;

// @LoggerMessage: ASM2
// @Description: More AirSim simulation data
// @Field: TimeUS: Time since system startup
// @Field: AX: simulation's acceleration, X-axis
// @Field: AY: simulation's acceleration, Y-axis
// @Field: AZ: simulation's acceleration, Z-axis
// @Field: VX: simulation's velocity, X-axis
// @Field: VY: simulation's velocity, Y-axis
// @Field: VZ: simulation's velocity, Z-axis
// @Field: PX: simulation's position, X-axis
// @Field: PY: simulation's position, Y-axis
// @Field: PZ: simulation's position, Z-axis
// @Field: Alt: simulation's gps altitude
// @Field: SD: simulation's earth-frame speed-down
    AP::logger().WriteStreaming("ASM2", "TimeUS,AX,AY,AZ,VX,VY,VZ,PX,PY,PZ,Alt,SD",
                       "Qfffffffffff",
                       AP_HAL::micros64(),
                       accel_body.x,
                       accel_body.y,
                       accel_body.z,
                       velocity_bf.x,
                       velocity_bf.y,
                       velocity_bf.z,
                       position.x,
                       position.y,
                       position.z,
                       state.gps.alt,
                       velocity_ef.z);
#endif

    last_timestamp = state.timestamp;
}

/*
  update the AirSim simulation by one time step
*/
void AirSim::update(const sitl_input& input)
{
    // Send servos to AirSim
    output_servos(input);

    // Receive sensor data
    recv_fdm(input);

    // update magnetic field
    update_mag_field_bf();

    report_FPS();
}

/*
  report frame rates
 */
void AirSim::report_FPS(void)
{
    if (frame_counter++ % 1000 == 0) {
        if (last_frame_count != 0) {
            printf("FPS avg=%.2f\n", 1.0e6/average_frame_time);
        }
        last_frame_count = state.timestamp;
    }
}

#endif  // HAL_SIM_AIRSIM_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         /*
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
/*
	Simulator connector for Airsim: https://github.com/Microsoft/AirSim
*/

#pragma once

#include <AP_HAL/AP_HAL_Boards.h>

#ifndef HAL_SIM_AIRSIM_ENABLED
#define HAL_SIM_AIRSIM_ENABLED (CONFIG_HAL_BOARD == HAL_BOARD_SITL)
#endif

#if HAL_SIM_AIRSIM_ENABLED

#include <AP_HAL/utility/Socket_native.h>
#include "SIM_Aircraft.h"

namespace SITL {

/*
	Airsim Simulator
*/

class AirSim : public Aircraft {
public:
	AirSim(const char *frame_str);

	/* update model by one time step */
	void update(const struct sitl_input &input) override;

	/* static object creator */
    static Aircraft *create(const char *frame_str) {
        return NEW_NOTHROW AirSim(frame_str);
    }

    /*  Create and set in/out socket for Airsim simulator */
    void set_interface_ports(const char* address, const int port_in, const int port_out) override;

private:
    enum class OutputType {
        Copter = 1,
        Rover = 2
    } output_type;

    // Control packet for Rover
    struct rover_packet {
        float throttle;     // -1 to 1
        float steering;     // -1 to 1
    };

    // rotor control packet sent by Ardupilot
    static const int kArduCopterRotorControlCount = 11;

    struct servo_packet {
		uint16_t pwm[kArduCopterRotorControlCount];
	};

	// default connection_info_.ip_address
	const char *airsim_ip = "127.0.0.1";

	// connection_info_.ip_port
	uint16_t airsim_sensor_port = 9003;

	// connection_info_.sitl_ip_port
	uint16_t airsim_control_port = 9002;

    SocketAPM_native sock;

    double average_frame_time;
    uint64_t frame_counter;
    uint64_t last_frame_count;
    uint64_t last_timestamp;

    void output_copter(const sitl_input& input);
    void output_rover(const sitl_input& input);
    // Wrapper function over the above 2 output methods
    void output_servos(const sitl_input& input);

    void recv_fdm(const sitl_input& input);
    void report_FPS(void);

	bool parse_sensors(const char *json);

	// buffer for parsing pose data in JSON format
    uint8_t sensor_buffer[65000];
    uint32_t sensor_buffer_len;

	enum data_type {
		DATA_UINT64,
        DATA_FLOAT,
        DATA_DOUBLE,
        DATA_VECTOR3F,
        DATA_VECTOR3F_ARRAY,
        DATA_FLOAT_ARRAY,
    };

    struct {
        uint64_t timestamp;
        struct {
            Vector3f angular_velocity;
            Vector3f linear_acceleration;
        } imu;
        struct {
            double lat, lon, alt;
        } gps;
        struct {
            float roll, pitch, yaw;
        } pose;
        struct {
            Vector3f world_linear_velocity;
        } velocity;
        struct {
            struct vector3f_array points;
        } lidar;
        struct {
            struct float_array rc_channels;
        } rc;
        struct {
            struct float_array rng_distances;
        } rng;
    } state;

    // table to aid parsing of JSON sensor data
    struct keytable {
        const char *section;
        const char *key;
        void *ptr;
        enum data_type type;
    } keytable[13] = {
        { "", "timestamp", &state.timestamp, DATA_UINT64 },
        { "imu", "angular_velocity",    &state.imu.angular_velocity, DATA_VECTOR3F },
        { "imu", "linear_acceleration", &state.imu.linear_acceleration, DATA_VECTOR3F },
        { "gps", "lat", &state.gps.lat, DATA_DOUBLE },
        { "gps", "lon", &state.gps.lon, DATA_DOUBLE },
        { "gps", "alt", &state.gps.alt, DATA_DOUBLE },
        { "pose", "roll",  &state.pose.roll, DATA_FLOAT },
        { "pose", "pitch", &state.pose.pitch, DATA_FLOAT },
        { "pose", "yaw",   &state.pose.yaw, DATA_FLOAT },
        { "velocity", "world_linear_velocity", &state.velocity.world_linear_velocity, DATA_VECTOR3F },
        { "lidar", "point_cloud", &state.lidar.points, DATA_VECTOR3F_ARRAY },
        { "rc", "channels", &state.rc.rc_channels, DATA_FLOAT_ARRAY },
        { "rng", "distances", &state.rng.rng_distances, DATA_FLOAT_ARRAY },
    };
};

}

#endif  // HAL_SIM_AIRSIM_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   /*
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
/*
  parent class for aircraft simulators
*/

#include "SIM_Aircraft.h"

#include <stdio.h>
#include <sys/time.h>
#include <unistd.h>

#include <GCS_MAVLink/GCS.h>
#include <AP_Logger/AP_Logger.h>
#include <AP_Param/AP_Param.h>
#include <AP_Declination/AP_Declination.h>
#include <AP_Terrain/AP_Terrain.h>
#include <AP_Scheduler/AP_Scheduler.h>
#include <AP_BoardConfig/AP_BoardConfig.h>
#include <AP_JSON/AP_JSON.h>
#include <AP_Filesystem/AP_Filesystem.h>
#include <AP_AHRS/AP_AHRS.h>
#include <AP_HAL_SITL/HAL_SITL_Class.h>

using namespace SITL;

extern const AP_HAL::HAL& hal;

// the SITL HAL can add information about pausing the simulation and its effect on the UART.  Not present when we're compiling for simulation-on-hardware
#if CONFIG_HAL_BOARD == HAL_BOARD_SITL
extern const HAL_SITL& hal_sitl;
#endif

/*
  parent class for all simulator types
 */

Aircraft::Aircraft(const char *frame_str) :
    frame(frame_str)
{
    // make the SIM_* variables available to simulator backends
    sitl = AP::sitl();

    set_speedup(1.0f);

    last_wall_time_us = get_wall_time_us();

    // allow for orientation settings, such as with tailsitters
    enum ap_var_type ptype;
    ahrs_orientation = (AP_Int8 *)AP_Param::find("AHRS_ORIENTATION", &ptype);

    // ahrs_orientation->get() returns ROTATION_NONE here, regardless of the actual value
    enum Rotation imu_rotation = ahrs_orientation?(enum Rotation)ahrs_orientation->get():ROTATION_NONE;
    last_imu_rotation = imu_rotation;
    // sitl is null if running example program
    if (sitl) {
        sitl->ahrs_rotation.from_rotation(imu_rotation);
        sitl->ahrs_rotation_inv = sitl->ahrs_rotation.transposed();
    }

    // init rangefinder array to NaN to signify no data
    for (uint8_t i = 0; i < ARRAY_SIZE(rangefinder_m); i++){
        rangefinder_m[i] = nanf("");
    }
}

void Aircraft::set_start_location(const Location &start_loc, const float start_yaw)
{
    home = start_loc;
    origin = home;
    position.xy().zero();
    home_yaw = start_yaw;
    home_is_set = true;

    ::printf("Home: %f %f alt=%fm hdg=%f\n",
             home.lat*1e-7,
             home.lng*1e-7,
             home.alt*0.01,
             home_yaw);

    location = home;
    ground_level = home.alt * 0.01f;

#if 0
    // useful test for home position being very different from origin
    home.offset(-3000*1000, 1800*1000);
#endif

    dcm.from_euler(0.0f, 0.0f, radians(home_yaw));
}

/*
   return difference in altitude between home position and current loc
*/
float Aircraft::ground_height_difference() const
{
#if AP_TERRAIN_AVAILABLE
    AP_Terrain *terrain = AP::terrain();
    float h1, h2;
    if (sitl &&
        terrain != nullptr &&
        sitl->terrain_enable &&
        terrain->height_amsl(home, h1, false) &&
        terrain->height_amsl(location, h2, false)) {
        h2 += local_ground_level;
        return h2 - h1;
    }
#endif
    return local_ground_level;
}

void Aircraft::set_precland(SIM_Precland *_precland) {
    precland = _precland;
    precland->set_default_location(home.lat * 1.0e-7f, home.lng * 1.0e-7f, static_cast<int16_t>(get_home_yaw()));
}

/*
   return current height above ground level (metres)
*/
float Aircraft::hagl() const
{
    return (-position.z) + home.alt * 0.01f - ground_level - frame_height - ground_height_difference();
}

/*
   return true if we are on the ground
*/
bool Aircraft::on_ground() const
{
    return hagl() <= 0.001f;  // prevent bouncing around ground
}

/*
   update location from position
*/
void Aircraft::update_position(void)
{
    location = origin;
    location.offset(position.x, position.y);

    location.alt  = static_cast<int32_t>(home.alt - position.z * 100.0f);

#if 0
    Vector3d pos_home = position;
    pos_home.xy() += home.get_distance_NE_double(origin);

    // logging of raw sitl data
    Vector3f accel_ef = dcm * accel_body;
// @LoggerMessage: SITL
// @Description: Simulation data
// @Field: TimeUS: Time since system startup
// @Field: VN: Velocity - North component
// @Field: VE: Velocity - East component
// @Field: VD: Velocity - Down component
// @Field: AN: Acceleration - North component
// @Field: AE: Acceleration - East component
// @Field: AD: Acceleration - Down component
// @Field: PN: Position - North component
// @Field: PE: Position - East component
// @Field: PD: Position - Down component
    AP::logger().WriteStreaming("SITL", "TimeUS,VN,VE,VD,AN,AE,AD,PN,PE,PD", "Qfffffffff",
                                           AP_HAL::micros64(),
                                           velocity_ef.x, velocity_ef.y, velocity_ef.z,
                                           accel_ef.x, accel_ef.y, accel_ef.z,
                                           pos_home.x, pos_home.y, pos_home.z);
#endif

    if (!disable_origin_movement) {
        uint32_t now = AP_HAL::millis();
        if (now - last_one_hz_ms >= 1000) {
            // shift origin of position at 1Hz to current location
            // this prevents spherical errors building up in the GPS data
            last_one_hz_ms = now;
            Vector2d diffNE = origin.get_distance_NE_double(location);
            position.xy() -= diffNE;
            smoothing.position.xy() -= diffNE;
            origin.lat = location.lat;
            origin.lng = location.lng;
        }
    }
}

/*
   update body magnetic field from position and rotation
*/
void Aircraft::update_mag_field_bf()
{
    // get the magnetic field intensity and orientation
    float intensity;
    float declination;
    float inclination;
    AP_Declination::get_mag_field_ef(location.lat * 1e-7f, location.lng * 1e-7f, intensity, declination, inclination);

    // create a field vector and rotate to the required orientation
    Vector3f mag_ef(1e3f * intensity, 0.0f, 0.0f);
    Matrix3f R;
    R.from_euler(0.0f, -ToRad(inclination), ToRad(declination));
    mag_ef = R * mag_ef;

    // calculate frame height above ground
    const float frame_height_agl = fmaxf((-position.z) + home.alt * 0.01f - ground_level, 0.0f);

    if (!sitl) {
        // running example program
        return;
    }

    // calculate scaling factor that varies from 1 at ground level to 1/8 at sitl->mag_anomaly_hgt
    // Assume magnetic anomaly strength scales with 1/R**3
    float anomaly_scaler = (sitl->mag_anomaly_hgt / (frame_height_agl + sitl->mag_anomaly_hgt));
    anomaly_scaler = anomaly_scaler * anomaly_scaler * anomaly_scaler;

    // add scaled anomaly to earth field
    mag_ef += sitl->mag_anomaly_ned.get() * anomaly_scaler;

    // Rotate into body frame
    mag_bf = dcm.transposed() * mag_ef;

    // add motor interference
    mag_bf += sitl->mag_mot.get() * battery_current;
}

/* advance time by deltat in seconds */
void Aircraft::time_advance()
{
    // we only advance time if it hasn't been advanced already by the
    // backend
    if (last_time_us == time_now_us) {
        time_now_us += frame_time_us;
    }
    last_time_us = time_now_us;
    if (use_time_sync) {
        sync_frame_time();
    }
}

/* setup the frame step time */
void Aircraft::setup_frame_time(float new_rate, float new_speedup)
{
    rate_hz = new_rate;
    target_speedup = new_speedup;
    frame_time_us = uint64_t(1.0e6f/rate_hz);

    last_wall_time_us = get_wall_time_us();
}

/* adjust frame_time calculation */
void Aircraft::adjust_frame_time(float new_rate)
{
    frame_time_us = uint64_t(1.0e6f/new_rate);
    rate_hz = new_rate;
}

/*
   try to synchronise simulation time with wall clock time, taking
   into account desired speedup
   This tries to take account of possible granularity of
   get_wall_time_us() so it works reasonably well on windows
*/
void Aircraft::sync_frame_time(void)
{
    frame_counter++;
    uint64_t now = get_wall_time_us();
    uint64_t dt_us = now - last_wall_time_us;

    const float target_dt_us = 1.0e6/(rate_hz*target_speedup);

    // accumulate sleep debt if we're running too fast
    sleep_debt_us += target_dt_us - dt_us;

    if (sleep_debt_us < -1.0e5) {
        // don't let a large negative debt build up
        sleep_debt_us = -1.0e5;
    }
    if (sleep_debt_us > min_sleep_time) {
        // sleep if we have built up a debt of min_sleep_tim
#if CONFIG_HAL_BOARD == HAL_BOARD_SITL
        usleep(sleep_debt_us);
#elif CONFIG_HAL_BOARD == HAL_BOARD_CHIBIOS
        hal.scheduler->delay_microseconds(sleep_debt_us);
#else
        // ??
#endif
        sleep_debt_us -= (get_wall_time_us() - now);
    }
    last_wall_time_us = get_wall_time_us();

    uint32_t now_ms = last_wall_time_us / 1000ULL;
    float dt_wall = (now_ms - last_fps_report_ms) * 0.001;
    if (dt_wall > 0.01) {  // 0.01s average
        achieved_rate_hz = (frame_counter - last_frame_count) / dt_wall;
#if 0
        ::printf("Rate: target:%.1f achieved:%.1f speedup %.1f/%.1f\n",
                 rate_hz*target_speedup, achieved_rate_hz,
                 achieved_rate_hz/rate_hz, target_speedup);
#endif
        last_frame_count = frame_counter;
        last_fps_report_ms = now_ms;
    }
}

/* add noise based on throttle level (from 0..1) */
void Aircraft::add_noise(float throttle)
{
    gyro += Vector3f(rand_normal(0, 1),
                     rand_normal(0, 1),
                     rand_normal(0, 1)) * gyro_noise * fabsf(throttle);
    accel_body += Vector3f(rand_normal(0, 1),
                           rand_normal(0, 1),
                           rand_normal(0, 1)) * accel_noise * fabsf(throttle);
}

/*
  normal distribution random numbers
  See
  http://en.literateprograms.org/index.php?title=Special:DownloadCode/Box-Muller_transform_%28C%29&oldid=7011
*/
double Aircraft::rand_normal(double mean, double stddev)
{
    static double n2 = 0.0;
    static int n2_cached = 0;
    if (!n2_cached) {
        double x, y, r;
        do
        {
            x = 2.0 * rand()/RAND_MAX - 1;
            y = 2.0 * rand()/RAND_MAX - 1;
            r = x*x + y*y;
        } while (is_zero(r) || r > 1.0);
        const double d = sqrt(-2.0 * log(r)/r);
        const double n1 = x * d;
        n2 = y * d;
        const double result = n1 * stddev + mean;
        n2_cached = 1;
        return result;
    } else {
        n2_cached = 0;
        return n2 * stddev + mean;
    }
}




/*
   fill a sitl_fdm structure from the simulator state
*/
void Aircraft::fill_fdm(struct sitl_fdm &fdm)
{
    bool is_smoothed = false;
    if (use_smoothing) {
        smooth_sensors();
        is_smoothed = true;
    }
    fdm.timestamp_us = time_now_us;
    if (fdm.home.lat == 0 && fdm.home.lng == 0) {
        // initialise home
        fdm.home = home;
    }
    fdm.is_lock_step_scheduled = lock_step_scheduled;
    fdm.latitude  = location.lat * 1.0e-7;
    fdm.longitude = location.lng * 1.0e-7;
    fdm.altitude  = location.alt * 1.0e-2;
    fdm.heading   = degrees(atan2f(velocity_ef.y, velocity_ef.x));
    fdm.speedN    = velocity_ef.x;
    fdm.speedE    = velocity_ef.y;
    fdm.speedD    = velocity_ef.z;
    fdm.xAccel    = accel_body.x;
    fdm.yAccel    = accel_body.y;
    fdm.zAccel    = accel_body.z;
    fdm.rollRate  = degrees(gyro.x);
    fdm.pitchRate = degrees(gyro.y);
    fdm.yawRate   = degrees(gyro.z);
    float r, p, y;
    dcm.to_euler(&r, &p, &y);
    fdm.rollDeg  = degrees(r);
    fdm.pitchDeg = degrees(p);
    fdm.yawDeg   = degrees(y);
    fdm.quaternion.from_rotation_matrix(dcm);
    fdm.airspeed = airspeed_pitot;
    fdm.velocity_air_bf = velocity_air_bf;
    fdm.battery_voltage = battery_voltage;
    fdm.battery_current = battery_current;
    fdm.motor_mask = motor_mask | sitl->vibe_motor_mask;
    memcpy(fdm.rpm, rpm, sizeof(fdm.rpm));
    fdm.rcin_chan_count = rcin_chan_count;
    fdm.range = rangefinder_range();
    memcpy(fdm.rcin, rcin, rcin_chan_count * sizeof(float));
    fdm.bodyMagField = mag_bf;

    // copy laser scanner results
    fdm.scanner.points = scanner.points;
    fdm.scanner.ranges = scanner.ranges;

    // copy rangefinder
    memcpy(fdm.rangefinder_m, rangefinder_m, sizeof(fdm.rangefinder_m));

    fdm.wind_vane_apparent.direction = wind_vane_apparent.direction;
    fdm.wind_vane_apparent.speed = wind_vane_apparent.speed;

    fdm.wind_ef = wind_ef;

    if (is_smoothed) {
        fdm.xAccel = smoothing.accel_body.x;
        fdm.yAccel = smoothing.accel_body.y;
        fdm.zAccel = smoothing.accel_body.z;
        fdm.rollRate  = degrees(smoothing.gyro.x);
        fdm.pitchRate = degrees(smoothing.gyro.y);
        fdm.yawRate   = degrees(smoothing.gyro.z);
        fdm.speedN    = smoothing.velocity_ef.x;
        fdm.speedE    = smoothing.velocity_ef.y;
        fdm.speedD    = smoothing.velocity_ef.z;
        fdm.latitude  = smoothing.location.lat * 1.0e-7;
        fdm.longitude = smoothing.location.lng * 1.0e-7;
        fdm.altitude  = smoothing.location.alt * 1.0e-2;
    }


    if (ahrs_orientation != nullptr) {
        enum Rotation imu_rotation = (enum Rotation)ahrs_orientation->get();
        if (imu_rotation != last_imu_rotation) {
            sitl->ahrs_rotation.from_rotation(imu_rotation);
            sitl->ahrs_rotation_inv = sitl->ahrs_rotation.transposed();
            last_imu_rotation = imu_rotation;
        }
        if (imu_rotation != ROTATION_NONE) {
            Matrix3f m = dcm;
            m = m * sitl->ahrs_rotation_inv;

            m.to_euler(&r, &p, &y);
            fdm.rollDeg  = degrees(r);
            fdm.pitchDeg = degrees(p);
            fdm.yawDeg   = degrees(y);
            fdm.quaternion.from_rotation_matrix(m);
        }
    }

    // in the first call here, if a speedup option is specified, overwrite it
    if (is_equal(last_speedup, -1.0f) && !is_equal(get_speedup(), 1.0f)) {
        sitl->speedup.set(get_speedup());
    }
    
    if (!is_equal(last_speedup, float(sitl->speedup)) && sitl->speedup > 0) {
        set_speedup(sitl->speedup);
        last_speedup = sitl->speedup;
    }

#if HAL_LOGGING_ENABLED
#if CONFIG_HAL_BOARD == HAL_BOARD_SITL
    // the SITL HAL can add information about pausing the simulation
    // and its effect on the UART.  Not present when we're compiling
    // for simulation-on-hardware
    const uint32_t full_count = hal_sitl.get_uart_output_full_queue_count();
#else
    const uint32_t full_count = 0;
#endif
    // for EKF comparison log relhome pos and velocity at loop rate
    static uint16_t last_ticks;
    uint16_t ticks = AP::scheduler().ticks();
    if (last_ticks != ticks) {
        last_ticks = ticks;
// @LoggerMessage: SIM2
// @Description: Additional simulator state
// @Field: TimeUS: Time since system startup
// @Field: PN: North position from home
// @Field: PE: East position from home
// @Field: PD: Down position from home
// @Field: VN: Velocity north
// @Field: VE: Velocity east
// @Field: VD: Velocity down
// @Field: As: Airspeed
// @Field: ASpdU: Achieved simulation speedup value
// @Field: UFC: Number of times simulation paused for serial0 output
        Vector3d pos = get_position_relhome();
        Vector3f vel = get_velocity_ef();
        AP::logger().WriteStreaming(
            "SIM2",
            "TimeUS,PN,PE,PD,VN,VE,VD,As,ASpdU,UFC",
            "QdddfffffI",
            AP_HAL::micros64(),
            pos.x, pos.y, pos.z,
            vel.x, vel.y, vel.z,
            airspeed_pitot,
            achieved_rate_hz/rate_hz,
            full_count
        );
    }
#endif
}

// returns perpendicular height to surface downward-facing rangefinder
// is bouncing off:
float Aircraft::perpendicular_distance_to_rangefinder_surface() const
{
    switch ((Rotation)sitl->sonar_rot.get()) {
    case Rotation::ROTATION_PITCH_270:
        return sitl->state.height_agl;
    case ROTATION_NONE ... ROTATION_YAW_315:
        return sitl->measure_distance_at_angle_bf(location, sitl->sonar_rot.get()*45);
    default:
        AP_BoardConfig::config_error("Bad simulated sonar rotation");
    }
}

float Aircraft::rangefinder_range() const
{

    float roll = sitl->state.rollDeg;
    float pitch = sitl->state.pitchDeg;

    if (roll > 0) {
        roll -= rangefinder_beam_width();
        if (roll < 0) {
            roll = 0;
        }
    } else {
        roll += rangefinder_beam_width();
        if (roll > 0) {
            roll = 0;
        }
    }
    if (pitch > 0) {
        pitch -= rangefinder_beam_width();
        if (pitch < 0) {
            pitch = 0;
        }
    } else {
        pitch += rangefinder_beam_width();
        if (pitch > 0) {
            pitch = 0;
        }
    }

    if (fabs(roll) >= 90.0 || fabs(pitch) >= 90.0) {
        // not going to hit the ground....
        return INFINITY;
    }

    float altitude = perpendicular_distance_to_rangefinder_surface();

    // sensor position offset in body frame
    const Vector3f relPosSensorBF = sitl->rngfnd_pos_offset;

    // n.b. the following code is assuming rotation-pitch-270:
    // adjust altitude for position of the sensor on the vehicle if position offset is non-zero
    if (!relPosSensorBF.is_zero()) {
        // get a rotation matrix following DCM conventions (body to earth)
        Matrix3f rotmat;
        sitl->state.quaternion.rotation_matrix(rotmat);
        // rotate the offset into earth frame
        const Vector3f relPosSensorEF = rotmat * relPosSensorBF;
        // correct the altitude at the sensor
        altitude -= relPosSensorEF.z;
    }

    // adjust for apparent altitude with roll
    altitude /= cosf(radians(roll)) * cosf(radians(pitch));

    // Add some noise on reading
    altitude += sitl->sonar_noise * rand_float();

    return altitude;
}

#if defined(__CYGWIN__) || defined(__CYGWIN64__)
extern "C" { uint32_t timeGetTime(); }
#endif

// potentially replace this with a call to AP_HAL::Util::get_hw_rtc
uint64_t Aircraft::get_wall_time_us() const
{
#if defined(__CYGWIN__) || defined(__CYGWIN64__)
    static uint32_t tPrev;
    static uint64_t last_ret_us;
    if (tPrev == 0) {
        tPrev = timeGetTime();
        return 0;
    }
    uint32_t now = timeGetTime();
    last_ret_us += (uint64_t)((now - tPrev)*1000UL);
    tPrev = now;
    return last_ret_us;
#elif CONFIG_HAL_BOARD == HAL_BOARD_SITL
    struct timespec ts;
    clock_gettime(CLOCK_MONOTONIC, &ts);
    return uint64_t(ts.tv_sec * 1000000ULL + ts.tv_nsec / 1000ULL);
#else
    return AP_HAL::micros64();
#endif
}

/*
  set simulation speedup
 */
void Aircraft::set_speedup(float speedup)
{
    setup_frame_time(rate_hz, speedup);
}

void Aircraft::update_home()
{
    if (!home_is_set) {
        if (sitl == nullptr) {
            return;
        }
        Location loc;
        loc.lat = sitl->opos.lat.get() * 1.0e7;
        loc.lng = sitl->opos.lng.get() * 1.0e7;
        loc.alt = sitl->opos.alt.get() * 1.0e2;
        set_start_location(loc, sitl->opos.hdg.get());
    }
}

void Aircraft::update_model(const struct sitl_input &input)
{
    local_ground_level = 0.0f;
    if (sitl != nullptr) {
        update(input);
    } else {
        time_advance();
    }
}

/*
  update the simulation attitude and relative position
 */
void Aircraft::update_dynamics(const Vector3f &rot_accel)
{
    // update eas2tas and air density
#if AP_AHRS_ENABLED
    eas2tas = AP::ahrs().get_EAS2TAS();
#endif
    air_density = SSL_AIR_DENSITY / sq(eas2tas);

    const float delta_time = frame_time_us * 1.0e-6f;

    // update eas2tas and air density
    eas2tas = AP_Baro::get_EAS2TAS_for_alt_amsl(location.alt*0.01);
    air_density = AP_Baro::get_air_density_for_alt_amsl(location.alt*0.01);

    // update rotational rates in body frame
    gyro += rot_accel * delta_time;

    gyro.x = constrain_float(gyro.x, -radians(2000.0f), radians(2000.0f));
    gyro.y = constrain_float(gyro.y, -radians(2000.0f), radians(2000.0f));
    gyro.z = constrain_float(gyro.z, -radians(2000.0f), radians(2000.0f));

    // limit body accel to 64G
    const float accel_limit = 64*GRAVITY_MSS;
    accel_body.x = constrain_float(accel_body.x, -accel_limit, accel_limit);
    accel_body.y = constrain_float(accel_body.y, -accel_limit, accel_limit);
    accel_body.z = constrain_float(accel_body.z, -accel_limit, accel_limit);

    // update attitude
    dcm.rotate(gyro * delta_time);
    dcm.normalize();

    Vector3f accel_earth = dcm * accel_body;
    accel_earth += Vector3f(0.0f, 0.0f, GRAVITY_MSS);

    // if we're on the ground, then our vertical acceleration is limited
    // to zero. This effectively adds the force of the ground on the aircraft
    if (on_ground() && accel_earth.z > 0) {
        accel_earth.z = 0;
    }

    // work out acceleration as seen by the accelerometers. It sees the kinematic
    // acceleration (ie. real movement), plus gravity
    accel_body = dcm.transposed() * (accel_earth + Vector3f(0.0f, 0.0f, -GRAVITY_MSS));

    // new velocity vector
    velocity_ef += accel_earth * delta_time;

    const bool was_on_ground = on_ground();
    // new position vector
    position += (velocity_ef * delta_time).todouble();

    // velocity relative to air mass, in earth frame
    velocity_air_ef = velocity_ef - wind_ef;

    // velocity relative to airmass in body frame
    velocity_air_bf = dcm.transposed() * velocity_air_ef;

    // airspeed
    update_eas_airspeed();

    // constrain height to the ground
    if (on_ground()) {
        if (!was_on_ground && AP_HAL::millis() - last_ground_contact_ms > 1000) {
            GCS_SEND_TEXT(MAV_SEVERITY_INFO, "SIM Hit ground at %f m/s", velocity_ef.z);
            last_ground_contact_ms = AP_HAL::millis();
        }
        position.z = -(ground_level + frame_height - home.alt * 0.01f + ground_height_difference());

        // get speed of ground movement (for ship takeoff/landing)
        float yaw_rate = 0;
#if AP_SIM_SHIP_ENABLED
        const Vector2f ship_movement = sitl->models.shipsim.get_ground_speed_adjustment(location, yaw_rate);
        const Vector3f gnd_movement(ship_movement.x, ship_movement.y, 0);
#else
        const Vector3f gnd_movement;
#endif
        switch (ground_behavior) {
        case GROUND_BEHAVIOR_NONE:
            break;
        case GROUND_BEHAVIOR_NO_MOVEMENT: {
            // zero roll/pitch, but keep yaw
            float r, p, y;
            dcm.to_euler(&r, &p, &y);
            y = y + yaw_rate * delta_time;
            dcm.from_euler(0.0f, 0.0f, y);
            // X, Y movement tracks ground movement
            velocity_ef.x = gnd_movement.x;
            velocity_ef.y = gnd_movement.y;
            if (velocity_ef.z > 0.0f) {
                velocity_ef.z = 0.0f;
            }
            gyro.zero();
            use_smoothing = true;
            break;
        }
        case GROUND_BEHAVIOR_FWD_ONLY: {
            // zero roll/pitch, but keep yaw
            float r, p, y;
            dcm.to_euler(&r, &p, &y);
            if (velocity_ef.length() < 5) {
                // at high speeds don't constrain pitch, otherwise we
                // can get stuck in takeoff
                p = 0;
            } else {
                p = MAX(p, 0);
            }
            y = y + yaw_rate * delta_time;
            dcm.from_euler(0.0f, p, y);
            // only fwd movement
            Vector3f v_bf = dcm.transposed() * velocity_ef;
            v_bf.y = 0.0f;
            if (v_bf.x < 0.0f) {
                v_bf.x = 0.0f;
            }

            Vector3f gnd_movement_bf = dcm.transposed() * gnd_movement;

            // lateral speed equals ground movement
            v_bf.y = gnd_movement_bf.y;

            if (!gnd_movement_bf.is_zero()) {
                // fwd speed slowly approaches ground movement to simulate wheel friction
                const float tconst = 20; // seconds
                const float alpha = delta_time/(delta_time+tconst/M_2PI);
                v_bf.x += (gnd_movement.x - v_bf.x) * alpha;
            }

            velocity_ef = dcm * v_bf;
            if (velocity_ef.z > 0.0f) {
                velocity_ef.z = 0.0f;
            }
            gyro.zero();
            gyro.z = yaw_rate;
            use_smoothing = true;
            break;
        }
        case GROUND_BEHAVIOR_TAILSITTER: {
            // rotate normal refernce frame to get yaw angle, then rotate back
            Matrix3f rot;
            rot.from_rotation(ROTATION_PITCH_270);
            float r, p, y;
            (dcm * rot).to_euler(&r, &p, &y);
            y = y + yaw_rate * delta_time;
            dcm.from_euler(0.0, 0.0, y);
            rot.from_rotation(ROTATION_PITCH_90);
            dcm *= rot;
            // X, Y movement tracks ground movement
            velocity_ef.x = gnd_movement.x;
            velocity_ef.y = gnd_movement.y;
            if (velocity_ef.z > 0.0f) {
                velocity_ef.z = 0.0f;
            }
            gyro.zero();
            gyro.x = yaw_rate;
            use_smoothing = true;
            break;
        }
        }
    }

    // update slung payload
#if AP_SIM_SLUNGPAYLOAD_ENABLED
    sitl->models.slung_payload_sim.update(get_position_relhome(), velocity_ef, accel_earth);
#endif

    // allow for changes in physics step
    adjust_frame_time(constrain_float(sitl->loop_rate_hz, rate_hz-1, rate_hz+1));
}

/*
  update wind vector
*/
void Aircraft::update_wind(const struct sitl_input &input)
{
    // wind vector in earth frame
    wind_ef = Vector3f(cosf(radians(input.wind.direction))*cosf(radians(input.wind.dir_z)), 
                       sinf(radians(input.wind.direction))*cosf(radians(input.wind.dir_z)), 
                       sinf(radians(input.wind.dir_z))) * input.wind.speed;

    wind_ef.z += get_local_updraft(position + home.get_distance_NED_double(origin));

    const float wind_turb = input.wind.turbulence * 10.0f;  // scale input.wind.turbulence to match standard deviation when using iir_coef=0.98
    const float iir_coef = 0.98f;  // filtering high frequencies from turbulence

    if (wind_turb > 0 && !on_ground()) {

        turbulence_azimuth = turbulence_azimuth + (2 * rand());

        turbulence_horizontal_speed =
                static_cast<float>(turbulence_horizontal_speed * iir_coef+wind_turb * rand_normal(0, 1) * (1 - iir_coef));

        turbulence_vertical_speed = static_cast<float>((turbulence_vertical_speed * iir_coef) + (wind_turb * rand_normal(0, 1) * (1 - iir_coef)));

        wind_ef += Vector3f(
            cosf(radians(turbulence_azimuth)) * turbulence_horizontal_speed,
            sinf(radians(turbulence_azimuth)) * turbulence_horizontal_speed,
            turbulence_vertical_speed);
    }

    // the AHRS wants wind with opposite sense
    wind_ef = -wind_ef;
}

/*
  smooth sensors for kinematic consistancy when we interact with the ground
 */
void Aircraft::smooth_sensors(void)
{
    uint64_t now = time_now_us;
    Vector3d delta_pos = position - smoothing.position;
    if (smoothing.last_update_us == 0 || delta_pos.length() > 10) {
        smoothing.position = position;
        smoothing.rotation_b2e = dcm;
        smoothing.accel_body = accel_body;
        smoothing.velocity_ef = velocity_ef;
        smoothing.gyro = gyro;
        smoothing.last_update_us = now;
        smoothing.location = location;
        printf("Smoothing reset at %.3f\n", now * 1.0e-6f);
        return;
    }
    const float delta_time = (now - smoothing.last_update_us) * 1.0e-6f;
    if (delta_time < 0 || delta_time > 0.1) {
        return;
    }

    // calculate required accel to get us to desired position and velocity in the time_constant
    const float time_constant = 0.1f;
    Vector3f dvel = (velocity_ef - smoothing.velocity_ef) + (delta_pos / time_constant).tofloat();
    Vector3f accel_e = dvel / time_constant + (dcm * accel_body + Vector3f(0.0f, 0.0f, GRAVITY_MSS));
    const float accel_limit = 14 * GRAVITY_MSS;
    accel_e.x = constrain_float(accel_e.x, -accel_limit, accel_limit);
    accel_e.y = constrain_float(accel_e.y, -accel_limit, accel_limit);
    accel_e.z = constrain_float(accel_e.z, -accel_limit, accel_limit);
    smoothing.accel_body = smoothing.rotation_b2e.transposed() * (accel_e + Vector3f(0.0f, 0.0f, -GRAVITY_MSS));

    // calculate rotational rate to get us to desired attitude in time constant
    Quaternion desired_q, current_q, error_q;
    desired_q.from_rotation_matrix(dcm);
    desired_q.normalize();
    current_q.from_rotation_matrix(smoothing.rotation_b2e);
    current_q.normalize();
    error_q = desired_q / current_q;
    error_q.normalize();

    Vector3f angle_differential;
    error_q.to_axis_angle(angle_differential);
    smoothing.gyro = gyro + angle_differential / time_constant;

    float R, P, Y;
    smoothing.rotation_b2e.to_euler(&R, &P, &Y);
    float R2, P2, Y2;
    dcm.to_euler(&R2, &P2, &Y2);

#if 0
// @LoggerMessage: SMOO
// @Description: Smoothed sensor data fed to EKF to avoid inconsistencies
// @Field: TimeUS: Time since system startup
// @Field: AEx: Angular Velocity (around x-axis)
// @Field: AEy: Angular Velocity (around y-axis)
// @Field: AEz: Angular Velocity (around z-axis)
// @Field: DPx: Velocity (along x-axis)
// @Field: DPy: Velocity (along y-axis)
// @Field: DPz: Velocity (along z-axis)
// @Field: R: Roll
// @Field: P: Pitch
// @Field: Y: Yaw
// @Field: R2: DCM Roll
// @Field: P2: DCM Pitch
// @Field: Y2: DCM Yaw
    AP::logger().WriteStreaming("SMOO", "TimeUS,AEx,AEy,AEz,DPx,DPy,DPz,R,P,Y,R2,P2,Y2",
                                           "Qffffffffffff",
                                           AP_HAL::micros64(),
                                           degrees(angle_differential.x),
                                           degrees(angle_differential.y),
                                           degrees(angle_differential.z),
                                           delta_pos.x, delta_pos.y, delta_pos.z,
                                           degrees(R), degrees(P), degrees(Y),
                                           degrees(R2), degrees(P2), degrees(Y2));
#endif


    // integrate to get new attitude
    smoothing.rotation_b2e.rotate(smoothing.gyro * delta_time);
    smoothing.rotation_b2e.normalize();

    // integrate to get new position
    smoothing.velocity_ef += accel_e * delta_time;
    smoothing.position += (smoothing.velocity_ef * delta_time).todouble();

    smoothing.location = origin;
    smoothing.location.offset(smoothing.position.x, smoothing.position.y);
    smoothing.location.alt  = static_cast<int32_t>(home.alt - smoothing.position.z * 100.0f);

    smoothing.last_update_us = now;
}

/*
  return a filtered servo input as a value from -1 to 1
  servo is assumed to be 1000 to 2000, trim at 1500
 */
float Aircraft::filtered_servo_angle(const struct sitl_input &input, uint8_t idx)
{
    return servo_filter[idx].filter_angle(input.servos[idx], frame_time_us * 1.0e-6);
}

/*
  return a filtered servo input as a value from 0 to 1
  servo is assumed to be 1000 to 2000
 */
float Aircraft::filtered_servo_range(const struct sitl_input &input, uint8_t idx)
{
    return servo_filter[idx].filter_range(input.servos[idx], frame_time_us * 1.0e-6);
}

// setup filtering for servo
void Aircraft::filtered_servo_setup(uint8_t idx, uint16_t pwm_min, uint16_t pwm_max, float deflection_deg)
{
    servo_filter[idx].set_pwm_range(pwm_min, pwm_max);
    servo_filter[idx].set_deflection(deflection_deg);
}

// extrapolate sensors by a given delta time in seconds
void Aircraft::extrapolate_sensors(float delta_time)
{
    Vector3f accel_earth = dcm * accel_body;
    accel_earth.z += GRAVITY_MSS;

    dcm.rotate(gyro * delta_time);
    dcm.normalize();

    // work out acceleration as seen by the accelerometers. It sees the kinematic
    // acceleration (ie. real movement), plus gravity
    accel_body = dcm.transposed() * (accel_earth + Vector3f(0,0,-GRAVITY_MSS));

    // new velocity and position vectors
    velocity_ef += accel_earth * delta_time;
    position += (velocity_ef * delta_time).todouble();
    velocity_air_ef = velocity_ef - wind_ef;
    velocity_air_bf = dcm.transposed() * velocity_air_ef;
}

bool Aircraft::Clamp::clamped(Aircraft &aircraft, const struct sitl_input &input)
{
    const auto clamp_ch = AP::sitl()->clamp_ch;
    if (clamp_ch < 1) {
        return false;
    }
    const uint32_t clamp_idx = clamp_ch - 1;
    if (clamp_idx > ARRAY_/*
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
/*
  balloon simulator class
*/

#pragma once

#include "SIM_Aircraft.h"

namespace SITL {

/*
  a balloon simulator
 */
class Balloon : public Aircraft {
public:
    Balloon(const char *frame_str);

    /* update model by one time step */
    void update(const struct sitl_input &input) override;

    /* static object creator */
    static Aircraft *create(const char *frame_str) {
        return NEW_NOTHROW Balloon(frame_str);
    }

private:
    float terminal_rotation_rate = radians(100);
    float climb_rate = 20;
    float terminal_velocity = 40;
    float burst_altitude = 20000;
    bool burst = false;
    bool released = false;
};

} // namespace SITL
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             #include "SIM_config.h"

#if AP_SIM_GPS_SBF_ENABLED

#include "SIM_GPS_SBF.h"

#include <SITL/SITL.h>
#include <time.h>

using namespace SITL;

static const uint16_t CRC16_LOOK_UP[256] = {
    0x0000, 0x1021, 0x2042, 0x3063, 0x4084, 0x50a5, 0x60c6, 0x70e7, 0x8108, 0x9129,
    0xa14a, 0xb16b, 0xc18c, 0xd1ad, 0xe1ce, 0xf1ef, 0x1231, 0x0210, 0x3273, 0x2252,
    0x52b5, 0x4294, 0x72f7, 0x62d6, 0x9339, 0x8318, 0xb37b, 0xa35a, 0xd3bd, 0xc39c,
    0xf3ff, 0xe3de, 0x2462, 0x3443, 0x0420, 0x1401, 0x64e6, 0x74c7, 0x44a4, 0x5485,
    0xa56a, 0xb54b, 0x8528, 0x9509, 0xe5ee, 0xf5cf, 0xc5ac, 0xd58d, 0x3653, 0x2672,
    0x1611, 0x0630, 0x76d7, 0x66f6, 0x5695, 0x46b4, 0xb75b, 0xa77a, 0x9719, 0x8738,
    0xf7df, 0xe7fe, 0xd79d, 0xc7bc, 0x48c4, 0x58e5, 0x6886, 0x78a7, 0x0840, 0x1861,
    0x2802, 0x3823, 0xc9cc, 0xd9ed, 0xe98e, 0xf9af, 0x8948, 0x9969, 0xa90a, 0xb92b,
    0x5af5, 0x4ad4, 0x7ab7, 0x6a96, 0x1a71, 0x0a50, 0x3a33, 0x2a12, 0xdbfd, 0xcbdc,
    0xfbbf, 0xeb9e, 0x9b79, 0x8b58, 0xbb3b, 0xab1a, 0x6ca6, 0x7c87, 0x4ce4, 0x5cc5,
    0x2c22, 0x3c03, 0x0c60, 0x1c41, 0xedae, 0xfd8f, 0xcdec, 0xddcd, 0xad2a, 0xbd0b,
    0x8d68, 0x9d49, 0x7e97, 0x6eb6, 0x5ed5, 0x4ef4, 0x3e13, 0x2e32, 0x1e51, 0x0e70,
    0xff9f, 0xefbe, 0xdfdd, 0xcffc, 0xbf1b, 0xaf3a, 0x9f59, 0x8f78, 0x9188, 0x81a9,
    0xb1ca, 0xa1eb, 0xd10c, 0xc12d, 0xf14e, 0xe16f, 0x1080, 0x00a1, 0x30c2, 0x20e3,
    0x5004, 0x4025, 0x7046, 0x6067, 0x83b9, 0x9398, 0xa3fb, 0xb3da, 0xc33d, 0xd31c,
    0xe37f, 0xf35e, 0x02b1, 0x1290, 0x22f3, 0x32d2, 0x4235, 0x5214, 0x6277, 0x7256,
    0xb5ea, 0xa5cb, 0x95a8, 0x8589, 0xf56e, 0xe54f, 0xd52c, 0xc50d, 0x34e2, 0x24c3,
    0x14a0, 0x0481, 0x7466, 0x6447, 0x5424, 0x4405, 0xa7db, 0xb7fa, 0x8799, 0x97b8,
    0xe75f, 0xf77e, 0xc71d, 0xd73c, 0x26d3, 0x36f2, 0x0691, 0x16b0, 0x6657, 0x7676,
    0x4615, 0x5634, 0xd94c, 0xc96d, 0xf90e, 0xe92f, 0x99c8, 0x89e9, 0xb98a, 0xa9ab,
    0x5844, 0x4865, 0x7806, 0x6827, 0x18c0, 0x08e1, 0x3882, 0x28a3, 0xcb7d, 0xdb5c,
    0xeb3f, 0xfb1e, 0x8bf9, 0x9bd8, 0xabbb, 0xbb9a, 0x4a75, 0x5a54, 0x6a37, 0x7a16,
    0x0af1, 0x1ad0, 0x2ab3, 0x3a92, 0xfd2e, 0xed0f, 0xdd6c, 0xcd4d, 0xbdaa, 0xad8b,
    0x9de8, 0x8dc9, 0x7c26, 0x6c07, 0x5c64, 0x4c45, 0x3ca2, 0x2c83, 0x1ce0, 0x0cc1,
    0xef1f, 0xff3e, 0xcf5d, 0xdf7c, 0xaf9b, 0xbfba, 0x8fd9, 0x9ff8, 0x6e17, 0x7e36,
    0x4e55, 0x5e74, 0x2e93, 0x3eb2, 0x0ed1, 0x1ef0
};

void GPS_SBF::send_sbf(uint16_t msgid, uint8_t *buf, uint16_t size)
{
    if ((size % 4) != 0) {
        AP_HAL::panic("Invalid SBF packet length");
    }

    //HEADER
    const uint8_t PREAMBLE1 = 0x24;
    const uint8_t PREAMBLE2 = 0x40;
    uint8_t hdr[8];
    uint16_t crc = 0;
    hdr[0] = PREAMBLE1;
    hdr[1] = PREAMBLE2;
    hdr[4] = msgid & 0xFF;
    hdr[5] = (msgid >> 8) & 0xFF;
    hdr[6] = (size+8) & 0xFF;
    hdr[7] = ((size+8) >> 8) & 0xFF;
    for (uint8_t i = 4; i<8; i++) {
        crc = (crc << 8) ^ CRC16_LOOK_UP[uint8_t((crc >> 8) ^ hdr[i])]; //include id and length
    }
    for (uint16_t i = 0; i<size; i++) {
        crc = (crc << 8) ^ CRC16_LOOK_UP[uint8_t((crc >> 8) ^ buf[i])];
    }
    hdr[2] = crc & 0xFF;
    hdr[3] = (crc >> 8) & 0xFF;

    write_to_autopilot((char*)hdr, sizeof(hdr));
    write_to_autopilot((char*)buf, size);
}

void GPS_SBF::publish(const GPS_Data *d) {
    publish_PVTGeodetic(d);
    publish_DOP(d);
}

// public PVTGeodetic message, ID 4007
void GPS_SBF::publish_PVTGeodetic(const GPS_Data *d)
{
    const double DNU_DOUBLE = -2e10;
    const float DNU_FLOAT = -2e10;
    const uint8_t DNU_UINT8 = 255;
    const uint16_t DNU_UINT16 = 65535;

    struct PACKED timestamp_t {
        uint32_t tow;
        uint16_t wnc;
    };

    struct PACKED sbf_pvtGeod_t
    {
        timestamp_t time_stamp;
        uint8_t mode;
        uint8_t error;
        double latitude;
        double longitude;
        double height;
        float undulation;
        float vn;
        float ve;
        float vu;
        float cog;
        double rxclkbias;
        float rxclkdrift;
        uint8_t timesystem;
        uint8_t datum;
        uint8_t nrsv;
        uint8_t wacorrinfo;
        uint16_t referenceid;
        uint16_t meancorrage;
        uint64_t signalinfo;
        uint8_t alertflag;
        uint8_t __PADDING__[3];  // packets must be zero-mod-4
    } pvtGeod_buf {} ;
    assert_storage_size<sbf_pvtGeod_t, 84> assert_storage_size_pvt_Geod_buf;
    (void)assert_storage_size_pvt_Geod_buf;

    const uint16_t PVTGEO_0_MSG_ID = 0x0FA7;    

    const auto gps_tow = gps_time();
    pvtGeod_buf.time_stamp.tow = gps_tow.ms;
    pvtGeod_buf.time_stamp.wnc = gps_tow.week;
    
    pvtGeod_buf.mode = 4; //Mode: default to rtk fixed
    pvtGeod_buf.error= 0; //Error: no error
    pvtGeod_buf.latitude = radians(_sitl->state.latitude);
    pvtGeod_buf.longitude = radians(_sitl->state.longitude);
    pvtGeod_buf.height = d->altitude;
    pvtGeod_buf.undulation = DNU_DOUBLE;
    pvtGeod_buf.vn = d->speedN;
    pvtGeod_buf.ve = d->speedE;
    pvtGeod_buf.vu = -d->speedD;
    pvtGeod_buf.cog = degrees(d->ground_track_rad());
    pvtGeod_buf.rxclkbias = DNU_DOUBLE;
    pvtGeod_buf.rxclkdrift = DNU_FLOAT;
    pvtGeod_buf.timesystem = DNU_UINT8; 
    pvtGeod_buf.datum = DNU_UINT8; 
    pvtGeod_buf.nrsv = _sitl->gps_numsats[instance];
    pvtGeod_buf.wacorrinfo = 0; //default value
    pvtGeod_buf.referenceid = DNU_UINT16; 
    pvtGeod_buf.meancorrage = DNU_UINT16; 
    pvtGeod_buf.signalinfo = 0;
    pvtGeod_buf.alertflag = 0;

    send_sbf(PVTGEO_0_MSG_ID, (uint8_t*)&pvtGeod_buf, sizeof(pvtGeod_buf));
}

// public DOP message, ID 4001
void GPS_SBF::publish_DOP(const GPS_Data *d)
{
    struct PACKED timestamp_t {
        uint32_t tow;
        uint16_t wnc;
    };

    const auto gps_tow = gps_time();

    // swiped from the driver:
    const struct PACKED {
        timestamp_t time_stamp;
        uint8_t NrSV;
        uint8_t Reserved;
        uint16_t PDOP;
        uint16_t TDOP;
        uint16_t HDOP;
        uint16_t VDOP;
        float HPL;
        float VPL;
        // uint8_t __PADDING__[2];
    } packet {
        { gps_tow.ms, gps_tow.week },  // timestamp
        17,  // NrSV
        0,  // reserved
        1,  // PDOP
        1,  // TDOP
        1,  // HDOP
        1,  // VDOP
        1.0,  // HPL
        1.0  // VPL
    };

    send_sbf(4001, (uint8_t*)&packet, sizeof(packet));
}

#endif //AP_SIM_GPS_SBF_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    #pragma once

#include "SIM_config.h"

#if AP_SIM_GPS_SBF_ENABLED

#include "SIM_GPS.h"

namespace SITL {

class GPS_SBF : public GPS_Backend {
public:
    CLASS_NO_COPY(GPS_SBF);

    using GPS_Backend::GPS_Backend;

    void publish(const GPS_Data *d) override;

private:

    void send_sbf(uint16_t msgid, uint8_t *buf, uint16_t buf_size);
    void publish_PVTGeodetic(const GPS_Data *d);
    void publish_DOP(const GPS_Data *d);

};

};

#endif  // AP_SIM_GPS_SBF_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    #include "SIM_GPS_SBP.h"

#if AP_SIM_GPS_SBP_ENABLED

#include <SITL/SITL.h>

using namespace SITL;

void GPS_SBP::publish(const GPS_Data *d)
{
    struct sbp_heartbeat_t {
        bool sys_error : 1;
        bool io_error : 1;
        bool nap_error : 1;
        uint8_t res : 5;
        uint8_t protocol_minor : 8;
        uint8_t protocol_major : 8;
        uint8_t res2 : 7;
        bool ext_antenna : 1;
    } hb; // 4 bytes

    struct PACKED sbp_gps_time_t {
        uint16_t wn;   //< GPS week number
        uint32_t tow;  //< GPS Time of Week rounded to the nearest ms
        int32_t ns;    //< Nanosecond remainder of rounded tow
        uint8_t flags; //< Status flags (reserved)
    } t;
    struct PACKED sbp_pos_llh_t {
        uint32_t tow;        //< GPS Time of Week
        double lat;          //< Latitude
        double lon;          //< Longitude
        double height;       //< Height
        uint16_t h_accuracy; //< Horizontal position accuracy estimate
        uint16_t v_accuracy; //< Vertical position accuracy estimate
        uint8_t n_sats;      //< Number of satellites used in solution
        uint8_t flags;       //< Status flags
    } pos;
    struct PACKED sbp_vel_ned_t {
        uint32_t tow;        //< GPS Time of Week
        int32_t n;           //< Velocity North coordinate
        int32_t e;           //< Velocity East coordinate
        int32_t d;           //< Velocity Down coordinate
        uint16_t h_accuracy; //< Horizontal velocity accuracy estimate
        uint16_t v_accuracy; //< Vertical velocity accuracy estimate
        uint8_t n_sats;      //< Number of satellites used in solution
        uint8_t flags;       //< Status flags (reserved)
    } velned;
    struct PACKED sbp_dops_t {
        uint32_t tow;  //< GPS Time of Week
        uint16_t gdop; //< Geometric Dilution of Precision
        uint16_t pdop; //< Position Dilution of Precision
        uint16_t tdop; //< Time Dilution of Precision
        uint16_t hdop; //< Horizontal Dilution of Precision
        uint16_t vdop; //< Vertical Dilution of Precision
        uint8_t flags; //< Status flags (reserved)
    } dops;

    static const uint16_t SBP_HEARTBEAT_MSGTYPE = 0xFFFF;
    static const uint16_t SBP_GPS_TIME_MSGTYPE = 0x0100;
    static const uint16_t SBP_DOPS_MSGTYPE = 0x0206;
    static const uint16_t SBP_POS_LLH_MSGTYPE = 0x0201;
    static const uint16_t SBP_VEL_NED_MSGTYPE = 0x0205;

    const auto gps_tow = gps_time();

    t.wn = gps_tow.week;
    t.tow = gps_tow.ms;
    t.ns = 0;
    t.flags = 0;
    sbp_send_message(SBP_GPS_TIME_MSGTYPE, 0x2222, sizeof(t), (uint8_t*)&t);

    if (!d->have_lock) {
        return;
    }

    pos.tow = gps_tow.ms;
    pos.lon = d->longitude;
    pos.lat= d->latitude;
    pos.height = d->altitude;
    pos.h_accuracy = _sitl->gps_accuracy[instance]*1000;
    pos.v_accuracy = _sitl->gps_accuracy[instance]*1000;
    pos.n_sats = d->have_lock ? _sitl->gps_numsats[instance] : 3;

    // Send single point position solution
    pos.flags = 0;
    sbp_send_message(SBP_POS_LLH_MSGTYPE, 0x2222, sizeof(pos), (uint8_t*)&pos);
    // Send "pseudo-absolute" RTK position solution
    pos.flags = 1;
    sbp_send_message(SBP_POS_LLH_MSGTYPE, 0x2222, sizeof(pos), (uint8_t*)&pos);

    velned.tow = gps_tow.ms;
    velned.n = 1e3 * d->speedN;
    velned.e = 1e3 * d->speedE;
    velned.d = 1e3 * d->speedD;
    velned.h_accuracy = 5e3;
    velned.v_accuracy = 5e3;
    velned.n_sats = d->have_lock ? _sitl->gps_numsats[instance] : 3;
    velned.flags = 0;
    sbp_send_message(SBP_VEL_NED_MSGTYPE, 0x2222, sizeof(velned), (uint8_t*)&velned);

    static uint32_t do_every_count = 0;
    if (do_every_count % 5 == 0) {

        dops.tow = gps_tow.ms;
        dops.gdop = 1;
        dops.pdop = 1;
        dops.tdop = 1;
        dops.hdop = 100;
        dops.vdop = 1;
        dops.flags = 1;
        sbp_send_message(SBP_DOPS_MSGTYPE, 0x2222, sizeof(dops),
                          (uint8_t*)&dops);

        hb = {};
        hb.protocol_major = 0; //Sends protocol version 0
        sbp_send_message(SBP_HEARTBEAT_MSGTY