 // number of locked satellites
    uint8_t num_sats(uint8_t instance) const {
        return state[instance].num_sats;
    }
    uint8_t num_sats() const {
        return num_sats(primary_instance);
    }

    // GPS time of week in milliseconds
    uint32_t time_week_ms(uint8_t instance) const {
        return state[instance].time_week_ms;
    }
    uint32_t time_week_ms() const {
        return time_week_ms(primary_instance);
    }

    // GPS week
    uint16_t time_week(uint8_t instance) const {
        return state[instance].time_week;
    }
    uint16_t time_week() const {
        return time_week(primary_instance);
    }

    // horizontal dilution of precision
    uint16_t get_hdop(uint8_t instance) const {
        return state[instance].hdop;
    }
    uint16_t get_hdop() const {
        return get_hdop(primary_instance);
    }

    // vertical dilution of precision
    uint16_t get_vdop(uint8_t instance) const {
        return state[instance].vdop;
    }
    uint16_t get_vdop() const {
        return get_vdop(primary_instance);
    }

    // the time we got our last fix in system milliseconds. This is
    // used when calculating how far we might have moved since that fix
    uint32_t last_fix_time_ms(uint8_t instance) const {
        return timing[instance].last_fix_time_ms;
    }
    uint32_t last_fix_time_ms(void) const {
        return last_fix_time_ms(primary_instance);
    }

    // the time we last processed a message in milliseconds. This is
    // used to indicate that we have new GPS data to process
    uint32_t last_message_time_ms(uint8_t instance) const {
        return timing[instance].last_message_time_ms;
    }
    uint32_t last_message_time_ms(void) const {
        return last_message_time_ms(primary_instance);
    }

    // system time delta between the last two reported positions
    uint16_t last_message_delta_time_ms(uint8_t instance) const {
        return timing[instance].delta_time_ms;
    }
    uint16_t last_message_delta_time_ms(void) const {
        return last_message_delta_time_ms(primary_instance);
    }

    // return true if the GPS supports vertical velocity values
    bool have_vertical_velocity(uint8_t instance) const {
        return state[instance].have_vertical_velocity;
    }
    bool have_vertical_velocity(void) const {
        return have_vertical_velocity(primary_instance);
    }

    // return true if the GPS currently has yaw available
    bool have_gps_yaw(uint8_t instance) const {
        return !_force_disable_gps_yaw && state[instance].have_gps_yaw;
    }
    bool have_gps_yaw(void) const {
        return have_gps_yaw(primary_instance);
    }

    // return true if the GPS is configured to provide yaw. This will
    // be true if we expect the GPS to provide yaw, even if it
    // currently is not able to provide yaw
    bool have_gps_yaw_configured(uint8_t instance) const {
        return state[instance].gps_yaw_configured;
    }
    
    // the expected lag (in seconds) in the position and velocity readings from the gps
    // return true if the GPS hardware configuration is known or the lag parameter has been set manually
    bool get_lag(uint8_t instance, float &lag_sec) const;
    bool get_lag(float &lag_sec) const {
        return get_lag(primary_instance, lag_sec);
    }

    // return a 3D vector defining the offset of the GPS antenna in meters relative to the body frame origin
    const Vector3f &get_antenna_offset(uint8_t instance) const;

    // lock out a GPS port, allowing another application to use the port
    void lock_port(uint8_t instance, bool locked);

    //MAVLink Status Sending
    void send_mavlink_gps_raw(mavlink_channel_t chan);
    void send_mavlink_gps2_raw(mavlink_channel_t chan);

    void send_mavlink_gps_rtk(mavlink_channel_t chan, uint8_t inst);

    // Returns true if there is an unconfigured GPS, and provides the instance number of the first non configured GPS
    bool first_unconfigured_gps(uint8_t &instance) const WARN_IF_UNUSED;
    void broadcast_first_configuration_failure_reason(void) const;

    // pre-arm check that all GPSs are close to each other.  farthest distance between GPSs (in meters) is returned
    bool all_consistent(float &distance) const;

    // pre-arm check of GPS blending.  False if blending is unhealthy, True if healthy or blending is not being used
    bool blend_health_check() const;

    // handle sending of initialisation strings to the GPS - only used by backends
    void send_blob_start(uint8_t instance);
    void send_blob_start(uint8_t instance, const char *_blob, uint16_t size);
    void send_blob_update(uint8_t instance);

    // return last fix time since the 1/1/1970 in microseconds
    uint64_t time_epoch_usec(uint8_t instance) const;
    uint64_t time_epoch_usec(void) const {
        return time_epoch_usec(primary_instance);
    }

    uint64_t last_message_epoch_usec(uint8_t instance) const;
    uint64_t last_message_epoch_usec() const {
        return last_message_epoch_usec(primary_instance);
    }

    // convert GPS week and millis to unix epoch in ms
    static uint64_t istate_time_to_epoch_ms(uint16_t gps_week, uint32_t gps_ms);

    static const struct AP_Param::GroupInfo var_info[];

#if HAL_LOGGING_ENABLED
    void Write_AP_Logger_Log_Startup_messages();
#endif

    // indicate which bit in LOG_BITMASK indicates gps logging enabled
    void set_log_gps_bit(uint32_t bit) { _log_gps_bit = bit; }

    // report if the gps is healthy (this is defined as existing, an update at a rate greater than 4Hz,
    // as well as any driver specific behaviour)
    bool is_healthy(uint8_t instance) const;
    bool is_healthy(void) const { return is_healthy(primary_instance); }

    // returns true if all GPS instances have passed all final arming checks/state changes
    bool prepare_for_arming(void);

    // returns true if all GPS backend drivers are OK with the concept
    // of the vehicle arming.  this is for backends to be able to
    // spout pre arm error messages
    bool pre_arm_checks(char failure_msg[], uint16_t failure_msg_len);

    // returns false if any GPS drivers are not performing their logging appropriately
    bool logging_failed(void) const;

    bool logging_present(void) const { return _raw_data != 0; }
    bool logging_enabled(void) const { return _raw_data != 0; }

    // used to disable GPS for GPS failure testing in flight
    void force_disable(bool disable) {
        _force_disable_gps = disable;
    }

    // used to disable GPS yaw for GPS failure testing in flight
    void set_force_disable_yaw(bool disable) {
        _force_disable_gps_yaw = disable;
    }

    // handle possibly fragmented RTCM injection data
    void handle_gps_rtcm_fragment(uint8_t flags, const uint8_t *data, uint8_t len);

    // get configured type by instance
    GPS_Type get_type(uint8_t instance) const {
        return instance>=ARRAY_SIZE(params) ? GPS_Type::GPS_TYPE_NONE : params[instance].type;
    }

    // get iTOW, if supported, zero otherwie
    uint32_t get_itow(uint8_t instance) const;

    bool get_error_codes(uint8_t instance, uint32_t &error_codes) const;
    bool get_error_codes(uint32_t &error_codes) const { return get_error_codes(primary_instance, error_codes); }

    enum class SBAS_Mode : int8_t {
        Disabled = 0,
        Enabled = 1,
        DoNotChange = 2,
    };

#if GPS_MOVING_BASELINE
    // methods used by UAVCAN GPS driver and AP_Periph for moving baseline
    void inject_MBL_data(uint8_t* data, uint16_t length);
    bool get_RelPosHeading(uint32_t &timestamp, float &relPosHeading, float &relPosLength, float &relPosD, float &accHeading) WARN_IF_UNUSED;
    bool get_RTCMV3(const uint8_t *&bytes, uint16_t &len);
    void clear_RTCMV3();
#endif // GPS_MOVING_BASELINE

#if !AP_GPS_BLENDED_ENABLED
    uint8_t get_auto_switch_type() const { return _auto_switch; }
#endif

protected:

    // configuration parameters
    Params params[GPS_MAX_RECEIVERS];
    AP_Int8 _navfilter;
    AP_Int8 _auto_switch;
    AP_Int16 _sbp_logmask;
    AP_Int8 _inject_to;
    uint32_t _last_instance_swap_ms;
    AP_Enum<SBAS_Mode> _sbas_mode;
    AP_Int8 _min_elevation;
    AP_Int8 _raw_data;
    AP_Int8 _save_config;
    AP_Int8 _auto_config;
    AP_Int8 _blend_mask;
    AP_Int16 _driver_options;
    AP_Int8 _primary;

    uint32_t _log_gps_bit = -1;

    enum DriverOptions : int16_t {
        UBX_MBUseUart2    = (1U << 0U),
        SBF_UseBaseForYaw = (1U << 1U),
        UBX_Use115200     = (1U << 2U),
        UAVCAN_MBUseDedicatedBus  = (1 << 3U),
        HeightEllipsoid   = (1U << 4),
        GPSL5HealthOverride = (1U << 5),
        AlwaysRTCMDecode = (1U << 6),
        DisableRTCMDecode = (1U << 7),
    };

    // check if an option is set
    bool option_set(const DriverOptions option) const {
        return (uint8_t(_driver_options.get()) & uint8_t(option)) != 0;
    }

private:
    static AP_GPS *_singleton;
    HAL_Semaphore rsem;

    // returns the desired gps update rate in milliseconds
    // this does not provide any guarantee that the GPS is updating at the requested
    // rate it is simply a helper for use in the backends for determining what rate
    // they should be configuring the GPS to run at
    uint16_t get_rate_ms(uint8_t instance) const;

    struct GPS_timing {
        // the time we got our last fix in system milliseconds
        uint32_t last_fix_time_ms;

        // the time we got our last message in system milliseconds
        uint32_t last_message_time_ms;

        // delta time between the last pair of GPS updates in system milliseconds
        uint16_t delta_time_ms;

        // count of delayed frames
        uint8_t delayed_count;

        // the average time delta
        float average_delta_ms;
    };
    // Note allowance for an additional instance to contain blended data
    GPS_timing timing[GPS_MAX_INSTANCES];
    GPS_State state[GPS_MAX_INSTANCES];
    AP_GPS_Backend *drivers[GPS_MAX_RECEIVERS];
    AP_HAL::UARTDriver *_port[GPS_MAX_RECEIVERS];

    /// primary GPS instance
    uint8_t primary_instance;

    /// number of GPS instances present
    uint8_t num_instances;

    // which ports are locked
    uint8_t locked_ports;

    // state of auto-detection process, per instance
    struct detect_state {
        uint32_t last_baud_change_ms;
        uint8_t current_baud;
        uint32_t probe_baud;
        bool auto_detected_baud;
#if AP_GPS_UBLOX_ENABLED
        struct UBLOX_detect_state ublox_detect_state;
#endif
#if AP_GPS_SIRF_ENABLED
        struct SIRF_detect_state sirf_detect_state;
#endif
#if AP_GPS_NMEA_ENABLED
        struct NMEA_detect_state nmea_detect_state;
#endif
#if AP_GPS_SBP_ENABLED
        struct SBP_detect_state sbp_detect_state;
#endif
#if AP_GPS_SBP2_ENABLED
        struct SBP2_detect_state sbp2_detect_state;
#endif
#if AP_GPS_ERB_ENABLED
        struct ERB_detect_state erb_detect_state;
#endif
    } detect_state[GPS_MAX_RECEIVERS];

    struct {
        const char *blob;
        uint16_t remaining;
    } initblob_state[GPS_MAX_RECEIVERS];

    static const uint32_t  _baudrates[];
    static const char _initialisation_blob[];
    static const char _initialisation_raw_blob[];

    void detect_instance(uint8_t instance);
    // run detection step for one GPS instance. If this finds a GPS then it
    // will return it - otherwise nullptr
    AP_GPS_Backend *_detect_instance(uint8_t instance);

    void update_instance(uint8_t instance);

    /*
      buffer for re-assembling RTCM data for GPS injection.
      The 8 bit flags field in GPS_RTCM_DATA is interpreted as:
              1 bit for "is fragmented"
              2 bits for fragment number
              5 bits for sequence number

      The rtcm_buffer is allocated on first use. Once a block of data
      is successfully reassembled it is injected into all active GPS
      backends. This assumes we don't want more than 4*180=720 bytes
      in a RTCM data block
     */
    struct rtcm_buffer {
        uint8_t fragments_received;
        uint8_t sequence;
        uint8_t fragment_count;
        uint16_t total_length;
        uint8_t buffer[MAVLINK_MSG_GPS_RTCM_DATA_FIELD_DATA_LEN*4];
    } *rtcm_buffer;

    struct {
        uint16_t fragments_used;
        uint16_t fragments_discarded;
    } rtcm_stats;

    // re-assemble GPS_RTCM_DATA message
    void handle_gps_rtcm_data(mavlink_channel_t chan, const mavlink_message_t &msg);
    void handle_gps_inject(const mavlink_message_t &msg);

    //Inject a packet of raw binary to a GPS
    void inject_data(const uint8_t *data, uint16_t len);
    void inject_data(uint8_t instance, const uint8_t *data, uint16_t len);

#if AP_GPS_BLENDED_ENABLED
    // GPS blending and switching
    Vector3f _blended_antenna_offset; // blended antenna offset
    float _blended_lag_sec; // blended receiver lag in seconds
    float _blend_weights[GPS_MAX_RECEIVERS]; // blend weight for each GPS. The blend weights must sum to 1.0 across all instances.
    bool _output_is_blended; // true when a blended GPS solution being output
    uint8_t _blend_health_counter;  // 0 = perfectly health, 100 = very unhealthy

    // calculate the blend weight.  Returns true if blend could be calculated, false if not
    bool calc_blend_weights(void);

    // calculate the blended state
    void calc_blended_state(void);
#endif

    bool should_log() const;

    bool needs_uart(GPS_Type type) const;

#if GPS_MAX_RECEIVERS > 1
    /// Update primary instance
    void update_primary(void);
#endif

    // helper function for mavlink gps yaw
    uint16_t gps_yaw_cdeg(uint8_t instance) const;

    // Auto configure types
    enum GPS_AUTO_CONFIG {
        GPS_AUTO_CONFIG_DISABLE = 0,
        GPS_AUTO_CONFIG_ENABLE_SERIAL_ONLY  = 1,
        GPS_AUTO_CONFIG_ENABLE_ALL = 2,
    };

    enum class GPSAutoSwitch {
        NONE        = 0,
        USE_BEST    = 1,
        BLEND       = 2,
        //USE_SECOND  = 3, deprecated for new primary param
        USE_PRIMARY_IF_3D_FIX = 4,
    };

    // used for flight testing with GPS loss
    bool _force_disable_gps;

    // used for flight testing with GPS yaw loss
    bool _force_disable_gps_yaw;

    // logging support
    void Write_GPS(uint8_t instance);

#if AP_GPS_RTCM_DECODE_ENABLED
    /*
      per mavlink channel RTCM decoder, enabled with RTCM decode
       option in GPS_DRV_OPTIONS
    */
    struct {
        RTCM3_Parser *parsers[MAVLINK_COMM_NUM_BUFFERS];
        uint32_t sent_crc[32];
        uint8_t sent_idx;
        uint16_t seen_mav_channels;
    } rtcm;
    bool parse_rtcm_injection(mavlink_channel_t chan, const mavlink_gps_rtcm_data_t &pkt);
#endif

    void convert_parameters();
};

namespace AP {
    AP_GPS &gps();
};

#endif  // AP_GPS_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         #include "AP_GPS.h"

#if AP_GPS_BLENDED_ENABLED

// defines used to specify the mask position for use of different accuracy metrics in the blending algorithm
#define BLEND_MASK_USE_HPOS_ACC     1
#define BLEND_MASK_USE_VPOS_ACC     2
#define BLEND_MASK_USE_SPD_ACC      4

// pre-arm check of GPS blending.  True means healthy or that blending is not being used
bool AP_GPS::blend_health_check() const
{
    return (_blend_health_counter < 50);
}

/*
 calculate the weightings used to blend GPSs location and velocity data
*/
bool AP_GPS::calc_blend_weights(void)
{
    // zero the blend weights
    memset(&_blend_weights, 0, sizeof(_blend_weights));


    static_assert(GPS_MAX_RECEIVERS == 2, "GPS blending only currently works with 2 receivers");
    // Note that the early quit below relies upon exactly 2 instances
    // The time delta calculations below also rely upon every instance being currently detected and being parsed

    // exit immediately if not enough receivers to do blending
    if (state[0].status <= NO_FIX || state[1].status <= NO_FIX) {
        return false;
    }

    // Use the oldest non-zero time, but if time difference is excessive, use newest to prevent a disconnected receiver from blocking updates
    uint32_t max_ms = 0; // newest non-zero system time of arrival of a GPS message
    uint32_t min_ms = -1; // oldest non-zero system time of arrival of a GPS message
    uint32_t max_rate_ms = 0; // largest update interval of a GPS receiver
    for (uint8_t i=0; i<GPS_MAX_RECEIVERS; i++) {
        // Find largest and smallest times
        if (state[i].last_gps_time_ms > max_ms) {
            max_ms = state[i].last_gps_time_ms;
        }
        if ((state[i].last_gps_time_ms < min_ms) && (state[i].last_gps_time_ms > 0)) {
            min_ms = state[i].last_gps_time_ms;
        }
        max_rate_ms = MAX(get_rate_ms(i), max_rate_ms);
        if (isinf(state[i].speed_accuracy) ||
            isinf(state[i].horizontal_accuracy) ||
            isinf(state[i].vertical_accuracy)) {
            return false;
        }
    }
    if ((max_ms - min_ms) < (2 * max_rate_ms)) {
        // data is not too delayed so use the oldest time_stamp to give a chance for data from that receiver to be updated
        state[GPS_BLENDED_INSTANCE].last_gps_time_ms = min_ms;
    } else {
        // receiver data has timed out so fail out of blending
        return false;
    }

    // calculate the sum squared speed accuracy across all GPS sensors
    float speed_accuracy_sum_sq = 0.0f;
    if (_blend_mask & BLEND_MASK_USE_SPD_ACC) {
        for (uint8_t i=0; i<GPS_MAX_RECEIVERS; i++) {
            if (state[i].status >= GPS_OK_FIX_3D) {
                if (state[i].have_speed_accuracy && state[i].speed_accuracy > 0.0f) {
                    speed_accuracy_sum_sq += sq(state[i].speed_accuracy);
                } else {
                    // not all receivers support this metric so set it to zero and don't use it
                    speed_accuracy_sum_sq = 0.0f;
                    break;
                }
            }
        }
    }

    // calculate the sum squared horizontal position accuracy across all GPS sensors
    float horizontal_accuracy_sum_sq = 0.0f;
    if (_blend_mask & BLEND_MASK_USE_HPOS_ACC) {
        for (uint8_t i=0; i<GPS_MAX_RECEIVERS; i++) {
            if (state[i].status >= GPS_OK_FIX_2D) {
                if (state[i].have_horizontal_accuracy && state[i].horizontal_accuracy > 0.0f) {
                    horizontal_accuracy_sum_sq += sq(state[i].horizontal_accuracy);
                } else {
                    // not all receivers support this metric so set it to zero and don't use it
                    horizontal_accuracy_sum_sq = 0.0f;
                    break;
                }
            }
        }
    }

    // calculate the sum squared vertical position accuracy across all GPS sensors
    float vertical_accuracy_sum_sq = 0.0f;
    if (_blend_mask & BLEND_MASK_USE_VPOS_ACC) {
        for (uint8_t i=0; i<GPS_MAX_RECEIVERS; i++) {
            if (state[i].status >= GPS_OK_FIX_3D) {
                if (state[i].have_vertical_accuracy && state[i].vertical_accuracy > 0.0f) {
                    vertical_accuracy_sum_sq += sq(state[i].vertical_accuracy);
                } else {
                    // not all receivers support this metric so set it to zero and don't use it
                    vertical_accuracy_sum_sq = 0.0f;
                    break;
                }
            }
        }
    }
    // Check if we can do blending using reported accuracy
    bool can_do_blending = (horizontal_accuracy_sum_sq > 0.0f || vertical_accuracy_sum_sq > 0.0f || speed_accuracy_sum_sq > 0.0f);

    // if we can't do blending using reported accuracy, return false and hard switch logic will be used instead
    if (!can_do_blending) {
        return false;
    }

    float sum_of_all_weights = 0.0f;

    // calculate a weighting using the reported horizontal position
    float hpos_blend_weights[GPS_MAX_RECEIVERS] = {};
    if (horizontal_accuracy_sum_sq > 0.0f) {
        // calculate the weights using the inverse of the variances
        float sum_of_hpos_weights = 0.0f;
        for (uint8_t i=0; i<GPS_MAX_RECEIVERS; i++) {
            if (state[i].status >= GPS_OK_FIX_2D && state[i].horizontal_accuracy >= 0.001f) {
                hpos_blend_weights[i] = horizontal_accuracy_sum_sq / sq(state[i].horizontal_accuracy);
                sum_of_hpos_weights += hpos_blend_weights[i];
            }
        }
        // normalise the weights
        if (sum_of_hpos_weights > 0.0f) {
            for (uint8_t i=0; i<GPS_MAX_RECEIVERS; i++) {
                hpos_blend_weights[i] = hpos_blend_weights[i] / sum_of_hpos_weights;
            }
            sum_of_all_weights += 1.0f;
        }
    }

    // calculate a weighting using the reported vertical position accuracy
    float vpos_blend_weights[GPS_MAX_RECEIVERS] = {};
    if (vertical_accuracy_sum_sq > 0.0f) {
        // calculate the weights using the inverse of the variances
        float sum_of_vpos_weights = 0.0f;
        for (uint8_t i=0; i<GPS_MAX_RECEIVERS; i++) {
            if (state[i].status >= GPS_OK_FIX_3D && state[i].vertical_accuracy >= 0.001f) {
                vpos_blend_weights[i] = vertical_accuracy_sum_sq / sq(state[i].vertical_accuracy);
                sum_of_vpos_weights += vpos_blend_weights[i];
            }
        }
        // normalise the weights
        if (sum_of_vpos_weights > 0.0f) {
            for (uint8_t i=0; i<GPS_MAX_RECEIVERS; i++) {
                vpos_blend_weights[i] = vpos_blend_weights[i] / sum_of_vpos_weights;
            }
            sum_of_all_weights += 1.0f;
        };
    }

    // calculate a weighting using the reported speed accuracy
    float spd_blend_weights[GPS_MAX_RECEIVERS] = {};
    if (speed_accuracy_sum_sq > 0.0f) {
        // calculate the weights using the inverse of the variances
        float sum_of_spd_weights = 0.0f;
        for (uint8_t i=0; i<GPS_MAX_RECEIVERS; i++) {
            if (state[i].status >= GPS_OK_FIX_3D && state[i].speed_accuracy >= 0.001f) {
                spd_blend_weights[i] = speed_accuracy_sum_sq / sq(state[i].speed_accuracy);
                sum_of_spd_weights += spd_blend_weights[i];
            }
        }
        // normalise the weights
        if (sum_of_spd_weights > 0.0f) {
            for (uint8_t i=0; i<GPS_MAX_RECEIVERS; i++) {
                spd_blend_weights[i] = spd_blend_weights[i] / sum_of_spd_weights;
            }
            sum_of_all_weights += 1.0f;
        }
    }

    if (!is_positive(sum_of_all_weights)) {
        return false;
    }

    // calculate an overall weight
    for (uint8_t i=0; i<GPS_MAX_RECEIVERS; i++) {
        _blend_weights[i] = (hpos_blend_weights[i] + vpos_blend_weights[i] + spd_blend_weights[i]) / sum_of_all_weights;
    }

    return true;
}

/*
 calculate a blended GPS state
*/
void AP_GPS::calc_blended_state(void)
{
    // initialise the blended states so we can accumulate the results using the weightings for each GPS receiver
    state[GPS_BLENDED_INSTANCE].instance = GPS_BLENDED_INSTANCE;
    state[GPS_BLENDED_INSTANCE].status = NO_FIX;
    state[GPS_BLENDED_INSTANCE].time_week_ms = 0;
    state[GPS_BLENDED_INSTANCE].time_week = 0;
    state[GPS_BLENDED_INSTANCE].ground_speed = 0.0f;
    state[GPS_BLENDED_INSTANCE].ground_course = 0.0f;
    state[GPS_BLENDED_INSTANCE].hdop = GPS_UNKNOWN_DOP;
    state[GPS_BLENDED_INSTANCE].vdop = GPS_UNKNOWN_DOP;
    state[GPS_BLENDED_INSTANCE].num_sats = 0;
    state[GPS_BLENDED_INSTANCE].velocity.zero();
    state[GPS_BLENDED_INSTANCE].speed_accuracy = 1e6f;
    state[GPS_BLENDED_INSTANCE].horizontal_accuracy = 1e6f;
    state[GPS_BLENDED_INSTANCE].vertical_accuracy = 1e6f;
    state[GPS_BLENDED_INSTANCE].have_vertical_velocity = false;
    state[GPS_BLENDED_INSTANCE].have_speed_accuracy = false;
    state[GPS_BLENDED_INSTANCE].have_horizontal_accuracy = false;
    state[GPS_BLENDED_INSTANCE].have_vertical_accuracy = false;
    state[GPS_BLENDED_INSTANCE].location = {};

    _blended_antenna_offset.zero();
    _blended_lag_sec = 0;

#if HAL_LOGGING_ENABLED
    const uint32_t last_blended_message_time_ms = timing[GPS_BLENDED_INSTANCE].last_message_time_ms;
#endif
    timing[GPS_BLENDED_INSTANCE].last_fix_time_ms = 0;
    timing[GPS_BLENDED_INSTANCE].last_message_time_ms = 0;

    if (state[0].have_undulation) {
        state[GPS_BLENDED_INSTANCE].have_undulation = true;
        state[GPS_BLENDED_INSTANCE].undulation = state[0].undulation;
    } else if (state[1].have_undulation) {
        state[GPS_BLENDED_INSTANCE].have_undulation = true;
        state[GPS_BLENDED_INSTANCE].undulation = state[1].undulation;
    } else {
        state[GPS_BLENDED_INSTANCE].have_undulation = false;
    }

    // combine the states into a blended solution
    for (uint8_t i=0; i<GPS_MAX_RECEIVERS; i++) {
        // use the highest status
        if (state[i].status > state[GPS_BLENDED_INSTANCE].status) {
            state[GPS_BLENDED_INSTANCE].status = state[i].status;
        }

        // calculate a blended average velocity
        state[GPS_BLENDED_INSTANCE].velocity += state[i].velocity * _blend_weights[i];

        // report the best valid accuracies and DOP metrics

        if (state[i].have_horizontal_accuracy && state[i].horizontal_accuracy > 0.0f && state[i].horizontal_accuracy < state[GPS_BLENDED_INSTANCE].horizontal_accuracy) {
            state[GPS_BLENDED_INSTANCE].have_horizontal_accuracy = true;
            state[GPS_BLENDED_INSTANCE].horizontal_accuracy = state[i].horizontal_accuracy;
        }

        if (state[i].have_vertical_accuracy && state[i].vertical_accuracy > 0.0f && state[i].vertical_accuracy < state[GPS_BLENDED_INSTANCE].vertical_accuracy) {
            state[GPS_BLENDED_INSTANCE].have_vertical_accuracy = true;
            state[GPS_BLENDED_INSTANCE].vertical_accuracy = state[i].vertical_accuracy;
        }

        if (state[i].have_vertical_velocity) {
            state[GPS_BLENDED_INSTANCE].have_vertical_velocity = true;
        }

        if (state[i].have_speed_accuracy && state[i].speed_accuracy > 0.0f && state[i].speed_accuracy < state[GPS_BLENDED_INSTANCE].speed_accuracy) {
            state[GPS_BLENDED_INSTANCE].have_speed_accuracy = true;
            state[GPS_BLENDED_INSTANCE].speed_accuracy = state[i].speed_accuracy;
        }

        if (state[i].hdop > 0 && state[i].hdop < state[GPS_BLENDED_INSTANCE].hdop) {
            state[GPS_BLENDED_INSTANCE].hdop = state[i].hdop;
        }

        if (state[i].vdop > 0 && state[i].vdop < state[GPS_BLENDED_INSTANCE].vdop) {
            state[GPS_BLENDED_INSTANCE].vdop = state[i].vdop;
        }

        if (state[i].num_sats > 0 && state[i].num_sats > state[GPS_BLENDED_INSTANCE].num_sats) {
            state[GPS_BLENDED_INSTANCE].num_sats = state[i].num_sats;
        }

        // report a blended average GPS antenna position
        Vector3f temp_antenna_offset = params[i].antenna_offset;
        temp_antenna_offset *= _blend_weights[i];
        _blended_antenna_offset += temp_antenna_offset;

        // blend the timing data
        if (timing[i].last_fix_time_ms > timing[GPS_BLENDED_INSTANCE].last_fix_time_ms) {
            timing[GPS_BLENDED_INSTANCE].last_fix_time_ms = timing[i].last_fix_time_ms;
        }
        if (timing[i].last_message_time_ms > timing[GPS_BLENDED_INSTANCE].last_message_time_ms) {
            timing[GPS_BLENDED_INSTANCE].last_message_time_ms = timing[i].last_message_time_ms;
        }
    }

    /*
     * Calculate an instantaneous weighted/blended average location from the available GPS instances and store in the _output_state.
     * This will be statistically the most likely location, but will be not stable enough for direct use by the autopilot.
    */

    // Use the GPS with the highest weighting as the reference position
    float best_weight = 0.0f;
    uint8_t best_index = 0;
    for (uint8_t i=0; i<GPS_MAX_RECEIVERS; i++) {
        if (_blend_weights[i] > best_weight) {
            best_weight = _blend_weights[i];
            best_index = i;
            state[GPS_BLENDED_INSTANCE].location = state[i].location;
        }
    }

    // Calculate the weighted sum of horizontal and vertical position offsets relative to the reference position
    Vector2f blended_NE_offset_m;
    float blended_alt_offset_cm = 0.0f;
    blended_NE_offset_m.zero();
    for (uint8_t i=0; i<GPS_MAX_RECEIVERS; i++) {
        if (_blend_weights[i] > 0.0f && i != best_index) {
            blended_NE_offset_m += state[GPS_BLENDED_INSTANCE].location.get_distance_NE(state[i].location) * _blend_weights[i];
            blended_alt_offset_cm += (float)(state[i].location.alt - state[GPS_BLENDED_INSTANCE].location.alt) * _blend_weights[i];
        }
    }

    // Add the sum of weighted offsets to the reference location to obtain the blended location
    state[GPS_BLENDED_INSTANCE].location.offset(blended_NE_offset_m.x, blended_NE_offset_m.y);
    state[GPS_BLENDED_INSTANCE].location.alt += (int)blended_alt_offset_cm;

    // Calculate ground speed and course from blended velocity vector
    state[GPS_BLENDED_INSTANCE].ground_speed = state[GPS_BLENDED_INSTANCE].velocity.xy().length();
    state[GPS_BLENDED_INSTANCE].ground_course = wrap_360(degrees(atan2f(state[GPS_BLENDED_INSTANCE].velocity.y, state[GPS_BLENDED_INSTANCE].velocity.x)));

    // If the GPS week is the same then use a blended time_week_ms
    // If week is different, then use time stamp from GPS with largest weighting
    // detect inconsistent week data
    uint8_t last_week_instance = 0;
    bool weeks_consistent = true;
    for (uint8_t i=0; i<GPS_MAX_RECEIVERS; i++) {
        if (last_week_instance == 0 && _blend_weights[i] > 0) {
            // this is our first valid sensor week data
            last_week_instance = state[i].time_week;
        } else if (last_week_instance != 0 && _blend_weights[i] > 0 && last_week_instance != state[i].time_week) {
            // there is valid sensor week data that is inconsistent
            weeks_consistent = false;
        }
    }
    // calculate output
    if (!weeks_consistent) {
        // use data from highest weighted sensor
        state[GPS_BLENDED_INSTANCE].time_week = state[best_index].time_week;
        state[GPS_BLENDED_INSTANCE].time_week_ms = state[best_index].time_week_ms;
    } else {
        // use week number from highest weighting GPS (they should all have the same week number)
        state[GPS_BLENDED_INSTANCE].time_week = state[best_index].time_week;
        // calculate a blended value for the number of ms lapsed in the week
        double temp_time_0 = 0.0;
        for (uint8_t i=0; i<GPS_MAX_RECEIVERS; i++) {
            if (_blend_weights[i] > 0.0f) {
                temp_time_0 += (double)state[i].time_week_ms * (double)_blend_weights[i];
            }
        }
        state[GPS_BLENDED_INSTANCE].time_week_ms = (uint32_t)temp_time_0;
    }

    // calculate a blended value for the timing data and lag
    double temp_time_1 = 0.0;
    double temp_time_2 = 0.0;
    for (uint8_t i=0; i<GPS_MAX_RECEIVERS; i++) {
        if (_blend_weights[i] > 0.0f) {
            temp_time_1 += (double)timing[i].last_fix_time_ms * (double) _blend_weights[i];
            temp_time_2 += (double)timing[i].last_message_time_ms * (double)_blend_weights[i];
            float gps_lag_sec = 0;
            get_lag(i, gps_lag_sec);
            _blended_lag_sec += gps_lag_sec * _blend_weights[i];
        }
    }
    timing[GPS_BLENDED_INSTANCE].last_fix_time_ms = (uint32_t)temp_time_1;
    timing[GPS_BLENDED_INSTANCE].last_message_time_ms = (uint32_t)temp_time_2;

#if HAL_LOGGING_ENABLED
    if (timing[GPS_BLENDED_INSTANCE].last_message_time_ms > last_blended_message_time_ms &&
        should_log()) {
        Write_GPS(GPS_BLENDED_INSTANCE);
    }
#endif
}
#endif  // AP_GPS_BLENDED_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  /*
 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

//
//  UAVCAN GPS driver
//
#include "AP_GPS_config.h"

#if AP_GPS_DRONECAN_ENABLED

#include <AP_HAL/AP_HAL.h>

#include "AP_GPS_DroneCAN.h"

#include <AP_CANManager/AP_CANManager.h>
#include <AP_DroneCAN/AP_DroneCAN.h>
#include <GCS_MAVLink/GCS.h>

#include <AP_Logger/AP_Logger.h>

#include <stdio.h>
#include <AP_BoardConfig/AP_BoardConfig.h>

#define GPS_PPS_EMULATION 0

extern const AP_HAL::HAL& hal;

#define GPS_UAVCAN_DEBUGGING 0

#if GPS_UAVCAN_DEBUGGING
#if defined(HAL_BUILD_AP_PERIPH)
 extern "C" {
   void can_printf(const char *fmt, ...);
 }
 # define Debug(fmt, args ...)  do {can_printf("%s:%d: " fmt "\n", __FUNCTION__, __LINE__, ## args);} while(0)
#else
 # define Debug(fmt, args ...)  do {hal.console->printf("%s:%d: " fmt "\n", __FUNCTION__, __LINE__, ## args); hal.scheduler->delay(1); } while(0)
#endif
#else
 # define Debug(fmt, args ...)
#endif

#define LOG_TAG "GPS"

#if CONFIG_HAL_BOARD == HAL_BOARD_SITL
#define NATIVE_TIME_OFFSET (AP_HAL::micros64() - AP_HAL::micros64())
#else
#define NATIVE_TIME_OFFSET 0
#endif
AP_GPS_DroneCAN::DetectedModules AP_GPS_DroneCAN::_detected_modules[];
HAL_Semaphore AP_GPS_DroneCAN::_sem_registry;

// Member Methods
AP_GPS_DroneCAN::AP_GPS_DroneCAN(AP_GPS &_gps,
                                 AP_GPS::Params &_params,
                                 AP_GPS::GPS_State &_state,
                                 AP_GPS::GPS_Role _role) :
    AP_GPS_Backend(_gps, _params, _state, nullptr),
    interim_state(_state),
    role(_role)
{
    param_int_cb = FUNCTOR_BIND_MEMBER(&AP_GPS_DroneCAN::handle_param_get_set_response_int, bool, AP_DroneCAN*, const uint8_t, const char*, int32_t &);
    param_float_cb = FUNCTOR_BIND_MEMBER(&AP_GPS_DroneCAN::handle_param_get_set_response_float, bool, AP_DroneCAN*, const uint8_t, const char*, float &);
    param_save_cb = FUNCTOR_BIND_MEMBER(&AP_GPS_DroneCAN::handle_param_save_response, void, AP_DroneCAN*, const uint8_t, bool);
}

AP_GPS_DroneCAN::~AP_GPS_DroneCAN()
{
    WITH_SEMAPHORE(_sem_registry);

    _detected_modules[_detected_module].driver = nullptr;

#if GPS_MOVING_BASELINE
    if (rtcm3_parser != nullptr) {
        delete rtcm3_parser;
    }
#endif
}

void AP_GPS_DroneCAN::subscribe_msgs(AP_DroneCAN* ap_dronecan)
{
    if (ap_dronecan == nullptr) {
        return;
    }

    if (Canard::allocate_sub_arg_callback(ap_dronecan, &handle_fix2_msg_trampoline, ap_dronecan->get_driver_index()) == nullptr) {
        AP_BoardConfig::allocation_error("status_sub");
    }

    if (Canard::allocate_sub_arg_callback(ap_dronecan, &handle_aux_msg_trampoline, ap_dronecan->get_driver_index()) == nullptr) {
        AP_BoardConfig::allocation_error("status_sub");
    }

    if (Canard::allocate_sub_arg_callback(ap_dronecan, &handle_heading_msg_trampoline, ap_dronecan->get_driver_index()) == nullptr) {
        AP_BoardConfig::allocation_error("status_sub");
    }

    if (Canard::allocate_sub_arg_callback(ap_dronecan, &handle_status_msg_trampoline, ap_dronecan->get_driver_index()) == nullptr) {
        AP_BoardConfig::allocation_error("status_sub");
    }
#if GPS_MOVING_BASELINE
    if (Canard::allocate_sub_arg_callback(ap_dronecan, &handle_moving_baseline_msg_trampoline, ap_dronecan->get_driver_index()) == nullptr) {
        AP_BoardConfig::allocation_error("moving_baseline_sub");
    }

    if (Canard::allocate_sub_arg_callback(ap_dronecan, &handle_relposheading_msg_trampoline, ap_dronecan->get_driver_index()) == nullptr) {
        AP_BoardConfig::allocation_error("relposheading_sub");
    }
#endif
}

AP_GPS_Backend* AP_GPS_DroneCAN::probe(AP_GPS &_gps, AP_GPS::GPS_State &_state)
{
    WITH_SEMAPHORE(_sem_registry);
    int8_t found_match = -1, last_match = -1;
    AP_GPS_DroneCAN* backend = nullptr;
    bool bad_override_config = false;
    for (int8_t i = GPS_MAX_RECEIVERS - 1; i >= 0; i--) {
        if (_detected_modules[i].driver == nullptr && _detected_modules[i].ap_dronecan != nullptr) {
            if (_gps.params[_state.instance].override_node_id != 0 &&
                _gps.params[_state.instance].override_node_id != _detected_modules[i].node_id) {
                continue; // This device doesn't match the correct node
            }
            last_match = found_match;
            for (uint8_t j = 0; j < GPS_MAX_RECEIVERS; j++) {
                if (_detected_modules[i].node_id == _gps.params[j].override_node_id &&
                    (j != _state.instance)) {
                    //wrong instance
                    found_match = -1;
                    break;
                }
                found_match = i;
            }

            // Handle Duplicate overrides
            for (uint8_t j = 0; j < GPS_MAX_RECEIVERS; j++) {
                if (_gps.params[i].override_node_id != 0 && (i != j) &&
                    _gps.params[i].override_node_id == _gps.params[j].override_node_id) {
                    bad_override_config = true;
                }
            }
            if (bad_override_config) {
                GCS_SEND_TEXT(MAV_SEVERITY_ERROR, "Same Node Id %lu set for multiple GPS", (unsigned long int)_gps.params[i].override_node_id.get());
                last_match = i;
            }

            if (found_match == -1) {
                found_match = last_match;
                continue;
            }
            break;
        }
    }

    if (found_match == -1) {
        return NULL;
    }
    // initialise the backend based on the UAVCAN Moving baseline selection
    switch (_gps.get_type(_state.instance)) {
        case AP_GPS::GPS_TYPE_UAVCAN:
            backend = NEW_NOTHROW AP_GPS_DroneCAN(_gps, _gps.params[_state.instance], _state, AP_GPS::GPS_ROLE_NORMAL);
            break;
#if GPS_MOVING_BASELINE
        case AP_GPS::GPS_TYPE_UAVCAN_RTK_BASE:
            backend = NEW_NOTHROW AP_GPS_DroneCAN(_gps, _gps.params[_state.instance], _state, AP_GPS::GPS_ROLE_MB_BASE);
            break;
        case AP_GPS::GPS_TYPE_UAVCAN_RTK_ROVER:
            backend = NEW_NOTHROW AP_GPS_DroneCAN(_gps, _gps.params[_state.instance], _state, AP_GPS::GPS_ROLE_MB_ROVER);
            break;
#endif
        default:
            return NULL;
    }
    if (backend == nullptr) {
        AP::can().log_text(AP_CANManager::LOG_ERROR,
                            LOG_TAG,
                            "Failed to register DroneCAN GPS Node %d on Bus %d\n",
                            _detected_modules[found_match].node_id,
                            _detected_modules[found_match].ap_dronecan->get_driver_index());
    } else {
        _detected_modules[found_match].driver = backend;
        backend->_detected_module = found_match;
        AP::can().log_text(AP_CANManager::LOG_INFO,
                            LOG_TAG,
                            "Registered DroneCAN GPS Node %d on Bus %d as instance %d\n",
                            _detected_modules[found_match].node_id,
                            _detected_modules[found_match].ap_dronecan->get_driver_index(),
                            _state.instance);
        snprintf(backend->_name, ARRAY_SIZE(backend->_name), "DroneCAN%u-%u", _detected_modules[found_match].ap_dronecan->get_driver_index()+1, _detected_modules[found_match].node_id);
        _detected_modules[found_match].instance = _state.instance;
        for (uint8_t i=0; i < GPS_MAX_RECEIVERS; i++) {
            if (_detected_modules[found_match].node_id == AP::gps().params[i].node_id) {
                if (i == _state.instance) {
                    // Nothing to do here
                    break;
                }
                // else swap
                uint8_t tmp = AP::gps().params[_state.instance].node_id.get();
                AP::gps().params[_state.instance].node_id.set_and_notify(_detected_modules[found_match].node_id);
                AP::gps().params[i].node_id.set_and_notify(tmp);
            }
        }
#if GPS_MOVING_BASELINE
        if (backend->role == AP_GPS::GPS_ROLE_MB_BASE) {
            backend->rtcm3_parser = NEW_NOTHROW RTCM3_Parser;
            if (backend->rtcm3_parser == nullptr) {
                GCS_SEND_TEXT(MAV_SEVERITY_ERROR, "DroneCAN%u-%u: failed RTCMv3 parser allocation", _detected_modules[found_match].ap_dronecan->get_driver_index()+1, _detected_modules[found_match].node_id);
            }
        }
#endif // GPS_MOVING_BASELINE
    }

    return backend;
}

bool AP_GPS_DroneCAN::inter_instance_pre_arm_checks(char failure_msg[], uint16_t failure_msg_len)
{
    // lint parameters and detected node IDs:
    for (uint8_t i = 0; i < GPS_MAX_RECEIVERS; i++) {
        const auto &params_i = AP::gps().params[i];
        // we are only interested in parameters for DroneCAN GPSs:
        if (!is_dronecan_gps_type(params_i.type)) {
            continue;
        }
        bool overriden_node_found = false;
        bool bad_override_config = false;
        if (params_i.override_node_id == 0) {
            //anything goes
            continue;
        }
        for (uint8_t j = 0; j < GPS_MAX_RECEIVERS; j++) {
            const auto &params_j = AP::gps().params[j];
            // we are only interested in parameters for DroneCAN GPSs:
            if (!is_dronecan_gps_type(params_j.type)) {
                continue;
            }
            if (params_i.override_node_id == params_j.override_node_id && (i != j)) {
                bad_override_config = true;
                break;
            }
            if (i == _detected_modules[j].instance && _detected_modules[j].driver) {
                if (params_i.override_node_id == _detected_modules[j].node_id) {
                    overriden_node_found = true;
                    break;
                }
            }
        }
        if (bad_override_config) {
            snprintf(failure_msg, failure_msg_len, "Same Node Id %lu set for multiple GPS", (unsigned long int)params_i.override_node_id.get());
            return false;
        }

        if (!overriden_node_found) {
            snprintf(failure_msg, failure_msg_len, "Selected GPS Node %lu not set as instance %d", (unsigned long int)params_i.override_node_id.get(), i + 1);
            return false;
        }
    }

    return true;
}

AP_GPS_DroneCAN* AP_GPS_DroneCAN::get_dronecan_backend(AP_DroneCAN* ap_dronecan, uint8_t node_id)
{
    if (ap_dronecan == nullptr) {
        return nullptr;
    }

    for (uint8_t i = 0; i < GPS_MAX_RECEIVERS; i++) {
        if (_detected_modules[i].driver != nullptr &&
            _detected_modules[i].ap_dronecan == ap_dronecan && 
            _detected_modules[i].node_id == node_id) {
            return _detected_modules[i].driver;
        }
    }

    bool already_detected = false;
    // Check if there's an empty spot for possible registeration
    for (uint8_t i = 0; i < GPS_MAX_RECEIVERS; i++) {
        if (_detected_modules[i].ap_dronecan == ap_dronecan && _detected_modules[i].node_id == node_id) {
            // Already Detected
            already_detected = true;
            break;
        }
    }
    if (!already_detected) {
        for (uint8_t i = 0; i < GPS_MAX_RECEIVERS; i++) {
            if (_detected_modules[i].ap_dronecan == nullptr) {
                _detected_modules[i].ap_dronecan = ap_dronecan;
                _detected_modules[i].node_id = node_id;
                // Just set the Node ID in order of appearance
                // This will be used to set select ids
                AP::gps().params[i].node_id.set_and_notify(node_id);
                break;
            }
        }
    }
    struct DetectedModules tempslot;
    // Sort based on the node_id, larger values first
    // we do this, so that we have repeatable GPS
    // registration
    for (uint8_t i = 1; i < GPS_MAX_RECEIVERS; i++) {
        for (uint8_t j = i; j > 0; j--) {
            if (_detected_modules[j].node_id > _detected_modules[j-1].node_id) {
                tempslot = _detected_modules[j];
                _detected_modules[j] = _detected_modules[j-1];
                _detected_modules[j-1] = tempslot;
                // also fix the _detected_module in the driver so that RTCM injection
                // can determine if it has the bus to itself
                if (_detected_modules[j].driver) {
                    _detected_modules[j].driver->_detected_module = j;
                }
                if (_detected_modules[j-1].driver) {
                    _detected_modules[j-1].driver->_detected_module = j-1;
                }
            }
        }
    }
    return nullptr;
}

/*
  handle velocity element of message
 */
void AP_GPS_DroneCAN::handle_velocity(const float vx, const float vy, const float vz)
{
    if (!isnan(vx)) {
        const Vector3f vel(vx, vy, vz);
        interim_state.velocity = vel;
        velocity_to_speed_course(interim_state);
        // assume we have vertical velocity if we ever get a non-zero Z velocity
        if (!isnan(vel.z) && !is_zero(vel.z)) {
            interim_state.have_vertical_velocity = true;
        } else {
            interim_state.have_vertical_velocity = state.have_vertical_velocity;
        }
    } else {
        interim_state.have_vertical_velocity = false;
    }
}

void AP_GPS_DroneCAN::handle_fix2_msg(const uavcan_equipment_gnss_Fix2& msg, uint64_t timestamp_usec)
{
    bool process = false;
    seen_fix2 = true;

    WITH_SEMAPHORE(sem);

    if (msg.status == UAVCAN_EQUIPMENT_GNSS_FIX2_STATUS_NO_FIX) {
        interim_state.status = AP_GPS::GPS_Status::NO_FIX;
    } else {
        if (msg.status == UAVCAN_EQUIPMENT_GNSS_FIX2_STATUS_TIME_ONLY) {
            interim_state.status = AP_GPS::GPS_Status::NO_FIX;
        } else if (msg.status == UAVCAN_EQUIPMENT_GNSS_FIX2_STATUS_2D_FIX) {
            interim_state.status = AP_GPS::GPS_Status::GPS_OK_FIX_2D;
            process = true;
        } else if (msg.status == UAVCAN_EQUIPMENT_GNSS_FIX2_STATUS_3D_FIX) {
            interim_state.status = AP_GPS::GPS_Status::GPS_OK_FIX_3D;
            process = true;
        }

        if (msg.gnss_time_standard == UAVCAN_EQUIPMENT_GNSS_FIX2_GNSS_TIME_STANDARD_UTC) {
            uint64_t epoch_ms = msg.gnss_timestamp.usec;
            if (epoch_ms != 0) {
                epoch_ms /= 1000;
                uint64_t gps_ms = epoch_ms - UNIX_OFFSET_MSEC;
                interim_state.time_week = (uint16_t)(gps_ms / AP_MSEC_PER_WEEK);
                interim_state.time_week_ms = (uint32_t)(gps_ms - (interim_state.time_week) * AP_MSEC_PER_WEEK);
            }
        }

        if (interim_state.status == AP_GPS::GPS_Status::GPS_OK_FIX_3D) {
            if (msg.mode == UAVCAN_EQUIPMENT_GNSS_FIX2_MODE_DGPS) {
                interim_state.status = AP_GPS::GPS_Status::GPS_OK_FIX_3D_DGPS;
            } else if (msg.mode == UAVCAN_EQUIPMENT_GNSS_FIX2_MODE_RTK) {
                if (msg.sub_mode == UAVCAN_EQUIPMENT_GNSS_FIX2_SUB_MODE_RTK_FLOAT) {
                    interim_state.status = AP_GPS::GPS_Status::GPS_OK_FIX_3D_RTK_FLOAT;
                } else if (msg.sub_mode == UAVCAN_EQUIPMENT_GNSS_FIX2_SUB_MODE_RTK_FIXED) {
                    interim_state.status = AP_GPS::GPS_Status::GPS_OK_FIX_3D_RTK_FIXED;
                }
            }
        }
    }

    if (process) {
        Location loc = { };
        loc.lat = msg.latitude_deg_1e8 / 10;
        loc.lng = msg.longitude_deg_1e8 / 10;
        const int32_t alt_amsl_cm = msg.height_msl_mm / 10;
        interim_state.have_undulation = true;
        interim_state.undulation = (msg.height_msl_mm - msg.height_ellipsoid_mm) * 0.001;
        interim_state.location = loc;
        set_alt_amsl_cm(interim_state, alt_amsl_cm);

        handle_velocity(msg.ned_velocity[0], msg.ned_velocity[1], msg.ned_velocity[2]);

        if (msg.covariance.len == 6) {
            if (!isnan(msg.covariance.data[0])) {
                interim_state.horizontal_accuracy = sqrtf(msg.covariance.data[0]);
                interim_state.have_horizontal_accuracy = true;
            } else {
                interim_state.have_horizontal_accuracy = false;
            }
            if (!isnan(msg.covariance.data[2])) {
                interim_state.vertical_accuracy = sqrtf(msg.covariance.data[2]);
                interim_state.have_vertical_accuracy = true;
            } else {
                interim_state.have_vertical_accuracy = false;
            }
            if (!isnan(msg.covariance.data[3]) &&
                !isnan(msg.covariance.data[4]) &&
                !isnan(msg.covariance.data[5])) {
                interim_state.speed_accuracy = sqrtf((msg.covariance.data[3] + msg.covariance.data[4] + msg.covariance.data[5])/3);
                interim_state.have_speed_accuracy = true;
            } else {
                interim_state.have_speed_accuracy = false;
            }
        }

        interim_state.num_sats = msg.sats_used;
    } else {
        interim_state.have_vertical_velocity = false;
        interim_state.have_vertical_accuracy = false;
        interim_state.have_horizontal_accuracy = false;
        interim_state.have_speed_accuracy = false;
        interim_state.num_sats = 0;
    }

    if (!seen_aux) {
        // if we haven't seen an Aux message then populate vdop and
        // hdop from pdop. Some GPS modules don't provide the Aux message
        interim_state.hdop = interim_state.vdop = msg.pdop * 100.0;
    }

    if ((msg.timestamp.usec > msg.gnss_timestamp.usec) && (msg.gnss_timestamp.usec > 0)) {
        // we have a valid timestamp based on gnss_timestamp timescale, we can use that to correct our gps message time
        interim_state.last_corrected_gps_time_us = jitter_correction.correct_offboard_timestamp_usec(msg.timestamp.usec, (timestamp_usec + NATIVE_TIME_OFFSET));
        interim_state.last_gps_time_ms = interim_state.last_corrected_gps_time_us/1000U;
        interim_state.last_corrected_gps_time_us -= msg.timestamp.usec - msg.gnss_timestamp.usec;
        // this is also the time the message was received on the UART on other end.
        interim_state.corrected_timestamp_updated = true;
    } else {
        interim_state.last_gps_time_ms = jitter_correction.correct_offboard_timestamp_usec(msg.timestamp.usec, timestamp_usec + NATIVE_TIME_OFFSET)/1000U;
    }

#if GPS_PPS_EMULATION
    // Emulates a PPS signal, can be used to check how close are we to real GPS time
    static virtual_timer_t timeout_vt;
    hal.gpio->pinMode(51, 1);
    auto handle_timeout = [](void *arg)
    {
        (void)arg;
        //we are called from ISR context
        chSysLockFromISR();
        hal.gpio->toggle(51);
        chSysUnlockFromISR();
    };

    static uint64_t next_toggle, last_toggle;
    
    next_toggle = (msg.timestamp.usec) + (1000000ULL - ((msg.timestamp.usec) % 1000000ULL));

    next_toggle += jitter_correction.get_link_offset_usec();
    if (next_toggle != last_toggle) {
        chVTSet(&timeout_vt, chTimeUS2I(next_toggle - AP_HAL::micros64()), handle_timeout, nullptr);
        last_toggle = next_toggle;
    }
#endif

    _new_data = true;
    if (!seen_message) {
        if (interim_state.status == AP_GPS::GPS_Status::NO_GPS) {
            // the first time we see a fix message we change from
            // NO_GPS to NO_FIX, indicating to user that a DroneCAN GPS
            // has been seen
            interim_state.status = AP_GPS::GPS_Status::NO_FIX;
        }
        seen_message = true;
    }
}

void AP_GPS_DroneCAN::handle_aux_msg(const uavcan_equipment_gnss_Auxiliary& msg)
{
    WITH_SEMAPHORE(sem);

    if (!isnan(msg.hdop)) {
        seen_aux = true;
        interim_state.hdop = msg.hdop * 100.0;
    }

    if (!isnan(msg.vdop)) {
        seen_aux = true;
        interim_state.vdop = msg.vdop * 100.0;
    }
}

void AP_GPS_DroneCAN::handle_heading_msg(const ardupilot_gnss_Heading& msg)
{
#if GPS_MOVING_BASELINE
    if (seen_relposheading && gps.params[interim_state.instance].mb_params.type.get() != 0) {
        // we prefer to use the relposheading to get yaw as it allows
        // the user to more easily control the relative antenna positions
        return;
    }
#endif

    WITH_SEMAPHORE(sem);

    if (interim_state.gps_yaw_configured == false) {
        interim_state.gps_yaw_configured = msg.heading_valid;
    }

    interim_state.have_gps_yaw = msg.heading_valid;
    interim_state.gps_yaw = degrees(msg.heading_rad);
    if (interim_state.have_gps_yaw) {
        interim_state.gps_yaw_time_ms = AP_HAL::millis();
    }

    interim_state.have_gps_yaw_accuracy = msg.heading_accuracy_valid;
    interim_state.gps_yaw_accuracy = degrees(msg.heading_accuracy_rad);
}

void AP_GPS_DroneCAN::handle_status_msg(const ardupilot_gnss_Status& msg)
{
    WITH_SEMAPHORE(sem);

    seen_status = true;

    healthy = msg.healthy;
    status_flags = msg.status;
    if (error_code != msg.error_codes) {
#if HAL_LOGGING_ENABLED
        AP::logger().Write_MessageF("GPS %d: error changed (0x%08x/0x%08x)",
                                    (unsigned int)(state.instance + 1),
                                    error_code,
                                    msg.error_codes);
#endif
        error_code = msg.error_codes;
    }
}

#if GPS_MOVING_BASELINE
/*
  handle moving baseline data.
  */
void AP_GPS_DroneCAN::handle_moving_baseline_msg(const ardupilot_gnss_MovingBaselineData& msg, uint8_t node_id)
{
    WITH_SEMAPHORE(sem);
    if (role != AP_GPS::GPS_ROLE_MB_BASE) {
        GCS_SEND_TEXT(MAV_SEVERITY_ERROR, "Incorrect Role set for DroneCAN GPS, %d should be Base", node_id);
        return;
    }

    if (rtcm3_parser == nullptr) {
        return;
    }
    for (int i=0; i < msg.data.len; i++) {
        rtcm3_parser->read(msg.data.data[i]);
    }
}

/*
    handle relposheading message
*/
void AP_GPS_DroneCAN::handle_relposheading_msg(const ardupilot_gnss_RelPosHeading& msg, uint8_t node_id)
{
    WITH_SEMAPHORE(sem);

    interim_state.gps_yaw_configured = true;
    seen_relposheading = true;
    // push raw heading data to calculate moving baseline heading states
    if (calculate_moving_base_yaw(interim_state,
                                msg.reported_heading_deg,
                                msg.relative_distance_m,
                                msg.relative_down_pos_m)) {
        if (msg.reported_heading_acc_available) {
            interim_state.gps_yaw_accuracy = msg.reported_heading_acc_deg;
        }
        interim_state.have_gps_yaw_accuracy = msg.reported_heading_acc_available;
    }
}

// support for retrieving RTCMv3 data from a moving baseline base
bool AP_GPS_DroneCAN::get_RTCMV3(const uint8_t *&bytes, uint16_t &len)
{
    WITH_SEMAPHORE(sem);
    if (rtcm3_parser != nullptr) {
        len = rtcm3_parser->get_len(bytes);
        return len > 0;
    }
    return false;
}

// clear previous RTCM3 packet
void AP_GPS_DroneCAN::clear_RTCMV3(void)
{
    WITH_SEMAPHORE(sem);
    if (rtcm3_parser != nullptr) {
        rtcm3_parser->clear_packet();
    }
}

#endif // GPS_MOVING_BASELINE

void AP_GPS_DroneCAN::handle_fix2_msg_trampoline(AP_DroneCAN *ap_dronecan, const CanardRxTransfer& transfer, const uavcan_equipment_gnss_Fix2& msg)
{
    WITH_SEMAPHORE(_sem_registry);

    AP_GPS_DroneCAN* driver = get_dronecan_backend(ap_dronecan, transfer.source_node_id);
    if (driver != nullptr) {
        driver->handle_fix2_msg(msg, transfer.timestamp_usec);
    }
}

void AP_GPS_DroneCAN::handle_aux_msg_trampoline(AP_DroneCAN *ap_dronecan, const CanardRxTransfer& transfer, const uavcan_equipment_gnss_Auxiliary& msg)
{
    WITH_SEMAPHORE(_sem_registry);

    AP_GPS_DroneCAN* driver = get_dronecan_backend(ap_dronecan, transfer.source_node_id);
    if (driver != nullptr) {
        driver->handle_aux_msg(msg);
    }
}

void AP_GPS_DroneCAN::handle_heading_msg_trampoline(AP_DroneCAN *ap_dronecan, const CanardRxTransfer& transfer, const ardupilot_gnss_Heading& msg)
{
    WITH_SEMAPHORE(_sem_registry);

    AP_GPS_DroneCAN* driver = get_dronecan_backend(ap_dronecan, transfer.source_node_id);
    if (driver != nullptr) {
        driver->handle_heading_msg(msg);
    }
}

void AP_GPS_DroneCAN::handle_status_msg_trampoline(AP_DroneCAN *ap_dronecan, const CanardRxTransfer& transfer, const ardupilot_gnss_Status& msg)
{
    WITH_SEMAPHORE(_sem_registry);

    AP_GPS_DroneCAN* driver = get_dronecan_backend(ap_dronecan, transfer.source_node_id);
    if (driver != nullptr) {
        driver->handle_status_msg(msg);
    }
}

#if GPS_MOVING_BASELINE
// Moving Baseline msg trampoline
void AP_GPS_DroneCAN::handle_moving_baseline_msg_trampoline(AP_DroneCAN *ap_dronecan, const CanardRxTransfer& transfer, const ardupilot_gnss_MovingBaselineData& msg)
{
    WITH_SEMAPHORE(_sem_registry);
    AP_GPS_DroneCAN* driver = get_dronecan_backend(ap_dronecan, transfer.source_node_id);
    if (driver != nullptr) {
        driver->handle_moving_baseline_msg(msg, transfer.source_node_id);
    }
}

// RelPosHeading msg trampoline
void AP_GPS_DroneCAN::handle_relposheading_msg_trampoline(AP_DroneCAN *ap_dronecan, const CanardRxTransfer& transfer, const ardupilot_gnss_RelPosHeading& msg)
{
    WITH_SEMAPHORE(_sem_registry);
    AP_GPS_DroneCAN* driver = get_dronecan_backend(ap_dronecan, transfer.source_node_id);
    if (driver != nullptr) {
        driver->handle_relposheading_msg(msg, transfer.source_node_id);
    }
}
#endif

bool AP_GPS_DroneCAN::do_config()
{
    AP_DroneCAN *ap_dronecan = _detected_modules[_detected_module].ap_dronecan;
    if (ap_dronecan == nullptr) {
        return false;
    }
    uint8_t node_id = _detected_modules[_detected_module].node_id;
    
    switch(cfg_step) {
        case STEP_SET_TYPE:
            // GPS_TYPE was renamed GPS1_TYPE.  Request both and
            // handle whichever we receive.
            ap_dronecan->get_parameter_on_node(node_id, "GPS_TYPE", &param_int_cb);
            ap_dronecan->get_parameter_on_node(node_id, "GPS1_TYPE", &param_int_cb);
            break;
        case STEP_SET_MB_CAN_TX:
            if (role != AP_GPS::GPS_Role::GPS_ROLE_NORMAL) {
                ap_dronecan->get_parameter_on_node(node_id, "GPS_MB_ONLY_PORT", &param_int_cb);
            } else {
                cfg_step++;
            }
            break;
        case STEP_SAVE_AND_REBOOT:
            if (requires_save_and_reboot) {
                ap_dronecan->save_parameters_on_node(node_id, &param_save_cb);
            } else {
                cfg_step++;
            }
            break;
        case STEP_FINISHED:
            return true;
        default:
            break;
    }
    return false;
}

// Consume new data and mark it received
bool AP_GPS_DroneCAN::read(void)
{
    if (gps._auto_config >= AP_GPS::GPS_AUTO_CONFIG_ENABLE_ALL) {
        if (!do_config()) {
            return false;
        }
    }

    WITH_SEMAPHORE(sem);

    send_rtcm();

    if (_new_data) {
        _new_data = false;

        // the encoding of accuracies in DroneCAN can result in infinite
        // values. These cause problems with blending. Use 1000m and 1000m/s instead
        interim_state.horizontal_accuracy = MIN(interim_state.horizontal_accuracy, 1000.0);
        interim_state.vertical_accuracy = MIN(interim_state.vertical_accuracy, 1000.0);
        interim_state.speed_accuracy = MIN(interim_state.speed_accuracy, 1000.0);

        // prevent announcing multiple times
        interim_state.announced_detection = state.announced_detection;

        state = interim_state;
        if (interim_state.last_corrected_gps_time_us) {
            // If we were able to get a valid last_corrected_gps_time_us
            // we have had a valid GPS message time, from which we calculate
            // the time of week.
            _last_itow_ms = interim_state.time_week_ms;
            _have_itow = true;
        }
        return true;
    }
    if (!seen_message) {
        // start with NO_GPS until we get first packet
        state.status = AP_GPS::GPS_Status::NO_GPS;
    }

    return false;
}

bool AP_GPS_DroneCAN::is_healthy(void) const
{
    // if we don't have any health reports, assume it's healthy
    if (!seen_status) {
        return true;
    }
    return healthy;
}

bool AP_GPS_DroneCAN::logging_healthy(void) const
{
    // if we don't have status, assume it's valid
    if (!seen_status) {
        return true;
    }

    return (status_flags & ARDUPILOT_GNSS_STATUS_STATUS_LOGGING) != 0;
}

bool AP_GPS_DroneCAN::is_configured(void) const
{
    // if we don't have status assume it's configured
    if (!seen_status) {
        return true;
    }

    return (status_flags & ARDUPILOT_GNSS_STATUS_STATUS_ARMABLE) != 0;
}

/*
  send pending RTCM data
 */
void AP_GPS_DroneCAN::send_rtcm(void)
{
    if (_rtcm_stream.buf == nullptr) {
        return;
    }
    WITH_SEMAPHORE(sem);

    const uint32_t now = AP_HAL::millis();
    if (now - _rtcm_stream.last_send_ms < 20) {
        // don't send more than 50 per second
        return;
    }
    uint32_t outlen = 0;
    const uint8_t *ptr = _rtcm_stream.buf->readptr(outlen);
    if (ptr == nullptr || outlen == 0) {
        return;
    }
    uavcan_equipment_gnss_RTCMStream msg {};
    outlen = MIN(outlen, sizeof(msg.data.data));
    msg.protocol_id = UAVCAN_EQUIPMENT_GNSS_RTCMSTREAM_PROTOCOL_ID_RTCM3;
    memcpy(msg.data.data, ptr, outlen);
    msg.data.len = outlen;
    if (_detected_modules[_detected_module].ap_dronecan->rtcm_stream.broadcast(msg)) {
        _rtcm_stream.buf->advance(outlen);
        _rtcm_stream.last_send_ms = now;
    }
}

/*
  handle RTCM data from MAVLink GPS_RTCM_DATA, forwarding it over MAVLink
 */
void AP_GPS_DroneCAN::inject_data(const uint8_t *data, uint16_t len)
{
    // we only handle this if we are the first DroneCAN GPS or we are
    // using a different uavcan instance than the first GPS, as we
    // send the data as broadcast on all DroneCAN device ports and we
    // don't want to send duplicates
    const uint32_t now_ms = AP_HAL::millis();
    if (_detected_module == 0 ||
        _detected_modules[_detected_module].ap_dronecan != _detected_modules[0].ap_dronecan ||
        now_ms - _detected_modules[0].last_inject_ms > 2000) {
        if (_rtcm_stream.buf == nullptr) {
            // give enough space for a full round from a NTRIP server with all
            // constellations
            _rtcm_stream.buf = NEW_NOTHROW ByteBuffer(2400);
            if (_rtcm_stream.buf == nullptr) {
                return;
            }
        }
        _detected_modules[_detected_module].last_inject_ms = now_ms;
        _rtcm_stream.buf->write(data, len);
        send_rtcm();
    }
}

/*
    handle param get/set response
*/
bool AP_GPS_DroneCAN::handle_param_get_set_response_int(AP_DroneCAN* ap_dronecan, uint8_t node_id, const char* name, int32_t &value)
{
    Debug("AP_GPS_DroneCAN: param set/get response from %d %s %ld\n", node_id, name, value);
    if (((strcmp(name, "GPS_TYPE") == 0) || (strcmp(name, "GPS1_TYPE") == 0)) && (cfg_step == STEP_SET_TYPE)) {
        if (role == AP_GPS::GPS_ROLE_MB_BASE && value != AP_GPS::GPS_TYPE_UBLOX_RTK_BASE) {
            value = (int32_t)AP_GPS::GPS_TYPE_UBLOX_RTK_BASE;
            requires_save_and_reboot = true;
            return true;
        } else if (role == AP_GPS::GPS_ROLE_MB_ROVER && value != AP_GPS::GPS_TYPE_UBLOX_RTK_ROVER) {
            value = (int32_t)AP_GPS::GPS_TYPE_UBLOX_RTK_ROVER;
            requires_save_and_reboot = true;
            return true;
        } else {
            cfg_step++;
        }
    }

    if (strcmp(name, "GPS_MB_ONLY_PORT") == 0 && cfg_step == STEP_SET_MB_CAN_TX) {
        if (option_set(AP_GPS::UAVCAN_MBUseDedicatedBus) && !value) {
            // set up so that another CAN port is used for the Moving Baseline Data
            // setting this value will allow another CAN port to be used as dedicated
            // line for the Moving Baseline Data
            value = 1;
            requires_save_and_reboot = true;
            return true;
        } else if (!option_set(AP_GPS::UAVCAN_MBUseDedicatedBus) && value) {
            // set up so that all CAN ports are used for the Moving Baseline Data
            value = 0;
            requires_save_and_reboot = true;
            return true;
        } else {
            cfg_step++;
        }
    }
    return false;
}

bool AP_GPS_DroneCAN::handle_para/*
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

//
//  Mavlink GPS driver which accepts gps position data from an external
//  companion computer
//
#pragma once

#include "AP_GPS_config.h"

#if AP_GPS_MAV_ENABLED

#include <AP_HAL/AP_HAL_Boards.h>

#include "AP_GPS.h"
#include "GPS_Backend.h"

class AP_GPS_MAV : public AP_GPS_Backend {
public:

    using AP_GPS_Backend::AP_GPS_Backend;

    bool read() override;

    static bool _detect(struct MAV_detect_state &state, uint8_t data);

    void handle_msg(const mavlink_message_t &msg) override;

    const char *name() const override { return "MAV"; }

private:
    bool _new_data;
    uint32_t first_week;
    JitterCorrection jitter{2000};
};

#endif  // AP_GPS_MAV_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           /*
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

//
//  MSP GPS driver
//
#include <AP_MSP/msp.h>
#include "AP_GPS_MSP.h"

#if HAL_MSP_GPS_ENABLED

// Reading does nothing in this class; we simply return whether or not
// the latest reading has been consumed.  By calling this function we assume
// the caller is consuming the new data;
bool AP_GPS_MSP::read(void)
{
    if (new_data) {
        new_data = false;
        return true;
    }
    return false;
}

// handles an incoming msp message and sets
// corresponding gps data appropriately;
void AP_GPS_MSP::handle_msp(const MSP::msp_gps_data_message_t &pkt)
{
    check_new_itow(pkt.ms_tow, sizeof(pkt));

    state.time_week = pkt.gps_week;
    state.time_week_ms = pkt.ms_tow;
    state.status = (AP_GPS::GPS_Status)pkt.fix_type;
    state.num_sats = pkt.satellites_in_view;

    Location loc = {};
    loc.lat = pkt.latitude;
    loc.lng = pkt.longitude;
    loc.alt = pkt.msl_altitude;

    state.location = loc;
    state.hdop = pkt.hdop;
    state.vdop = GPS_UNKNOWN_DOP;

    state.have_vertical_velocity = true;
    Vector3f vel;
    vel.x = pkt.ned_vel_north * 0.01;
    vel.y = pkt.ned_vel_east * 0.01;
    vel.z = pkt.ned_vel_down * 0.01;
    state.velocity = vel;

    velocity_to_speed_course(state);

    state.have_speed_accuracy = true;
    state.have_horizontal_accuracy = true;
    state.have_vertical_accuracy = true;
    state.have_vertical_velocity = true;

    state.horizontal_accuracy = pkt.horizontal_pos_accuracy * 0.01;
    state.vertical_accuracy = pkt.vertical_pos_accuracy * 0.01;
    state.speed_accuracy = pkt.horizontal_vel_accuracy * 0.01;

    state.last_gps_time_ms = AP_HAL::millis();

    if (pkt.true_yaw != 65535) {
        state.gps_yaw = wrap_360(pkt.true_yaw*0.01);
        state.have_gps_yaw = true;
        state.gps_yaw_time_ms = state.last_gps_time_ms;
    }

    new_data = pkt.fix_type>0;
}

/*
  return velocity lag in seconds
 */
bool AP_GPS_MSP::get_lag(float &lag_sec) const
{
    // measured on Matek M8Q
    lag_sec = 0.11;
    return true;
}

#endif // HAL_MSP_GPS_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  /*
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

//
//  MSP GPS driver which accepts gps position data from an external source
//
#pragma once

#include <AP_Common/AP_Common.h>
#include <AP_HAL/AP_HAL.h>

#include "AP_GPS.h"
#include "GPS_Backend.h"

#if HAL_MSP_GPS_ENABLED

class AP_GPS_MSP : public AP_GPS_Backend
{
public:

    using AP_GPS_Backend::AP_GPS_Backend;

    bool read() override;
    void handle_msp(const MSP::msp_gps_data_message_t &pkt) override;

    const char *name() const override { return "MSP"; }

    bool get_lag(float &lag_sec) const override;

private:
    bool new_data;
};

#endif // HAL_MSP_GPS_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          /*
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

//
// NMEA parser, adapted by Michael Smith from TinyGPS v9:
//
// TinyGPS - a small GPS library for Arduino providing basic NMEA parsing
// Copyright (C) 2008-9 Mikal Hart
// All rights reserved.
//

/// @file	AP_GPS_NMEA.cpp
/// @brief	NMEA protocol parser
///
/// This is a lightweight NMEA parser, derived originally from the
/// TinyGPS parser by Mikal Hart.
///

#include <AP_Common/AP_Common.h>
#include <AP_Common/NMEA.h>
#include <GCS_MAVLink/GCS.h>
#include <AP_Logger/AP_Logger.h>

#include <ctype.h>
#include <stdint.h>
#include <stdlib.h>
#include <stdio.h>

#include "AP_GPS_NMEA.h"

#if AP_GPS_NMEA_ENABLED
extern const AP_HAL::HAL& hal;

#ifndef AP_GPS_NMEA_CONFIG_PERIOD_MS
// how often we send board specific config commands
#define AP_GPS_NMEA_CONFIG_PERIOD_MS 15000U
#endif

// a quiet nan for invalid values
#define QNAN nanf("GPS")

// Convenience macros //////////////////////////////////////////////////////////
//
#define DIGIT_TO_VAL(_x)        (_x - '0')
#define hexdigit(x) ((x)>9?'A'+((x)-10):'0'+(x))

bool AP_GPS_NMEA::read(void)
{
    int16_t numc;
    bool parsed = false;

    send_config();

    numc = port->available();
    while (numc--) {
        char c = port->read();
#if AP_GPS_DEBUG_LOGGING_ENABLED
        log_data((const uint8_t *)&c, 1);
#endif
        if (_decode(c)) {
            parsed = true;
        }
    }
    return parsed;
}

/*
  decode one character, return true if we have successfully completed a sentence, false otherwise
 */
bool AP_GPS_NMEA::_decode(char c)
{
    _sentence_length++;
        
    switch (c) {
    case ';':
        // header separator for unicore
        if (!_is_unicore) {
            return false;
        }
        FALLTHROUGH;
    case ',': // term terminators
        _parity ^= c;
        if (_is_unicore) {
            _crc32 = crc_crc32(_crc32, (const uint8_t *)&c, 1);
        }
        FALLTHROUGH;
    case '\r':
    case '\n':
    case '*': {
        if (_sentence_done) {
            return false;
        }
        bool valid_sentence = false;
        if (_term_offset < sizeof(_term)) {
            _term[_term_offset] = 0;
            valid_sentence = _term_complete();
        }
        ++_term_number;
        _term_offset = 0;
        _is_checksum_term = c == '*';
        return valid_sentence;
    }

    case '$': // sentence begin
    case '#': // unicore message begin
        _is_unicore = (c == '#');
        _term_number = _term_offset = 0;
        _parity = 0;
        _crc32 = 0;
        _sentence_type = _GPS_SENTENCE_OTHER;
        _is_checksum_term = false;
        _sentence_length = 1;
        _sentence_done = false;
        _new_gps_yaw = QNAN;
        return false;
    }

    // ordinary characters
    if (_term_offset < sizeof(_term) - 1)
        _term[_term_offset++] = c;
    if (!_is_checksum_term) {
        _parity ^= c;
        if (_is_unicore) {
            _crc32 = crc_crc32(_crc32, (const uint8_t *)&c, 1);
        }
    }

    return false;
}

int32_t AP_GPS_NMEA::_parse_decimal_100(const char *p)
{
    char *endptr = nullptr;
    long ret = 100 * strtol(p, &endptr, 10);
    int sign = ret < 0 ? -1 : 1;

    if (ret >= (long)INT32_MAX) {
        return INT32_MAX;
    }
    if (ret <= (long)INT32_MIN) {
        return INT32_MIN;
    }
    if (endptr == nullptr || *endptr != '.') {
        return ret;
    }

    if (isdigit(endptr[1])) {
        ret += sign * 10 * DIGIT_TO_VAL(endptr[1]);
        if (isdigit(endptr[2])) {
            ret += sign * DIGIT_TO_VAL(endptr[2]);
            if (isdigit(endptr[3])) {
                ret += sign * (DIGIT_TO_VAL(endptr[3]) >= 5);
            }
        }
    }
    return ret;
}

/*
  parse a NMEA latitude/longitude degree value. The result is in degrees*1e7
 */
uint32_t AP_GPS_NMEA::_parse_degrees()
{
    char *p, *q;
    uint8_t deg = 0, min = 0;
    float frac_min = 0;
    int32_t ret = 0;

    // scan for decimal point or end of field
    for (p = _term; *p && isdigit(*p); p++)
        ;
    q = _term;

    // convert degrees
    while ((p - q) > 2 && *q) {
        if (deg)
            deg *= 10;
        deg += DIGIT_TO_VAL(*q++);
    }

    // convert minutes
    while (p > q && *q) {
        if (min)
            min *= 10;
        min += DIGIT_TO_VAL(*q++);
    }

    // convert fractional minutes
    if (*p == '.') {
        q = p + 1;
        float frac_scale = 0.1f;
        while (*q && isdigit(*q)) {
            frac_min += DIGIT_TO_VAL(*q) * frac_scale;
            q++;
            frac_scale *= 0.1f;
        }
    }
    ret = (deg * (int32_t)10000000UL);
    ret += (min * (int32_t)10000000UL / 60);
    ret += (int32_t) (frac_min * (1.0e7f / 60.0f));
    return ret;
}

/*
  see if we have a new set of NMEA messages
 */
bool AP_GPS_NMEA::_have_new_message()
{
    if (_last_RMC_ms == 0 ||
        _last_GGA_ms == 0) {
        return false;
    }
    uint32_t now = AP_HAL::millis();
    if (now - _last_RMC_ms > 150 ||
        now - _last_GGA_ms > 150) {
        return false;
    }
    if (_last_VTG_ms != 0 && 
        now - _last_VTG_ms > 150) {
        return false;
    }

    /*
      if we have seen a message with 3D velocity data messages then
      wait for them again. This is important as the
      have_vertical_velocity field will be overwritten by
      fill_3d_velocity()
     */
    if (_last_vvelocity_ms != 0 &&
        now - _last_vvelocity_ms > 150 &&
        now - _last_vvelocity_ms < 1000) {
        // waiting on a message with velocity
        return false;
    }
    if (_last_vaccuracy_ms != 0 &&
        now - _last_vaccuracy_ms > 150 &&
        now - _last_vaccuracy_ms < 1000) {
        // waiting on a message with velocity accuracy
        return false;
    }

    // prevent these messages being used again
    if (_last_VTG_ms != 0) {
        _last_VTG_ms = 1;
    }

    if (now - _last_yaw_ms > 300) {
        // we have lost GPS yaw
        state.have_gps_yaw = false;
    }

    if (now - _last_KSXT_pos_ms > 500) {
        // we have lost KSXT
        _last_KSXT_pos_ms = 0;
    }

#if AP_GPS_NMEA_UNICORE_ENABLED
    if (now - _last_AGRICA_ms > 500) {
        if (_last_AGRICA_ms != 0) {
            // we have lost AGRICA
            state.have_gps_yaw = false;
            state.have_vertical_velocity = false;
            state.have_speed_accuracy = false;
            state.have_horizontal_accuracy = false;
            state.have_vertical_accuracy = false;
            state.have_undulation = false;
            _last_AGRICA_ms = 0;
        }
    }
#endif // AP_GPS_NMEA_UNICORE_ENABLED

    _last_fix_ms = now;

    _last_GGA_ms = 1;
    _last_RMC_ms = 1;
    return true;
}

// Processes a just-completed term
// Returns true if new sentence has just passed checksum test and is validated
bool AP_GPS_NMEA::_term_complete()
{
    // handle the last term in a message
    if (_is_checksum_term) {
        _sentence_done = true;
        const uint32_t crc = strtoul(_term, nullptr, 16);
        const bool crc_ok = _is_unicore? (_crc32 == crc) : (_parity == crc);
        if (crc_ok) {
            uint32_t now = AP_HAL::millis();
            switch (_sentence_type) {
            case _GPS_SENTENCE_RMC:
                _last_RMC_ms = now;
                //time                        = _new_time;
                //date                        = _new_date;
                if (_last_KSXT_pos_ms == 0 && _last_AGRICA_ms == 0) {
                    state.location.lat     = _new_latitude;
                    state.location.lng     = _new_longitude;
                }
                if (_last_3D_velocity_ms == 0 ||
                    now - _last_3D_velocity_ms > 1000) {
                    state.ground_speed     = _new_speed*0.01f;
                    state.ground_course    = wrap_360(_new_course*0.01f);
                }
                if (state.status >= AP_GPS::GPS_OK_FIX_3D) {
                    make_gps_time(_new_date, _new_time * 10);
                    if (_last_AGRICA_ms != 0) {
                        state.time_week_ms = _last_itow_ms;
                    }
                }
                set_uart_timestamp(_sentence_length);
                state.last_gps_time_ms = now;
                if (_last_vvelocity_ms == 0 ||
                    now - _last_vvelocity_ms > 1000) {
                    fill_3d_velocity();
                }
                break;
            case _GPS_SENTENCE_GGA:
                _last_GGA_ms = now;
                if (_last_KSXT_pos_ms == 0 && _last_AGRICA_ms == 0) {
                    set_alt_amsl_cm(state, _new_altitude);
                    state.location.lat  = _new_latitude;
                    state.location.lng  = _new_longitude;
                }
                state.num_sats      = _new_satellite_count;
                state.hdop          = _new_hdop;
                switch(_new_quality_indicator) {
                case 0: // Fix not available or invalid
                    state.status = AP_GPS::NO_FIX;
                    break;
                case 1: // GPS SPS Mode, fix valid
                    state.status = AP_GPS::GPS_OK_FIX_3D;
                    break;
                case 2: // Differential GPS, SPS Mode, fix valid
                    state.status = AP_GPS::GPS_OK_FIX_3D_DGPS;
                    break;
                case 3: // GPS PPS Mode, fix valid
                    state.status = AP_GPS::GPS_OK_FIX_3D;
                    break;
                case 4: // Real Time Kinematic. System used in RTK mode with fixed integers
                    state.status = AP_GPS::GPS_OK_FIX_3D_RTK_FIXED;
                    break;
                case 5: // Float RTK. Satellite system used in RTK mode, floating integers
                    state.status = AP_GPS::GPS_OK_FIX_3D_RTK_FLOAT;
                    break;
                case 6: // Estimated (dead reckoning) Mode
                    state.status = AP_GPS::NO_FIX;
                    break;
                default://to maintain compatibility with MAV_GPS_INPUT and others
                    state.status = AP_GPS::GPS_OK_FIX_3D;
                    break;
                }
                break;
            case _GPS_SENTENCE_VTG:
                _last_VTG_ms = now;
                if (_last_3D_velocity_ms == 0 ||
                    now - _last_3D_velocity_ms > 1000) {
                    state.ground_speed  = _new_speed*0.01f;
                    state.ground_course = wrap_360(_new_course*0.01f);
                    if (_last_vvelocity_ms == 0 ||
                        now - _last_vvelocity_ms > 1000) {
                        fill_3d_velocity();
                    }
                }
                // VTG has no fix indicator, can't change fix status
                break;
            case _GPS_SENTENCE_HDT:
            case _GPS_SENTENCE_THS:
                if (_last_AGRICA_ms != 0 || _expect_agrica) {
                    // use AGRICA
                    break;
                }
                if (isnan(_new_gps_yaw)) {
                    // empty sentence
                    break;
                }
                _last_yaw_ms = now;
                state.gps_yaw = wrap_360(_new_gps_yaw*0.01f);
                state.have_gps_yaw = true;
                state.gps_yaw_time_ms = now;
                // remember that we are setup to provide yaw. With
                // a NMEA GPS we can only tell if the GPS is
                // configured to provide yaw when it first sends a
                // HDT sentence.
                state.gps_yaw_configured = true;
                break;
            case _GPS_SENTENCE_PHD:
                if (_last_AGRICA_ms != 0) {
                    // prefer AGRICA
                    break;
                }
                if (_phd.msg_id == 12) {
                    state.velocity.x = _phd.fields[0] * 0.01;
                    state.velocity.y = _phd.fields[1] * 0.01;
                    state.velocity.z = _phd.fields[2] * 0.01;
                    state.have_vertical_velocity = true;
                    _last_vvelocity_ms = now;
                    // we prefer a true 3D velocity when available
                    velocity_to_speed_course(state);
                    _last_3D_velocity_ms = now;
                } else if (_phd.msg_id == 26) {
                    state.horizontal_accuracy = MAX(_phd.fields[0],_phd.fields[1]) * 0.001;
                    state.have_horizontal_accuracy = true;
                    state.vertical_accuracy = _phd.fields[2] * 0.001;
                    state.have_vertical_accuracy = true;
                    state.speed_accuracy = MAX(_phd.fields[3],_phd.fields[4]) * 0.001;
                    state.have_speed_accuracy = true;
                    _last_vaccuracy_ms = now;
                }
                break;
            case _GPS_SENTENCE_KSXT:
                if (_last_AGRICA_ms != 0 || _expect_agrica) {
                    // prefer AGRICA
                    break;
                }
                state.location.lat     = _ksxt.fields[2]*1.0e7;
                state.location.lng     = _ksxt.fields[1]*1.0e7;
                set_alt_amsl_cm(state, _ksxt.fields[3]*1.0e2);
                _last_KSXT_pos_ms = now;
                if (_ksxt.fields[9] >= 1) {
                    // we have 3D fix
                    constexpr float kmh_to_mps = 1.0 / 3.6;
                    state.velocity.y = _ksxt.fields[16] * kmh_to_mps;
                    state.velocity.x = _ksxt.fields[17] * kmh_to_mps;
                    state.velocity.z = _ksxt.fields[18] * -kmh_to_mps;
                    state.have_vertical_velocity = true;
                    _last_vvelocity_ms = now;
                    // we prefer a true 3D velocity when available
                    velocity_to_speed_course(state);
                    _last_3D_velocity_ms = now;
                }
                if (is_equal(3.0f, float(_ksxt.fields[10]))) {
                    // have good yaw (from RTK fixed moving baseline solution)
                    _last_yaw_ms = now;
                    state.gps_yaw = _ksxt.fields[4];
                    state.have_gps_yaw = true;
                    state.gps_yaw_time_ms = now;
                    state.gps_yaw_configured = true;
                }
                break;
#if AP_GPS_NMEA_UNICORE_ENABLED
            case _GPS_SENTENCE_AGRICA: {
                const auto &ag = _agrica;
                _last_AGRICA_ms = now;
                _last_vvelocity_ms = now;
                _last_vaccuracy_ms = now;
                _last_3D_velocity_ms = now;
                state.location.lat = ag.lat*1.0e7;
                state.location.lng = ag.lng*1.0e7;
                state.undulation   = -ag.undulation;
                state.have_undulation = true;
                set_alt_amsl_cm(state, ag.alt*1.0e2);
                state.velocity = ag.vel_NED;
                velocity_to_speed_course(state);
                state.speed_accuracy = ag.vel_stddev.length();
                state.horizontal_accuracy = ag.pos_stddev.xy().length();
                state.vertical_accuracy = ag.pos_stddev.z;
                state.have_vertical_velocity = true;
                state.have_speed_accuracy = true;
                state.have_horizontal_accuracy = true;
                state.have_vertical_accuracy = true;
                check_new_itow(ag.itow, _sentence_length);
                break;
            }
            case _GPS_SENTENCE_VERSIONA: {
                _have_unicore_versiona = true;
                GCS_SEND_TEXT(MAV_SEVERITY_INFO,
                              "NMEA %s %s %s",
                              _versiona.type,
                              _versiona.version,
                              _versiona.build_date);
                break;
            }
            case _GPS_SENTENCE_UNIHEADINGA: {
#if GPS_MOVING_BASELINE
                const auto &ag = _agrica;
                const auto &uh = _uniheadinga;
                if (now - _last_AGRICA_ms > 500 || ag.heading_status != 4) {
                    // we need heading_status from AGRICA
                    state.have_gps_yaw = false;
                    break;
                }
                const float dist = uh.baseline_length;
                const float bearing = uh.heading;
                const float alt_diff = dist*tanf(radians(-uh.pitch));
                state.relPosHeading = bearing;
                state.relPosLength = dist;
                state.relPosD = alt_diff;
                state.relposheading_ts = now;
                if (calculate_moving_base_yaw(bearing, dist, alt_diff)) {
                    state.have_gps_yaw_accuracy = true;
                    state.gps_yaw_accuracy = uh.heading_sd;
                    _last_yaw_ms = now;
                }
                state.gps_yaw_configured = true;
#endif // GPS_MOVING_BASELINE
                break;
            }
#endif // AP_GPS_NMEA_UNICORE_ENABLED
            }
            // see if we got a good message
            return _have_new_message();
        }
        // we got a bad message, ignore it
        return false;
    }

    // the first term determines the sentence type
    if (_term_number == 0) {
        /*
          special case for $PHD message
         */
        if (strcmp(_term, "PHD") == 0) {
            _sentence_type = _GPS_SENTENCE_PHD;
            return false;
        }
        if (strcmp(_term, "KSXT") == 0) {
            _sentence_type = _GPS_SENTENCE_KSXT;
            return false;
        }
#if AP_GPS_NMEA_UNICORE_ENABLED
        if (strcmp(_term, "AGRICA") == 0 && _expect_agrica) {
            _sentence_type = _GPS_SENTENCE_AGRICA;
            return false;
        }
        if (strcmp(_term, "VERSIONA") == 0) {
            _sentence_type = _GPS_SENTENCE_VERSIONA;
            return false;
        }
        if (strcmp(_term, "UNIHEADINGA") == 0 && _expect_agrica) {
            _sentence_type = _GPS_SENTENCE_UNIHEADINGA;
            return false;
        }
#endif
        /*
          The first two letters of the NMEA term are the talker
          ID. The most common is 'GP' but there are a bunch of others
          that are valid. We accept any two characters here.
         */
        if (_term[0] < 'A' || _term[0] > 'Z' ||
            _term[1] < 'A' || _term[1] > 'Z') {
            _sentence_type = _GPS_SENTENCE_OTHER;
            return false;
        }
        const char *term_type = &_term[2];
        if (strcmp(term_type, "RMC") == 0) {
            _sentence_type = _GPS_SENTENCE_RMC;
        } else if (strcmp(term_type, "GGA") == 0) {
            _sentence_type = _GPS_SENTENCE_GGA;
        } else if (strcmp(term_type, "HDT") == 0) {
            _sentence_type = _GPS_SENTENCE_HDT;
        } else if (strcmp(term_type, "THS") == 0) {
            _sentence_type = _GPS_SENTENCE_THS;
        } else if (strcmp(term_type, "VTG") == 0) {
            _sentence_type = _GPS_SENTENCE_VTG;
        } else {
            _sentence_type = _GPS_SENTENCE_OTHER;
        }
        return false;
    }

    // 32 = RMC, 64 = GGA, 96 = VTG, 128 = HDT, 160 = THS
    if (_sentence_type != _GPS_SENTENCE_OTHER && _term[0]) {
        switch (_sentence_type + _term_number) {
        // operational status
        //
        case _GPS_SENTENCE_RMC + 2: // validity (RMC)
            break;
        case _GPS_SENTENCE_GGA + 6: // Fix data (GGA)
            if (_term[0] > '0') {
                _new_quality_indicator = _term[0] - '0';
            } else {
                _new_quality_indicator = 0;
            }
            break;
        case _GPS_SENTENCE_GGA + 7: // satellite count (GGA)
            _new_satellite_count = atol(_term);
            break;
        case _GPS_SENTENCE_GGA + 8: // HDOP (GGA)
            _new_hdop = (uint16_t)_parse_decimal_100(_term);
            break;

        // time and date
        //
        case _GPS_SENTENCE_RMC + 1: // Time (RMC)
        case _GPS_SENTENCE_GGA + 1: // Time (GGA)
            _new_time = _parse_decimal_100(_term);
            break;
        case _GPS_SENTENCE_RMC + 9: // Date (GPRMC)
            _new_date = atol(_term);
            break;

        // location
        //
        case _GPS_SENTENCE_RMC + 3: // Latitude
        case _GPS_SENTENCE_GGA + 2:
            _new_latitude = _parse_degrees();
            break;
        case _GPS_SENTENCE_RMC + 4: // N/S
        case _GPS_SENTENCE_GGA + 3:
            if (_term[0] == 'S')
                _new_latitude = -_new_latitude;
            break;
        case _GPS_SENTENCE_RMC + 5: // Longitude
        case _GPS_SENTENCE_GGA + 4:
            _new_longitude = _parse_degrees();
            break;
        case _GPS_SENTENCE_RMC + 6: // E/W
        case _GPS_SENTENCE_GGA + 5:
            if (_term[0] == 'W')
                _new_longitude = -_new_longitude;
            break;
        case _GPS_SENTENCE_GGA + 9: // Altitude (GPGGA)
            _new_altitude = _parse_decimal_100(_term);
            break;

        // course and speed
        //
        case _GPS_SENTENCE_RMC + 7: // Speed (GPRMC)
        case _GPS_SENTENCE_VTG + 5: // Speed (VTG)
            _new_speed = (_parse_decimal_100(_term) * 514) / 1000;       // knots-> m/sec, approximates * 0.514
            break;
        case _GPS_SENTENCE_HDT + 1: // Course (HDT)
            _new_gps_yaw = _parse_decimal_100(_term);
            break;
        case _GPS_SENTENCE_THS + 1: // Course (THS)
            _new_gps_yaw = _parse_decimal_100(_term);
            break;
        case _GPS_SENTENCE_RMC + 8: // Course (GPRMC)
        case _GPS_SENTENCE_VTG + 1: // Course (VTG)
            _new_course = _parse_decimal_100(_term);
            break;

        case _GPS_SENTENCE_PHD + 1: // PHD class
            _phd.msg_class = atol(_term);
            break;
        case _GPS_SENTENCE_PHD + 2: // PHD message
            _phd.msg_id = atol(_term);
            break;
        case _GPS_SENTENCE_PHD + 5: // PHD message, itow
            _phd.itow = strtoul(_term, nullptr, 10);
            break;
        case _GPS_SENTENCE_PHD + 6 ... _GPS_SENTENCE_PHD + 11: // PHD message, fields
            _phd.fields[_term_number-6] = atol(_term);
            break;
        case _GPS_SENTENCE_KSXT + 1 ... _GPS_SENTENCE_KSXT + 22: // KSXT message, fields
            _ksxt.fields[_term_number-1] = atof(_term);
            break;
#if AP_GPS_NMEA_UNICORE_ENABLED
        case _GPS_SENTENCE_AGRICA + 1 ... _GPS_SENTENCE_AGRICA + 65: // AGRICA message
            parse_agrica_field(_term_number, _term);
            break;
        case _GPS_SENTENCE_VERSIONA + 1 ... _GPS_SENTENCE_VERSIONA + 20:
            parse_versiona_field(_term_number, _term);
            break;
#if GPS_MOVING_BASELINE
        case _GPS_SENTENCE_UNIHEADINGA + 1 ... _GPS_SENTENCE_UNIHEADINGA + 28: // UNIHEADINGA message
            parse_uniheadinga_field(_term_number, _term);
            break;
#endif
#endif
        }
    }

    return false;
}

#if AP_GPS_NMEA_UNICORE_ENABLED
/*
  parse an AGRICA message term

  Example:
     #AGRICA,82,GPS,FINE,2237,176366400,0,0,18,15;GNSS,232,22,11,22,0,59,8,1,5,8,12,0,0.0000,0.0000,0.0000,0.0000,0.0000,0.0000,296.4656,-26.5685,0.0000,0.005,0.000,0.000,-0.005,0.044,0.032,0.038,-35.33142715815,149.13181842030,609.1494,-4471799.0368,2672944.7758,-3668288.9857,1.3923,1.5128,3.2272,2.3026,2.1633,2.1586,0.00000000000,0.00000000000,0.0000,0.00000000000,0.00000000000,0.0000,176366400,0.000,66.175285,18.972784,0.000000,0.000000,5,0,0,0*9f704dad
 */
void AP_GPS_NMEA::parse_agrica_field(uint16_t term_number, const char *term)
{
    auto &ag = _agrica;
    // subtract 8 to align term numbers with reference manual
    // look for "Unicore Reference Command Manual" to find the specification
    const uint8_t hdr_align = 8;
    if (term_number < hdr_align) {
        // discard header;
        return;
    }
    term_number -= hdr_align;
    // useful for debugging
    //::printf("AGRICA[%u]=%s\n", unsigned(term_number), term);
    switch (term_number) {
    case 10:
        ag.rtk_status = atol(term);
        break;
    case 11:
        ag.heading_status = atol(term);
        break;
    case 25 ... 26:
        ag.vel_NED[term_number-25] = atof(term);
        break;
    case 27:
        // AGRIC gives velocity up
        ag.vel_NED.z = -atof(term);
        break;
    case 28 ... 30:
        ag.vel_stddev[term_number-28] = atof(term);
        break;
    case 31:
        ag.lat = atof(term);
        break;
    case 32:
        ag.lng = atof(term);
        break;
    case 33:
        ag.alt = atof(term);
        break;
    case 49:
        ag.itow = atol(term);
        break;
    case 37 ... 39:
        ag.pos_stddev[term_number-37] = atof(term);
        break;
    case 52:
        ag.undulation = atof(term);
        break;
    }
}

#if GPS_MOVING_BASELINE
/*
  parse a UNIHEADINGA message term

  Example:
    #UNIHEADINGA,79,GPS,FINE,2242,167498200,0,0,18,22;SOL_COMPUTED,L1_INT,2.7889,296.7233,-25.7710,0.0000,0.1127,0.1812,"999",49,37,37,0,3,00,1,51*d50af0ea
 */
void AP_GPS_NMEA::parse_uniheadinga_field(uint16_t term_number, const char *term)
{
    const uint8_t hdr_align = 8;
    if (term_number < hdr_align) {
        // discard header;
        return;
    }
    term_number -= hdr_align;
    // useful for debugging
    // ::printf("UNIHEADINGA[%u]=%s\n", unsigned(term_number), term);
    auto &uh = _uniheadinga;
    switch (term_number) {
    case 4:
        uh.baseline_length = atof(term);
        break;
    case 5:
        uh.heading = atof(term);
        break;
    case 6:
        uh.pitch = atof(term);
        break;
    case 8:
        uh.heading_sd = atof(term);
        break;
    }
}
#endif // GPS_MOVING_BASELINE

// parse VERSIONA fields
void AP_GPS_NMEA::parse_versiona_field(uint16_t term_number, const char *term)
{
    // printf useful for debugging
    // ::printf("VERSIONA[%u]='%s'\n", term_number, term);
    auto &v = _versiona;
#pragma GCC diagnostic push
#if defined(__GNUC__) &&  __GNUC__ >= 9
#pragma GCC diagnostic ignored "-Wstringop-truncation"
#endif
    switch (term_number) {
    case 10:
        strncpy(v.type, _term, sizeof(v.type)-1);
        break;
    case 11:
        strncpy(v.version, _term, sizeof(v.version)-1);
        break;
    case 15:
        strncpy(v.build_date, _term, sizeof(v.build_date)-1);
        break;
    }
#pragma GCC diagnostic pop
}
#endif // AP_GPS_NMEA_UNICORE_ENABLED

/*
  detect a NMEA GPS. Adds one byte, and returns true if the stream
  matches a NMEA string
 */
bool
AP_GPS_NMEA::_detect(struct NMEA_detect_state &state, uint8_t data)
{
	switch (state.step) {
	case 0:
		state.ck = 0;
		if ('$' == data) {
			state.step++;
		}
		break;
	case 1:
		if ('*' == data) {
			state.step++;
		} else {
			state.ck ^= data;
		}
		break;
	case 2:
		if (hexdigit(state.ck>>4) == data) {
			state.step++;
		} else {
			state.step = 0;
		}
		break;
	case 3:
		if (hexdigit(state.ck&0xF) == data) {
            state.step = 0;
			return true;
		}
		state.step = 0;
		break;
    }
    return false;
}

/*
  send type specific config strings
 */
void AP_GPS_NMEA::send_config(void)
{
    const auto type = get_type();
    _expect_agrica = (type == AP_GPS::GPS_TYPE_UNICORE_NMEA ||
                      type == AP_GPS::GPS_TYPE_UNICORE_MOVINGBASE_NMEA);
    if (gps._auto_config == AP_GPS::GPS_AUTO_CONFIG_DISABLE) {
        // not doing auto-config
        return;
    }
    uint32_t now_ms = AP_HAL::millis();
    if (now_ms - last_config_ms < AP_GPS_NMEA_CONFIG_PERIOD_MS) {
        return;
    }
    last_config_ms = now_ms;
    const uint16_t rate_ms = params.rate_ms;
#if AP_GPS_NMEA_UNICORE_ENABLED
    const float rate_s = rate_ms * 0.001;
#endif
    const uint8_t rate_hz = 1000U / rate_ms;

    switch (get_type()) {
#if AP_GPS_NMEA_UNICORE_ENABLED
    case AP_GPS::GPS_TYPE_UNICORE_MOVINGBASE_NMEA:
        port->printf("\r\nCONFIG HEADING FIXLENGTH\r\n" \
                     "CONFIG UNDULATION AUTO\r\n" \
                     "CONFIG\r\n" \
                     "UNIHEADINGA %.3f\r\n",
                     rate_s);
        state.gps_yaw_configured = true;
        FALLTHROUGH;

    case AP_GPS::GPS_TYPE_UNICORE_NMEA: {
        port->printf("\r\nAGRICA %.3f\r\n" \
                     "MODE MOVINGBASE\r\n" \
                     "GNGGA %.3f\r\n" \
                     "GNRMC %.3f\r\n",
                     rate_s, rate_s, rate_s);
        if (!_have_unicore_versiona) {
            // get version information for logging if we don't have it yet
            port->printf("VERSIONA\r\n");
            if (gps._save_config) {
                // save config changes for fast startup
                port->printf("SAVECONFIG\r\n");
            }
        }
        break;
    }
#endif // AP_GPS_NMEA_UNICORE_ENABLED

    case AP_GPS::GPS_TYPE_HEMI: {
        port->printf(
        "$JATT,NMEAHE,0\r\n" /* Prefix of GP on the HDT message */      \
        "$JASC,GPGGA,%u\r\n" /* GGA at 5Hz */                            \
        "$JASC,GPRMC,%u\r\n" /* RMC at 5Hz */                            \
        "$JASC,GPVTG,%u\r\n" /* VTG at 5Hz */                            \
        "$JASC,GPHDT,%u\r\n" /* HDT at 5Hz */                            \
        "$JMODE,SBASR,YES\r\n" /* Enable SBAS */,
        rate_hz, rate_hz, rate_hz, rate_hz);
        break;
    }

    case AP_GPS::GPS_TYPE_ALLYSTAR:
        nmea_printf(port, "$PHD,06,42,UUUUTTTT,BB,0,%u,55,0,%u,0,0,0",
                    unsigned(rate_hz), unsigned(rate_ms));
        break;

    default:
        break;
    }

#ifdef AP_GPS_NMEA_CUSTOM_CONFIG_STRING
    // allow for custom config strings, useful for peripherals
    port->printf("%s\r\n", AP_GPS_NMEA_CUSTOM_CONFIG_STRING);
#endif
}

/*
  return health status
 */
bool AP_GPS_NMEA::is_healthy(void) const
{
    switch (get_type()) {
#if AP_GPS_NMEA_UNICORE_ENABLED
    case AP_GPS::GPS_TYPE_UNICORE_MOVINGBASE_NMEA:
    case AP_GPS::GPS_TYPE_UNICORE_NMEA:
        // we should be getting AGRICA messages
        return _last_AGRICA_ms != 0;
#endif // AP_GPS_NMEA_UNICORE_ENABLED

    case AP_GPS::GPS_TYPE_HEMI:
        // we should be getting HDR for yaw
        return _last_yaw_ms != 0;

    case AP_GPS::GPS_TYPE_ALLYSTAR:
        // we should get vertical velocity and accuracy from PHD
        return _last_vvelocity_ms != 0 && _last_vaccuracy_ms != 0;

    default:
        break;
    }
    return true;
}

// get the velocity lag
bool AP_GPS_NMEA::get_lag(float &lag_sec) const
{
    switch (get_type()) {
#if AP_GPS_NMEA_UNICORE_ENABLED
    case AP_GPS::GPS_TYPE_UNICORE_MOVINGBASE_NMEA:
    case AP_GPS::GPS_TYPE_UNICORE_NMEA:
        lag_sec = 0.14;
        break;
#endif // AP_GPS_NMEA_UNICORE_ENABLED

    default:
        lag_sec = 0.2;
        break;
    }
    return true;
}

#if HAL_LOGGING_ENABLED
void AP_GPS_NMEA::Write_AP_Logger_Log_Startup_messages() const
{
    AP_GPS_Backend::Write_AP_Logger_Log_Startup_messages();
#if AP_GPS_NMEA_UNICORE_ENABLED
    if (_have_unicore_versiona) {
        AP::logger().Write_MessageF("NMEA %u %s %s %s",
                                    state.instance+1,
                                    _versiona.type,
                                    _versiona.version,
                                    _versiona.build_date);
    }
#endif
}
#endif

#endif // AP_GPS_NMEA_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            /*
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

//
// NMEA parser, adapted by Michael Smith from TinyGPS v9:
//
// TinyGPS - a small GPS library for Arduino providing basic NMEA parsing
// Copyright (C) 2008-9 Mikal Hart
// All rights reserved.
//
//

/// @file	AP_GPS_NMEA.h
/// @brief	NMEA protocol parser
///
/// This is a lightweight NMEA parser, derived originally from the
/// TinyGPS parser by Mikal Hart.  It is frugal in its use of memory
/// and tries to avoid unnecessary arithmetic.
///
/// The parser handles GPGGA, GPRMC and GPVTG messages, and attempts to be
/// robust in the face of occasional corruption in the input stream.  It
/// makes a basic effort to configure GPS' that are likely to be connected in
/// NMEA mode (SiRF, MediaTek and ublox) to emit the correct message
/// stream, but does not validate that the correct stream is being received.
/// In particular, a unit emitting just GPRMC will show as having a fix
/// even though no altitude data is being received.
///
/// GPVTG data is parsed, but as the message may not contain the the
/// qualifier field (this is common with e.g. older SiRF units) it is
/// not considered a source of fix-valid information.
///
#pragma once

#include "AP_GPS.h"
#include "GPS_Backend.h"

#if AP_GPS_NMEA_ENABLED
/// NMEA parser
///
class AP_GPS_NMEA : public AP_GPS_Backend
{
    friend class AP_GPS_NMEA_Test;

public:

    using AP_GPS_Backend::AP_GPS_Backend;

    /// Checks the serial receive buffer for characters,
    /// attempts to parse NMEA data and updates internal state
    /// accordingly.
    bool        read() override;

	static bool _detect(struct NMEA_detect_state &state, uint8_t data);

    const char *name() const override { return "NMEA"; }

    // driver specific health, returns true if the driver is healthy
    bool is_healthy(void) const override;

    // get lag in seconds
    bool get_lag(float &lag_sec) const override;

#if HAL_LOGGING_ENABLED
    void Write_AP_Logger_Log_Startup_messages() const override;
#endif

private:
    /// Coding for the GPS sentences that the parser handles
    enum _sentence_types : uint16_t {      //there are some more than 10 fields in some sentences , thus we have to increase these value.
        _GPS_SENTENCE_RMC = 32,
        _GPS_SENTENCE_GGA = 64,
        _GPS_SENTENCE_VTG = 96,
        _GPS_SENTENCE_HDT = 128,
        _GPS_SENTENCE_PHD = 138, // extension for AllyStar GPS modules
        _GPS_SENTENCE_THS = 160, // True heading with quality indicator, available on Trimble MB-Two
        _GPS_SENTENCE_KSXT = 170, // extension for Unicore, 21 fields
        _GPS_SENTENCE_AGRICA = 193, // extension for Unicore, 65 fields
        _GPS_SENTENCE_VERSIONA = 270, // extension for Unicore, version, 10 fields
        _GPS_SENTENCE_UNIHEADINGA = 290, // extension for Unicore, uniheadinga, 20 fields
        _GPS_SENTENCE_OTHER = 0
    };

    /// Update the decode state machine with a new character
    ///
    /// @param	c		The next character in the NMEA input stream
    /// @returns		True if processing the character has resulted in
    ///					an update to the GPS state
    ///
    bool                        _decode(char c);

    /// Parses the @p as a NMEA-style decimal number with
    /// up to 3 decimal digits.
    ///
    /// @returns		The value expressed by the string in @p,
    ///					multiplied by 100.
    ///
    static int32_t _parse_decimal_100(const char *p);

    /// Parses the current term as a NMEA-style degrees + minutes
    /// value with up to four decimal digits.
    ///
    /// This gives a theoretical resolution limit of around 1cm.
    ///
    /// @returns		The value expressed by the string in _term,
    ///					multiplied by 1e7.
    ///
    uint32_t    _parse_degrees();

    /// Processes the current term when it has been deemed to be
    /// complete.
    ///
    /// Each GPS message is broken up into terms separated by commas.
    /// Each term is then processed by this function as it is received.
    ///
    /// @returns		True if completing the term has resulted in
    ///					an update to the GPS state.
    bool                        _term_complete();

    /// return true if we have a new set of NMEA messages
    bool _have_new_message(void);

#if AP_GPS_NMEA_UNICORE_ENABLED
    /*
      parse an AGRICA field
     */
    void parse_agrica_field(uint16_t term_number, const char *term);

    // parse VERSIONA field
    void parse_versiona_field(uint16_t term_number, const char *term);

#if GPS_MOVING_BASELINE
    // parse UNIHEADINGA field
    void parse_uniheadinga_field(uint16_t term_number, const char *term);
#endif
#endif


    uint8_t _parity;                                                    ///< NMEA message checksum accumulator
    uint32_t _crc32;                                            ///< CRC for unicore messages
    bool _is_checksum_term;                                     ///< current term is the checksum
    char _term[30];                                                     ///< buffer for the current term within the current sentence
    uint16_t _sentence_type;                                     ///< the sentence type currently being processed
    bool _is_unicore;                                           ///< true if in a unicore '#' sentence
    uint16_t _term_number;                                       ///< term index within the current sentence
    uint8_t _term_offset;                                       ///< character offset with the term being received
    uint16_t _sentence_length;
    bool _sentence_done;                                        ///< set when a sentence has been fully decoded

    // The result of parsing terms within a message is stored temporarily until
    // the message is completely processed and the checksum validated.
    // This avoids the need to buffer the entire message.
    int32_t _new_time;                                                  ///< time parsed from a term
    int32_t _new_date;                                                  ///< date parsed from a term
    int32_t _new_latitude;                                      ///< latitude parsed from a term
    int32_t _new_longitude;                                     ///< longitude parsed from a term
    int32_t _new_altitude;                                      ///< altitude parsed from a term
    int32_t _new_speed;                                                 ///< speed parsed from a term
    int32_t _new_course;                                        ///< course parsed from a term
    float   _new_gps_yaw;                                        ///< yaw parsed from a term
    uint16_t _new_hdop;                                                 ///< HDOP parsed from a term
    uint8_t _new_satellite_count;                       ///< satellite count parsed from a term
    uint8_t _new_quality_indicator;                                     ///< GPS quality indicator parsed from a term

    uint32_t _last_RMC_ms;
    uint32_t _last_GGA_ms;
    uint32_t _last_VTG_ms;
    uint32_t _last_yaw_ms;
    uint32_t _last_vvelocity_ms;
    uint32_t _last_vaccuracy_ms;
    uint32_t _last_3D_velocity_ms;
    uint32_t _last_KSXT_pos_ms;
    uint32_t _last_AGRICA_ms;
    uint32_t _last_fix_ms;

    /// @name	Init strings
    ///			In ::init, an attempt is made to configure the GPS
    ///			unit to send just the messages that we are interested
    ///			in using these strings
    //@{
    static const char _SiRF_init_string[];         ///< init string for SiRF units
    static const char _ublox_init_string[];        ///< init string for ublox units
    //@}

    static const char _initialisation_blob[];

    /*
      the $PHD message is an extension from AllyStar that gives
      vertical velocity and more accuracy estimates. It is designed as
      a mapping from ublox UBX protocol messages to NMEA. So class 1,
      message 12 is a mapping to NMEA of the NAV-VELNED UBX message
      and contains the same fields. Class 1 message 26 is called
      "NAV-PVERR", but does not correspond to a UBX message

      example:
        $PHD,01,12,TIIITTITT,,245808000,0,0,0,0,0,10260304,0,0*27
        $PHD,01,26,TTTTTTT,,245808000,877,864,1451,11,11,17*17
     */
    struct {
        uint8_t msg_class;
        uint8_t msg_id;
        uint32_t itow;
        int32_t fields[8];
    } _phd;

    /*
      The KSXT message is an extension from Unicore that gives 3D velocity and yaw
      example: $KSXT,20211016083433.00,116.31296102,39.95817066,49.4911,223.57,-11.32,330.19,0.024,,1,3,28,27,,,,-0.012,0.021,0.020,,*2D
     */
    struct {
        double fields[21];
    } _ksxt;

#if AP_GPS_NMEA_UNICORE_ENABLED
    /*
      unicore AGRICA message parsing
     */
    struct {
        uint32_t start_byte;
        uint8_t rtk_status;
        uint8_t heading_status;
        Vector3f vel_NED;
        Vector3f vel_stddev;
        double lat, lng;
        float alt;
        uint32_t itow;
        float undulation;
        Vector3f pos_stddev;
    } _agrica;

    // unicore VERSIONA parsing
    struct {
        char type[10];
        char version[20];
        char build_date[13];
    } _versiona;
    bool _have_unicore_versiona;

#if GPS_MOVING_BASELINE
    // unicore UNIHEADINGA parsing
    struct {
        float baseline_length;
        float heading;
        float pitch;
        float heading_sd;
    } _uniheadinga;
#endif
#endif // AP_GPS_NMEA_UNICORE_ENABLED
    bool _expect_agrica;

    // last time we sent type specific config strings
    uint32_t last_config_ms;

    // send type specific config strings
    void send_config(void);
};

#if AP_GPS_NMEA_UNICORE_ENABLED && !defined(NMEA_UNICORE_SETUP)
// we don't know what port the GPS may be using, so configure all 3. We need to get it sending
// one message to allow the NMEA detector to run
#define NMEA_UNICORE_SETUP "CONFIG COM1 230400 8 n 1\r\nCONFIG COM2 230400 8 n 1\r\nCONFIG COM3 230400 8 n 1\r\nGPGGA 0.2\r\n"
#endif

#endif // AP_GPS_NMEA_ENABLED

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  /*
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

//  Novatel/Tersus/ComNav GPS driver for ArduPilot.
//  Code by Michael Oborne
//  Derived from http://www.novatel.com/assets/Documents/Manuals/om-20000129.pdf

#include "AP_GPS.h"
#include "AP_GPS_NOVA.h"
#include <AP_Logger/AP_Logger.h>

#if AP_GPS_NOVA_ENABLED

extern const AP_HAL::HAL& hal;

#define NOVA_DEBUGGING 0

#if NOVA_DEBUGGING
#include <cstdio>
 # define Debug(fmt, args ...)                  \
do {                                            \
    printf("%s:%d: " fmt "\n",     \
                        __FUNCTION__, __LINE__, \
                        ## args);               \
    hal.scheduler->delay(1);                    \
} while(0)
#else
 # define Debug(fmt, args ...)
#endif

AP_GPS_NOVA::AP_GPS_NOVA(AP_GPS &_gps,
                         AP_GPS::Params &_params,
                         AP_GPS::GPS_State &_state,
                         AP_HAL::UARTDriver *_port) :
    AP_GPS_Backend(_gps, _params, _state, _port)
{
    nova_msg.nova_state = nova_msg_parser::PREAMBLE1;

    nova_msg.header.data[0] = NOVA_PREAMBLE1;
    nova_msg.header.data[1] = NOVA_PREAMBLE2;
    nova_msg.header.data[2] = NOVA_PREAMBLE3;

    if (gps._auto_config != AP_GPS::GPS_AUTO_CONFIG_DISABLE) {
        const char *init_str = _initialisation_blob[0];
        const char *init_str1 = _initialisation_blob[1];

        port->write((const uint8_t*)init_str, strlen(init_str));
        port->write((const uint8_t*)init_str1, strlen(init_str1));
    }
}

const char* const AP_GPS_NOVA::_initialisation_blob[4] {
    "\r\n\r\nunlogall\r\n", // cleanup enviroment
    "log bestposb ontime 0.2 0 nohold\r\n",
    "log bestvelb ontime 0.2 0 nohold\r\n",
    "log psrdopb ontime 0.2 0 nohold\r\n",
};

// Process all bytes available from the stream
//
bool
AP_GPS_NOVA::read(void)
{
    if (gps._auto_config != AP_GPS::GPS_AUTO_CONFIG_DISABLE) {
        const uint32_t now = AP_HAL::millis();

        if (_init_blob_index < (sizeof(_initialisation_blob) / sizeof(_initialisation_blob[0]))) {
            const char *init_str = _initialisation_blob[_init_blob_index];

            if (now > _init_blob_time) {
                port->write((const uint8_t*)init_str, strlen(init_str));
                _init_blob_time = now + 200;
                _init_blob_index++;
            }
        }
    }

    bool ret = false;
    for (uint16_t i=0; i<8192; i++) {
        uint8_t temp;
        if (!port->read(temp)) {
            break;
        }
#if AP_GPS_DEBUG_LOGGING_ENABLED
        log_data(&temp, 1);
#endif
        ret |= parse(temp);
    }
    
    return ret;
}

bool
AP_GPS_NOVA::parse(uint8_t temp)
{
    switch (nova_msg.nova_state)
    {
        default:
        case nova_msg_parser::PREAMBLE1:
            if (temp == NOVA_PREAMBLE1) {
                nova_msg.nova_state = nova_msg_parser::PREAMBLE2;
            }
            nova_msg.read = 0;
            break;
        case nova_msg_parser::PREAMBLE2:
            if (temp == NOVA_PREAMBLE2) {
                nova_msg.nova_state = nova_msg_parser::PREAMBLE3;
            } else {
                nova_msg.nova_state = nova_msg_parser::PREAMBLE1;
            }
            break;
        case nova_msg_parser::PREAMBLE3:
            if (temp == NOVA_PREAMBLE3) {
                nova_msg.nova_state = nova_msg_parser::HEADERLENGTH;
            } else {
                nova_msg.nova_state = nova_msg_parser::PREAMBLE1;
            }
            break;
        case nova_msg_parser::