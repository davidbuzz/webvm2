DSB serial baudrate.
    // @Values: 1:1200,2:2400,4:4800,9:9600,19:19200,38:38400,57:57600,111:111100,115:115200,230:230400,256:256000,460:460800,500:500000,921:921600,1500:1500000
    // @Increment: 1
    // @User: Standard
    // @RebootRequired: True
    GSCALAR(adsb_baudrate, "ADSB_BAUDRATE", HAL_PERIPH_ADSB_BAUD_DEFAULT),

    // @Param: ADSB_PORT
    // @DisplayName: ADSB Serial Port
    // @Description: This is the serial port number where SERIALx_PROTOCOL will be set to ADSB.
    // @Range: 0 10
    // @Increment: 1
    // @User: Advanced
    // @RebootRequired: True
    GSCALAR(adsb_port, "ADSB_PORT", HAL_PERIPH_ADSB_PORT_DEFAULT),
#endif

#ifdef HAL_PERIPH_ENABLE_PWM_HARDPOINT
    // @Param: HARDPOINT_ID
    // @DisplayName: Hardpoint ID
    // @Description: Hardpoint ID
    // @User: Advanced
    GSCALAR(hardpoint_id, "HARDPOINT_ID", HAL_PWM_HARDPOINT_ID_DEFAULT),

    // @Param: HARDPOINT_RATE
    // @DisplayName: Hardpoint PWM rate
    // @Description: Hardpoint PWM rate
    // @Range: 10 100
    // @Units: Hz
    // @Increment: 1
    // @User: Advanced
    GSCALAR(hardpoint_rate, "HARDPOINT_RATE", 100),
#endif

#if defined(HAL_PERIPH_ENABLE_HWESC) || defined(HAL_PERIPH_ENABLE_ESC_APD)
    // @Param: ESC_NUMBER
    // @DisplayName: ESC number
    // @Description: This is the ESC number to report as in UAVCAN ESC telemetry feedback packets.
    // @Increment: 1
    // @User: Advanced
    GARRAY(esc_number, 0, "ESC_NUMBER", 0),
#endif

#ifdef HAL_PERIPH_ENABLE_RC_OUT
    // Servo driver
    // @Group: OUT
    // @Path: ../libraries/SRV_Channel/SRV_Channels.cpp
    GOBJECT(servo_channels, "OUT",     SRV_Channels),

    // @Param: ESC_RATE
    // @DisplayName: ESC Update Rate
    // @Description: Rate in Hz that ESC PWM outputs (function is MotorN) will update at
    // @Units: Hz
    // @Range: 50 400
    // @Increment: 1
    // @User: Advanced
    GSCALAR(esc_rate, "ESC_RATE", 400), // effective Copter and QuadPlane default after clamping

    // @Param: ESC_PWM_TYPE
    // @DisplayName: Output PWM type
    // @Description: This selects the output PWM type, allowing for normal PWM continuous output, OneShot, brushed or DShot motor output
    // @Values: 1:Normal,2:OneShot,3:OneShot125,4:Brushed,5:DShot150,6:DShot300,7:DShot600,8:DShot1200
    // @User: Advanced
    // @RebootRequired: True
    GSCALAR(esc_pwm_type, "ESC_PWM_TYPE",     0),

    // @Param: ESC_CMD_TIMO
    // @DisplayName: ESC Command Timeout
    // @Description: This is the duration (ms) with which to hold the last driven ESC command before timing out and zeroing the ESC outputs. To disable zeroing of outputs in event of CAN loss, use 0. Use values greater than the expected duration between two CAN frames to ensure Periph is not starved of ESC Raw Commands.
    // @Range: 0 10000
    // @Units: ms
    // @User: Advanced
    GSCALAR(esc_command_timeout_ms, "ESC_CMD_TIMO",     200),

#if HAL_WITH_ESC_TELEM && !HAL_GCS_ENABLED
    // @Param: ESC_TELEM_PORT
    // @DisplayName: ESC Telemetry Serial Port
    // @Description: This is the serial port number where SERIALx_PROTOCOL will be set to ESC Telemetry
    // @Range: 0 10
    // @Increment: 1
    // @User: Advanced
    // @RebootRequired: True
    GSCALAR(esc_telem_port, "ESC_TELEM_PORT", AP_PERIPH_ESC_TELEM_PORT_DEFAULT),
#endif

#if HAL_WITH_ESC_TELEM
    // @Param: ESC_TELEM_RATE
    // @DisplayName: ESC Telemetry update rate
    // @Description: This is the rate at which ESC Telemetry will be sent across the CAN bus
    // @Range: 0 1000
    // @Increment: 1
    // @User: Advanced
    // @RebootRequired: True
    GSCALAR(esc_telem_rate, "ESC_TELEM_RATE", AP_PERIPH_ESC_TELEM_RATE_DEFAULT),
#endif
#endif

#if AP_TEMPERATURE_SENSOR_ENABLED
    // @Group: TEMP
    // @Path: ../libraries/AP_TemperatureSensor/AP_TemperatureSensor.cpp
    GOBJECT(temperature_sensor,         "TEMP",     AP_TemperatureSensor),
#endif

#ifdef HAL_PERIPH_ENABLE_MSP
    // @Param: MSP_PORT
    // @DisplayName: MSP Serial Port
    // @Description: This is the serial port number where SERIALx_PROTOCOL will be set to MSP
    // @Range: 0 10
    // @Increment: 1
    // @User: Advanced
    // @RebootRequired: True
    GSCALAR(msp_port, "MSP_PORT", AP_PERIPH_MSP_PORT_DEFAULT),
#endif
    
#ifdef HAL_PERIPH_ENABLE_NOTIFY
    // @Group: NTF_
    // @Path: ../libraries/AP_Notify/AP_Notify.cpp
    GOBJECT(notify, "NTF_",  AP_Notify),
#endif

#if HAL_LOGGING_ENABLED
    // @Group: LOG
    // @Path: ../libraries/AP_Logger/AP_Logger.cpp
    GOBJECT(logger,           "LOG",  AP_Logger),

    // @Param: LOG_BITMASK
    // @DisplayName: Log bitmask
    // @Description: 4 byte bitmap of log types to enable
    // @Bitmask: 2:GPS
    // @User: Standard
    GSCALAR(log_bitmask,    "LOG_BITMASK",          4),
#endif

#if HAL_GCS_ENABLED
    // @Param: SYSID_THISMAV
    // @DisplayName: MAVLink system ID of this vehicle
    // @Description: Allows setting an individual system id for this vehicle to distinguish it from others on the same network
    // @Range: 1 255
    // @User: Advanced
    GSCALAR(sysid_this_mav,         "SYSID_THISMAV",  MAV_SYSTEM_ID),
#endif

#if HAL_GCS_ENABLED || defined(HAL_PERIPH_SHOW_SERIAL_MANAGER_PARAMS)
    // @Group: SERIAL
    // @Path: ../libraries/AP_SerialManager/AP_SerialManager.cpp
    GOBJECT(serial_manager, "SERIAL",   AP_SerialManager),
#endif

#if AP_SCRIPTING_ENABLED
    // @Group: SCR_
    // @Path: ../libraries/AP_Scripting/AP_Scripting.cpp
    GOBJECT(scripting, "SCR_", AP_Scripting),
#endif

#if AP_STATS_ENABLED
    // @Group: Node
    // @Path: ../libraries/AP_Stats/AP_Stats.cpp
    GOBJECT(node_stats, "STAT", AP_Stats),
#endif

#ifdef HAL_PERIPH_ENABLE_EFI
    // @Param: EFI_BAUDRATE
    // @DisplayName: EFI serial baudrate
    // @Description: EFI  serial baudrate.
    // @Values: 1:1200,2:2400,4:4800,9:9600,19:19200,38:38400,57:57600,111:111100,115:115200,230:230400,256:256000,460:460800,500:500000,921:921600,1500:1500000
    // @Increment: 1
    // @User: Standard
    // @RebootRequired: True
    GSCALAR(efi_baudrate, "EFI_BAUDRATE", HAL_PERIPH_EFI_BAUDRATE_DEFAULT),

    // @Param: EFI_PORT
    // @DisplayName: EFI Serial Port
    // @Description: This is the serial port number where SERIALx_PROTOCOL will be set to EFI.
    // @Range: 0 10
    // @Increment: 1
    // @User: Advanced
    // @RebootRequired: True
    GSCALAR(efi_port, "EFI_PORT", AP_PERIPH_EFI_PORT_DEFAULT),

    // EFI driver
    // @Group: EFI
    // @Path: ../libraries/AP_EFI/AP_EFI.cpp
    GOBJECT(efi, "EFI", AP_EFI),
#endif

#ifdef HAL_PERIPH_ENABLE_PROXIMITY
    // @Param: PRX_BAUDRATE
    // @DisplayName: Proximity Sensor serial baudrate
    // @Description: Proximity Sensor serial baudrate.
    // @Values: 1:1200,2:2400,4:4800,9:9600,19:19200,38:38400,57:57600,111:111100,115:115200,230:230400,256:256000,460:460800,500:500000,921:921600,1500:1500000
    // @Increment: 1
    // @User: Standard
    // @RebootRequired: True
    GSCALAR(proximity_baud, "PRX_BAUDRATE", HAL_PERIPH_RANGEFINDER_BAUDRATE_DEFAULT),

    // @Param: PRX_PORT
    // @DisplayName: Proximity Sensor Serial Port
    // @Description: This is the serial port number where SERIALx_PROTOCOL will be set to Proximity Sensor.
    // @Range: 0 10
    // @Increment: 1
    // @User: Advanced
    // @RebootRequired: True
    GSCALAR(proximity_port, "PRX_PORT", AP_PERIPH_RANGEFINDER_PORT_DEFAULT),

    // @Param: PRX_MAX_RATE
    // @DisplayName: Proximity Sensor max rate
    // @Description: This is the maximum rate we send Proximity Sensor data in Hz. Zero means no limit
    // @Units: Hz
    // @Range: 0 200
    // @Increment: 1
    // @User: Advanced
    GSCALAR(proximity_max_rate, "PRX_MAX_RATE", 50),

    // Proximity driver
    // @Group: PRX
    // @Path: ../libraries/AP_Proximity/AP_Proximity.cpp
    GOBJECT(proximity, "PRX", AP_Proximity),
#endif  // HAL_PERIPH_ENABLE_PROXIMITY

#if HAL_NMEA_OUTPUT_ENABLED
    // @Group: NMEA_
    // @Path: ../libraries/AP_NMEA_Output/AP_NMEA_Output.cpp
    GOBJECT(nmea, "NMEA_",   AP_NMEA_Output),
#endif

#if AP_KDECAN_ENABLED
    // @Group: KDE_
    // @Path: ../libraries/AP_KDECAN/AP_KDECAN.cpp
    GOBJECT(kdecan, "KDE_",   AP_KDECAN),
#endif

#if defined(HAL_PERIPH_ENABLE_ESC_APD)
    GARRAY(pole_count, 0, "ESC_NUM_POLES", 22),
#endif

#if defined(HAL_PERIPH_ENABLE_ESC_APD)
    // @Param: ESC_APD_SERIAL_1
    // @DisplayName: ESC APD Serial 1
    // @Description: Which serial port to use for APD ESC data
    // @Range: 0 6
    // @Increment: 1
    // @User: Advanced
    // @RebootRequired: True
    GARRAY(esc_serial_port, 0, "ESC_APD_SERIAL_1", APD_ESC_SERIAL_0),

  #if APD_ESC_INSTANCES > 1
    GARRAY(esc_number, 1, "ESC_NUMBER2", 1),

    GARRAY(pole_count, 1, "ESC_NUM_POLES2", 22),

    // @Param: ESC_APD_SERIAL_2
    // @DisplayName: ESC APD Serial 2
    // @Description: Which serial port to use for APD ESC data
    // @Range: 0 6
    // @Increment: 1
    // @User: Advanced
    // @RebootRequired: True
    GARRAY(esc_serial_port, 1, "ESC_APD_SERIAL_2", APD_ESC_SERIAL_1),
  #endif
#endif

#ifdef HAL_PERIPH_ENABLE_NETWORKING
    // @Group: NET_
    // @Path: networking.cpp
    GOBJECT(networking_periph, "NET_", Networking_Periph),
#endif

#ifdef HAL_PERIPH_ENABLE_RPM
    // @Group: RPM
    // @Path: ../libraries/AP_RPM/AP_RPM.cpp
    GOBJECT(rpm_sensor, "RPM", AP_RPM),
#endif

#ifdef HAL_PERIPH_ENABLE_RCIN
    // @Group: RC
    // @Path: rc_in.cpp
    GOBJECT(g_rcin, "RC",  Parameters_RCIN),
#endif

#ifdef HAL_PERIPH_ENABLE_BATTERY_BALANCE
    // @Group: BAL
    // @Path: batt_balance.cpp
    GOBJECT(battery_balance, "BAL",  BattBalance),
#endif

#ifdef HAL_PERIPH_ENABLE_SERIAL_OPTIONS
    // @Group: UART
    // @Path: serial_options.cpp
    GOBJECT(serial_options, "UART",  SerialOptions),
#endif
    
    // NOTE: sim parameters should go last
#if AP_SIM_ENABLED
    // @Group: SIM_
    // @Path: ../libraries/SITL/SITL.cpp
    GOBJECT(sitl, "SIM_", SITL::SIM),

#if AP_AHRS_ENABLED
    // @Group: AHRS_
    // @Path: ../libraries/AP_AHRS/AP_AHRS.cpp
    GOBJECT(ahrs,                   "AHRS_",    AP_AHRS),
#endif
#endif // AP_SIM_ENABLED

#if HAL_PERIPH_CAN_MIRROR
    // @Param: CAN_MIRROR_PORTS
    // @DisplayName: CAN ports to mirror traffic between
    // @Description: Any set ports will participate in blindly mirroring traffic from one port to the other. It is the users responsibility to ensure that no loops exist that cause traffic to be infinitly repeated, and both ports must be running the same baud rates.
    // @Bitmask: 0:CAN1, 1:CAN2, 2:CAN3
    // @User: Advanced
    GSCALAR(can_mirror_ports, "CAN_MIRROR_PORTS", 0),
#endif // HAL_PERIPH_CAN_MIRROR

#ifdef HAL_PERIPH_ENABLE_RTC
    // @Group: RTC
    // @Path: ../libraries/AP_RTC/AP_RTC.cpp
    GOBJECT(rtc,                   "RTC",    AP_RTC),
#endif

#ifdef HAL_PERIPH_ENABLE_RELAY
    // @Group: RELAY
    // @Path: ../libraries/AP_Relay/AP_Relay.cpp
    GOBJECT(relay,                 "RELAY", AP_Relay),
#endif

#ifdef HAL_PERIPH_ENABLE_DEVICE_TEMPERATURE
    // @Param: TEMP_MSG_RATE
    // @DisplayName: Temperature sensor message rate
    // @Description: This is the rate Temperature sensor data is sent in Hz. Zero means no send. Each sensor with source DroneCAN is sent in turn.
    // @Units: Hz
    // @Range: 0 200
    // @Increment: 1
    // @User: Standard
    GSCALAR(temperature_msg_rate, "TEMP_MSG_RATE", 0),
#endif

    // @Param: OPTIONS
    // @DisplayName: AP Periph Options
    // @Description: Bitmask of AP Periph Options
    // @Bitmask: 0: Enable continuous sensor probe
    // @User: Standard
    GSCALAR(options, "OPTIONS", AP_PERIPH_PROBE_CONTINUOUS),

#ifdef HAL_PERIPH_ENABLE_RPM_STREAM
    // @Param: RPM_MSG_RATE
    // @DisplayName: RPM sensor message rate
    // @Description: This is the rate RPM sensor data is sent in Hz. Zero means no send. Each sensor with a set ID is sent in turn.
    // @Units: Hz
    // @Range: 0 200
    // @Increment: 1
    // @User: Standard
    GSCALAR(rpm_msg_rate, "RPM_MSG_RATE", 0),
#endif

#if AP_EXTENDED_ESC_TELEM_ENABLED && HAL_WITH_ESC_TELEM
    // @Param: ESC_EXT_TLM_RATE
    // @DisplayName: ESC Extended telemetry message rate
    // @Description: This is the rate at which extended ESC Telemetry will be sent across the CAN bus for each ESC
    // @Units: Hz
    // @Range: 0 50
    // @Increment: 1
    // @User: Advanced
    GSCALAR(esc_extended_telem_rate, "ESC_EXT_TLM_RATE", AP_PERIPH_ESC_TELEM_RATE_DEFAULT / 10),
#endif

    AP_VAREND
};


void AP_Periph_FW::load_parameters(void)
{
    AP_Param::setup_sketch_defaults();

    AP_Param::check_var_info();

    if (!g.format_version.load() ||
        g.format_version != Parameters::k_format_version) {
        // erase all parameters
        StorageManager::erase();
        AP_Param::erase_all();

        // save the current format version
        g.format_version.set_and_save(Parameters::k_format_version);
    }
    g.format_version.set_default(Parameters::k_format_version);

    // Load all auto-loaded EEPROM variables
    AP_Param::load_all();
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        #pragma once

#include <AP_Common/AP_Common.h>
#include "GCS_MAVLink.h"

#define AP_PARAM_VEHICLE_NAME periph

// Global parameter class.
//
class Parameters {
public:
    static const uint16_t k_format_version = 2;

    enum {
        // Layout version number, always key zero.
        //
        k_param_format_version = 0,
        k_param_gps,
        k_param_compass,
        k_param_can_node,
        k_param_can_baudrate0,
        k_param_baro,
        k_param_buzz_volume,
        k_param_led_brightness,
        k_param_airspeed,
        k_param_rangefinder,
        k_param_flash_bootloader,
        k_param_rangefinder_baud0,
        k_param_adsb_baudrate,
        k_param_hardpoint_id,
        k_param_hardpoint_rate,
        k_param_baro_enable,
        k_param_esc_number0,
        k_param_battery_lib,
        k_param_debug,
        k_param_serial_number,
        k_param_adsb_port,
        k_param_servo_channels,
        k_param_rangefinder_port0,
        k_param_gps_port,
        k_param_msp_port,
        k_param_notify,
        k_param_esc_pwm_type,
        k_param_logger,
        k_param_log_bitmask,
        k_param_can_baudrate1,
        k_param_can_baudrate2,
        k_param_can_protocol0,
        k_param_can_protocol1,
        k_param_can_protocol2,
        k_param_sysid_this_mav,
        k_param_serial_manager,
        k_param_gps_mb_only_can_port,
        k_param_scripting,
        k_param_esc_telem_port,
        k_param_can_fdmode,
        k_param_can_fdbaudrate0,
        k_param_can_fdbaudrate1,
        k_param_node_stats,
        k_param_rangefinder_max_rate,
        k_param_efi,
        k_param_efi_port,
        k_param_efi_baudrate,
        k_param_esc_telem_rate,
        k_param_can_slcan_cport,
        k_param_temperature_sensor,
        k_param_esc_command_timeout_ms,
        k_param_proximity,
        k_param_proximity_baud,
        k_param_proximity_port,
        k_param_proximity_max_rate,
        k_param_nmea,
        k_param_kdecan,
        k_param_pole_count0,
        k_param_esc_serial_port0,
        k_param_esc_number1,
        k_param_pole_count1,
        k_param_esc_serial_port1,
        k_param_networking_periph,
        k_param_rpm_sensor,
        k_param_g_rcin,
        k_param_sitl,
        k_param_ahrs,
        k_param_battery_balance,
        k_param_battery_hide_mask,
        k_param_can_mirror_ports,
        k_param_rtc,
        k_param_can_terminate0,
        k_param_can_terminate1,
        k_param_can_terminate2,
        k_param_serial_options,
        k_param_relay,
        k_param_temperature_msg_rate,
        k_param_rangefinder_baud1,
        k_param_rangefinder_port1,
        k_param_options,
        k_param_rpm_msg_rate,
        k_param_esc_rate,
        k_param_esc_extended_telem_rate,
    };

    AP_Int16 format_version;
    AP_Int16 can_node;
    
    AP_Int32 can_baudrate[HAL_NUM_CAN_IFACES];
#if HAL_NUM_CAN_IFACES >= 2
    AP_Enum<AP_CAN::Protocol> can_protocol[HAL_NUM_CAN_IFACES];
#endif

#if AP_CAN_SLCAN_ENABLED
    AP_Int8 can_slcan_cport;
#endif

#ifdef HAL_PERIPH_ENABLE_BUZZER_WITHOUT_NOTIFY
    AP_Int8 buzz_volume;
#endif
#ifdef AP_PERIPH_HAVE_LED_WITHOUT_NOTIFY
    AP_Int8 led_brightness;
#endif
#ifdef HAL_PERIPH_ENABLE_BARO
    AP_Int8 baro_enable;
#endif
#if !defined(HAL_NO_FLASH_SUPPORT) && !defined(HAL_NO_ROMFS_SUPPORT)
    AP_Int8 flash_bootloader;
#endif

#ifdef HAL_PERIPH_ENABLE_RANGEFINDER
    AP_Int32 rangefinder_baud[RANGEFINDER_MAX_INSTANCES];
    AP_Int8 rangefinder_port[RANGEFINDER_MAX_INSTANCES];
    AP_Int16 rangefinder_max_rate;
#endif

#ifdef HAL_PERIPH_ENABLE_PROXIMITY
    AP_Int32 proximity_baud;
    AP_Int8 proximity_port;
    AP_Int16 proximity_max_rate;
#endif


#ifdef HAL_PERIPH_ENABLE_ADSB
    AP_Int32 adsb_baudrate;
    AP_Int8 adsb_port;
#endif

#ifdef HAL_PERIPH_ENABLE_PWM_HARDPOINT
    AP_Int16 hardpoint_id;
    AP_Int8 hardpoint_rate;
#endif

#if defined(HAL_PERIPH_ENABLE_HWESC) || defined(HAL_PERIPH_ENABLE_ESC_APD)
    #if defined ESC_NUMBERS
        #error "ESC_NUMBERS should not have been previously defined"
    #endif
    #if defined(APD_ESC_INSTANCES)
        #define ESC_NUMBERS APD_ESC_INSTANCES
    #else
        #define ESC_NUMBERS 2
    #endif // defined(APD_ESC_INSTANCES)
    AP_Int8 esc_number[ESC_NUMBERS];
    AP_Int8 esc_serial_port[ESC_NUMBERS];
#endif

#if defined(ESC_NUMBERS)
    AP_Int8 pole_count[ESC_NUMBERS];
#endif

#ifdef HAL_PERIPH_ENABLE_GPS
    AP_Int8 gps_port;
#if GPS_MOVING_BASELINE
    AP_Int8 gps_mb_only_can_port;
#endif
#endif

#ifdef HAL_PERIPH_ENABLE_MSP
    AP_Int8 msp_port;
#endif

#ifdef HAL_PERIPH_ENABLE_RC_OUT
    AP_Int16 esc_rate;
    AP_Int8 esc_pwm_type;
    AP_Int16 esc_command_timeout_ms;
#if HAL_WITH_ESC_TELEM && !HAL_GCS_ENABLED
    AP_Int8 esc_telem_port;
#endif
#if HAL_WITH_ESC_TELEM
    AP_Int32 esc_telem_rate;
#if AP_EXTENDED_ESC_TELEM_ENABLED
    AP_Int16 esc_extended_telem_rate;
#endif
#endif
#endif

    AP_Int8 debug;

    AP_Int32 serial_number;

#if HAL_LOGGING_ENABLED
    AP_Int32        log_bitmask;
#endif

#if HAL_GCS_ENABLED
    AP_Int16 sysid_this_mav;
#endif

#ifdef HAL_PERIPH_ENABLE_BATTERY
    AP_Int32 battery_hide_mask;
#endif

#ifdef HAL_PERIPH_ENABLE_EFI
    AP_Int32 efi_baudrate;
    AP_Int8 efi_port;
#endif

#if HAL_PERIPH_CAN_MIRROR
    AP_Int8 can_mirror_ports;
#endif // HAL_PERIPH_CAN_MIRROR

#ifdef HAL_PERIPH_ENABLE_DEVICE_TEMPERATURE
    AP_Int8 temperature_msg_rate;
#endif

#ifdef HAL_PERIPH_ENABLE_RPM_STREAM
    AP_Int16 rpm_msg_rate;
#endif

#if HAL_CANFD_SUPPORTED
    AP_Int8 can_fdmode;
    AP_Int8 can_fdbaudrate[HAL_NUM_CAN_IFACES];
#else
    static constexpr uint8_t can_fdmode = 0;
#endif

    AP_Int32 options;

    AP_Int8 can_terminate[HAL_NUM_CAN_IFACES];

    AP_Int8 node_stats;
    Parameters() {}
};

extern const AP_Param::Info var_info[];
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         # AP_Periph DroneCAN Peripheral Firmware

This is an ArduPilot based DroneCAN peripheral firmware. This firmware
takes advantage of the wide range of sensor drivers in ArduPilot to
make building a DroneCAN peripheral firmware easy.

The AP_Periph firmware is based on the same ChibiOS hwdef.dat system
that is used to define pinouts for STM32 based flight controllers
supported by ArduPilot. That means you can add support for a new
DroneCAN peripheral based on the STM32 by just writing a simple
hwdef.dat that defines the pinout of your device.

We have over 60 build targets building for AP_Periph firmwares. All
ArduPilot supported MCUs can be used, including:

 - STM32F1xx
 - STM32F3xx
 - STM32F4xx
 - STM32F7xx
 - STM32H7xx
 - STM32L4xx
 - STM32G4xx

More can be added using the hwdef.dat system

# Features

The AP_Periph firmware can be configured to enable a wide range of
DroneCAN sensor types. Support is included for:

 - GPS modules (including RTK GPS)
 - Magnetometers (SPI or I2C)
 - Barometers (SPI or I2C)
 - Airspeed sensors (I2C)
 - Rangefinders (UART or I2C)
 - ADSB (uAvionix compatible Ping ADSB receiver on UART)
 - Battery Monitor (Analog, I2C/SMBus, UART)
 - LEDs (GPIO, I2C or WS2812 serial)
 - Safety LED and Safety Switch
 - Buzzer (tonealarm or simple GPIO)
 - RC Output (All standard RCOutput protocols)
 - RC input
 - battery balance monitor
 - EFI engines
 - Proximity sensors

An AP_Periph DroneCAN firmware supports these DroneCAN features:

 - dynamic or static CAN node allocation
 - firmware upload
 - automatically generated bootloader
 - parameter storage in flash
 - easy bootloader update
 - high resiliance features using watchdog, CRC and board checks
 - firmware and parameter update via MissionPlanner or DroneCAN GUI tool when attached to an autopilot
 - firmware update via USB if USB port is provided
 - parameter update using SLCAN and DroneCAN GUI on standalone peripheral via USB, if provided

# Building

Using f103-GPS as an example, build the main firmware like this:

 - ./waf configure --board f103-GPS
 - ./waf AP_Periph

that will build a file build/f103-GPS/bin/AP_Periph.bin. You can
now load that using the CAN bootloader and either dronecan_gui_tool or
MissionPlanner DroneCAN support.

# Flashing

To load directly with a stlink-v2, do this:

 - st-flash write build/f103-GPS/bin/AP_Periph.bin 0x8006400

for the CUAV_GPS which loads at offset 0x10000 use this:

 - st-flash write build/CUAV_GPS/bin/AP_Periph.bin 0x8010000

# Flashing bootloader

To flash the bootloader use this:

 - st-flash write Tools/bootloaders/f103-GPS_bl.bin 0x8000000

# Building bootloader

To build the bootloader use this:

 - Tools/scripts/build_bootloaders.py f103-GPS

the resulting bootloader will be in Tools/bootloaders

# Firmware Builds

Firmware targets are automatically built and distributed on the
ArduPilot firmware server on firmware.ardupilot.org. These firmwares
can be loaded using Mission Planner or the DroneCAN GUI Tool. Parameters
for peripherals can be changed using the Mission Planner DroneCAN support
or using DroneCAN GUI Tools.

# User Bootloader Update

The bootloader is automatically stored in ROMFS in the main
firmware. End users can update the bootloader by setting the DroneCAN
parameter "FLASH_BOOTLOADER" to 1. After setting it to 1 the node will
respond with a debug text message which can be seen in the DroneCAN GUI
tool to show the result of the flash.

# SITL Testing

A wide range of DroneCAN peripherals are supported in the SITL
simulation system. The simplest way of starting a DroneCAN enabled
simulated vehicle is to use sim_vehicle.py.

For a quadplane use: sim_vehicle.py with the option -f quadplane-can

For a quadcopter use: sim_vehicle.py with the option -f quad-can

# Discussion and Feedback

Please join the discussions at these locations:

 - https://discuss.ardupilot.org/
 - https://ardupilot.org/discord

                                                                                                                                                                                           Release 1.7.0 26th February 2023
--------------------------------

This is a major AP_Periph release with the following key changes:

- fixed DroneCAN packet parsing bug when dealing with corrupt packets
- added BATT_HIDE_MASK parameter
- support IPv4 networking in AP_Periph and PPP gateway
- support per-cell battery monitoring
- rate limit EFI updates
- support serial tunnelling over DroneCAN
- support relays over DroneCAN via hardpoint messages
- support mapping MAVLink SEND_TEXT to DroneCAN debug levels
- fixed CANFD timings

Release 1.6.0 8th September 2023
--------------------------------

This is a major release with the following changes:

 - much faster CAN bootloader for faster firmware update
 - improved handling of peripherals with 2 or more CAN interfaces
 - support most AP_Periph features in SITL testing
 - added RC input support
 - added battery balance plug support
 - support sending RPM over DroneCAN
 - support for pitot temperature reporting

Release 1.5.1 23rd July 2023
---------------------------

This is a major release with the following changes:

- support serial tunnelling over DroneCAN
- raised CAN priority of MovingBaseline data
- support APD ESC telemetry
- support DroneCAN and CAN statistics reporting
- support KDECAN to DroneCAN translation

The serial tunnelling support allows for uCenter to be used over
DroneCAN with the serial tunnelling panel in the DroneCAN GUI
tool. This allows for monitoring of uBlox GPS over a telemetry link,
and update of F9P firmware over DroneCAN

Release 1.5.0 27th Mar 2023
---------------------------

This is a major release with the following changes:

- fixed airspeed bus default
- limit mag to 25Hz by default
- fixed send rate of GPS yaw
- fixed HW ESC telem temp units
- allow set of port for HW telem
- send GNSS heading message if available
- stop sending old GNSS Fix message

Release 1.4.1 27th Sep 2022
---------------------------

This is a minor release with one bug fix:

 - fixed compass diagnonal compensation for AP_Periph compasses

Release 1.4.0 4th Sep 2022
--------------------------

This is a major release with a significant number of changes:

 - use new AP_CheckFirmware system
 - fixed passing of WGS84 height from GPS
 - support CANFD on STM32H7
 - fixes for moving baseline yaw with DroneCAN GPS
 - fixed GPS dropout issues on F4 and L4 GPS
 - added EFI peripheral support
 - fixed non-contiguous mask for ESC telem

Release 1.3.1 15th Apr 2022
---------------------------

This is a minor release with a single bug fix:

 - fixed intermittent loss of GPS packets on F4 and L4 GPS nodes which caused loss of GPS lock on the flight controller

Release 1.3.0 18th Mar 2022
---------------------------

This is a major release with several significant bug fixes and
improvements:

 - added new peripherals: BirdCANdy, MatekL431, CubeOrange-periph,
   G4-ESC, HerePro, Hitec-Airspeed, HolybroG4GPS, HolybroGPS,
   Sierra-F405, Sierra-F421, Sierra-F9P, Sierra-L431,
   f103-QiotekPeriph, f405-MatekGPS, f405-MatekAirspeed, mRo-M10095,
   ARK_GPS, HitecMosaic, MatekH743-periph, Pixracer-periph

 - support dshot for CAN ESC outputs

 - support a wider range of notify options

 - numerous small bug fixes

 - support lua scripting in peripherals

 - switched to DroneCAN compiler and libraries

 - support logging in peripherals

 - support dual CAN bus

 - support BLHeli monitoring of ESC telemetry

 - support mavlink in peripherals

 - support moving baseline yaw dual-GPS on dual-CAN GPS

 - support MPPT battery driver

 - fixed MSP GPS yaw

Note that the next major release will add CANFD support.

Release 1.2.0 6th Jan 2020
--------------------------

This is a major release with several significant bug fixes and
improvements:

 - support for battery monitor nodes

 - support for testing in SITL

 - improvements in error reporting to the flight controller

 - fixes to stack sizes

 - MSP output support

 - support for BGR NCP5623 LEDs

 - switched to common CAN stack with main ArduPilot vehicle code

 - added several new board types


Release 1.1.0 14th May 2020
---------------------------

This is a major release with several significant bug fixes:

 - fixed initial GPS timestamp which could cause ArduPilot to get bad
   time sync

 - fixed airspeed pressure wrap

 - fixed rangefinder to send the RNGFND1_ADDR as sensor_id

 - added distinctive LED blink pattern when waiting for UAVCAN node ID
   allocation

 - added HWESC build targets for HobbyWing ESC telemetry

 - fixed RM3100 compass scaling bug

Release 1.0.0 9th November 2019
-------------------------------

Initial stable release
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                --[[
   example script to test lua socket API
--]]

---@diagnostic disable: param-type-mismatch
---@diagnostic disable: need-check-nil
---@diagnostic disable: redundant-parameter
---@diagnostic disable: undefined-field

PARAM_TABLE_KEY = 47
PARAM_TABLE_PREFIX = "WEB_"

-- add a parameter and bind it to a variable
function bind_add_param(name, idx, default_value)
    assert(param:add_param(PARAM_TABLE_KEY, idx, name, default_value), string.format('could not add param %s', name))
    return Parameter(PARAM_TABLE_PREFIX .. name)
end

-- Setup Parameters
assert(param:add_table(PARAM_TABLE_KEY, PARAM_TABLE_PREFIX, 6), 'net_test: could not add param table')

--[[
  // @Param: WEB_ENABLE
  // @DisplayName: enable web server
  // @Description: enable web server
  // @Values: 0:Disabled,1:Enabled
  // @User: Standard
--]]
local WEB_ENABLE = bind_add_param('ENABLE',  1, 1)

--[[
  // @Param: WEB_BIND_PORT
  // @DisplayName: web server TCP port
  // @Description: web server TCP port
  // @Range: 1 65535
  // @User: Standard
--]]
local WEB_BIND_PORT = bind_add_param('BIND_PORT', 2, 80)

--[[
  // @Param: WEB_DEBUG
  // @DisplayName: web server debugging
  // @Description: web server debugging
  // @Values: 0:Disabled,1:Enabled
  // @User: Advanced
--]]
local WEB_DEBUG = bind_add_param('DEBUG', 3, 0)

--[[
  // @Param: WEB_BLOCK_SIZE
  // @DisplayName: web server block size
  // @Description: web server block size for download
  // @Range: 1 65535
  // @User: Advanced
--]]
local WEB_BLOCK_SIZE = bind_add_param('BLOCK_SIZE', 4, 10240)

--[[
  // @Param: WEB_TIMEOUT
  // @DisplayName: web server timeout
  // @Description: timeout for inactive connections
  // @Units: s
  // @Range: 0.1 60
  // @User: Advanced
--]]
local WEB_TIMEOUT = bind_add_param('TIMEOUT', 5, 2.0)

--[[
  // @Param: WEB_SENDFILE_MIN
  // @DisplayName: web server minimum file size for sendfile
  // @Description: sendfile is an offloading mechanism for faster file download. If this is non-zero and the file is larger than this size then sendfile will be used for file download
  // @Range: 0 10000000
  // @User: Advanced
--]]
local WEB_SENDFILE_MIN = bind_add_param('SENDFILE_MIN', 6, 100000)

if WEB_ENABLE:get() ~= 1 then
   periph:can_printf("WebServer: disabled")
   return
end

periph:can_printf(string.format("WebServer: starting on port %u", WEB_BIND_PORT:get()))

local sock_listen = Socket(0)
local clients = {}

local DOCTYPE = "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2 Final//EN\">"
local SERVER_VERSION = "net_webserver 1.0"
local CONTENT_TEXT_HTML = "text/html;charset=UTF-8"
local CONTENT_OCTET_STREAM = "application/octet-stream"

local HIDDEN_FOLDERS = { "@SYS", "@ROMFS", "@MISSION", "@PARAM" }

local MNT_PREFIX = "/mnt"
local MNT_PREFIX2 = MNT_PREFIX .. "/"

local MIME_TYPES = {
   ["apj"] = CONTENT_OCTET_STREAM,
   ["dat"] = CONTENT_OCTET_STREAM,
   ["o"] = CONTENT_OCTET_STREAM,
   ["obj"] = CONTENT_OCTET_STREAM,
   ["lua"] = "text/x-lua",
   ["py"] = "text/x-python",
   ["shtml"] = CONTENT_TEXT_HTML,
   ["js"] = "text/javascript",
   -- thanks to https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types/Common_types
   ["aac"] = "audio/aac",
   ["abw"] = "application/x-abiword",
   ["arc"] = "application/x-freearc",
   ["avif"] = "image/avif",
   ["avi"] = "video/x-msvideo",
   ["azw"] = "application/vnd.amazon.ebook",
   ["bin"] = "application/octet-stream",
   ["bmp"] = "image/bmp",
   ["bz"] = "application/x-bzip",
   ["bz2"] = "application/x-bzip2",
   ["cda"] = "application/x-cdf",
   ["csh"] = "application/x-csh",
   ["css"] = "text/css",
   ["csv"] = "text/csv",
   ["doc"] = "application/msword",
   ["docx"] = "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
   ["eot"] = "application/vnd.ms-fontobject",
   ["epub"] = "application/epub+zip",
   ["gz"] = "application/gzip",
   ["gif"] = "image/gif",
   ["htm"] = CONTENT_TEXT_HTML,
   ["html"] = CONTENT_TEXT_HTML,
   ["ico"] = "image/vnd.microsoft.icon",
   ["ics"] = "text/calendar",
   ["jar"] = "application/java-archive",
   ["jpeg"] = "image/jpeg",
   ["json"] = "application/json",
   ["jsonld"] = "application/ld+json",
   ["mid"] = "audio/x-midi",
   ["mjs"] = "text/javascript",
   ["mp3"] = "audio/mpeg",
   ["mp4"] = "video/mp4",
   ["mpeg"] = "video/mpeg",
   ["mpkg"] = "application/vnd.apple.installer+xml",
   ["odp"] = "application/vnd.oasis.opendocument.presentation",
   ["ods"] = "application/vnd.oasis.opendocument.spreadsheet",
   ["odt"] = "application/vnd.oasis.opendocument.text",
   ["oga"] = "audio/ogg",
   ["ogv"] = "video/ogg",
   ["ogx"] = "application/ogg",
   ["opus"] = "audio/opus",
   ["otf"] = "font/otf",
   ["png"] = "image/png",
   ["pdf"] = "application/pdf",
   ["php"] = "application/x-httpd-php",
   ["ppt"] = "application/vnd.ms-powerpoint",
   ["pptx"] = "application/vnd.openxmlformats-officedocument.presentationml.presentation",
   ["rar"] = "application/vnd.rar",
   ["rtf"] = "application/rtf",
   ["sh"] = "application/x-sh",
   ["svg"] = "image/svg+xml",
   ["tar"] = "application/x-tar",
   ["tif"] = "image/tiff",
   ["tiff"] = "image/tiff",
   ["ts"] = "video/mp2t",
   ["ttf"] = "font/ttf",
   ["txt"] = "text/plain",
   ["vsd"] = "application/vnd.visio",
   ["wav"] = "audio/wav",
   ["weba"] = "audio/webm",
   ["webm"] = "video/webm",
   ["webp"] = "image/webp",
   ["woff"] = "font/woff",
   ["woff2"] = "font/woff2",
   ["xhtml"] = "application/xhtml+xml",
   ["xls"] = "application/vnd.ms-excel",
   ["xlsx"] = "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
   ["xml"] = "default.",
   ["xul"] = "application/vnd.mozilla.xul+xml",
   ["zip"] = "application/zip",
   ["3gp"] = "video",
   ["3g2"] = "video",
   ["7z"] = "application/x-7z-compressed",
}

--[[
 builtin dynamic pages
--]]
local DYNAMIC_PAGES = {

-- main home page
["/"] = [[
<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <title>ArduPilot</title>
    <script>
      <?lstr JS_LIBRARY['dynamic_load']?>
    </script>
</head>

<h2>ArduPilot PPP Gateway</h2>
<body onload="javascript: dynamic_load('board_status','/@DYNAMIC/board_status.shtml',1000)">

  <div id="main">
    <ul>
      <li><a href="mnt/">Filesystem Access</a></li>
      <li><a href="?FWUPDATE">Reboot for Firmware Update</a></li>
    </ul>
    </div>
<h2>Controller Status</h2>
  <div id="board_status"></div>
</body>
</html>
]],    
   
-- board status section on front page
["@DYNAMIC/board_status.shtml"] = [[
         <table>
         <tr><td>Firmware</td><td><?lstr FWVersion:string() ?></td></tr>
         <tr><td>GIT Hash</td><td><?lstr FWVersion:hash() ?></td></tr>
         <tr><td>Uptime</td><td><?lstr hms_uptime() ?></td></tr>
         <tr><td>IP</td><td><?lstr networking:address_to_str(networking:get_ip_active()) ?></td></tr>
         <tr><td>Netmask</td><td><?lstr networking:address_to_str(networking:get_netmask_active()) ?></td></tr>
         <tr><td>Gateway</td><td><?lstr networking:address_to_str(networking:get_gateway_active()) ?></td></tr>
         <tr><td>MCU Temperature</td><td><?lstr string.format("%.1fC", analog:mcu_temperature()) ?></td></tr>
         </table>
]]
}

reboot_counter = 0

local ACTION_PAGES = {
   ["/?FWUPDATE"] = function()
      periph:can_printf("Rebooting for firmware update")
      reboot_counter = 50
   end
}

--[[
 builtin javascript library functions
--]]
JS_LIBRARY = {
   ["dynamic_load"] = [[
      function dynamic_load(div_id, uri, period_ms) {
          var xhr = new XMLHttpRequest();
          xhr.open('GET', uri);
          
          xhr.setRequestHeader("Cache-Control", "no-cache, no-store, max-age=0");
          xhr.setRequestHeader("Expires", "Tue, 01 Jan 1980 1:00:00 GMT");
          xhr.setRequestHeader("Pragma", "no-cache");
          
          xhr.onload = function () {
              if (xhr.status === 200) {
                 var output = document.getElementById(div_id);
                 if (uri.endsWith('.shtml') || uri.endsWith('.html')) {
                  output.innerHTML = xhr.responseText;
                 } else {
                  output.textContent = xhr.responseText;
                 }
              }
              setTimeout(function() { dynamic_load(div_id,uri, period_ms); }, period_ms);
          }
          xhr.send();
     }
]]
}

if not sock_listen:bind("0.0.0.0", WEB_BIND_PORT:get()) then
   periph:can_printf(string.format("WebServer: failed to bind to TCP %u", WEB_BIND_PORT:get()))
   return
end

if not sock_listen:listen(20) then
   periph:can_printf("WebServer: failed to listen")
   return
end

function hms_uptime()
   local s = (millis()/1000):toint()
   local min = math.floor(s / 60) % 60
   local hr = math.floor(s / 3600)
   return string.format("%u hours %u minutes %u seconds", hr, min, s%60)
end

--[[
   split string by pattern
--]]
local function split(str, pattern)
   local ret = {}
   for s in string.gmatch(str, pattern) do
      table.insert(ret, s)
   end
   return ret
end

--[[
   return true if a string ends in the 2nd string
--]]
local function endswith(str, s)
   local len1 = #str
   local len2 = #s
   return string.sub(str,1+len1-len2,len1) == s
end

--[[
   return true if a string starts with the 2nd string
--]]
local function startswith(str, s)
   return string.sub(str,1,#s) == s
end

local debug_count=0

function DEBUG(txt)
   if WEB_DEBUG:get() ~= 0 then
      periph:can_printf(txt .. string.format(" [%u]", debug_count))
      debug_count = debug_count + 1
   end
end

--[[
   return index of element in a table
--]]
function table_index(t,el)
   for i,v in ipairs(t) do
      if v == el then
         return i
      end
   end
   return nil
end

--[[
   return true if a table contains a given element
--]]
function table_contains(t,el)
   local i = table_index(t, el)
   return i ~= nil
end

function is_hidden_dir(path)
   return table_contains(HIDDEN_FOLDERS, path)
end

local DAYS = { "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" }
local MONTHS = { "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" }

function isdirectory(path)
   local s = fs:stat(path)
   return s and s:is_directory()
end

--[[
   time string for directory listings
--]]
function file_timestring(path)
   local s = fs:stat(path)
   if not s then
      return ""
   end
   local mtime = s:mtime()
   local year, month, day, hour, min, sec, _ = rtc:clock_s_to_date_fields(mtime)
   if not year then
      return ""
   end
   return string.format("%04u-%02u-%02u %02u:%02u", year, month+1, day, hour, min, sec)
end

--[[
   time string for Last-Modified
--]]
function file_timestring_http(mtime)
   local year, month, day, hour, min, sec, wday = rtc:clock_s_to_date_fields(mtime)
   if not year then
      return ""
   end
   return string.format("%s, %02u %s %u %02u:%02u:%02u GMT",
                        DAYS[wday+1],
                        day,
                        MONTHS[month+1],
                        year,
                        hour,
                        min,
                        sec)
end

--[[
   parse a http time string to a uint32_t seconds timestamp
--]]
function file_timestring_http_parse(tstring)
   local dayname, day, monthname, year, hour, min, sec =
      string.match(tstring,
                   '(%w%w%w), (%d+) (%w%w%w) (%d%d%d%d) (%d%d):(%d%d):(%d%d) GMT')
   if not dayname then
      return nil
   end
   local mon = table_index(MONTHS, monthname)
   return rtc:date_fields_to_clock_s(year, mon-1, day, hour, min, sec)
end

--[[
   return true if path exists and is not a directory
--]]
function file_exists(path)
   local s = fs:stat(path)
   if not s then
      return false
   end
   return not s:is_directory()
end

--[[
   substitute variables of form {xxx} from a table
   from http://lua-users.org/wiki/StringInterpolation
--]]
function substitute_vars(s, vars)
   s = (string.gsub(s, "({([^}]+)})",
                    function(whole,i)
                       return vars[i] or whole
   end))
   return s
end

--[[
  lat or lon as a string, working around limited type in ftoa_engine
--]]
function latlon_str(ll)
   local ipart = tonumber(string.match(tostring(ll*1.0e-7), '(.*[.]).*'))
   local fpart = math.abs(ll - ipart*10000000)
   return string.format("%d.%u", ipart, fpart, ipart*10000000, ll)
end

--[[
 location string for home page
--]]
function location_string(loc)
   return substitute_vars([[<a href="https://www.google.com/maps/search/?api=1&query={lat},{lon}" target="_blank">{lat} {lon}</a> {alt}]],
      { ["lat"] = latlon_str(loc:lat()),
        ["lon"] = latlon_str(loc:lng()),
        ["alt"] = string.format("%.1fm", loc:alt()*1.0e-2) })
end

--[[
   client class for open connections
--]]
local function Client(_sock, _idx)
   local self = {}

   self.closed = false

   local sock = _sock
   local idx = _idx
   local have_header = false
   local header = ""
   local header_lines = {}
   local header_vars = {}
   local run = nil
   local protocol = nil
   local file = nil
   local start_time = millis()
   local offset = 0

   function self.read_header()
      local s = sock:recv(2048)
      if not s then
         local now = millis()
         if not sock:is_connected() or now - start_time > WEB_TIMEOUT:get()*1000 then
            -- EOF while looking for header
            DEBUG(string.format("%u: EOF", idx))
            self.remove()
            return false
         end
         return false
      end
      if not s or #s == 0 then
         return false
      end
      header = header .. s
      local eoh = string.find(s, '\r\n\r\n')
      if eoh then
         DEBUG(string.format("%u: got header", idx))
         have_header = true
         header_lines = split(header, "[^\r\n]+")
         -- blocking for reply
         sock:set_blocking(true)
         return true
      end
      return false
   end

   function self.sendstring(s)
      sock:send(s, #s)
   end

   function self.sendline(s)
      self.sendstring(s .. "\r\n")
   end

   --[[
      send a string with variable substitution using {varname}
   --]]
   function self.sendstring_vars(s, vars)
      self.sendstring(substitute_vars(s, vars))
   end
   
   function self.send_header(code, codestr, vars)
      self.sendline(string.format("%s %u %s", protocol, code, codestr))
      self.sendline(string.format("Server: %s", SERVER_VERSION))
      for k,v in pairs(vars) do
         self.sendline(string.format("%s: %s", k, v))
      end
      self.sendline("Connection: close")
      self.sendline("")
   end

   -- get size of a file
   function self.file_size(fname)
      local s = fs:stat(fname)
      if not s then
         return 0
      end
      local ret = s:size():toint()
      DEBUG(string.format("%u: size of '%s' -> %u", idx, fname, ret))
      return ret
   end


   --[[
      return full path with .. resolution
   --]]
   function self.full_path(path, name)
      DEBUG(string.format("%u: full_path(%s,%s)", idx, path, name))
      local ret = path
      if path == "/" and startswith(name,"@") then
         return name
      end
      if name == ".." then
         if path == "/" then
            return "/"
         end
         if endswith(path,"/") then
            path = string.sub(path, 1, #path-1)
         end
         local dir, _ = string.match(path, '(.*/)(.*)')
         if not dir then
            return path
         end
         return dir
      end
      if not endswith(ret, "/") then
         ret = ret .. "/"
      end
      ret = ret .. name
      DEBUG(string.format("%u: full_path(%s,%s) -> %s", idx, path, name, ret))
      return ret
   end
   
   function self.directory_list(path)
      sock:set_blocking(true)
      if startswith(path, "/@") then
         path = string.sub(path, 2, #path-1)
      end
      DEBUG(string.format("%u: directory_list(%s)", idx, path))
      local dlist = dirlist(path)
      if not dlist then
         dlist = {}
      end
      if not table_contains(dlist, "..") then
         -- on ChibiOS we don't get ..
         table.insert(dlist, "..")
      end
      if path == "/" then
         for _,v in ipairs(HIDDEN_FOLDERS) do
            table.insert(dlist, v)
         end
      end

      table.sort(dlist)
      self.send_header(200, "OK", {["Content-Type"]=CONTENT_TEXT_HTML})
      self.sendline(DOCTYPE)
      self.sendstring_vars([[
<html>
 <head>
  <title>Index of {path}</title>
 </head>
 <body>
<h1>Index of {path}</h1>
  <table>
   <tr><th align="left">Name</th><th align="left">Last modified</th><th align="left">Size</th></tr>
]], {path=path})
      for _,d in ipairs(dlist) do
         local skip = d == "."
         if not skip then
            local fullpath = self.full_path(path, d)
            local name = d
            local sizestr = "0"
            local stat = fs:stat(fullpath)
            local size = stat and stat:size() or 0
            if is_hidden_dir(fullpath) or (stat and stat:is_directory()) then
               name = name .. "/"
            elseif size >= 100*1000*1000 then
               sizestr = string.format("%uM", (size/(1000*1000)):toint())
            else
               sizestr = tostring(size)
            end
            local modtime = file_timestring(fullpath)
            self.sendstring_vars([[<tr><td align="left"><a href="{name}">{name}</a></td><td align="left">{modtime}</td><td align="left">{size}</td></tr>
]], { name=name, size=sizestr, modtime=modtime })
         end
      end
      self.sendstring([[
</table>
</body>
</html>
]])
   end

   -- send file content
   function self.send_file()
      if not sock:pollout(0) then
         return
      end
      local chunk = WEB_BLOCK_SIZE:get()
      local b = file:read(chunk)
      sock:set_blocking(true)
      if b and #b > 0 then
         local sent = sock:send(b, #b)
         if sent == -1 then
            run = nil
            self.remove()
            return
         end
         if sent < #b then
            file:seek(offset+sent)
         end
         offset = offset + sent
      end
      if not b or #b < chunk then
         -- EOF
         DEBUG(string.format("%u: sent file", idx))
         run = nil
         self.remove()
         return
      end
   end

   --[[
      load whole file as a string
   --]]
   function self.load_file()
      local chunk = WEB_BLOCK_SIZE:get()
      local ret = ""
      while true do
         local b = file:read(chunk)
         if not b or #b == 0 then
            break
         end
         ret = ret .. b
      end
      return ret
   end
   
   --[[
      evaluate some lua code and return as a string
   --]]
   function self.evaluate(code)
      local eval_code = "function eval_func()\n" .. code .. "\nend\n"
      local f, errloc, err = load(eval_code, "eval_func", "t", _ENV)
      if not f then
         DEBUG(string.format("load failed: err=%s errloc=%s", err, errloc))
         return nil
      end
      local success, err2 = pcall(f)
      if not success then
         DEBUG(string.format("pcall failed: err=%s", err2))
         return nil
      end
      local ok, s2 = pcall(eval_func)
      eval_func = nil
      if ok then
         return s2
      end
      return nil
   end

   --[[
      process a file as a lua CGI
   --]]
   function self.send_cgi()
      sock:set_blocking(true)
      local contents = self.load_file()
      local s = self.evaluate(contents)
      if s then
         self.sendstring(s)
      end
      self.remove()
   end

   --[[
      send file content with server side processsing
      files ending in .shtml can have embedded lua lika this:
      <?lua return "foo" ?>
      <?lstr 2.6+7.2 ?>

      Using 'lstr' a return tostring(yourcode) is added to the code
      automatically
   --]]
   function self.send_processed_file(dynamic_page)
      sock:set_blocking(true)
      local contents
      if dynamic_page then
         contents = file
      else
         contents = self.load_file()
      end
      while #contents > 0 do
         local pat1 = "(.-)[<][?]lua[ \n](.-)[?][>](.*)"
         local pat2 = "(.-)[<][?]lstr[ \n](.-)[?][>](.*)"
         local p1, p2, p3 = string.match(contents, pat1)
         if not p1 then
            p1, p2, p3 = string.match(contents, pat2)
            if not p1 then
               break
            end
            p2 = "return tostring(" .. p2 .. ")"
         end
         self.sendstring(p1)
         local s2 = self.evaluate(p2)
         if s2 then
            self.sendstring(s2)
         end
         contents = p3
      end
      self.sendstring(contents)
      self.remove()
   end
   
   -- return a content type
   function self.content_type(path)
      if path == "/" then
         return MIME_TYPES["html"]
      end
      local _, ext = string.match(path, '(.*[.])(.*)')
      ext = string.lower(ext)
      local ret = MIME_TYPES[ext]
      if not ret then
         return CONTENT_OCTET_STREAM
      end
      return ret
   end

   -- perform a file download
   function self.file_download(path)
      if startswith(path, "/@") then
         path = string.sub(path, 2, #path)
      end
      DEBUG(string.format("%u: file_download(%s)", idx, path))
      file = DYNAMIC_PAGES[path]
      dynamic_page = file ~= nil
      if not dynamic_page then
         file = io.open(path,"rb")
         if not file then
            DEBUG(string.format("%u: Failed to open '%s'", idx, path))
            return false
         end
      end
      local vars = {["Content-Type"]=self.content_type(path)}
      local cgi_processing = startswith(path, "/cgi-bin/") and endswith(path, ".lua")
      local server_side_processing = endswith(path, ".shtml")
      local stat = fs:stat(path)
      if not startswith(path, "@") and
         not server_side_processing and
         not cgi_processing and stat and
         not dynamic_page then
         local fsize = stat:size()
         local mtime = stat:mtime()
         vars["Content-Length"]= tostring(fsize)
         local modtime = file_timestring_http(mtime)
         if modtime then
            vars["Last-Modified"] = modtime
         end
         local if_modified_since = header_vars['If-Modified-Since']
         if if_modified_since then
            local tsec = file_timestring_http_parse(if_modified_since)
            if tsec and tsec >= mtime then
               DEBUG(string.format("%u: Not modified: %s %s", idx, modtime, if_modified_since))
               self.send_header(304, "Not Modified", vars)
               return true
            end
         end
      end
      self.send_header(200, "OK", vars)
      if server_side_processing or dynamic_page then
         DEBUG(string.format("%u: shtml processing %s", idx, path))
         run = self.send_processed_file(dynamic_page)
      elseif cgi_processing then
         DEBUG(string.format("%u: CGI processing %s", idx, path))
         run = self.send_cgi
      elseif stat and
         WEB_SENDFILE_MIN:get() > 0 and
         stat:size() >= WEB_SENDFILE_MIN:get() and
         sock:sendfile(file) then
         return true
      else
         run = self.send_file
      end
      return true
   end

   function self.not_found()
      self.send_header(404, "Not found", {})
   end

   function self.moved_permanently(relpath)
      if not startswith(relpath, "/") then
         relpath = "/" .. relpath
      end
      local location = string.format("http://%s%s", header_vars['Host'], relpath)
      DEBUG(string.format("%u: Redirect -> %s", idx, location))
      self.send_header(301, "Moved Permanently", {["Location"]=location})
   end
   
   -- process a single request
   function self.process_request()
      local h1 = header_lines[1]
      if not h1 or #h1 == 0 then
         DEBUG(string.format("%u: empty request", idx))
         return
      end
      local cmd = split(header_lines[1], "%S+")
      if not cmd or #cmd < 3 then
         DEBUG(string.format("bad request: %s", header_lines[1]))
         return
      end
      if cmd[1] ~= "GET" then
         DEBUG(string.format("bad op: %s", cmd[1]))
         return
      end
      protocol = cmd[3]
      if protocol ~= "HTTP/1.0" and protocol ~= "HTTP/1.1" then
         DEBUG(string.format("bad protocol: %s", protocol))
         return
      end
      local path = cmd[2]
      DEBUG(string.format("%u: path='%s'", idx, path))

      -- extract header variables
      for i = 2,#header_lines do
         local key, var = string.match(header_lines[i], '(.*): (.*)')
         if key then
            header_vars[key] = var
         end
      end

      if ACTION_PAGES[path] ~= nil then
         DEBUG(string.format("Running ACTION %s", path))
         local fn = ACTION_PAGES[path]
         self.send_header(200, "OK", {["Content-Type"]=CONTENT_TEXT_HTML})
         self.sendstring([[
<html>
<head>
<meta http-equiv="refresh" content="2; url=/">
</head>
</html>
]])
         fn()
         return
      end

      if DYNAMIC_PAGES[path] ~= nil then
         self.file_download(path)
         return
      end

      if path == MNT_PREFIX then
         path = "/"
      end
      if startswith(path, MNT_PREFIX2) then
         path = string.sub(path,#MNT_PREFIX2,#path)
      end

      if isdirectory(path) and
         not endswith(path,"/") and
         header_vars['Host'] and
         not is_hidden_dir(path) then
         self.moved_permanently(path .. "/")
         return
      end

      if path ~= "/" and endswith(path,"/") then
         path = string.sub(path, 1, #path-1)
      end

      if startswith(path,"/@") then
         path = string.sub(path, 2, #path)
      end

      -- see if we have an index file
      if isdirectory(path) and file_exists(path .. "/index.html") then
         DEBUG(string.format("%u: found index.html", idx))
         if self.file_download(path .. "/index.html") then
            return
         end
      end
      
      -- see if it is a directory
      if (path == "/" or
         DYNAMIC_PAGES[path] == nil) and
         (endswith(path,"/") or
          isdirectory(path) or
          is_hidden_dir(path)) then
         self.directory_list(path)
         return
      end
      
      -- or a file
      if self.file_download(path) then
         return
      end
      self.not_found(path)
   end

   -- update the client
   function self.update()
      if run then
         run()
         return
      end
      if not have_header then
         if not self.read_header() then
            return
         end
      end
      self.process_request()
      if not run then
         -- nothing more to do
         self.remove()
      end
   end

   function self.remove()
      DEBUG(string.format("%u: removing client OFFSET=%u", idx, offset))
      if self.closed then
         return
      end
      sock:close()
      self.closed = true
   end

   -- return the instance
   return self
end

--[[
   see if any new clients want to connect
--]]
local function check_new_clients()
   while sock_listen:pollin(0) do
      local sock = sock_listen:accept()
      if not sock then
         return
      end
      -- non-blocking for header read
      sock:set_blocking(false)
      -- find free client slot
      for i = 1, #clients+1 do
         if clients[i] == nil then
            local idx = i
            local client = Client(sock, idx)
            DEBUG(string.format("%u: New client", idx))
            clients[idx] = client
         end
      end
   end
end

--[[
   check for client activity
--]]
local function check_clients()
   for idx,client in ipairs(clients) do
      if not client.closed then
         client.update()
      end
      if client.closed then
         table.remove(clients,idx)
      end
   end
end

local function update()
   check_new_clients()
   check_clients()
   if reboot_counter then
      reboot_counter = reboot_counter - 1
      if reboot_counter == 0 then
         periph:can_printf("Rebooting")
         periph:reboot(true)
      end
   end
   return update,5
end

return update,100
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 /*
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
/*
  AP_Periph ADSB support. This is designed to talk to a Ping ADSB
  module over the UART
 */

#include <AP_HAL/AP_HAL_Boards.h>
#include "AP_Periph.h"

#ifdef HAL_PERIPH_ENABLE_ADSB

#include <AP_SerialManager/AP_SerialManager.h>
#include <dronecan_msgs.h>

extern const AP_HAL::HAL &hal;

/*
  init ADSB support
 */
void AP_Periph_FW::adsb_init(void)
{
    if (g.adsb_baudrate > 0) {
        auto *uart = hal.serial(g.adsb_port);
        if (uart == nullptr) {
            return;
        }
        uart->begin(AP_SerialManager::map_baudrate(g.adsb_baudrate), 256, 256);
    }
}

/*
  update ADSB subsystem
 */
void AP_Periph_FW::adsb_update(void)
{
    if (g.adsb_baudrate <= 0) {
        return;
    }

    auto *uart = hal.serial(g.adsb_port);
    if (uart == nullptr) {
        return;
    }

    // look for incoming MAVLink ADSB_VEHICLE packets
    const uint16_t nbytes = uart->available();
    for (uint16_t i=0; i<nbytes; i++) {
        const uint8_t c = (uint8_t)uart->read();

        // Try to get a new message
        if (mavlink_frame_char_buffer(&adsb.msg, &adsb.status, c, &adsb.msg, &adsb.status) == MAVLINK_FRAMING_OK) {
            if (adsb.msg.msgid == MAVLINK_MSG_ID_ADSB_VEHICLE) {
                // decode and send as UAVCAN TrafficReport
                static mavlink_adsb_vehicle_t msg;
                mavlink_msg_adsb_vehicle_decode(&adsb.msg, &msg);
                can_send_ADSB(msg);
            }
        }
    }

    /*
      some ADSB devices need a heartbeat to get the system ID
     */
    const uint32_t now_ms = AP_HAL::millis();
    if (now_ms - adsb.last_heartbeat_ms >= 1000) {
        adsb.last_heartbeat_ms = now_ms;
        mavlink_heartbeat_t heartbeat {};
        mavlink_message_t msg;
        heartbeat.type = MAV_TYPE_GENERIC;
        heartbeat.autopilot = MAV_AUTOPILOT_ARDUPILOTMEGA;
        auto len = mavlink_msg_heartbeat_encode_status(1,
                                                       MAV_COMP_ID_PERIPHERAL,
                                                       &adsb.status,
                                                       &msg, &heartbeat);

        uart->write((uint8_t*)&msg.magic, len);
    }
}

/*
  map an ADSB_VEHICLE MAVLink message to a UAVCAN TrafficReport message
 */
void AP_Periph_FW::can_send_ADSB(struct __mavlink_adsb_vehicle_t &msg)
{
    ardupilot_equipment_trafficmonitor_TrafficReport pkt {};
    pkt.timestamp.usec = 0;
    pkt.icao_address = msg.ICAO_address;
    pkt.tslc = msg.tslc;
    pkt.latitude_deg_1e7 = msg.lat;
    pkt.longitude_deg_1e7 = msg.lon;
    pkt.alt_m = msg.altitude * 1e-3;

    pkt.heading = radians(msg.heading * 1e-2);

    pkt.velocity[0] = cosf(pkt.heading) * msg.hor_velocity * 1e-2;
    pkt.velocity[1] = sinf(pkt.heading) * msg.hor_velocity * 1e-2;
    pkt.velocity[2] = -msg.ver_velocity * 1e-2;

    pkt.squawk = msg.squawk;
    memcpy(pkt.callsign, msg.callsign, MIN(sizeof(msg.callsign),sizeof(pkt.callsign)));
    if (msg.flags & 0x8000) {
        pkt.source = ARDUPILOT_EQUIPMENT_TRAFFICMONITOR_TRAFFICREPORT_SOURCE_ADSB_UAT;
    } else {
        pkt.source = ARDUPILOT_EQUIPMENT_TRAFFICMONITOR_TRAFFICREPORT_SOURCE_ADSB;
    }

    pkt.traffic_type = msg.emitter_type;

    if ((msg.flags & ADSB_FLAGS_VALID_ALTITUDE) != 0 && msg.altitude_type == 0) {
        pkt.alt_type = ARDUPILOT_EQUIPMENT_TRAFFICMONITOR_TRAFFICREPORT_ALT_TYPE_PRESSURE_AMSL;
    } else if ((msg.flags & ADSB_FLAGS_VALID_ALTITUDE) != 0 && msg.altitude_type == 1) {
        pkt.alt_type = ARDUPILOT_EQUIPMENT_TRAFFICMONITOR_TRAFFICREPORT_ALT_TYPE_WGS84;
    } else {
        pkt.alt_type = ARDUPILOT_EQUIPMENT_TRAFFICMONITOR_TRAFFICREPORT_ALT_TYPE_ALT_UNKNOWN;
    }

    pkt.lat_lon_valid = (msg.flags & ADSB_FLAGS_VALID_COORDS) != 0;
    pkt.heading_valid = (msg.flags & ADSB_FLAGS_VALID_HEADING) != 0;
    pkt.velocity_valid = (msg.flags & ADSB_FLAGS_VALID_VELOCITY) != 0;
    pkt.callsign_valid = (msg.flags & ADSB_FLAGS_VALID_CALLSIGN) != 0;
    pkt.ident_valid = (msg.flags & ADSB_FLAGS_VALID_SQUAWK) != 0;
    pkt.simulated_report = (msg.flags & ADSB_FLAGS_SIMULATED) != 0;

    // these flags are not in common.xml
    pkt.vertical_velocity_valid = (msg.flags & 0x0080) != 0;
    pkt.baro_valid = (msg.flags & 0x0100) != 0;

    uint8_t buffer[ARDUPILOT_EQUIPMENT_TRAFFICMONITOR_TRAFFICREPORT_MAX_SIZE];
    uint16_t total_size = ardupilot_equipment_trafficmonitor_TrafficReport_encode(&pkt, buffer, !periph.canfdout());

    canard_broadcast(ARDUPILOT_EQUIPMENT_TRAFFICMONITOR_TRAFFICREPORT_SIGNATURE,
                    ARDUPILOT_EQUIPMENT_TRAFFICMONITOR_TRAFFICREPORT_ID,
                    CANARD_TRANSFER_PRIORITY_LOWEST,
                    &buffer[0],
                    total_size);
}

#endif // HAL_PERIPH_ENABLE_ADSB
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            #include "AP_Periph.h"

#ifdef HAL_PERIPH_ENABLE_AIRSPEED

/*
  airspeed support
 */

#include <dronecan_msgs.h>

#ifndef AP_PERIPH_PROBE_CONTINUOUS
#define AP_PERIPH_PROBE_CONTINUOUS 0
#endif

/*
  update CAN airspeed
 */
void AP_Periph_FW::can_airspeed_update(void)
{
    if (!airspeed.enabled()) {
        return;
    }
#if AP_PERIPH_PROBE_CONTINUOUS
    if (option_is_set(PeriphOptions::PROBE_CONTINUOUS) && !hal.util->get_soft_armed() && !airspeed.healthy()) {
        uint32_t now = AP_HAL::millis();
        static uint32_t last_probe_ms;
        if (now - last_probe_ms >= 1000) {
            last_probe_ms = now;
            airspeed.allocate();
        }
    }
#endif
    uint32_t now = AP_HAL::millis();
    if (now - last_airspeed_update_ms < 50) {
        // max 20Hz data
        return;
    }
    last_airspeed_update_ms = now;
    airspeed.update();
    if (!airspeed.healthy()) {
        // don't send any data
        return;
    }
    const float press = airspeed.get_corrected_pressure();
    float temp;
    if (!airspeed.get_temperature(temp)) {
        temp = nanf("");
    } else {
        temp = C_TO_KELVIN(temp);
    }

    uavcan_equipment_air_data_RawAirData pkt {};

    // unfilled elements are NaN
    pkt.static_pressure = nanf("");
    pkt.static_pressure_sensor_temperature = nanf("");
    pkt.differential_pressure_sensor_temperature = nanf("");
    pkt.pitot_temperature = nanf("");

    // populate the elements we have
    pkt.differential_pressure = press;
    pkt.static_air_temperature = temp;

    // if a Pitot tube temperature sensor is available, use it
#if AP_TEMPERATURE_SENSOR_ENABLED
    for (uint8_t i=0; i<temperature_sensor.num_instances(); i++) {
        float temp_pitot;
        if (temperature_sensor.get_source(i) == AP_TemperatureSensor_Params::Source::Pitot_tube && temperature_sensor.get_temperature(temp_pitot, i)) {
            pkt.pitot_temperature = C_TO_KELVIN(temp_pitot);
            break;
        }
    }
#endif

    uint8_t buffer[UAVCAN_EQUIPMENT_AIR_DATA_RAWAIRDATA_MAX_SIZE];
    uint16_t total_size = uavcan_equipment_air_data_RawAirData_encode(&pkt, buffer, !periph.canfdout());

    canard_broadcast(UAVCAN_EQUIPMENT_AIR_DATA_RAWAIRDATA_SIGNATURE,
                    UAVCAN_EQUIPMENT_AIR_DATA_RAWAIRDATA_ID,
                    CANARD_TRANSFER_PRIORITY_LOW,
                    &buffer[0],
                    total_size);
}

#endif // HAL_PERIPH_ENABLE_AIRSPEED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       #include "AP_Periph.h"

#ifdef HAL_PERIPH_ENABLE_BARO

/*
  barometer support
 */

#include <dronecan_msgs.h>

/*
  update CAN baro
 */
void AP_Periph_FW::can_baro_update(void)
{
    if (!periph.g.baro_enable) {
        return;
    }
    baro.update();
    if (last_baro_update_ms == baro.get_last_update()) {
        return;
    }

    last_baro_update_ms = baro.get_last_update();
    if (!baro.healthy()) {
        // don't send any data
        return;
    }
    const float press = baro.get_pressure();
    const float temp = baro.get_temperature();

    {
        uavcan_equipment_air_data_StaticPressure pkt {};
        pkt.static_pressure = press;
        pkt.static_pressure_variance = 0; // should we make this a parameter?

        uint8_t buffer[UAVCAN_EQUIPMENT_AIR_DATA_STATICPRESSURE_MAX_SIZE];
        uint16_t total_size = uavcan_equipment_air_data_StaticPressure_encode(&pkt, buffer, !periph.canfdout());

        canard_broadcast(UAVCAN_EQUIPMENT_AIR_DATA_STATICPRESSURE_SIGNATURE,
                        UAVCAN_EQUIPMENT_AIR_DATA_STATICPRESSURE_ID,
                        CANARD_TRANSFER_PRIORITY_LOW,
                        &buffer[0],
                        total_size);
    }

    {
        uavcan_equipment_air_data_StaticTemperature pkt {};
        pkt.static_temperature = C_TO_KELVIN(temp);
        pkt.static_temperature_variance = 0; // should we make this a parameter?

        uint8_t buffer[UAVCAN_EQUIPMENT_AIR_DATA_STATICTEMPERATURE_MAX_SIZE];
        uint16_t total_size = uavcan_equipment_air_data_StaticTemperature_encode(&pkt, buffer, !periph.canfdout());

        canard_broadcast(UAVCAN_EQUIPMENT_AIR_DATA_STATICTEMPERATURE_SIGNATURE,
                        UAVCAN_EQUIPMENT_AIR_DATA_STATICTEMPERATURE_ID,
                        CANARD_TRANSFER_PRIORITY_LOW,
                        &buffer[0],
                        total_size);
    }
}

#endif // HAL_PERIPH_ENABLE_BARO
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                /*
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include "AP_Periph.h"

#ifdef HAL_PERIPH_ENABLE_BATTERY_BALANCE

#include <dronecan_msgs.h>

extern const AP_HAL::HAL &hal;

#ifndef AP_PERIPH_BATTERY_BALANCE_NUMCELLS_DEFAULT
#define AP_PERIPH_BATTERY_BALANCE_NUMCELLS_DEFAULT 0
#endif

#ifndef AP_PERIPH_BATTERY_BALANCE_RATE_DEFAULT
#define AP_PERIPH_BATTERY_BALANCE_RATE_DEFAULT 1
#endif

#ifndef AP_PERIPH_BATTERY_BALANCE_CELL1_PIN_DEFAULT
#define AP_PERIPH_BATTERY_BALANCE_CELL1_PIN_DEFAULT 1
#endif

#ifndef AP_PERIPH_BATTERY_BALANCE_ID_DEFAULT
#define AP_PERIPH_BATTERY_BALANCE_ID_DEFAULT 0
#endif


const AP_Param::GroupInfo BattBalance::var_info[] {
    // @Param: _NUM_CELLS
    // @DisplayName: Number of battery cells
    // @Description: Number of battery cells to monitor
    // @Range: 0 64
    AP_GROUPINFO("_NUM_CELLS", 1, BattBalance, num_cells, AP_PERIPH_BATTERY_BALANCE_NUMCELLS_DEFAULT),

    // @Param: _ID
    // @DisplayName: Battery ID
    // @Description: Battery ID to match against other batteries
    // @Range: 0 127
    AP_GROUPINFO("_ID", 2, BattBalance, id, AP_PERIPH_BATTERY_BALANCE_ID_DEFAULT),
        
    // @Param: _RATE
    // @DisplayName: Send Rate
    // @Description: Rate to send cell information
    // @Range: 0 20
    AP_GROUPINFO("_RATE", 3, BattBalance, rate, AP_PERIPH_BATTERY_BALANCE_RATE_DEFAULT),

    // @Param: _CELL1_PIN
    // @DisplayName: First analog pin
    // @Description: Analog pin of the first cell. Later cells must be sequential
    // @Range: 0 127
    AP_GROUPINFO("_CELL1_PIN", 4, BattBalance, cell1_pin, AP_PERIPH_BATTERY_BALANCE_CELL1_PIN_DEFAULT),
        
    AP_GROUPEND
};

BattBalance::BattBalance(void)
{
    AP_Param::setup_object_defaults(this, var_info);
}

void AP_Periph_FW::batt_balance_update()
{
    const int8_t ncell = battery_balance.num_cells;
    if (ncell <= 0) {
        return;
    }

    // allocate cell sources if needed
    if (battery_balance.cells == nullptr) {
        battery_balance.cells = NEW_NOTHROW AP_HAL::AnalogSource*[ncell];
        if (battery_balance.cells == nullptr) {
            return;
        }
        battery_balance.cells_allocated = ncell;
        for (uint8_t i=0; i<battery_balance.cells_allocated; i++) {
            battery_balance.cells[i] = hal.analogin->channel(battery_balance.cell1_pin + i);
        }
    }

    const uint32_t now = AP_HAL::millis();
    if (now - battery_balance.last_send_ms < 1000.0/battery_balance.rate.get()) {
        return;
    }
    battery_balance.last_send_ms = now;

    // allocate space for the packet. This is a large
    // packet that won't fit on the stack, so dynamically allocate
    auto *pkt = NEW_NOTHROW ardupilot_equipment_power_BatteryInfoAux;
    uint8_t *buffer = NEW_NOTHROW uint8_t[ARDUPILOT_EQUIPMENT_POWER_BATTERYINFOAUX_MAX_SIZE];
    if (pkt == nullptr || buffer == nullptr) {
        delete pkt;
        delete [] buffer;
        return;
    }

    pkt->voltage_cell.len = battery_balance.cells_allocated;
    float last_cell = 0;
    for (uint8_t i=0; i<battery_balance.cells_allocated; i++) {
        auto *chan = battery_balance.cells[i];
        if (chan == nullptr) {
            continue;
        }
        const float v = chan->voltage_average();
        pkt->voltage_cell.data[i] = v - last_cell;
        last_cell = v;
    }
    pkt->max_current = nanf("");
    pkt->nominal_voltage = nanf("");
    pkt->battery_id = uint8_t(battery_balance.id);

    // encode and send message:
    const uint16_t total_size = ardupilot_equipment_power_BatteryInfoAux_encode(pkt, buffer, !periph.canfdout());

    canard_broadcast(ARDUPILOT_EQUIPMENT_POWER_BATTERYINFOAUX_SIGNATURE,
                     ARDUPILOT_EQUIPMENT_POWER_BATTERYINFOAUX_ID,
                     CANARD_TRANSFER_PRIORITY_LOW,
                     buffer,
                     total_size);

    delete pkt;
    delete [] buffer;
}

#endif  // HAL_PERIPH_ENABLE_BATTERY_BALANCE

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             #pragma once

#ifdef HAL_PERIPH_ENABLE_BATTERY_BALANCE

class BattBalance {
public:
    friend class AP_Periph_FW;
    BattBalance(void);

    static const struct AP_Param::GroupInfo var_info[];

private:
    AP_Int8 num_cells;
    AP_Int8 id;
    AP_Int8 cell1_pin;
    AP_Float rate;
    uint32_t last_send_ms;

    AP_HAL::AnalogSource **cells;
    uint8_t cells_allocated;
};

#endif // HAL_PERIPH_ENABLE_BATTERY_BALANCE

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      #include "AP_Periph.h"

#ifdef HAL_PERIPH_ENABLE_MAG

/*
  magnetometer support
 */

#include <dronecan_msgs.h>

#ifndef AP_PERIPH_MAG_MAX_RATE
#define AP_PERIPH_MAG_MAX_RATE 25U
#endif

#ifndef AP_PERIPH_PROBE_CONTINUOUS
#define AP_PERIPH_PROBE_CONTINUOUS 0
#endif

#ifndef AP_PERIPH_MAG_HIRES
#define AP_PERIPH_MAG_HIRES 0
#endif

extern const AP_HAL::HAL &hal;

/*
  update CAN magnetometer
 */
void AP_Periph_FW::can_mag_update(void)
{
    if (!compass.available()) {
        return;
    }

#if AP_PERIPH_MAG_MAX_RATE > 0
    // don't flood the bus with very high rate magnetometers
    const uint32_t now_ms = AP_HAL::millis();
    if (now_ms - last_mag_update_ms < (1000U / AP_PERIPH_MAG_MAX_RATE)) {
        return;
    }
#endif

    compass.read();

#if AP_PERIPH_PROBE_CONTINUOUS
    if (option_is_set(PeriphOptions::PROBE_CONTINUOUS) && !hal.util->get_soft_armed() && (compass.get_count() == 0)) {
        static uint32_t last_probe_ms;
        uint32_t now = AP_HAL::millis();
        if (now - last_probe_ms >= 1000) {
            last_probe_ms = now;
            compass.init();
        }
    }
#endif

    if (last_mag_update_ms == compass.last_update_ms()) {
        return;
    }
    if (!compass.healthy()) {
        return;
    }

    last_mag_update_ms = compass.last_update_ms();
    Vector3f field_Ga = compass.get_field() * 0.001;

#if !AP_PERIPH_MAG_HIRES
    // normal message, float16 values
    uavcan_equipment_ahrs_MagneticFieldStrength pkt {};

    for (uint8_t i=0; i<3; i++) {
        pkt.magnetic_field_ga[i] = field_Ga[i];
    }
    
    uint8_t buffer[UAVCAN_EQUIPMENT_AHRS_MAGNETICFIELDSTRENGTH_MAX_SIZE];
    uint16_t total_size = uavcan_equipment_ahrs_MagneticFieldStrength_encode(&pkt, buffer, !periph.canfdout());

    canard_broadcast(UAVCAN_EQUIPMENT_AHRS_MAGNETICFIELDSTRENGTH_SIGNATURE,
                    UAVCAN_EQUIPMENT_AHRS_MAGNETICFIELDSTRENGTH_ID,
                    CANARD_TRANSFER_PRIORITY_LOW,
                    &buffer[0],
                    total_size);
#else
    // High resolution magnetometer, for magnetic surveys
    dronecan_sensors_magnetometer_MagneticFieldStrengthHiRes pkt {};

    for (uint8_t i=0; i<3; i++) {
        pkt.magnetic_field_ga[i] = field_Ga[i];
    }
    
    uint8_t buffer[DRONECAN_SENSORS_MAGNETOMETER_MAGNETICFIELDSTRENGTHHIRES_MAX_SIZE];
    uint16_t total_size = dronecan_sensors_magnetometer_MagneticFieldStrengthHiRes_encode(&pkt, buffer, !periph.canfdout());

    canard_broadcast(DRONECAN_SENSORS_MAGNETOMETER_MAGNETICFIELDSTRENGTHHIRES_SIGNATURE,
                     DRONECAN_SENSORS_MAGNETOMETER_MAGNETICFIELDSTRENGTHHIRES_ID,
                     CANARD_TRANSFER_PRIORITY_LOW,
                     &buffer[0],
                     total_size);
#endif // AP_PERIPH_MAG_HIRES
}

#endif // HAL_PERIPH_ENABLE_MAG
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         #include "AP_Periph.h"

#ifdef HAL_PERIPH_ENABLE_EFI

/*
  EFI support
 */

#include <dronecan_msgs.h>

#ifndef AP_PERIPH_EFI_MAX_RATE
// default to 2x the AP_Vehicle rate
#define AP_PERIPH_EFI_MAX_RATE 100U
#endif

/*
  update CAN EFI
 */
void AP_Periph_FW::can_efi_update(void)
{
    if (!efi.enabled()) {
        return;
    }

#if AP_PERIPH_EFI_MAX_RATE > 0
    const uint32_t now_ms = AP_HAL::millis();
    if (now_ms - last_efi_update_ms < (1000U / AP_PERIPH_EFI_MAX_RATE)) {
        return;
    }
    last_efi_update_ms = now_ms;
#endif

    efi.update();
    const uint32_t update_ms = efi.get_last_update_ms();
    if (!efi.is_healthy() || efi_update_ms == update_ms) {
        return;
    }
    efi_update_ms = update_ms;
    EFI_State state;
    efi.get_state(state);

    {
        /*
          send status packet
        */
        uavcan_equipment_ice_reciprocating_Status pkt {};

        // state maps 1:1 from Engine_State
        pkt.state = uint8_t(state.engine_state);

        switch (state.crankshaft_sensor_status) {
        case Crankshaft_Sensor_Status::NOT_SUPPORTED:
            break;
        case Crankshaft_Sensor_Status::OK:
            pkt.flags |= UAVCAN_EQUIPMENT_ICE_RECIPROCATING_STATUS_FLAG_CRANKSHAFT_SENSOR_ERROR_SUPPORTED;
            break;
        case Crankshaft_Sensor_Status::ERROR:
            pkt.flags |=
                UAVCAN_EQUIPMENT_ICE_RECIPROCATING_STATUS_FLAG_CRANKSHAFT_SENSOR_ERROR_SUPPORTED |
                UAVCAN_EQUIPMENT_ICE_RECIPROCATING_STATUS_FLAG_CRANKSHAFT_SENSOR_ERROR;
            break;
        }

        switch (state.temperature_status) {
        case Temperature_Status::NOT_SUPPORTED:
            break;
        case Temperature_Status::OK:
            pkt.flags |= UAVCAN_EQUIPMENT_ICE_RECIPROCATING_STATUS_FLAG_TEMPERATURE_SUPPORTED;
            break;
        case Temperature_Status::BELOW_NOMINAL:
            pkt.flags |=
                UAVCAN_EQUIPMENT_ICE_RECIPROCATING_STATUS_FLAG_TEMPERATURE_SUPPORTED |
                UAVCAN_EQUIPMENT_ICE_RECIPROCATING_STATUS_FLAG_TEMPERATURE_BELOW_NOMINAL;
            break;
        case Temperature_Status::ABOVE_NOMINAL:
            pkt.flags |=
                UAVCAN_EQUIPMENT_ICE_RECIPROCATING_STATUS_FLAG_TEMPERATURE_SUPPORTED |
                UAVCAN_EQUIPMENT_ICE_RECIPROCATING_STATUS_FLAG_TEMPERATURE_ABOVE_NOMINAL;
            break;
        case Temperature_Status::OVERHEATING:
            pkt.flags |=
                UAVCAN_EQUIPMENT_ICE_RECIPROCATING_STATUS_FLAG_TEMPERATURE_SUPPORTED |
                UAVCAN_EQUIPMENT_ICE_RECIPROCATING_STATUS_FLAG_TEMPERATURE_OVERHEATING;
            break;
        case Temperature_Status::EGT_ABOVE_NOMINAL:
            pkt.flags |=
                UAVCAN_EQUIPMENT_ICE_RECIPROCATING_STATUS_FLAG_TEMPERATURE_SUPPORTED |
                UAVCAN_EQUIPMENT_ICE_RECIPROCATING_STATUS_FLAG_TEMPERATURE_EGT_ABOVE_NOMINAL;
            break;
        }

        switch (state.fuel_pressure_status) {
        case Fuel_Pressure_Status::NOT_SUPPORTED:
            break;
        case Fuel_Pressure_Status::OK:
            pkt.flags |= UAVCAN_EQUIPMENT_ICE_RECIPROCATING_STATUS_FLAG_FUEL_PRESSURE_SUPPORTED;
            break;
        case Fuel_Pressure_Status::BELOW_NOMINAL:
            pkt.flags |=
                UAVCAN_EQUIPMENT_ICE_RECIPROCATING_STATUS_FLAG_FUEL_PRESSURE_SUPPORTED |
                UAVCAN_EQUIPMENT_ICE_RECIPROCATING_STATUS_FLAG_FUEL_PRESSURE_BELOW_NOMINAL;
            break;
        case Fuel_Pressure_Status::ABOVE_NOMINAL:
            pkt.flags |=
                UAVCAN_EQUIPMENT_ICE_RECIPROCATING_STATUS_FLAG_FUEL_PRESSURE_SUPPORTED |
                UAVCAN_EQUIPMENT_ICE_RECIPROCATING_STATUS_FLAG_FUEL_PRESSURE_ABOVE_NOMINAL;
            break;
        }

        switch (state.oil_pressure_status) {
        case Oil_Pressure_Status::NOT_SUPPORTED:
            break;
        case Oil_Pressure_Status::OK:
            pkt.flags |= UAVCAN_EQUIPMENT_ICE_RECIPROCATING_STATUS_FLAG_OIL_PRESSURE_SUPPORTED;
            break;
        case Oil_Pressure_Status::BELOW_NOMINAL:
            pkt.flags |=
                UAVCAN_EQUIPMENT_ICE_RECIPROCATING_STATUS_FLAG_OIL_PRESSURE_SUPPORTED |
                UAVCAN_EQUIPMENT_ICE_RECIPROCATING_STATUS_FLAG_OIL_PRESSURE_BELOW_NOMINAL;
            break;
        case Oil_Pressure_Status::ABOVE_NOMINAL:
            pkt.flags |=
                UAVCAN_EQUIPMENT_ICE_RECIPROCATING_STATUS_FLAG_OIL_PRESSURE_SUPPORTED |
                UAVCAN_EQUIPMENT_ICE_RECIPROCATING_STATUS_FLAG_OIL_PRESSURE_ABOVE_NOMINAL;
            break;
        }

        switch (state.detonation_status) {
        case Detonation_Status::NOT_SUPPORTED:
            break;
        case Detonation_Status::NOT_OBSERVED:
            pkt.flags |=
                UAVCAN_EQUIPMENT_ICE_RECIPROCATING_STATUS_FLAG_DETONATION_SUPPORTED;
            break;
        case Detonation_Status::OBSERVED:
            pkt.flags |=
                UAVCAN_EQUIPMENT_ICE_RECIPROCATING_STATUS_FLAG_DETONATION_SUPPORTED |
                UAVCAN_EQUIPMENT_ICE_RECIPROCATING_STATUS_FLAG_DETONATION_OBSERVED;
            break;
        }

        switch (state.misfire_status) {
        case Misfire_Status::NOT_SUPPORTED:
            break;
        case Misfire_Status::NOT_OBSERVED:
            pkt.flags |=
                UAVCAN_EQUIPMENT_ICE_RECIPROCATING_STATUS_FLAG_MISFIRE_SUPPORTED;
            break;
        case Misfire_Status::OBSERVED:
            pkt.flags |=
                UAVCAN_EQUIPMENT_ICE_RECIPROCATING_STATUS_FLAG_MISFIRE_SUPPORTED |
                UAVCAN_EQUIPMENT_ICE_RECIPROCATING_STATUS_FLAG_MISFIRE_OBSERVED;
            break;
        }

        switch (state.debris_status) {
        case Debris_Status::NOT_SUPPORTED:
            break;
        case Debris_Status::NOT_DETECTED:
            pkt.flags |=
                UAVCAN_EQUIPMENT_ICE_RECIPROCATING_STATUS_FLAG_DEBRIS_SUPPORTED;
            break;
        case Debris_Status::DETECTED:
            pkt.flags |=
                UAVCAN_EQUIPMENT_ICE_RECIPROCATING_STATUS_FLAG_DEBRIS_SUPPORTED |
                UAVCAN_EQUIPMENT_ICE_RECIPROCATING_STATUS_FLAG_DEBRIS_DETECTED;
            break;
        }

        pkt.engine_load_percent = state.engine_load_percent;
        pkt.engine_speed_rpm = state.engine_speed_rpm;
        pkt.spark_dwell_time_ms = state.spark_dwell_time_ms;
        pkt.atmospheric_pressure_kpa = state.atmospheric_pressure_kpa;
        pkt.intake_manifold_pressure_kpa = state.intake_manifold_pressure_kpa;
        pkt.intake_manifold_temperature = state.intake_manifold_temperature;
        pkt.coolant_temperature = state.coolant_temperature;
        pkt.oil_pressure = state.oil_pressure;
        pkt.oil_temperature = state.oil_temperature;
        pkt.fuel_pressure = state.fuel_pressure;
        pkt.fuel_consumption_rate_cm3pm = state.fuel_consumption_rate_cm3pm;
        pkt.estimated_consumed_fuel_volume_cm3 = state.estimated_consumed_fuel_volume_cm3;
        pkt.throttle_position_percent = state.throttle_position_percent;
        pkt.ecu_index = state.ecu_index;
        pkt.spark_plug_usage = uint8_t(state.spark_plug_usage);

        // assume single set of cylinder status
        pkt.cylinder_status.len = 1;
        auto &c = pkt.cylinder_status.data[0];
        const auto &state_c = state.cylinder_status;
        c.ignition_timing_deg = state_c.ignition_timing_deg;
        c.injection_time_ms = state_c.injection_time_ms;
        c.cylinder_head_temperature = state_c.cylinder_head_temperature;
        c.exhaust_gas_temperature = state_c.exhaust_gas_temperature;
        c.lambda_coefficient = state_c.lambda_coefficient;

        uint8_t buffer[UAVCAN_EQUIPMENT_ICE_RECIPROCATING_STATUS_MAX_SIZE];
        const uint16_t total_size = uavcan_equipment_ice_reciprocating_Status_encode(&pkt, buffer, !canfdout());

        canard_broadcast(UAVCAN_EQUIPMENT_ICE_RECIPROCATING_STATUS_SIGNATURE,
                        UAVCAN_EQUIPMENT_ICE_RECIPROCATING_STATUS_ID,
                        CANARD_TRANSFER_PRIORITY_LOW,
                        &buffer[0],
                        total_size);
    }
}

#endif // HAL_PERIPH_ENABLE_EFI
                                         /*
  ESC Telemetry for the APD HV Pro ESC

  Protocol is here: https://docs.powerdrives.net/products/hv_pro/uart-telemetry-output
 */
#include "esc_apd_telem.h"
#include <AP_HAL/utility/sparse-endian.h>
#include <AP_Math/crc.h>
#include <AP_Math/definitions.h>
#include <string.h>

#ifdef HAL_PERIPH_ENABLE_ESC_APD

extern const AP_HAL::HAL& hal;

#define TELEM_HEADER 0x9B
#define TELEM_LEN    0x16

ESC_APD_Telem::ESC_APD_Telem (AP_HAL::UARTDriver *_uart, float num_poles) :
    pole_count(num_poles),
    uart(_uart) {
    uart->begin(115200);
}

bool ESC_APD_Telem::update() {
    uint32_t n = uart->available();
    if (n == 0) {
        return false;
    }

    // don't read too much in one loop to prevent too high CPU load
    if (n > 50) {
        n = 50;
    }

    bool ret = false;

    while (n--) {
        uint8_t b = uart->read();
        received.bytes[len++] = b;

        // check the packet size first
        if ((size_t)len >= sizeof(received.packet)) {
            // we have a full packet, check the stop byte
            if (received.packet.stop == 65535) {
                // valid stop byte, check the CRC
                if (crc_fletcher16(received.bytes, 18) == received.packet.checksum) {
                    // valid packet, copy the data we need and reset length
                    decoded.voltage = le16toh(received.packet.voltage) * 1e-2f;
                    decoded.temperature = convert_temperature(le16toh(received.packet.temperature));
                    decoded.current = ((int16_t)le16toh(received.packet.bus_current)) * (1 / 12.5f);
                    decoded.rpm = le32toh(received.packet.erpm) / pole_count;
                    decoded.power_rating_pct = le16toh(received.packet.motor_duty) * 1e-2f;
                    ret = true;
                    len = 0;
                } else {
                    // we have an invalid packet, shift it back a byte
                    shift_buffer();
                }
            } else {
                // invalid stop byte, we've lost sync, shift the packet by 1 byte
                shift_buffer();
            }
            
        }
    }
    return ret;
}

// shift the decode buffer left by 1 byte, and rewind the progress
void ESC_APD_Telem::shift_buffer(void) {
    memmove(received.bytes, received.bytes + 1, sizeof(received.bytes) - 1);
    len--;
}

// convert the raw ESC temperature to a useful value (in Kelvin)
// based on the 1.1 example C code found here https://docs.powerdrives.net/products/hv_pro/uart-telemetry-output
float ESC_APD_Telem::convert_temperature(uint16_t raw) const {
    const float series_resistor     = 10000;
    const float nominal_resistance  = 10000;
    const float nominal_temperature = 25;
    const float b_coefficent        = 3455;


    const float Rntc = series_resistor / ((4096 / float(raw)) - 1);

    float temperature = Rntc / nominal_resistance;          // (R/Ro)
    temperature = logf(temperature);                        // ln(R/Ro)
    temperature /= b_coefficent;                            // 1/B * ln(R/Ro)
    temperature += 1 / C_TO_KELVIN(nominal_temperature); // + (1/To)
    temperature = 1 / temperature;                          // invert

    // the example code rejected anything below 0C, or above 200C, the 200C clamp makes some sense, the below 0C is harder to accept
    return temperature;
}

#endif // HAL_PERIPH_ENABLE_ESC_APD
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         /*
  ESC Telemetry for APD ESC.
 */

#pragma once

#include <AP_HAL/AP_HAL.h>

#ifdef HAL_PERIPH_ENABLE_ESC_APD

class ESC_APD_Telem {
public:
    ESC_APD_Telem (AP_HAL::UARTDriver *_uart, float num_poles);
    bool update();

    CLASS_NO_COPY(ESC_APD_Telem);

    struct telem {
        uint32_t error_count;
        float voltage;
        float current;
        float temperature; // kelvin
        int32_t rpm;
        uint8_t power_rating_pct;
    };

    const telem &get_telem(void) {
        return decoded;
    }

private:
    AP_HAL::UARTDriver *uart;

    union {
        struct PACKED {
            uint16_t voltage;
            uint16_t temperature;
            int16_t bus_current;
            uint16_t reserved0;
            uint32_t erpm;
            uint16_t input_duty;
            uint16_t motor_duty;
            uint16_t reserved1;
            uint16_t checksum; // 16 bit fletcher checksum
            uint16_t stop; // should always be 65535 on a valid packet
        } packet;
        uint8_t bytes[22];
    } received;
    static_assert(sizeof(received.packet) == sizeof(received.bytes), "The packet must be the same size as the raw buffer");

    uint8_t len;

    struct telem decoded;

    float pole_count;

    float convert_temperature(uint16_t raw) const;
    void shift_buffer(void);
};

#endif // HAL_PERIPH_ENABLE_ESC_APD
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   #include "AP_Periph.h"

#ifdef HAL_PERIPH_ENABLE_GPS

/*
  GPS support
 */

#include <dronecan_msgs.h>
#include <AP_GPS/RTCM3_Parser.h>

#define DEBUG_PRINTS 0

#if DEBUG_PRINTS
 # define Debug(fmt, args ...)  do {can_printf(fmt "\n", ## args);} while(0)
#else
 # define Debug(fmt, args ...)
#endif

/*
  handle gnss::RTCMStream
 */
void AP_Periph_FW::handle_RTCMStream(CanardInstance* canard_instance, CanardRxTransfer* transfer)
{
    uavcan_equipment_gnss_RTCMStream req;
    if (uavcan_equipment_gnss_RTCMStream_decode(transfer, &req)) {
        return;
    }
    gps.handle_gps_rtcm_fragment(0, req.data.data, req.data.len);
}

/*
    handle gnss::MovingBaselineData
*/
#if GPS_MOVING_BASELINE
void AP_Periph_FW::handle_MovingBaselineData(CanardInstance* canard_instance, CanardRxTransfer* transfer)
{
    ardupilot_gnss_MovingBaselineData msg;
    if (ardupilot_gnss_MovingBaselineData_decode(transfer, &msg)) {
        return;
    }
    gps.inject_MBL_data(msg.data.data, msg.data.len);
    Debug("MovingBaselineData: len=%u\n", msg.data.len);
}
#endif // GPS_MOVING_BASELINE

/*
  convert large values to NaN for float16
 */
static void check_float16_range(float *v, uint8_t len)
{
    for (uint8_t i=0; i<len; i++) {
        const float f16max = 65519;
        if (isinf(v[i]) || v[i] <= -f16max || v[i] >= f16max) {
            v[i] = nanf("");
        }
    }
}

/*
  update CAN GPS
 */
void AP_Periph_FW::can_gps_update(void)
{
    if (gps.get_type(0) == AP_GPS::GPS_Type::GPS_TYPE_NONE) {
        return;
    }
    gps.update();
    send_moving_baseline_msg();
    send_relposheading_msg();
    if (last_gps_update_ms == gps.last_message_time_ms()) {
        return;
    }
    last_gps_update_ms = gps.last_message_time_ms();

    {
        /*
          send Fix2 packet
        */
        uavcan_equipment_gnss_Fix2 pkt {};
        const Location &loc = gps.location();
        const Vector3f &vel = gps.velocity();
        if (gps.status() < AP_GPS::GPS_OK_FIX_2D && !saw_gps_lock_once) {
            pkt.timestamp.usec = AP_HAL::micros64();
            pkt.gnss_timestamp.usec = 0;
        } else {
            saw_gps_lock_once = true;
            pkt.timestamp.usec = gps.time_epoch_usec();
            pkt.gnss_timestamp.usec = gps.last_message_epoch_usec();
        }
        if (pkt.gnss_timestamp.usec == 0) {
            pkt.gnss_time_standard = UAVCAN_EQUIPMENT_GNSS_FIX_GNSS_TIME_STANDARD_NONE;
        } else {
            pkt.gnss_time_standard = UAVCAN_EQUIPMENT_GNSS_FIX_GNSS_TIME_STANDARD_UTC;
        }
        pkt.longitude_deg_1e8 = uint64_t(loc.lng) * 10ULL;
        pkt.latitude_deg_1e8 = uint64_t(loc.lat) * 10ULL;
        pkt.height_ellipsoid_mm = loc.alt * 10;
        pkt.height_msl_mm = loc.alt * 10;
        float undulation;
        if (gps.get_undulation(undulation)) {
            pkt.height_ellipsoid_mm -= undulation*1000;
        }
        for (uint8_t i=0; i<3; i++) {
            pkt.ned_velocity[i] = vel[i];
        }
        pkt.sats_used = gps.num_sats();
        switch (gps.status()) {
        case AP_GPS::GPS_Status::NO_GPS:
        case AP_GPS::GPS_Status::NO_FIX:
            pkt.status = UAVCAN_EQUIPMENT_GNSS_FIX2_STATUS_NO_FIX;
            pkt.mode = UAVCAN_EQUIPMENT_GNSS_FIX2_MODE_SINGLE;
            pkt.sub_mode = UAVCAN_EQUIPMENT_GNSS_FIX2_SUB_MODE_DGPS_OTHER;
            break;
        case AP_GPS::GPS_Status::GPS_OK_FIX_2D:
            pkt.status = UAVCAN_EQUIPMENT_GNSS_FIX2_STATUS_2D_FIX;
            pkt.mode = UAVCAN_EQUIPMENT_GNSS_FIX2_MODE_SINGLE;
            pkt.sub_mode = UAVCAN_EQUIPMENT_GNSS_FIX2_SUB_MODE_DGPS_OTHER;
            break;
        case AP_GPS::GPS_Status::GPS_OK_FIX_3D:
            pkt.status = UAVCAN_EQUIPMENT_GNSS_FIX2_STATUS_3D_FIX;
            pkt.mode = UAVCAN_EQUIPMENT_GNSS_FIX2_MODE_SINGLE;
            pkt.sub_mode = UAVCAN_EQUIPMENT_GNSS_FIX2_SUB_MODE_DGPS_OTHER;
            break;
        case AP_GPS::GPS_Status::GPS_OK_FIX_3D_DGPS:
            pkt.status = UAVCAN_EQUIPMENT_GNSS_FIX2_STATUS_3D_FIX;
            pkt.mode = UAVCAN_EQUIPMENT_GNSS_FIX2_MODE_DGPS;
            pkt.sub_mode = UAVCAN_EQUIPMENT_GNSS_FIX2_SUB_MODE_DGPS_SBAS;
            break;
        case AP_GPS::GPS_Status::GPS_OK_FIX_3D_RTK_FLOAT:
            pkt.status = UAVCAN_EQUIPMENT_GNSS_FIX2_STATUS_3D_FIX;
            pkt.mode = UAVCAN_EQUIPMENT_GNSS_FIX2_MODE_RTK;
            pkt.sub_mode = UAVCAN_EQUIPMENT_GNSS_FIX2_SUB_MODE_RTK_FLOAT;
            break;
        case AP_GPS::GPS_Status::GPS_OK_FIX_3D_RTK_FIXED:
            pkt.status = UAVCAN_EQUIPMENT_GNSS_FIX2_STATUS_3D_FIX;
            pkt.mode = UAVCAN_EQUIPMENT_GNSS_FIX2_MODE_RTK;
            pkt.sub_mode = UAVCAN_EQUIPMENT_GNSS_FIX2_SUB_MODE_RTK_FIXED;
            break;
        }

        pkt.covariance.len = 6;

        float hacc;
        if (gps.horizontal_accuracy(hacc)) {
            pkt.covariance.data[0] = pkt.covariance.data[1] = sq(hacc);
        }
    
        float vacc;
        if (gps.vertical_accuracy(vacc)) {
            pkt.covariance.data[2] = sq(vacc);
        }

        float sacc;
        if (gps.speed_accuracy(sacc)) {
            float vc3 = sq(sacc);
            pkt.covariance.data[3] = pkt.covariance.data[4] = pkt.covariance.data[5] = vc3;
        }

        check_float16_range(pkt.covariance.data, pkt.covariance.len);

        uint8_t buffer[UAVCAN_EQUIPMENT_GNSS_FIX2_MAX_SIZE];
        uint16_t total_size = uavcan_equipment_gnss_Fix2_encode(&pkt, buffer, !canfdout());

        canard_broadcast(UAVCAN_EQUIPMENT_GNSS_FIX2_SIGNATURE,
                         UAVCAN_EQUIPMENT_GNSS_FIX2_ID,
                         CANARD_TRANSFER_PRIORITY_LOW,
                         &buffer[0],
                         total_size);
    }
    
    /*
      send aux packet
     */
    {
        uavcan_equipment_gnss_Auxiliary aux {};
        aux.hdop = gps.get_hdop() * 0.01;
        aux.vdop = gps.get_vdop() * 0.01;

        uint8_t buffer[UAVCAN_EQUIPMENT_GNSS_AUXILIARY_MAX_SIZE];
        uint16_t total_size = uavcan_equipment_gnss_Auxiliary_encode(&aux, buffer, !canfdout());
        canard_broadcast(UAVCAN_EQUIPMENT_GNSS_AUXILIARY_SIGNATURE,
                        UAVCAN_EQUIPMENT_GNSS_AUXILIARY_ID,
                        CANARD_TRANSFER_PRIORITY_LOW,
                        &buffer[0],
                        total_size);
    }

    // send the gnss status packet
    {
        ardupilot_gnss_Status status {};

        status.healthy = gps.is_healthy();
        if (gps.logging_present() && gps.logging_enabled() && !gps.logging_failed()) {
            status.status |= ARDUPILOT_GNSS_STATUS_STATUS_LOGGING;
        }
        uint8_t idx; // unused
        if (status.healthy && !gps.first_unconfigured_gps(idx)) {
            status.status |= ARDUPILOT_GNSS_STATUS_STATUS_ARMABLE;
        }

        uint32_t error_codes;
        if (gps.get_error_codes(error_codes)) {
            status.error_codes = error_codes;
        }

        uint8_t buffer[ARDUPILOT_GNSS_STATUS_MAX_SIZE];
        const uint16_t total_size = ardupilot_gnss_Status_encode(&status, buffer, !canfdout());
        canard_broadcast(ARDUPILOT_GNSS_STATUS_SIGNATURE,
                        ARDUPILOT_GNSS_STATUS_ID,
                        CANARD_TRANSFER_PRIORITY_LOW,
                        &buffer[0],
                        total_size);

    }

    // send Heading message if we are not sending RelPosHeading messages and have yaw
    if (gps.have_gps_yaw() && last_relposheading_ms == 0) {
        float yaw_deg, yaw_acc_deg;
        uint32_t yaw_time_ms;
        if (gps.gps_yaw_deg(yaw_deg, yaw_acc_deg, yaw_time_ms) && yaw_time_ms != last_gps_yaw_ms) {
            last_gps_yaw_ms = yaw_time_ms;
            
            ardupilot_gnss_Heading heading {};
            heading.heading_valid = true;
            heading.heading_accuracy_valid = is_positive(yaw_acc_deg);
            heading.heading_rad = radians(yaw_deg);
            heading.heading_accuracy_rad = radians(yaw_acc_deg);
            uint8_t buffer[ARDUPILOT_GNSS_HEADING_MAX_SIZE];
            const uint16_t total_size = ardupilot_gnss_Heading_encode(&heading, buffer, !canfdout());
            canard_broadcast(ARDUPILOT_GNSS_HEADING_SIGNATURE,
                             ARDUPILOT_GNSS_HEADING_ID,
                             CANARD_TRANSFER_PRIORITY_LOW,
                             &buffer[0],
                             total_size);
        }
    }
}


void AP_Periph_FW::send_moving_baseline_msg()
{
#if GPS_MOVING_BASELINE
    const uint8_t *data = nullptr;
    uint16_t len = 0;
    if (!gps.get_RTCMV3(data, len)) {
        return;
    }
    if (len == 0 || data == nullptr) {
        return;
    }

    /*
      send the packet from Moving Base to be used RelPosHeading calc by GPS module
      for long RTCMv3 packets we may need to split it up
    */

    uint8_t iface_mask = 0;
#if HAL_NUM_CAN_IFACES >= 2 && CANARD_MULTI_IFACE
    if (gps_mb_can_port != -1 && (gps_mb_can_port < HAL_NUM_CAN_IFACES)) {
        iface_mask = 1U<<gps_mb_can_port;
    }
#endif

    // get the data from the moving base and send as MovingBaselineData message
    while (len > 0) {
        ardupilot_gnss_MovingBaselineData mbldata {};

        const uint16_t n = MIN(len, sizeof(mbldata.data.data));

        mbldata.data.len = n;
        memcpy(mbldata.data.data, data, n);

        uint8_t buffer[ARDUPILOT_GNSS_MOVINGBASELINEDATA_MAX_SIZE];
        const uint16_t total_size = ardupilot_gnss_MovingBaselineData_encode(&mbldata, buffer, !canfdout());

        canard_broadcast(ARDUPILOT_GNSS_MOVINGBASELINEDATA_SIGNATURE,
                         ARDUPILOT_GNSS_MOVINGBASELINEDATA_ID,
                         CANARD_TRANSFER_PRIORITY_LOW,
                         &buffer[0],
                         total_size,
                         iface_mask);
        len -= n;
        data += n;
    }

    gps.clear_RTCMV3();
#endif // GPS_MOVING_BASELINE
}

void AP_Periph_FW::send_relposheading_msg() {
#if GPS_MOVING_BASELINE
    float reported_heading;
    float relative_distance;
    float relative_down_pos;
    float reported_heading_acc;
    uint32_t curr_timestamp = 0;
    if (!gps.get_RelPosHeading(curr_timestamp, reported_heading, relative_distance, relative_down_pos, reported_heading_acc) ||
        last_relposheading_ms == curr_timestamp) {
        return;
    }
    last_relposheading_ms = curr_timestamp;
    ardupilot_gnss_RelPosHeading relpos {};
    relpos.timestamp.usec = uint64_t(curr_timestamp)*1000LLU;
    relpos.reported_heading_deg = reported_heading;
    relpos.relative_distance_m = relative_distance;
    relpos.relative_down_pos_m = relative_down_pos;
    relpos.reported_heading_acc_deg = reported_heading_acc;
    relpos.reported_heading_acc_available = !is_zero(relpos.reported_heading_acc_deg);
    uint8_t buffer[ARDUPILOT_GNSS_RELPOSHEADING_MAX_SIZE];
    const uint16_t total_size = ardupilot_gnss_RelPosHeading_encode(&relpos, buffer, !canfdout());
    canard_broadcast(ARDUPILOT_GNSS_RELPOSHEADING_SIGNATURE,
                    ARDUPILOT_GNSS_RELPOSHEADING_ID,
                    CANARD_TRANSFER_PRIORITY_LOW,
                    &buffer[0],
                    total_size);
#endif // GPS_MOVING_BASELINE
}

#endif // HAL_PERIPH_ENABLE_GPS
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         #include "AP_Periph.h"

#ifdef HAL_PERIPH_ENABLE_PWM_HARDPOINT

#include <AP_HAL/AP_HAL.h>

extern const AP_HAL::HAL &hal;

/*
  hardpoint support
 */

#include <dronecan_msgs.h>

void AP_Periph_FW::pwm_hardpoint_init()
{
    hal.gpio->attach_interrupt(
        PWM_HARDPOINT_PIN,
        FUNCTOR_BIND_MEMBER(&AP_Periph_FW::pwm_irq_handler, void, uint8_t, bool, uint32_t), AP_HAL::GPIO::INTERRUPT_BOTH);
}

/*
  called on PWM pin transition
 */
void AP_Periph_FW::pwm_irq_handler(uint8_t pin, bool pin_state, uint32_t timestamp)
{
    if (pin_state == 0 && pwm_hardpoint.last_state == 1 && pwm_hardpoint.last_ts_us != 0) {
        uint32_t width = timestamp - pwm_hardpoint.last_ts_us;
        if (width > 500 && width < 2500) {
            pwm_hardpoint.pwm_value = width;
            if (width > pwm_hardpoint.highest_pwm) {
                pwm_hardpoint.highest_pwm = width;
            }
        }
    }
    pwm_hardpoint.last_state = pin_state;
    pwm_hardpoint.last_ts_us = timestamp;
}

void AP_Periph_FW::pwm_hardpoint_update()
{
    uint32_t now = AP_HAL::millis();
    // send at 10Hz
    void *save = hal.scheduler->disable_interrupts_save();
    uint16_t value = pwm_hardpoint.highest_pwm;
    pwm_hardpoint.highest_pwm = 0;
    hal.scheduler->restore_interrupts(save);
    float rate = g.hardpoint_rate;
    rate = constrain_float(rate, 10, 100);
    if (value > 0 && now - pwm_hardpoint.last_send_ms >= 1000U/rate) {
        pwm_hardpoint.last_send_ms = now;
        uavcan_equipment_hardpoint_Command cmd {};
        cmd.hardpoint_id = g.hardpoint_id;
        cmd.command = value;

        uint8_t buffer[UAVCAN_EQUIPMENT_HARDPOINT_COMMAND_MAX_SIZE];
        uint16_t total_size = uavcan_equipment_hardpoint_Command_encode(&cmd, buffer, !canfdout());
        canard_broadcast(UAVCAN_EQUIPMENT_HARDPOINT_COMMAND_SIGNATURE,
                        UAVCAN_EQUIPMENT_HARDPOINT_COMMAND_ID,
                        CANARD_TRANSFER_PRIORITY_LOW,
                        &buffer[0],
                        total_size);
    }
}

#endif // HAL_PERIPH_ENABLE_PWM_HARDPOINT
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 