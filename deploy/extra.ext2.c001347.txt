    return send_fixedlen_packet(AddressByte::LENS, AP_MOUNT_TOPOTEK_ID3CHAR_CONTROL_ZOOM, true, zoom_cmd);
    }

    // unsupported zoom type
    return false;
}

// set focus specified as rate, percentage or auto
// focus in = -1, focus hold = 0, focus out = 1
SetFocusResult AP_Mount_Topotek::set_focus(FocusType focus_type, float focus_value)
{
    // exit immediately if not initialised
    if (!_initialised) {
        return SetFocusResult::FAILED;
    }

    switch (focus_type) {
    case FocusType::RATE: {
        // focus stop
        uint8_t focus_cmd;
        if (is_zero(focus_value)) {
            focus_cmd = 0;
            _last_focus_stop = true;
        } else if (focus_value < 0) {
            // focus-
            focus_cmd = 2;
        } else {
            // focus+
            focus_cmd = 1;
        }
        // send focus command and switch to manual focus
        // sample command: #TPUM2wFCC00
        if (send_fixedlen_packet(AddressByte::LENS, AP_MOUNT_TOPOTEK_ID3CHAR_CONTROL_FOCUS, true, focus_cmd) &&
            send_fixedlen_packet(AddressByte::LENS, AP_MOUNT_TOPOTEK_ID3CHAR_CONTROL_FOCUS, true, 0x11)) {
                return SetFocusResult::ACCEPTED;
        }
        return SetFocusResult::FAILED;
    }
    case FocusType::PCT:
        // not supported
        return SetFocusResult::INVALID_PARAMETERS;
    case FocusType::AUTO:
        // auto focus
        if (send_fixedlen_packet(AddressByte::LENS, AP_MOUNT_TOPOTEK_ID3CHAR_CONTROL_FOCUS, true, 0x10)) {
            return SetFocusResult::ACCEPTED;
        }
        return SetFocusResult::FAILED;
    }

    // unsupported focus type
    return SetFocusResult::INVALID_PARAMETERS;
}

// set tracking to none, point or rectangle (see TrackingType enum)
// if POINT only p1 is used, if RECTANGLE then p1 is top-left, p2 is bottom-right
// p1,p2 are in range 0 to 1.  0 is left or top, 1 is right or bottom
bool AP_Mount_Topotek::set_tracking(TrackingType tracking_type, const Vector2f& p1, const Vector2f& p2)
{
    // exit immediately if not initialised
    if (!_initialised) {
        return false;
    }

    // local variables holding tracker center and width
    int16_t track_center_x, track_center_y, track_width, track_height;
    bool send_tracking_cmd = false;

    switch (tracking_type) {

    case TrackingType::TRK_NONE:
        return cancel_tracking();

    case TrackingType::TRK_POINT: {
        // calculate tracking center, width and height
        track_center_x = (int16_t)((p1.x*TRACK_TOTAL_WIDTH - 960) /  0.96);
        track_center_y = (int16_t)((p1.y*TRACK_TOTAL_HEIGHT - 540) /  0.54);
        track_width = (int16_t)(TRACK_RANGE / 0.96);
        track_height = (int16_t)(TRACK_RANGE / 0.54);
        send_tracking_cmd = true;
        break;
    }

    case TrackingType::TRK_RECTANGLE:
        // calculate upper left and bottom right points
        // handle case where p1 and p2 are in an unexpected order
        int16_t upper_leftx = (int16_t)(MIN(p1.x, p2.x)*TRACK_TOTAL_WIDTH);
        int16_t upper_lefty = (int16_t)(MIN(p1.y, p2.y)*TRACK_TOTAL_HEIGHT);
        int16_t bottom_rightx = (int16_t)(MAX(p1.x, p2.x)*TRACK_TOTAL_WIDTH);
        int16_t bottom_righty = (int16_t)(MAX(p1.y, p2.y)*TRACK_TOTAL_HEIGHT);

        // calculated width and height and sanity check 
        const int16_t frame_selection_width = bottom_rightx - upper_leftx;
        const int16_t frame_selection_height = bottom_righty - upper_lefty;
        if (frame_selection_width <= 0 || frame_selection_height <= 0) {
            return false;
        }

        // calculate tracking center
        track_center_x = (int16_t)((((upper_leftx + bottom_rightx) * 0.5) - 960) / 0.96);
        track_center_y = (int16_t)((((upper_lefty + bottom_righty) * 0.5) - 540) / 0.54);

        // tracking range after conversion
        track_width = (int16_t)(frame_selection_width / 0.96);
        track_height = (int16_t)(frame_selection_height / 0.54);

        send_tracking_cmd = true;
        break;
    }

    if (send_tracking_cmd) {
        // set the gimbal to the ready-to-track state when the gimbal tracking status is stopped
        if (_last_tracking_state == TrackingStatus::STOPPED_TRACKING) {
            send_fixedlen_packet(AddressByte::SYSTEM_AND_IMAGE, AP_MOUNT_TOPOTEK_ID3CHAR_TRACKING, true, 2);
        }

        // prepare data bytes
        uint8_t databuff[10];
        databuff[0] = HIGHBYTE(track_center_x);
        databuff[1] = LOWBYTE(track_center_x);
        databuff[2] = HIGHBYTE(track_center_y);
        databuff[3] = LOWBYTE(track_center_y);
        databuff[4] = HIGHBYTE(track_width);
        databuff[5] = LOWBYTE(track_width);
        databuff[6] = HIGHBYTE(track_height);
        databuff[7] = LOWBYTE(track_height);
        databuff[8] = 0;
        databuff[9] = (tracking_type == TrackingType::TRK_POINT) ? 9 : 1;   // when tracking point, enable fuzzy click function

        // send tracking command
        bool res = send_variablelen_packet(HeaderType::VARIABLE_LEN,
                                           AddressByte::SYSTEM_AND_IMAGE,
                                           AP_MOUNT_TOPOTEK_ID3CHAR_START_TRACKING,
                                           true,
                                           (uint8_t*)databuff, ARRAY_SIZE(databuff));

        // display error message on failure
        if (!res) {
            GCS_SEND_TEXT(MAV_SEVERITY_ERROR, "%s tracking failed", send_message_prefix);
        }

        return res;
    }

    // should never reach here
    return false;
}

// send command to gimbal to cancel tracking (if necessary)
// returns true on success, false on failure to send message
bool AP_Mount_Topotek::cancel_tracking()
{
    // exit immediately if not initialised
    if (!_initialised) {
        return false;
    }

    // if gimbal is tracking-in-progress change to waiting state, otherwise stop
    const uint8_t track_set = _last_tracking_state == TrackingStatus::TRACKING_IN_PROGRESS ? 1 : 0;

    // send tracking command
    return send_fixedlen_packet(AddressByte::SYSTEM_AND_IMAGE, AP_MOUNT_TOPOTEK_ID3CHAR_TRACKING, true, track_set);
}

// set camera picture-in-picture mode
bool AP_Mount_Topotek::set_lens(uint8_t lens)
{
    // exit immediately if not initialised
    if (!_initialised) {
        return false;
    }

    // sanity check lens number
    // 00:main only, 01:main+sub, 02:sub+main, 03:sub only, 0A:next
    // sample command: #TPUD2wPIP0A
    if (lens > 3) {
        return false;
    }

    // send pip command
    return send_fixedlen_packet(AddressByte::SYSTEM_AND_IMAGE, AP_MOUNT_TOPOTEK_ID3CHAR_PIP, true, lens);
}

#if HAL_MOUNT_SET_CAMERA_SOURCE_ENABLED
// set_camera_source is functionally the same as set_lens except primary and secondary lenses are specified by type
// primary and secondary sources use the AP_Camera::CameraSource enum cast to uint8_t
bool AP_Mount_Topotek::set_camera_source(uint8_t primary_source, uint8_t secondary_source)
{
    // exit immediately if not initialised
    if (!_initialised) {
        return false;
    }

    // maps primary and secondary source to pip setting
    // pip settings 00:main only, 01:main+sub, 02:sub+main, 03:sub only, 0A:next
    // sample command: #TPUD2wPIP0A
    uint8_t pip_setting = 0;
    switch (primary_source) {
    case 0: // Default (RGB)
        FALLTHROUGH;
    case 1: // RGB
        switch (secondary_source) {
        case 0: // RGB + Default (None)
            pip_setting = 0;    // main only
            break;
        case 2: // PIP RGB+IR
            pip_setting = 1;    // main+sub
            break;
        default:
            return false;
        }
        break;
    case 2: // IR
        switch (secondary_source) {
        case 0: // IR + Default (None)
            pip_setting = 3;    // sub only
            break;
        case 1: // IR+RGB
            pip_setting = 2;    // sub+main
            break;
        default:
            return false;
        }
        break;
    default:
        return false;
    }

    // send pip command
    return send_fixedlen_packet(AddressByte::SYSTEM_AND_IMAGE, AP_MOUNT_TOPOTEK_ID3CHAR_PIP, true, pip_setting);
}
#endif  // HAL_MOUNT_SET_CAMERA_SOURCE_ENABLED

// send camera information message to GCS
void AP_Mount_Topotek::send_camera_information(mavlink_channel_t chan) const
{
    // exit immediately if not initialised
    if (!_initialised) {
        return;
    }

    static const uint8_t vendor_name[32] = "Topotek";
    static uint8_t model_name[32] {};
    const char cam_definition_uri[140] {};

    // copy model name if available
    if (_got_gimbal_model_name) {
        strncpy((char*)model_name, (const char*)_model_name, ARRAY_SIZE(model_name));
    }

    // capability flags
    const uint32_t flags = CAMERA_CAP_FLAGS_CAPTURE_VIDEO |
                           CAMERA_CAP_FLAGS_CAPTURE_IMAGE |
                           CAMERA_CAP_FLAGS_HAS_BASIC_ZOOM |
                           CAMERA_CAP_FLAGS_HAS_BASIC_FOCUS |
                           CAMERA_CAP_FLAGS_HAS_TRACKING_POINT |
                           CAMERA_CAP_FLAGS_HAS_TRACKING_RECTANGLE;

    // send CAMERA_INFORMATION message
    mavlink_msg_camera_information_send(
        chan,
        AP_HAL::millis(),       // time_boot_ms
        vendor_name,            // vendor_name uint8_t[32]
        model_name,             // model_name uint8_t[32]
        _firmware_ver,          // firmware version uint32_t
        0,                      // focal_length float (mm)
        0,                      // sensor_size_h float (mm)
        0,                      // sensor_size_v float (mm)
        0,                      // resolution_h uint16_t (pix)
        0,                      // resolution_v uint16_t (pix)
        0,                      // lens_id uint8_t
        flags,                  // flags uint32_t (CAMERA_CAP_FLAGS)
        0,                      // cam_definition_version uint16_t
        cam_definition_uri,     // cam_definition_uri char[140]
        _instance + 1);         // gimbal_device_id uint8_t
}

// send camera settings message to GCS
void AP_Mount_Topotek::send_camera_settings(mavlink_channel_t chan) const
{
    // exit immediately if not initialised
    if (!_initialised) {
        return;
    }

    const float NaN = nanf("0x4152");

    // send CAMERA_SETTINGS message
    mavlink_msg_camera_settings_send(
        chan,
        AP_HAL::millis(),   // time_boot_ms
        _recording ? CAMERA_MODE_VIDEO : CAMERA_MODE_IMAGE, // camera mode (0:image, 1:video, 2:image survey)
        NaN,                // zoomLevel float, percentage from 0 to 100, NaN if unknown
        NaN);               // focusLevel float, percentage from 0 to 100, NaN if unknown
}

// get rangefinder distance.  Returns true on success
bool AP_Mount_Topotek::get_rangefinder_distance(float& distance_m) const
{
    // if not healthy or negative distance return false
    // healthy() checks attitude timeout which is in same message as rangefinder distance
    if (!healthy() || (_measure_dist_m < 0)) {
        return false;
    }

    distance_m = _measure_dist_m;
    return true;
}

// enable/disable rangefinder.  Returns true on success
bool AP_Mount_Topotek::set_rangefinder_enable(bool enable)
{
    // exit immediately if not initialised
    if (!_initialised) {
        return false;
    }

    // 00:ranging stop, 01:ranging start, 02:single measurement, 03:continuous measurement
    // sample command: #TPUM2wLRF00
    return send_fixedlen_packet(AddressByte::LENS, AP_MOUNT_TOPOTEK_ID3CHAR_LRF, true, enable ? 3 : 0);
}

// get attitude as a quaternion.  returns true on success
bool AP_Mount_Topotek::get_attitude_quaternion(Quaternion& att_quat)
{
    att_quat.from_euler(_current_angle_rad.x, _current_angle_rad.y, _current_angle_rad.z);
    return true;
}

// reading incoming packets from gimbal and confirm they are of the correct format
void AP_Mount_Topotek::read_incoming_packets()
{
    // check for bytes on the serial port
    int16_t nbytes = MIN(_uart->available(), 1024U);
    if (nbytes <= 0 ) {
        return;
    }

    // flag to allow cases below to reset parser state
    bool reset_parser = false;

    // process bytes received
    for (int16_t i = 0; i < nbytes; i++) {
        uint8_t b;
        if (!_uart->read(b)) {
            continue;
        }

        // add latest byte to buffer
        _msg_buff[_msg_buff_len++] = b;

        // protect against overly long messages
        if (_msg_buff_len >= AP_MOUNT_TOPOTEK_PACKETLEN_MAX) {
            reset_parser = true;
        }

        // process byte depending upon current state
        switch (_parser.state) {

        case ParseState::WAITING_FOR_HEADER1:
            if (b == '#') {
                _parser.state = ParseState::WAITING_FOR_HEADER2;
                break;
            }
            reset_parser = true;
            break;

        case ParseState::WAITING_FOR_HEADER2:
            if (b == 't' || b == 'T') {
                _parser.state = ParseState::WAITING_FOR_HEADER3;
                break;
            }
            reset_parser = true;
            break;

        case ParseState::WAITING_FOR_HEADER3:
            if (b == 'p' || b == 'P') {
                _parser.state = ParseState::WAITING_FOR_ADDR1;
                break;
            }
            reset_parser = true;
            break;

        case ParseState::WAITING_FOR_ADDR1:
        case ParseState::WAITING_FOR_ADDR2:
            if (b == 'U' || b =='M' || b == 'D' || b =='E' || b =='P' || b =='G') {
                // advance to next state
                _parser.state = (ParseState)((uint8_t)_parser.state+1);
                break;
            }
            reset_parser = true;
            break;

        case ParseState::WAITING_FOR_DATALEN:
            // sanity check data length
            _parser.data_len = (uint8_t)char_to_hex(b);
            if (_parser.data_len <= AP_MOUNT_TOPOTEK_DATALEN_MAX) {
                _parser.state = ParseState::WAITING_FOR_CONTROL;
                break;
            }
            reset_parser = true;
            break;

        case ParseState::WAITING_FOR_CONTROL:
            // r or w
            if (b == 'r' || b == 'w') {
                _parser.state = ParseState::WAITING_FOR_ID1;
                break;
            }
            reset_parser = true;
            break;

        case ParseState::WAITING_FOR_ID1:
        case ParseState::WAITING_FOR_ID2:
        case ParseState::WAITING_FOR_ID3:
            // check all uppercase letters and numbers.  eg 'GAC'
            if ((b >= 'A' && b <= 'Z') || (b >= '0' && b <= '9')) {
                // advance to next state
                _parser.state = (ParseState)((uint8_t)_parser.state+1);
                break;
            }
            reset_parser = true;
            break;

        case ParseState::WAITING_FOR_DATA: {
            // normally hex numbers in char form (e.g. '0A')
            const uint8_t data_bytes_received = _msg_buff_len - (AP_MOUNT_TOPOTEK_PACKETLEN_MIN - 2);

            // sanity check to protect against programming errors
            if (data_bytes_received > AP_MOUNT_TOPOTEK_DATALEN_MAX) {
                INTERNAL_ERROR(AP_InternalError::error_t::flow_of_control);
                reset_parser = true;
                break;
            }
            
            // advance parser state once expected number of bytes have been received
            if (data_bytes_received == _parser.data_len) {
                _parser.state = ParseState::WAITING_FOR_CRC_LOW;
            }
            break;
        }

        case ParseState::WAITING_FOR_CRC_LOW:
            _parser.state = ParseState::WAITING_FOR_CRC_HIGH;
            break;

        case ParseState::WAITING_FOR_CRC_HIGH:
            // this is the last byte in the message so reset the parser
            reset_parser = true;

            // sanity check to protect against programming errors
            if (_msg_buff_len < AP_MOUNT_TOPOTEK_PACKETLEN_MIN) {
                INTERNAL_ERROR(AP_InternalError::error_t::flow_of_control);
                break;
            }

            // calculate and check CRC
            const uint8_t crc_value = calculate_crc(_msg_buff, _msg_buff_len - 2);
            const char crc_char1 = hex2char((crc_value >> 4) & 0x0f);
            const char crc_char2 = hex2char((crc_value) & 0x0f);
            if (crc_char1 != _msg_buff[_msg_buff_len - 2] || crc_char2 != _msg_buff[_msg_buff_len-1]) {
                debug("CRC expected:%x got:%c%c", (int)crc_value, crc_char1, crc_char2);
                break;
            }

            // CRC is OK, call function to process the message
            for (uint8_t count = 0; count < AP_MOUNT_RECV_GIMBAL_CMD_CATEGORIES_NUM; count++) {
                if (strncmp((const char*)_msg_buff + 7, (const char*)(uart_recv_cmd_compare_list[count].uart_cmd_key), 3) == 0) {
                    (this->*(uart_recv_cmd_compare_list[count].func))();
                    break;
                }
            }
        }

        // handle reset of parser
        if (reset_parser) {
            _parser.state = ParseState::WAITING_FOR_HEADER1;
            _msg_buff_len = 0;
            reset_parser = false;
        }
    }
}

// request gimbal attitude
void AP_Mount_Topotek::request_gimbal_attitude()
{
    // sample command: #TPUG2wGAA01
    send_fixedlen_packet(AddressByte::GIMBAL, AP_MOUNT_TOPOTEK_ID3CHAR_GIMBAL_ATT, true, 1);
}

// request gimbal memory card information
void AP_Mount_Topotek::request_gimbal_sdcard_info()
{
    // request remaining capacity
    // sample command including CRC: #TPUD2rSDC003E
    // 00:get remaining capacity, 01:get total capacity
    send_fixedlen_packet(AddressByte::SYSTEM_AND_IMAGE, AP_MOUNT_TOPOTEK_ID3CHAR_SD_CARD, false, 0);
}

// request gimbal tracking status
void AP_Mount_Topotek::request_track_status()
{
    // 00:get status (use with "r"), 01:stop (use with "w")
    // sample command: #TPUD2rTRC00
    send_fixedlen_packet(AddressByte::SYSTEM_AND_IMAGE, AP_MOUNT_TOPOTEK_ID3CHAR_TRACKING, false, 0);
}

// request gimbal version
void AP_Mount_Topotek::request_gimbal_version()
{
    // sample command: #TPUD2rVSN00
    send_fixedlen_packet(AddressByte::SYSTEM_AND_IMAGE, AP_MOUNT_TOPOTEK_ID3CHAR_GET_VERSION, false, 0);
}

// request gimbal model name
void AP_Mount_Topotek::request_gimbal_model_name()
{
    // sample command: #TPUG2rPA200
    send_fixedlen_packet(AddressByte::GIMBAL, AP_MOUNT_TOPOTEK_ID3CHAR_GET_MODEL_NAME, false, 0);
}

// send angle target in radians to gimbal
void AP_Mount_Topotek::send_angle_target(const MountTarget& angle_rad)
{
    // gimbal's earth-frame angle control drifts so always use body frame
    // set gimbal's lock state if it has changed
    if (!set_gimbal_lock(false)) {
        return;
    }

    // calculate and send yaw target
    // sample command #tpUG6wGIY
    const char* format_str = "%04x%02x";
    const uint8_t speed = 99;
    const uint16_t yaw_angle_cd = (uint16_t)constrain_int16(degrees(angle_rad.get_bf_yaw()) * 100, MAX(-18000, _params.yaw_angle_min * 100), MIN(18000, _params.yaw_angle_max * 100));

    uint8_t databuff[7];
    hal.util->snprintf((char *)databuff, ARRAY_SIZE(databuff), format_str, yaw_angle_cd, speed);
    send_variablelen_packet(HeaderType::VARIABLE_LEN,
                            AddressByte::GIMBAL,
                            AP_MOUNT_TOPOTEK_ID3CHAR_YAW_ANGLE_BF,
                            true,
                            (uint8_t*)databuff, ARRAY_SIZE(databuff)-1);

    // send pitch target
    // sample command: #tpUG6wGIP
    const uint16_t pitch_angle_cd = (uint16_t)constrain_int16(-degrees(angle_rad.pitch) * 100, -9000, 9000);
    hal.util->snprintf((char *)databuff, ARRAY_SIZE(databuff), format_str, pitch_angle_cd, speed);
    send_variablelen_packet(HeaderType::VARIABLE_LEN,
                            AddressByte::GIMBAL,
                            AP_MOUNT_TOPOTEK_ID3CHAR_PITCH_ANGLE,
                            true,
                            (uint8_t*)databuff, ARRAY_SIZE(databuff)-1);

    // send roll target
    // sample command: #tpUG6wGIR
    const uint16_t roll_angle_cd = (uint16_t)constrain_int16(degrees(angle_rad.roll) * 100, -18000, 18000);
    hal.util->snprintf((char *)databuff, ARRAY_SIZE(databuff), format_str, roll_angle_cd, speed);
    send_variablelen_packet(HeaderType::VARIABLE_LEN,
                            AddressByte::GIMBAL,
                            AP_MOUNT_TOPOTEK_ID3CHAR_ROLL_ANGLE,
                            true,
                            (uint8_t*)databuff, ARRAY_SIZE(databuff)-1);
}

// send rate target in rad/s to gimbal
void AP_Mount_Topotek::send_rate_target(const MountTarget& rate_rads)
{
    // set gimbal's lock state if it has changed
    if (!set_gimbal_lock(rate_rads.yaw_is_ef)) {
        return;
    }

    // convert and constrain rates
    const uint8_t roll_angle_speed = constrain_int16(degrees(rate_rads.roll) * ANGULAR_VELOCITY_CONVERSION, -99, 99);
    const uint8_t pitch_angle_speed = constrain_int16(degrees(rate_rads.pitch) * ANGULAR_VELOCITY_CONVERSION, -99, 99);
    const uint8_t yaw_angle_speed = constrain_int16(degrees(rate_rads.yaw) * ANGULAR_VELOCITY_CONVERSION, -99, 99);

    // send stop rotation command three times if target roll, pitch and yaw are zero
    if (roll_angle_speed == 0 && pitch_angle_speed == 0 && yaw_angle_speed == 0) {
        if (_stop_order_count < 3) {
            // sample command: #TPUG2wPTZ00
            if (send_fixedlen_packet(AddressByte::GIMBAL, AP_MOUNT_TOPOTEK_ID3CHAR_GIMBAL_MODE, true, 0)) {
                _stop_order_count++;
            }
        }
        return;
    }
    _stop_order_count = 0;

    // prepare and send command
    // sample command: #tpUG6wYPR
    uint8_t databuff[7];
    hal.util->snprintf((char *)databuff, ARRAY_SIZE(databuff), "%02x%02x%02x", yaw_angle_speed, pitch_angle_speed, roll_angle_speed);
    send_variablelen_packet(HeaderType::VARIABLE_LEN, AddressByte::GIMBAL, AP_MOUNT_TOPOTEK_ID3CHAR_YPR_RATE, true, databuff, ARRAY_SIZE(databuff)-1);
}

// send time and date to gimbal
bool AP_Mount_Topotek::send_time_to_gimbal()
{
#if AP_RTC_ENABLED
    // get date and time
    // year is the regular Gregorian year, month is 0~11, day is 1~31, hour is 0~23, minute is 0~59, second is 0~60 (1 leap second), ms is 0~999
    uint16_t year, ms;
    uint8_t month, day, hour, min, sec;
    if (!AP::rtc().get_date_and_time_utc(year, month, day, hour, min, sec, ms)) {
        return false;
    }

    // sample command: #tpUDCwUTCHHMMSSDDMMYY
    uint8_t databuff[13];
    hal.util->snprintf((char*)databuff, ARRAY_SIZE(databuff), "%02d%02d%02d%02d%02d%02d", hour, min, sec, day, month + 1, year - 2000);
    return send_variablelen_packet(HeaderType::VARIABLE_LEN, AddressByte::SYSTEM_AND_IMAGE, AP_MOUNT_TOPOTEK_ID3CHAR_TIME, true, (uint8_t*)databuff, ARRAY_SIZE(databuff)-1);
#else
    return false;
#endif
}

// send GPS-related information to the gimbal
bool AP_Mount_Topotek::send_location_info()
{
    // get current location
    Location loc;
    int32_t alt_amsl_cm = 0;
    if (!AP::ahrs().get_location(loc) || !loc.get_alt_cm(Location::AltFrame::ABSOLUTE, alt_amsl_cm)) {
        return false;
    }

    // convert latitude and longitude to positive angles in degrees
    const double latitude = labs(loc.lat) * 1e-7;
    const double longitude = labs(loc.lng) * 1e-7;

    // get the degree part
    const int16_t lat_deg = (int16_t)latitude;
    const int16_t lng_deg = (int16_t)longitude;

    // get the minute part
    const double lat_min = (latitude - lat_deg) * 60.0;
    const double lng_min = (longitude - lng_deg) * 60.0;

    // prepare and send latitude
    // first byte is N or S, followed by GPS coordinates in degree division format, in the format of ddmm.mmmm
    // first byte is zero and will also be transmitted.  same as the data format in $GPGGA
    // sample command: #tpUDAwLATNddmm.mmmm
    uint8_t databuff_lat[11];
    hal.util->snprintf((char*)databuff_lat, ARRAY_SIZE(databuff_lat), "%c%02d%07.4f", loc.lat > 0 ? 'N':'S', lat_deg, lat_min);
    if (!send_variablelen_packet(HeaderType::VARIABLE_LEN, AddressByte::SYSTEM_AND_IMAGE, AP_MOUNT_TOPOTEK_ID3CHAR_SET_LAT, true, (uint8_t*)databuff_lat, ARRAY_SIZE(databuff_lat)-1)) {
        return false;
    }

    // prepare and send longitude
    // sample command: #tpUDBwLONEdddmm.mmmm
    uint8_t databuff_lon[12];
    hal.util->snprintf((char*)databuff_lon, ARRAY_SIZE(databuff_lon), "%c%03d%07.4f", loc.lng > 0 ? 'E':'W', lng_deg, lng_min);
    if (!send_variablelen_packet(HeaderType::VARIABLE_LEN, AddressByte::SYSTEM_AND_IMAGE, AP_MOUNT_TOPOTEK_ID3CHAR_SET_LON, true, (uint8_t*)databuff_lon, ARRAY_SIZE(databuff_lon)-1)) {
        return false;
    }

    // get the height in meters
    float alt_amsl_m = alt_amsl_cm * 0.01;

    // prepare and send vehicle altitude
    // sample command: #tpUD8wALT000000.0, similar format to $GPGGA
    uint8_t databuff_alt[9];
    hal.util->snprintf((char*)databuff_alt, ARRAY_SIZE(databuff_alt), "%08.1f", alt_amsl_m);
    if (!send_variablelen_packet(HeaderType::VARIABLE_LEN, AddressByte::SYSTEM_AND_IMAGE, AP_MOUNT_TOPOTEK_ID3CHAR_SET_ALT, true, (uint8_t*)databuff_alt, ARRAY_SIZE(databuff_alt)-1)) {
        return false;
    }

    // prepare and send vehicle yaw
    // sample command: #tpUD5wAZI359.9, similar format to $GPRMC
    const float veh_yaw_deg = wrap_360(degrees(AP::ahrs().get_yaw()));
    uint8_t databuff_azimuth[6];
    hal.util->snprintf((char*)databuff_azimuth, ARRAY_SIZE(databuff_azimuth), "%05.1f", veh_yaw_deg);
    if (!send_variablelen_packet(HeaderType::VARIABLE_LEN, AddressByte::SYSTEM_AND_IMAGE, AP_MOUNT_TOPOTEK_ID3CHAR_SET_AZIMUTH, true, (uint8_t*)databuff_azimuth, ARRAY_SIZE(databuff_azimuth)-1)) {
        return false;
    }

    return true;
}

// attitude information analysis of gimbal
void AP_Mount_Topotek::gimbal_angle_analyse()
{
    // consume current angles
    int16_t yaw_angle_cd = wrap_180_cd(hexchar4_to_int16(_msg_buff[10], _msg_buff[11], _msg_buff[12], _msg_buff[13]));
    int16_t pitch_angle_cd = -hexchar4_to_int16(_msg_buff[14], _msg_buff[15], _msg_buff[16], _msg_buff[17]);
    int16_t roll_angle_cd = hexchar4_to_int16(_msg_buff[18], _msg_buff[19], _msg_buff[20], _msg_buff[21]);

    // convert cd to radians
    _current_angle_rad.x = radians(roll_angle_cd * 0.01);
    _current_angle_rad.y = radians(pitch_angle_cd * 0.01);
    _current_angle_rad.z = radians(yaw_angle_cd * 0.01);
    _last_current_angle_ms = AP_HAL::millis();

    return;
}

// gimbal video information analysis
void AP_Mount_Topotek::gimbal_record_analyse()
{
    _recording = (_msg_buff[10] == '1' || _msg_buff[11] == '1');
    GCS_SEND_TEXT(MAV_SEVERITY_INFO, "%s recording %s", send_message_prefix, _recording ? "ON" : "OFF");
}

// information analysis of gimbal storage card
void AP_Mount_Topotek::gimbal_sdcard_analyse()
{
    if (('N' == _msg_buff[10]) && ('N' == _msg_buff[11]) && ('N' == _msg_buff[12]) && ('N' == _msg_buff[13])) {
        // memory card exception
        _sdcard_status = false;
        return;
    }
    _sdcard_status = true;

    // send UTC time to the camera
    if (_sent_time_count < 7) {
        if (send_time_to_gimbal()) {
            _sent_time_count++;
        }
    }

    return;
}

// gimbal tracking information analysis
void AP_Mount_Topotek::gimbal_track_analyse()
{
    // ignore tracking state if unchanged
    TrackingStatus tracking_state = (TrackingStatus)_msg_buff[11];
    if (tracking_state == _last_tracking_state) {
        return;
    }
    _last_tracking_state = tracking_state;

    // inform user
    const char* tracking_str = "tracking";
    switch (tracking_state) {
    case TrackingStatus::STOPPED_TRACKING:
        GCS_SEND_TEXT(MAV_SEVERITY_INFO, "%s %s stopped", send_message_prefix, tracking_str);
        _is_tracking = false;
        break;
    case TrackingStatus::WAITING_FOR_TRACKING:
        GCS_SEND_TEXT(MAV_SEVERITY_INFO, "%s %s waiting", send_message_prefix, tracking_str);
        _is_tracking = false;
        break;
    case TrackingStatus::TRACKING_IN_PROGRESS:
        GCS_SEND_TEXT(MAV_SEVERITY_INFO, "%s %s started", send_message_prefix, tracking_str);
        _is_tracking = true;
        break;
    }
}

// gimbal distance information analysis
void AP_Mount_Topotek::gimbal_dist_info_analyse()
{
    if ('E' == _msg_buff[10] && 'R' == _msg_buff[11] && 'R' ==_msg_buff[12]) {
        _measure_dist_m = -1.0f;
        return;
    }

    // distance is in meters in the format, "12345.6" where each digit is in decimal
    _measure_dist_m = char_to_hex(_msg_buff[10]) * 10000.0 +
                      char_to_hex(_msg_buff[11]) * 1000.0 +
                      char_to_hex(_msg_buff[12]) * 100.0 +
                      char_to_hex(_msg_buff[13]) * 10.0 +
                      char_to_hex(_msg_buff[14]) +
                      char_to_hex(_msg_buff[16]) * 0.1;
}

// gimbal basic information analysis
void AP_Mount_Topotek::gimbal_version_analyse()
{
    // version array with index 0=major, 1=minor, 2=patch
    uint8_t version[3] {};

    // extract firmware version
    // the version can be in the format "1.2.3" or "123"
    const uint8_t data_buf_len = char_to_hex(_msg_buff[5]);

    // check for "."
    bool contains_period = false;
    for (uint8_t i = 0; i < data_buf_len; i++) {
        contains_period |= _msg_buff[10 + i] == '.';
    }

    // if contains period, extract version number
    uint32_t ver_num = 0;
    uint8_t ver_count = 0;
    if (contains_period) {
        for (uint8_t i = 0; i < data_buf_len; i++) {
            if (_msg_buff[10 + i] != '.') {
                ver_num = ver_num * 10 + char_to_hex(_msg_buff[10 + i]);
            } else {
                version[ver_count++] = ver_num;
                ver_num = 0;
            }
            if (ver_count >= ARRAY_SIZE(version)) {
                break;
            }
        }
    } else {
        if (data_buf_len >= 1) {
            version[0] = char_to_hex(_msg_buff[10]);
        }
        if (data_buf_len >= 2) {
            version[1] = char_to_hex(_msg_buff[11]);
        }
        if (data_buf_len >= 3) {
            version[2] = char_to_hex(_msg_buff[12]);
        }
    }
    _firmware_ver = (version[2] << 16) | (version[1] << 8) | (version[0]);

    // display gimbal model and firmware version to user
    GCS_SEND_TEXT(MAV_SEVERITY_INFO, "%s v%u.%u.%u",
        send_message_prefix,
        version[0],     // major version
        version[1],     // minor version
        version[2]);    // patch version

    _got_gimbal_version = true;
}

// gimbal model name message analysis
void AP_Mount_Topotek::gimbal_model_name_analyse()
{
    strncpy((char *)_model_name, (const char *)_msg_buff + 10, char_to_hex(_msg_buff[5]));

    // display gimbal model name to user
    GCS_SEND_TEXT(MAV_SEVERITY_INFO, "%s %s", send_message_prefix, _model_name);

    _got_gimbal_model_name = true;
}

// calculate checksum
uint8_t AP_Mount_Topotek::calculate_crc(const uint8_t *cmd, uint8_t len) const
{
    uint8_t crc = 0;
    for (uint16_t i = 0; i<len; i++) {
        crc += cmd[i];
    }
    return(crc);
}

// hexadecimal to character conversion
uint8_t AP_Mount_Topotek::hex2char(uint8_t data) const
{
    if ((9 >= data)) {
        return (data + '0');
    } else {
        return (data - 10 + 'A');
    }
}

// convert a 4 character hex number to an integer
// the characters are in the format "1234" where the most significant digit is first
int16_t AP_Mount_Topotek::hexchar4_to_int16(char high, char mid_high, char mid_low, char low) const
{
    const int16_t value = (char_to_hex(high) << 12) |
                          (char_to_hex(mid_high) << 8) |
                          (char_to_hex(mid_low) << 4) |
                          (char_to_hex(low));

    return value;
}

// send a fixed length packet
bool AP_Mount_Topotek::send_fixedlen_packet(AddressByte address, const Identifier id, bool write, uint8_t value)
{
    uint8_t databuff[3];
    hal.util->snprintf((char *)databuff, ARRAY_SIZE(databuff), "%02x", value);
    return send_variablelen_packet(HeaderType::FIXED_LEN, address, id, write, databuff, ARRAY_SIZE(databuff)-1);
}

// send variable length packet
bool AP_Mount_Topotek::send_variablelen_packet(HeaderType header, AddressByte address, const Identifier id, bool write, const uint8_t* databuff, uint8_t databuff_len)
{
    // exit immediately if not initialised
    if (!_initialised) {
        return false;
    }

    // calculate and sanity check packet size
    const uint16_t packet_size = AP_MOUNT_TOPOTEK_PACKETLEN_MIN + databuff_len;
    if (packet_size > AP_MOUNT_TOPOTEK_PACKETLEN_MAX) {
        debug("send_packet data buff too large");
        return false;
    }

    // check for sufficient space in outgoing buffer
    if (_uart->txspace() < packet_size) {
        debug("tx buffer full");
        return false;
    }

    // create buffer for holding outgoing packet
    uint8_t send_buff[packet_size];
    uint8_t send_buff_ofs = 0;

    // packet header (bytes 0 ~ 2)
    send_buff[send_buff_ofs++] = '#';
    send_buff[send_buff_ofs++] = (header == HeaderType::FIXED_LEN) ? 'T' : 't';
    send_buff[send_buff_ofs++] = (header == HeaderType::FIXED_LEN) ? 'P' : 'p';

    // address (bytes 3, 4)
    send_buff[send_buff_ofs++] = (uint8_t)AddressByte::UART;
    send_buff[send_buff_ofs++] = (uint8_t)address;

    // data length (byte 5)
    send_buff[send_buff_ofs++] = hex2char(databuff_len);

    // control byte (byte 6)
    send_buff[send_buff_ofs++] = write ? (uint8_t)ControlByte::WRITE : (uint8_t)ControlByte::READ;

    // identified (bytes 7 ~ 9)
    send_buff[send_buff_ofs++] = id[0];
    send_buff[send_buff_ofs++] = id[1];
    send_buff[send_buff_ofs++] = id[2];

    // data
    if (databuff_len != 0) {
        memcpy(&send_buff[send_buff_ofs], databuff, databuff_len);
        send_buff_ofs += databuff_len;
    }

    // crc
    uint8_t crc = calculate_crc(send_buff, send_buff_ofs);
    send_buff[send_buff_ofs++] = hex2char((crc >> 4) & 0x0f);
    send_buff[send_buff_ofs++] = hex2char(crc & 0x0f);

    // send packet
    _uart->write(send_buff, send_buff_ofs);
    return true;
}

// set gimbal's lock vs follow mode
// lock should be true if gimbal should maintain an earth-frame target
// lock is false to follow / maintain a body-frame target
bool AP_Mount_Topotek::set_gimbal_lock(bool lock)
{
    if (_last_lock == lock) {
        return true;
    }

    // send message and update lock state
    if (send_fixedlen_packet(AddressByte::GIMBAL, AP_MOUNT_TOPOTEK_ID3CHAR_GIMBAL_MODE, true, lock ? 6 : 7)) {
        _last_lock = lock;
        return true;
    }
    return false;
}

#endif // HAL_MOUNT_TOPOTEK_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         /*
  Topotek gimbal driver using custom serial protocol

  Packet format (courtesy of Topotek's SDK document)

  -------------------------------------------------------------------------------------------
  Field                 Index   Bytes       Description
  -------------------------------------------------------------------------------------------
  Frame Header          0       3           type of command
  Address Bit           3       2           the source address comes first, and the destination address comes last
  Data_Len              5       1           data length
  Control Bit           6       1           r -> query w -> setup and control
  Identification Bit    7       3           identification function
  Data                  10      Data_Len
  Check Bit                     2           the frame header is converted to HEX before reaching the check bit,
                                            the sum is done, and the result is converted to ASC-II. Two bytes, the high one first
 */

#pragma once

#include "AP_Mount_config.h"

#if HAL_MOUNT_TOPOTEK_ENABLED

#include "AP_Mount_Backend_Serial.h"
#include <AP_HAL/AP_HAL.h>
#include <AP_Math/AP_Math.h>
#include <AP_Common/AP_Common.h>

#define AP_MOUNT_TOPOTEK_PACKETLEN_MAX              36          // maximum number of bytes in a packet sent to or received from the gimbal
#define AP_MOUNT_RECV_GIMBAL_CMD_CATEGORIES_NUM     7           // parse the number of gimbal command types

class AP_Mount_Topotek : public AP_Mount_Backend_Serial
{

public:
    // Constructor
    using AP_Mount_Backend_Serial::AP_Mount_Backend_Serial;

    // Do not allow copies
    CLASS_NO_COPY(AP_Mount_Topotek);

    // update mount position - should be called periodically
    void update() override;

    // return true if healthy
    bool healthy() const override;

    // has_pan_control - returns true if this mount can control its pan (required for multicopters)
    bool has_pan_control() const override { return yaw_range_valid(); };

    //
    // camera controls for gimbals
    //

    // take a picture.  returns true on success
    bool take_picture() override;

    // start or stop video recording
    // set start_recording = true to start record, false to stop recording
    bool record_video(bool start_recording) override;

    // set zoom specified as a rate
    bool set_zoom(ZoomType zoom_type, float zoom_value) override;

    // set focus specified as rate or auto
    // focus in = -1, focus hold = 0, focus out = 1
    SetFocusResult set_focus(FocusType focus_type, float focus_value) override;

    // set tracking to none, point or rectangle (see TrackingType enum)
    // if POINT only p1 is used, if RECTANGLE then p1 is top-left, p2 is bottom-right
    // p1,p2 are in range 0 to 1.  0 is left or top, 1 is right or bottom
    bool set_tracking(TrackingType tracking_type, const Vector2f& p1, const Vector2f& p2) override;

    // send command to gimbal to cancel tracking (if necessary)
    // returns true on success, false on failure to send message
    bool cancel_tracking();

    // set camera picture-in-picture mode
    bool set_lens(uint8_t lens) override;

#if HAL_MOUNT_SET_CAMERA_SOURCE_ENABLED
    // set_camera_source is functionally the same as set_lens except primary and secondary lenses are specified by type
    // primary and secondary sources use the AP_Camera::CameraSource enum cast to uint8_t
    bool set_camera_source(uint8_t primary_source, uint8_t secondary_source) override;
#endif

    // send camera information message to GCS
    void send_camera_information(mavlink_channel_t chan) const override;

    // send camera settings message to GCS
    void send_camera_settings(mavlink_channel_t chan) const override;

    //
    // rangefinder
    //

    // get rangefinder distance.  Returns true on success
    bool get_rangefinder_distance(float& distance_m) const override;

    // enable/disable rangefinder.  Returns true on success
    bool set_rangefinder_enable(bool enable) override;

protected:

    // get attitude as a quaternion.  returns true on success
    bool get_attitude_quaternion(Quaternion& att_quat) override;

private:

    // header type (fixed or variable length)
    // first three bytes of packet determined by this value
    enum class HeaderType : uint8_t {
        FIXED_LEN = 0x00,       // #TP will be sent
        VARIABLE_LEN = 0x01,    // #tp will be sent
    };

    // address (2nd and 3rd bytes of packet)
    // first byte is always U followed by one of the other options
    enum class AddressByte : uint8_t {
        SYSTEM_AND_IMAGE = 68,      // 'D'
        AUXILIARY_EQUIPMENT = 69,   // 'E'
        GIMBAL = 71,                // 'G'
        LENS = 77,                  // 'M'
        NETWORK = 80,               // 'P'
        UART = 85,                  // 'U'
    };

    // control byte (read or write)
    // sent as 7th byte of packet
    enum class ControlByte : uint8_t {
        READ = 114,     // 'r'
        WRITE = 119,    // 'w'
    };

    // parsing state
    enum class ParseState : uint8_t {
        WAITING_FOR_HEADER1 = 0,// #
        WAITING_FOR_HEADER2,    // T or t
        WAITING_FOR_HEADER3,    // P or p
        WAITING_FOR_ADDR1,      // normally U
        WAITING_FOR_ADDR2,      // M, D, E, P, G
        WAITING_FOR_DATALEN,
        WAITING_FOR_CONTROL,    // r or w
        WAITING_FOR_ID1,        // e.g. 'G'
        WAITING_FOR_ID2,        // e.g. 'A'
        WAITING_FOR_ID3,        // e.g. 'C'
        WAITING_FOR_DATA,       // normally hex numbers in char form (e.g. '0A')
        WAITING_FOR_CRC_LOW,
        WAITING_FOR_CRC_HIGH,
    };

    // tracking status
    enum class TrackingStatus : uint8_t {
        STOPPED_TRACKING = 0x30,                // not tracking
        WAITING_FOR_TRACKING = 0x31,            // wait to track command status
        TRACKING_IN_PROGRESS = 0x32             // the status is being tracked.
    };

    // identifier bytes
    typedef char Identifier[3];

    // send text prefix string
    static const char* send_message_prefix;

    // reading incoming packets from gimbal and confirm they are of the correct format
    void read_incoming_packets();

    // request gimbal attitude
    void request_gimbal_attitude();

    // request gimbal memory card information
    void request_gimbal_sdcard_info();

    // request gimbal tracking status
    void request_track_status();

    // request gimbal version
    void request_gimbal_version();

    // request gimbal model name
    void request_gimbal_model_name();

    // send angle target in radians to gimbal
    void send_angle_target(const MountTarget& angle_rad);

    // send rate target in rad/s to gimbal
    void send_rate_target(const MountTarget& rate_rads);

    // send time and date to gimbal
    bool send_time_to_gimbal();

    // send GPS-related information to the gimbal
    bool send_location_info();

    // attitude information analysis of gimbal
    void gimbal_angle_analyse();

    // gimbal video information analysis
    void gimbal_record_analyse();

    // information analysis of gimbal storage card
    void gimbal_sdcard_analyse();

    // gimbal tracking information analysis
    void gimbal_track_analyse();

    // gimbal basic information analysis
    void gimbal_version_analyse();

    // gimbal model name message analysis
    void gimbal_model_name_analyse();

    // gimbal distance information analysis
    void gimbal_dist_info_analyse();

    // calculate checksum
    uint8_t calculate_crc(const uint8_t *cmd, uint8_t len) const;

    // hexadecimal to character conversion
    uint8_t hex2char(uint8_t data) const;

    // convert a 4 character hex number to an integer
    // the characters are in the format "1234" where the most significant digit is first
    int16_t hexchar4_to_int16(char high, char mid_high, char mid_low, char low) const;

    // send a fixed length packet to gimbal
    // returns true on success, false if serial port initialization failed
    bool send_fixedlen_packet(AddressByte address, const Identifier id, bool write, uint8_t value);

    // send a variable length packet to gimbal
    // returns true on success, false if serial port initialization failed
    bool send_variablelen_packet(HeaderType header, AddressByte address, const Identifier id, bool write, const uint8_t* databuff, uint8_t databuff_len);

    // set gimbal's lock vs follow mode
    // lock should be true if gimbal should maintain an earth-frame target
    // lock is false to follow / maintain a body-frame target
    bool set_gimbal_lock(bool lock);

    // members
    bool _recording;                                            // recording status (received from gimbal)
    bool _is_tracking;                                          // whether to enable the tracking state
    TrackingStatus _last_tracking_state = TrackingStatus::STOPPED_TRACKING; // last tracking state received from gimbal
    uint8_t _last_mode;                                         // mode during latest update, used to detect mode changes and cancel tracking
    bool _sdcard_status;                                        // memory card status (received from gimbal)
    bool _last_lock;                                            // last lock mode sent to gimbal
    bool _got_gimbal_version;                                   // true if gimbal's version has been received
    bool _got_gimbal_model_name;                                // true if gimbal's model name has been received
    bool _last_zoom_stop;                                       // true if zoom has been stopped (used to re-send in order to handle lost packets)
    bool _last_focus_stop;                                      // true if focus has been stopped (used to re-sent in order to handle lost packets)
    uint8_t _model_name[16];                                    // gimbal model name
    uint8_t _sent_time_count;                                   // count of current time messages sent to gimbal
    uint32_t _firmware_ver;                                     // firmware version
    Vector3f _current_angle_rad;                                // current angles in radians received from gimbal (x=roll, y=pitch, z=yaw)
    uint32_t _last_current_angle_ms;                            // system time (in milliseconds) that angle information received from the gimbal
    uint32_t _last_req_current_info_ms;                         // system time that this driver last requested current gimbal infomation
    uint8_t _last_req_step;                                     // 10hz request loop step (different requests are sent at various steps)
    uint8_t _stop_order_count;                                  // number of stop commands sent since target rates became zero
    float _measure_dist_m = -1.0f;                              // latest rangefinder distance (in meters)
    uint8_t _msg_buff[AP_MOUNT_TOPOTEK_PACKETLEN_MAX];          // buffer holding bytes from latest packet received.  only used to calculate crc
    uint8_t _msg_buff_len;                                      // number of bytes in the msg buffer
    struct {
        ParseState state;                                       // parser state
        uint8_t data_len;                                       // expected number of data bytes
    } _parser;

    // mapping from received message key to member function pointer to consume the message
    typedef struct {
        uint8_t uart_cmd_key[4];                                // gimbal message key;
        void (AP_Mount_Topotek::*func)(void);		            // member function to consume messager
    } UartCmdFunctionHandler;

    // stores command ID and corresponding member functions that are compared with the command received by the gimbal
    UartCmdFunctionHandler uart_recv_cmd_compare_list[AP_MOUNT_RECV_GIMBAL_CMD_CATEGORIES_NUM] = {
        {{"GAC"}, &AP_Mount_Topotek::gimbal_angle_analyse},
        {{"REC"}, &AP_Mount_Topotek::gimbal_record_analyse},
        {{"SDC"}, &AP_Mount_Topotek::gimbal_sdcard_analyse},
        {{"LRF"}, &AP_Mount_Topotek::gimbal_dist_info_analyse},
        {{"TRC"}, &AP_Mount_Topotek::gimbal_track_analyse},
        {{"VSN"}, &AP_Mount_Topotek::gimbal_version_analyse},
        {{"PA2"}, &AP_Mount_Topotek::gimbal_model_name_analyse}
    };
};

#endif // HAL_MOUNT_TOPOTEK_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              #include "AP_Mount_Viewpro.h"

#if HAL_MOUNT_VIEWPRO_ENABLED
#include <AP_HAL/AP_HAL.h>
#include <AP_AHRS/AP_AHRS.h>
#include <AP_GPS/AP_GPS.h>
#include <AP_RTC/AP_RTC.h>
#include <GCS_MAVLink/GCS.h>
#include <GCS_MAVLink/include/mavlink/v2.0/checksum.h>

extern const AP_HAL::HAL& hal;

#define AP_MOUNT_VIEWPRO_HEADER1       0x55     // first header byte
#define AP_MOUNT_VIEWPRO_HEADER2       0xAA     // second header byte
#define AP_MOUNT_VIEWPRO_HEADER3       0xDC     // third header byte
#define AP_MOUNT_VIEWPRO_PACKETLEN_MIN 5        // min number of bytes in a packet (3 header bytes, length, crc)
#define AP_MOUNT_VIEWPRO_DATALEN_MAX   (AP_MOUNT_VIEWPRO_PACKETLEN_MAX-AP_MOUNT_VIEWPRO_PACKETLEN_MIN) // max bytes for data portion of packet
#define AP_MOUNT_VIEWPRO_HEALTH_TIMEOUT_MS 1000 // state will become unhealthy if no attitude is received within this timeout
#define AP_MOUNT_VIEWPRO_UPDATE_INTERVAL_MS 100 // resend angle or rate targets to gimbal at this interval
#define AP_MOUNT_VIEWPRO_ZOOM_SPEED     0x07    // hard-coded zoom speed (fast)
#define AP_MOUNT_VIEWPRO_ZOOM_MAX       10      // hard-coded absolute zoom times max
#define AP_MOUNT_VIEWPRO_DEG_TO_OUTPUT  (65536.0 / 360.0)   // scalar to convert degrees to the viewpro angle scaling
#define AP_MOUNT_VIEWPRO_OUTPUT_TO_DEG  (360.0 / 65536.0)   // scalar to convert viewpro angle scaling to degrees

#define AP_MOUNT_VIEWPRO_DEBUG 0
#define debug(fmt, args ...) do { if (AP_MOUNT_VIEWPRO_DEBUG) { GCS_SEND_TEXT(MAV_SEVERITY_INFO, "Viewpro: " fmt, ## args); } } while (0)

const char* AP_Mount_Viewpro::send_text_prefix = "Viewpro:";

// update mount position - should be called periodically
void AP_Mount_Viewpro::update()
{
    // exit immediately if not initialised
    if (!_initialised) {
        return;
    }

    // below here we sent angle or rate targets
    // throttle sends of target angles or rates
    uint32_t now_ms = AP_HAL::millis();
    if (now_ms - _last_update_ms < AP_MOUNT_VIEWPRO_UPDATE_INTERVAL_MS) {
        return;
    }
    _last_update_ms = now_ms;

    // reading incoming packets from gimbal
    read_incoming_packets();

    // request model name
    if (!_got_model_name) {
        send_comm_config_cmd(CommConfigCmd::QUERY_MODEL);
    }

    // request firmware version
    if (!_got_firmware_version) {
        send_comm_config_cmd(CommConfigCmd::QUERY_FIRMWARE_VER);
    }

    // send handshake
    send_handshake();

    // send vehicle attitude and position
    send_m_ahrs();

    // change to RC_TARGETING mode if RC input has changed
    set_rctargeting_on_rcinput_change();

    // if tracking is active we do not send new targets to the gimbal
    if (_last_tracking_status == TrackingStatus::SEARCHING || _last_tracking_status == TrackingStatus::TRACKING) {
        return;
    }

    // update based on mount mode
    switch (get_mode()) {
        // move mount to a "retracted" position.  To-Do: remove support and replace with a relaxed mode?
        case MAV_MOUNT_MODE_RETRACT: {
            const Vector3f &angle_bf_target = _params.retract_angles.get();
            mnt_target.target_type = MountTargetType::ANGLE;
            mnt_target.angle_rad.set(angle_bf_target*DEG_TO_RAD, false);
            break;
        }

        // move mount to a neutral position, typically pointing forward
        case MAV_MOUNT_MODE_NEUTRAL: {
            const Vector3f &angle_bf_target = _params.neutral_angles.get();
            mnt_target.target_type = MountTargetType::ANGLE;
            mnt_target.angle_rad.set(angle_bf_target*DEG_TO_RAD, false);
            break;
        }

        // point to the angles given by a mavlink message
        case MAV_MOUNT_MODE_MAVLINK_TARGETING:
            // mavlink targets are stored while handling the incoming message
            break;

        // RC radio manual angle control, but with stabilization from the AHRS
        case MAV_MOUNT_MODE_RC_TARGETING: {
            // update targets using pilot's RC inputs
            MountTarget rc_target;
            get_rc_target(mnt_target.target_type, rc_target);
            switch (mnt_target.target_type) {
            case MountTargetType::ANGLE:
                mnt_target.angle_rad = rc_target;
                break;
            case MountTargetType::RATE:
                mnt_target.rate_rads = rc_target;
                break;
            }
            break;
        }

        // point mount to a GPS point given by the mission planner
        case MAV_MOUNT_MODE_GPS_POINT:
            if (get_angle_target_to_roi(mnt_target.angle_rad)) {
                mnt_target.target_type = MountTargetType::ANGLE;
            }
            break;

        // point mount to Home location
        case MAV_MOUNT_MODE_HOME_LOCATION:
            if (get_angle_target_to_home(mnt_target.angle_rad)) {
                mnt_target.target_type = MountTargetType::ANGLE;
            }
            break;

        // point mount to another vehicle
        case MAV_MOUNT_MODE_SYSID_TARGET:
            if (get_angle_target_to_sysid(mnt_target.angle_rad)) {
                mnt_target.target_type = MountTargetType::ANGLE;
            }
            break;

        default:
            // we do not know this mode so raise internal error
            INTERNAL_ERROR(AP_InternalError::error_t::flow_of_control);
            break;
    }

    // send target angles or rates depending on the target type
    switch (mnt_target.target_type) {
        case MountTargetType::ANGLE:
            send_target_angles(mnt_target.angle_rad.pitch, mnt_target.angle_rad.yaw, mnt_target.angle_rad.yaw_is_ef);
            break;
        case MountTargetType::RATE:
            send_target_rates(mnt_target.rate_rads.pitch, mnt_target.rate_rads.yaw, mnt_target.rate_rads.yaw_is_ef);
            break;
    }
}

// return true if healthy
bool AP_Mount_Viewpro::healthy() const
{
    // unhealthy until gimbal has been found and replied with firmware version info
    if (!_initialised) {
        return false;
    }

    // unhealthy if attitude information NOT received recently
    const uint32_t now_ms = AP_HAL::millis();
    if (now_ms - _last_current_angle_rad_ms > AP_MOUNT_VIEWPRO_HEALTH_TIMEOUT_MS) {
        return false;
    }

    // if we get this far return healthy
    return true;
}

// get attitude as a quaternion.  returns true on success
bool AP_Mount_Viewpro::get_attitude_quaternion(Quaternion& att_quat)
{
    att_quat.from_euler(_current_angle_rad.x, _current_angle_rad.y, _current_angle_rad.z);
    return true;
}

// reading incoming packets from gimbal and confirm they are of the correct format
// results are held in the _parsed_msg structure
void AP_Mount_Viewpro::read_incoming_packets()
{
    // check for bytes on the serial port
    int16_t nbytes = MIN(_uart->available(), 1024U);
    if (nbytes <= 0 ) {
        return;
    }

    // flag to allow cases below to reset parser state
    bool reset_parser = false;

    // process bytes received
    for (int16_t i = 0; i < nbytes; i++) {
        uint8_t b;
        if (!_uart->read(b)) {
            continue;
        }

        _msg_buff[_msg_buff_len++] = b;

        // protect against overly long messages
        if (_msg_buff_len > AP_MOUNT_VIEWPRO_PACKETLEN_MAX) {
            reset_parser = true;
            debug("vp buff full s:%u len:%u", (unsigned)_parsed_msg.state, (unsigned)_msg_buff_len);
        }

        // process byte depending upon current state
        switch (_parsed_msg.state) {

        case ParseState::WAITING_FOR_HEADER1:
            if (b == AP_MOUNT_VIEWPRO_HEADER1) {
                // throw away byte
                _msg_buff_len = 0;
                _parsed_msg.state = ParseState::WAITING_FOR_HEADER2;
            } else {
                reset_parser = true;
            }
            break;

        case ParseState::WAITING_FOR_HEADER2:
            if (b == AP_MOUNT_VIEWPRO_HEADER2) {
                // throw away byte
                _msg_buff_len = 0;
                _parsed_msg.state = ParseState::WAITING_FOR_HEADER3;
            } else {
                reset_parser = true;
            }
            break;

        case ParseState::WAITING_FOR_HEADER3:
            if (b == AP_MOUNT_VIEWPRO_HEADER3) {
                // throw away byte
                _msg_buff_len = 0;
                _parsed_msg.state = ParseState::WAITING_FOR_LENGTH;
            } else {
                reset_parser = true;
            }
            break;

        case ParseState::WAITING_FOR_LENGTH:
            // length held in bits 0 ~ 5.  length includes this length byte, frame id and final crc
            // ignore frame counter held in bits 6~7
            _parsed_msg.data_len = b & 0x3F;
            _parsed_msg.state = ParseState::WAITING_FOR_FRAMEID;
            break;

        case ParseState::WAITING_FOR_FRAMEID:
            _parsed_msg.frame_id = b;
            _parsed_msg.data_bytes_received = 0;
            _parsed_msg.state = ParseState::WAITING_FOR_DATA;
            break;

        case ParseState::WAITING_FOR_DATA:
            _parsed_msg.data_bytes_received++;
            // check if we have received all data bytes.  subtract 3 to remove length byte, frame id and final crc
            if (_parsed_msg.data_bytes_received >= _parsed_msg.data_len - 3) {
                _parsed_msg.state = ParseState::WAITING_FOR_CRC;
            }
            break;

        case ParseState::WAITING_FOR_CRC: {
            _parsed_msg.crc = b;
            const uint16_t expected_crc = calc_crc(_msg_buff, _msg_buff_len-1);
            if (expected_crc == _parsed_msg.crc) {
                // successfully received a message, do something with it
                process_packet();
            } else {
                debug("crc expected:%x got:%x", (unsigned)expected_crc, (unsigned)_parsed_msg.crc);
            }
            reset_parser = true;
            break;
            }
        }

        // handle reset of parser
        if (reset_parser) {
            _msg_buff_len = 0;
            _parsed_msg.state = ParseState::WAITING_FOR_HEADER1;
            reset_parser = false;
        }
    }
}

// process successfully decoded packets held in the _parsed_msg structure
void AP_Mount_Viewpro::process_packet()
{
    // process packet depending upon frame id
    switch ((FrameId)_parsed_msg.frame_id) {

    case FrameId::HANDSHAKE:
        break;

    case FrameId::V: {
        const CommConfigCmd control_cmd = (CommConfigCmd)_msg_buff[_msg_buff_data_start];
        switch (control_cmd) {
        case CommConfigCmd::QUERY_FIRMWARE_VER: {
            // firmware version, length is 20 bytes but we expect format of "S" + yyyymmdd
            const uint8_t fw_major_str[3] {_msg_buff[_msg_buff_data_start+4], _msg_buff[_msg_buff_data_start+5], 0x0};
            const uint8_t fw_minor_str[3] {_msg_buff[_msg_buff_data_start+6], _msg_buff[_msg_buff_data_start+7], 0x0};
            const uint8_t fw_patch_str[3] {_msg_buff[_msg_buff_data_start+8], _msg_buff[_msg_buff_data_start+9], 0x0};
            const uint8_t major_ver = atoi((const char*)fw_major_str) & 0xFF;
            const uint8_t minor_ver = atoi((const char*)fw_minor_str) & 0xFF;
            const uint8_t patch_ver = atoi((const char*)fw_patch_str) & 0xFF;
            _firmware_version = (patch_ver << 16) | (minor_ver << 8) | major_ver;
            _got_firmware_version = true;
            GCS_SEND_TEXT(MAV_SEVERITY_INFO, "%s fw:%u.%u.%u", send_text_prefix, (unsigned)major_ver, (unsigned)minor_ver, (unsigned)patch_ver);
            break;
        }
        case CommConfigCmd::QUERY_MODEL:
            // gimbal model, length is 10 bytes
            strncpy((char *)_model_name, (const char *)&_msg_buff[_msg_buff_data_start+1], sizeof(_model_name)-1);
            _got_model_name = true;
            GCS_SEND_TEXT(MAV_SEVERITY_INFO, "%s %s", send_text_prefix, (const char*)_model_name);
            break;
        default:
            // unsupported control command
            break;
        }
        break;
    }

    case FrameId::T1_F1_B1_D1: {
        // T1 holds target info including target lean angles
        // F1 holds tracker sensor status (which camera, tracking vs lost)
        // B1 section holds actual lean angles
        // D1 section holds camera status including zoom level
        //const int8_t servo_status = (_msg_buff[_msg_buff_data_start+24] & 0xF0) >> 4;
        const TrackingStatus tracking_status = (TrackingStatus)((_msg_buff[_msg_buff_data_start+22] & 0x18) >> 3);
        if (tracking_status != _last_tracking_status) {
            _last_tracking_status = tracking_status;
            switch (tracking_status) {
            case TrackingStatus::STOPPED:
                GCS_SEND_TEXT(MAV_SEVERITY_INFO, "%s tracking OFF", send_text_prefix);
                break;
            case TrackingStatus::SEARCHING:
                GCS_SEND_TEXT(MAV_SEVERITY_INFO, "%s tracking searching", send_text_prefix);
                break;
            case TrackingStatus::TRACKING:
                GCS_SEND_TEXT(MAV_SEVERITY_INFO, "%s tracking ON", send_text_prefix);
                break;
            case TrackingStatus::LOST:
                GCS_SEND_TEXT(MAV_SEVERITY_INFO, "%s tracking Lost", send_text_prefix);
                break;
            }
        }

        _last_current_angle_rad_ms = AP_HAL::millis();
        _current_angle_rad.x = radians((int16_t)UINT16_VALUE(_msg_buff[_msg_buff_data_start+23] & 0x0F, _msg_buff[_msg_buff_data_start+24]) * (180.0/4095.0) - 90.0);   // roll angle
        _current_angle_rad.z = radians((int16_t)UINT16_VALUE(_msg_buff[_msg_buff_data_start+25], _msg_buff[_msg_buff_data_start+26]) * AP_MOUNT_VIEWPRO_OUTPUT_TO_DEG); // yaw angle
        _current_angle_rad.y = -radians((int16_t)UINT16_VALUE(_msg_buff[_msg_buff_data_start+27], _msg_buff[_msg_buff_data_start+28]) * AP_MOUNT_VIEWPRO_OUTPUT_TO_DEG); // pitch angle
        debug("r:%4.1f p:%4.1f y:%4.1f", (double)degrees(_current_angle_rad.x), (double)degrees(_current_angle_rad.y), (double)degrees(_current_angle_rad.z));

        // get active image sensor. D1's image sensor values are one value lower than C1's
        _image_sensor = ImageSensor((_msg_buff[_msg_buff_data_start+29] & 0x07) + 1);

        // get recording status
        const RecordingStatus recording_status = (RecordingStatus)(_msg_buff[_msg_buff_data_start+32] & 0x07);
        const bool recording = (recording_status == RecordingStatus::RECORDING);
        if (recording != _recording) {
            _recording = recording;
            GCS_SEND_TEXT(MAV_SEVERITY_INFO,  "%s recording %s", send_text_prefix, _recording ? "ON" : "OFF");
        }

        // get optical zoom times
        _zoom_times = UINT16_VALUE(_msg_buff[_msg_buff_data_start+39], _msg_buff[_msg_buff_data_start+40]) * 0.1;

        // get laser rangefinder distance
        _rangefinder_dist_m = UINT16_VALUE(_msg_buff[_msg_buff_data_start+33], _msg_buff[_msg_buff_data_start+34]) * 0.1;
        break;
    }

    default:
        debug("Unhandled FrameId:%u", (unsigned)_parsed_msg.frame_id);
        break;
    }
}

// calculate crc of the received message
uint8_t AP_Mount_Viewpro::calc_crc(const uint8_t *buf, uint8_t len) const
{
    uint8_t res = 0;
    for (uint8_t i=0; i<len; i++) {
        res = (res ^ buf[i]) & 0xFF;
    }
    return res;
}

// calculate the length and frame count byte (3rd byte of all messages)
// length is all bytes after the header including CRC
uint8_t AP_Mount_Viewpro::get_length_and_frame_count_byte(uint8_t length)
{
  // increment frame counter
  _last_frame_counter = (_last_frame_counter + 1) & 0x03;
  return ((_last_frame_counter << 6) | (length & 0x3F));
}

// send packet to gimbal.  databuff includes everything after the length-and-frame-counter, does not include crc
// returns true on success, false if outgoing serial buffer is full
bool AP_Mount_Viewpro::send_packet(const uint8_t* databuff, uint8_t databuff_len)
{
    if (!_initialised) {
        return false;
    }

    // calculate and sanity check packet size
    const uint16_t packet_size = AP_MOUNT_VIEWPRO_PACKETLEN_MIN + databuff_len;
    if (packet_size > AP_MOUNT_VIEWPRO_PACKETLEN_MAX) {
        debug("send_packet data buff too large");
        return false;
    }

    // check for sufficient space in outgoing buffer
    if (_uart->txspace() < packet_size) {
        debug("tx space too low (%u < %u)", (unsigned)_uart->txspace(), (unsigned)packet_size);
        return false;
    }

    // buffer for holding outgoing packet
    uint8_t send_buff[packet_size];
    uint8_t send_buff_ofs = 0;

    // packet header
    send_buff[send_buff_ofs++] = AP_MOUNT_VIEWPRO_HEADER1;
    send_buff[send_buff_ofs++] = AP_MOUNT_VIEWPRO_HEADER2;
    send_buff[send_buff_ofs++] = AP_MOUNT_VIEWPRO_HEADER3;

    // length and frame counter. length is databuffer length + 2 (1 for length, 1 for crc)
    send_buff[send_buff_ofs++] = get_length_and_frame_count_byte(databuff_len + 2);

    // data
    if (databuff_len != 0) {
        memcpy(&send_buff[send_buff_ofs], databuff, databuff_len);
        send_buff_ofs += databuff_len;
    }

    // crc
    const uint8_t crc = calc_crc(&send_buff[3], send_buff_ofs-3);
    send_buff[send_buff_ofs++] = crc;

    // write packet to serial port
    _uart->write(send_buff, send_buff_ofs);
    

    return true;
}

// send handshake, gimbal will respond with T1_F1_B1_D1 paket that includes current angles
void AP_Mount_Viewpro::send_handshake()
{
    const HandshakePacket hs_packet {
        .content = {
            frame_id: FrameId::HANDSHAKE,
            unused: 0
        }
    };
    send_packet(hs_packet.bytes, sizeof(hs_packet.bytes));
}

// set gimbal's lock vs follow mode
// lock should be true if gimbal should maintain an earth-frame target
// lock is false to follow / maintain a body-frame target
bool AP_Mount_Viewpro::set_lock(bool lock)
{
    // do not send if lock mode has already been sent recently
    if (_last_lock == lock) {
        return true;
    }

    // fill in packet
    const A1Packet a1_packet {
        .content = {
            frame_id: FrameId::A1,
            servo_status: lock ? ServoStatus::FOLLOW_YAW_DISABLE : ServoStatus::FOLLOW_YAW
        }
    };

    // send targets to gimbal
    if (send_packet(a1_packet.bytes, sizeof(a1_packet.bytes))) {
        _last_lock = lock;
        return true;
    }
    return false;
}

// send communication configuration command (aka U packet), gimbal will respond with a V packet
bool AP_Mount_Viewpro::send_comm_config_cmd(CommConfigCmd cmd)
{
    // fill in packet
    const UPacket u_packet {
        .content = {
            frame_id: FrameId::U,
            control_cmd: cmd
        }
    };

    // send targets to gimbal
    return send_packet(u_packet.bytes, sizeof(u_packet.bytes));
}

// send target pitch and yaw rates to gimbal
// yaw_is_ef should be true if yaw_rads target is an earth frame rate, false if body_frame
bool AP_Mount_Viewpro::send_target_rates(float pitch_rads, float yaw_rads, bool yaw_is_ef)
{
    // set lock value
    if (!set_lock(yaw_is_ef)) {
        return false;
    }

    // scale pitch and yaw to values gimbal understands
    const int16_t pitch_rate_output = -degrees(pitch_rads) * 100.0;
    const int16_t yaw_rate_output = degrees(yaw_rads) * 100.0;

    // fill in packet
    const A1Packet a1_packet {
        .content = {
            frame_id: FrameId::A1,
            servo_status: ServoStatus::MANUAL_SPEED_MODE,
            yaw_be: htobe16(yaw_rate_output),
            pitch_be: htobe16(pitch_rate_output)
        }
    };

    // send targets to gimbal
    return send_packet(a1_packet.bytes, sizeof(a1_packet.bytes));
}

// send target pitch and yaw angles to gimbal
// yaw_is_ef should be true if yaw_rad target is an earth frame angle, false if body_frame
bool AP_Mount_Viewpro::send_target_angles(float pitch_rad, float yaw_rad, bool yaw_is_ef)
{
    // gimbal does not support lock in angle control mode
    if (!set_lock(false)) {
        return false;
    }

    // convert yaw angle to body-frame
    float yaw_bf_rad = yaw_is_ef ? wrap_PI(yaw_rad - AP::ahrs().get_yaw()) : yaw_rad;

    // enforce body-frame yaw angle limits.  If beyond limits always use body-frame control
    const float yaw_bf_min = radians(_params.yaw_angle_min);
    const float yaw_bf_max = radians(_params.yaw_angle_max);
    if (yaw_bf_rad < yaw_bf_min || yaw_bf_rad > yaw_bf_max) {
        yaw_bf_rad = constrain_float(yaw_bf_rad, yaw_bf_min, yaw_bf_max);
        yaw_is_ef = false;
    }

    // scale pitch and yaw to values gimbal understands
    const int16_t pitch_angle_output = -degrees(pitch_rad) * AP_MOUNT_VIEWPRO_DEG_TO_OUTPUT;
    const int16_t yaw_angle_output = degrees(yaw_bf_rad) * AP_MOUNT_VIEWPRO_DEG_TO_OUTPUT;

    // fill in packet
    const A1Packet a1_packet {
        .content = {
            frame_id: FrameId::A1,
            servo_status: ServoStatus::MANUAL_ABSOLUTE_ANGLE_MODE,
            yaw_be: htobe16(yaw_angle_output),
            pitch_be: htobe16(pitch_angle_output)
        }
    };

    // send targets to gimbal
    return send_packet(a1_packet.bytes, sizeof(a1_packet.bytes));
}

// send camera command, affected image sensor and value (e.g. zoom speed)
bool AP_Mount_Viewpro::send_camera_command(ImageSensor img_sensor, CameraCommand cmd, uint8_t value, LRFCommand lrf_cmd)
{
    // fill in 2 bytes containing sensor, zoom speed, operation command and LRF
    // bit0~2: sensor
    // bit3~5: zoom speed
    // bit6~12: operation command no
    // bit13~15: LRF command
    const uint16_t sensor_id = (uint16_t)img_sensor;
    const uint16_t zoom_speed = ((uint16_t)value & 0x07) << 3;
    const uint16_t operation_cmd = ((uint16_t)cmd & 0x7F) << 6;
    const uint16_t rangefinder_cmd = ((uint16_t)lrf_cmd & 0x07) << 13;

    // fill in packet
    const C1Packet c1_packet {
        .content = {
            frame_id: FrameId::C1,
            sensor_zoom_cmd_be:  htobe16(sensor_id | zoom_speed | operation_cmd | rangefinder_cmd)
        }
    };

    // send packet to gimbal
    return send_packet(c1_packet.bytes, sizeof(c1_packet.bytes));
}

// send camera command2 and corresponding value (e.g. zoom as absolute value)
bool AP_Mount_Viewpro::send_camera_command2(CameraCommand2 cmd, uint16_t value)
{
    // fill in packet
    const C2Packet c2_packet {
        .content = {
            frame_id: FrameId::C2,
            cmd: cmd,
            value_be: htobe16(value)
        }
    };

    // send packet to gimbal
    return send_packet(c2_packet.bytes, sizeof(c2_packet.bytes));
}

// send tracking command and corresponding value (normally zero)
bool AP_Mount_Viewpro::send_tracking_command(TrackingCommand cmd, uint8_t value)
{
    // convert image sensor to tracking source
    TrackingSource tracking_source = TrackingSource::EO1;
    switch (_image_sensor) {
    case ImageSensor::NO_ACTION:    
    case ImageSensor::EO1:
    case ImageSensor::EO1_IR_PIP:
    case ImageSensor::FUSION:
        tracking_source = TrackingSource::EO1;
        break;
    case ImageSensor::IR:
    case ImageSensor::IR_EO1_PIP:
    case ImageSensor::IR1_13MM:
    case ImageSensor::IR2_52MM:
        tracking_source = TrackingSource::IR;
        break;    
    }

    // fill in packet
    // Packet creation is done long-hand here to support g++-7.5.0
    E1Packet e1_packet {};
    e1_packet.content.frame_id = FrameId::E1;
    e1_packet.content.source = tracking_source;
    e1_packet.content.cmd = cmd;
    e1_packet.content.param2 = value; // normally zero

    // send packet to gimbal
    return send_packet(e1_packet.bytes, sizeof(e1_packet.bytes));
}

// send camera command2 and corresponding parameter values
bool AP_Mount_Viewpro::send_tracking_command2(TrackingCommand2 cmd, uint16_t param1, uint16_t param2)
{
    // fill in packet
    const E2Packet e2_packet {
        .content = {
            frame_id: FrameId::E2,
            cmd: cmd,
            param1_be: htobe16(param1),
            param2_be: htobe16(param2),
        }
    };

    // send packet to gimbal
    return send_packet(e2_packet.bytes, sizeof(e2_packet.bytes));
}

// send vehicle attitude and position to gimbal
bool AP_Mount_Viewpro::send_m_ahrs()
{
    // get current location
    Location loc;
    int32_t alt_amsl_cm = 0;
    if (!AP::ahrs().get_location(loc) || !loc.get_alt_cm(Location::AltFrame::ABSOLUTE, alt_amsl_cm)) {
        return false;
    }

#if AP_RTC_ENABLED
    // get date and time
    uint16_t year, ms;
    uint8_t month, day, hour, min, sec;
    if (!AP::rtc().get_date_and_time_utc(year, month, day, hour, min, sec, ms)) {
        year = month = day = hour = min = sec = ms = 0;
    }
    uint16_t date = ((year-2000) & 0x7f) | (((month+1) & 0x0F) << 7) | ((day & 0x1F) << 11);
    uint64_t second_hundredths = (((hour * 60 * 60) + (min * 60) + sec) * 100) + (ms * 0.1);
#else
    const uint16_t date = 0;
    const uint64_t second_hundredths = 0;
#endif

    // get vehicle velocity in m/s in NED Frame
    Vector3f vel_NED;
    IGNORE_RETURN(AP::ahrs().get_velocity_NED(vel_NED));
    float vel_yaw_deg = wrap_360(degrees(vel_NED.xy().angle()));

    // get GPS vdop
    uint16_t gps_vdop = AP::gps().get_vdop();

    // get vehicle yaw in the range 0 to 360
    const uint16_t veh_yaw_deg = wrap_360(degrees(AP::ahrs().get_yaw()));

    // fill in packet
    const M_AHRSPacket mahrs_packet {
        .content = {
            frame_id: FrameId::M_AHRS,
            data_type: 0x07,                        // Bit0: Attitude, Bit1: GPS, Bit2 Gyro
            unused2to8 : {0, 0, 0, 0, 0, 0, 0},
            roll_be: htobe16(degrees(AP::ahrs().get_roll()) * AP_MOUNT_VIEWPRO_DEG_TO_OUTPUT),      // vehicle roll angle.  1bit=360deg/65536
            pitch_be: htobe16(-degrees(AP::ahrs().get_pitch()) * AP_MOUNT_VIEWPRO_DEG_TO_OUTPUT),   // vehicle pitch angle.  1bit=360deg/65536
            yaw_be: htobe16(veh_yaw_deg * AP_MOUNT_VIEWPRO_DEG_TO_OUTPUT),                          // vehicle yaw angle.  1bit=360deg/65536
            date_be: htobe16(date),                 // bit0~6:year, bit7~10:month, bit11~15:day
            seconds_utc: {uint8_t((second_hundredths & 0xFF0000ULL) >> 16), // seconds * 100 MSB.  1bit = 0.01sec
                          uint8_t((second_hundredths & 0xFF00ULL) >> 8),    // seconds * 100 next MSB.  1bit = 0.01sec
                          uint8_t(second_hundredths & 0xFFULL)},            // seconds * 100 LSB.  1bit = 0.01sec
            gps_yaw_be: htobe16(vel_yaw_deg * AP_MOUNT_VIEWPRO_DEG_TO_OUTPUT),  // GPS yaw
            position_mark_bitmask: 0x0F,            // bit0:new position, bit1:clock fix calced, bit2:horiz calced, bit3:alt calced
            latitude_be: htobe32(loc.lat),          // latitude.  1bit = 10e-7
            longitude_be: htobe32(loc.lng),         // longitude.  1bit = 10e-7
            height_be: htobe32(alt_amsl_cm * 10),   // height.  1bit = 1mm
            ground_speed_N_be: htobe16(vel_NED.x * 100),    // ground speed in North direction. 1bit = 0.01m/s
            ground_speed_E_be: htobe16(vel_NED.y * 100),    // ground speed in East direction. 1bit = 0.01m/s
            vdop_be: htobe16(gps_vdop),             // GPS vdop. 1bit = 0.01
            ground_speed_D_be: htobe16(vel_NED.z * 100)     // speed downwards. 1bit = 0.01m/s
        }
    };

    // send packet to gimbal
    return send_packet(mahrs_packet.bytes, sizeof(mahrs_packet.bytes));
}

// take a picture.  returns true on success
bool AP_Mount_Viewpro::take_picture()
{
    // exit immediately if not initialised
    if (!_initialised) {
        return false;
    }

    return send_camera_command(_image_sensor, CameraCommand::TAKE_PICTURE, 0);
}

// start or stop video recording.  returns true on success
// set start_recording = true to start record, false to stop recording
bool AP_Mount_Viewpro::record_video(bool start_recording)
{
    // exit immediately if not initialised
    if (!_initialised) {
        return false;
    }

    return send_camera_command(_image_sensor, start_recording ? CameraCommand::START_RECORD : CameraCommand::STOP_RECORD, 0);
}

// set zoom specified as a rate or percentage
bool AP_Mount_Viewpro::set_zoom(ZoomType zoom_type, float zoom_value)
{
    // exit immediately if not initialised
    if (!_initialised) {
        return false;
    }

    // zoom rate
    if (zoom_type == ZoomType::RATE) {
        CameraCommand zoom_cmd = CameraCommand::STOP_FOCUS_AND_ZOOM;
        if (zoom_value < 0) {
            zoom_cmd = CameraCommand::ZOOM_OUT;
        } else if (zoom_value > 0) {
            zoom_cmd = CameraCommand::ZOOM_IN;
        }
        return send_camera_command(_image_sensor, zoom_cmd, AP_MOUNT_VIEWPRO_ZOOM_SPEED);
    }

    // zoom percentage
    if (zoom_type == ZoomType::PCT) {
        // convert zoom percentage (0 ~ 100) to zoom value (0 ~ max zoom * 10)
        return send_camera_command2(CameraCommand2::SET_EO_ZOOM, linear_interpolate(0, AP_MOUNT_VIEWPRO_ZOOM_MAX * 10, zoom_value, 0, 100));
    }

    // unsupported zoom type
    return false;
}

// set focus specified as rate, percentage or auto
// focus in = -1, focus hold = 0, focus out = 1
SetFocusResult AP_Mount_Viewpro::set_focus(FocusType focus_type, float focus_value)
{
    // exit immediately if not initialised
    if (!_initialised) {
        return SetFocusResult::FAILED;
    }

    switch (focus_type) {
    case FocusType::RATE: {
        CameraCommand focus_cmd = CameraCommand::STOP_FOCUS_AND_ZOOM;
        if (focus_value < 0) {
            focus_cmd = CameraCommand::FOCUS_MINUS;
        } else if (focus_value > 0) {
            focus_cmd = CameraCommand::FOCUS_PLUS;
        }
        if (!send_camera_command(_image_sensor, focus_cmd, 0)) {
            return SetFocusResult::FAILED;
        }
        return SetFocusResult::ACCEPTED;
    }
    case FocusType::PCT:
        // not supported
        return SetFocusResult::INVALID_PARAMETERS;
    case FocusType::AUTO:
        if (!send_camera_command(_image_sensor, CameraCommand::AUTO_FOCUS, 0)) {
            return SetFocusResult::FAILED;
        }
        return SetFocusResult::ACCEPTED;
    }

    // unsupported focus type
    return SetFocusResult::INVALID_PARAMETERS;
}

// set tracking to none, point or rectangle (see TrackingType enum)
// if POINT only p1 is used, if RECTANGLE then p1 is top-left, p2 is bottom-right
// p1,p2 are in range 0 to 1.  0 is left or top, 1 is right or bottom
bool AP_Mount_Viewpro::set_tracking(TrackingType tracking_type, const Vector2f& p1, const Vector2f& p2)
{
    // exit immediately if not initialised
    if (!_initialised) {
        return false;
    }

    switch (tracking_type) {
    case TrackingType::TRK_NONE:
        return send_tracking_command(TrackingCommand::STOP, 0);
        break;
    case TrackingType::TRK_POINT: {
        return (send_tracking_command(TrackingCommand::START, 0) &&
                send_tracking_command2(TrackingCommand2::SET_POINT, (p1.x - 0.5) * 960, (p1.y - 0.5) * 540));
        break;
    }
    case TrackingType::TRK_RECTANGLE:
        return (send_tracking_command(TrackingCommand::START, 0) &&
                send_tracking_command2(TrackingCommand2::SET_RECT_TOPLEFT, (p1.x - 0.5) * 960, (p1.y - 0.5) * 540) &&
                send_tracking_command2(TrackingCommand2::SET_RECT_BOTTOMRIGHT, (p2.x - 0.5) * 960, (p2.y - 0.5) * 540));
        break;
    }

    // should never reach here
    return false;
}

// set camera lens as a value from 0 to 5
bool AP_Mount_Viewpro::set_lens(uint8_t lens)
{
    // exit immediately if not initialised
    if (!_initialised) {
        return false;
    }

    // match lens to ImageSensor enum values and sanity check
    lens++;
    if (lens > (uint8_t)ImageSensor::IR2_52MM) {
        return false;
    }

    // if lens is zero use default lens
    ImageSensor new_image_sensor = ImageSensor(lens);
    return send_camera_command(new_image_sensor, CameraCommand::NO_ACTION, 0);
}

// set_camera_source is functionally the same as set_lens except primary and secondary lenses are specified by type
// primary and secondary sources use the AP_Camera::CameraSource enum cast to uint8_t
bool AP_Mount_Viewpro::set_camera_source(uint8_t primary_source, uint8_t secondary_source)
{
    // maps primary and secondary source to viewpro image sensor
    ImageSensor new_image_sensor;
    switch (primary_source) {
    case 0: // Default (RGB)
        FALLTHROUGH;
    case 1: // RGB
        switch (secondary_source) {
        case 0: // RGB + Default (None)
            new_image_sensor = ImageSensor::EO1;
            break;
        case 2: // PIP RGB+IR
            new_image_sensor = ImageSensor::EO1_IR_PIP;
            break;
        default:
            return false;
        }
        break;
    case /************************************************************
* SoloGimbal -- library to control a 3 axis rate gimbal.     *
*                                                           *
* Author:  Arthur Benemann, Paul Riseborough;               *
*                                                           *
************************************************************/
#pragma once

#include "AP_Mount_config.h"

#if HAL_SOLO_GIMBAL_ENABLED

#include <AP_AccelCal/AP_AccelCal.h>
#include <AP_Common/AP_Common.h>
#include <AP_HAL/AP_HAL_Boards.h>
#include <AP_Math/AP_Math.h>
#include <GCS_MAVLink/GCS_MAVLink.h>

#include "SoloGimbal_Parameters.h"
#include "SoloGimbalEKF.h"

enum gimbal_state_t {
    GIMBAL_STATE_NOT_PRESENT = 0,
    GIMBAL_STATE_PRESENT_INITIALIZING,
    GIMBAL_STATE_PRESENT_ALIGNING,
    GIMBAL_STATE_PRESENT_RUNNING
};

enum gimbal_mode_t {
    GIMBAL_MODE_IDLE = 0,
    GIMBAL_MODE_POS_HOLD,
    GIMBAL_MODE_POS_HOLD_FF,
    GIMBAL_MODE_STABILIZE
};

class SoloGimbal : AP_AccelCal_Client
{
public:
    //Constructor
    SoloGimbal() :
        _ekf(),
        _state(GIMBAL_STATE_NOT_PRESENT),
        _vehicle_yaw_rate_ef_filt(0.0f),
        _vehicle_to_gimbal_quat(),
        _vehicle_to_gimbal_quat_filt(),
        _filtered_joint_angles(),
        _last_report_msg_ms(0),
        _max_torque(5000.0f),
        _ang_vel_mag_filt(0),
        _lockedToBody(false),
        _log_dt(0),
        _log_del_ang(),
        _log_del_vel()
    {
#if HAL_INS_ACCELCAL_ENABLED
        AP_AccelCal::register_client(this);
#endif
    }

    void    update_target(const Vector3f &newTarget);
    void    receive_feedback(mavlink_channel_t chan, const mavlink_message_t &msg);

    void update_fast();

    bool present();
    bool aligned();

    void set_lockedToBody(bool val) { _lockedToBody = val; }

    void write_logs();

    float get_log_dt() const { return _log_dt; }

    void disable_torque_report() { _gimbalParams.set_param(GMB_PARAM_GMB_SND_TORQUE, 0); }
    void fetch_params() { _gimbalParams.fetch_params(); }

    void handle_param_value(const mavlink_message_t &msg) {
        _gimbalParams.handle_param_value(msg);
    }

private:
    // private methods
    void update_estimators();
    void send_controls(mavlink_channel_t chan);
    void extract_feedback(const mavlink_gimbal_report_t& report_msg);
    void update_joint_angle_est();

    Vector3f get_ang_vel_dem_yaw(const Quaternion &quatEst);
    Vector3f get_ang_vel_dem_roll_tilt(const Quaternion &quatEst);
    Vector3f get_ang_vel_dem_feedforward(const Quaternion &quatEst) const;
    Vector3f get_ang_vel_dem_gyro_bias();
    Vector3f get_ang_vel_dem_body_lock();

    void gimbal_ang_vel_to_joint_rates(const Vector3f& ang_vel, Vector3f& joint_rates) const;
    void joint_rates_to_gimbal_ang_vel(const Vector3f& joint_rates, Vector3f& ang_vel) const;

    void readVehicleDeltaAngle(uint8_t ins_index, Vector3f &dAng);

    void _acal_save_calibrations() override;
    bool _acal_get_ready_to_sample() override;
    bool _acal_get_saving() override;
    AccelCalibrator* _acal_get_calibrator(uint8_t instance) override;

    gimbal_mode_t get_mode();

    bool joints_near_limits() const;

    // private member variables
    SoloGimbalEKF            _ekf;      // state of small EKF for gimbal

    gimbal_state_t _state;

    struct {
        float delta_time;
        Vector3f delta_angles;
        Vector3f delta_velocity;
        Vector3f joint_angles;
    } _measurement;

    float _vehicle_yaw_rate_ef_filt;

    static const uint8_t _compid = MAV_COMP_ID_GIMBAL;

    // joint angle filter states
    Vector3f _vehicle_delta_angles;

    Quaternion _vehicle_to_gimbal_quat;
    Quaternion _vehicle_to_gimbal_quat_filt;
    Vector3f _filtered_joint_angles;

    uint32_t _last_report_msg_ms;

    float _max_torque;

    float _ang_vel_mag_filt;

    Vector3f    _ang_vel_dem_rads;       // rad/s
    Vector3f    _att_target_euler_rad;   // desired earth-frame roll, tilt and pan angles in radians

    bool _lockedToBody;

    SoloGimbal_Parameters _gimbalParams;

    AccelCalibrator _calibrator;

    float _log_dt;
    Vector3f _log_del_ang;
    Vector3f _log_del_vel;
};

#endif // HAL_SOLO_GIMBAL_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     #include <AP_HAL/AP_HAL.h>

// uncomment this to force the optimisation of this code, note that
// this makes debugging harder
#if CONFIG_HAL_BOARD == HAL_BOARD_SITL || CONFIG_HAL_BOARD == HAL_BOARD_LINUX
#pragma GCC optimize("O0")
#else
#pragma GCC optimize("O2")
#endif

#include "SoloGimbalEKF.h"
#if HAL_SOLO_GIMBAL_ENABLED
#include <AP_Param/AP_Param.h>
#include <AP_NavEKF/AP_Nav_Common.h>
#include <AP_AHRS/AP_AHRS.h>
#include <AP_Compass/AP_Compass.h>

#include <stdio.h>

extern const AP_HAL::HAL& hal;


// Define tuning parameters
const AP_Param::GroupInfo SoloGimbalEKF::var_info[] = {
    AP_GROUPEND
};

// Hash define constants
#define GYRO_BIAS_LIMIT 0.349066f // maximum allowed gyro bias (rad/sec)

// constructor
SoloGimbalEKF::SoloGimbalEKF() :
    states(),
    state(*reinterpret_cast<struct state_elements *>(&states))
{
    AP_Param::setup_object_defaults(this, var_info);
    reset();
}


// complete reset
void SoloGimbalEKF::reset()
{
    ZERO_FARRAY(states);
    memset((void *)&gSense,0,sizeof(gSense));
    memset(&Cov,0,sizeof(Cov));
    TiltCorrectionSquared = 0;
    StartTime_ms = 0;
    FiltInit = false;
    lastMagUpdate = 0;
    dtIMU = 0;
    innovationIncrement = 0;
    lastInnovation = 0;
}

// run a 9-state EKF used to calculate orientation
void SoloGimbalEKF::RunEKF(float delta_time, const Vector3f &delta_angles, const Vector3f &delta_velocity, const Vector3f &joint_angles)
{
    imuSampleTime_ms = AP_HAL::millis();
    dtIMU = delta_time;

    // initialise variables and constants
    if (!FiltInit) {
        // Note: the start time is initialised to 0 in the constructor
        if (StartTime_ms == 0) {
            StartTime_ms = imuSampleTime_ms;
        }

        // Set data to pre-initialsation defaults
        FiltInit = false;
        newDataMag = false;
        YawAligned = false;
        memset((void *)&state, 0, sizeof(state));
        state.quat[0] = 1.0f;

        bool main_ekf_healthy = false;
        nav_filter_status main_ekf_status;

        const auto &_ahrs = AP::ahrs();

        if (_ahrs.get_filter_status(main_ekf_status)) {
            if (main_ekf_status.flags.attitude) {
                main_ekf_healthy = true;
            }
        }

        // Wait for gimbal to stabilise to body fixed position for a few seconds before starting small EKF
        // Also wait for navigation EKF to be healthy beasue we are using the velocity output data
        // This prevents jerky gimbal motion from degrading the EKF initial state estimates
        if (imuSampleTime_ms - StartTime_ms < 5000 || !main_ekf_healthy) {
            return;
        }

        Quaternion ned_to_vehicle_quat;
        ned_to_vehicle_quat.from_rotation_matrix(_ahrs.get_rotation_body_to_ned());

        Quaternion vehicle_to_gimbal_quat;
        vehicle_to_gimbal_quat.from_vector312(joint_angles.x,joint_angles.y,joint_angles.z);

        // calculate initial orientation
        state.quat = ned_to_vehicle_quat * vehicle_to_gimbal_quat;

        const float Sigma_velNED = 0.5f; // 1 sigma uncertainty in horizontal velocity components
        const float Sigma_dAngBias = 0.002f*dtIMU; // 1 Sigma uncertainty in delta angle bias (rad)
        const float Sigma_angErr = 0.1f; // 1 Sigma uncertainty in angular misalignment (rad)
        for (uint8_t i=0; i <= 2; i++) Cov[i][i] = sq(Sigma_angErr);
        for (uint8_t i=3; i <= 5; i++) Cov[i][i] = sq(Sigma_velNED);
        for (uint8_t i=6; i <= 8; i++) Cov[i][i] = sq(Sigma_dAngBias);
        FiltInit = true;
        DEV_PRINTF("\nSoloGimbalEKF Alignment Started\n");

        // Don't run the filter in this timestep because we have already used the delta velocity data to set an initial orientation
        return;
    }

    // We are using IMU data and joint angles from the gimbal
    gSense.gPsi = joint_angles.z; // yaw
    gSense.gPhi = joint_angles.x; // roll
    gSense.gTheta = joint_angles.y; // pitch
    cosPhi = cosf(gSense.gPhi);
    cosTheta = cosf(gSense.gTheta);
    sinPhi = sinf(gSense.gPhi);
    sinTheta = sinf(gSense.gTheta);
    sinPsi = sinf(gSense.gPsi);
    cosPsi = cosf(gSense.gPsi);
    gSense.delAng = delta_angles;
    gSense.delVel = delta_velocity;

    // predict states
    predictStates();

    // predict the covariance
    predictCovariance();

    // fuse SoloGimbalEKF velocity data
    fuseVelocity();

    
    // Align the heading once there has been enough time for the filter to settle and the tilt corrections have dropped below a threshold
    // Force it to align if too much time has lapsed
    if (((((imuSampleTime_ms - StartTime_ms) > 8000 && TiltCorrectionSquared < sq(1e-4f)) || (imuSampleTime_ms - StartTime_ms) > 30000)) && !YawAligned) {
        //calculate the initial heading using magnetometer, estimated tilt and declination
        alignHeading();
        YawAligned = true;
        DEV_PRINTF("\nSoloGimbalEKF Alignment Completed\n");
    }

    // Fuse magnetometer data if  we have new measurements and an aligned heading
    
    readMagData();
    if (newDataMag && YawAligned) {
        fuseCompass();
        newDataMag = false;
    }
    
}

// state prediction
void SoloGimbalEKF::predictStates()
{
    static Vector3f gimDelAngCorrected;
    static Vector3f gimDelAngPrev;

    // NED gravity vector m/s^2
    const Vector3f gravityNED(0, 0, GRAVITY_MSS);

    // apply corrections for bias and coning errors
    // % * - and + operators have been overloaded
    gimDelAngCorrected   = gSense.delAng - state.delAngBias - (gimDelAngPrev % gimDelAngCorrected) * 8.333333e-2f;
    gimDelAngPrev        = gSense.delAng - state.delAngBias;

    // update the quaternions by rotating from the previous attitude through
    // the delta angle rotation quaternion
    state.quat.rotate(gimDelAngCorrected);

    // normalise the quaternions and update the quaternion states
    state.quat.normalize();

    // calculate the sensor to NED cosine matrix
    state.quat.rotation_matrix(Tsn);

    // transform body delta velocities to delta velocities in the nav frame
    // * and + operators have been overloaded
    Vector3f delVelNav  = Tsn*gSense.delVel + gravityNED*dtIMU;

    // sum delta velocities to get velocity
    state.velocity += delVelNav;

    state.delAngBias.x = constrain_float(state.delAngBias.x, -GYRO_BIAS_LIMIT*dtIMU,GYRO_BIAS_LIMIT*dtIMU);
    state.delAngBias.y = constrain_float(state.delAngBias.y, -GYRO_BIAS_LIMIT*dtIMU,GYRO_BIAS_LIMIT*dtIMU);
    state.delAngBias.z = constrain_float(state.delAngBias.z, -GYRO_BIAS_LIMIT*dtIMU,GYRO_BIAS_LIMIT*dtIMU);
}

// covariance prediction using optimised algebraic toolbox expressions
// equivalent to P = F*P*transpose(P) + G*imu_errors*transpose(G) +
// gyro_bias_state_noise
void SoloGimbalEKF::predictCovariance()
{
    float delAngBiasVariance = sq(dtIMU*5E-6f);
    if (YawAligned && !hal.util->get_soft_armed()) {
        delAngBiasVariance *= 4.0f;
    }

    float daxNoise = sq(dtIMU*0.0087f);
    float dayNoise = sq(dtIMU*0.0087f);
    float dazNoise = sq(dtIMU*0.0087f);

    float dvxNoise = sq(dtIMU*0.5f);
    float dvyNoise = sq(dtIMU*0.5f);
    float dvzNoise = sq(dtIMU*0.5f);
    float dvx = gSense.delVel.x;
    float dvy = gSense.delVel.y;
    float dvz = gSense.delVel.z;
    float dax = gSense.delAng.x;
    float day = gSense.delAng.y;
    float daz = gSense.delAng.z;
    float q0 = state.quat[0];
    float q1 = state.quat[1];
    float q2 = state.quat[2];
    float q3 = state.quat[3];
    float dax_b = state.delAngBias.x;
    float day_b = state.delAngBias.y;
    float daz_b = state.delAngBias.z;
    float t1365 = dax*0.5f;
    float t1366 = dax_b*0.5f;
    float t1367 = t1365-t1366;
    float t1368 = day*0.5f;
    float t1369 = day_b*0.5f;
    float t1370 = t1368-t1369;
    float t1371 = daz*0.5f;
    float t1372 = daz_b*0.5f;
    float t1373 = t1371-t1372;
    float t1374 = q2*t1367*0.5f;
    float t1375 = q1*t1370*0.5f;
    float t1376 = q0*t1373*0.5f;
    float t1377 = q2*0.5f;
    float t1378 = q3*t1367*0.5f;
    float t1379 = q1*t1373*0.5f;
    float t1380 = q1*0.5f;
    float t1381 = q0*t1367*0.5f;
    float t1382 = q3*t1370*0.5f;
    float t1383 = q0*0.5f;
    float t1384 = q2*t1370*0.5f;
    float t1385 = q3*t1373*0.5f;
    float t1386 = q0*t1370*0.5f;
    float t1387 = q3*0.5f;
    float t1388 = q1*t1367*0.5f;
    float t1389 = q2*t1373*0.5f;
    float t1390 = t1374+t1375+t1376-t1387;
    float t1391 = t1377+t1378+t1379-t1386;
    float t1392 = q2*t1391*2.0f;
    float t1393 = t1380+t1381+t1382-t1389;
    float t1394 = q1*t1393*2.0f;
    float t1395 = t1383+t1384+t1385-t1388;
    float t1396 = q0*t1395*2.0f;
    float t1403 = q3*t1390*2.0f;
    float t1397 = t1392+t1394+t1396-t1403;
    float t1398 = sq(q0);
    float t1399 = sq(q1);
    float t1400 = sq(q2);
    float t1401 = sq(q3);
    float t1402 = t1398+t1399+t1400+t1401;
    float t1404 = t1374+t1375-t1376+t1387;
    float t1405 = t1377-t1378+t1379+t1386;
    float t1406 = q1*t1405*2.0f;
    float t1407 = -t1380+t1381+t1382+t1389;
    float t1408 = q2*t1407*2.0f;
    float t1409 = t1383-t1384+t1385+t1388;
    float t1410 = q3*t1409*2.0f;
    float t1420 = q0*t1404*2.0f;
    float t1411 = t1406+t1408+t1410-t1420;
    float t1412 = -t1377+t1378+t1379+t1386;
    float t1413 = q0*t1412*2.0f;
    float t1414 = t1374-t1375+t1376+t1387;
    float t1415 = t1383+t1384-t1385+t1388;
    float t1416 = q2*t1415*2.0f;
    float t1417 = t1380-t1381+t1382+t1389;
    float t1418 = q3*t1417*2.0f;
    float t1421 = q1*t1414*2.0f;
    float t1419 = t1413+t1416+t1418-t1421;
    float t1422 = Cov[0][0]*t1397;
    float t1423 = Cov[1][0]*t1411;
    float t1429 = Cov[6][0]*t1402;
    float t1430 = Cov[2][0]*t1419;
    float t1424 = t1422+t1423-t1429-t1430;
    float t1425 = Cov[0][1]*t1397;
    float t1426 = Cov[1][1]*t1411;
    float t1427 = Cov[0][2]*t1397;
    float t1428 = Cov[1][2]*t1411;
    float t1434 = Cov[6][1]*t1402;
    float t1435 = Cov[2][1]*t1419;
    float t1431 = t1425+t1426-t1434-t1435;
    float t1442 = Cov[6][2]*t1402;
    float t1443 = Cov[2][2]*t1419;
    float t1432 = t1427+t1428-t1442-t1443;
    float t1433 = t1398+t1399-t1400-t1401;
    float t1436 = q0*q2*2.0f;
    float t1437 = q1*q3*2.0f;
    float t1438 = t1436+t1437;
    float t1439 = q0*q3*2.0f;
    float t1441 = q1*q2*2.0f;
    float t1440 = t1439-t1441;
    float t1444 = t1398-t1399+t1400-t1401;
    float t1445 = q0*q1*2.0f;
    float t1449 = q2*q3*2.0f;
    float t1446 = t1445-t1449;
    float t1447 = t1439+t1441;
    float t1448 = t1398-t1399-t1400+t1401;
    float t1450 = t1445+t1449;
    float t1451 = t1436-t1437;
    float t1452 = Cov[0][6]*t1397;
    float t1453 = Cov[1][6]*t1411;
    float t1628 = Cov[6][6]*t1402;
    float t1454 = t1452+t1453-t1628-Cov[2][6]*t1419;
    float t1455 = Cov[0][7]*t1397;
    float t1456 = Cov[1][7]*t1411;
    float t1629 = Cov[6][7]*t1402;
    float t1457 = t1455+t1456-t1629-Cov[2][7]*t1419;
    float t1458 = Cov[0][8]*t1397;
    float t1459 = Cov[1][8]*t1411;
    float t1630 = Cov[6][8]*t1402;
    float t1460 = t1458+t1459-t1630-Cov[2][8]*t1419;
    float t1461 = q0*t1390*2.0f;
    float t1462 = q1*t1391*2.0f;
    float t1463 = q3*t1395*2.0f;
    float t1473 = q2*t1393*2.0f;
    float t1464 = t1461+t1462+t1463-t1473;
    float t1465 = q0*t1409*2.0f;
    float t1466 = q2*t1405*2.0f;
    float t1467 = q3*t1404*2.0f;
    float t1474 = q1*t1407*2.0f;
    float t1468 = t1465+t1466+t1467-t1474;
    float t1469 = q1*t1415*2.0f;
    float t1470 = q2*t1414*2.0f;
    float t1471 = q3*t1412*2.0f;
    float t1475 = q0*t1417*2.0f;
    float t1472 = t1469+t1470+t1471-t1475;
    float t1476 = Cov[7][0]*t1402;
    float t1477 = Cov[0][0]*t1464;
    float t1486 = Cov[1][0]*t1468;
    float t1487 = Cov[2][0]*t1472;
    float t1478 = t1476+t1477-t1486-t1487;
    float t1479 = Cov[7][1]*t1402;
    float t1480 = Cov[0][1]*t1464;
    float t1492 = Cov[1][1]*t1468;
    float t1493 = Cov[2][1]*t1472;
    float t1481 = t1479+t1480-t1492-t1493;
    float t1482 = Cov[7][2]*t1402;
    float t1483 = Cov[0][2]*t1464;
    float t1498 = Cov[1][2]*t1468;
    float t1499 = Cov[2][2]*t1472;
    float t1484 = t1482+t1483-t1498-t1499;
    float t1485 = sq(t1402);
    float t1488 = q1*t1390*2.0f;
    float t1489 = q2*t1395*2.0f;
    float t1490 = q3*t1393*2.0f;
    float t1533 = q0*t1391*2.0f;
    float t1491 = t1488+t1489+t1490-t1533;
    float t1494 = q0*t1407*2.0f;
    float t1495 = q1*t1409*2.0f;
    float t1496 = q2*t1404*2.0f;
    float t1534 = q3*t1405*2.0f;
    float t1497 = t1494+t1495+t1496-t1534;
    float t1500 = q0*t1415*2.0f;
    float t1501 = q1*t1417*2.0f;
    float t1502 = q3*t1414*2.0f;
    float t1535 = q2*t1412*2.0f;
    float t1503 = t1500+t1501+t1502-t1535;
    float t1504 = dvy*t1433;
    float t1505 = dvx*t1440;
    float t1506 = t1504+t1505;
    float t1507 = dvx*t1438;
    float t1508 = dvy*t1438;
    float t1509 = dvz*t1440;
    float t1510 = t1508+t1509;
    float t1511 = dvx*t1444;
    float t1551 = dvy*t1447;
    float t1512 = t1511-t1551;
    float t1513 = dvz*t1444;
    float t1514 = dvy*t1446;
    float t1515 = t1513+t1514;
    float t1516 = dvx*t1446;
    float t1517 = dvz*t1447;
    float t1518 = t1516+t1517;
    float t1519 = dvx*t1448;
    float t1520 = dvz*t1451;
    float t1521 = t1519+t1520;
    float t1522 = dvy*t1448;
    float t1552 = dvz*t1450;
    float t1523 = t1522-t1552;
    float t1524 = dvx*t1450;
    float t1525 = dvy*t1451;
    float t1526 = t1524+t1525;
    float t1527 = Cov[7][6]*t1402;
    float t1528 = Cov[0][6]*t1464;
    float t1529 = Cov[7][7]*t1402;
    float t1530 = Cov[0][7]*t1464;
    float t1531 = Cov[7][8]*t1402;
    float t1532 = Cov[0][8]*t1464;
    float t1536 = Cov[8][0]*t1402;
    float t1537 = Cov[1][0]*t1497;
    float t1545 = Cov[0][0]*t1491;
    float t1546 = Cov[2][0]*t1503;
    float t1538 = t1536+t1537-t1545-t1546;
    float t1539 = Cov[8][1]*t1402;
    float t1540 = Cov[1][1]*t1497;
    float t1547 = Cov[0][1]*t1491;
    float t1548 = Cov[2][1]*t1503;
    float t1541 = t1539+t1540-t1547-t1548;
    float t1542 = Cov[8][2]*t1402;
    float t1543 = Cov[1][2]*t1497;
    float t1549 = Cov[0][2]*t1491;
    float t1550 = Cov[2][2]*t1503;
    float t1544 = t1542+t1543-t1549-t1550;
    float t1553 = Cov[8][6]*t1402;
    float t1554 = Cov[1][6]*t1497;
    float t1555 = Cov[8][7]*t1402;
    float t1556 = Cov[1][7]*t1497;
    float t1557 = Cov[8][8]*t1402;
    float t1558 = Cov[1][8]*t1497;
    float t1560 = dvz*t1433;
    float t1559 = t1507-t1560;
    float t1561 = Cov[0][0]*t1510;
    float t1567 = Cov[2][0]*t1506;
    float t1568 = Cov[1][0]*t1559;
    float t1562 = Cov[3][0]+t1561-t1567-t1568;
    float t1563 = Cov[0][1]*t1510;
    float t1569 = Cov[2][1]*t1506;
    float t1570 = Cov[1][1]*t1559;
    float t1564 = Cov[3][1]+t1563-t1569-t1570;
    float t1565 = Cov[0][2]*t1510;
    float t1571 = Cov[2][2]*t1506;
    float t1572 = Cov[1][2]*t1559;
    float t1566 = Cov[3][2]+t1565-t1571-t1572;
    float t1573 = -t1507+t1560;
    float t1574 = Cov[1][0]*t1573;
    float t1575 = Cov[3][0]+t1561-t1567+t1574;
    float t1576 = Cov[1][1]*t1573;
    float t1577 = Cov[3][1]+t1563-t1569+t1576;
    float t1578 = Cov[1][2]*t1573;
    float t1579 = Cov[3][2]+t1565-t1571+t1578;
    float t1580 = Cov[0][6]*t1510;
    float t1581 = Cov[0][7]*t1510;
    float t1582 = Cov[0][8]*t1510;
    float t1583 = Cov[1][0]*t1518;
    float t1584 = Cov[2][0]*t1512;
    float t1592 = Cov[0][0]*t1515;
    float t1585 = Cov[4][0]+t1583+t1584-t1592;
    float t1586 = Cov[1][1]*t1518;
    float t1587 = Cov[2][1]*t1512;
    float t1593 = Cov[0][1]*t1515;
    float t1588 = Cov[4][1]+t1586+t1587-t1593;
    float t1589 = Cov[1][2]*t1518;
    float t1590 = Cov[2][2]*t1512;
    float t1594 = Cov[0][2]*t1515;
    float t1591 = Cov[4][2]+t1589+t1590-t1594;
    float t1595 = dvxNoise*t1433*t1447;
    float t1596 = Cov[1][6]*t1518;
    float t1597 = Cov[2][6]*t1512;
    float t1598 = Cov[4][6]+t1596+t1597-Cov[0][6]*t1515;
    float t1599 = Cov[1][7]*t1518;
    float t1600 = Cov[2][7]*t1512;
    float t1601 = Cov[4][7]+t1599+t1600-Cov[0][7]*t1515;
    float t1602 = Cov[1][8]*t1518;
    float t1603 = Cov[2][8]*t1512;
    float t1604 = Cov[4][8]+t1602+t1603-Cov[0][8]*t1515;
    float t1605 = Cov[2][0]*t1526;
    float t1606 = Cov[0][0]*t1523;
    float t1614 = Cov[1][0]*t1521;
    float t1607 = Cov[5][0]+t1605+t1606-t1614;
    float t1608 = Cov[2][1]*t1526;
    float t1609 = Cov[0][1]*t1523;
    float t1615 = Cov[1][1]*t1521;
    float t1610 = Cov[5][1]+t1608+t1609-t1615;
    float t1611 = Cov[2][2]*t1526;
    float t1612 = Cov[0][2]*t1523;
    float t1616 = Cov[1][2]*t1521;
    float t1613 = Cov[5][2]+t1611+t1612-t1616;
    float t1617 = dvzNoise*t1438*t1448;
    float t1618 = dvyNoise*t1444*t1450;
    float t1619 = Cov[2][6]*t1526;
    float t1620 = Cov[0][6]*t1523;
    float t1621 = Cov[5][6]+t1619+t1620-Cov[1][6]*t1521;
    float t1622 = Cov[2][7]*t1526;
    float t1623 = Cov[0][7]*t1523;
    float t1624 = Cov[5][7]+t1622+t1623-Cov[1][7]*t1521;
    float t1625 = Cov[2][8]*t1526;
    float t1626 = Cov[0][8]*t1523;
    float t1627 = Cov[5][8]+t1625+t1626-Cov[1][8]*t1521;
    float nextCov[9][9];
    nextCov[0][0] = daxNoise*t1485+t1397*t1424+t1411*t1431-t1419*t1432-t1402*t1454;
    nextCov[1][0] = -t1397*t1478-t1411*t1481+t1419*t1484+t1402*(t1527+t1528-Cov[1][6]*t1468-Cov[2][6]*t1472);
    nextCov[2][0] = -t1397*t1538-t1411*t1541+t1419*t1544+t1402*(t1553+t1554-Cov[0][6]*t1491-Cov[2][6]*t1503);
    nextCov[3][0] = -t1402*(Cov[3][6]+t1580-Cov[2][6]*t1506-Cov[1][6]*t1559)+t1397*t1562+t1411*t1564-t1419*t1566;
    nextCov[4][0] = t1397*t1585+t1411*t1588-t1402*t1598-t1419*t1591;
    nextCov[5][0] = t1397*t1607+t1411*t1610-t1402*t1621-t1419*t1613;
    nextCov[6][0] = -t1628+Cov[6][0]*t1397+Cov[6][1]*t1411-Cov[6][2]*t1419;
    nextCov[7][0] = -t1527+Cov[7][0]*t1397+Cov[7][1]*t1411-Cov[7][2]*t1419;
    nextCov[8][0] = -t1553+Cov[8][0]*t1397+Cov[8][1]*t1411-Cov[8][2]*t1419;
    nextCov[0][1] = -t1402*t1457-t1424*t1464+t1431*t1468+t1432*t1472;
    nextCov[1][1] = dayNoise*t1485+t1464*t1478-t1468*t1481-t1472*t1484+t1402*(t1529+t1530-Cov[1][7]*t1468-Cov[2][7]*t1472);
    nextCov[2][1] = t1464*t1538-t1468*t1541-t1472*t1544+t1402*(t1555+t1556-Cov[0][7]*t1491-Cov[2][7]*t1503);
    nextCov[3][1] = -t1402*(Cov[3][7]+t1581-Cov[2][7]*t1506-Cov[1][7]*t1559)-t1464*t1562+t1468*t1564+t1472*t1566;
    nextCov[4][1] = -t1402*t1601-t1464*t1585+t1468*t1588+t1472*t1591;
    nextCov[5][1] = -t1402*t1624-t1464*t1607+t1468*t1610+t1472*t1613;
    nextCov[6][1] = -t1629-Cov[6][0]*t1464+Cov[6][1]*t1468+Cov[6][2]*t1472;
    nextCov[7][1] = -t1529-Cov[7][0]*t1464+Cov[7][1]*t1468+Cov[7][2]*t1472;
    nextCov[8][1] = -t1555-Cov[8][0]*t1464+Cov[8][1]*t1468+Cov[8][2]*t1472;
    nextCov[0][2] = -t1402*t1460-t1431*t1497+t1432*t1503+t1491*(t1422+t1423-t1429-t1430);
    nextCov[1][2] = -t1478*t1491+t1481*t1497-t1484*t1503+t1402*(t1531+t1532-Cov[1][8]*t1468-Cov[2][8]*t1472);
    nextCov[2][2] = dazNoise*t1485-t1491*t1538+t1497*t1541-t1503*t1544+t1402*(t1557+t1558-Cov[0][8]*t1491-Cov[2][8]*t1503);
    nextCov[3][2] = -t1402*(Cov[3][8]+t1582-Cov[2][8]*t1506-Cov[1][8]*t1559)+t1491*t1562-t1497*t1564+t1503*t1566;
    nextCov[4][2] = -t1402*t1604+t1491*t1585-t1497*t1588+t1503*t1591;
    nextCov[5][2] = -t1402*t1627+t1491*t1607-t1497*t1610+t1503*t1613;
    nextCov[6][2] = -t1630+Cov[6][0]*t1491-Cov[6][1]*t1497+Cov[6][2]*t1503;
    nextCov[7][2] = -t1531+Cov[7][0]*t1491-Cov[7][1]*t1497+Cov[7][2]*t1503;
    nextCov[8][2] = -t1557+Cov[8][0]*t1491-Cov[8][1]*t1497+Cov[8][2]*t1503;
    nextCov[0][3] = Cov[0][3]*t1397+Cov[1][3]*t1411-Cov[2][3]*t1419-Cov[6][3]*t1402-t1432*t1506+t1510*(t1422+t1423-t1429-t1430)-t1559*(t1425+t1426-t1434-t1435);
    nextCov[1][3] = -Cov[0][3]*t1464-Cov[7][3]*t1402+Cov[1][3]*t1468+Cov[2][3]*t1472-t1478*t1510+t1484*t1506+t1481*t1559;
    nextCov[2][3] = -Cov[8][3]*t1402+Cov[0][3]*t1491-Cov[1][3]*t1497+Cov[2][3]*t1503-t1510*t1538+t1506*t1544+t1541*t1559;
    nextCov[3][3] = Cov[3][3]+Cov[0][3]*t1510-Cov[2][3]*t1506+Cov[1][3]*t1573-t1506*t1566+t1510*t1575+t1573*t1577+dvxNoise*sq(t1433)+dvyNoise*sq(t1440)+dvzNoise*sq(t1438);
    nextCov[4][3] = Cov[4][3]+t1595-Cov[0][3]*t1515+Cov[1][3]*t1518+Cov[2][3]*t1512+t1510*t1585-t1506*t1591+t1573*t1588-dvyNoise*t1440*t1444-dvzNoise*t1438*t1446;
    nextCov[5][3] = Cov[5][3]+t1617+Cov[0][3]*t1523-Cov[1][3]*t1521+Cov[2][3]*t1526+t1510*t1607-t1506*t1613+t1573*t1610-dvxNoise*t1433*t1451-dvyNoise*t1440*t1450;
    nextCov[6][3] = Cov[6][3]-Cov[6][2]*t1506+Cov[6][0]*t1510+Cov[6][1]*t1573;
    nextCov[7][3] = Cov[7][3]-Cov[7][2]*t1506+Cov[7][0]*t1510+Cov[7][1]*t1573;
    nextCov[8][3] = Cov[8][3]-Cov[8][2]*t1506+Cov[8][0]*t1510+Cov[8][1]*t1573;
    nextCov[0][4] = Cov[0][4]*t1397+Cov[1][4]*t1411-Cov[2][4]*t1419-Cov[6][4]*t1402-t1424*t1515+t1432*t1512+t1518*(t1425+t1426-t1434-t1435);
    nextCov[1][4] = -Cov[0][4]*t1464-Cov[7][4]*t1402+Cov[1][4]*t1468+Cov[2][4]*t1472+t1478*t1515-t1484*t1512-t1481*t1518;
    nextCov[2][4] = -Cov[8][4]*t1402+Cov[0][4]*t1491-Cov[1][4]*t1497+Cov[2][4]*t1503+t1515*t1538-t1512*t1544-t1518*t1541;
    nextCov[3][4] = Cov[3][4]+t1595+Cov[0][4]*t1510-Cov[2][4]*t1506+Cov[1][4]*t1573-t1515*t1575+t1512*t1579+t1518*t1577-dvyNoise*t1440*t1444-dvzNoise*t1438*t1446;
    nextCov[4][4] = Cov[4][4]-Cov[0][4]*t1515+Cov[1][4]*t1518+Cov[2][4]*t1512-t1515*t1585+t1512*t1591+t1518*t1588+dvxNoise*sq(t1447)+dvyNoise*sq(t1444)+dvzNoise*sq(t1446);
    nextCov[5][4] = Cov[5][4]+t1618+Cov[0][4]*t1523-Cov[1][4]*t1521+Cov[2][4]*t1526-t1515*t1607+t1512*t1613+t1518*t1610-dvxNoise*t1447*t1451-dvzNoise*t1446*t1448;
    nextCov[6][4] = Cov[6][4]+Cov[6][2]*t1512-Cov[6][0]*t1515+Cov[6][1]*t1518;
    nextCov[7][4] = Cov[7][4]+Cov[7][2]*t1512-Cov[7][0]*t1515+Cov[7][1]*t1518;
    nextCov[8][4] = Cov[8][4]+Cov[8][2]*t1512-Cov[8][0]*t1515+Cov[8][1]*t1518;
    nextCov[0][5] = Cov[0][5]*t1397+Cov[1][5]*t1411-Cov[2][5]*t1419-Cov[6][5]*t1402+t1424*t1523-t1431*t1521+t1526*(t1427+t1428-t1442-t1443);
    nextCov[1][5] = -Cov[0][5]*t1464-Cov[7][5]*t1402+Cov[1][5]*t1468+Cov[2][5]*t1472-t1478*t1523+t1481*t1521-t1484*t1526;
    nextCov[2][5] = -Cov[8][5]*t1402+Cov[0][5]*t1491-Cov[1][5]*t1497+Cov[2][5]*t1503-t1523*t1538+t1521*t1541-t1526*t1544;
    nextCov[3][5] = Cov[3][5]+t1617+Cov[0][5]*t1510-Cov[2][5]*t1506+Cov[1][5]*t1573-t1521*t1577+t1523*t1575+t1526*t1579-dvxNoise*t1433*t1451-dvyNoise*t1440*t1450;
    nextCov[4][5] = Cov[4][5]+t1618-Cov[0][5]*t1515+Cov[1][5]*t1518+Cov[2][5]*t1512+t1523*t1585-t1521*t1588+t1526*t1591-dvxNoise*t1447*t1451-dvzNoise*t1446*t1448;
    nextCov[5][5] = Cov[5][5]+Cov[0][5]*t1523-Cov[1][5]*t1521+Cov[2][5]*t1526+t1523*t1607-t1521*t1610+t1526*t1613+dvxNoise*sq(t1451)+dvyNoise*sq(t1450)+dvzNoise*sq(t1448);
    nextCov[6][5] = Cov[6][5]-Cov[6][1]*t1521+Cov[6][0]*t1523+Cov[6][2]*t1526;
    nextCov[7][5] = Cov[7][5]-Cov[7][1]*t1521+Cov[7][0]*t1523+Cov[7][2]*t1526;
    nextCov[8][5] = Cov[8][5]-Cov[8][1]*t1521+Cov[8][0]*t1523+Cov[8][2]*t1526;
    nextCov[0][6] = t1454;
    nextCov[1][6] = -t1527-t1528+Cov[1][6]*t1468+Cov[2][6]*t1472;
    nextCov[2][6] = -t1553-t1554+Cov[0][6]*t1491+Cov[2][6]*t1503;
    nextCov[3][6] = Cov[3][6]+t1580-Cov[2][6]*t1506+Cov[1][6]*t1573;
    nextCov[4][6] = t1598;
    nextCov[5][6] = t1621;
    nextCov[6][6] = Cov[6][6];
    nextCov[7][6] = Cov[7][6];
    nextCov[8][6] = Cov[8][6];
    nextCov[0][7] = t1457;
    nextCov[1][7] = -t1529-t1530+Cov[1][7]*t1468+Cov[2][7]*t1472;
    nextCov[2][7] = -t1555-t1556+Cov[0][7]*t1491+Cov[2][7]*t1503;
    nextCov[3][7] = Cov[3][7]+t1581-Cov[2][7]*t1506+Cov[1][7]*t1573;
    nextCov[4][7] = t1601;
    nextCov[5][7] = t1624;
    nextCov[6][7] = Cov[6][7];
    nextCov[7][7] = Cov[7][7];
    nextCov[8][7] = Cov[8][7];
    nextCov[0][8] = t1460;
    nextCov[1][8] = -t1531-t1532+Cov[1][8]*t1468+Cov[2][8]*t1472;
    nextCov[2][8] = -t1557-t1558+Cov[0][8]*t1491+Cov[2][8]*t1503;
    nextCov[3][8] = Cov[3][8]+t1582-Cov[2][8]*t1506+Cov[1][8]*t1573;
    nextCov[4][8] = t1604;
    nextCov[5][8] = t1627;
    nextCov[6][8] = Cov[6][8];
    nextCov[7][8] = Cov[7][8];
    nextCov[8][8] = Cov[8][8];

    // Add the gyro bias state noise
    for (uint8_t i=6;i<=8;i++) {
        nextCov[i][i] = nextCov[i][i] + delAngBiasVariance;
    }

    // copy predicted variances whilst constraining to be non-negative
    for (uint8_t index=0; index<=8; index++) {
        if (nextCov[index][index] < 0.0f) {
            Cov[index][index] = 0.0f;
        } else {
            Cov[index][index] = nextCov[index][index];
        }
    }

    // copy elements to covariance matrix whilst enforcing symmetry
    for (uint8_t rowIndex=1; rowIndex<=8; rowIndex++) {
        for (uint8_t colIndex=0; colIndex<=rowIndex-1; colIndex++) {
            Cov[rowIndex][colIndex] = 0.5f*(nextCov[rowIndex][colIndex] + nextCov[colIndex][rowIndex]);
            Cov[colIndex][rowIndex] = Cov[rowIndex][colIndex];
        }
    }

}

// Fuse the SoloGimbalEKF velocity estimates - this enables alevel reference to be maintained during constant turns
void SoloGimbalEKF::fuseVelocity()
{
    const auto &_ahrs = AP::ahrs();

    if (!_ahrs.have_inertial_nav()) {
        return;
    }

    float R_OBS = 0.25f;
    float innovation[3];
    float varInnov[3];
    Vector3f angErrVec;
    uint8_t stateIndex;
    float K[9];
    // Fuse measurements sequentially
    for (uint8_t obsIndex=0;obsIndex<=2;obsIndex++) {
        stateIndex = 3 + obsIndex;

        // Calculate the velocity measurement innovation using the SoloGimbalEKF estimate as the observation
        // if heading isn't aligned, use zero velocity (static assumption)
        if (YawAligned) {
            Vector3f measVelNED;
            nav_filter_status main_ekf_status;

            if (_ahrs.get_filter_status(main_ekf_status)) {
                if (main_ekf_status.flags.horiz_vel) {
                    UNUSED_RESULT(_ahrs.get_velocity_NED(measVelNED));
                }
            }

            innovation[obsIndex] = state.velocity[obsIndex] - measVelNED[obsIndex];
        } else {
            innovation[obsIndex] = state.velocity[obsIndex];
        }

        // Zero the attitude error states - they represent the incremental error so must be zero before corrections are applied
        state.angErr.zero();
        // Calculate the innovation variance
        varInnov[obsIndex] = Cov[stateIndex][stateIndex] + R_OBS;
        // Calculate the Kalman gain and correct states, taking advantage of direct state observation
        for (uint8_t rowIndex=0;rowIndex<=8;rowIndex++) {
            K[rowIndex] = Cov[rowIndex][stateIndex]/varInnov[obsIndex];
            states[rowIndex] -= K[rowIndex] * innovation[obsIndex];
        }

        // Store tilt error estimate for external monitoring
        angErrVec = angErrVec + state.angErr;

        // the first 3 states represent the angular error vector where truth = estimate + error. This is is used to correct the estimated quaternion
        // Bring the quaternion state estimate back to 'truth' by adding the error
        state.quat.rotate(state.angErr);

        // re-normalise the quaternion
        state.quat.normalize();

        // Update the covariance
        for (uint8_t rowIndex=0;rowIndex<=8;rowIndex++) {
            for (uint8_t colIndex=0;colIndex<=8;colIndex++) {
                Cov[rowIndex][colIndex] = Cov[rowIndex][colIndex] - K[rowIndex]*Cov[stateIndex][colIndex];
            }
        }

        // force symmetry and constrain diagonals to be non-negative
        fixCovariance();
    }

    // calculate tilt component of angle correction
    TiltCorrectionSquared = sq(angErrVec.x) + sq(angErrVec.y);
}

// check for new magnetometer data and update store measurements if available
void SoloGimbalEKF::readMagData()
{
    Compass &compass = AP::compass();

    if (compass.use_for_yaw() &&
        compass.last_update_usec() != lastMagUpdate) {
        // store time of last measurement update
        lastMagUpdate = compass.last_update_usec();

        // read compass data and scale to improve numerical conditioning
        magData = compass.get_field();

        // let other processes know that new compass data has arrived
        newDataMag = true;

    } else {
        newDataMag = false;
    }
}

// Fuse compass measurements from autopilot
void SoloGimbalEKF::fuseCompass()
{
    float q0 = state.quat[0];
    float q1 = state.quat[1];
    float q2 = state.quat[2];
    float q3 = state.quat[3];

    float magX = magData.x;
    float magY = magData.y;
    float magZ = magData.z;

    const float R_MAG = 3e-2f;

    // Calculate observation Jacobian
    float t5695 = sq(q0);
    float t5696 = sq(q1);
    float t5697 = sq(q2);
    float t5698 = sq(q3);
    float t5699 = t5695+t5696-t5697-t5698;
    float t5702 = q0*q2*2.0f;
    float t5703 = q1*q3*2.0f;
    float t5704 = t5702+t5703;
    float t5705 = q0*q3*2.0f;
    float t5707 = q1*q2*2.0f;
    float t5706 = t5705-t5707;
    float t5708 = cosTheta*sinPsi;
    float t5709 = sinPhi*sinTheta*cosPsi;
    float t5710 = t5708+t5709;
    float t5711 = t5705+t5707;
    float t5712 = sinTheta*sinPsi;
    float t5730 = cosTheta*sinPhi*cosPsi;
    float t5713 = t5712-t5730;
    float t5714 = q0*q1*2.0f;
    float t5720 = q2*q3*2.0f;
    float t5715 = t5714-t5720;
    float t5716 = t5695-t5696+t5697-t5698;
    float t5717 = sinTheta*cosPsi;
    float t5718 = cosTheta*sinPhi*sinPsi;
    float t5719 = t5717+t5718;
    float t5721 = cosTheta*cosPsi;
    float t5735 = sinPhi*sinTheta*sinPsi;
    float t5722 = t5721-t5735;
    float t5724 = sinPhi*t5706;
    float t5725 = cosPhi*sinTheta*t5699;
    float t5726 = cosPhi*cosTheta*t5704;
    float t5727 = t5724+t5725-t5726;
    float t5728 = magZ*t5727;
    float t5729 = t5699*t5710;
    float t5731 = t5704*t5713;
    float t5732 = cosPhi*cosPsi*t5706;
    float t5733 = t5729+t5731-t5732;
    float t5734 = magY*t5733;
    float t5736 = t5699*t5722;
    float t5737 = t5704*t5719;
    float t5738 = cosPhi*sinPsi*t5706;
    float t5739 = t5736+t5737+t5738;
    float t5740 = magX*t5739;
    float t5741 = -t5728+t5734+t5740;
    float t5742 = 1.0f/t5741;
    float t5743 = sinPhi*t5716;
    float t5744 = cosPhi*cosTheta*t5715;
    float t5745 = cosPhi*sinTheta*t5711;
    float t5746 = -t5743+t5744+t5745;
    float t5747 = magZ*t5746;
    float t5748 = t5710*t5711;
    float t5749 = t5713*t5715;
    float t5750 = cosPhi*cosPsi*t5716;
    float t5751 = t5748-t5749+t5750;
    float t5752 = magY*t5751;
    float t5753 = t5715*t5719;
    float t5754 = t5711*t5722;
    float t5755 = cosPhi*sinPsi*t5716;
    float t5756 = t5753-t5754+t5755;
    float t5757 = magX*t5756;
    float t5758 = t5747-t5752+t5757;
    float t5759 = t5742*t5758;
    float t5723 = tanf(t5759);
    float t5760 = sq(t5723);
    float t5761 = t5760+1.0f;
    float t5762 = 1.0f/sq(t5741);
    float H_MAG[3];
    H_MAG[0] = -t5761*(t5742*(magZ*(sinPhi*t5715+cosPhi*cosTheta*t5716)+magY*(t5713*t5716+cosPhi*cosPsi*t5715)+magX*(t5716*t5719-cosPhi*sinPsi*t5715))-t5758*t5762*(magZ*(sinPhi*t5704+cosPhi*cosTheta*t5706)+magY*(t5706*t5713+cosPhi*cosPsi*t5704)+magX*(t5706*t5719-cosPhi*sinPsi*t5704)));
    H_MAG[1] =  t5761*(t5742*(magZ*(cosPhi*cosTheta*t5711-cosPhi*sinTheta*t5715)+magY*(t5711*t5713+t5710*t5715)+magX*(t5711*t5719+t5715*t5722))+t5758*t5762*(magZ*(cosPhi*cosTheta*t5699+cosPhi*sinTheta*t5704)+magY*(t5699*t5713-t5704*t5710)+magX*(t5699*t5719-t5704*t5722)));
    H_MAG[2] =  t5761*(t5742*(-magZ*(sinPhi*t5711+cosPhi*sinTheta*t5716)+magY*(t5710*t5716-cosPhi*cosPsi*t5711)+magX*(t5716*t5722+cosPhi*sinPsi*t5711))-t5758*t5762*(magZ*(sinPhi*t5699-cosPhi*sinTheta*t5706)+magY*(t5706*t5710+cosPhi*t5699*cosPsi)+magX*(t5706*t5722-cosPhi*t5699*sinPsi)));

    // Calculate innovation variance and Kalman gains, taking advantage of the fact that only the first 3 elements in H are non zero
    float PH[3];
    float varInnov = R_MAG;
    for (uint8_t rowIndex=0;rowIndex<=2;rowIndex++) {
        PH[rowIndex] = 0.0f;
        for (uint8_t colIndex=0;colIndex<=2;colIndex++) {
            PH[rowIndex] += Cov[rowIndex][colIndex]*H_MAG[colIndex];
        }
        varInnov += H_MAG[rowIndex]*PH[rowIndex];
    }
    float K_MAG[9];
    float varInnovInv = 1.0f / varInnov;
    for (uint8_t rowIndex=0;rowIndex<=8;rowIndex++) {
        K_MAG[rowIndex] = 0.0f;
        for (uint8_t colIndex=0;colIndex<=2;colIndex++) {
            K_MAG[rowIndex] += Cov[rowIndex][colIndex]*H_MAG[colIndex];
        }
        K_MAG[rowIndex] *= varInnovInv;
    }

    // Calculate the innovation
    float innovation = calcMagHeadingInnov();

    // limit the innovation so that initial corrections are not too large
    if (innovation > 0.5f) {
        innovation = 0.5f;
    } else if (innovation < -0.5f) {
        innovation = -0.5f;
    }

    // correct the state vector
    state.angErr.zero();
    for (uint8_t i=0;i<=8;i++) {
        states[i] -= K_MAG[i] * innovation;
    }

    // the first 3 states represent the angular error vector where truth = estimate + error. This is is used to correct the estimated quaternion
    // Bring the quaternion state estimate back to 'truth' by adding the error
    state.quat.rotate(state.angErr);

    // re-normalise the quaternion
    state.quat.normalize();

    // correct the covariance using P = P - K*H*P taking advantage of the fact that only the first 3 elements in H are non zero
    float HP[9];
    for (uint8_t colIndex=0;colIndex<=8;colIndex++) {
        HP[colIndex] = 0.0f;
        for (uint8_t rowIndex=0;rowIndex<=2;rowIndex++) {
            HP[colIndex] += H_MAG[rowIndex]*Cov[rowIndex][colIndex];
        }
    }
    for (uint8_t rowIndex=0;rowIndex<=8;rowIndex++) {
        for (uint8_t colIndex=0;colIndex<=8;colIndex++) {
            Cov[rowIndex][colIndex] -= K_MAG[rowIndex] * HP[colIndex];
        }
    }

    // force symmetry and constrain diagonals to be non-negative
    fixCovariance();
}

// Perform an initial heading alignment using the magnetic field and assumed declination
void SoloGimbalEKF::alignHeading()
{
    // calculate the correction rotation vector in NED frame
    Vector3f deltaRotNED = Vector3f(0,0,-calcMagHeadingInnov());

    // rotate into sensor frame
    Vector3f angleCorrection = Tsn.transposed()*deltaRotNED;

    // apply the correction to the quaternion state
    // Bring the quaternion state estimate back to 'truth' by adding the error
    state.quat.rotate(angleCorrection);

    // re-normalize the quaternion
    state.quat.normalize();
}


// Calculate magnetic heading innovation
float SoloGimbalEKF::calcMagHeadingInnov()
{
    // Define rotation from magnetometer to sensor using a 312 rotation sequence
    Matrix3f Tms;
    Tms[0][0] = cosTheta*cosPsi-sinPsi*sinPhi*sinTheta;
    Tms[1][0] = -sinPsi*cosPhi;
    Tms[2][0] = cosPsi*sinTheta+cosTheta*sinPsi*sinPhi;
    Tms[0][1] = cosTheta*sinPsi+cosPsi*sinPhi*sinTheta;
    Tms[1][1] = cosPsi*cosPhi;
    Tms[2][1] = sinPsi*sinTheta-cosTheta*cosPsi*sinPhi;
    Tms[0][2] = -sinTheta*cosPhi;
    Tms[1][2] = sinPhi;
    Tms[2][2] = cosTheta*cosPhi;

    const auto &_ahrs = AP::ahrs();

    // get earth magnetic field estimate from main ekf if available to take advantage of main ekf magnetic field learning
    Vector3f earth_magfield = Vector3f(0,0,0);
    _ahrs.get_mag_field_NED(earth_magfield);

    float declination;
    if (!earth_magfield.is_zero()) {
        declination = atan2f(earth_magfield.y,earth_magfield.x);
    } else {
        declination = AP::compass().get_declination();
    }

    Vector3f body_magfield = Vector3f(0,0,0);
    _ahrs.get_mag_field_correction(body_magfield);

    // Define rotation from magnetometer to NED axes
    Matrix3f Tmn = Tsn*Tms;

    // rotate magnetic field measured at top plate into NED axes afer applying bias values learnt by main EKF
    Vector3f magMeasNED = Tmn*(magData - body_magfield);

    // calculate the innovation where the predicted measurement is the angle wrt magnetic north of the horizontal component of the measured field
    float innovation = atan2f(magMeasNED.y,magMeasNED.x) - declination;

    // wrap the innovation so it sits on the range from +-pi
    if (innovation > M_PI) {
        innovation = innovation - 2*M_PI;
    } else if (innovation < -M_PI) {
        innovation = innovation + 2*M_PI;
    }

    // Unwrap so that a large yaw gyro bias offset that causes the heading to wrap does not lead to continual uncontrolled heading drift
    if (innovation - lastInnovation > M_PI) {
        // Angle has wrapped in the positive direction to subtract an additional 2*Pi
        innovationIncrement -= 2*M_PI;
    } else if (innovation -innovationIncrement < -M_PI) {
        // Angle has wrapped in the negative direction so add an additional 2*Pi
        innovationIncrement += 2*M_PI;
    }
    lastInnovation = innovation;

    return innovation + innovationIncrement;
}

// Force symmmetry and non-negative diagonals on state covarinace matrix
void SoloGimbalEKF::fixCovariance()
{
    // force