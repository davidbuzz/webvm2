rcin9) / 2.0f + 0.5f);

    CHECK_PAYLOAD_SIZE(NAMED_VALUE_FLOAT);
    send_named_float("Lights2",
                     SRV_Channels::get_output_norm(SRV_Channel::k_rcin10) / 2.0f + 0.5f);

    CHECK_PAYLOAD_SIZE(NAMED_VALUE_FLOAT);
    send_named_float("PilotGain", sub.gain);

    CHECK_PAYLOAD_SIZE(NAMED_VALUE_FLOAT);
    send_named_float("InputHold", sub.input_hold_engaged);

    CHECK_PAYLOAD_SIZE(NAMED_VALUE_FLOAT);
    send_named_float("RollPitch", sub.roll_pitch_flag);

    CHECK_PAYLOAD_SIZE(NAMED_VALUE_FLOAT);
    send_named_float("RFTarget", sub.mode_surftrak.get_rangefinder_target_cm() / 100.0f);

    return true;
}

/*
  send PID tuning message
 */
void GCS_MAVLINK_Sub::send_pid_tuning()
{
    const Parameters &g = sub.g;
    AP_AHRS &ahrs = AP::ahrs();
    AC_AttitudeControl_Sub &attitude_control = sub.attitude_control;

    const Vector3f &gyro = ahrs.get_gyro();
    if (g.gcs_pid_mask & 1) {
        const AP_PIDInfo &pid_info = attitude_control.get_rate_roll_pid().get_pid_info();
        mavlink_msg_pid_tuning_send(chan, PID_TUNING_ROLL,
                                    pid_info.target*0.01f,
                                    degrees(gyro.x),
                                    pid_info.FF*0.01f,
                                    pid_info.P*0.01f,
                                    pid_info.I*0.01f,
                                    pid_info.D*0.01f,
                                    pid_info.slew_rate,
                                    pid_info.Dmod);
        if (!HAVE_PAYLOAD_SPACE(chan, PID_TUNING)) {
            return;
        }
    }
    if (g.gcs_pid_mask & 2) {
        const AP_PIDInfo &pid_info = attitude_control.get_rate_pitch_pid().get_pid_info();
        mavlink_msg_pid_tuning_send(chan, PID_TUNING_PITCH,
                                    pid_info.target*0.01f,
                                    degrees(gyro.y),
                                    pid_info.FF*0.01f,
                                    pid_info.P*0.01f,
                                    pid_info.I*0.01f,
                                    pid_info.D*0.01f,
                                    pid_info.slew_rate,
                                    pid_info.Dmod);
        if (!HAVE_PAYLOAD_SPACE(chan, PID_TUNING)) {
            return;
        }
    }
    if (g.gcs_pid_mask & 4) {
        const AP_PIDInfo &pid_info = attitude_control.get_rate_yaw_pid().get_pid_info();
        mavlink_msg_pid_tuning_send(chan, PID_TUNING_YAW,
                                    pid_info.target*0.01f,
                                    degrees(gyro.z),
                                    pid_info.FF*0.01f,
                                    pid_info.P*0.01f,
                                    pid_info.I*0.01f,
                                    pid_info.D*0.01f,
                                    pid_info.slew_rate,
                                    pid_info.Dmod);
        if (!HAVE_PAYLOAD_SPACE(chan, PID_TUNING)) {
            return;
        }
    }
    if (g.gcs_pid_mask & 8) {
        const AP_PIDInfo &pid_info = sub.pos_control.get_accel_z_pid().get_pid_info();
        mavlink_msg_pid_tuning_send(chan, PID_TUNING_ACCZ,
                                    pid_info.target*0.01f,
                                    -(ahrs.get_accel_ef().z + GRAVITY_MSS),
                                    pid_info.FF*0.01f,
                                    pid_info.P*0.01f,
                                    pid_info.I*0.01f,
                                    pid_info.D*0.01f,
                                    pid_info.slew_rate,
                                    pid_info.Dmod);
        if (!HAVE_PAYLOAD_SPACE(chan, PID_TUNING)) {
            return;
        }
    }
}

uint8_t GCS_MAVLINK_Sub::sysid_my_gcs() const
{
    return sub.g.sysid_my_gcs;
}

bool GCS_Sub::vehicle_initialised() const {
    return sub.ap.initialised;
}

// try to send a message, return false if it won't fit in the serial tx buffer
bool GCS_MAVLINK_Sub::try_send_message(enum ap_message id)
{
    switch (id) {

    case MSG_NAMED_FLOAT:
        send_info();
        break;

    case MSG_TERRAIN:
#if AP_TERRAIN_AVAILABLE
        CHECK_PAYLOAD_SIZE(TERRAIN_REQUEST);
        sub.terrain.send_request(chan);
#endif
        break;

    default:
        return GCS_MAVLINK::try_send_message(id);
    }

    return true;
}


const AP_Param::GroupInfo GCS_MAVLINK_Parameters::var_info[] = {
    // @Param: RAW_SENS
    // @DisplayName: Raw sensor stream rate
    // @Description: Stream rate of RAW_IMU, SCALED_IMU2, SCALED_PRESSURE, and SENSOR_OFFSETS to ground station
    // @Units: Hz
    // @Range: 0 50
    // @Increment: 1
    // @RebootRequired: True
    // @User: Advanced
    AP_GROUPINFO("RAW_SENS", 0, GCS_MAVLINK_Parameters, streamRates[GCS_MAVLINK::STREAM_RAW_SENSORS],  2),

    // @Param: EXT_STAT
    // @DisplayName: Extended status stream rate to ground station
    // @Description: Stream rate of SYS_STATUS, MEMINFO, MISSION_CURRENT, GPS_RAW_INT, NAV_CONTROLLER_OUTPUT, and LIMITS_STATUS to ground station
    // @Units: Hz
    // @Range: 0 50
    // @Increment: 1
    // @RebootRequired: True
    // @User: Advanced
    AP_GROUPINFO("EXT_STAT", 1, GCS_MAVLINK_Parameters, streamRates[GCS_MAVLINK::STREAM_EXTENDED_STATUS],  2),

    // @Param: RC_CHAN
    // @DisplayName: RC Channel stream rate to ground station
    // @Description: Stream rate of SERVO_OUTPUT_RAW and RC_CHANNELS_RAW to ground station
    // @Units: Hz
    // @Range: 0 50
    // @Increment: 1
    // @RebootRequired: True
    // @User: Advanced
    AP_GROUPINFO("RC_CHAN",  2, GCS_MAVLINK_Parameters, streamRates[GCS_MAVLINK::STREAM_RC_CHANNELS],  2),

    // @Param: POSITION
    // @DisplayName: Position stream rate to ground station
    // @Description: Stream rate of GLOBAL_POSITION_INT to ground station
    // @Units: Hz
    // @Range: 0 50
    // @Increment: 1
    // @RebootRequired: True
    // @User: Advanced
    AP_GROUPINFO("POSITION", 4, GCS_MAVLINK_Parameters, streamRates[GCS_MAVLINK::STREAM_POSITION],  3),

    // @Param: EXTRA1
    // @DisplayName: Extra data type 1 stream rate to ground station
    // @Description: Stream rate of ATTITUDE and SIMSTATE (SITL only) to ground station
    // @Units: Hz
    // @Range: 0 50
    // @Increment: 1
    // @RebootRequired: True
    // @User: Advanced
    AP_GROUPINFO("EXTRA1",   5, GCS_MAVLINK_Parameters, streamRates[GCS_MAVLINK::STREAM_EXTRA1],  10),

    // @Param: EXTRA2
    // @DisplayName: Extra data type 2 stream rate to ground station
    // @Description: Stream rate of VFR_HUD to ground station
    // @Units: Hz
    // @Range: 0 50
    // @Increment: 1
    // @RebootRequired: True
    // @User: Advanced
    AP_GROUPINFO("EXTRA2",   6, GCS_MAVLINK_Parameters, streamRates[GCS_MAVLINK::STREAM_EXTRA2],  10),

    // @Param: EXTRA3
    // @DisplayName: Extra data type 3 stream rate to ground station
    // @Description: Stream rate of AHRS and SYSTEM_TIME to ground station
    // @Units: Hz
    // @Range: 0 50
    // @Increment: 1
    // @RebootRequired: True
    // @User: Advanced
    AP_GROUPINFO("EXTRA3",   7, GCS_MAVLINK_Parameters, streamRates[GCS_MAVLINK::STREAM_EXTRA3],  3),

    // @Param: PARAMS
    // @DisplayName: Parameter stream rate to ground station
    // @Description: Stream rate of PARAM_VALUE to ground station
    // @Units: Hz
    // @Range: 0 50
    // @Increment: 1
    // @RebootRequired: True
    // @User: Advanced
    AP_GROUPINFO("PARAMS",   8, GCS_MAVLINK_Parameters, streamRates[GCS_MAVLINK::STREAM_PARAMS],  0),
    AP_GROUPEND
};

static const ap_message STREAM_RAW_SENSORS_msgs[] = {
    MSG_RAW_IMU,
    MSG_SCALED_IMU2,
    MSG_SCALED_IMU3,
    MSG_SCALED_PRESSURE,
    MSG_SCALED_PRESSURE2,
    MSG_SCALED_PRESSURE3,
};
static const ap_message STREAM_EXTENDED_STATUS_msgs[] = {
    MSG_SYS_STATUS,
    MSG_POWER_STATUS,
#if HAL_WITH_MCU_MONITORING
    MSG_MCU_STATUS,
#endif
    MSG_MEMINFO,
    MSG_CURRENT_WAYPOINT,
    MSG_GPS_RAW,
    MSG_GPS_RTK,
#if GPS_MAX_RECEIVERS > 1
    MSG_GPS2_RAW,
    MSG_GPS2_RTK,
#endif
    MSG_NAV_CONTROLLER_OUTPUT,
#if AP_FENCE_ENABLED
    MSG_FENCE_STATUS,
#endif
    MSG_NAMED_FLOAT
};
static const ap_message STREAM_POSITION_msgs[] = {
    MSG_LOCATION,
    MSG_LOCAL_POSITION
};
static const ap_message STREAM_RC_CHANNELS_msgs[] = {
    MSG_SERVO_OUTPUT_RAW,
    MSG_RC_CHANNELS,
#if AP_MAVLINK_MSG_RC_CHANNELS_RAW_ENABLED
    MSG_RC_CHANNELS_RAW, // only sent on a mavlink1 connection
#endif
};
static const ap_message STREAM_EXTRA1_msgs[] = {
    MSG_ATTITUDE,
#if AP_SIM_ENABLED
    MSG_SIMSTATE,
#endif
    MSG_AHRS2,
    MSG_PID_TUNING
};
static const ap_message STREAM_EXTRA2_msgs[] = {
    MSG_VFR_HUD
};
static const ap_message STREAM_EXTRA3_msgs[] = {
    MSG_AHRS,
    MSG_SYSTEM_TIME,
#if AP_RANGEFINDER_ENABLED
    MSG_RANGEFINDER,
#endif
    MSG_DISTANCE_SENSOR,
#if AP_TERRAIN_AVAILABLE
    MSG_TERRAIN,
#endif
#if AP_BATTERY_ENABLED
    MSG_BATTERY_STATUS,
#endif
#if HAL_MOUNT_ENABLED
    MSG_GIMBAL_DEVICE_ATTITUDE_STATUS,
#endif
#if AP_OPTICALFLOW_ENABLED
    MSG_OPTICAL_FLOW,
#endif
#if COMPASS_CAL_ENABLED
    MSG_MAG_CAL_REPORT,
    MSG_MAG_CAL_PROGRESS,
#endif
    MSG_EKF_STATUS_REPORT,
    MSG_VIBRATION,
#if AP_RPM_ENABLED
    MSG_RPM,
#endif
#if HAL_WITH_ESC_TELEM
    MSG_ESC_TELEMETRY,
#endif
};
static const ap_message STREAM_PARAMS_msgs[] = {
    MSG_NEXT_PARAM
};

const struct GCS_MAVLINK::stream_entries GCS_MAVLINK::all_stream_entries[] = {
    MAV_STREAM_ENTRY(STREAM_RAW_SENSORS),
    MAV_STREAM_ENTRY(STREAM_EXTENDED_STATUS),
    MAV_STREAM_ENTRY(STREAM_POSITION),
    MAV_STREAM_ENTRY(STREAM_RC_CHANNELS),
    MAV_STREAM_ENTRY(STREAM_EXTRA1),
    MAV_STREAM_ENTRY(STREAM_EXTRA2),
    MAV_STREAM_ENTRY(STREAM_EXTRA3),
    MAV_STREAM_ENTRY(STREAM_PARAMS),
    MAV_STREAM_TERMINATOR // must have this at end of stream_entries
};

bool GCS_MAVLINK_Sub::handle_guided_request(AP_Mission::Mission_Command &cmd)
{
    return sub.do_guided(cmd);
}

MAV_RESULT GCS_MAVLINK_Sub::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg)
{
    if (sub.motors.armed()) {
        gcs().send_text(MAV_SEVERITY_INFO, "Disarm before calibration.");
        return MAV_RESULT_FAILED;
    }

    if (!sub.control_check_barometer()) {
        return MAV_RESULT_FAILED;
    }

    AP::baro().calibrate(true);
    return MAV_RESULT_ACCEPTED;
}

MAV_RESULT GCS_MAVLINK_Sub::_handle_command_preflight_calibration(const mavlink_command_int_t &packet, const mavlink_message_t &msg)
{
    if (packet.y == 1) {
        // compassmot calibration
        //result = sub.mavlink_compassmot(chan);
        gcs().send_text(MAV_SEVERITY_INFO, "#CompassMot calibration not supported");
        return MAV_RESULT_UNSUPPORTED;
    }

    return GCS_MAVLINK::_handle_command_preflight_calibration(packet, msg);
}

MAV_RESULT GCS_MAVLINK_Sub::handle_command_do_set_roi(const Location &roi_loc)
{
    if (!roi_loc.check_latlng()) {
        return MAV_RESULT_FAILED;
    }
    sub.mode_auto.set_auto_yaw_roi(roi_loc);
    return MAV_RESULT_ACCEPTED;
}

MAV_RESULT GCS_MAVLINK_Sub::handle_command_int_do_reposition(const mavlink_command_int_t &packet)
{
    const bool change_modes = ((int32_t)packet.param2 & MAV_DO_REPOSITION_FLAGS_CHANGE_MODE) == MAV_DO_REPOSITION_FLAGS_CHANGE_MODE;
    if (!sub.flightmode->in_guided_mode() && !change_modes) {
        return MAV_RESULT_DENIED;
    }

    // sanity check location
    if (!check_latlng(packet.x, packet.y)) {
        return MAV_RESULT_DENIED;
    }

    Location request_location;
    if (!location_from_command_t(packet, request_location)) {
        return MAV_RESULT_DENIED;
    }

    if (request_location.sanitize(sub.current_loc)) {
        // if the location wasn't already sane don't load it
        return MAV_RESULT_DENIED; // failed as the location is not valid
    }

    // we need to do this first, as we don't want to change the flight mode unless we can also set the target
    if (!sub.mode_guided.guided_set_destination(request_location)) {
        return MAV_RESULT_FAILED;
    }

    if (!sub.flightmode->in_guided_mode()) {
        if (!sub.set_mode(Mode::Number::GUIDED, ModeReason::GCS_COMMAND)) {
            return MAV_RESULT_FAILED;
        }
        // the position won't have been loaded if we had to change the flight mode, so load it again
        if (!sub.mode_guided.guided_set_destination(request_location)) {
            return MAV_RESULT_FAILED;
        }
    }

    return MAV_RESULT_ACCEPTED;
}

MAV_RESULT GCS_MAVLINK_Sub::handle_command_int_packet(const mavlink_command_int_t &packet, const mavlink_message_t &msg)
{
    switch(packet.command) {

    case MAV_CMD_CONDITION_YAW:
        return handle_MAV_CMD_CONDITION_YAW(packet);

    case MAV_CMD_DO_CHANGE_SPEED:
        return handle_MAV_CMD_DO_CHANGE_SPEED(packet);

    case MAV_CMD_DO_MOTOR_TEST:
        return handle_MAV_CMD_DO_MOTOR_TEST(packet);

    case MAV_CMD_DO_REPOSITION:
        return handle_command_int_do_reposition(packet);

    case MAV_CMD_MISSION_START:
        if (!is_zero(packet.param1) || !is_zero(packet.param2)) {
            // first-item/last item not supported
            return MAV_RESULT_DENIED;
        }
        return handle_MAV_CMD_MISSION_START(packet);

    case MAV_CMD_NAV_LOITER_UNLIM:
        return handle_MAV_CMD_NAV_LOITER_UNLIM(packet);

    case MAV_CMD_NAV_LAND:
        return handle_MAV_CMD_NAV_LAND(packet);

    }

    return GCS_MAVLINK::handle_command_int_packet(packet, msg);
}

MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_NAV_LOITER_UNLIM(const mavlink_command_int_t &packet)
{
        if (!sub.set_mode(Mode::Number::POSHOLD, ModeReason::GCS_COMMAND)) {
            return MAV_RESULT_FAILED;
        }
        return MAV_RESULT_ACCEPTED;
}

MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_NAV_LAND(const mavlink_command_int_t &packet)
{
        if (!sub.set_mode(Mode::Number::SURFACE, ModeReason::GCS_COMMAND)) {
            return MAV_RESULT_FAILED;
        }
        return MAV_RESULT_ACCEPTED;
}

MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_CONDITION_YAW(const mavlink_command_int_t &packet)
{
        // param1 : target angle [0-360]
        // param2 : speed during change [deg per second]
        // param3 : direction (-1:ccw, +1:cw)
        // param4 : relative offset (1) or absolute angle (0)
        if ((packet.param1 >= 0.0f)   &&
            (packet.param1 <= 360.0f) &&
            (is_zero(packet.param4) || is_equal(packet.param4,1.0f))) {
            sub.mode_auto.set_auto_yaw_look_at_heading(packet.param1, packet.param2, (int8_t)packet.param3, (uint8_t)packet.param4);
            return MAV_RESULT_ACCEPTED;
        }
        return MAV_RESULT_DENIED;
}

MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_DO_CHANGE_SPEED(const mavlink_command_int_t &packet)
{
        // param1 : unused
        // param2 : new speed in m/s
        // param3 : unused
        // param4 : unused
        if (packet.param2 > 0.0f) {
            sub.wp_nav.set_speed_xy(packet.param2 * 100.0f);
            return MAV_RESULT_ACCEPTED;
        }
        return MAV_RESULT_FAILED;
}

MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_MISSION_START(const mavlink_command_int_t &packet)
{
        if (sub.motors.armed() && sub.set_mode(Mode::Number::AUTO, ModeReason::GCS_COMMAND)) {
            return MAV_RESULT_ACCEPTED;
        }
        return MAV_RESULT_FAILED;
}

MAV_RESULT GCS_MAVLINK_Sub::handle_MAV_CMD_DO_MOTOR_TEST(const mavlink_command_int_t &packet)
{
        // param1 : motor sequence number (a number from 1 to max number of motors on the vehicle)
        // param2 : throttle type (0=throttle percentage, 1=PWM, 2=pilot throttle channel pass-through. See MOTOR_TEST_THROTTLE_TYPE enum)
        // param3 : throttle (range depends upon param2)
        // param4 : timeout (in seconds)
        if (!sub.handle_do_motor_test(packet)) {
            return MAV_RESULT_FAILED;
        }
        return MAV_RESULT_ACCEPTED;
}

void GCS_MAVLINK_Sub::handle_message(const mavlink_message_t &msg)
{
    switch (msg.msgid) {

    case MAVLINK_MSG_ID_MANUAL_CONTROL: {     // MAV ID: 69
        if (msg.sysid != sub.g.sysid_my_gcs) {
            break;    // Only accept control from our gcs
        }
        mavlink_manual_control_t packet;
        mavlink_msg_manual_control_decode(&msg, &packet);

        if (packet.target != sub.g.sysid_this_mav) {
            break; // only accept control aimed at us
        }

        sub.transform_manual_control_to_rc_override(
            packet.x,
            packet.y,
            packet.z,
            packet.r,
            packet.buttons,
            packet.buttons2,
            packet.enabled_extensions,
            packet.s,
            packet.t,
            packet.aux1,
            packet.aux2,
            packet.aux3,
            packet.aux4,
            packet.aux5,
            packet.aux6
        );

        sub.failsafe.last_pilot_input_ms = AP_HAL::millis();
        // a RC override message is considered to be a 'heartbeat'
        // from the ground station for failsafe purposes
        gcs().sysid_myggcs_seen(AP_HAL::millis());
        break;
    }

    case MAVLINK_MSG_ID_RC_CHANNELS_OVERRIDE: {     // MAV ID: 70
        if (msg.sysid != sub.g.sysid_my_gcs) {
            break;    // Only accept control from our gcs
        }

        sub.failsafe.last_pilot_input_ms = AP_HAL::millis();
        // a RC override message is considered to be a 'heartbeat'
        // from the ground station for failsafe purposes
        
        handle_rc_channels_override(msg);
        break;
    }

    
    case MAVLINK_MSG_ID_SET_ATTITUDE_TARGET: { // MAV ID: 82
        // decode packet
        mavlink_set_attitude_target_t packet;
        mavlink_msg_set_attitude_target_decode(&msg, &packet);

        // ensure type_mask specifies to use attitude
        // the thrust can be used from the altitude hold
        if (packet.type_mask & (1<<6)) {
            sub.set_attitude_target_no_gps = {AP_HAL::millis(), packet};
        }

        // ensure type_mask specifies to use attitude and thrust
        if ((packet.type_mask & ((1<<7)|(1<<6))) != 0) {
            break;
        }

        // convert thrust to climb rate
        packet.thrust = constrain_float(packet.thrust, 0.0f, 1.0f);
        float climb_rate_cms = 0.0f;
        if (is_equal(packet.thrust, 0.5f)) {
            climb_rate_cms = 0.0f;
        } else if (packet.thrust > 0.5f) {
            // climb at up to WPNAV_SPEED_UP
            climb_rate_cms = (packet.thrust - 0.5f) * 2.0f * sub.wp_nav.get_default_speed_up();
        } else {
            // descend at up to WPNAV_SPEED_DN
            climb_rate_cms = (packet.thrust - 0.5f) * 2.0f * sub.wp_nav.get_default_speed_down();
        }
        sub.mode_guided.guided_set_angle(Quaternion(packet.q[0],packet.q[1],packet.q[2],packet.q[3]), climb_rate_cms);
        break;
    }

    case MAVLINK_MSG_ID_SET_POSITION_TARGET_LOCAL_NED: {   // MAV ID: 84
        // decode packet
        mavlink_set_position_target_local_ned_t packet;
        mavlink_msg_set_position_target_local_ned_decode(&msg, &packet);

        // exit if vehicle is not in Guided mode or Auto-Guided mode
        if ((sub.control_mode != Mode::Number::GUIDED) && !(sub.control_mode == Mode::Number::AUTO && sub.auto_mode == Auto_NavGuided)) {
            break;
        }

        // check for supported coordinate frames
        if (packet.coordinate_frame != MAV_FRAME_LOCAL_NED &&
                packet.coordinate_frame != MAV_FRAME_LOCAL_OFFSET_NED &&
                packet.coordinate_frame != MAV_FRAME_BODY_NED &&
                packet.coordinate_frame != MAV_FRAME_BODY_OFFSET_NED &&
                packet.coordinate_frame != MAV_FRAME_BODY_FRD) {
            break;
        }

        bool pos_ignore      = packet.type_mask & MAVLINK_SET_POS_TYPE_MASK_POS_IGNORE;
        bool vel_ignore      = packet.type_mask & MAVLINK_SET_POS_TYPE_MASK_VEL_IGNORE;
        bool acc_ignore      = packet.type_mask & MAVLINK_SET_POS_TYPE_MASK_ACC_IGNORE;
        bool yaw_ignore      = packet.type_mask & MAVLINK_SET_POS_TYPE_MASK_YAW_IGNORE;
        bool yaw_rate_ignore = packet.type_mask & MAVLINK_SET_POS_TYPE_MASK_YAW_RATE_IGNORE;

        // prepare position
        Vector3f pos_vector;
        if (!pos_ignore) {
            // convert to cm
            pos_vector = Vector3f(packet.x * 100.0f, packet.y * 100.0f, -packet.z * 100.0f);
            // rotate from body-frame if necessary
            if (packet.coordinate_frame == MAV_FRAME_BODY_NED ||
                    packet.coordinate_frame == MAV_FRAME_BODY_FRD ||
                    packet.coordinate_frame == MAV_FRAME_BODY_OFFSET_NED) {
                sub.rotate_body_frame_to_NE(pos_vector.x, pos_vector.y);
            }
            // add body offset if necessary
            if (packet.coordinate_frame == MAV_FRAME_LOCAL_OFFSET_NED ||
                    packet.coordinate_frame == MAV_FRAME_BODY_NED ||
                    packet.coordinate_frame == MAV_FRAME_BODY_FRD ||
                    packet.coordinate_frame == MAV_FRAME_BODY_OFFSET_NED) {
                pos_vector += sub.inertial_nav.get_position_neu_cm();
            }
        }

        // prepare velocity
        Vector3f vel_vector;
        if (!vel_ignore) {
            // convert to cm
            vel_vector = Vector3f(packet.vx * 100.0f, packet.vy * 100.0f, -packet.vz * 100.0f);
            // rotate from body-frame if necessary
            if (packet.coordinate_frame == MAV_FRAME_BODY_NED || packet.coordinate_frame == MAV_FRAME_BODY_FRD || packet.coordinate_frame == MAV_FRAME_BODY_OFFSET_NED) {
                sub.rotate_body_frame_to_NE(vel_vector.x, vel_vector.y);
            }
        }

        // prepare yaw
        float yaw_cd =  0.0f;
        bool yaw_relative = false;
        float yaw_rate_cds = 0.0f;
        if (!yaw_ignore) {
            yaw_cd = ToDeg(packet.yaw) * 100.0f;
            yaw_relative = packet.coordinate_frame == MAV_FRAME_BODY_OFFSET_NED;
        }
        if (!yaw_rate_ignore) {
            yaw_rate_cds = ToDeg(packet.yaw_rate) * 100.0f;
        }

        // send request
        if (!pos_ignore && !vel_ignore && acc_ignore) {
            sub.mode_guided.guided_set_destination_posvel(pos_vector, vel_vector, !yaw_ignore, yaw_cd, !yaw_rate_ignore, yaw_rate_cds, yaw_relative);
        } else if (pos_ignore && !vel_ignore && acc_ignore) {
            sub.mode_guided.guided_set_velocity(vel_vector, !yaw_ignore, yaw_cd, !yaw_rate_ignore, yaw_rate_cds, yaw_relative);
        } else if (!pos_ignore && vel_ignore && acc_ignore) {
            sub.mode_guided.guided_set_destination(pos_vector, !yaw_ignore, yaw_cd, !yaw_rate_ignore, yaw_rate_cds, yaw_relative);
        }

        break;
    }

    case MAVLINK_MSG_ID_SET_POSITION_TARGET_GLOBAL_INT: {  // MAV ID: 86
        // decode packet
        mavlink_set_position_target_global_int_t packet;
        mavlink_msg_set_position_target_global_int_decode(&msg, &packet);

        // exit if vehicle is not in Guided, Auto-Guided, or Depth Hold modes
        if ((sub.control_mode != Mode::Number::GUIDED)
            && !(sub.control_mode == Mode::Number::AUTO && sub.auto_mode == Auto_NavGuided)
            && !(sub.control_mode == Mode::Number::ALT_HOLD)) {
            break;
        }

        bool z_ignore        = packet.type_mask & MAVLINK_SET_POS_TYPE_MASK_Z_IGNORE;
        bool pos_ignore      = packet.type_mask & MAVLINK_SET_POS_TYPE_MASK_POS_IGNORE;
        bool vel_ignore      = packet.type_mask & MAVLINK_SET_POS_TYPE_MASK_VEL_IGNORE;
        bool acc_ignore      = packet.type_mask & MAVLINK_SET_POS_TYPE_MASK_ACC_IGNORE;

        /*
         * for future use:
         * bool force           = packet.type_mask & MAVLINK_SET_POS_TYPE_MASK_FORCE;
         * bool yaw_ignore      = packet.type_mask & MAVLINK_SET_POS_TYPE_MASK_YAW_IGNORE;
         * bool yaw_rate_ignore = packet.type_mask & MAVLINK_SET_POS_TYPE_MASK_YAW_RATE_IGNORE;
         */

        if (!z_ignore && sub.control_mode == Mode::Number::ALT_HOLD) { // Control only target depth when in ALT_HOLD
            sub.pos_control.set_pos_target_z_cm(packet.alt*100);
            break;
        }

        Vector3f pos_neu_cm;  // position (North, East, Up coordinates) in centimeters

        if (!pos_ignore) {
            // sanity check location
            if (!check_latlng(packet.lat_int, packet.lon_int)) {
                break;
            }
            Location::AltFrame frame;
            if (!mavlink_coordinate_frame_to_location_alt_frame((MAV_FRAME)packet.coordinate_frame, frame)) {
                // unknown coordinate frame
                break;
            }
            const Location loc{
                packet.lat_int,
                packet.lon_int,
                int32_t(packet.alt*100),
                frame,
            };
            if (!loc.get_vector_from_origin_NEU(pos_neu_cm)) {
                break;
            }
        }

        if (!pos_ignore && !vel_ignore && acc_ignore) {
            sub.mode_guided.guided_set_destination_posvel(pos_neu_cm, Vector3f(packet.vx * 100.0f, packet.vy * 100.0f, -packet.vz * 100.0f));
        } else if (pos_ignore && !vel_ignore && acc_ignore) {
            sub.mode_guided.guided_set_velocity(Vector3f(packet.vx * 100.0f, packet.vy * 100.0f, -packet.vz * 100.0f));
        } else if (!pos_ignore && vel_ignore && acc_ignore) {
            sub.mode_guided.guided_set_destination(pos_neu_cm);
        }

        break;
    }

    case MAVLINK_MSG_ID_TERRAIN_DATA:
    case MAVLINK_MSG_ID_TERRAIN_CHECK:
#if AP_TERRAIN_AVAILABLE
        sub.terrain.handle_data(chan, msg);
#endif
        break;

    // This adds support for leak detectors in a separate enclosure
    // connected to a mavlink enabled subsystem
    case MAVLINK_MSG_ID_SYS_STATUS: {
        uint32_t MAV_SENSOR_WATER = 0x20000000;
        mavlink_sys_status_t packet;
        mavlink_msg_sys_status_decode(&msg, &packet);
        if ((packet.onboard_control_sensors_enabled & MAV_SENSOR_WATER) && !(packet.onboard_control_sensors_health & MAV_SENSOR_WATER)) {
            sub.leak_detector.set_detect();
        }
    }
        break;

    default:
        GCS_MAVLINK::handle_message(msg);
        break;
    }     // end switch
} // end handle mavlink

uint64_t GCS_MAVLINK_Sub::capabilities() const
{
    return (MAV_PROTOCOL_CAPABILITY_MISSION_FLOAT |
            MAV_PROTOCOL_CAPABILITY_MISSION_INT |
            MAV_PROTOCOL_CAPABILITY_SET_POSITION_TARGET_LOCAL_NED |
            MAV_PROTOCOL_CAPABILITY_SET_POSITION_TARGET_GLOBAL_INT |
            MAV_PROTOCOL_CAPABILITY_FLIGHT_TERMINATION |
#if AP_TERRAIN_AVAILABLE
            (sub.terrain.enabled() ? MAV_PROTOCOL_CAPABILITY_TERRAIN : 0) |
#endif
            MAV_PROTOCOL_CAPABILITY_SET_ATTITUDE_TARGET |
            GCS_MAVLINK::capabilities()
        );
}

MAV_RESULT GCS_MAVLINK_Sub::handle_flight_termination(const mavlink_command_int_t &packet)
{
    if (packet.param1 > 0.5f) {
        sub.arming.disarm(AP_Arming::Method::TERMINATION);
        return MAV_RESULT_ACCEPTED;
    }
    return MAV_RESULT_FAILED;
}

int32_t GCS_MAVLINK_Sub::global_position_int_alt() const
{
    return static_cast<int32_t>(sub.get_alt_msl() * 1000.0f);
}

int32_t GCS_MAVLINK_Sub::global_position_int_relative_alt() const
{
    return static_cast<int32_t>(sub.get_alt_rel() * 1000.0f);
}

#if HAL_HIGH_LATENCY2_ENABLED
int16_t GCS_MAVLINK_Sub::high_latency_target_altitude() const
{
    AP_AHRS &ahrs = AP::ahrs();
    Location global_position_current;
    UNUSED_RESULT(ahrs.get_location(global_position_current));

    //return units are m
    if (sub.control_mode == Mode::Number::AUTO || sub.control_mode == Mode::Number::GUIDED) {
        return 0.01 * (global_position_current.alt + sub.pos_control.get_pos_error_z_cm());
    }
    return 0;
    
}

uint8_t GCS_MAVLINK_Sub::high_latency_tgt_heading() const
{
    // return units are deg/2
    if (sub.control_mode == Mode::Number::AUTO || sub.control_mode == Mode::Number::GUIDED) {
        // need to convert -18000->18000 to 0->360/2
        return wrap_360_cd(sub.wp_nav.get_wp_bearing_to_destination()) / 200;
    }
    return 0;      
}
    
uint16_t GCS_MAVLINK_Sub::high_latency_tgt_dist() const
{
    // return units are dm
    if (sub.control_mode == Mode::Number::AUTO || sub.control_mode == Mode::Number::GUIDED) {
        return MIN(sub.wp_nav.get_wp_distance_to_destination() * 0.001, UINT16_MAX);
    }
    return 0;
}

uint8_t GCS_MAVLINK_Sub::high_latency_tgt_airspeed() const
{
    // return units are m/s*5
    if (sub.control_mode == Mode::Number::AUTO || sub.control_mode == Mode::Number::GUIDED) {
        return MIN((sub.pos_control.get_vel_desired_cms().length()/100) * 5, UINT8_MAX);
    }
    return 0;
}
#endif // HAL_HIGH_LATENCY2_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    t_default_function(CH_3, SRV_Channel::k_throttle);

    if (is_balancebot()) {
        g2.crash_angle.set_default(30);
    }

    SRV_Channels::upgrade_parameters();

    // convert CH7_OPTION to RC7_OPTION for Rover-3.4 to 3.5 upgrade
    const AP_Param::ConversionInfo ch7_option_info = { Parameters::k_param_ch7_option, 0, AP_PARAM_INT8, "RC7_OPTION" };
    AP_Int8 ch7_opt_old;
    if (AP_Param::find_old_parameter(&ch7_option_info, &ch7_opt_old)) {
        const uint8_t ch7_opt_map[] = {0,7,50,41,51,52,53,54,16,4,42,55,56};
        const uint8_t ch7_opt_old_val = (uint8_t)ch7_opt_old.get();
        if (ch7_opt_old_val < ARRAY_SIZE(ch7_opt_map)) {
            AP_Param::set_default_by_name(ch7_option_info.new_name, ch7_opt_map[ch7_opt_old_val]);
        }
    }

    // set AR_WPNav's WP_SPEED to be old WP_SPEED (if set) or CRUISE_SPEED (if set)
    const AP_Param::ConversionInfo wp_speed_old_info = { Parameters::k_param_g2, 14, AP_PARAM_FLOAT, "WP_SPEED" };
    const AP_Param::ConversionInfo cruise_speed_info = { Parameters::k_param_speed_cruise, 0, AP_PARAM_FLOAT, "WP_SPEED" };
    AP_Float wp_speed_old;
    if (AP_Param::find_old_parameter(&wp_speed_old_info, &wp_speed_old)) {
        // old WP_SPEED parameter value was set so copy to new WP_SPEED
        AP_Param::convert_old_parameter(&wp_speed_old_info, 1.0f);
    } else {
        // copy CRUISE_SPEED to new WP_SPEED
        AP_Param::convert_old_parameter(&cruise_speed_info, 1.0f);
    }

    // attitude control FF and FILT parameter changes for Rover-3.6
    const AP_Param::ConversionInfo ff_and_filt_conversion_info[] = {
        { Parameters::k_param_g2, 24650, AP_PARAM_FLOAT, "ATC_STR_RAT_FLTE" },
        { Parameters::k_param_g2, 28746, AP_PARAM_FLOAT, "ATC_STR_RAT_FF" },
        { Parameters::k_param_g2, 24714, AP_PARAM_FLOAT, "ATC_SPEED_FLTE" },
        { Parameters::k_param_g2, 28810, AP_PARAM_FLOAT, "ATC_SPEED_FF" },
        { Parameters::k_param_g2, 25226, AP_PARAM_FLOAT, "ATC_BAL_FLTE" },
        { Parameters::k_param_g2, 29322, AP_PARAM_FLOAT, "ATC_BAL_FF" },
        { Parameters::k_param_g2, 25354, AP_PARAM_FLOAT, "ATC_SAIL_FLTE" },
        { Parameters::k_param_g2, 29450, AP_PARAM_FLOAT, "ATC_SAIL_FF" },
    };
    AP_Param::convert_old_parameters(&ff_and_filt_conversion_info[0], ARRAY_SIZE(ff_and_filt_conversion_info));

    // configure safety switch to allow stopping the motors while armed
#if HAL_HAVE_SAFETY_SWITCH
    AP_Param::set_default_by_name("BRD_SAFETYOPTION", AP_BoardConfig::BOARD_SAFETY_OPTION_BUTTON_ACTIVE_SAFETY_OFF|
                                                      AP_BoardConfig::BOARD_SAFETY_OPTION_BUTTON_ACTIVE_SAFETY_ON|
                                                      AP_BoardConfig::BOARD_SAFETY_OPTION_BUTTON_ACTIVE_ARMED);
#endif

#if AP_AIRSPEED_ENABLED | AP_AIS_ENABLED | AP_FENCE_ENABLED
    // Find G2's Top Level Key
    AP_Param::ConversionInfo info;
    if (!AP_Param::find_top_level_key_by_pointer(&g2, info.old_key)) {
        return;
    }
#endif

    static const AP_Param::G2ObjectConversion g2_conversions[] {
#if AP_AIRSPEED_ENABLED
// PARAMETER_CONVERSION - Added: JAN-2022
        { &airspeed, airspeed.var_info, 37 },
#endif
#if AP_AIS_ENABLED
// PARAMETER_CONVERSION - Added: MAR-2022
        { &ais, ais.var_info, 50 },
#endif
#if AP_FENCE_ENABLED
// PARAMETER_CONVERSION - Added: Mar-2022
        { &fence, fence.var_info, 17 },
#endif
#if AP_STATS_ENABLED
    // PARAMETER_CONVERSION - Added: Jan-2024 for Rover-4.6
        { &stats, stats.var_info, 1 },
#endif
#if AP_SCRIPTING_ENABLED
    // PARAMETER_CONVERSION - Added: Jan-2024 for Rover-4.6
        { &scripting, scripting.var_info, 41 },
#endif
#if AP_GRIPPER_ENABLED
    // PARAMETER_CONVERSION - Added: Feb-2024 for Copter-4.6
        { &gripper, gripper.var_info, 39 },
#endif
    };

    AP_Param::convert_g2_objects(&g2, g2_conversions, ARRAY_SIZE(g2_conversions));

    // PARAMETER_CONVERSION - Added: Feb-2024 for Rover-4.6
#if HAL_LOGGING_ENABLED
    AP_Param::convert_class(g.k_param_logger, &logger, logger.var_info, 0, true);
#endif

    static const AP_Param::TopLevelObjectConversion toplevel_conversions[] {
#if AP_SERIALMANAGER_ENABLED
        // PARAMETER_CONVERSION - Added: Feb-2024 for Rover-4.6
        { &serial_manager, serial_manager.var_info, Parameters::k_param_serial_manager_old },
#endif
    };

    AP_Param::convert_toplevel_objects(toplevel_conversions, ARRAY_SIZE(toplevel_conversions));

}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            #pragma once

#include <AP_Common/AP_Common.h>

#include "RC_Channel.h"
#include <AC_Avoidance/AC_Avoid.h>
#include "AC_Sprayer/AC_Sprayer.h"
#include <AP_AIS/AP_AIS.h>
#include <AP_Beacon/AP_Beacon.h>
#include <AP_Follow/AP_Follow.h>
#include <AP_Proximity/AP_Proximity.h>
#include "AP_Rally.h"
#include <AP_SmartRTL/AP_SmartRTL.h>
#include <AP_Stats/AP_Stats.h>
#include "AP_Torqeedo/AP_Torqeedo.h"
#include <AP_WindVane/AP_WindVane.h>

#define AP_PARAM_VEHICLE_NAME rover

// Global parameter class.
//
class Parameters {
public:
    // The version of the layout as described by the parameter enum.
    //
    // When changing the parameter enum in an incompatible fashion, this
    // value should be incremented by one.
    //
    // The increment will prevent old parameters from being used incorrectly
    // by newer code.
    //
    static const uint16_t k_format_version = 16;

    enum {
        // Layout version number, always key zero.
        //
        k_param_format_version = 0,
        k_param_software_type, // unused
        k_param_can_mgr,

        // Misc
        //
        k_param_log_bitmask_old = 10,  // unused
        k_param_num_resets_old,         // unused
        k_param_reset_switch_chan,
        k_param_initial_mode,
        k_param_scheduler,
        k_param_relay,
        k_param_BoardConfig,
        k_param_pivot_turn_angle_old,   // unused
        k_param_rc_13_old,  // unused
        k_param_rc_14_old,  // unused

        // IO pins
        k_param_rssi_pin = 20,  // unused, replaced by rssi_ library parameters
        k_param_battery_volt_pin,
        k_param_battery_curr_pin,

        k_param_precland = 24,

        // braking
        k_param_braking_percent_old = 30,   // unused
        k_param_braking_speederr_old,       // unused

        // misc2
        k_param_log_bitmask = 40,
        k_param_gps,
        k_param_serial0_baud,   // deprecated, can be deleted
        k_param_serial1_baud,   // deprecated, can be deleted
        k_param_serial2_baud,   // deprecated, can be deleted

        // 97: RSSI
        k_param_rssi = 97,
        k_param_rpm_sensor,     // rpm sensor 98
        
        // 100: Arming parameters
        k_param_arming = 100,

        // 110: Telemetry control
        //
        k_param_gcs0 = 110,         // stream rates for SERIAL0
        k_param_gcs1,               // stream rates for SERIAL1
        k_param_sysid_this_mav,
        k_param_sysid_my_gcs,
        k_param_serial0_baud_old,   // unused
        k_param_serial1_baud_old,   // unused
        k_param_telem_delay,
        k_param_skip_gyro_cal,      // unused
        k_param_gcs2,               // stream rates for SERIAL2
        k_param_serial2_baud_old,   // unused
        k_param_serial2_protocol,   // deprecated, can be deleted
        k_param_serial_manager_old,     // serial manager library
        k_param_cli_enabled_old,    // unused
        k_param_gcs3,
        k_param_gcs_pid_mask,
        k_param_gcs4,
        k_param_gcs5,
        k_param_gcs6,

        //
        // 130: Sensor parameters
        //
        k_param_compass_enabled_deprecated = 130,
        k_param_steering_learn,     // unused
        k_param_NavEKF,             // deprecated - remove
        k_param_mission,            // mission library
        k_param_NavEKF2_old,        // deprecated - remove
        k_param_NavEKF2,
        k_param_g2,                 // 2nd block of parameters
        k_param_NavEKF3,

        // 140: battery controls
        k_param_battery_monitoring = 140,   // deprecated, can be deleted
        k_param_volt_div_ratio,             // deprecated, can be deleted
        k_param_curr_amp_per_volt,          // deprecated, can be deleted
        k_param_input_voltage,              // deprecated, can be deleted
        k_param_pack_capacity,              // deprecated, can be deleted
        k_param_battery,

        //
        // 150: Navigation parameters
        //
        k_param_crosstrack_gain = 150,  // unused
        k_param_crosstrack_entry_angle, // unused
        k_param_speed_cruise,
        k_param_speed_turn_gain,    // unused
        k_param_speed_turn_dist,    // unused
        k_param_ch7_option,         // unused
        k_param_auto_trigger_pin,
        k_param_auto_kickstart,
        k_param_turn_circle,  // unused
        k_param_turn_max_g_old, // unused

        //
        // 160: Radio settings
        //
        k_param_rc_1_old = 160, // unused
        k_param_rc_2_old,       // unused
        k_param_rc_3_old,       // unused
        k_param_rc_4_old,       // unused
        k_param_rc_5_old,       // unused
        k_param_rc_6_old,       // unused
        k_param_rc_7_old,       // unused
        k_param_rc_8_old,       // unused

        // throttle control
        k_param_throttle_min_old = 170, // unused
        k_param_throttle_max_old,       // unused
        k_param_throttle_cruise,
        k_param_throttle_slewrate_old,  // unused
        k_param_throttle_reduction,     // unused
        k_param_pilot_steer_type,
        k_param_skid_steer_out_old, // unused

        // failsafe control
        k_param_fs_action = 180,
        k_param_fs_timeout,
        k_param_fs_throttle_enabled,
        k_param_fs_throttle_value,
        k_param_fs_gcs_enabled,
        k_param_fs_crash_check,
        k_param_fs_ekf_action,
        k_param_fs_ekf_thresh,  // 187

        // obstacle control
        k_param_sonar_enabled = 190,  // deprecated, can be removed
        k_param_sonar_old,            // unused
        k_param_rangefinder_trigger_cm, // unused
        k_param_rangefinder_turn_angle, // unused
        k_param_rangefinder_turn_time,  // unused
        k_param_sonar2_old,           // unused
        k_param_rangefinder_debounce, // unused
        k_param_rangefinder,          // rangefinder object

        //
        // 210: driving modes
        //
        k_param_mode_channel = 210,
        k_param_mode1,
        k_param_mode2,
        k_param_mode3,
        k_param_mode4,
        k_param_mode5,
        k_param_mode6,
        k_param_aux_channel_old,

        //
        // 220: Waypoint data
        //
        k_param_command_total = 220,    // unused
        k_param_command_index,          // unused
        k_param_waypoint_radius_old,    // unused
        k_param_waypoint_overshoot_old, // unused

        //
        // camera control
        //
        k_param_camera,
        k_param_camera_mount,
        k_param_camera_mount2,          // unused

        //
        // 230: PID Controllers
        k_param_pidNavSteer = 230,
        k_param_pidServoSteer,  // unused
        k_param_pidSpeedThrottle_old,   // unused

        // high RC channels
        k_param_rc_9_old = 235, // unused
        k_param_rc_10_old,      // unused
        k_param_rc_11_old,      // unused
        k_param_rc_12_old,      // unusedS

        // other objects
        k_param_sitl = 240,
        k_param_ahrs,
        k_param_ins,
        k_param_compass,
        k_param_rcmap,
        k_param_L1_controller,          // unused
        k_param_steerController_old,    // unused
        k_param_barometer,
        k_param_notify,
        k_param_button,
        k_param_osd,
        k_param_optflow,

        k_param_logger = 253,  // Logging Group

        // 254,255: reserved

        k_param_vehicle = 257, // vehicle common block of parameters
        };

    AP_Int16    format_version;

    // Misc
    //
    AP_Int32    log_bitmask;
    AP_Int8     reset_switch_chan;
    AP_Int8     initial_mode;

    // Telemetry control
    //
    AP_Int16    sysid_this_mav;
    AP_Int16    sysid_my_gcs;
    AP_Int8     telem_delay;

    // navigation parameters
    //
    AP_Float    speed_cruise;
    AP_Int8     ch7_option;
    AP_Int8     auto_trigger_pin;
    AP_Float    auto_kickstart;
    AP_Int16    gcs_pid_mask;

    // Throttle
    //
    AP_Int8     throttle_cruise;
    AP_Int8     pilot_steer_type;

    // failsafe control
    AP_Int8     fs_action;
    AP_Float    fs_timeout;
    AP_Int8     fs_throttle_enabled;
    AP_Int16    fs_throttle_value;
    AP_Int8     fs_gcs_enabled;
    AP_Int8     fs_crash_check;
    AP_Int8     fs_ekf_action;
    AP_Float    fs_ekf_thresh;

    // driving modes
    //
    AP_Int8     mode_channel;
    AP_Int8     mode1;
    AP_Int8     mode2;
    AP_Int8     mode3;
    AP_Int8     mode4;
    AP_Int8     mode5;
    AP_Int8     mode6;

    Parameters() {}
};

/*
  2nd block of parameters, to avoid going past 256 top level keys
 */
class ParametersG2 {
public:
    ParametersG2(void);

    // var_info for holding Parameter information
    static const struct AP_Param::GroupInfo var_info[];

    // whether to enforce acceptance of packets only from sysid_my_gcs
    AP_Int8 sysid_enforce;

    // RC input channels
    RC_Channels_Rover rc_channels;

    // control over servo output ranges
    SRV_Channels servo_channels;

#if AP_ROVER_ADVANCED_FAILSAFE_ENABLED
    // advanced failsafe library
    AP_AdvancedFailsafe_Rover afs;
#endif

#if AP_BEACON_ENABLED
    AP_Beacon beacon;
#endif

    // wheel encoders
    AP_WheelEncoder wheel_encoder;
    AP_WheelRateControl wheel_rate_control;

    // Motor library
    AP_MotorsUGV motors;

    // steering and throttle controller
    AR_AttitudeControl attitude_control;

    // turn radius of vehicle (only used in steering mode)
    AP_Float turn_radius;

    // acro mode turn rate maximum
    AP_Float acro_turn_rate;

    // Safe RTL library
    AP_SmartRTL smart_rtl;

    // default speed for rtl
    AP_Float rtl_speed;

    // frame class for vehicle
    AP_Int8 frame_class;

#if HAL_PROXIMITY_ENABLED
    // proximity library
    AP_Proximity proximity;
#endif

#if MODE_DOCK_ENABLED
    // we need a pointer to the mode for the G2 table
    class ModeDock *mode_dock_ptr;
#endif

#if AP_AVOIDANCE_ENABLED
    // avoidance library
    AC_Avoid avoid;
#endif

    // pitch angle at 100% throttle
    AP_Float bal_pitch_max;

    // pitch/roll angle for crash check
    AP_Int8 crash_angle;

#if AP_FOLLOW_ENABLED
    // follow mode library
    AP_Follow follow;
#endif

    // frame type for vehicle (used for vectored motor vehicles and custom motor configs)
    AP_Int8 frame_type;

    // loiter type
    AP_Int8 loit_type;
    AP_Float loit_radius;

#if HAL_SPRAYER_ENABLED
    // Sprayer
    AC_Sprayer sprayer;
#endif

#if HAL_RALLY_ENABLED
    // Rally point library
    AP_Rally_Rover rally;
#endif

    // Simple mode types
    AP_Int8 simple_type;

    // windvane
    AP_WindVane windvane;

#if AP_MISSION_ENABLED
    // mission behave
    AP_Enum<ModeAuto::DoneBehaviour> mis_done_behave;
#endif

    // balance both pitch trim
    AP_Float bal_pitch_trim;

    // stick mixing for auto modes
    AP_Int8     stick_mixing;

    // waypoint navigation
    AR_WPNav_OA wp_nav;

    // Sailboat functions
    Sailboat sailboat;

#if AP_OAPATHPLANNER_ENABLED
    // object avoidance path planning
    AP_OAPathPlanner oa;
#endif

    // maximum speed for vehicle
    AP_Float speed_max;

    // gain for speed of correction in loiter
    AP_Float loiter_speed_gain;

    // FS options
    AP_Int32 fs_options;

#if HAL_TORQEEDO_ENABLED
    // torqeedo motor driver
    AP_Torqeedo torqeedo;
#endif

    // position controller
    AR_PosControl pos_control;

    // guided options bitmask
    AP_Int32 guided_options;

    // manual mode options
    AP_Int32 manual_options;

    // manual mode steering expo
    AP_Float manual_steering_expo;

    // FS GCS timeout trigger time
    AP_Float fs_gcs_timeout;

    class ModeCircle mode_circle;
};

extern const AP_Param::Info var_info[];
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 #include "Rover.h"

#include "RC_Channel.h"

// defining these two macros and including the RC_Channels_VarInfo
// header defines the parameter information common to all vehicle
// types
#define RC_CHANNELS_SUBCLASS RC_Channels_Rover
#define RC_CHANNEL_SUBCLASS RC_Channel_Rover

#include <RC_Channel/RC_Channels_VarInfo.h>

int8_t RC_Channels_Rover::flight_mode_channel_number() const
{
    return rover.g.mode_channel;
}

void RC_Channel_Rover::mode_switch_changed(modeswitch_pos_t new_pos)
{
    if (new_pos < 0 || (uint8_t)new_pos > rover.num_modes) {
        // should not have been called
        return;
    }

    rover.set_mode((Mode::Number)rover.modes[new_pos].get(), ModeReason::RC_COMMAND);
}

// init_aux_switch_function - initialize aux functions
void RC_Channel_Rover::init_aux_function(const AUX_FUNC ch_option, const AuxSwitchPos ch_flag)
{
    // init channel options
    switch (ch_option) {
    // the following functions do not need initialising:
    case AUX_FUNC::ACRO:
    case AUX_FUNC::AUTO:
    case AUX_FUNC::CIRCLE:
    case AUX_FUNC::FOLLOW:
    case AUX_FUNC::GUIDED:
    case AUX_FUNC::HOLD:
    case AUX_FUNC::LEARN_CRUISE:
    case AUX_FUNC::LOITER:
    case AUX_FUNC::MAINSAIL:
    case AUX_FUNC::MANUAL:
    case AUX_FUNC::PITCH:
    case AUX_FUNC::ROLL:
    case AUX_FUNC::WALKING_HEIGHT:
    case AUX_FUNC::RTL:
    case AUX_FUNC::SAILBOAT_TACK:
    case AUX_FUNC::TRIM_TO_CURRENT_SERVO_RC:
    case AUX_FUNC::SAVE_WP:
    case AUX_FUNC::SIMPLE:
    case AUX_FUNC::SMART_RTL:
    case AUX_FUNC::STEERING:
    case AUX_FUNC::WIND_VANE_DIR_OFSSET:
        break;
    case AUX_FUNC::SAILBOAT_MOTOR_3POS:
        do_aux_function_sailboat_motor_3pos(ch_flag);
        break;
    default:
        RC_Channel::init_aux_function(ch_option, ch_flag);
        break;
    }
}


bool RC_Channels_Rover::in_rc_failsafe() const
{
    return rover.failsafe.bits & FAILSAFE_EVENT_THROTTLE;
}

bool RC_Channels_Rover::has_valid_input() const
{
    if (in_rc_failsafe()) {
        return false;
    }
    return true;
}

RC_Channel * RC_Channels_Rover::get_arming_channel(void) const
{
    return rover.channel_steer;
}

void RC_Channel_Rover::do_aux_function_change_mode(Mode &mode,
        const AuxSwitchPos ch_flag)
{
    switch (ch_flag) {
    case AuxSwitchPos::HIGH:
        rover.set_mode(mode, ModeReason::AUX_FUNCTION);
        break;
    case AuxSwitchPos::MIDDLE:
        // do nothing
        break;
    case AuxSwitchPos::LOW:
        if (rover.control_mode == &mode) {
            rc().reset_mode_switch();
        }
    }
}

void RC_Channel_Rover::add_waypoint_for_current_loc()
{
    // create new mission command
    AP_Mission::Mission_Command cmd = {};

    // set new waypoint to current location
    cmd.content.location = rover.current_loc;

    // make the new command to a waypoint
    cmd.id = MAV_CMD_NAV_WAYPOINT;

    // save command
    if (rover.mode_auto.mission.add_cmd(cmd)) {
        hal.console->printf("Added waypoint %u", (unsigned)rover.mode_auto.mission.num_commands());
    }
}

void RC_Channel_Rover::do_aux_function_sailboat_motor_3pos(const AuxSwitchPos ch_flag)
{
    switch (ch_flag) {
    case AuxSwitchPos::HIGH:
        rover.g2.sailboat.set_motor_state(Sailboat::UseMotor::USE_MOTOR_ALWAYS);
        break;
    case AuxSwitchPos::MIDDLE:
        rover.g2.sailboat.set_motor_state(Sailboat::UseMotor::USE_MOTOR_ASSIST);
        break;
    case AuxSwitchPos::LOW:
        rover.g2.sailboat.set_motor_state(Sailboat::UseMotor::USE_MOTOR_NEVER);
        break;
    }
}

bool RC_Channel_Rover::do_aux_function(const AUX_FUNC ch_option, const AuxSwitchPos ch_flag)
{
    switch (ch_option) {
    case AUX_FUNC::DO_NOTHING:
        break;
    case AUX_FUNC::SAVE_WP:
        if (ch_flag == AuxSwitchPos::HIGH) {
            // do nothing if in AUTO mode
            if (rover.control_mode == &rover.mode_auto) {
                break;
            }

            // if disarmed clear mission and set home to current location
            if (!rover.arming.is_armed()) {
                rover.mode_auto.mission.clear();
                gcs().send_text(MAV_SEVERITY_NOTICE, "SaveWP: Mission cleared!");
                if (!rover.set_home_to_current_location(false)) {
                    // ignored
                }
                break;
            }

            // record the waypoint if not in auto mode
            if (rover.control_mode != &rover.mode_auto) {
                if (rover.mode_auto.mission.num_commands() == 0) {
                    // add a home location....
                    add_waypoint_for_current_loc();
                }
                add_waypoint_for_current_loc();
            }
        }
        break;

    // learn cruise speed and throttle
    case AUX_FUNC::LEARN_CRUISE:
        if (ch_flag == AuxSwitchPos::HIGH) {
            rover.cruise_learn_start();
        }
        break;

    // set mode to Manual
    case AUX_FUNC::MANUAL:
        do_aux_function_change_mode(rover.mode_manual, ch_flag);
        break;

    // set mode to Acro
    case AUX_FUNC::ACRO:
        do_aux_function_change_mode(rover.mode_acro, ch_flag);
        break;

    // set mode to Steering
    case AUX_FUNC::STEERING:
        do_aux_function_change_mode(rover.mode_steering, ch_flag);
        break;

    // set mode to Hold
    case AUX_FUNC::HOLD:
        do_aux_function_change_mode(rover.mode_hold, ch_flag);
        break;

    // set mode to Auto
    case AUX_FUNC::AUTO:
        do_aux_function_change_mode(rover.mode_auto, ch_flag);
        break;

    // set mode to RTL
    case AUX_FUNC::RTL:
        do_aux_function_change_mode(rover.mode_rtl, ch_flag);
        break;

    // set mode to SmartRTL
    case AUX_FUNC::SMART_RTL:
        do_aux_function_change_mode(rover.mode_smartrtl, ch_flag);
        break;

    // set mode to Guided
    case AUX_FUNC::GUIDED:
        do_aux_function_change_mode(rover.mode_guided, ch_flag);
        break;

    // Set mode to LOITER
    case AUX_FUNC::LOITER:
        do_aux_function_change_mode(rover.mode_loiter, ch_flag);
        break;

#if MODE_FOLLOW_ENABLED
    // Set mode to Follow
    case AUX_FUNC::FOLLOW:
        do_aux_function_change_mode(rover.mode_follow, ch_flag);
        break;
#endif

    // set mode to Simple
    case AUX_FUNC::SIMPLE:
        do_aux_function_change_mode(rover.mode_simple, ch_flag);
        break;

    case AUX_FUNC::CIRCLE:
        do_aux_function_change_mode(rover.g2.mode_circle, ch_flag);
        break;

    // trigger sailboat tack
    case AUX_FUNC::SAILBOAT_TACK:
        // any switch movement interpreted as request to tack
        rover.control_mode->handle_tack_request();
        break;

    // sailboat motor state 3pos
    case AUX_FUNC::SAILBOAT_MOTOR_3POS:
        do_aux_function_sailboat_motor_3pos(ch_flag);
        break;

    // save steering trim
    case AUX_FUNC::TRIM_TO_CURRENT_SERVO_RC:
        if (!rover.g2.motors.have_skid_steering() && rover.arming.is_armed() &&
            (rover.control_mode != &rover.mode_loiter)
            && (rover.control_mode != &rover.mode_hold) && ch_flag == AuxSwitchPos::HIGH) {
            SRV_Channels::set_trim_to_servo_out_for(SRV_Channel::k_steering);
            gcs().send_text(MAV_SEVERITY_CRITICAL, "Steering trim saved!");
        }
        break;

    // manual input, nothing to do
    case AUX_FUNC::MAINSAIL:
    case AUX_FUNC::PITCH:
    case AUX_FUNC::ROLL:
    case AUX_FUNC::WALKING_HEIGHT:
    case AUX_FUNC::WIND_VANE_DIR_OFSSET:
        break;

    default:
        return RC_Channel::do_aux_function(ch_option, ch_flag);

    }

    return true;
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      #pragma once

#include <RC_Channel/RC_Channel.h>
#include "Rover.h"
#include "mode.h"

class RC_Channel_Rover : public RC_Channel
{

public:

protected:

    void init_aux_function(AUX_FUNC ch_option, AuxSwitchPos) override;
    bool do_aux_function(AUX_FUNC ch_option, AuxSwitchPos) override;

    // called when the mode switch changes position:
    void mode_switch_changed(modeswitch_pos_t new_pos) override;

private:

    void do_aux_function_change_mode(Mode &mode,
                                     const AuxSwitchPos ch_flag);

    void add_waypoint_for_current_loc();

    void do_aux_function_sailboat_motor_3pos(const AuxSwitchPos ch_flag);
};

class RC_Channels_Rover : public RC_Channels
{

public:

    bool in_rc_failsafe() const override;
    bool has_valid_input() const override;

    RC_Channel *get_arming_channel(void) const override;

    RC_Channel_Rover obj_channels[NUM_RC_CHANNELS];

    RC_Channel_Rover *channel(const uint8_t chan) override {
        if (chan >= NUM_RC_CHANNELS) {
            return nullptr;
        }
        return &obj_channels[chan];
    }

private:

    int8_t flight_mode_channel_number() const override;
};
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    Rover Release Notes:
------------------------------------------------------------------
Release 4.5.5 1st Aug 2024

No changes from 4.5.5-beta2
------------------------------------------------------------------
Release 4.5.5-beta2 27 July 2024

Changes from 4.5.5-beta1

1) Board specific enhancements and bug fixes

- CubeRed's second core disabled at boot to avoid spurious writes to RAM
- CubeRed bootloader's dual endpoint update method fixed
------------------------------------------------------------------
Release 4.5.5-beta1 1st July 2024

Changes from 4.5.4

1) Board specific enhancements and bug fixes

- fixed IOMCU transmission errors when using bdshot
- update relay parameter names on various boards
- add ASP5033 airspeed in minimal builds
- added RadiolinkPIX6
- fix Aocoda-RC H743Dual motor issue
- use ICM45686 as an ICM20649 alternative in CubeRedPrimary

2) System level minor enhancements and bug fixes

- correct use-after-free in script statistics
- added arming check for eeprom full
- fixed a block logging issue which caused log messages to be dropped
- enable Socket SO_REUSEADDR on LwIP
- removed IST8310 overrun message
- added Siyi ZT6 support
- added BTFL sidebar symbols to the OSD
- added CRSF extended link stats to the OSD
- use the ESC with the highest RPM in the OSD when only one can be displayed
- support all Tramp power levels on high power VTXs
- emit jump count in missions even if no limit
- improve the bitmask indicating persistent parameters on bootloader flash	
- fix duplicate error condition in the MicroStrain7

5) Other minor enhancements and bug fixes

- specify pymonocypher version in more places
- added DroneCAN dependencies to custom builds

------------------------------------------------------------------
Release 4.5.4 12th June 2024

Changes from 4.5.3

Disable highres IMU sampling on ICM42670 fixing an issue on some versions of Pixhawk6X

------------------------------------------------------------------
Release 4.5.3 28th May 2024

No changes from 4.5.3-beta1
------------------------------------------------------------------
Release 4.5.3-beta1 16th May 2024

Changes from 4.5.2

1) Board specific enhancements and bug fixes

- correct default GPS port on MambaH743v4
- added SDMODELV2
- added iFlight Blitz H7 Pro
- added BLITZ Wing H743
- added highres IMU sampling on Pixhawk6X

2) System level minor enhancements and bug fixes

- fixed rare crash bug in lua scripting on script fault handling
- fixed Neopixel pulse proportions to work with more LED variants
- fixed timeout in lua rangefinder drivers
- workaround hardware issue in IST8310 compass
- allow FIFO rate logging for highres IMU sampling

3) Rover specific changes

- correct clamping of RTL_SPEED for fractional speed values

------------------------------------------------------------------
Release 4.5.2 14th May 2024

No changes from 4.5.2-beta1
------------------------------------------------------------------
Release 4.5.2-beta1 29th April 2024

Changes from 4.5.1

1) Board specific enhancements and bug fixes

- FoxeerF405v2 support
- iFlight BLITZ Mini F745 support
- Pixhawk5X, Pixhawk6C, Pixhawk6X, Durandal power peripherals immediately at startup

2) System level minor enhancements and bug fixes

- Camera lens (e.g. RGB, IR) can be selected from GCS or during missions using set-camera-source
- Crashdump pre-arm check added
- Gimbal gets improved yaw lock reporting to GCS
- Gimbal default mode fixed (MNTx_DEFLT_MODE was being overriden by RC input)
- RM3100 compass SPI bus speed reduced to 1Mhz
- SBUS output fix for channels 1 to 8 also applying to 9 to 16
- ViewPro gimbal supports enable/disable rangefinder from RC aux switch
- Visual Odometry delay fixed (was always using 1ms delay, see VISO_DELAY_MS)
- fixed serial passthrough to avoid data loss at high data rates

3) AHRS / EKF fixes

- Compass learning disabled when using GPS-for-yaw
- GSF reset minimum speed reduced to 1m/s (except Plane which remains 5m/s)
- MicroStrain7 External AHRS position quantization bug fix
- MicroStrain7 init failure warning added
- MicroStrain5 and 7 position and velocity variance reporting fix

4) Other minor enhancements and bug fixes

- DDS_UDP_PORT parameter renamed (was DDS_PORT)
- Harmonic Notch bitmask parameter conversion fix (see INS_HNTCH_HMNCS)

------------------------------------------------------------------
Release 4.5.1 8th April 2024

This release fixes a critical bug in the CRSF R/C protocol parser that
can lead to a handfault and a vehicle crashing. A similar fix was
applied to the GHST protocol, although we believe that GHST could not
be affected by the bug, so this was just a precaution.

There are no other changes in this release.

------------------------------------------------------------------
Release 4.5.0 2nd April 2024

No changes from 4.5.0-beta4
-------------------------------------------------------------------
Release 4.5.0-beta4 22nd March 2024

Changes from 4.5.0-beta3

1) system changes

- fixed a cache corruption issue with microSD card data on H7 based boards
- rename parameter NET_ENABLED to NET_ENABLE
- fixed FDCAN labels for adding new H7 boards
- avoid logging dma.txt to save CPU
- fixed roll/pitch in viewpro driver
- added band X in VideoTX
- fixed quaternion attitude reporting for Microstrain external AHRS
- add RPLidarC1 proximity support

2) new boards
- added MicoAir405v2
- add Orqa F405 Pro

-------------------------------------------------------------------
Release 4.5.0-beta3 14-March-2024

Changes from 4.5.0-beta2

1) Board specific changes
- added PixFlamingo F7 board
- support ICM42688 on BlitzF745AIO
- fixed IMU orientation of CubeRedSecondary
- enable all FPV features on SpeedyBeeF405WING

2) System level changes

- improved robustness of CRSF parser
- reduced memory used by DDS/ROS2
- added filesystem crc32 binding in lua scripting
- support visual odometry quality metric and added autoswitching lua script
- allow for expansion of fence storage to microSD for larger pologon fences
- allow FTP upload of fence and rally points
- fixed vehicle type of ship simulation for ship landing
- make severity level depend on generator error level in IE 2400 generator
- speed up initial GPS probe by using SERIALn_BAUD first
- allow NanoRadar radar and proximity sensor to share the CAN bus
- added MR72 CAN proximity sensor
- only produce *_with_bl.hex not *.hex in builds if bootloader available
- fixed check for GPS antenna separation in moving baseline yaw
- added GPS_DRV_OPTIONS options for fully parsing RTCMv3 stream
- fixed logging of RTCM fragments in GPS driver
- fixed video recording while armed
- robostness and logging improvements for ExternalAHRS
- fixed RPM from bdshot on boards with IOMCU
- fixed accel cal simple to remove unused IMUs

-------------------------------------------------------------------
Rover 4.5.0-beta2 14th February 2024
Changes from 4.5.0-beta1:

1) New Autopilots supported
 - YJUAV_A6Ultra
 - AnyLeaf H7

2) System level changes
 - fixed float rounding issue in HAL_Linux millis and micros functions
 - fixed loading of defaults.parm parameters for dynamic parameter subtrees
 - fixed discrimination between GHST and CRSF protocols
 - fixed bug in DroneCAN packet parsing for corrupt packets that could cause a crash
 - fixed handling of network sockets in scripting when used after close
 - fixed bit timing of CANFD buses

3) Camera and gimbal enhancements
 - wait for non-zero camera version in SIYI driver

4) Miscellaneous
 - do relay parameter conversion for parachute parameters if ever has been used
 - broaden acceptance criteria for GPS yaw measurement for moving baseline yaw

------------------------------------------------------------------
Rover 4.5.0-beta1 30-Jan-2025
Changes from 4.4.4
1) New autopilots supported
    - ACNS-F405AIO
    - Airvolute DCS2 onboard FMU
    - Aocoda-RC-H743Dual
    - BrainFPV RADIX 2 HD
    - CAN-Zero
    - CM4Pilot
    - CubeRed
    - Esp32-tomte76, esp32nick, esp32s3devkit
    - FlyingMoonH743
    - Flywoo F405 Pro
    - FlywooF405S-AIO with alternative IMUs
    - Here4 GPS as flight controller
    - Holybro 6X revision 6
    - Holybro6X-45686 with 3x ICM45686 IMUs
    - JAE JFB110
    - KakuteH7 using ICM42688
    - PixFlamingo (uses STM32L4PLUS CPU)
    - PixPilot-C3
    - PixSurveyA1-IND
    - QiotekAdeptF407
    - Sierra TrueNavIC
    - SPRacing H7RF
    - SW-Nav-F405
    - YJUAV_A6
    - YJUAV_A6SE, YJUAV_A6SE_H743
2) Autopilot specific changes
    - 1MB boards lose features to save flash (Payload Place, some battery monitors, NMEA Output, bootloaders, Turtle mode)
    - CubeOrangePlus supports IMU high resolution sampling (works with ICM42688, ICM42652, ICM42670, ICM45686 IMUs)
    - F4 processors with only 1 IMU gain Triple Harmonic Notch support
    - F765-SE bdshot support on 1st 4 pin
    - F7 and H7 boards lose DMA on I2C ports (not required, limited DMA better used elsewhere)
    - FlyingMoonH743, FlyingMoonF427 2nd and 3rd IMU order swapped
    - HEEWING-F405 supports CRSF
    - MatekL431-RC bootloader added, DMA used for RC and GPS
    - PH4-mini, PH4-mini-bdshot, Swan-K1 and TBS-Colibri-F7 BRD_SER4_RTSCTS param conflict fixed
    - Pixhawk6C supports BMI088 baro
    - TMotorH743, Heewing-F405 serial parameter definitions fixed
3) AHRS/EKF enhancements and fixes
    - AHRS_OPTIONS supports disabling fallback to DCM
    - BARO_ALT_OFFSET slews more slowly (was 20sec, now 1min)
    - EKF2 removed (can be re-enabled with Custom build server)
    - External AHRS support for multiple GPSs
    - InertialLabs INS-U external AHRS support
    - Lord external AHRS renamed to MicroStrain5
    - MAV_CMD_EXTERNAL_POSITION_ESTIMATE supports setting approximate position during dead-reckoning
    - Microstrain7 (aka 3DM-QG7) external AHRS support
4) Driver enhancements
    - 3DR Solo supports up to 6S batteries
    - Airspeed health checks vs GPS use 3D velocity
    - BDshot on the first four channels of boards with F103-based IOMCUs (e.g. Pixhawk 6X)
    - Dshot on all IOMCU channels on all boards with an IOMCU (e.g. all CubePilot autopilots)
    - Dshot commands (e.g. motor reversal abd beeps) and EDT supported on IOMCU
    - DroneCAN battery monitors calculate consumed energy if battery doesn't provide directly
    - DroneCAN RC and Ghost RC protocol support
    - EFI MAVLink driver
    - Extended DShot Telemetry support (requires BLHeli32 ver 32.10 or BlueJay, set SERVO_DSHOT_ESC=3 or 4)
    - GPS L5 band health override to enable L5 signal use (see GPS_DRV_OPTIONS)
    - GPS-for-yaw works at lower update rate (3hz minimum)
    - GSOF GPS supports GPS_COM_PORT parameter
    - Hirth ICEngine support
    - ICE option to enable/disable starting while disarmed
    - ICE support for starter via relay
    - IMUDATA serial protocol outputs raw IMU data on serial port (only available using custom build server)
    - Innomaker LD06 360deg lidar support
    - Intelligent Energy fuel cells new protocol support
    - IRC Tramp supports 1G3 bands A and B
    - IRC Ghost support
    - JAE JRE-30 radar
    - KDECAN driver rewrite (params moved to KDE_, works on all vehicles)
    - MCP9601 temperature sensor support
    - NanoRadar NRA24 rangefinder support
    - NeoPixelsRGB support
    - NoopLoop TOFSense, TOFSenseF-I2c rangefinder support
    - OSD shows flashing horizon when inverted
    - OSD2 support (e.g. second OSD)
    - QMC5883P compass support
    - Relay refactored to support RELAYx_FUNCTION, RELAY_STATUS message support added
    - Reventech fuel level support (extends existing analog driver, see BATT_FL_xx parameters)
    - RPLidarS1 360 deg lidar support and improved reliability for all RPLidars
    - SBF GPS supports yaw from dual antennas
    - Temperature sensor using analog voltages supported
    - Trimble PX-1 support added as a GPS
    - Winch driver enhancements including stuck protection, option for spin-free on startup
5) Control and navigation changes and enhancements
    - Auto missions can always be cleared while disarmed (would fail if mission still running)
    - DO_ENGINE_CONTROL allows starting engine even when disarmed
    - DO_SET_MISSION_CURRENT command can reset mission (see Reset Mission field)
    - DO_SET_SERVO, DO_REPEAT_SERVO work with servo outputs set to RCInxScaled
    - Fractional Loiter Turn Support in missions
    - HarmonicNotch supports up to 16 harmonics
    - JUMP command sends improved text msg to pilot (says where will jump to)
    - MAV_CMD_AIRFRAME_CONFIGURATION can control landing gear on all vehicles
    - MAV_CMD_NAV_SET_YAW_SPEED deprecated
    - MOT_OPTIONS allows voltage compensation to use raw battery voltages (instead of current corrected voltage)
    - PID controllers get DFF/D_FF (derivative feed-forward), NTF (target notch filter index) and NEF (error notch filter index)
    - PID controllers get PDMX param to limit P+D output (useful for large vehicles and/or slow actuators)
    - PID notch filter configured via new filter library using FILT parameters
6) Parameters renamed
    - COMPASS_TYPEMASK renamed to COMPASS_DISBLMSK
7) ROS2 / DDS support
    - Added support for EProsima MicroXRCEDDS as a transport in SITL and hardware
    - Added sensor data topic support such as NavSatStatus and BatteryState
    - Added a new AP_ExternalControl library for generic control support in SI units
    - Added support for building ArduPilot with the colcon build system
    - DDS topics comply with ROS REP-147
    - Added Gazebo Garden and Gazebo Harmonic simulation with examples
    - Added support for ROS 2 services such as Arm and Mode control
    - Added high level goal interface for waypoints
    - Wiki updated to support ROS 2
    - Added ROS 2 launch scripts for SITL, MAVProxy and micro-ROS agent
    - Add pytests for DDS client and ROS 2 launch scripts and integrate into CI
8) Camera and gimbal enhancements
    - Calculates location where camera gimbal is pointing (see CAMERA_FOV_STATUS)
    - CAMx_MNT_INST allows specifying which mount camera is in
    - Camera lens (e.g. live video stream) selectable using RC aux function
    - Interval timer (for taking pictures at timed intervals)
    - Image tracking support (ViewPro only)
    - MAVLink Gimbal Protocol v2 support for better GCS integration
    - MNTx_SYSID_DFLT allows easier pointing gimbal at another vehicle
    - MOUNT_CONTROL, MOUNT_CONFIGURE messages deprecated
    - RangeFinder support (only logged, only supported on Siyi, Viewpro)
    - Pilot's RC input re-takes manual control of gimbal (e.g. switches to RC_TARGETING mode)
    - Siyi driver gets Zoom control, sends autopilot attitude and time (reduces leans)
    - Video recording may start when armed (see CAMx_OPTIONS)
    - ViewPro driver (replaces equivalent Lua driver)
    - Xacti camera gimbal support
    - Zoom percentage support (for both missions and GCS commands)
9) Logging and reporting changes
    - Battery logging (e.g. BAT) includes health, temperature, state-of-health percentage
    - CAM and MNT messages contain camera gimbal's desired and actual angles
    - INS_RAW_LOG_OPT allows raw, pre-filter and post-filter sensor data logging (alternative to "batch logging", good for filtering analysis)
    - PID logging gets reset and I-term-set flags
    - Rangefinder logging (e.g. RFND) includes signal quality
    - RC aux functions sorted alphabetically for GCS
    - RC logging (RCI, RCI2) include valid input and failsafe flags
    - RTK GPS logging includes number of fragments used or discarded
10) Scripting enhancements
    - Autopilot reboot support
    - Baro, Compass, IMU, IOMCU health check support
    - Battery cell voltage bindings
    - Battery driver support
    - BattEsimate.lua applet estimates SoC from voltage
    - Camera and Mount bindings improved
    - CAN input packet filtering reduces work required by Lua CAN drivers
    - DJI RS2/RS3 gimbal driver supports latest DJI firmware version (see mount-djirs2-driver.lua)
    - EFI drivers for DLA serial, InnoFlight Inject EFI driver
    - EFI bindings improved
    - Fence support
    - Generator drivers for Halo6000, Zhuhai SVFFI
    - GCS failsafe support
    - Hobbywing_DataLink driver (see Hobbywing_DataLink.lua)
    - is_landing, is_taking_off bindings
    - led_on_a_switch.lua sets LED brightness from RC switch
    - MAVLink sending and receiving support
   /*
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
/*
  CAN bootloader support
 */
#include <AP_HAL/AP_HAL.h>
#include <hal.h>
#if HAL_USE_CAN == TRUE || HAL_NUM_CAN_IFACES
#include <AP_Math/AP_Math.h>
#include <AP_Math/crc.h>
#include <canard.h>
#include "support.h"
#include <dronecan_msgs.h>
#include "can.h"
#include "bl_protocol.h"
#include <drivers/stm32/canard_stm32.h>
#include "app_comms.h"
#include <AP_HAL_ChibiOS/hwdef/common/watchdog.h>
#include <stdio.h>
#include <AP_HAL_ChibiOS/CANIface.h>
#include <AP_CheckFirmware/AP_CheckFirmware.h>

static CanardInstance canard;
static uint32_t canard_memory_pool[4096/4];
#ifndef HAL_CAN_DEFAULT_NODE_ID
#define HAL_CAN_DEFAULT_NODE_ID CANARD_BROADCAST_NODE_ID
#endif
static uint8_t initial_node_id = HAL_CAN_DEFAULT_NODE_ID;

// can config for 1MBit
static uint32_t baudrate = 1000000U;

#if HAL_USE_CAN
static CANConfig cancfg = {
    CAN_MCR_ABOM | CAN_MCR_AWUM | CAN_MCR_TXFP,
    0 // filled in below
};
// pipelining is not faster when using ChibiOS CAN driver
#define FW_UPDATE_PIPELINE_LEN 1
#else
static ChibiOS::CANIface can_iface[HAL_NUM_CAN_IFACES];
#endif

#ifndef CAN_APP_VERSION_MAJOR
#define CAN_APP_VERSION_MAJOR                                           2
#endif
#ifndef CAN_APP_VERSION_MINOR
#define CAN_APP_VERSION_MINOR                                           0
#endif
#ifndef CAN_APP_NODE_NAME
#define CAN_APP_NODE_NAME "org.ardupilot." CHIBIOS_BOARD_NAME
#endif

#ifdef EXT_FLASH_SIZE_MB
static_assert(EXT_FLASH_SIZE_MB == 0, "DroneCAN bootloader cannot support external flash");
#endif

static uint8_t node_id_allocation_transfer_id;
static uavcan_protocol_NodeStatus node_status;
static uint32_t send_next_node_id_allocation_request_at_ms;
static uint8_t node_id_allocation_unique_id_offset;

static void processTx(void);

// keep up to 4 transfers in progress
#ifndef FW_UPDATE_PIPELINE_LEN
#define FW_UPDATE_PIPELINE_LEN 4
#endif

#if CH_CFG_USE_MUTEXES == TRUE
static HAL_Semaphore can_mutex;
#endif

static struct {
    uint32_t rtt_ms;
    uint32_t ofs;
    uint8_t node_id;
    uint8_t path[sizeof(uavcan_protocol_file_Path::path.data)+1];
    uint8_t sector;
    uint32_t sector_ofs;
    uint8_t transfer_id;
    uint8_t idx;
    struct {
        uint8_t tx_id;
        uint32_t sent_ms;
        uint32_t offset;
        bool have_reply;
        uavcan_protocol_file_ReadResponse pkt;
    } reads[FW_UPDATE_PIPELINE_LEN];
    uint16_t erased_to;
} fw_update;

/*
  get cpu unique ID
 */
static void readUniqueID(uint8_t* out_uid)
{
    uint8_t len = sizeof(uavcan_protocol_dynamic_node_id_Allocation::unique_id.data);
    memset(out_uid, 0, len);
    memcpy(out_uid, (const void *)UDID_START, MIN(len,12));
}

/*
  simple 16 bit random number generator
 */
static uint16_t get_randomu16(void)
{
    static uint32_t m_z = 1234;
    static uint32_t m_w = 76542;
    m_z = 36969 * (m_z & 0xFFFFu) + (m_z >> 16);
    m_w = 18000 * (m_w & 0xFFFFu) + (m_w >> 16);
    return ((m_z << 16) + m_w) & 0xFFFF;
}


/**
 * Returns a pseudo random integer in a given range
 */
static uint32_t get_random_range(uint16_t range)
{
    return get_randomu16() % range;
}

/*
  handle a GET_NODE_INFO request
 */
static void handle_get_node_info(CanardInstance* ins,
                                 CanardRxTransfer* transfer)
{
    uint8_t buffer[UAVCAN_PROTOCOL_GETNODEINFO_RESPONSE_MAX_SIZE];
    uavcan_protocol_GetNodeInfoResponse pkt {};

    node_status.uptime_sec = AP_HAL::millis() / 1000U;

    pkt.status = node_status;
    pkt.software_version.major = CAN_APP_VERSION_MAJOR;
    pkt.software_version.minor = CAN_APP_VERSION_MINOR;

    readUniqueID(pkt.hardware_version.unique_id);

    // use hw major/minor for APJ_BOARD_ID so we know what fw is
    // compatible with this hardware
    pkt.hardware_version.major = APJ_BOARD_ID >> 8;
    pkt.hardware_version.minor = APJ_BOARD_ID & 0xFF;

    char name[strlen(CAN_APP_NODE_NAME)+1];
    strcpy(name, CAN_APP_NODE_NAME);
    pkt.name.len = strlen(CAN_APP_NODE_NAME);
    memcpy(pkt.name.data, name, pkt.name.len);

    uint16_t total_size = uavcan_protocol_GetNodeInfoResponse_encode(&pkt, buffer, true);

    canardRequestOrRespond(ins,
                           transfer->source_node_id,
                           UAVCAN_PROTOCOL_GETNODEINFO_SIGNATURE,
                           UAVCAN_PROTOCOL_GETNODEINFO_ID,
                           &transfer->transfer_id,
                           transfer->priority,
                           CanardResponse,
                           &buffer[0],
                           total_size);
}

/*
  send a read for a fw update
 */
static bool send_fw_read(uint8_t idx)
{
    auto &r = fw_update.reads[idx];
    r.tx_id = fw_update.transfer_id;
    r.have_reply = false;

    uavcan_protocol_file_ReadRequest pkt {};
    pkt.path.path.len = strlen((const char *)fw_update.path);
    pkt.offset = r.offset;
    memcpy(pkt.path.path.data, fw_update.path, pkt.path.path.len);

    uint8_t buffer[UAVCAN_PROTOCOL_FILE_READ_REQUEST_MAX_SIZE];
    uint16_t total_size = uavcan_protocol_file_ReadRequest_encode(&pkt, buffer, true);

    if (canardRequestOrRespond(&canard,
                               fw_update.node_id,
                               UAVCAN_PROTOCOL_FILE_READ_SIGNATURE,
                               UAVCAN_PROTOCOL_FILE_READ_ID,
                               &fw_update.transfer_id,
                               CANARD_TRANSFER_PRIORITY_HIGH,
                               CanardRequest,
                               &buffer[0],
                               total_size) > 0) {
        // mark it as having been sent
        r.sent_ms = AP_HAL::millis();
        return true;
    }
    return false;
}

/*
  send a read for a fw update
 */
static void send_fw_reads(void)
{
    const uint32_t now = AP_HAL::millis();

    for (uint8_t i=0; i<FW_UPDATE_PIPELINE_LEN; i++) {
        const uint8_t idx = (fw_update.idx+i) % FW_UPDATE_PIPELINE_LEN;
        const auto &r = fw_update.reads[idx];
        if (r.have_reply) {
            continue;
        }
        if (r.sent_ms != 0 && now - r.sent_ms < 10+2*MAX(250,fw_update.rtt_ms)) {
            // waiting on a response
            continue;
        }
        if (!send_fw_read(idx)) {
            break;
        }
    }
}

/*
  erase up to at least the given sector number
 */
static void erase_to(uint16_t sector)
{
    if (sector < fw_update.erased_to) {
        return;
    }
    flash_func_erase_sector(sector);
    fw_update.erased_to = sector+1;

    /*
      pre-erase any non-erased pages up to end of flash. This puts all
      the load of erasing at the start of flashing which is much
      faster than flashing as we go on boards with small flash
      sectors.  We stop at the first already erased page so we don't
      end up wasting time erasing already erased pages when the
      firmware is much smaller than the total flash size
     */
    while (flash_func_sector_size(fw_update.erased_to) != 0 &&
           !flash_func_is_erased(fw_update.erased_to)) {
        flash_func_erase_sector(fw_update.erased_to);
        fw_update.erased_to++;
    }
}

/*
  handle response to file read for fw update
 */
static void handle_file_read_response(CanardInstance* ins, CanardRxTransfer* transfer)
{
    if (transfer->source_node_id != fw_update.node_id) {
        return;
    }
    /*
      match the response to a sent request
     */
    uint8_t idx = 0;
    bool found = false;
    for (idx=0; idx<FW_UPDATE_PIPELINE_LEN; idx++) {
        const auto &r = fw_update.reads[idx];
        if (r.tx_id == transfer->transfer_id) {
            found = true;
            break;
        }
    }
    if (!found) {
        // not a current transfer
        return;
    }
    if (uavcan_protocol_file_ReadResponse_decode(transfer, &fw_update.reads[idx].pkt)) {
        return;
    }
    fw_update.reads[idx].have_reply = true;
    uint32_t rtt = MIN(3000,MAX(AP_HAL::millis() - fw_update.reads[idx].sent_ms, 25));
    fw_update.rtt_ms = uint32_t(0.9 * fw_update.rtt_ms + 0.1 * rtt);

    while (fw_update.reads[fw_update.idx].have_reply) {
        auto &r = fw_update.reads[fw_update.idx];
        if (r.offset != fw_update.ofs) {
            // bad sequence
            r.have_reply = false;
            r.sent_ms = 0;
            break;
        }
        const auto &pkt = r.pkt;
        const uint16_t len = pkt.data.len;
        const uint16_t len_words = (len+3U)/4U;
        const uint8_t *buf = (uint8_t *)pkt.data.data;
        uint32_t buf32[len_words] {};
        memcpy((uint8_t*)buf32, buf, len);

        if (fw_update.ofs == 0) {
            flash_set_keep_unlocked(true);
        }

        const uint32_t sector_size = flash_func_sector_size(fw_update.sector);
        if (sector_size == 0) {
            // firmware is too big
            fw_update.node_id = 0;
            flash_write_flush();
            flash_set_keep_unlocked(false);
            node_status.vendor_specific_status_code = uint8_t(check_fw_result_t::FAIL_REASON_BAD_LENGTH_APP);
            break;
        }
        if (fw_update.sector_ofs == 0) {
            erase_to(fw_update.sector);
        }
        if (fw_update.sector_ofs+len > sector_size) {
            erase_to(fw_update.sector+1);
        }
        if (!flash_write_buffer(fw_update.ofs, buf32, len_words)) {
            continue;
        }

        fw_update.ofs += len;
        fw_update.sector_ofs += len;
        if (fw_update.sector_ofs >= flash_func_sector_size(fw_update.sector)) {
            fw_update.sector++;
            fw_update.sector_ofs -= sector_size;
        }

        if (len < sizeof(uavcan_protocol_file_ReadResponse::data.data)) {
            fw_update.node_id = 0;
            flash_write_flush();
            flash_set_keep_unlocked(false);
            const auto ok = check_good_firmware();
            node_status.vendor_specific_status_code = uint8_t(ok);
            if (ok == check_fw_result_t::CHECK_FW_OK) {
                jump_to_app();
            }
            return;
        }

        r.have_reply = false;
        r.sent_ms = 0;
        r.offset += FW_UPDATE_PIPELINE_LEN*sizeof(uavcan_protocol_file_ReadResponse::data.data);
        send_fw_read(fw_update.idx);
        processTx();

        fw_update.idx = (fw_update.idx + 1) % FW_UPDATE_PIPELINE_LEN;
    }

    // show offset number we are flashing in kbyte as crude progress indicator
    node_status.vendor_specific_status_code = 1 + (fw_update.ofs / 1024U);
}

/*
  handle a begin firmware update request. We start pulling in the file data
 */
static void handle_begin_firmware_update(CanardInstance* ins, CanardRxTransfer* transfer)
{
    if (fw_update.node_id == 0) {
        uavcan_protocol_file_BeginFirmwareUpdateRequest pkt;
        if (uavcan_protocol_file_BeginFirmwareUpdateRequest_decode(transfer, &pkt)) {
            return;
        }
        if (pkt.image_file_remote_path.path.len > sizeof(fw_update.path)-1) {
            return;
        }
        memset(&fw_update, 0, sizeof(fw_update));
        for (uint8_t i=0; i<FW_UPDATE_PIPELINE_LEN; i++) {
            fw_update.reads[i].offset = i*sizeof(uavcan_protocol_file_ReadResponse::data.data);
        }
        memcpy(fw_update.path, pkt.image_file_remote_path.path.data, pkt.image_file_remote_path.path.len);
        fw_update.path[pkt.image_file_remote_path.path.len] = 0;
        fw_update.node_id = pkt.source_node_id;
        if (fw_update.node_id == 0) {
            fw_update.node_id = transfer->source_node_id;
        }
    }

    uint8_t buffer[UAVCAN_PROTOCOL_FILE_BEGINFIRMWAREUPDATE_RESPONSE_MAX_SIZE];
    uavcan_protocol_file_BeginFirmwareUpdateResponse reply {};
    reply.error = UAVCAN_PROTOCOL_FILE_BEGINFIRMWAREUPDATE_RESPONSE_ERROR_OK;

    uint32_t total_size = uavcan_protocol_file_BeginFirmwareUpdateResponse_encode(&reply, buffer, true);
    canardRequestOrRespond(ins,
                           transfer->source_node_id,
                           UAVCAN_PROTOCOL_FILE_BEGINFIRMWAREUPDATE_SIGNATURE,
                           UAVCAN_PROTOCOL_FILE_BEGINFIRMWAREUPDATE_ID,
                           &transfer->transfer_id,
                           transfer->priority,
                           CanardResponse,
                           &buffer[0],
                           total_size);
}

static void handle_allocation_response(CanardInstance* ins, CanardRxTransfer* transfer)
{
    // Rule C - updating the randomized time interval
    send_next_node_id_allocation_request_at_ms =
        AP_HAL::millis() + UAVCAN_PROTOCOL_DYNAMIC_NODE_ID_ALLOCATION_MIN_REQUEST_PERIOD_MS +
        get_random_range(UAVCAN_PROTOCOL_DYNAMIC_NODE_ID_ALLOCATION_MAX_FOLLOWUP_DELAY_MS);

    if (transfer->source_node_id == CANARD_BROADCAST_NODE_ID)
    {
        node_id_allocation_unique_id_offset = 0;
        return;
    }

    struct uavcan_protocol_dynamic_node_id_Allocation msg;
    if (uavcan_protocol_dynamic_node_id_Allocation_decode(transfer, &msg)) {
        return;
    }
    
    // Obtaining the local unique ID
    uint8_t my_unique_id[sizeof(uavcan_protocol_dynamic_node_id_Allocation::unique_id.data)];
    readUniqueID(my_unique_id);

    // Matching the received UID against the local one
    if (memcmp(msg.unique_id.data, my_unique_id, msg.unique_id.len) != 0) {
        node_id_allocation_unique_id_offset = 0;
        return;         // No match, return
    }

    if (msg.unique_id.len < sizeof(msg.unique_id.data)) {
        // The allocator has confirmed part of unique ID, switching to the next stage and updating the timeout.
        node_id_allocation_unique_id_offset = msg.unique_id.len;
        send_next_node_id_allocation_request_at_ms -= UAVCAN_PROTOCOL_DYNAMIC_NODE_ID_ALLOCATION_MIN_REQUEST_PERIOD_MS;
    } else {
        // Allocation complete - copying the allocated node ID from the message
        canardSetLocalNodeID(ins, msg.node_id);
    }
}

/**
 * This callback is invoked by the library when a new message or request or response is received.
 */
static void onTransferReceived(CanardInstance* ins,
                               CanardRxTransfer* transfer)
{
    /*
     * Dynamic node ID allocation protocol.
     * Taking this branch only if we don't have a node ID, ignoring otherwise.
     */
    if (canardGetLocalNodeID(ins) == CANARD_BROADCAST_NODE_ID) {
        if (transfer->transfer_type == CanardTransferTypeBroadcast &&
            transfer->data_type_id == UAVCAN_PROTOCOL_DYNAMIC_NODE_ID_ALLOCATION_ID) {
            handle_allocation_response(ins, transfer);
        }
        return;
    }

    switch (transfer->data_type_id) {
    case UAVCAN_PROTOCOL_GETNODEINFO_ID:
        handle_get_node_info(ins, transfer);
        break;

    case UAVCAN_PROTOCOL_FILE_BEGINFIRMWAREUPDATE_ID:
        handle_begin_firmware_update(ins, transfer);
        break;

    case UAVCAN_PROTOCOL_FILE_READ_ID:
        handle_file_read_response(ins, transfer);
        break;

    case UAVCAN_PROTOCOL_RESTARTNODE_ID:
        NVIC_SystemReset();
        break;
    }
}


/**
 * This callback is invoked by the library when it detects beginning of a new transfer on the bus that can be received
 * by the local node.
 * If the callback returns true, the library will receive the transfer.
 * If the callback returns false, the library will ignore the transfer.
 * All transfers that are addressed to other nodes are always ignored.
 */
static bool shouldAcceptTransfer(const CanardInstance* ins,
                                 uint64_t* out_data_type_signature,
                                 uint16_t data_type_id,
                                 CanardTransferType transfer_type,
                                 uint8_t source_node_id)
{
    (void)source_node_id;

    if (canardGetLocalNodeID(ins) == CANARD_BROADCAST_NODE_ID) {
        /*
         * If we're in the process of allocation of dynamic node ID, accept only relevant transfers.
         */
        if ((transfer_type == CanardTransferTypeBroadcast) &&
            (data_type_id == UAVCAN_PROTOCOL_DYNAMIC_NODE_ID_ALLOCATION_ID))
        {
            *out_data_type_signature = UAVCAN_PROTOCOL_DYNAMIC_NODE_ID_ALLOCATION_SIGNATURE;
            return true;
        }
        return false;
    }

    switch (data_type_id) {
    case UAVCAN_PROTOCOL_GETNODEINFO_ID:
        *out_data_type_signature = UAVCAN_PROTOCOL_GETNODEINFO_SIGNATURE;
        return true;
    case UAVCAN_PROTOCOL_FILE_BEGINFIRMWAREUPDATE_ID:
        *out_data_type_signature = UAVCAN_PROTOCOL_FILE_BEGINFIRMWAREUPDATE_SIGNATURE;
        return true;
    case UAVCAN_PROTOCOL_RESTARTNODE_ID:
        *out_data_type_signature = UAVCAN_PROTOCOL_RESTARTNODE_SIGNATURE;
        return true;
    case UAVCAN_PROTOCOL_FILE_READ_ID:
        *out_data_type_signature = UAVCAN_PROTOCOL_FILE_READ_SIGNATURE;
        return true;
    default:
        break;
    }

    return false;
}

#if HAL_USE_CAN
static void processTx(void)
{
    static uint8_t fail_count;
    for (const CanardCANFrame* txf = NULL; (txf = canardPeekTxQueue(&canard)) != NULL;) {
        CANTxFrame txmsg {};
        txmsg.DLC = txf->data_len;
        memcpy(txmsg.data8, txf->data, 8);
        txmsg.EID = txf->id & CANARD_CAN_EXT_ID_MASK;
        txmsg.IDE = 1;
        txmsg.RTR = 0;
        if (canTransmit(&CAND1, CAN_ANY_MAILBOX, &txmsg, TIME_IMMEDIATE) == MSG_OK) {
            canardPopTxQueue(&canard);
            fail_count = 0;
        } else {
            // just exit and try again later. If we fail 8 times in a row
            // then start discarding to prevent the pool filling up
            if (fail_count < 8) {
                fail_count++;
            } else {
                canardPopTxQueue(&canard);
            }
            return;
        }
    }
}

static void processRx(void)
{
    CANRxFrame rxmsg {};
    while (canReceive(&CAND1, CAN_ANY_MAILBOX, &rxmsg, TIME_IMMEDIATE) == MSG_OK) {
        CanardCANFrame rx_frame {};

#ifdef HAL_GPIO_PIN_LED_BOOTLOADER
        palToggleLine(HAL_GPIO_PIN_LED_BOOTLOADER);
#endif
        const uint64_t timestamp = AP_HAL::micros64();
        memcpy(rx_frame.data, rxmsg.data8, 8);
        rx_frame.data_len = rxmsg.DLC;
        if(rxmsg.IDE) {
            rx_frame.id = CANARD_CAN_FRAME_EFF | rxmsg.EID;
        } else {
            rx_frame.id = rxmsg.SID;
        }
        canardHandleRxFrame(&canard, &rx_frame, timestamp);
    }
}
#else
// Use HAL CAN interface
static void processTx(void)
{
    static uint8_t fail_count;
    for (const CanardCANFrame* txf = NULL; (txf = canardPeekTxQueue(&canard)) != NULL;) {
        AP_HAL::CANFrame txmsg {};
        txmsg.dlc = txf->data_len;
        memcpy(txmsg.data, txf->data, 8);
        txmsg.id = (txf->id | AP_HAL::CANFrame::FlagEFF);
        // push message with 1s timeout
        bool send_ok = false;
        for (uint8_t i=0; i<HAL_NUM_CAN_IFACES; i++) {
            send_ok |= (can_iface[i].send(txmsg, AP_HAL::micros64() + 1000000, 0) > 0);
        }
        if (send_ok) {
            canardPopTxQueue(&canard);
            fail_count = 0;
        } else {
            // just exit and try again later. If we fail 8 times in a row
            // then start discarding to prevent the pool filling up
            if (fail_count < 8) {
                fail_count++;
            } else {
                canardPopTxQueue(&canard);
            }
            return;
        }
    }
}

static void processRx(void)
{
    AP_HAL::CANFrame rxmsg;
    while (true) {
        bool got_pkt = false;
        for (uint8_t i=0; i<HAL_NUM_CAN_IFACES; i++) {
            bool read_select = true;
            bool write_select = false;
            can_iface[i].select(read_select, write_select, nullptr, 0);
            if (!read_select) {
                continue;
            }
#ifdef HAL_GPIO_PIN_LED_BOOTLOADER
            palToggleLine(HAL_GPIO_PIN_LED_BOOTLOADER);
#endif
            CanardCANFrame rx_frame {};

            //palToggleLine(HAL_GPIO_PIN_LED);
            uint64_t timestamp;
            AP_HAL::CANIface::CanIOFlags flags;
            can_iface[i].receive(rxmsg, timestamp, flags);
            memcpy(rx_frame.data, rxmsg.data, 8);
            rx_frame.data_len = rxmsg.dlc;
            rx_frame.id = rxmsg.id;
            canardHandleRxFrame(&canard, &rx_frame, timestamp);
            got_pkt = true;
        }
        if (!got_pkt) {
            break;
        }
    }
}
#endif //#if HAL_USE_CAN

/*
  wrapper around broadcast
 */
static void canard_broadcast(uint64_t data_type_signature,
                             uint16_t data_type_id,
                             uint8_t &transfer_id,
                             uint8_t priority,
                             const void* payload,
                             uint16_t payload_len)
{
#if CH_CFG_USE_MUTEXES == TRUE
    WITH_SEMAPHORE(can_mutex);
#endif
    canardBroadcast(&canard,
                    data_type_signature,
                    data_type_id,
                    &transfer_id,
                    priority,
                    payload,
                    payload_len);
}


/*
  handle waiting for a node ID
 */
static void can_handle_DNA(void)
{
    if (canardGetLocalNodeID(&canard) != CANARD_BROADCAST_NODE_ID) {
        return;
    }

    if (AP_HAL::millis() < send_next_node_id_allocation_request_at_ms) {
        return;
    }

    send_next_node_id_allocation_request_at_ms =
        AP_HAL::millis() + UAVCAN_PROTOCOL_DYNAMIC_NODE_ID_ALLOCATION_MIN_REQUEST_PERIOD_MS +
        get_random_range(UAVCAN_PROTOCOL_DYNAMIC_NODE_ID_ALLOCATION_MAX_FOLLOWUP_DELAY_MS);
    
    // Structure of the request is documented in the DSDL definition
    // See http://uavcan.org/Specification/6._Application_level_functions/#dynamic-node-id-allocation
    uint8_t allocation_request[CANARD_CAN_FRAME_MAX_DATA_LEN - 1];
    allocation_request[0] = (uint8_t)(CANARD_BROADCAST_NODE_ID << 1U);

    if (node_id_allocation_unique_id_offset == 0) {
        allocation_request[0] |= 1;     // First part of unique ID
    }

    uint8_t my_unique_id[sizeof(uavcan_protocol_dynamic_node_id_Allocation::unique_id.data)];
    readUniqueID(my_unique_id);

    static const uint8_t MaxLenOfUniqueIDInRequest = 6;
    uint8_t uid_size = (uint8_t)(sizeof(uavcan_protocol_dynamic_node_id_Allocation::unique_id.data) - node_id_allocation_unique_id_offset);
    if (uid_size > MaxLenOfUniqueIDInRequest) {
        uid_size = MaxLenOfUniqueIDInRequest;
    }

    memmove(&allocation_request[1], &my_unique_id[node_id_allocation_unique_id_offset], uid_size);

    // Broadcasting the request
    canard_broadcast(UAVCAN_PROTOCOL_DYNAMIC_NODE_ID_ALLOCATION_SIGNATURE,
                     UAVCAN_PROTOCOL_DYNAMIC_NODE_ID_ALLOCATION_ID,
                     node_id_allocation_transfer_id,
                     CANARD_TRANSFER_PRIORITY_LOW,
                     &allocation_request[0],
                     (uint16_t) (uid_size + 1));

    // Preparing for timeout; if response is received, this value will be updated from the callback.
    node_id_allocation_unique_id_offset = 0;
}

static void send_node_status(void)
{
    uint8_t buffer[UAVCAN_PROTOCOL_NODESTATUS_MAX_SIZE];
    node_status.uptime_sec = AP_HAL::millis() / 1000U;

    uint32_t len = uavcan_protocol_NodeStatus_encode(&node_status, buffer, true);

    static uint8_t transfer_id;  // Note that the transfer ID variable MUST BE STATIC (or heap-allocated)!

    canard_broadcast(UAVCAN_PROTOCOL_NODESTATUS_SIGNATURE,
                     UAVCAN_PROTOCOL_NODESTATUS_ID,
                     transfer_id,
                     CANARD_TRANSFER_PRIORITY_LOW,
                     buffer,
                     len);
}


/**
 * This function is called at 1 Hz rate from the main loop.
 */
static void process1HzTasks(uint64_t timestamp_usec)
{
    canardCleanupStaleTransfers(&canard, timestamp_usec);

    if (canardGetLocalNodeID(&canard) != CANARD_BROADCAST_NODE_ID) {
        node_status.mode = fw_update.node_id?UAVCAN_PROTOCOL_NODESTATUS_MODE_SOFTWARE_UPDATE:UAVCAN_PROTOCOL_NODESTATUS_MODE_MAINTENANCE;
        send_node_status();
    }
}

void can_set_node_id(uint8_t node_id)
{
    initial_node_id = node_id;
}

// check for a firmware update marker left by app
bool can_check_update(void)
{
    bool ret = false;
#if HAL_RAM_RESERVE_START >= 256
    struct app_bootloader_comms *comms = (struct app_bootloader_comms *)HAL_RAM0_START;
    if (comms->magic == APP_BOOTLOADER_COMMS_MAGIC && comms->my_node_id != 0) {
        can_set_node_id(comms->my_node_id);
        fw_update.node_id = comms->server_node_id;
        for (uint8_t i=0; i<FW_UPDATE_PIPELINE_LEN; i++) {
            fw_update.reads[i].offset = i*sizeof(uavcan_protocol_file_ReadResponse::data.data);
        }
        memcpy(fw_update.path, comms->path, sizeof(uavcan_protocol_file_Path::path.data)+1);
        ret = true;
        // clear comms region
        memset(comms, 0, sizeof(struct app_bootloader_comms));
    }
#endif
#if defined(CAN1_BASE) && defined(RCC_APB1ENR_CAN1EN)
    // check for px4 fw update. px4 uses the filter registers in CAN1
    // to communicate with the bootloader. This only works on CAN1
    if (!ret && stm32_was_software_reset()) {
        uint32_t *fir = (uint32_t *)(CAN1_BASE + 0x240);
        struct PACKED app_shared {
            union {
                uint64_t ull;
                uint32_t ul[2];
                uint8_t  valid;
            } crc;
            uint32_t signature;
            uint32_t bus_speed;
            uint32_t node_id;
        } *app = (struct app_shared *)&fir[4];
        /* we need to enable the CAN peripheral in order to look at
           the FIR registers.
        */
        RCC->APB1ENR |= RCC_APB1ENR_CAN1EN;
        static const uint32_t app_signature = 0xb0a04150;
        if (app->signature == app_signature &&
            app->node_id > 0 && app->node_id < 128) {
            // crc is in reversed word order in FIR registers
            uint32_t sig[3];
            memcpy((uint8_t *)&sig[0], (const uint8_t *)&app->signature, sizeof(sig));
            const uint64_t crc = crc_crc64(sig, 3);
            const uint32_t *crc32 = (const uint32_t *)&crc;
            if (crc32[0] == app->crc.ul[1] &&
                crc32[1] == app->crc.ul[0]) {
                // reset signature so we don't get in a boot loop
                app->signature = 0;
                // setup node ID
                can_set_node_id(app->node_id);
                // and baudrate
                baudrate = app->bus_speed;
                ret = true;
            }
        }
    }
#endif
    return ret;
}

void can_start()
{
    node_status.vendor_specific_status_code = uint8_t(check_good_firmware());
    node_status.mode = UAVCAN_PROTOCOL_NODESTATUS_MODE_MAINTENANCE;

#if HAL_USE_CAN
    // calculate optimal CAN timings given PCLK1 and baudrate
    CanardSTM32CANTimings timings {};
    canardSTM32ComputeCANTimings(STM32_PCLK1, baudrate, &timings);
    cancfg.btr = CAN_BTR_SJW(0) |
        CAN_BTR_TS2(timings.bit_segment_2-1) |
        CAN_BTR_TS1(timings.bit_segment_1-1) |
        CAN_BTR_BRP(timings.bit_rate_prescaler-1);
    canStart(&CAND1, &cancfg);
#else
    for (uint8_t i=0; i<HAL_NUM_CAN_IFACES; i++) {
        can_iface[i].init(baudrate, AP_HAL::CANIface::NormalMode);
    }
#endif
    canardInit(&canard, (uint8_t *)canard_memory_pool, sizeof(canard_memory_pool),
               onTransferReceived, shouldAcceptTransfer, NULL);

    if (initial_node_id != CANARD_BROADCAST_NODE_ID) {
        canardSetLocalNodeID(&canard, initial_node_id);
    }

    send_next_node_id_allocation_request_at_ms =
        AP_HAL::millis() + UAVCAN_PROTOCOL_DYNAMIC_NODE_ID_ALLOCATION_MIN_REQUEST_PERIOD_MS +
        get_random_range(UAVCAN_PROTOCOL_DYNAMIC_NODE_ID_ALLOCATION_MAX_FOLLOWUP_DELAY_MS);

    if (stm32_was_watchdog_reset()) {
        node_status.vendor_specific_status_code = uint8_t(check_fw_result_t::FAIL_REASON_WATCHDOG);
    }
}


void can_update()
{
    // do one loop of CAN support. If we are doing a firmware update
    // then loop until it is finished
    do {
        processTx();
        processRx();
        can_handle_DNA();
        static uint32_t last_1Hz_ms;
        uint32_t now = AP_HAL::millis();
        if (now - last_1Hz_ms >= 1000) {
            last_1Hz_ms = now;
            process1HzTasks(AP_HAL::micros64());
        }
        if (fw_update.node_id != 0) {
            send_fw_reads();
        }
#if CH_CFG_ST_FREQUENCY >= 1000000
        // give a bit of time for background processing
        chThdSleepMicroseconds(200);
#endif
    } while (fw_update.node_id != 0);
}

// printf to CAN LogMessage for debugging
void can_printf(const char *fmt, ...)
{
    // only on H7 for now, where we have plenty of flash
#if defined(STM32H7)
    uavcan_protocol_debug_LogMessage pkt {};
    uint8_t buffer[UAVCAN_PROTOCOL_DEBUG_LOGMESSAGE_MAX_SIZE];
    va_list ap;
    va_start(ap, fmt);
    uint32_t n = vsnprintf((char*)pkt.text.data, sizeof(pkt.text.data), fmt, ap);
    va_end(ap);
    pkt.text.len = MIN(n, sizeof(pkt.text.data));

    uint32_t len = uavcan_protocol_debug_LogMessage_encode(&pkt, buffer, true);
    static uint8_t logmsg_transfer_id;

    canard_broadcast(UAVCAN_PROTOCOL_DEBUG_LOGMESSAGE_SIGNATURE,
                     UAVCAN_PROTOCOL_DEBUG_LOGMESSAGE_ID,
                     logmsg_transfer_id,
                     CANARD_TRANSFER_PRIORITY_LOW,
                     buffer,
                     len);
#endif // defined(STM32H7)
}


#endif // HAL_USE_CAN
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         void can_start();
void can_update();
void can_set_node_id(uint8_t node_id);
bool can_check_update(void);
void can_printf(const char *fmt, ...);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                /*
  custom code for specific boards
 */
#include <AP_HAL/AP_HAL.h>
#include "ch.h"
#include "hal.h"
#include "support.h"

#ifdef AP_BOOTLOADER_CUSTOM_HERE4
/*
  reset here4 LEDs
*/
static void bootloader_custom_Here4(void)
{
    for (uint8_t n=0; n<10; n++) {
        const uint8_t num_leds = 4;
        const uint32_t min_bits = num_leds*25+50;
        const uint8_t num_leading_zeros = 8-min_bits%8 + 50;
        const uint32_t output_stream_byte_length = (min_bits+7)/8;
        palSetLineMode(HAL_GPIO_PIN_LED_DI, PAL_MODE_OUTPUT_PUSHPULL);
        palSetLineMode(HAL_GPIO_PIN_LED_SCK, PAL_MODE_OUTPUT_PUSHPULL);
        int l = 100;
        while (l--) {
            for (uint32_t i=0; i<output_stream_byte_length; i++) {
                for (uint8_t bit = 0; bit < 8; bit++) {
                    uint32_t out_bit_idx = i*8+bit;
                    uint8_t bit_val;
                    if (out_bit_idx < num_leading_zeros) {
                        bit_val = 0;
                    } else if ((out_bit_idx-num_leading_zeros) % 25 == 0) {
                        bit_val = 1;
                    } else {
                        bit_val = 0;
                    }

                    palClearLine(HAL_GPIO_PIN_LED_SCK);
                    palWriteLine(HAL_GPIO_PIN_LED_DI, bit_val);
                    palSetLine(HAL_GPIO_PIN_LED_SCK);
                }
            }
        }
        chThdSleepMilliseconds(10);
    }
}
#endif // AP_BOOTLOADER_CUSTOM_HERE4

void custom_startup(void)
{
#ifdef AP_BOOTLOADER_CUSTOM_HERE4
    bootloader_custom_Here4();
#endif
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             # Copyright (C) 2016  Intel Corporation. All rights reserved.
#
# This file is free software: you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This file is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program.  If not, see <http://www.gnu.org/licenses/>.
"""
WAF Tool that checks cxx parameters, creating the ap_config.h
header file.

This tool needs compiler_cxx to be loaded, make sure you
load them before this tool.

Example::
    def configure(cfg):
        cfg.load('cxx_checks')
"""

from waflib.Configure import conf

@conf
def ap_common_checks(cfg):
    cfg.check(
        compiler='cxx',
        fragment='''
        #include <cmath>

        int main() {
          return std::isfinite(1.0f);
        }''',
        define_name="HAVE_CMATH_ISFINITE",
        msg="Checking for HAVE_CMATH_ISFINITE",
        mandatory=False,
    )

    cfg.check(
        compiler='cxx',
        fragment='''
        #include <cmath>

        int main() {
          return std::isinf(1.0f);
        }''',
        define_name="HAVE_CMATH_ISINF",
        msg="Checking for HAVE_CMATH_ISINF",
        mandatory=False,
    )

    cfg.check(
        compiler='cxx',
        fragment='''
        #include <cmath>

        int main() {
          return std::isnan(1.0f);
        }''',
        define_name="HAVE_CMATH_ISNAN",
        msg="Checking for HAVE_CMATH_ISNAN",
        mandatory=False,
    )

    # NEED_CMATH_FUNCTION_STD_NAMESPACE checks are needed due to
    # new gcc versions being more restrictive.
    #
    # Here we check if we need to add 'using std::function' to
    # the function.
    #
    # Without these checks, in some cases, gcc points this as
    # overloads or function duplication in scope.

    cfg.check(
        compiler='cxx',
        fragment='''
        #include <math.h>
        #include <cmath>

        using std::isfinite;

        int main() {
          return isfinite((double)1);
        }''',
        define_name="NEED_CMATH_ISFINITE_STD_NAMESPACE",
        msg="Checking for NEED_CMATH_ISFINITE_STD_NAMESPACE",
        mandatory=False,
    )

    cfg.check(
        compiler='cxx',
        fragment='''
        #include <math.h>
        #include <cmath>

        using std::isinf;

        int main() {
          return isinf((double)1);
        }''',
        define_name="NEED_CMATH_ISINF_STD_NAMESPACE",
        msg="Checking for NEED_CMATH_ISINF_STD_NAMESPACE",
        mandatory=False,
    )

    cfg.check(
        compiler='cxx',
        fragment='''
        #include <math.h>
        #include <cmath>

        using std::isnan;

        int main() {
          return isnan((double)1);
        }''',
        define_name="NEED_CMATH_ISNAN_STD_NAMESPACE",
        msg="Checking for NEED_CMATH_ISNAN_STD_NAMESPACE",
        mandatory=False,
    )

    cfg.check(header_name='endian.h', mandatory=False)

    cfg.check(header_name='byteswap.h', mandatory=False)

    cfg.check(
        compiler='cxx',
        fragment='''
        #include <string.h>
        int main() {
        const char *s = "abc";
          return memrchr((const void *)s, 0, 3) != NULL;
        }''',
        define_name="HAVE_MEMRCHR",
        msg="Checking for HAVE_MEMRCHR",
        mandatory=False,
    )

@conf
def check_librt(cfg, env):
    if cfg.env.DEST_OS == 'darwin':
        return True

    ret = cfg.check(
        compiler='cxx',
        fragment='''
        #include <time.h>

        int main() {
            clock_gettime(CLOCK_REALTIME, NULL);
        }''',
        msg='Checking for need to link with librt',
        okmsg='not necessary',
        errmsg='necessary',
        mandatory=False,
    )

    if ret:
        return ret

    ret = cfg.check(compiler='cxx', lib='rt')
    if ret:
        env.LIB += cfg.env['LIB_RT']

    return ret

@conf
def check_feenableexcept(cfg):

    cfg.check(
        compiler='cxx',
        fragment='''
        #include <fenv.h>

        int main() {
            return feenableexcept(FE_OVERFLOW | FE_DIVBYZERO);
        }''',
        msg="Checking for feenableexcept",
        define_name="HAVE_FEENABLEEXCEPT",
        mandatory=False,
    )

@conf
def check_package(cfg, env, libname):
    '''use pkg-config to look for an installed library that has a LIBNAME.pc file'''
    capsname = libname.upper()

    cfg.env.stash()

    if not cfg.check_cfg(package=libname, mandatory=False, global_define=True,
                         args=['--libs', '--cflags'], uselib_store=capsname):
        # Don't even try to link if check_cfg fails
        cfg.env.revert()
        return False

    if not cfg.check(compiler='cxx',
            fragment='''int main() { return 0; }''',
            msg='Checking link with %s' % libname,
            mandatory=False,
            use=capsname):
        cfg.env.revert()
        return False

    cfg.env.commit()

    # Add to global environment:
    # we always want to use the library for all targets
    env.LIB += cfg.env['LIB_%s' % capsname]
    env.INCLUDES += cfg.env['INCLUDES_%s' % capsname]
    env.CFLAGS += cfg.env['CFLAGS_%s' % capsname]
    env.LIBPATH += cfg.env['LIBPATH_%s' % capsname]

    return True

@conf
def check_lttng(cfg, env):
    if not cfg.options.enable_lttng:
        cfg.msg("Checking for 'lttng-ust':", 'disabled', color='YELLOW')
        return False
    if cfg.env.STATIC_LINKING:
        # lttng-ust depends on libdl which means it can't be used in a static build
        cfg.msg("Checking for 'lttng-ust':", 'disabled for static build', color='YELLOW')
        return False

    return check_package(cfg, env, 'lttng-ust')

@conf
def check_libiio(cfg, env):
    if cfg.env.STATIC_LINKING:
        # libiio depends on libdl which means it can't be used in a static build
        cfg.msg("Checking for 'libiio':", 'disabled for static build', color='YELLOW')
        return False
    if cfg.options.disable_libiio:
        cfg.msg("Checking for 'libiio':", 'disabled', color='YELLOW')
        return False

    return check_package(cfg, env, 'libiio')

@conf
def check_libdl(cfg, env):
    if cfg.env.STATIC_LINKING:
        # using loadable modules for a static build is not recommended
        cfg.msg("Checking for 'libdl':", 'disabled for static build', color='YELLOW')
        return False
    ret = cfg.check(compiler='cxx', lib='dl', mandatory=False, global_define=True, define_name='HAVE_LIBDL')
    if ret:
        env.LIB += cfg.env['LIB_DL']
    return ret

@conf
def check_SFML(cfg, env):
    if not cfg.options.enable_sfml:
        cfg.msg("Checking for SFML graphics:", 'disabled', color='YELLOW')
        return False
    libs = ['sfml-graphics', 'sfml-window','sfml-system']
    for lib in libs:
        if not cfg.check(compiler='cxx', lib=lib, mandatory=False,
                         global_define=True):
            cfg.fatal("Missing SFML libraries - please install libsfml-dev")
            return False

    # see if we need Graphics.hpp or Graphics.h
    if not cfg.check(compiler='cxx',
                     fragment='''#include <SFML/Graphics.hpp>\nint main() {}''', define_name="HAVE_SFML_GRAPHICS_HPP",
                     msg="Checking for Graphics.hpp", mandatory=False):
        if not cfg.check(compiler='cxx', fragment='''#include <SFML/Graphics.h>\nint main() {}''', define_name="HAVE_SFML_GRAPHICS_H",
                         msg="Checking for Graphics.h", mandatory=False):
            cfg.fatal("Missing SFML headers SFML/Graphics.hpp or SFML/Graphics.h")
            return False
    env.LIB += libs
    return True


@conf
def check_SFML_Audio(cfg, env):
    if not cfg.options.enable_sfml_audio:
        cfg.msg("Checking for SFML audio:", 'disabled', color='YELLOW')
        return False
    libs = ['sfml-audio']
    for lib in libs:
        if not cfg.check(compiler='cxx', l