[[DIA_X, ODI_X, ODI_Y], [ODI_X, DIA_Y, ODI_Z], [ODI_Y, ODI_Z, DIA_Z]]
    // @User: Advanced
    // @Calibration: 1

    // @Param: ODI_Y
    // @DisplayName: Compass soft-iron off-diagonal Y component
    // @Description: ODI_Y in the compass soft-iron calibration matrix: [[DIA_X, ODI_X, ODI_Y], [ODI_X, DIA_Y, ODI_Z], [ODI_Y, ODI_Z, DIA_Z]]
    // @User: Advanced
    // @Calibration: 1

    // @Param: ODI_Z
    // @DisplayName: Compass soft-iron off-diagonal Z component
    // @Description: ODI_Z in the compass soft-iron calibration matrix: [[DIA_X, ODI_X, ODI_Y], [ODI_X, DIA_Y, ODI_Z], [ODI_Y, ODI_Z, DIA_Z]]
    // @User: Advanced
    AP_GROUPINFO("ODI",    25, Compass, _state._priv_instance[0].offdiagonals, 0),

#if COMPASS_MAX_INSTANCES > 1
    // @Param: DIA2_X
    // @DisplayName: Compass2 soft-iron diagonal X component
    // @Description: DIA_X in the compass2 soft-iron calibration matrix: [[DIA_X, ODI_X, ODI_Y], [ODI_X, DIA_Y, ODI_Z], [ODI_Y, ODI_Z, DIA_Z]]
    // @User: Advanced
    // @Calibration: 1

    // @Param: DIA2_Y
    // @DisplayName: Compass2 soft-iron diagonal Y component
    // @Description: DIA_Y in the compass2 soft-iron calibration matrix: [[DIA_X, ODI_X, ODI_Y], [ODI_X, DIA_Y, ODI_Z], [ODI_Y, ODI_Z, DIA_Z]]
    // @User: Advanced
    // @Calibration: 1

    // @Param: DIA2_Z
    // @DisplayName: Compass2 soft-iron diagonal Z component
    // @Description: DIA_Z in the compass2 soft-iron calibration matrix: [[DIA_X, ODI_X, ODI_Y], [ODI_X, DIA_Y, ODI_Z], [ODI_Y, ODI_Z, DIA_Z]]
    // @User: Advanced
    AP_GROUPINFO("DIA2",    26, Compass, _state._priv_instance[1].diagonals, 1.0),

    // @Param: ODI2_X
    // @DisplayName: Compass2 soft-iron off-diagonal X component
    // @Description: ODI_X in the compass2 soft-iron calibration matrix: [[DIA_X, ODI_X, ODI_Y], [ODI_X, DIA_Y, ODI_Z], [ODI_Y, ODI_Z, DIA_Z]]
    // @User: Advanced
    // @Calibration: 1

    // @Param: ODI2_Y
    // @DisplayName: Compass2 soft-iron off-diagonal Y component
    // @Description: ODI_Y in the compass2 soft-iron calibration matrix: [[DIA_X, ODI_X, ODI_Y], [ODI_X, DIA_Y, ODI_Z], [ODI_Y, ODI_Z, DIA_Z]]
    // @User: Advanced
    // @Calibration: 1

    // @Param: ODI2_Z
    // @DisplayName: Compass2 soft-iron off-diagonal Z component
    // @Description: ODI_Z in the compass2 soft-iron calibration matrix: [[DIA_X, ODI_X, ODI_Y], [ODI_X, DIA_Y, ODI_Z], [ODI_Y, ODI_Z, DIA_Z]]
    // @User: Advanced
    AP_GROUPINFO("ODI2",    27, Compass, _state._priv_instance[1].offdiagonals, 0),
#endif // COMPASS_MAX_INSTANCES

#if COMPASS_MAX_INSTANCES > 2
    // @Param: DIA3_X
    // @DisplayName: Compass3 soft-iron diagonal X component
    // @Description: DIA_X in the compass3 soft-iron calibration matrix: [[DIA_X, ODI_X, ODI_Y], [ODI_X, DIA_Y, ODI_Z], [ODI_Y, ODI_Z, DIA_Z]]
    // @User: Advanced
    // @Calibration: 1

    // @Param: DIA3_Y
    // @DisplayName: Compass3 soft-iron diagonal Y component
    // @Description: DIA_Y in the compass3 soft-iron calibration matrix: [[DIA_X, ODI_X, ODI_Y], [ODI_X, DIA_Y, ODI_Z], [ODI_Y, ODI_Z, DIA_Z]]
    // @User: Advanced
    // @Calibration: 1

    // @Param: DIA3_Z
    // @DisplayName: Compass3 soft-iron diagonal Z component
    // @Description: DIA_Z in the compass3 soft-iron calibration matrix: [[DIA_X, ODI_X, ODI_Y], [ODI_X, DIA_Y, ODI_Z], [ODI_Y, ODI_Z, DIA_Z]]
    // @User: Advanced
    AP_GROUPINFO("DIA3",    28, Compass, _state._priv_instance[2].diagonals, 1.0),

    // @Param: ODI3_X
    // @DisplayName: Compass3 soft-iron off-diagonal X component
    // @Description: ODI_X in the compass3 soft-iron calibration matrix: [[DIA_X, ODI_X, ODI_Y], [ODI_X, DIA_Y, ODI_Z], [ODI_Y, ODI_Z, DIA_Z]]
    // @User: Advanced
    // @Calibration: 1

    // @Param: ODI3_Y
    // @DisplayName: Compass3 soft-iron off-diagonal Y component
    // @Description: ODI_Y in the compass3 soft-iron calibration matrix: [[DIA_X, ODI_X, ODI_Y], [ODI_X, DIA_Y, ODI_Z], [ODI_Y, ODI_Z, DIA_Z]]
    // @User: Advanced
    // @Calibration: 1

    // @Param: ODI3_Z
    // @DisplayName: Compass3 soft-iron off-diagonal Z component
    // @Description: ODI_Z in the compass3 soft-iron calibration matrix: [[DIA_X, ODI_X, ODI_Y], [ODI_X, DIA_Y, ODI_Z], [ODI_Y, ODI_Z, DIA_Z]]
    // @User: Advanced
    AP_GROUPINFO("ODI3",    29, Compass, _state._priv_instance[2].offdiagonals, 0),
#endif // COMPASS_MAX_INSTANCES
#endif // AP_COMPASS_DIAGONALS_ENABLED

#if COMPASS_CAL_ENABLED
    // @Param: CAL_FIT
    // @DisplayName: Compass calibration fitness
    // @Description: This controls the fitness level required for a successful compass calibration. A lower value makes for a stricter fit (less likely to pass). This is the value used for the primary magnetometer. Other magnetometers get double the value.
    // @Range: 4 32
    // @Values: 4:Very Strict,8:Strict,16:Default,32:Relaxed
    // @Increment: 0.1
    // @User: Advanced
    AP_GROUPINFO("CAL_FIT", 30, Compass, _calibration_threshold, AP_COMPASS_CALIBRATION_FITNESS_DEFAULT),
#endif

#ifndef HAL_BUILD_AP_PERIPH
    // @Param: OFFS_MAX
    // @DisplayName: Compass maximum offset
    // @Description: This sets the maximum allowed compass offset in calibration and arming checks
    // @Range: 500 3000
    // @Increment: 1
    // @User: Advanced
    AP_GROUPINFO("OFFS_MAX", 31, Compass, _offset_max, AP_COMPASS_OFFSETS_MAX_DEFAULT),
#endif

#if COMPASS_MOT_ENABLED
    // @Group: PMOT
    // @Path: Compass_PerMotor.cpp
    AP_SUBGROUPINFO(_per_motor, "PMOT", 32, Compass, Compass_PerMotor),
#endif

    // @Param: DISBLMSK
    // @DisplayName: Compass disable driver type mask
    // @Description: This is a bitmask of driver types to disable. If a driver type is set in this mask then that driver will not try to find a sensor at startup
    // @Bitmask: 0:HMC5883,1:LSM303D,2:AK8963,3:BMM150,4:LSM9DS1,5:LIS3MDL,6:AK09916,7:IST8310,8:ICM20948,9:MMC3416,11:DroneCAN,12:QMC5883,14:MAG3110,15:IST8308,16:RM3100,17:MSP,18:ExternalAHRS
    // @User: Advanced
    AP_GROUPINFO("DISBLMSK", 33, Compass, _driver_type_mask, 0),

    // @Param: FLTR_RNG
    // @DisplayName: Range in which sample is accepted
    // @Description: This sets the range around the average value that new samples must be within to be accepted. This can help reduce the impact of noise on sensors that are on long I2C cables. The value is a percentage from the average value. A value of zero disables this filter.
    // @Units: %
    // @Range: 0 100
    // @Increment: 1
    AP_GROUPINFO("FLTR_RNG", 34, Compass, _filter_range, HAL_COMPASS_FILTER_DEFAULT),

#if COMPASS_CAL_ENABLED
    // @Param: AUTO_ROT
    // @DisplayName: Automatically check orientation
    // @Description: When enabled this will automatically check the orientation of compasses on successful completion of compass calibration. If set to 2 then external compasses will have their orientation automatically corrected.
    // @Values: 0:Disabled,1:CheckOnly,2:CheckAndFix,3:use same tolerance to auto rotate 45 deg rotations
    AP_GROUPINFO("AUTO_ROT", 35, Compass, _rotate_auto, HAL_COMPASS_AUTO_ROT_DEFAULT),
#endif

#if COMPASS_MAX_INSTANCES > 1
    // @Param: PRIO1_ID
    // @DisplayName: Compass device id with 1st order priority
    // @Description: Compass device id with 1st order priority, set automatically if 0. Reboot required after change.
    // @RebootRequired: True
    // @User: Advanced
    AP_GROUPINFO("PRIO1_ID",  36, Compass, _priority_did_stored_list._priv_instance[0], 0),

    // @Param: PRIO2_ID
    // @DisplayName: Compass device id with 2nd order priority
    // @Description: Compass device id with 2nd order priority, set automatically if 0. Reboot required after change.
    // @RebootRequired: True
    // @User: Advanced
    AP_GROUPINFO("PRIO2_ID", 37, Compass, _priority_did_stored_list._priv_instance[1], 0),
#endif // COMPASS_MAX_INSTANCES

#if COMPASS_MAX_INSTANCES > 2
    // @Param: PRIO3_ID
    // @DisplayName: Compass device id with 3rd order priority
    // @Description: Compass device id with 3rd order priority, set automatically if 0. Reboot required after change.
    // @RebootRequired: True
    // @User: Advanced
    AP_GROUPINFO("PRIO3_ID", 38, Compass, _priority_did_stored_list._priv_instance[2], 0),
#endif // COMPASS_MAX_INSTANCES

    // @Param: ENABLE
    // @DisplayName: Enable Compass
    // @Description: Setting this to Enabled(1) will enable the compass. Setting this to Disabled(0) will disable the compass. Note that this is separate from COMPASS_USE. This will enable the low level senor, and will enable logging of magnetometer data. To use the compass for navigation you must also set COMPASS_USE to 1.
    // @User: Standard
    // @RebootRequired: True
    // @Values: 0:Disabled,1:Enabled
    AP_GROUPINFO("ENABLE", 39, Compass, _enabled, AP_COMPASS_ENABLE_DEFAULT),

#ifndef HAL_BUILD_AP_PERIPH
    // @Param: SCALE
    // @DisplayName: Compass1 scale factor
    // @Description: Scaling factor for first compass to compensate for sensor scaling errors. If this is 0 then no scaling is done
    // @User: Standard
    // @Range: 0 1.3
    AP_GROUPINFO("SCALE", 40, Compass, _state._priv_instance[0].scale_factor, 0),

#if COMPASS_MAX_INSTANCES > 1
    // @Param: SCALE2
    // @DisplayName: Compass2 scale factor
    // @Description: Scaling factor for 2nd compass to compensate for sensor scaling errors. If this is 0 then no scaling is done
    // @User: Standard
    // @Range: 0 1.3
    AP_GROUPINFO("SCALE2", 41, Compass, _state._priv_instance[1].scale_factor, 0),
#endif

#if COMPASS_MAX_INSTANCES > 2
    // @Param: SCALE3
    // @DisplayName: Compass3 scale factor
    // @Description: Scaling factor for 3rd compass to compensate for sensor scaling errors. If this is 0 then no scaling is done
    // @User: Standard
    // @Range: 0 1.3
    AP_GROUPINFO("SCALE3", 42, Compass, _state._priv_instance[2].scale_factor, 0),
#endif
#endif // HAL_BUILD_AP_PERIPH

#ifndef HAL_BUILD_AP_PERIPH
    // @Param: OPTIONS
    // @DisplayName: Compass options
    // @Description: This sets options to change the behaviour of the compass
    // @Bitmask: 0:CalRequireGPS
    // @Bitmask: 1: Allow missing DroneCAN compasses to be automaticaly replaced (calibration still required)
    // @User: Advanced
    AP_GROUPINFO("OPTIONS", 43, Compass, _options, 0),
#endif

#if COMPASS_MAX_UNREG_DEV > 0
    // @Param: DEV_ID4
    // @DisplayName: Compass4 device id
    // @Description: Extra 4th compass's device id.  Automatically detected, do not set manually
    // @ReadOnly: True
    // @User: Advanced
    AP_GROUPINFO("DEV_ID4", 44, Compass, extra_dev_id[0], 0),
#endif // COMPASS_MAX_UNREG_DEV

#if COMPASS_MAX_UNREG_DEV > 1
    // @Param: DEV_ID5
    // @DisplayName: Compass5 device id
    // @Description: Extra 5th compass's device id.  Automatically detected, do not set manually
    // @ReadOnly: True
    // @User: Advanced
    AP_GROUPINFO("DEV_ID5", 45, Compass, extra_dev_id[1], 0),
#endif // COMPASS_MAX_UNREG_DEV

#if COMPASS_MAX_UNREG_DEV > 2
    // @Param: DEV_ID6
    // @DisplayName: Compass6 device id
    // @Description: Extra 6th compass's device id.  Automatically detected, do not set manually
    // @ReadOnly: True
    // @User: Advanced
    AP_GROUPINFO("DEV_ID6", 46, Compass, extra_dev_id[2], 0),
#endif // COMPASS_MAX_UNREG_DEV

#if COMPASS_MAX_UNREG_DEV > 3
    // @Param: DEV_ID7
    // @DisplayName: Compass7 device id
    // @Description: Extra 7th compass's device id.  Automatically detected, do not set manually
    // @ReadOnly: True
    // @User: Advanced
    AP_GROUPINFO("DEV_ID7", 47, Compass, extra_dev_id[3], 0),
#endif // COMPASS_MAX_UNREG_DEV

#if COMPASS_MAX_UNREG_DEV > 4
    // @Param: DEV_ID8
    // @DisplayName: Compass8 device id
    // @Description: Extra 8th compass's device id.  Automatically detected, do not set manually
    // @ReadOnly: True
    // @User: Advanced
    AP_GROUPINFO("DEV_ID8", 48, Compass, extra_dev_id[4], 0),
#endif // COMPASS_MAX_UNREG_DEV

    // @Param: CUS_ROLL
    // @DisplayName: Custom orientation roll offset
    // @Description: Compass mounting position roll offset. Positive values = roll right, negative values = roll left. This parameter is only used when COMPASS_ORIENT/2/3 is set to CUSTOM.
    // @Range: -180 180
    // @Units: deg
    // @Increment: 1
    // @RebootRequired: True
    // @User: Advanced

    // index 49

    // @Param: CUS_PIT
    // @DisplayName: Custom orientation pitch offset
    // @Description: Compass mounting position pitch offset. Positive values = pitch up, negative values = pitch down. This parameter is only used when COMPASS_ORIENT/2/3 is set to CUSTOM.
    // @Range: -180 180
    // @Units: deg
    // @Increment: 1
    // @RebootRequired: True
    // @User: Advanced

    // index 50

    // @Param: CUS_YAW
    // @DisplayName: Custom orientation yaw offset
    // @Description: Compass mounting position yaw offset. Positive values = yaw right, negative values = yaw left. This parameter is only used when COMPASS_ORIENT/2/3 is set to CUSTOM.
    // @Range: -180 180
    // @Units: deg
    // @Increment: 1
    // @RebootRequired: True
    // @User: Advanced

    // index 51

    AP_GROUPEND
};

// Default constructor.
// Note that the Vector/Matrix constructors already implicitly zero
// their values.
//
Compass::Compass(void)
{
    if (_singleton != nullptr) {
#if CONFIG_HAL_BOARD == HAL_BOARD_SITL
        AP_HAL::panic("Compass must be singleton");
#endif
        return;
    }
    _singleton = this;
    AP_Param::setup_object_defaults(this, var_info);
}

// Default init method
//
void Compass::init()
{
    if (!_enabled) {
        return;
    }

    /*
      on init() if any devid is set then we set suppress_devid_save to
      false. This is used to determine if we save device ids during
      the init process.
     */
    suppress_devid_save = true;
    for (uint8_t i=0; i<COMPASS_MAX_INSTANCES; i++) {
        if (_state._priv_instance[i].dev_id != 0) {
            suppress_devid_save = false;
            break;
        }
#if COMPASS_MAX_INSTANCES > 1
        if (_priority_did_stored_list._priv_instance[i] != 0) {
            suppress_devid_save = false;
            break;
        }
#endif
    }

    // convert to new custom rotation method
    // PARAMETER_CONVERSION - Added: Nov-2021
#if AP_CUSTOMROTATIONS_ENABLED
    for (StateIndex i(0); i<COMPASS_MAX_INSTANCES; i++) {
        if (_state[i].orientation != ROTATION_CUSTOM_OLD) {
            continue;
        }
        _state[i].orientation.set_and_save(ROTATION_CUSTOM_2);
        AP_Param::ConversionInfo info;
        if (AP_Param::find_top_level_key_by_pointer(this, info.old_key)) {
            info.type = AP_PARAM_FLOAT;
            float rpy[3] = {};
            AP_Float rpy_param;
            for (info.old_group_element=49; info.old_group_element<=51; info.old_group_element++) {
                if (AP_Param::find_old_parameter(&info, &rpy_param)) {
                    rpy[info.old_group_element-49] = rpy_param.get();
                }
            }
            AP::custom_rotations().convert(ROTATION_CUSTOM_2, rpy[0], rpy[1], rpy[2]);
        }
        break;
    }
#endif  // AP_CUSTOMROTATIONS_ENABLED

#if COMPASS_MAX_INSTANCES > 1
    // Look if there was a primary compass setup in previous version
    // if so and the primary compass is not set in current setup
    // make the devid as primary.
    if (_priority_did_stored_list[Priority(0)] == 0) {
        uint16_t k_param_compass;
        if (AP_Param::find_top_level_key_by_pointer(this, k_param_compass)) {
            const AP_Param::ConversionInfo primary_compass_old_param = {k_param_compass, 12, AP_PARAM_INT8, ""};
            AP_Int8 value;
            value.set(0);
            bool primary_param_exists = AP_Param::find_old_parameter(&primary_compass_old_param, &value);
            int8_t oldvalue = value.get();
            if ((oldvalue!=0) && (oldvalue<COMPASS_MAX_INSTANCES) && primary_param_exists) {
                _priority_did_stored_list[Priority(0)].set_and_save_ifchanged(_state[StateIndex(oldvalue)].dev_id);
            }
        }
    }

    // Load priority list from storage, the changes to priority list
    // by user only take effect post reboot, after this
    if (!suppress_devid_save) {
        for (Priority i(0); i<COMPASS_MAX_INSTANCES; i++) {
            if (_priority_did_stored_list[i] != 0) {
                _priority_did_list[i] = _priority_did_stored_list[i];
            } else {
                // Maintain a list without gaps and duplicates
                for (Priority j(i+1); j<COMPASS_MAX_INSTANCES; j++) {
                    int32_t temp;
                    if (_priority_did_stored_list[j] == _priority_did_stored_list[i]) {
                        _priority_did_stored_list[j].set_and_save_ifchanged(0);
                    }
                    if (_priority_did_stored_list[j] == 0) {
                        continue;
                    }
                    temp = _priority_did_stored_list[j];
                    _priority_did_stored_list[j].set_and_save_ifchanged(0);
                    _priority_did_list[i] = temp;
                    _priority_did_stored_list[i].set_and_save_ifchanged(temp);
                    break;
                }
            }
        }
    }
#endif // COMPASS_MAX_INSTANCES

    // cache expected dev ids for use during runtime detection
    for (StateIndex i(0); i<COMPASS_MAX_INSTANCES; i++) {
        _state[i].expected_dev_id = _state[i].dev_id;
    }

#if COMPASS_MAX_UNREG_DEV
    // set the dev_id to 0 for undetected compasses. extra_dev_id is just an
    // interface for users to see unreg compasses, we actually never store it
    // in storage.
    for (uint8_t i=_unreg_compass_count; i<COMPASS_MAX_UNREG_DEV; i++) {
        // cache the extra devices detected in last boot
        // for detecting replacement mag
        _previously_unreg_mag[i] = extra_dev_id[i];
        extra_dev_id[i].set(0);
    }
#endif

#if COMPASS_MAX_INSTANCES > 1
    // This method calls set_and_save_ifchanged on parameters
    // which are set() but not saved() during normal runtime,
    // do not move this call without ensuring that is not happening
    // read comments under set_and_save_ifchanged for details
    if (!suppress_devid_save) {
        _reorder_compass_params();
    }
#endif

    if (_compass_count == 0) {
        // detect available backends. Only called once
        _detect_backends();
    }

    if (_compass_count != 0) {
        // get initial health status
        hal.scheduler->delay(100);
        read();
    }
    // set the dev_id to 0 for undetected compasses, to make it easier
    // for users to see how many compasses are detected. We don't do a
    // set_and_save() as the user may have temporarily removed the
    // compass, and we don't want to force a re-cal if they plug it
    // back in again
    for (StateIndex i(0); i<COMPASS_MAX_INSTANCES; i++) {
        if (!_state[i].registered) {
            _state[i].dev_id.set(0);
        }
    }

#ifndef HAL_BUILD_AP_PERIPH
    // updating the AHRS orientation updates our own orientation:
    AP::ahrs().update_orientation();
#endif

    init_done = true;
    suppress_devid_save = false;
}

#if COMPASS_MAX_INSTANCES > 1 || COMPASS_MAX_UNREG_DEV
// Update Priority List for Mags, by default, we just
// load them as they come up the first time
Compass::Priority Compass::_update_priority_list(int32_t dev_id)
{
    // Check if already in priority list
    for (Priority i(0); i<COMPASS_MAX_INSTANCES; i++) {
        if (_priority_did_list[i] == dev_id) {
            if (i >= _compass_count) {
                _compass_count = uint8_t(i)+1;
            }
            return i;
        }
    }

    // We are not in priority list, let's add at first empty
    for (Priority i(0); i<COMPASS_MAX_INSTANCES; i++) {
        if (_priority_did_stored_list[i] == 0) {
            if (suppress_devid_save) {
                _priority_did_stored_list[i].set(dev_id);
            } else {
                _priority_did_stored_list[i].set_and_save(dev_id);
            }
            _priority_did_list[i] = dev_id;
            if (i >= _compass_count) {
                _compass_count = uint8_t(i)+1;
            }
            return i;
        }
    }
    return Priority(COMPASS_MAX_INSTANCES);
}
#endif


#if COMPASS_MAX_INSTANCES > 1
// This method reorganises devid list to match
// priority list, only call before detection at boot
void Compass::_reorder_compass_params()
{
    mag_state swap_state;
    StateIndex curr_state_id;
    for (Priority i(0); i<COMPASS_MAX_INSTANCES; i++) {
        if (_priority_did_list[i] == 0) {
            continue;
        }
        curr_state_id = COMPASS_MAX_INSTANCES;
        for (StateIndex j(0); j<COMPASS_MAX_INSTANCES; j++) {
            if (_priority_did_list[i] == _state[j].dev_id) {
                curr_state_id = j;
                break;
            }
        }
        if (curr_state_id != COMPASS_MAX_INSTANCES && uint8_t(curr_state_id) != uint8_t(i)) {
            //let's swap
            swap_state.copy_from(_state[curr_state_id]);
            _state[curr_state_id].copy_from(_state[StateIndex(uint8_t(i))]);
            _state[StateIndex(uint8_t(i))].copy_from(swap_state);
        }
    }
}
#endif

void Compass::mag_state::copy_from(const Compass::mag_state& state)
{
    external.set_and_save_ifchanged(state.external);
    orientation.set_and_save_ifchanged(state.orientation);
    offset.set_and_save_ifchanged(state.offset);
#if AP_COMPASS_DIAGONALS_ENABLED
    diagonals.set_and_save_ifchanged(state.diagonals);
    offdiagonals.set_and_save_ifchanged(state.offdiagonals);
#endif
    scale_factor.set_and_save_ifchanged(state.scale_factor);
    dev_id.set_and_save_ifchanged(state.dev_id);
    motor_compensation.set_and_save_ifchanged(state.motor_compensation);
    expected_dev_id = state.expected_dev_id;
    detected_dev_id = state.detected_dev_id;
}
//  Register a new compass instance
//
bool Compass::register_compass(int32_t dev_id, uint8_t& instance)
{

#if COMPASS_MAX_INSTANCES == 1 && !COMPASS_MAX_UNREG_DEV
    // simple single compass setup for AP_Periph
    Priority priority(0);
    StateIndex i(0);
    if (_state[i].registered) {
        return false;
    }
    _state[i].registered = true;
    _state[i].priority = priority;
    instance = uint8_t(i);
    _compass_count = 1;
    return true;
#else
    Priority priority;
    // Check if we already have this dev_id registered
    for (StateIndex i(0); i<COMPASS_MAX_INSTANCES; i++) {
        priority = _update_priority_list(dev_id);
        if (_state[i].expected_dev_id == dev_id && priority < COMPASS_MAX_INSTANCES) {
            _state[i].registered = true;
            _state[i].priority = priority;
            instance = uint8_t(i);
            return true;
        }
    }

    // This is an unregistered compass, check if any free slot is available
    for (StateIndex i(0); i<COMPASS_MAX_INSTANCES; i++) {
        priority = _update_priority_list(dev_id);
        if (_state[i].dev_id == 0 && priority < COMPASS_MAX_INSTANCES) {
            _state[i].registered = true;
            _state[i].priority = priority;
            instance = uint8_t(i);
            return true;
        }
    }

    // This might be a replacement compass module, find any unregistered compass
    // instance and replace that
    for (StateIndex i(0); i<COMPASS_MAX_INSTANCES; i++) {
        priority = _update_priority_list(dev_id);
        if (!_state[i].registered && priority < COMPASS_MAX_INSTANCES) {
            _state[i].registered = true;
            _state[i].priority = priority;
            instance = uint8_t(i);
            return true;
        }
    }
#endif

#if COMPASS_MAX_UNREG_DEV
    // Set extra dev id
    if (_unreg_compass_count >= COMPASS_MAX_UNREG_DEV) {
        AP_HAL::panic("Too many compass instances");
    }

    for (uint8_t i=0; i<COMPASS_MAX_UNREG_DEV; i++) {
        if (extra_dev_id[i] == dev_id) {
            if (i >= _unreg_compass_count) {
                _unreg_compass_count = i+1;
            }
            instance = i+COMPASS_MAX_INSTANCES;
            return false;
        } else if (extra_dev_id[i] == 0) {
            extra_dev_id[_unreg_compass_count++].set(dev_id);
            instance = i+COMPASS_MAX_INSTANCES;
            return false;
        }
    }
#else
    AP_HAL::panic("Too many compass instances");
#endif

    return false;
}

Compass::StateIndex Compass::_get_state_id(Compass::Priority priority) const
{
#if COMPASS_MAX_INSTANCES > 1
    if (_priority_did_list[priority] == 0) {
        return StateIndex(COMPASS_MAX_INSTANCES);
    }
    for (StateIndex i(0); i<COMPASS_MAX_INSTANCES; i++) {
        if (_priority_did_list[priority] == _state[i].detected_dev_id) {
            return i;
        }
    }
    return StateIndex(COMPASS_MAX_INSTANCES);
#else
    return StateIndex(0);
#endif
}

bool Compass::_add_backend(AP_Compass_Backend *backend)
{
    if (!backend) {
        return false;
    }

    if (_backend_count == COMPASS_MAX_BACKEND) {
        return false;
    }

    _backends[_backend_count++] = backend;

    return true;
}

/*
  return true if a driver type is enabled
 */
bool Compass::_driver_enabled(enum DriverType driver_type)
{
    uint32_t mask = (1U<<uint8_t(driver_type));
    return (mask & uint32_t(_driver_type_mask.get())) == 0;
}

/*
  wrapper around hal.i2c_mgr->get_device() that prevents duplicate devices being opened
 */
bool Compass::_have_i2c_driver(uint8_t bus, uint8_t address) const
{
    for (StateIndex i(0); i<COMPASS_MAX_INSTANCES; i++) {
        if (!_state[i].registered) {
            continue;
        }
        if (AP_HAL::Device::make_bus_id(AP_HAL::Device::BUS_TYPE_I2C, bus, address, 0) ==
            AP_HAL::Device::change_bus_id(uint32_t(_state[i].dev_id.get()), 0)) {
            // we are already using this device
            return true;
        }
    }
    return false;
}

#if COMPASS_MAX_UNREG_DEV > 0
#define CHECK_UNREG_LIMIT_RETURN  if (_unreg_compass_count == COMPASS_MAX_UNREG_DEV) return
#else
#define CHECK_UNREG_LIMIT_RETURN
#endif

/*
  macro to add a backend with check for too many backends or compass
  instances. We don't try to start more than the maximum allowed
 */
#define ADD_BACKEND(driver_type, backend)   \
    do { if (_driver_enabled(driver_type)) { _add_backend(backend); } \
        CHECK_UNREG_LIMIT_RETURN; \
    } while (0)

#define GET_I2C_DEVICE(bus, address) _have_i2c_driver(bus, address)?nullptr:hal.i2c_mgr->get_device(bus, address)

/*
  look for compasses on external i2c buses
 */
void Compass::_probe_external_i2c_compasses(void)
{
#if !defined(HAL_SKIP_AUTO_INTERNAL_I2C_PROBE)
    bool all_external = (AP_BoardConfig::get_board_type() == AP_BoardConfig::PX4_BOARD_PIXHAWK2);
    (void)all_external;  // in case all backends using this are compiled out
#endif
#if AP_COMPASS_HMC5843_ENABLED
    // external i2c bus
    FOREACH_I2C_EXTERNAL(i) {
        ADD_BACKEND(DRIVER_HMC5843, AP_Compass_HMC5843::probe(GET_I2C_DEVICE(i, HAL_COMPASS_HMC5843_I2C_ADDR),
                    true, ROTATION_ROLL_180));
    }

#if !defined(HAL_SKIP_AUTO_INTERNAL_I2C_PROBE)
    if (AP_BoardConfig::get_board_type() != AP_BoardConfig::PX4_BOARD_MINDPXV2 &&
        AP_BoardConfig::get_board_type() != AP_BoardConfig::PX4_BOARD_AEROFC) {
        // internal i2c bus
        FOREACH_I2C_INTERNAL(i) {
            ADD_BACKEND(DRIVER_HMC5843, AP_Compass_HMC5843::probe(GET_I2C_DEVICE(i, HAL_COMPASS_HMC5843_I2C_ADDR),
                        all_external, all_external?ROTATION_ROLL_180:ROTATION_YAW_270));
        }
    }
#endif  // !defined(HAL_SKIP_AUTO_INTERNAL_I2C_PROBE)
#endif  // AP_COMPASS_HMC5843_ENABLED

#if AP_COMPASS_QMC5883L_ENABLED
    //external i2c bus
    FOREACH_I2C_EXTERNAL(i) {
        ADD_BACKEND(DRIVER_QMC5883L, AP_Compass_QMC5883L::probe(GET_I2C_DEVICE(i, HAL_COMPASS_QMC5883L_I2C_ADDR),
                    true, HAL_COMPASS_QMC5883L_ORIENTATION_EXTERNAL));
    }

    // internal i2c bus
#if !defined(HAL_SKIP_AUTO_INTERNAL_I2C_PROBE)
    if (all_external) {
        // only probe QMC5883L on internal if we are treating internals as externals
        FOREACH_I2C_INTERNAL(i) {
            ADD_BACKEND(DRIVER_QMC5883L, AP_Compass_QMC5883L::probe(GET_I2C_DEVICE(i, HAL_COMPASS_QMC5883L_I2C_ADDR),
                        all_external,
                        all_external?HAL_COMPASS_QMC5883L_ORIENTATION_EXTERNAL:HAL_COMPASS_QMC5883L_ORIENTATION_INTERNAL));
        }
    }
#endif
#endif  // AP_COMPASS_QMC5883L_ENABLED

#if AP_COMPASS_QMC5883P_ENABLED
    //external i2c bus
    FOREACH_I2C_EXTERNAL(i) {
        ADD_BACKEND(DRIVER_QMC5883P, AP_Compass_QMC5883P::probe(GET_I2C_DEVICE(i, HAL_COMPASS_QMC5883P_I2C_ADDR),
                    true, HAL_COMPASS_QMC5883P_ORIENTATION_EXTERNAL));
    }

    // internal i2c bus
#if !defined(HAL_SKIP_AUTO_INTERNAL_I2C_PROBE)
    if (all_external) {
        // only probe QMC5883P on internal if we are treating internals as externals
        FOREACH_I2C_INTERNAL(i) {
            ADD_BACKEND(DRIVER_QMC5883P, AP_Compass_QMC5883P::probe(GET_I2C_DEVICE(i, HAL_COMPASS_QMC5883P_I2C_ADDR),
                        all_external,
                        all_external?HAL_COMPASS_QMC5883P_ORIENTATION_EXTERNAL:HAL_COMPASS_QMC5883P_ORIENTATION_INTERNAL));
        }
    }
#endif
#endif  // AP_COMPASS_QMC5883P_ENABLED

#ifndef HAL_BUILD_AP_PERIPH
    // AK09916 on ICM20948
#if AP_COMPASS_AK09916_ENABLED && AP_COMPASS_ICM20948_ENABLED
    FOREACH_I2C_EXTERNAL(i) {
        ADD_BACKEND(DRIVER_ICM20948, AP_Compass_AK09916::probe_ICM20948(GET_I2C_DEVICE(i, HAL_COMPASS_AK09916_I2C_ADDR),
                    GET_I2C_DEVICE(i, HAL_COMPASS_ICM20948_I2C_ADDR),
                    true, ROTATION_PITCH_180_YAW_90));
        ADD_BACKEND(DRIVER_ICM20948, AP_Compass_AK09916::probe_ICM20948(GET_I2C_DEVICE(i, HAL_COMPASS_AK09916_I2C_ADDR),
                    GET_I2C_DEVICE(i, HAL_COMPASS_ICM20948_I2C_ADDR2),
                    true, ROTATION_PITCH_180_YAW_90));
    }

#if !defined(HAL_SKIP_AUTO_INTERNAL_I2C_PROBE)
    FOREACH_I2C_INTERNAL(i) {
        ADD_BACKEND(DRIVER_ICM20948, AP_Compass_AK09916::probe_ICM20948(GET_I2C_DEVICE(i, HAL_COMPASS_AK09916_I2C_ADDR),
                    GET_I2C_DEVICE(i, HAL_COMPASS_ICM20948_I2C_ADDR),
                    all_external, ROTATION_PITCH_180_YAW_90));
        ADD_BACKEND(DRIVER_ICM20948, AP_Compass_AK09916::probe_ICM20948(GET_I2C_DEVICE(i, HAL_COMPASS_AK09916_I2C_ADDR),
                    GET_I2C_DEVICE(i, HAL_COMPASS_ICM20948_I2C_ADDR2),
                    all_external, ROTATION_PITCH_180_YAW_90));
    }
#endif
#endif  // AP_COMPASS_AK09916_ENABLED && AP_COMPASS_ICM20948_ENABLED
#endif // HAL_BUILD_AP_PERIPH

#if AP_COMPASS_LIS3MDL_ENABLED
    // lis3mdl on bus 0 with default address
#if !defined(HAL_SKIP_AUTO_INTERNAL_I2C_PROBE)
    FOREACH_I2C_INTERNAL(i) {
        ADD_BACKEND(DRIVER_LIS3MDL, AP_Compass_LIS3MDL::probe(GET_I2C_DEVICE(i, HAL_COMPASS_LIS3MDL_I2C_ADDR),
                    all_external, all_external?ROTATION_YAW_90:ROTATION_NONE));
    }

    // lis3mdl on bus 0 with alternate address
    FOREACH_I2C_INTERNAL(i) {
        ADD_BACKEND(DRIVER_LIS3MDL, AP_Compass_LIS3MDL::probe(GET_I2C_DEVICE(i, HAL_COMPASS_LIS3MDL_I2C_ADDR2),
                    all_external, all_external?ROTATION_YAW_90:ROTATION_NONE));
    }
#endif
    // external lis3mdl on bus 1 with default address
    FOREACH_I2C_EXTERNAL(i) {
        ADD_BACKEND(DRIVER_LIS3MDL, AP_Compass_LIS3MDL::probe(GET_I2C_DEVICE(i, HAL_COMPASS_LIS3MDL_I2C_ADDR),
                    true, ROTATION_YAW_90));
    }

    // external lis3mdl on bus 1 with alternate address
    FOREACH_I2C_EXTERNAL(i) {
        ADD_BACKEND(DRIVER_LIS3MDL, AP_Compass_LIS3MDL::probe(GET_I2C_DEVICE(i, HAL_COMPASS_LIS3MDL_I2C_ADDR2),
                    true, ROTATION_YAW_90));
    }
#endif  // AP_COMPASS_LIS3MDL_ENABLED

#if AP_COMPASS_AK09916_ENABLED
    // AK09916. This can be found twice, due to the ICM20948 i2c bus pass-thru, so we need to be careful to avoid that
    FOREACH_I2C_EXTERNAL(i) {
        ADD_BACKEND(DRIVER_AK09916, AP_Compass_AK09916::probe(GET_I2C_DEVICE(i, HAL_COMPASS_AK09916_I2C_ADDR),
                    true, ROTATION_YAW_270));
    }
#if !defined(HAL_SKIP_AUTO_INTERNAL_I2C_PROBE)
    FOREACH_I2C_INTERNAL(i) {
        ADD_BACKEND(DRIVER_AK09916, AP_Compass_AK09916::probe(GET_I2C_DEVICE(i, HAL_COMPASS_AK09916_I2C_ADDR),
                    all_external, all_external?ROTATION_YAW_270:ROTATION_NONE));
    }
#endif
#endif  // AP_COMPASS_AK09916_ENABLED

#if AP_COMPASS_IST8310_ENABLED
    // IST8310 on external and internal bus
    if (AP_BoardConfig::get_board_type() != AP_BoardConfig::PX4_BOARD_FMUV5 &&
        AP_BoardConfig::get_board_type() != AP_BoardConfig::PX4_BOARD_FMUV6) {
        enum Rotation default_rotation = AP_COMPASS_IST8310_DEFAULT_ROTATION;

        if (AP_BoardConfig::get_board_type() == AP_BoardConfig::PX4_BOARD_AEROFC) {
            default_rotation = ROTATION_PITCH_180_YAW_90;
        }
        // probe all 4 possible addresses
        const uint8_t ist8310_addr[] = { 0x0C, 0x0D, 0x0E, 0x0F };

        for (uint8_t a=0; a<ARRAY_SIZE(ist8310_addr); a++) {
            FOREACH_I2C_EXTERNAL(i) {
                ADD_BACKEND(DRIVER_IST8310, AP_Compass_IST8310::probe(GET_I2C_DEVICE(i, ist8310_addr[a]),
                            true, default_rotation));
            }
#if !defined(HAL_COMPASS_DISABLE_IST8310_INTERNAL_PROBE) && !defined(HAL_SKIP_AUTO_INTERNAL_I2C_PROBE)
            FOREACH_I2C_INTERNAL(i) {
                ADD_BACKEND(DRIVER_IST8310, AP_Compass_IST8310::probe(GET_I2C_DEVICE(i, ist8310_addr[a]),
                            all_external, default_rotation));
            }
#endif
        }
    }
#endif  // AP_COMPASS_IST8310_ENABLED

#if AP_COMPASS_IST8308_ENABLED
    // external i2c bus
    FOREACH_I2C_EXTERNAL(i) {
        ADD_BACKEND(DRIVER_IST8308, AP_Compass_IST8308::probe(GET_I2C_DEVICE(i, HAL_COMPASS_IST8308_I2C_ADDR),
                    true, ROTATION_NONE));
    }
#if !defined(HAL_SKIP_AUTO_INTERNAL_I2C_PROBE)
    FOREACH_I2C_INTERNAL(i) {
        ADD_BACKEND(DRIVER_IST8308, AP_Compass_IST8308::probe(GET_I2C_DEVICE(i, HAL_COMPASS_IST8308_I2C_ADDR),
                    all_external, ROTATION_NONE));
    }
#endif
#endif  // AP_COMPASS_IST8308_ENABLED

#if AP_COMPASS_MMC3416_ENABLED
    // external i2c bus
    FOREACH_I2C_EXTERNAL(i) {
        ADD_BACKEND(DRIVER_MMC3416, AP_Compass_MMC3416::probe(GET_I2C_DEVICE(i, HAL_COMPASS_MMC3416_I2C_ADDR),
                    true, ROTATION_NONE));
    }
#if !defined(HAL_SKIP_AUTO_INTERNAL_I2C_PROBE)
    FOREACH_I2C_INTERNAL(i) {
        ADD_BACKEND(DRIVER_MMC3416, AP_Compass_MMC3416::probe(GET_I2C_DEVICE(i, HAL_COMPASS_MMC3416_I2C_ADDR),
                    all_external, ROTATION_NONE));
    }
#endif
#endif  // AP_COMPASS_MMC3416_ENABLED

#if AP_COMPASS_RM3100_ENABLED
#ifdef HAL_COMPASS_RM3100_I2C_ADDR
    const uint8_t rm3100_addresses[] = { HAL_COMPASS_RM3100_I2C_ADDR };
#else
    // RM3100 can be on 4 different addresses
    const uint8_t rm3100_addresses[] = { HAL_COMPASS_RM3100_I2C_ADDR1,
                                         HAL_COMPASS_RM3100_I2C_ADDR2,
                                         HAL_COMPASS_RM3100_I2C_ADDR3,
                                         HAL_COMPASS_RM3100_I2C_ADDR4 };
#endif
    // external i2c bus
    FOREACH_I2C_EXTERNAL(i) {
        for (uint8_t j=0; j<ARRAY_SIZE(rm3100_addresses); j++) {
            ADD_BACKEND(DRIVER_RM3100, AP_Compass_RM3100::probe(GET_I2C_DEVICE(i, rm3100_addresses[j]), true, ROTATION_NONE));
        }
    }

#if !defined(HAL_SKIP_AUTO_INTERNAL_I2C_PROBE)
    FOREACH_I2C_INTERNAL(i) {
        for (uint8_t j=0; j<ARRAY_SIZE(rm3100_addresses); j++) {
            ADD_BACKEND(DRIVER_RM3100, AP_Compass_RM3100::probe(GET_I2C_DEVICE(i, rm3100_addresses[j]), all_external, ROTATION_NONE));
        }
    }
#endif
#endif  // AP_COMPASS_RM3100_ENABLED

#if AP_COMPASS_BMM150_DETECT_BACKENDS_ENABLED
    // BMM150 on I2C
    FOREACH_I2C_EXTERNAL(i) {
        for (uint8_t addr=BMM150_I2C_ADDR_MIN; addr <= BMM150_I2C_ADDR_MAX; addr++) {
            ADD_BACKEND(DRIVER_BMM150,
                        AP_Compass_BMM150::probe(GET_I2C_DEVICE(i, addr), true, ROTATION_NONE));
        }
    }
#endif // AP_COMPASS_BMM150_ENABLED
}

/*
  detect available backends for this board
 */
void Compass::_detect_backends(void)
{
#if AP_COMPASS_EXTERNALAHRS_ENABLED
    const int8_t serial_port = AP::externalAHRS().get_port(AP_ExternalAHRS::AvailableSensor::COMPASS);
    if (serial_port >= 0) {
        ADD_BACKEND(DRIVER_EXTERNALAHRS, NEW_NOTHROW AP_Compass_ExternalAHRS(serial_port));
    }
#endif
    
#if AP_FEATURE_BOARD_DETECT
    if (AP_BoardConfig::get_board_type() == AP_BoardConfig::PX4_BOARD_PIXHAWK2) {
        // default to disabling LIS3MDL on pixhawk2 due to hardware issue
#if AP_COMPASS_LIS3MDL_ENABLED
    _driver_type_mask.set_default(1U<<DRIVER_LIS3MDL);
#endif
    }
#endif

#if AP_COMPASS_SITL_ENABLED && !AP_TEST_DRONECAN_DRIVERS
    ADD_BACKEND(DRIVER_SITL, NEW_NOTHROW AP_Compass_SITL());
#endif

#if AP_COMPASS_DRONECAN_ENABLED
    // probe DroneCAN before I2C and SPI so that DroneCAN compasses
    // default to first in the list for a new board
    probe_dronecan_compasses();
    CHECK_UNREG_LIMIT_RETURN;
#endif

#ifdef HAL_PROBE_EXTERNAL_I2C_COMPASSES
    // allow boards to ask for external probing of all i2c compass types in hwdef.dat
    _probe_external_i2c_compasses();
    CHECK_UNREG_LIMIT_RETURN;
#endif

#if AP_COMPASS_MSP_ENABLED
    for (uint8_t i=0; i<8; i++) {
        if (msp_instance_mask & (1U<<i)) {
            ADD_BACKEND(DRIVER_MSP, NEW_NOTHROW AP_Compass_MSP(i));
        }
    }
#endif

    // finally look for i2c and spi compasses not found yet
    CHECK_UNREG_LIMIT_RETURN;
    probe_i2c_spi_compasses();

    if (_backend_count == 0 ||
        _compass_count == 0) {
        DEV_PRINTF("No Compass backends available\n");
    }
}

/*
  probe i2c and SPI compasses
 */
void Compass::probe_i2c_spi_compasses(void)
{
#if defined(HAL_MAG_PROBE_LIST)
    // driver probes defined by COMPASS lines in hwdef.dat
    HAL_MAG_PROBE_LIST;
#elif AP_FEATURE_BOARD_DETECT
    switch (AP_BoardConfig::get_board_type()) {
    case AP_BoardConfig::PX4_BOARD_PX4V1:
    case AP_BoardConfig::PX4_BOARD_PIXHAWK:
    case AP_BoardConfig::PX4_BOARD_PHMINI:
    case AP_BoardConfig::PX4_BOARD_AUAV21:
    case AP_BoardConfig::PX4_BOARD_PH2SLIM:
    case AP_BoardConfig::PX4_BOARD_PIXHAWK2:
    case AP_BoardConfig::PX4_BOARD_MINDPXV2:
    case AP_BoardConfig::PX4_BOARD_FMUV5:
    case AP_BoardConfig::PX4_BOARD_FMUV6:
    case AP_BoardConfig::PX4_BOARD_PIXHAWK_PRO:
    case AP_BoardConfig::PX4_BOARD_AEROFC:
        _probe_external_i2c_compasses();
        CHECK_UNREG_LIMIT_RETURN;
        break;

    case AP_BoardConfig::PX4_BOARD_PCNC1:
#if AP_COMPASS_BMM150_ENABLED
        ADD_BACKEND(DRIVER_BMM150,
                    AP_Compass_BMM150::probe(GET_I2C_DEVICE(0, 0x10), false, ROTATION_NONE));
#endif
        break;
    case AP_BoardConfig::VRX_BOARD_BRAIN54:
    case AP_BoardConfig::VRX_BOARD_BRAIN51: {
#if AP_COMPASS_HMC5843_ENABLED
        // external i2c bus
        ADD_BACKEND(DRIVER_HMC5843, AP_Compass_HMC5843::probe(GET_I2C_DEVICE(1, HAL_COMPASS_HMC5843_I2C_ADDR),
                    true, ROTATION_ROLL_180));

        // internal i2c bus
        ADD_BACKEND(DRIVER_HMC5843, AP_Compass_HMC5843::probe(GET_I2C_DEVICE(0, HAL_COMPASS_HMC5843_I2C_ADDR),
                    false, ROTATION_YAW_270));
#endif  // AP_COMPASS_HMC5843_ENABLED
    }
    break;

    case AP_BoardConfig::VRX_BOARD_BRAIN52:
    case AP_BoardConfig::VRX_BOARD_BRAIN52E:
    case AP_BoardConfig::VRX_BOARD_CORE10:
    case AP_BoardConfig::VRX_BOARD_UBRAIN51:
    case AP_BoardConfig::VRX_BOARD_UBRAIN52: {
#if AP_COMPASS_HMC5843_ENABLED
        // external i2c bus
        ADD_BACKEND(DRIVER_HMC5843, AP_Compass_HMC5843::probe(GET_I2C_DEVICE(1, HAL_COMPASS_HMC5843_I2C_ADDR),
                    true, ROTATION_ROLL_180));
#endif  // AP_COMPASS_HMC5843_ENABLED
    }
    break;

    default:
        break;
    }
    switch (AP_BoardConfig::get_board_type()) {
    case AP_BoardConfig::PX4_BOARD_PIXHAWK:
#if AP_COMPASS_HMC5843_ENABLED
        ADD_BACKEND(DRIVER_HMC5843, AP_Compass_HMC5843::probe(hal.spi->get_device(HAL_COMPASS_HMC5843_NAME),
                    false, ROTATION_PITCH_180));
#endif
#if AP_COMPASS_LSM303D_ENABLED
        ADD_BACKEND(DRIVER_LSM303D, AP_Compass_LSM303D::probe(hal.spi->get_device(HAL_INS_LSM9DS0_A_NAME), ROTATION_NONE));
#endif
        break;

    case AP_BoardConfig::PX4_BOARD_PIXHAWK2:
#if AP_COMPASS_LSM303D_ENABLED
        ADD_BACKEND(DRIVER_LSM303D, AP_Compass_LSM303D::probe(hal.spi->get_device(HAL_INS_LSM9DS0_EXT_A_NAME), ROTATION_YAW_270));
#endif
#if AP_COMPASS_AK8963_ENABLED
        // we run the AK8963 only on the 2nd MPU9250, which leaves the
        // first MPU9250 to run without disturbance at high rate
        ADD_BACKEND(DRIVER_AK8963, AP_Compass_AK8963::probe_mpu9250(1, ROTATION_YAW_270));
#endif
#if AP_COMPASS_AK09916_ENABLED && AP_COMPASS_ICM20948_ENABLED
        ADD_BACKEND(DRIVER_AK09916, AP_Compass_AK09916::probe_ICM20948(0, ROTATION_ROLL_180_YAW_90));
#endif
        break;

    case AP_BoardConfig::PX4_BOARD_FMUV5:
    case AP_BoardConfig::PX4_BOARD_FMUV6:
#if AP_COMPASS_IST8310_ENABLED
        FOREACH_I2C_EXTERNAL(i) {
            ADD_BACKEND(DRIVER_IST8310, AP_Compass_IST8310::probe(GET_I2C_DEVICE(i, HAL_COMPASS_IST8310_I2C_ADDR),
                        true, ROTATION_ROLL_180_YAW_90));
        }
        FOREACH_I2C_INTERNAL(i) {
            ADD_BACKEND(DRIVER_IST8310, AP_Compass_IST8310::probe(GET_I2C_DEVICE(i, HAL_COMPASS_IST8310_I2C_ADDR),
                        false, ROTATION_ROLL_180_YAW_90));
        }
#endif  // AP_COMPASS_IST8310_ENABLED
        break;

    case AP_BoardConfig::PX4_BOARD_SP01:
#if AP_COMPASS_AK8963_ENABLED
        ADD_BACKEND(DRIVER_AK8963, AP_Compass_AK8963::probe_mpu9250(1, ROTATION_NONE));
#endif
        break;

    case AP_BoardConfig::PX4_BOARD_PIXHAWK_PRO:
#if AP_COMPASS_AK8963_ENABLED
        ADD_BACKEND(DRIVER_AK8963, AP_Compass_AK8963::probe_mpu9250(0, ROTATION_ROLL_180_YAW_90));
#endif
#if AP_COMPASS_LIS3MDL_ENABLED
        ADD_BACKEND(DRIVER_LIS3MDL, AP_Compass_LIS3MDL::probe(hal.spi->get_device(HAL_COMPASS_LIS3MDL_NAME),
                    false, ROTATION_NONE));
#endif  // AP_COMPASS_LIS3MDL_ENABLED
        break;

    case AP_BoardConfig::PX4_BOARD_PHMINI:
#if AP_COMPASS_AK8963_ENABLED
        ADD_BACKEND(DRIVER_AK8963, AP_Compass_AK8963::probe_mpu9250(0, ROTATION_ROLL_180));
#endif
        break;

    case AP_BoardConfig::PX4_BOARD_AUAV21:
#if AP_COMPASS_AK8963_ENABLED
        ADD_BACKEND(DRIVER_AK8963, AP_Compass_AK8963::probe_mpu9250(0, ROTATION_ROLL_180_YAW_90));
#endif
        break;

    case AP_BoardConfig::PX4_BOARD_PH2SLIM:
#if AP_COMPASS_AK8963_ENABLED
        ADD_BACKEND(DRIVER_AK8963, AP_Compass_AK8963::probe_mpu9250(0, ROTATION_YAW_270));
#endif
        break;

    case AP_BoardConfig::PX4_BOARD_MINDPXV2:
#if AP_COMPASS_HMC5843_ENABLED
        ADD_BACKEND(DRIVER_HMC5843, AP_Compass_HMC5843::probe(GET_I2C_DEVICE(0, HAL_COMPASS_HMC5843_I2C_ADDR),
                    false, ROTATION_YAW_90));
#endif
#if AP_COMPASS_LSM303D_ENABLED
        ADD_BACKEND(DRIVER_LSM303D, AP_Compass_LSM303D::probe(hal.spi->get_device(HAL_INS_LSM9DS0_A_NAME), ROTATION_PITCH_180_YAW_270));
#endif
        break;

    default:
        break;
    }
#endif
}

#if AP_COMPASS_DRONECAN_ENABLED
/*
  look for DroneCAN compasses
 */
void Compass::probe_dronecan_compasses(void)
{
    if (!_driver_enabled(DRIVER_UAVCAN)) {
        return;
    }
    for (uint8_t i=0; i<COMPASS_MAX_BACKEND; i++) {
        AP_Compass_Backend* _uavcan_backend = AP_Compass_DroneCAN::probe(i);
        if (_uavcan_backend) {
            _add_backend(_uavcan_backend);
        }
#if COMPASS_MAX_UNREG_DEV > 0
        if (_unreg_compass_count == COMPASS_MAX_UNREG_DEV)  {
            break;
        }
#endif
    }

#if COMPASS_MAX_UNREG_DEV > 0
    if (option_set(Option::ALLOW_DRONECAN_AUTO_REPLACEMENT) && !suppress_devid_save) {
        // check if there's any uavcan compass in prio slot that's not found
        // and replace it if there's a replacement compass
        for (Priority i(0); i<COMPASS_MAX_INSTANCES; i++) {
            if (AP_HAL::Device::devid_get_bus_type(_priority_did_list[i]) != AP_HAL::Device::BUS_TYPE_UAVCAN
                || _get_state(i).registered) {
                continue;
            }
            // There's a UAVCAN compass missing
            // Let's check if there's a replacement
            for (uint8_t j=0; j<COMPASS_MAX_INSTANCES; j++) {
                uint32_t detected_devid = AP_Compass_DroneCAN::get_detected_devid(j);
                // Check if this is a potential replacement mag
                if (!is_replacement_mag(detected_devid)) {
                    continue;
                }
                // We have found a replacement mag, let's replace the existing one
 #pragma once

#include "AP_Compass_config.h"

#include <inttypes.h>

#include <AP_Common/AP_Common.h>
#include <AP_Declination/AP_Declination.h>
#include <AP_HAL/AP_HAL.h>
#include <AP_Math/AP_Math.h>
#include <AP_Param/AP_Param.h>
#include <GCS_MAVLink/GCS_MAVLink.h>
#include <AP_MSP/msp.h>
#include <AP_ExternalAHRS/AP_ExternalAHRS.h>

#include "AP_Compass_Backend.h"
#include "Compass_PerMotor.h"
#include <AP_Common/TSIndex.h>

// motor compensation types (for use with motor_comp_enabled)
#define AP_COMPASS_MOT_COMP_DISABLED    0x00
#define AP_COMPASS_MOT_COMP_THROTTLE    0x01
#define AP_COMPASS_MOT_COMP_CURRENT     0x02
#define AP_COMPASS_MOT_COMP_PER_MOTOR   0x03

// setup default mag orientation for some board types
#ifndef MAG_BOARD_ORIENTATION
#if CONFIG_HAL_BOARD == HAL_BOARD_LINUX && CONFIG_HAL_BOARD_SUBTYPE == HAL_BOARD_SUBTYPE_LINUX_BEBOP
# define MAG_BOARD_ORIENTATION ROTATION_YAW_90
#elif CONFIG_HAL_BOARD == HAL_BOARD_LINUX && (CONFIG_HAL_BOARD_SUBTYPE == HAL_BOARD_SUBTYPE_LINUX_ERLEBRAIN2 || \
      CONFIG_HAL_BOARD_SUBTYPE == HAL_BOARD_SUBTYPE_LINUX_PXFMINI)
# define MAG_BOARD_ORIENTATION ROTATION_YAW_270
#else
# define MAG_BOARD_ORIENTATION ROTATION_NONE
#endif
#endif

#ifndef COMPASS_MOT_ENABLED
#define COMPASS_MOT_ENABLED 1
#endif
#ifndef COMPASS_LEARN_ENABLED
#define COMPASS_LEARN_ENABLED AP_COMPASS_CALIBRATION_FIXED_YAW_ENABLED
#endif

// define default compass calibration fitness and consistency checks
#define AP_COMPASS_CALIBRATION_FITNESS_DEFAULT 16.0f
#define AP_COMPASS_MAX_XYZ_ANG_DIFF radians(90.0f)
#define AP_COMPASS_MAX_XY_ANG_DIFF radians(60.0f)
#define AP_COMPASS_MAX_XY_LENGTH_DIFF 200.0f

/**
   maximum number of compass instances available on this platform. If more
   than 1 then redundant sensors may be available
 */
#ifndef HAL_BUILD_AP_PERIPH
#ifndef HAL_COMPASS_MAX_SENSORS
#define HAL_COMPASS_MAX_SENSORS 3
#endif
#if HAL_COMPASS_MAX_SENSORS > 1
#define COMPASS_MAX_UNREG_DEV 5
#else
#define COMPASS_MAX_UNREG_DEV 0
#endif
#else
#ifndef HAL_COMPASS_MAX_SENSORS
#define HAL_COMPASS_MAX_SENSORS 1
#endif
#define COMPASS_MAX_UNREG_DEV 0
#endif

#define COMPASS_MAX_INSTANCES HAL_COMPASS_MAX_SENSORS
#define COMPASS_MAX_BACKEND   HAL_COMPASS_MAX_SENSORS

#define MAX_CONNECTED_MAGS (COMPASS_MAX_UNREG_DEV+COMPASS_MAX_INSTANCES)

#include "CompassCalibrator.h"

class CompassLearn;

class Compass
{
friend class AP_Compass_Backend;
public:
    Compass();

    /* Do not allow copies */
    CLASS_NO_COPY(Compass);

    // get singleton instance
    static Compass *get_singleton() {
        return _singleton;
    }

    friend class CompassLearn;

    /// Initialize the compass device.
    ///
    /// @returns    True if the compass was initialized OK, false if it was not
    ///             found or is not functioning.
    ///
    void init();

    /// Read the compass and update the mag_ variables.
    ///
    bool read();

    // available returns true if the compass is both enabled and has
    // been initialised
    bool available() const { return _enabled && init_done; }

    /// Calculate the tilt-compensated heading_ variables.
    ///
    /// @param dcm_matrix			The current orientation rotation matrix
    ///
    /// @returns heading in radians
    ///
    float calculate_heading(const Matrix3f &dcm_matrix) const {
        return calculate_heading(dcm_matrix, _first_usable);
    }
    float calculate_heading(const Matrix3f &dcm_matrix, uint8_t i) const;

    /// Sets offset x/y/z values.
    ///
    /// @param  i                   compass instance
    /// @param  offsets             Offsets to the raw mag_ values in milligauss.
    ///
    void set_offsets(uint8_t i, const Vector3f &offsets);

    /// Sets and saves the compass offset x/y/z values.
    ///
    /// @param  i                   compass instance
    /// @param  offsets             Offsets to the raw mag_ values in milligauss.
    ///
    void set_and_save_offsets(uint8_t i, const Vector3f &offsets);
#if AP_COMPASS_DIAGONALS_ENABLED
    void set_and_save_diagonals(uint8_t i, const Vector3f &diagonals);
    void set_and_save_offdiagonals(uint8_t i, const Vector3f &diagonals);
#endif
    void set_and_save_scale_factor(uint8_t i, float scale_factor);
    void set_and_save_orientation(uint8_t i, Rotation orientation);

    /// Saves the current offset x/y/z values for one or all compasses
    ///
    /// @param  i                   compass instance
    ///
    /// This should be invoked periodically to save the offset values maintained by
    /// ::learn_offsets.
    ///
    void save_offsets(uint8_t i);
    void save_offsets(void);

    // return the number of compass instances
    uint8_t get_count(void) const { return _compass_count; }

    // return the number of enabled sensors
    uint8_t get_num_enabled(void) const;
    
    /// Return the current field as a Vector3f in milligauss
    const Vector3f &get_field(uint8_t i) const { return _get_state(Priority(i)).field; }
    const Vector3f &get_field(void) const { return get_field(_first_usable); }

    /// Return true if we have set a scale factor for a compass
    bool have_scale_factor(uint8_t i) const;

#if COMPASS_MOT_ENABLED
    // per-motor calibration access
    void per_motor_calibration_start(void) {
        _per_motor.calibration_start();
    }
    void per_motor_calibration_update(void) {
        _per_motor.calibration_update();
    }
    void per_motor_calibration_end(void) {
        _per_motor.calibration_end();
    }
#endif

#if COMPASS_CAL_ENABLED
    // compass calibrator interface
    void cal_update();

    // start_calibration_all will only return false if there are no
    // compasses to calibrate.
    bool start_calibration_all(bool retry=false, bool autosave=false, float delay_sec=0.0f, bool autoreboot = false);

    void cancel_calibration_all();

    bool compass_cal_requires_reboot() const { return _cal_requires_reboot; }
    bool is_calibrating() const;

#if HAL_MAVLINK_BINDINGS_ENABLED
    /*
      handle an incoming MAG_CAL command
    */
    MAV_RESULT handle_mag_cal_command(const mavlink_command_int_t &packet);

    bool send_mag_cal_progress(const class GCS_MAVLINK& link);
    bool send_mag_cal_report(const class GCS_MAVLINK& link);
#endif  // HAL_MAVLINK_BINDINGS_ENABLED
#endif  // COMPASS_CAL_ENABLED

    // indicate which bit in LOG_BITMASK indicates we should log compass readings
    void set_log_bit(uint32_t log_bit) { _log_bit = log_bit; }

    // check if the compasses are pointing in the same direction
    bool consistent() const;

    /// Return the health of a compass
    bool healthy(uint8_t i) const;
    bool healthy(void) const { return healthy(_first_usable); }
    uint8_t get_healthy_mask() const;

    /// Returns the current offset values
    ///
    /// @returns                    The current compass offsets in milligauss.
    ///
    const Vector3f &get_offsets(uint8_t i) const { return _get_state(Priority(i)).offset; }
    const Vector3f &get_offsets(void) const { return get_offsets(_first_usable); }

#if AP_COMPASS_DIAGONALS_ENABLED
    const Vector3f &get_diagonals(uint8_t i) const { return _get_state(Priority(i)).diagonals; }
    const Vector3f &get_diagonals(void) const { return get_diagonals(_first_usable); }

    const Vector3f &get_offdiagonals(uint8_t i) const { return _get_state(Priority(i)).offdiagonals; }
    const Vector3f &get_offdiagonals(void) const { return get_offdiagonals(_first_usable); }
#endif  // AP_COMPASS_DIAGONALS_ENABLED

    // learn offsets accessor
    bool learn_offsets_enabled() const { return _learn == LEARN_INFLIGHT; }

    /// return true if the compass should be used for yaw calculations
    bool use_for_yaw(uint8_t i) const;
    bool use_for_yaw(void) const;

    /// Sets the local magnetic field declination.
    ///
    /// @param  radians             Local field declination.
    /// @param save_to_eeprom       true to save to eeprom (false saves only to memory)
    ///
    void set_declination(float radians, bool save_to_eeprom = true);
    float get_declination() const;

    bool auto_declination_enabled() const { return _auto_declination != 0; }

    // set overall board orientation
    void set_board_orientation(enum Rotation orientation) {
        _board_orientation = orientation;
    }

    // get overall board orientation
    enum Rotation get_board_orientation(void) const {
        return _board_orientation;
    }

    /// Set the motor compensation type
    ///
    /// @param  comp_type           0 = disabled, 1 = enabled use throttle, 2 = enabled use current
    ///
    void motor_compensation_type(const uint8_t comp_type);

    /// get the motor compensation value.
    uint8_t get_motor_compensation_type() const {
        return _motor_comp_type;
    }

    /// Set the motor compensation factor x/y/z values.
    ///
    /// @param  i                   instance of compass
    /// @param  offsets             Offsets multiplied by the throttle value and added to the raw mag_ values.
    ///
    void set_motor_compensation(uint8_t i, const Vector3f &motor_comp_factor);

    /// get motor compensation factors as a vector
    const Vector3f& get_motor_compensation(uint8_t i) const { return _get_state(Priority(i)).motor_compensation; }
    const Vector3f& get_motor_compensation(void) const { return get_motor_compensation(_first_usable); }

    /// Saves the current motor compensation x/y/z values.
    ///
    /// This should be invoked periodically to save the offset values calculated by the motor compensation auto learning
    ///
    void save_motor_compensation();

    /// Returns the current motor compensation offset values
    ///
    /// @returns                    The current compass offsets in milligauss.
    ///
    const Vector3f &get_motor_offsets(uint8_t i) const { return _get_state(Priority(i)).motor_offset; }
    const Vector3f &get_motor_offsets(void) const { return get_motor_offsets(_first_usable); }

    /// Set the throttle as a percentage from 0.0 to 1.0
    /// @param thr_pct              throttle expressed as a percentage from 0 to 1.0
    void set_throttle(float thr_pct) {
        if (_motor_comp_type == AP_COMPASS_MOT_COMP_THROTTLE) {
            _thr = thr_pct;
        }
    }

#if COMPASS_MOT_ENABLED
    /// Set the battery voltage for per-motor compensation
    void set_voltage(float voltage) {
        _per_motor.set_voltage(voltage);
    }
#endif
    
    /// Returns True if the compasses have been configured (i.e. offsets saved)
    ///
    /// @returns                    True if compass has been configured
    ///
    bool configured(uint8_t i);
    bool configured(char *failure_msg, uint8_t failure_msg_len);

    // return last update time in microseconds
    uint32_t last_update_usec(void) const { return last_update_usec(_first_usable); }
    uint32_t last_update_usec(uint8_t i) const { return _get_state(Priority(i)).last_update_usec; }

    uint32_t last_update_ms(void) const { return last_update_ms(_first_usable); }
    uint32_t last_update_ms(uint8_t i) const { return _get_state(Priority(i)).last_update_ms; }

    static const struct AP_Param::GroupInfo var_info[];

    enum LearnType {
        LEARN_NONE=0,
        LEARN_INTERNAL=1,
        LEARN_EKF=2,
        LEARN_INFLIGHT=3
    };

    // return the chosen learning type
    enum LearnType get_learn_type(void) const {
        return (enum LearnType)_learn.get();
    }

    // set the learning type
    void set_learn_type(enum LearnType type, bool save) {
        if (save) {
            _learn.set_and_save((int8_t)type);
        } else {
            _learn.set((int8_t)type);
        }
    }
    
    // return maximum allowed compass offsets
    uint16_t get_offsets_max(void) const {
        return (uint16_t)_offset_max.get();
    }

    uint8_t get_filter_range() const { return uint8_t(_filter_range.get()); }

#if AP_COMPASS_CALIBRATION_FIXED_YAW_ENABLED
    /*
      fast compass calibration given vehicle position and yaw
     */
    bool mag_cal_fixed_yaw(float yaw_deg, uint8_t compass_mask,
                           float lat_deg, float lon_deg,
                           bool force_use=false);
#endif

#if AP_COMPASS_MSP_ENABLED
    void handle_msp(const MSP::msp_compass_data_message_t &pkt);
#endif

#if AP_COMPASS_EXTERNALAHRS_ENABLED
    void handle_external(const AP_ExternalAHRS::mag_data_message_t &pkt);
#endif

    // force save of current calibration as valid
    void force_save_calibration(void);

    // get the first compass marked for use by COMPASSx_USE
    uint8_t get_first_usable(void) const { return _first_usable; }

private:
    static Compass *_singleton;

    // Use Priority and StateIndex typesafe index types
    // to distinguish between two different type of indexing
    // We use StateIndex for access by Backend
    // and Priority for access by Frontend
    DECLARE_TYPESAFE_INDEX(Priority, uint8_t);
    DECLARE_TYPESAFE_INDEX(StateIndex, uint8_t);

    /// Register a new compas driver, allocating an instance number
    ///
    /// @param  dev_id                   Dev ID of compass to register against
    ///
    /// @return instance number saved against the dev id or first available empty instance number
    bool register_compass(int32_t dev_id, uint8_t& instance);

    // load backend drivers
    bool _add_backend(AP_Compass_Backend *backend);
    void _probe_external_i2c_compasses(void);
    void _detect_backends(void);
    void probe_i2c_spi_compasses(void);
#if AP_COMPASS_DRONECAN_ENABLED
    void probe_dronecan_compasses(void);
#endif

#if COMPASS_CAL_ENABLED
    // compass cal
    void _update_calibration_trampoline();
    bool _accept_calibration(uint8_t i);
    bool _accept_calibration_mask(uint8_t mask);
    void _cancel_calibration(uint8_t i);
    void _cancel_calibration_mask(uint8_t mask);
    uint8_t _get_cal_mask();
    bool _start_calibration(uint8_t i, bool retry=false, float delay_sec=0.0f);
    bool _start_calibration_mask(uint8_t mask, bool retry=false, bool autosave=false, float delay_sec=0.0f, bool autoreboot=false);
    bool _auto_reboot() const { return _compass_cal_autoreboot; }
#if HAL_MAVLINK_BINDINGS_ENABLED
    Priority next_cal_progress_idx[MAVLINK_COMM_NUM_BUFFERS];
    Priority next_cal_report_idx[MAVLINK_COMM_NUM_BUFFERS];
#endif
#endif  // COMPASS_CAL_ENABLED

    // see if we already have probed a i2c driver by bus number and address
    bool _have_i2c_driver(uint8_t bus_num, uint8_t address) const;

#if AP_COMPASS_CALIBRATION_FIXED_YAW_ENABLED
    /*
      get mag field with the effects of offsets, diagonals and
      off-diagonals removed
    */
    bool get_uncorrected_field(uint8_t instance, Vector3f &field) const;
#endif

#if COMPASS_CAL_ENABLED
    //keep track of which calibrators have been saved
    RestrictIDTypeArray<bool, COMPASS_MAX_INSTANCES, Priority> _cal_saved;
    bool _cal_autosave;

    //autoreboot after compass calibration
    bool _compass_cal_autoreboot;
    bool _cal_requires_reboot;
    bool _cal_has_run;
#endif  // COMPASS_CAL_ENABLED

    // enum of drivers for COMPASS_DISBLMSK
    enum DriverType {
#if AP_COMPASS_HMC5843_ENABLED
        DRIVER_HMC5843  =0,
#endif
#if AP_COMPASS_LSM303D_ENABLED
        DRIVER_LSM303D  =1,
#endif
#if AP_COMPASS_AK8963_ENABLED
        DRIVER_AK8963   =2,
#endif
#if AP_COMPASS_BMM150_ENABLED
        DRIVER_BMM150   =3,
#endif
#if AP_COMPASS_LSM9DS1_ENABLED
        DRIVER_LSM9DS1  =4,
#endif
#if AP_COMPASS_LIS3MDL_ENABLED
        DRIVER_LIS3MDL  =5,
#endif
#if AP_COMPASS_AK09916_ENABLED
        DRIVER_AK09916  =6,
#endif
#if AP_COMPASS_IST8310_ENABLED
        DRIVER_IST8310  =7,
#endif
#if AP_COMPASS_ICM20948_ENABLED
        DRIVER_ICM20948 =8,
#endif
#if AP_COMPASS_MMC3416_ENABLED
        DRIVER_MMC3416  =9,
#endif
#if AP_COMPASS_DRONECAN_ENABLED
        DRIVER_UAVCAN   =11,
#endif
#if AP_COMPASS_QMC5883L_ENABLED
        DRIVER_QMC5883L =12,
#endif
#if AP_COMPASS_SITL_ENABLED
        DRIVER_SITL     =13,
#endif
#if AP_COMPASS_MAG3110_ENABLED
        DRIVER_MAG3110  =14,
#endif
#if AP_COMPASS_IST8308_ENABLED
        DRIVER_IST8308  =15,
#endif
#if AP_COMPASS_RM3100_ENABLED
		DRIVER_RM3100   =16,
#endif
#if AP_COMPASS_MSP_ENABLED
        DRIVER_MSP      =17,
#endif
#if AP_COMPASS_EXTERNALAHRS_ENABLED
        DRIVER_EXTERNALAHRS   =18,
#endif
#if AP_COMPASS_MMC5XX3_ENABLED
        DRIVER_MMC5XX3  =19,
#endif
#if AP_COMPASS_QMC5883P_ENABLED
        DRIVER_QMC5883P =20,
#endif
};

    bool _driver_enabled(enum DriverType driver_type);
    
    // backend objects
    AP_Compass_Backend *_backends[COMPASS_MAX_BACKEND];
    uint8_t     _backend_count;

    // whether to enable the compass drivers at all
    AP_Int8     _enabled;

    // number of registered compasses.
    uint8_t     _compass_count;

    // number of unregistered compasses.
    uint8_t     _unreg_compass_count;

    // settable parameters
    AP_Int8 _learn;

    // board orientation from AHRS
    enum Rotation _board_orientation = ROTATION_NONE;

    // declination in radians
    AP_Float    _declination;

    // enable automatic declination code
    AP_Int8     _auto_declination;

    // stores which bit is used to indicate we should log compass readings
    uint32_t _log_bit = -1;

    // motor compensation type
    // 0 = disabled, 1 = enabled for throttle, 2 = enabled for current
    AP_Int8     _motor_comp_type;

    // automatic compass orientation on calibration
    AP_Int8     _rotate_auto;

    // throttle expressed as a percentage from 0 ~ 1.0, used for motor compensation
    float       _thr;

    struct mag_state {
        AP_Int8     external;
        bool        healthy;
        bool        registered;
        Compass::Priority priority;
        AP_Int8     orientation;
        AP_Vector3f offset;
#if AP_COMPASS_DIAGONALS_ENABLED
        AP_Vector3f diagonals;
        AP_Vector3f offdiagonals;
#endif
        AP_Float    scale_factor;

        // device id detected at init.
        // saved to eeprom when offsets are saved allowing ram &
        // eeprom values to be compared as consistency check
        AP_Int32    dev_id;
        // Initialised when compass is detected
        int32_t detected_dev_id;
        // Initialised at boot from saved devid
        int32_t expected_dev_id;

        // factors multiplied by throttle and added to compass outputs
        AP_Vector3f motor_compensation;

        // latest compensation added to compass
        Vector3f    motor_offset;

        // corrected magnetic field strength
        Vector3f    field;

        // when we last got data
        uint32_t    last_update_ms;
        uint32_t    last_update_usec;

        // board specific orientation
        enum Rotation rotation;

        // accumulated samples, protected by _sem, used by AP_Compass_Backend
        Vector3f accum;
        uint32_t accum_count;
        // We only copy persistent params
        void copy_from(const mag_state& state);
    };

    //Create an Array of mag_state to be accessible by StateIndex only
    RestrictIDTypeArray<mag_state, COMPASS_MAX_INSTANCES+1, StateIndex> _state;

    //Convert Priority to StateIndex
    StateIndex _get_state_id(Priority priority) const;
    //Get State Struct by Priority
    const struct mag_state& _get_state(Priority priority) const { return _state[_get_state_id(priority)]; }
    //Convert StateIndex to Priority
    Priority _get_priority(StateIndex state_id) { return _state[state_id].priority; }
    //Method to detect compass beyond initialisation stage
    void _detect_runtime(void);
    // This method reorganises devid list to match
    // priority list, only call before detection at boot
#if COMPASS_MAX_INSTANCES > 1
    void _reorder_compass_params();
#endif
    // Update Priority List for Mags, by default, we just
    // load them as they come up the first time
    Priority _update_priority_list(int32_t dev_id);
    
    // method to check if the mag with the devid 
    // is a replacement mag
    bool is_replacement_mag(uint32_t dev_id);

    //remove the devid from unreg compass list
    void remove_unreg_dev_id(uint32_t devid);

    void _reset_compass_id();
    //Create Arrays to be accessible by Priority only
    RestrictIDTypeArray<AP_Int8, COMPASS_MAX_INSTANCES, Priority> _use_for_yaw;
#if COMPASS_MAX_INSTANCES > 1
    RestrictIDTypeArray<AP_Int32, COMPASS_MAX_INSTANCES, Priority> _priority_did_stored_list;
    RestrictIDTypeArray<int32_t, COMPASS_MAX_INSTANCES, Priority> _priority_did_list;
#endif

    AP_Int16 _offset_max;

    // bitmask of options
    enum class Option : uint16_t {
        CAL_REQUIRE_GPS = (1U<<0),
        ALLOW_DRONECAN_AUTO_REPLACEMENT = (1U<<1),
    };
    bool option_set(Option opt) const { return (_options.get() & uint16_t(opt)) != 0; }
    AP_Int16 _options;

#if COMPASS_CAL_ENABLED
    RestrictIDTypeArray<CompassCalibrator*, COMPASS_MAX_INSTANCES, Priority> _calibrator;
#endif

#if COMPASS_MOT_ENABLED
    // per-motor compass compensation
    Compass_PerMotor _per_motor{*this};
#endif
    
    AP_Float _calibration_threshold;

    // mask of driver types to not load. Bit positions match DEVTYPE_ in backend
    AP_Int32 _driver_type_mask;

#if COMPASS_MAX_UNREG_DEV
    // Put extra dev ids detected
    AP_Int32 extra_dev_id[COMPASS_MAX_UNREG_DEV];
    uint32_t _previously_unreg_mag[COMPASS_MAX_UNREG_DEV];
#endif

    AP_Int8 _filter_range;

    CompassLearn *learn;
    bool learn_allocated;

    /// Sets the initial location used to get declination
    ///
    /// @param  latitude             GPS Latitude.
    /// @param  longitude            GPS Longitude.
    ///
    void try_set_initial_location();
    bool _initial_location_set;

    bool _cal_thread_started;

#if AP_COMPASS_MSP_ENABLED
    uint8_t msp_instance_mask;
#endif
    bool init_done;

    bool suppress_devid_save;

    uint8_t _first_usable; // first compass usable based on COMPASSx_USE param
};

namespace AP {
    Compass &compass();
};
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  /*
 * This file is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This file is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
/*
  Driver by Andrew Tridgell, Nov 2016
 */
#include "AP_Compass_AK09916.h"

#if AP_COMPASS_AK09916_ENABLED

#include <assert.h>
#include <AP_HAL/AP_HAL.h>
#include <utility>
#include <AP_Math/AP_Math.h>
#include <stdio.h>
#include <AP_InertialSensor/AP_InertialSensor_Invensensev2.h>
#include <GCS_MAVLink/GCS.h>
#include <AP_BoardConfig/AP_BoardConfig.h>

extern const AP_HAL::HAL &hal;

#define REG_COMPANY_ID      0x00
#define REG_DEVICE_ID       0x01
#define REG_ST1             0x10
#define REG_HXL             0x11
#define REG_HXH             0x12
#define REG_HYL             0x13
#define REG_HYH             0x14
#define REG_HZL             0x15
#define REG_HZH             0x16
#define REG_TMPS            0x17
#define REG_ST2             0x18
#define REG_CNTL1           0x30
#define REG_CNTL2           0x31
#define REG_CNTL3           0x32

#define REG_ICM_WHOAMI      0x00
#define REG_ICM_PWR_MGMT_1  0x06
#define REG_ICM_INT_PIN_CFG 0x0f

#define ICM_WHOAMI_VAL      0xEA

#define AK09915_Device_ID   0x10
#define AK09916_Device_ID   0x09
#define AK09918_Device_ID   0x0c
#define AK09916_MILLIGAUSS_SCALE 10.0f

extern const AP_HAL::HAL &hal;

AP_Compass_AK09916::AP_Compass_AK09916(AP_AK09916_BusDriver *bus,
                                        bool force_external,
                                        enum Rotation rotation)
    : _bus(bus)
    , _force_external(force_external)
    , _rotation(rotation)
{
}

AP_Compass_AK09916::~AP_Compass_AK09916()
{
    delete _bus;
}

AP_Compass_Backend *AP_Compass_AK09916::probe(AP_HAL::OwnPtr<AP_HAL::I2CDevice> dev,
                                             bool force_external,
                                             enum Rotation rotation)
{
    if (!dev) {
        return nullptr;
    }
    AP_AK09916_BusDriver *bus = NEW_NOTHROW AP_AK09916_BusDriver_HALDevice(std::move(dev));
    if (!bus) {
        return nullptr;
    }

    AP_Compass_AK09916 *sensor = NEW_NOTHROW AP_Compass_AK09916(bus, force_external, rotation);
    if (!sensor || !sensor->init()) {
        delete sensor;
        return nullptr;
    }

    return sensor;
}

#if AP_COMPASS_ICM20948_ENABLED
AP_Compass_Backend *AP_Compass_AK09916::probe_ICM20948(AP_HAL::OwnPtr<AP_HAL::I2CDevice> dev,
                                                     AP_HAL::OwnPtr<AP_HAL::I2CDevice> dev_icm,
                                                     bool force_external,
                                                     enum Rotation rotation)
{
    if (!dev || !dev_icm) {
        return nullptr;
    }

    dev->get_semaphore()->take_blocking();

    /* Allow ICM20x48 to shortcut auxiliary bus and host bus */
    uint8_t rval;
    uint16_t whoami;
    uint8_t retries = 5;
    if (!dev_icm->read_registers(REG_ICM_WHOAMI, &rval, 1) ||
        rval != ICM_WHOAMI_VAL) {
        // not an ICM_WHOAMI
        goto fail;
    }
    do {
        // reset then bring sensor out of sleep mode
        if (!dev_icm->write_register(REG_ICM_PWR_MGMT_1, 0x80)) {
            goto fail;
        }
        hal.scheduler->delay(10);

        if (!dev_icm->write_register(REG_ICM_PWR_MGMT_1, 0x00)) {
            goto fail;
        }
        hal.scheduler->delay(10);
        
        // see if ICM20948 is sleeping
        if (!dev_icm->read_registers(REG_ICM_PWR_MGMT_1, &rval, 1)) {
            goto fail;
        }
        if ((rval & 0x40) == 0) {
            break;
        }
    } while (retries--);
    
    if (rval & 0x40) {
        // it didn't come out of sleep
        goto fail;
    }

    // initially force i2c bypass off
    dev_icm->write_register(REG_ICM_INT_PIN_CFG, 0x00);
    hal.scheduler->delay(1);

    // now check if a AK09916 shows up on the bus. If it does then
    // we have both a real AK09916 and a ICM20948 with an embedded
    // AK09916. In that case we will fail the driver load and use
    // the main AK09916 driver
    if (dev->read_registers(REG_COMPANY_ID, (uint8_t *)&whoami, 2)) {
        // a device is replying on the AK09916 I2C address, don't
        // load the ICM20948
        DEV_PRINTF("ICM20948: AK09916 bus conflict\n");
        goto fail;
    }

    // now force bypass on
    dev_icm->write_register(REG_ICM_INT_PIN_CFG, 0x02);
    hal.scheduler->delay(1);
    dev->get_semaphore()->give();
    return probe(std::move(dev), force_external, rotation);
fail:
    dev->get_semaphore()->give();
    return nullptr;
}

// un-named, assume SPI for compat
AP_Compass_Backend *AP_Compass_AK09916::probe_ICM20948(uint8_t inv2_instance,
                                                     enum Rotation rotation)
{  
    return probe_ICM20948_SPI(inv2_instance,rotation);
}

AP_Compass_Backend *AP_Compass_AK09916::probe_ICM20948_SPI(uint8_t inv2_instance,
                                                     enum Rotation rotation)
{
#if AP_INERTIALSENSOR_ENABLED
    AP_InertialSensor &ins = AP::ins();

    AP_AK09916_BusDriver *bus =
        NEW_NOTHROW AP_AK09916_BusDriver_Auxiliary(ins, HAL_INS_INV2_SPI, inv2_instance, HAL_COMPASS_AK09916_I2C_ADDR);
    if (!bus) {
        return nullptr;
    }

    AP_Compass_AK09916 *sensor = NEW_NOTHROW AP_Compass_AK09916(bus, false, rotation);
    if (!sensor || !sensor->init()) {
        delete sensor;
        return nullptr;
    }

    return sensor;
#else
    return nullptr;
#endif
}

AP_Compass_Backend *AP_Compass_AK09916::probe_ICM20948_I2C(uint8_t inv2_instance,
                                                     enum Rotation rotation)
{
    AP_InertialSensor &ins = AP::ins();

    AP_AK09916_BusDriver *bus =
        NEW_NOTHROW AP_AK09916_BusDriver_Auxiliary(ins, HAL_INS_INV2_I2C, inv2_instance, HAL_COMPASS_AK09916_I2C_ADDR);
    if (!bus) {
        return nullptr;
    }

    AP_Compass_AK09916 *sensor = NEW_NOTHROW AP_Compass_AK09916(bus, false, rotation);
    if (!sensor || !sensor->init()) {
        delete sensor;
        return nullptr;
    }

    return sensor;
}
#endif  // AP_COMPASS_ICM20948_ENABLED

bool AP_Compass_AK09916::init()
{
    AP_HAL::Semaphore *bus_sem = _bus->get_semaphore();

    if (!bus_sem) {
        return false;
    }
    _bus->get_semaphore()->take_blocking();

    if (!_bus->configure()) {
        DEV_PRINTF("AK09916: Could not configure the bus\n");
        goto fail;
    }

    if (!_reset()) {
        goto fail;
    }

    if (!_check_id()) {
        goto fail;
    }

    // one checked register for mode
    _bus->setup_checked_registers(1);

    if (!_setup_mode()) {
        DEV_PRINTF("AK09916: Could not setup mode\n");
        goto fail;
    }

    if (!_bus->start_measurements()) {
        DEV_PRINTF("AK09916: Could not start measurements\n");
        goto fail;
    }

    _initialized = true;

    /* register the compass instance in the frontend */
    _bus->set_device_type(_devtype);
    if (!register_compass(_bus->get_bus_id(), _compass_instance)) {
        goto fail;
    }
    set_dev_id(_compass_instance, _bus->get_bus_id());

    if (_force_external) {
        set_external(_compass_instance, true);
    }

    set_rotation(_compass_instance, _rotation);
    
    bus_sem->give();

    _bus->register_periodic_callback(10000, FUNCTOR_BIND_MEMBER(&AP_Compass_AK09916::_update, void));

    return true;

fail:
    bus_sem->give();
    return false;
}

void AP_Compass_AK09916::read()
{
    if (!_initialized) {
        return;
    }

    drain_accumulated_samples(_compass_instance);
}

void AP_Compass_AK09916::_make_adc_sensitivity_adjustment(Vector3f& field) const
{
    static const float ADC_16BIT_RESOLUTION = 0.15f;

    field *= ADC_16BIT_RESOLUTION;
}

void AP_Compass_AK09916::_update()
{
    struct sample_regs regs = {0};
    Vector3f raw_field;

    if (!_bus->block_read(REG_ST1, (uint8_t *) &regs, sizeof(regs))) {
        goto check_registers;
    }

    if (!(regs.st1 & 0x01)) {
        no_data++;
        if (no_data == 5) {
            _reset();
            _setup_mode();
            no_data = 0;
        }
        goto check_registers;
    }
    no_data = 0;

    /* Check for overflow. See AK09916's datasheet*/
    if ((regs.st2 & 0x08)) {
        goto check_registers;
    }

    raw_field = Vector3f(regs.val[0], regs.val[1], regs.val[2]);

    if (is_zero(raw_field.x) && is_zero(raw_field.y) && is_zero(raw_field.z)) {
        goto check_registers;
    }

    _make_adc_sensitivity_adjustment(raw_field);
    raw_field *= AK09916_MILLIGAUSS_SCALE;

    accumulate_sample(raw_field, _compass_instance, 10);

check_registers:
    _bus->check_next_register();
}

bool AP_Compass_AK09916::_check_id()
{
    for (int i = 0; i < 5; i++) {
        uint8_t deviceid = 0;

        /* Read AK09916's id */
        if (_bus->register_read(REG_DEVICE_ID, &deviceid)) {
            switch (deviceid) {
            case AK09915_Device_ID:
                _devtype = DEVTYPE_AK09915;
                return true;
            case AK09916_Device_ID:
                _devtype = DEVTYPE_AK09916;
                return true;
            case AK09918_Device_ID:
                _devtype = DEVTYPE_AK09918;
                return true;
            }
        }
    }

    return false;
}

bool AP_Compass_AK09916::_setup_mode() {
    return _bus->register_write(REG_CNTL2, 0x08, true); //Continuous Mode 2
}

bool AP_Compass_AK09916::_reset()
{
    return _bus->register_write(REG_CNTL3, 0x01); //Soft Reset
}

/* AP_HAL::I2CDevice implementation of the AK09916 */
AP_AK09916_BusDriver_HALDevice::AP_AK09916_BusDriver_HALDevice(AP_HAL::OwnPtr<AP_HAL::I2CDevice> dev)
    : _dev(std::move(dev))
{
}

bool AP_AK09916_BusDriver_HALDevice::block_read(uint8_t reg, uint8_t *buf, uint32_t size)
{
    return _dev->read_registers(reg, buf, size);
}

bool AP_AK09916_BusDriver_HALDevice::register_read(uint8_t reg, uint8_t *val)
{
    return _dev->read_registers(reg, val, 1);
}

bool AP_AK09916_BusDriver_HALDevice::register_write(uint8_t reg, uint8_t val, bool checked)
{
    return _dev->write_register(reg, val, checked);
}

AP_HAL::Semaphore *AP_AK09916_BusDriver_HALDevice::get_semaphore()
{
    return _dev->get_semaphore();
}

AP_HAL::Device::PeriodicHandle AP_AK09916_BusDriver_HALDevice::register_periodic_callback(uint32_t period_usec, AP_HAL::Device::PeriodicCb cb)
{
    return _dev->register_periodic_callback(period_usec, cb);
}

/* AK09916 on an auxiliary bus of IMU driver */
AP_AK09916_BusDriver_Auxiliary::AP_AK09916_BusDriver_Auxiliary(AP_InertialSensor &ins, uint8_t backend_id,
                                                             uint8_t backend_instance, uint8_t addr)
{
    /*
     * Only initialize members. Fails are handled by configure or while
     * getting the semaphore
     */
#if AP_INERTIALSENSOR_ENABLED
    _bus = ins.get_auxiliary_bus(backend_id, backend_instance);
    if (!_bus) {
        return;
    }

    _slave = _bus->request_next_slave(addr);
#endif
}

AP_AK09916_BusDriver_Auxiliary::~AP_AK09916_BusDriver_Auxiliary()
{
    /* After started it's owned by AuxiliaryBus */
    if (!_started) {
        delete _slave;
    }
}

bool AP_AK09916_BusDriver_Auxiliary::block_read(uint8_t reg, uint8_t *buf, uint32_t size)
{
    if (_started) {
        /*
         * We can only read a block when reading the block of sample values -
         * calling with any other value is a mistake
         */
        if (reg != REG_ST1) {
            return false;
        }

        int n = _slave->read(buf);
        return n == static_cast<int>(size);
    }

    int r = _slave->passthrough_read(reg, buf, size);

    return r > 0 && static_cast<uint32_t>(r) == size;
}

bool AP_AK09916_BusDriver_Auxiliary::register_read(uint8_t reg, uint8_t *val)
{
    return _slave->passthrough_read(reg, val, 1) == 1;
}

bool AP_AK09916_BusDriver_Auxiliary::register_write(uint8_t reg, uint8_t val, bool checked)
{
    (void)checked;
    return _slave->passthrough_write(reg, val) == 1;
}

AP_HAL::Semaphore *AP_AK09916_BusDriver_Auxiliary::get_semaphore()
{
    return _bus ? _bus->get_semaphore() : nullptr;
}

bool AP_AK09916_BusDriver_Auxiliary::configure()
{
    if (!_bus || !_slave) {
        return false;
    }
    return true;
}

bool AP_AK09916_BusDriver_Auxiliary::start_measurements()
{
    if (_bus->register_periodic_read(_slave, REG_ST1, sizeof(AP_Compass_AK09916::sample_regs)) < 0) {
        return false;
    }

    _started = true;

    return true;
}

AP_HAL::Device::PeriodicHandle AP_AK09916_BusDriver_Auxiliary::register_periodic_callback(uint32_t period_usec, AP_HAL::Device::PeriodicCb cb)
{
    return _bus->register_periodic_callback(period_usec, cb);
}

// set device type within a device class
void AP_AK09916_BusDriver_Auxiliary::set_device_type(uint8_t devtype)
{
    _bus->set_device_type(devtype);
}

// return 24 bit bus identifier
uint32_t AP_AK09916_BusDriver_Auxiliary::get_bus_id(void) const
{
    return _bus->get_bus_id();
}

#endif  // AP_COMPASS_AK09916_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             /*
 * This file is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This file is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
#pragma once

#include "AP_Compass_config.h"

#if AP_COMPASS_AK09916_ENABLED

#include <AP_Common/AP_Common.h>
#include <AP_HAL/AP_HAL.h>
#include <AP_HAL/I2CDevice.h>
#include <AP_Math/AP_Math.h>

#include "AP_Compass.h"
#include "AP_Compass_Backend.h"

#ifndef HAL_COMPASS_AK09916_I2C_ADDR
# define HAL_COMPASS_AK09916_I2C_ADDR 0x0C
#endif


#ifndef HAL_COMPASS_ICM20948_I2C_ADDR
# define HAL_COMPASS_ICM20948_I2C_ADDR 0x69
#endif

#ifndef HAL_COMPASS_ICM20948_I2C_ADDR2
# define HAL_COMPASS_ICM20948_I2C_ADDR2 0x68
#endif

class AuxiliaryBus;
class AuxiliaryBusSlave;
class AP_InertialSensor;
class AP_AK09916_BusDriver;

class AP_Compass_AK09916 : public AP_Compass_Backend
{
public:
    /* Probe for AK09916 standalone on I2C bus */
    static AP_Compass_Backend *probe(AP_HAL::OwnPtr<AP_HAL::I2CDevice> dev,
                                     bool force_external,
                                     enum Rotation rotation);

#if AP_COMPASS_ICM20948_ENABLED
    /* Probe for AK09916 on auxiliary bus of ICM20948, connected through I2C */
    static AP_Compass_Backend *probe_ICM20948(AP_HAL::OwnPtr<AP_HAL::I2CDevice> dev,
                                             AP_HAL::OwnPtr<AP_HAL::I2CDevice> dev_icm,
                                             bool force_external,
                                             enum Rotation rotation);

    /* Probe for AK09916 on auxiliary bus of ICM20948, connected through SPI by default */
    static AP_Compass_Backend *probe_ICM20948(uint8_t mpu9250_instance, enum Rotation rotation);
    static AP_Compass_Backend *probe_ICM20948_SPI(uint8_t mpu9250_instance,
                                             enum Rotation rotation);

	/* Probe for AK09916 on auxiliary bus of ICM20948, connected through I2C */
    static AP_Compass_Backend *probe_ICM20948_I2C(uint8_t mpu9250_instance,
                                             enum Rotation rotation);
#endif

    static constexpr const char *name = "AK09916";

    virtual ~AP_Compass_AK09916();

    void read() override;

    /* Must be public so the BusDriver can access its definition */
    struct PACKED sample_regs {
        uint8_t st1;
        int16_t val[3];
        uint8_t tmps;
        uint8_t st2;
    };

private:
    AP_Compass_AK09916(AP_AK09916_BusDriver *bus, bool force_external,
                       enum Rotation rotation);

    bool init();
    void _make_factory_sensitivity_adjustment(Vector3f &field) const;
    void _make_adc_sensitivity_adjustment(Vector3f &field) const;

    bool _reset();
    bool _setup_mode();
    bool _check_id();
    bool _calibrate();

    void _update();

    AP_AK09916_BusDriver *_bus;

    bool _force_external;
    uint8_t _compass_instance;
    bool _initialized;
    enum Rotation _rotation;
    enum AP_Compass_Backend::DevTypes _devtype;
    uint8_t no_data;
};


class AP_AK09916_BusDriver
{
public:
    virtual ~AP_AK09916_BusDriver() { }

    virtual bool block_read(uint8_t reg, uint8_t *buf, uint32_t size) = 0;
    virtual bool register_read(uint8_t reg, uint8_t *val) = 0;
    virtual bool register_write(uint8_t reg, uint8_t val, bool checked=false) = 0;

    virtual AP_HAL::Semaphore  *get_semaphore() = 0;

    virtual bool configure() { return true; }
    virtual bool start_measurements() { return true; }
    virtual AP_HAL::Device::PeriodicHandle register_periodic_callback(uint32_t, AP_HAL::Device::PeriodicCb) = 0;

    // set device type within a device class
    virtual void set_device_type(uint8_t devtype) = 0;

    // return 24 bit bus identifier
    virtual uint32_t get_bus_id(void) const = 0;

    /**
     setup for register value checking. Frequency is how often to
     check registers. If set to 10 then every 10th call to
     check_next_register will check a register
     */
    virtual void setup_checked_registers(uint8_t num_regs) {}
    virtual void check_next_register(void) {}
};

class AP_AK09916_BusDriver_HALDevice: public AP_AK09916_BusDriver
{
public:
    AP_AK09916_BusDriver_HALDevice(AP_HAL::OwnPtr<AP_HAL::I2CDevice> dev);

    virtual bool block_read(uint8_t reg, uint8_t *buf, uint32_t size) override;
    virtual bool register_read(uint8_t reg, uint8_t *val) override;
    virtual bool register_write(uint8_t reg, uint8_t val, bool checked) override;

    virtual AP_HAL::Semaphore  *get_semaphore() override;
    AP_HAL::Device::PeriodicHandle register_periodic_callback(uint32_t period_usec, AP_HAL::Device::PeriodicCb) override;

    // set device type within a device class
    void set_device_type(uint8_t devtype) override {
        _dev->set_device_type(devtype);
    }

    // return 24 bit bus identifier
    uint32_t get_bus_id(void) const override {
        return _dev->get_bus_id();
    }

    /**
     setup for register value checking. Frequency is how often to
     check registers. If set to 10 then every 10th call to
     check_next_register will check a register
     */
    void setup_checked_registers(uint8_t num_regs) override {
        _dev->setup_checked_registers(num_regs);
    }
    void check_next_register(void) override {
        _dev->check_next_register();
    }
    
private:
    AP_HAL::OwnPtr<AP_HAL::I2CDevice> _dev;
};

class AP_AK09916_BusDriver_Auxiliary : public AP_AK09916_BusDriver
{
public:
    AP_AK09916_BusDriver_Auxiliary(AP_InertialSensor &ins, uint8_t backend_id,
                                  uint8_t backend_instance, uint8_t addr);
    ~AP_AK09916_BusDriver_Auxiliary();

    bool block_read(uint8_t reg, uint8_t *buf, uint32_t size) override;
    bool register_read(uint8_t reg, uint8_t *val) override;
    bool register_write(uint8_t reg, uint8_t val, bool checked) override;

    AP_HAL::Device::PeriodicHandle register_periodic_callback(uint32_t period_usec, AP_HAL::Device::PeriodicCb) override;
    
    AP_HAL::Semaphore  *get_semaphore() override;

    bool configure() override;
    bool start_measurements() override;

    // set device type within a device class
    void set_device_type(uint8_t devtype) override;

    // return 24 bit bus identifier
    uint32_t get_bus_id(void) const override;
    
private:
    AuxiliaryBus *_bus;
    AuxiliaryBusSlave *_slave;
    bool _started;
};

#endif  // AP_COMPASS_AK09916_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       /*
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include "AP_Compass_AK8963.h"

#if AP_COMPASS_AK8963_ENABLED

#include <assert.h>
#include <utility>

#include <AP_Math/AP_Math.h>
#include <AP_HAL/AP_HAL.h>

#include <AP_InertialSensor/AP_InertialSensor_Invensense.h>

#define AK8963_I2C_ADDR                                 0x0c

#define AK8963_WIA                                      0x00
#        define AK8963_Device_ID                        0x48

#define AK8963_HXL                                      0x03

/* bit definitions for AK8963 CNTL1 */
#define AK8963_CNTL1                                    0x0A
#        define    AK8963_CONTINUOUS_MODE1              0x02
#        define    AK8963_CONTINUOUS_MODE2              0x06
#        define    AK8963_SELFTEST_MODE                 0x08
#        define    AK8963_POWERDOWN_MODE                0x00
#        define    AK8963_FUSE_MODE                     0x0f
#        define    AK8963_16BIT_ADC                     0x10
#        define    AK8963_14BIT_ADC                     0x00

#define AK8963_CNTL2                                    0x0B
#        define AK8963_RESET                            0x01

#define AK8963_ASAX                                     0x10

#define AK8963_MILLIGAUSS_SCALE 10.0f

extern const AP_HAL::HAL &hal;

AP_Compass_AK8963::AP_Compass_AK8963(AP_AK8963_BusDriver *bus,
                                     enum Rotation rotation)
    : _bus(bus)
    , _rotation(rotation)
{
}

AP_Compass_AK8963::~AP_Compass_AK8963()
{
    delete _bus;
}

AP_Compass_Backend *AP_Compass_AK8963::probe(AP_HAL::OwnPtr<AP_HAL::I2CDevice> dev,
                                             enum Rotation rotation)
{
    if (!dev) {
        return nullptr;
    }
    AP_AK8963_BusDriver *bus = NEW_NOTHROW AP_AK8963_BusDriver_HALDevice(std::move(dev));
    if (!bus) {
        return nullptr;
    }

    AP_Compass_AK8963 *sensor = NEW_NOTHROW AP_Compass_AK8963(bus, rotation);
    if (!sensor || !sensor->init()) {
        delete sensor;
        return nullptr;
    }

    return sensor;
}

AP_Compass_Backend *AP_Compass_AK8963::probe_mpu9250(AP_HAL::OwnPtr<AP_HAL::I2CDevice> dev,
                                                     enum Rotation rotation)
{
    if (!dev) {
        return nullptr;
    }
#if AP_INERTIALSENSOR_ENABLED
    AP_InertialSensor &ins = *AP_InertialSensor::get_singleton();

    /* Allow MPU9250 to shortcut auxiliary bus and host bus */
    ins.detect_backends();
#endif

    return probe(std::move(dev), rotation);
}

AP_Compass_Backend *AP_Compass_AK8963::probe_mpu9250(uint8_t mpu9250_instance,
                                                     enum Rotation rotation)
{
#if AP_INERTIALSENSOR_ENABLED
    AP_InertialSensor &ins = *AP_InertialSensor::get_singleton();

    AP_AK8963_BusDriver *bus =
        NEW_NOTHROW AP_AK8963_BusDriver_Auxiliary(ins, HAL_INS_MPU9250_SPI, mpu9250_instance, AK8963_I2C_ADDR);
    if (!bus) {
        return nullptr;
    }

    AP_Compass_AK8963 *sensor = NEW_NOTHROW AP_Compass_AK8963(bus, rotation);
    if (!sensor || !sensor->init()) {
        delete sensor;
        return nullptr;
    }

    return sensor;
#else
    return nullptr;
#endif

}

bool AP_Compass_AK8963::init()
{
    AP_HAL::Semaphore *bus_sem = _bus->get_semaphore();

    if (!bus_sem) {
        return false;
    }
    _bus->get_semaphore()->take_blocking();

    if (!_bus->configure()) {
        DEV_PRINTF("AK8963: Could not configure the bus\n");
        goto fail;
    }

    if (!_check_id()) {
        DEV_PRINTF("AK8963: Wrong id\n");
        goto fail;
    }

    if (!_calibrate()) {
        DEV_PRINTF("AK8963: Could not read calibration data\n");
        goto fail;
    }

    if (!_setup_mode()) {
        DEV_PRINTF("AK8963: Could not setup mode\n");
        goto fail;
    }

    if (!_bus->start_measurements()) {
        DEV_PRINTF("AK8963: Could not start measurements\n");
        goto fail;
    }

    _initialized = true;

    /* register the compass instance in the frontend */
    _bus->set_device_type(DEVTYPE_AK8963);
    if (!register_compass(_bus->get_bus_id(), _compass_instance)) {
        goto fail;
    }
    set_dev_id(_compass_instance, _bus->get_bus_id());

    set_rotation(_compass_instance, _rotation);
    bus_sem->give();

    _bus->register_periodic_callback(10000, FUNCTOR_BIND_MEMBER(&AP_Compass_AK8963::_update, void));

    return true;

fail:
    bus_sem->give();
    return false;
}

void AP_Compass_AK8963::read()
{
    if (!_initialized) {
        return;
    }

    drain_accumulated_samples(_compass_instance);
}

void AP_Compass_AK8963::_make_adc_sensitivity_adjustment(Vector3f& field) const
{
    static const float ADC_16BIT_RESOLUTION = 0.15f;

    field *= ADC_16BIT_RESOLUTION;
}

void AP_Compass_AK8963::_make_factory_sensitivity_adjustment(Vector3f& field) const
{
    field.x *= _magnetometer_ASA[0];
    field.y *= _magnetometer_ASA[1];
    field.z *= _magnetometer_ASA[2];
}

void AP_Compass_AK8963::_update()
{
    struct sample_regs regs;
    Vector3f raw_field;

    if (!_bus->block_read(AK8963_HXL, (uint8_t *) &regs, sizeof(regs))) {
        return;
    }

    /* Check for overflow. See AK8963's datasheet, section
     * 6.4.3.6 - Magnetic Sensor Overflow. */
    if ((regs.st2 & 0x08)) {
        return;
    }

    raw_field = Vector3f(regs.val[0], regs.val[1], regs.val[2]);

    if (is_zero(raw_field.x) && is_zero(raw_field.y) && is_zero(raw_field.z)) {
        return;
    }

    _make_factory_sensitivity_adjustment(raw_field);
    _make_adc_sensitivity_adjustment(raw_field);
    raw_field *= AK8963_MILLIGAUSS_SCALE;

    accumulate_sample(raw_field, _compass_instance, 10);
}

bool AP_Compass_AK8963::_check_id()
{
    for (int i = 0; i < 5; i++) {
        uint8_t deviceid = 0;

        /* Read AK8963's id */
        if (_bus->register_read(AK8963_WIA, &deviceid) &&
            deviceid == AK8963_Device_ID) {
            return true;
        }
    }

    return false;
}

bool AP_Compass_AK8963::_setup_mode() {
    return _bus->register_write(AK8963_CNTL1, AK8963_CONTINUOUS_MODE2 | AK8963_16BIT_ADC);
}

bool AP_Compass_AK8963::_reset()
{
    return _bus->register_write(AK8963_CNTL2, AK8963_RESET);
}


bool AP_Compass_AK8963::_calibrate()
{
    /* Enable FUSE-mode in order to be able to read calibration data */
    _bus->register_write(AK8963_CNTL1, AK8963_FUSE_MODE | AK8963_16BIT_ADC);

    uint8_t response[3];

    _bus->block_read(AK8963_ASAX, response, 3);

    for (int i = 0; i < 3; i++) {
        float data = response[i];
        _magnetometer_ASA[i] = ((data - 128) / 256 + 1);
    }

    return true;
}

/* AP_HAL::I2CDevice implementation of the AK8963 */
AP_AK8963_BusDriver_HALDevice::AP_AK8963_BusDriver_HALDevice(AP_HAL::OwnPtr<AP_HAL::I2CDevice> dev)
    : _dev(std::move(dev))
{
}

bool AP_AK8963_BusDriver_HALDevice::block_read(uint8_t reg, uint8_t *buf, uint32_t size)
{
    return _dev->read_registers(reg, buf, size);
}

bool AP_AK8963_BusDriver_HALDevice::register_read(uint8_t reg, uint8_t *val)
{
    return _dev->read_registers(reg, val, 1);
}

bool AP_AK8963_BusDriver_HALDevice::register_write(uint8_t reg, uint8_t val)
{
    return _dev->write_register(reg, val);
}

AP_HAL::Semaphore *AP_AK8963_BusDriver_HALDevice::get_semaphore()
{
    return _dev->get_semaphore();
}

AP_HAL::Device::PeriodicHandle AP_AK8963_BusDriver_HALDevice::register_periodic_callback(uint32_t period_usec, AP_HAL::Device::PeriodicCb cb)
{
    return _dev->register_periodic_callback(period_usec, cb);
}

/* AK8963 on an auxiliary bus of IMU driver */
AP_AK8963_BusDriver_Auxiliary::AP_AK8963_BusDriver_Auxiliary(AP_InertialSensor &ins, uint8_t backend_id,
                                                             uint8_t backend_instance, uint8_t addr)
{
    /*
     * Only initialize members. Fails are handled by configure or while
     * getting the semaphore
     */
#if AP_INERTIALSENSOR_ENABLED
    _bus = ins.get_auxiliary_bus(backend_id, backend_instance);
    if (!_bus) {
        return;
    }

    _slave = _bus->request_next_slave(addr);
#endif
}

AP_AK8963_BusDriver_Auxiliary::~AP_AK8963_BusDriver_Auxiliary()
{
    /* After started it's owned by AuxiliaryBus */
    if (!_started) {
        delete _slave;
    }
}

bool AP_AK8963_BusDriver_Auxiliary::block_read(uint8_t reg, uint8_t *buf, uint32_t size)
{
    if (_started) {
        /*
         * We can only read a block when reading the block of sample values -
         * calling with any other value is a mistake
         */
        if (reg != AK8963_HXL) {
            return false;
        }

        int n = _slave->read(buf);
        return n == static_cast<int>(size);
    }

    int r = _slave->passthrough_read(reg, buf, size);

    return r > 0 && static_cast<uint32_t>(r) == size;
}

bool AP_AK8963_BusDriver_Auxiliary::register_read(uint8_t reg, uint8_t *val)
{
    return _slave->passthrough_read(reg, val, 1) == 1;
}

bool AP_AK8963_BusDriver_Auxiliary::register_write(uint8_t reg, uint8_t val)
{
    return _slave->passthrough_write(reg, val) == 1;
}

AP_HAL::Semaphore *AP_AK8963_BusDriver_Auxiliary::get_semaphore()
{
    return _bus ? _bus->get_semaphore() : nullptr;
}

bool AP_AK8963_BusDriver_Auxiliary::configure()
{
    if (!_bus || !_slave) {
        return false;
    }
    return true;
}

bool AP_AK8963_BusDriver_Auxiliary::start_measurements()
{
    if (_bus->register_periodic_read(_slave, AK8963_HXL, sizeof(AP_Compass_AK8963::sample_regs)) < 0) {
        return false;
    }

    _started = true;

    return true;
}

AP_HAL::Device::PeriodicHandle AP_AK8963_BusDriver_Auxiliary::register_periodic_callback(uint32_t period_usec, AP_HAL::Device::PeriodicCb cb)
{
    return _bus->register_periodic_callback(period_usec, cb);
}

// set device type within a device class
void AP_AK8963_BusDriver_Auxiliary::set_device_type(uint8_t devtype)
{
    _bus->set_device_type(devtype);
}

// return 24 bit bus identifier
uint32_t AP_AK8963_BusDriver_Auxiliary::get_bus_id(void) const
{
    return _bus->get_bus_id();
}

#endif  // AP_COMPASS_AK8963_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         #pragma once

#include "AP_Compass_config.h"

#if AP_COMPASS_AK8963_ENABLED

#include <AP_Common/AP_Common.h>
#include <AP_HAL/AP_HAL.h>
#include <AP_HAL/I2CDevice.h>
#include <AP_HAL/SPIDevice.h>
#include <AP_Math/AP_Math.h>

#include "AP_Compass.h"
#include "AP_Compass_Backend.h"

class AuxiliaryBus;
class AuxiliaryBusSlave;
class AP_InertialSensor;
class AP_AK8963_BusDriver;

class AP_Compass_AK8963 : public AP_Compass_Backend
{
public:
    /* Probe for AK8963 standalone on I2C bus */
    static AP_Compass_Backend *probe(AP_HAL::OwnPtr<AP_HAL::I2CDevice> dev,
                                     enum Rotation rotation);

    /* Probe for AK8963 on auxiliary bus of MPU9250, connected through I2C */
    static AP_Compass_Backend *probe_mpu9250(AP_HAL::OwnPtr<AP_HAL::I2CDevice> dev,
                                             enum Rotation rotation);

    /* Probe for AK8963 on auxiliary bus of MPU9250, connected through SPI */
    static AP_Compass_Backend *probe_mpu9250(uint8_t mpu9250_instance,
                                             enum Rotation rotation);

    static constexpr const char *name = "AK8963";

    virtual ~AP_Compass_AK8963();

    void read() override;

    /* Must be public so the BusDriver can access its definition */
    struct PACKED sample_regs {
        int16_t val[3];
        uint8_t st2;
    };

private:
    AP_Compass_AK8963(AP_AK8963_BusDriver *bus,
                      enum Rotation rotation);

    bool init();
    void _make_factory_sensitivity_adjustment(Vector3f &field) const;
    void _make_adc_sensitivity_adjustment(Vector3f &field) const;

    bool _reset();
    bool _setup_mode();
    bool _check_id();
    bool _calibrate();

    void _update();

    AP_AK8963_BusDriver *_bus;

    float _magnetometer_ASA[3] {0, 0, 0};

    uint8_t _compass_instance;
    bool _initialized;
    enum Rotation _rotation;
};

class AP_AK8963_BusDriver
{
public:
    virtual ~AP_AK8963_BusDriver() { }

    virtual bool block_read(uint8_t reg, uint8_t *buf, uint32_t size) = 0;
    virtual bool register_read(uint8_t reg, uint8_t *val) = 0;
    virtual bool register_write(uint8_t reg, uint8_t val) = 0;

    virtual AP_HAL::Semaphore  *get_semaphore() = 0;

    virtual bool configure() { return true; }
    virtual bool start_measurements() { return true; }
    virtual AP_HAL::Device::PeriodicHandle register_periodic_callback(uint32_t, AP_HAL::Device::PeriodicCb) = 0;

    // set device type within a device class
    virtual void set_device_type(uint8_t devtype) = 0;

    // return 24 bit bus identifier
    virtual uint32_t get_bus_id(void) const = 0;
};

class AP_AK8963_BusDriver_HALDevice: public AP_AK8963_BusDriver
{
public:
    AP_AK8963_BusDriver_HALDevice(AP_HAL::OwnPtr<AP_HAL::I2CDevice> dev);

    virtual bool block_read(uint8_t reg, uint8_t *buf, uint32_t size) override;
    virtual bool register_read(uint8_t reg, uint8_t *val) override;
    virtual bool register_write(uint8_t reg, uint8_t val) override;

    virtual AP_HAL::Semaphore  *get_semaphore() override;
    AP_HAL::Device::PeriodicHandle register_periodic_callback(uint32_t period_usec, AP_HAL::Device::PeriodicCb) override;

    // set device type within a device class
    void set_device_type(uint8_t devtype) override {
        _dev->set_device_type(devtype);
    }

    // return 24 bit bus identifier
    uint32_t get_bus_id(void) const override {
        return _dev->get_bus_id();
    }
    
private:
    AP_HAL::OwnPtr<AP_HAL::I2CDevice> _dev;
};

class AP_AK8963_BusDriver_Auxiliary : public AP_AK8963_BusDriver
{
public:
    AP_AK8963_BusDriver_Auxiliary(AP_InertialSensor &ins, uint8_t backend_id,
                                  uint8_t backend_instance, uint8_t addr);
    ~AP_AK8963_BusDriver_Auxiliary();

    bool block_read(uint8_t reg, uint8_t *buf, uint32_t size) override;
    bool register_read(uint8_t reg, uint8_t *val) override;
    bool register_write(uint8_t reg, uint8_t val) override;

    AP_HAL::Device::PeriodicHandle register_periodic_callback(uint32_t period_usec, AP_HAL::Device::PeriodicCb) override;
    
    AP_HAL::Semaphore  *get_semaphore() override;

    bool configure() override;
    bool start_measurements() override;

    // set device type within a device class
    void set_device_type(uint8_t devtype) override;

    // return 24 bit bus identifier
    uint32_t get_bus_id(void) const override;
    
private:
    AuxiliaryBus *_bus;
    AuxiliaryBusSlave *_slave;
    bool _started;
};

#endif  // AP_COMPASS_AK8963_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            /*
 * Copyright (C) 2016  Intel Corporation. All rights reserved.
 *
 * This file is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This file is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
#include "AP_Compass_BMM150.h"

#if AP_COMPASS_BMM150_ENABLED

#include <AP_HAL/AP_HAL.h>

#include <utility>

#include <AP_HAL/utility/sparse-endian.h>
#include <AP_Math/AP_Math.h>
#include <stdio.h>

#define CHIP_ID_REG 0x40
#define CHIP_ID_VAL 0x32

#define POWER_AND_OPERATIONS_REG 0x4B
#define POWER_CONTROL_VAL (1 << 0)
#define SOFT_RESET (1 << 7 | 1 << 1)

#define OP_MODE_SELF_TEST_ODR_REG 0x4C
#define NORMAL_MODE (0 << 1)
#define ODR_30HZ (1 << 3 | 1 << 4 | 1 << 5)
#define ODR_20HZ (1 << 3 | 0 << 4 | 1 << 5)

#define DATA_X_LSB_REG 0x42

#define REPETITIONS_XY_REG 0x51
#define REPETITIONS_Z_REG 0X52

/* Trim registers */
#define DIG_X1_REG 0x5D
#define DIG_Y1_REG 0x5E
#define DIG_Z4_LSB_REG 0x62
#define DIG_Z4_MSB_REG 0x63
#define DIG_X2_REG 0x64
#define DIG_Y2_REG 0x65
#define DIG_Z2_LSB_REG 0x68
#define DIG_Z2_MSB_REG 0x69
#define DIG_Z1_LSB_REG 0x6A
#define DIG_Z1_MSB_REG 0x6B
#define DIG_XYZ1_LSB_REG 0x6C
#define DIG_XYZ1_MSB_REG 0x6D
#define DIG_Z3_LSB_REG 0x6E
#define DIG_Z3_MSB_REG 0x6F
#define DIG_XY2_REG 0x70
#define DIG_XY1_REG 0x71

#define MEASURE_TIME_USEC 16667

extern const AP_HAL::HAL &hal;

AP_Compass_Backend *AP_Compass_BMM150::probe(AP_HAL::OwnPtr<AP_HAL::I2CDevice> dev, bool force_external, enum Rotation rotation)
{
    if (!dev) {
        return nullptr;
    }
    AP_Compass_BMM150 *sensor = NEW_NOTHROW AP_Compass_BMM150(std::move(dev), force_external, rotation);
    if (!sensor || !sensor->init()) {
        delete sensor;
        return nullptr;
    }

    return sensor;
}

AP_Compass_BMM150::AP_Compass_BMM150(AP_HAL::OwnPtr<AP_HAL::Device> dev, bool force_external, enum Rotation rotation)
    : _dev(std::move(dev)), _rotation(rotation), _force_external(force_external)
{
}

bool AP_Compass_BMM150::_load_trim_values()
{
    struct {
        int8_t dig_x1;
        int8_t dig_y1;
        uint8_t rsv[3];
        le16_t dig_z4;
        int8_t dig_x2;
        int8_t dig_y2;
        uint8_t rsv2[2];
        le16_t dig_z2;
        le16_t dig_z1;
        le16_t dig_xyz1;
        le16_t dig_z3;
        int8_t dig_xy2;
        uint8_t dig_xy1;
    } PACKED trim_registers, trim_registers2;

    // read the registers twice to confirm we have the right
    // values. There is no CRC in the registers and these values are
    // vital to correct operation
    int8_t tries = 4;
    while (tries--) {
        if (!_dev->read_registers(DIG_X1_REG, (uint8_t *)&trim_registers,
                                  sizeof(trim_registers))) {
            continue;
        }
        if (!_dev->read_registers(DIG_X1_REG, (uint8_t *)&trim_registers2,
                                  sizeof(trim_registers))) {
            continue;
        }
        if (memcmp(&trim_registers, &trim_registers2, sizeof(trim_registers)) == 0) {
            break;
        }
    }
    if (-1 == tries) {
        DEV_PRINTF("BMM150: Failed to load trim registers\n");
        return false;
    }

    _dig.x1 = trim_registers.dig_x1;
    _dig.x2 = trim_registers.dig_x2;
    _dig.xy1 = trim_registers.dig_xy1;
    _dig.xy2 = trim_registers.dig_xy2;
    _dig.xyz1 = le16toh(trim_registers.dig_xyz1);
    _dig.y1 = trim_registers.dig_y1;
    _dig.y2 = trim_registers.dig_y2;
    _dig.z1 = le16toh(trim_registers.dig_z1);
    _dig.z2 = le16toh(trim_registers.dig_z2);
    _dig.z3 = le16toh(trim_registers.dig_z3);
    _dig.z4 = le16toh(trim_registers.dig_z4);

    return true;
}

bool AP_Compass_BMM150::init()
{
    uint8_t val = 0;
    bool ret;

    _dev->get_semaphore()->take_blocking();

    // 10 retries for init
    _dev->set_retries(10);

    // use checked registers to cope with bus errors
    _dev->setup_checked_registers(4);
    
    int8_t boot_tries = 4;
    while (boot_tries--) {
        /* Do a soft reset */
        ret = _dev->write_register(POWER_AND_OPERATIONS_REG, SOFT_RESET);
        hal.scheduler->delay(2);
        if (!ret) {
            continue;
        }

        /* Change power state from suspend mode to sleep mode */
        ret = _dev->write_register(POWER_AND_OPERATIONS_REG, POWER_CONTROL_VAL, true);
        hal.scheduler->delay(2);
        if (!ret) {
            continue;
        }

        ret = _dev->read_registers(CHIP_ID_REG, &val, 1);
        if (!ret) {
            continue;
        }
        if (val == CHIP_ID_VAL) {
            // found it
            break;
        }
        if (boot_tries == 0) {
            DEV_PRINTF("BMM150: Wrong chip ID 0x%02x should be 0x%02x\n", val, CHIP_ID_VAL);
        }
    }
    if (-1 == boot_tries) {
        goto bus_error;
    }

    ret = _load_trim_values();
    if (!ret) {
        goto bus_error;
    }

    /*
     * Recommended preset for high accuracy:
     * - Rep X/Y = 47
     * - Rep Z = 83
     * - ODR = 20
     * But we are going to use 30Hz of ODR
     */
    ret = _dev->write_register(REPETITIONS_XY_REG, (47 - 1) / 2, true);
    if (!ret) {
        goto bus_error;
    }
    ret = _dev->write_register(REPETITIONS_Z_REG, 83 - 1, true);
    if (!ret) {
        goto bus_error;
    }
    /* Change operation mode from sleep to normal and set ODR */
    ret = _dev->write_register(OP_MODE_SELF_TEST_ODR_REG, NORMAL_MODE | ODR_30HZ, true);
    if (!ret) {
        goto bus_error;
    }

    _dev->get_semaphore()->give();

    /* register the compass instance in the frontend */
    _dev->set_device_type(DEVTYPE_BMM150);
    if (!register_compass(_dev->get_bus_id(), _compass_instance)) {
        return false;
    }
    set_dev_id(_compass_instance, _dev->get_bus_id());

    set_rotation(_compass_instance, _rotation);

    if (_force_external) {
        set_external(_compass_instance, true);
    }

    // 2 retries for run
    _dev->set_retries(2);
    
    _dev->register_periodic_callback(MEASURE_TIME_USEC,
            FUNCTOR_BIND_MEMBER(&AP_Compass_BMM150::_update, void));

    _last_read_ms = AP_HAL::millis();
    
    return true;

bus_error:
    _dev->get_semaphore()->give();
    return false;
}

/*
 * Compensation algorithm got from https://github.com/BoschSensortec/BMM050_driver
 * this is not explained in datasheet.
 */
int16_t AP_Compass_BMM150::_compensate_xy(int16_t xy, uint32_t rhall, int32_t txy1, int32_t txy2) const
{
    int32_t inter = ((int32_t)_dig.xyz1) << 14;
    inter /= rhall;
    inter -= 0x4000;

    int32_t val = _dig.xy2 * ((inter * inter) >> 7);
    val += (inter * (((uint32_t)_dig.xy1) << 7));
    val >>= 9;
    val += 0x100000;
    val *= (txy2 + 0xA0);
    val >>= 12;
    val *= xy;
    val >>= 13;
    val += (txy1 << 3);

    return val;
}

int16_t AP_Compass_BMM150::_compensate_z(int16_t z, uint32_t rhall) const
{
    int32_t dividend = int32_t(z - _dig.z4) << 15;
    int32_t dividend2 = dividend - ((_dig.z3 * (int32_t(rhall) - int32_t(_dig.xyz1))) >> 2);

    int32_t divisor = int32_t(_dig.z1) * (rhall << 1);
    divisor += 0x8000;
    divisor >>= 16;
    divisor += _dig.z2;

    int16_t ret = constrain_int32(dividend2 / divisor, -0x8000, 0x8000);
#if 0
    static uint8_t counter;
    if (counter++ == 0) {
        printf("ret=%d z=%d rhall=%u z1=%d z2=%d z3=%d z4=%d xyz1=%d dividend=%d dividend2=%d divisor=%d\n",
               ret, z, rhall, _dig.z1, _dig.z2, _dig.z3, _dig.z4, _dig.xyz1, dividend, dividend2, divisor);
    }
#endif
    return ret;
}

void AP_Compass_BMM150::_update()
{
    le16_t data[4];
    bool ret = _dev->read_registers(DATA_X_LSB_REG, (uint8_t *) &data, sizeof(data));

    /* Checking data ready status */
    if (!ret || !(data[3] & 0x1)) {
        _dev->check_next_register();
        uint32_t now = AP_HAL::millis();
        if (now - _last_read_ms > 250) {
            // cope with power cycle to sensor
            _last_read_ms = now;
            _dev->write_register(POWER_AND_OPERATIONS_REG, SOFT_RESET);
            _dev->write_register(POWER_AND_OPERATIONS_REG, POWER_CONTROL_VAL, true);
        }
        return;
    }

    const uint16_t rhall = le16toh(data[3]) >> 2;

    Vector3f raw_field = Vector3f{
        (float) _compensate_xy(((int16_t)le16toh(data[0])) >> 3,
                               rhall, _dig.x1, _dig.x2),
        (float) _compensate_xy(((int16_t)le16toh(data[1])) >> 3,
                               rhall, _dig.y1, _dig.y2),
        (float) _compensate_z(((int16_t)le16toh(data[2])) >> 1, rhall)};

    /* apply sensitivity scale 16 LSB/uT */
    raw_field /= 16;
    /* convert uT to milligauss */
    raw_field *= 10;

    _last_read_ms = AP_HAL::millis();

    accumulate_sample(raw_field, _compass_instance);
    _dev->check_next_register();
}

void AP_Compass_BMM150::read()
{
    drain_accumulated_samples(_compass_instance);
}


#endif  // AP_COMPASS_BMM150_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             /*
 * Copyright (C) 2016  Intel Corporation. All rights reserved.
 *
 * This file is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This file is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
#pragma once

#include "AP_Compass_config.h"

#if AP_COMPASS_BMM150_ENABLED

#include <AP_Common/AP_Common.h>
#include <AP_HAL/AP_HAL.h>
#include <AP_HAL/I2CDevice.h>
#include <AP_Math/AP_Math.h>

#include "AP_Compass.h"
#include "AP_Compass_Backend.h"

#define BMM150_I2C_ADDR_MIN 0x10
#define BMM150_I2C_ADDR_MAX 0x13

class AP_Compass_BMM150 : public AP_Compass_Backend
{
public:
    static AP_Compass_Backend *probe(AP_HAL::OwnPtr<AP_HAL::I2CDevice> dev, bool force_external, enum Rotation rotation);

    void read() override;

    static constexpr const char *name = "BMM150";

private:
    AP_Compass_BMM150(AP_HAL::OwnPtr<AP_HAL::Device> dev, bool force_external, enum Rotation rotation);

    /**
     * Device periodic callback to read data from the sensor.
     */
    bool init();
    void _update();
    bool _load_trim_values();
    int16_t _compensate_xy(int16_t xy, uint32_t rhall, int32_t txy1, int32_t txy2) const;
    int16_t _compensate_z(int16_t z, uint32_t rhall) const;

    AP_HAL::OwnPtr<AP_HAL::Device> _dev;

    uint8_t _compass_instance;

    struct {
        int8_t x1;
        int8_t y1;
        int8_t x2;
        int8_t y2;
        uint16_t z1;
        int16_t z2;
        int16_t z3;
        int16_t z4;
        uint8_t xy1;
        int8_t xy2;
        uint16_t xyz1;
    } _dig;

    uint32_t _last_read_ms;
    enum Rotation _rotation;
    bool _force_external;
};

#endif  // AP_COMPASS_BMM150_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         