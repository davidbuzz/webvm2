ion and height measurement variances.
        // Use different errors if operating without external aiding using an assumed position or velocity of zero
        if (PV_AidingMode == AID_NONE) {
            if (tiltAlignComplete && motorsArmed) {
                // This is a compromise between corrections for gyro errors and reducing effect of manoeuvre accelerations on tilt estimate
                R_OBS[0] = sq(constrain_ftype(frontend->_noaidHorizNoise, 0.5f, 50.0f));
            } else {
                // Use a smaller value to give faster initial alignment
                R_OBS[0] = sq(0.5f);
            }
            R_OBS[1] = R_OBS[0];
            R_OBS[2] = R_OBS[0];
            R_OBS[3] = R_OBS[0];
            R_OBS[4] = R_OBS[0];
            for (uint8_t i=0; i<=2; i++) R_OBS_DATA_CHECKS[i] = R_OBS[i];
        } else {
            if (gpsSpdAccuracy > 0.0f) {
                // use GPS receivers reported speed accuracy if available and floor at value set by GPS velocity noise parameter
                R_OBS[0] = sq(constrain_ftype(gpsSpdAccuracy, frontend->_gpsHorizVelNoise, 50.0f));
                R_OBS[2] = sq(constrain_ftype(gpsSpdAccuracy, frontend->_gpsVertVelNoise, 50.0f));
#if EK3_FEATURE_EXTERNAL_NAV
            } else if (extNavVelToFuse) {
                R_OBS[2] = R_OBS[0] = sq(constrain_ftype(extNavVelDelayed.err, 0.05f, 5.0f));
#endif
            } else {
                // calculate additional error in GPS velocity caused by manoeuvring
                R_OBS[0] = sq(constrain_ftype(frontend->_gpsHorizVelNoise, 0.05f, 5.0f)) + sq(frontend->gpsNEVelVarAccScale * accNavMag);
                R_OBS[2] = sq(constrain_ftype(frontend->_gpsVertVelNoise,  0.05f, 5.0f)) + sq(frontend->gpsDVelVarAccScale  * accNavMag);
            }
            R_OBS[1] = R_OBS[0];
            // Use GPS reported position accuracy if available and floor at value set by GPS position noise parameter
            if (gpsPosAccuracy > 0.0f) {
                R_OBS[3] = sq(constrain_ftype(gpsPosAccuracy, frontend->_gpsHorizPosNoise, 100.0f));
#if EK3_FEATURE_EXTERNAL_NAV
            } else if (extNavUsedForPos) {
                R_OBS[3] = sq(constrain_ftype(extNavDataDelayed.posErr, 0.01f, 10.0f));
#endif
            } else {
                R_OBS[3] = sq(constrain_ftype(frontend->_gpsHorizPosNoise, 0.1f, 10.0f)) + sq(posErr);
            }
            R_OBS[4] = R_OBS[3];
            // For data integrity checks we use the same measurement variances as used to calculate the Kalman gains for all measurements except GPS horizontal velocity
            // For horizontal GPS velocity we don't want the acceptance radius to increase with reported GPS accuracy so we use a value based on best GPS performance
            // plus a margin for manoeuvres. It is better to reject GPS horizontal velocity errors early
            ftype obs_data_chk;
#if EK3_FEATURE_EXTERNAL_NAV
            if (extNavVelToFuse) {
                obs_data_chk = sq(constrain_ftype(extNavVelDelayed.err, 0.05f, 5.0f)) + sq(frontend->extNavVelVarAccScale * accNavMag);
            } else
#endif
            {
                obs_data_chk = sq(constrain_ftype(frontend->_gpsHorizVelNoise, 0.05f, 5.0f)) + sq(frontend->gpsNEVelVarAccScale * accNavMag);
            }
            R_OBS_DATA_CHECKS[0] = R_OBS_DATA_CHECKS[1] = R_OBS_DATA_CHECKS[2] = obs_data_chk;
        }
        R_OBS[5] = posDownObsNoise;
        for (uint8_t i=3; i<=5; i++) R_OBS_DATA_CHECKS[i] = R_OBS[i];

        // if vertical GPS velocity data and an independent height source is being used, check to see if the GPS vertical velocity and altimeter
        // innovations have the same sign and are outside limits. If so, then it is likely aliasing is affecting
        // the accelerometers and we should disable the GPS and barometer innovation consistency checks.
        if (gpsDataDelayed.have_vz && fuseVelData && (frontend->sources.getPosZSource() != AP_NavEKF_Source::SourceZ::GPS)) {
            // calculate innovations for height and vertical GPS vel measurements
            const ftype hgtErr  = stateStruct.position.z - velPosObs[5];
            const ftype velDErr = stateStruct.velocity.z - velPosObs[2];
            // Check if they are the same sign and both more than 3-sigma out of bounds
            // Step the test threshold up in stages from 1 to 2 to 3 sigma after exiting
            // from a previous bad IMU event so that a subsequent error is caught more quickly.
            const uint32_t timeSinceLastBadIMU_ms = imuSampleTime_ms - badIMUdata_ms;
            float R_gain;
            if (timeSinceLastBadIMU_ms > (BAD_IMU_DATA_HOLD_MS * 2)) {
                R_gain = 9.0F;
            } else if  (timeSinceLastBadIMU_ms > ((BAD_IMU_DATA_HOLD_MS * 3) / 2)) {
                R_gain = 4.0F;
            } else {
                R_gain = 1.0F;
            }
            if ((hgtErr*velDErr > 0.0f) && (sq(hgtErr) > R_gain * R_OBS[5]) && (sq(velDErr) >R_gain * R_OBS[2])) {
                badIMUdata_ms = imuSampleTime_ms;
            } else {
                goodIMUdata_ms = imuSampleTime_ms;
            }
            if (timeSinceLastBadIMU_ms < BAD_IMU_DATA_HOLD_MS) {
                badIMUdata = true;
                stateStruct.velocity.z = gpsDataDelayed.vel.z;
            } else {
                badIMUdata = false;
            }
        }

        // Test horizontal position measurements
        if (fusePosData) {
            innovVelPos[3] = stateStruct.position.x - velPosObs[3];
            innovVelPos[4] = stateStruct.position.y - velPosObs[4];
            varInnovVelPos[3] = P[7][7] + R_OBS_DATA_CHECKS[3];
            varInnovVelPos[4] = P[8][8] + R_OBS_DATA_CHECKS[4];

            // Apply an innovation consistency threshold test
            // Don't allow test to fail if not navigating and using a constant position
            // assumption to constrain tilt errors because innovations can become large
            // due to vehicle motion.
            ftype maxPosInnov2 = sq(MAX(0.01 * (ftype)frontend->_gpsPosInnovGate, 1.0))*(varInnovVelPos[3] + varInnovVelPos[4]);

            posTestRatio = (sq(innovVelPos[3]) + sq(innovVelPos[4])) / maxPosInnov2;
            if (posTestRatio < 1.0f || (PV_AidingMode == AID_NONE)) {
                posCheckPassed = true;
                lastPosPassTime_ms = imuSampleTime_ms;
            } else if ((frontend->_gpsGlitchRadiusMax <= 0) && (PV_AidingMode != AID_NONE)) {
                // Handle the special case where the glitch radius parameter has been set to a non-positive number.
                // The innovation variance is increased to limit the state update to an amount corresponding
                // to a test ratio of 1.
                posCheckPassed = true;
                lastPosPassTime_ms = imuSampleTime_ms;
                varInnovVelPos[3] *= posTestRatio;
                varInnovVelPos[4] *= posTestRatio;
                posCheckPassed = true;
                lastPosPassTime_ms = imuSampleTime_ms;
            }

            // Use position data if healthy or timed out or bad IMU data
            // Always fuse data if bad IMU to prevent aliasing and clipping pulling the state estimate away
            // from the measurement un-opposed if test threshold is exceeded.
            if (posCheckPassed || posTimeout || badIMUdata) {
                // if timed out or outside the specified uncertainty radius, reset to the external sensor
                // if velocity drift is being constrained, dont reset until gps passes quality checks
                const bool posVarianceIsTooLarge = (frontend->_gpsGlitchRadiusMax > 0) && (P[8][8] + P[7][7]) > sq(ftype(frontend->_gpsGlitchRadiusMax));
                if ((posTimeout || posVarianceIsTooLarge) && (!velAiding || gpsGoodToAlign)) {
                    // reset the position to the current external sensor position
                    ResetPosition(resetDataSource::DEFAULT);

                    // Don't fuse the same data we have used to reset states.
                    fusePosData = false;

                    // Reset the position variances and corresponding covariances to a value that will pass the checks
                    zeroRows(P,7,8);
                    zeroCols(P,7,8);
                    P[7][7] = sq(ftype(0.5f*frontend->_gpsGlitchRadiusMax));
                    P[8][8] = P[7][7];

                    // Reset the normalised innovation to avoid failing the bad fusion tests
                    posTestRatio = 0.0f;

                    // Reset velocity if it has timed out
                    if (velTimeout) {
                        ResetVelocity(resetDataSource::DEFAULT);

                        // Don't fuse the same data we have used to reset states.
                        fuseVelData = false;

                        // Reset the normalised innovation to avoid failing the bad fusion tests
                        velTestRatio = 0.0f;
                    }
                }
            } else {
                fusePosData = false;
            }
        }

        // Test velocity measurements
        if (fuseVelData) {
            uint8_t imax = 2;
            // Don't fuse vertical velocity observations if disabled in sources or not available
            if ((!frontend->sources.haveVelZSource() || PV_AidingMode != AID_ABSOLUTE ||
                 !gpsDataDelayed.have_vz) && !useExtNavVel) {
                imax = 1;
            }

            // Apply an innovation consistency threshold test
            ftype innovVelSumSq = 0; // sum of squares of velocity innovations
            ftype varVelSum = 0; // sum of velocity innovation variances

            for (uint8_t i = 0; i<=imax; i++) {
                stateIndex   = i + 4;
                const float innovation = stateStruct.velocity[i] - velPosObs[i];
                innovVelSumSq += sq(innovation);
                varInnovVelPos[i] = P[stateIndex][stateIndex] + R_OBS_DATA_CHECKS[i];
                varVelSum += varInnovVelPos[i];
            }
            velTestRatio = innovVelSumSq / (varVelSum * sq(MAX(0.01 * (ftype)frontend->_gpsVelInnovGate, 1.0)));
            if (velTestRatio < 1.0) {
                velCheckPassed = true;
                lastVelPassTime_ms = imuSampleTime_ms;
            } else if (frontend->_gpsGlitchRadiusMax <= 0) {
                // Handle the special case where the glitch radius parameter has been set to a non-positive number.
                // The innovation variance is increased to limit the state update to an amount corresponding
                // to a test ratio of 1.
                posCheckPassed = true;
                lastPosPassTime_ms = imuSampleTime_ms;
                for (uint8_t i = 0; i<=imax; i++) {
                    varInnovVelPos[i] *= velTestRatio;
                }
                velCheckPassed = true;
                lastVelPassTime_ms = imuSampleTime_ms;
            }

            // Use velocity data if healthy, timed out or when IMU fault has been detected
            // Always fuse data if bad IMU to prevent aliasing and clipping pulling the state estimate away
            // from the measurement un-opposed if test threshold is exceeded.
            if (velCheckPassed || velTimeout || badIMUdata) {
                // If we are doing full aiding and velocity fusion times out, reset to the external sensor velocity
                if (PV_AidingMode == AID_ABSOLUTE && velTimeout) {
                    ResetVelocity(resetDataSource::DEFAULT);

                    // Don't fuse the same data we have used to reset states.
                    fuseVelData = false;

                    // Reset the normalised innovation to avoid failing the bad fusion tests
                    velTestRatio = 0.0f;
                }
            } else {
                fuseVelData = false;
            }
        }

        // Test height measurements
        if (fuseHgtData) {
            // Calculate height innovations
            innovVelPos[5] = stateStruct.position.z - velPosObs[5];
            varInnovVelPos[5] = P[9][9] + R_OBS_DATA_CHECKS[5];

            // Calculate the innovation consistency test ratio
            hgtTestRatio = sq(innovVelPos[5]) / (sq(MAX(0.01 * (ftype)frontend->_hgtInnovGate, 1.0)) * varInnovVelPos[5]);

            // When on ground we accept a larger test ratio to allow the filter to handle large switch on IMU
            // bias errors without rejecting the height sensor.
            const bool onGroundNotNavigating = (PV_AidingMode == AID_NONE) && onGround;
            const float maxTestRatio = onGroundNotNavigating ? 3.0f : 1.0f;
            if (hgtTestRatio < maxTestRatio) {
                hgtCheckPassed = true;
                lastHgtPassTime_ms = imuSampleTime_ms;
            } else if ((frontend->_gpsGlitchRadiusMax <= 0) && !onGroundNotNavigating && (activeHgtSource == AP_NavEKF_Source::SourceZ::GPS)) {
                // Handle the special case where the glitch radius parameter has been set to a non-positive number.
                // The innovation variance is increased to limit the state update to an amount corresponding
                // to a test ratio of 1.
                posCheckPassed = true;
                lastPosPassTime_ms = imuSampleTime_ms;
                varInnovVelPos[5] *= hgtTestRatio;
                hgtCheckPassed = true;
                lastHgtPassTime_ms = imuSampleTime_ms;
            }

            // Use height data if innovation check passed or timed out or if bad IMU data
            // Always fuse data if bad IMU to prevent aliasing and clipping pulling the state estimate away
            // from the measurement un-opposed if test threshold is exceeded.
            if (hgtCheckPassed || hgtTimeout || badIMUdata) {
                // Calculate a filtered value to be used by pre-flight health checks
                // We need to filter because wind gusts can generate significant baro noise and we want to be able to detect bias errors in the inertial solution
                if (onGround) {
                    ftype dtBaro = (imuSampleTime_ms - lastHgtPassTime_ms) * 1.0e-3;
                    const ftype hgtInnovFiltTC = 2.0;
                    ftype alpha = constrain_ftype(dtBaro/(dtBaro+hgtInnovFiltTC), 0.0, 1.0);
                    hgtInnovFiltState += (innovVelPos[5] - hgtInnovFiltState)*alpha;
                } else {
                    hgtInnovFiltState = 0.0f;
                }

                if (hgtTimeout) {
                    ResetHeight();

                    // Don't fuse the same data we have used to reset states.
                    fuseHgtData = false;
                }

            } else {
                fuseHgtData = false;
            }
        }

        // set range for sequential fusion of velocity and position measurements depending on which data is available and its health
        if (fuseVelData) {
            fuseData[0] = true;
            fuseData[1] = true;
            if (useGpsVertVel || useExtNavVel) {
                fuseData[2] = true;
            }
        }
        if (fusePosData) {
            fuseData[3] = true;
            fuseData[4] = true;
        }
        if (fuseHgtData) {
            fuseData[5] = true;
        }

        // fuse measurements sequentially
        for (obsIndex=0; obsIndex<=5; obsIndex++) {
            if (fuseData[obsIndex]) {
                stateIndex = 4 + obsIndex;
                // calculate the measurement innovation, using states from a different time coordinate if fusing height data
                // adjust scaling on GPS measurement noise variances if not enough satellites
                if (obsIndex <= 2) {
                    innovVelPos[obsIndex] = stateStruct.velocity[obsIndex] - velPosObs[obsIndex];
                    R_OBS[obsIndex] *= sq(gpsNoiseScaler);
                } else if (obsIndex == 3 || obsIndex == 4) {
                    innovVelPos[obsIndex] = stateStruct.position[obsIndex-3] - velPosObs[obsIndex];
                    R_OBS[obsIndex] *= sq(gpsNoiseScaler);
                } else if (obsIndex == 5) {
                    innovVelPos[obsIndex] = stateStruct.position[obsIndex-3] - velPosObs[obsIndex];
                    const ftype gndMaxBaroErr = MAX(frontend->_baroGndEffectDeadZone, 0.0);
                    const ftype gndBaroInnovFloor = -0.5;

                    if ((dal.get_touchdown_expected() || dal.get_takeoff_expected()) && activeHgtSource == AP_NavEKF_Source::SourceZ::BARO) {
                        // when baro positive pressure error due to ground effect is expected,
                        // floor the barometer innovation at gndBaroInnovFloor
                        // constrain the correction between 0 and gndBaroInnovFloor+gndMaxBaroErr
                        // this function looks like this:
                        //         |/
                        //---------|---------
                        //    ____/|
                        //   /     |
                        //  /      |
                        innovVelPos[5] += constrain_ftype(-innovVelPos[5]+gndBaroInnovFloor, 0.0f, gndBaroInnovFloor+gndMaxBaroErr);
                    }
                }

                // calculate the Kalman gain and calculate innovation variances
                varInnovVelPos[obsIndex] = P[stateIndex][stateIndex] + R_OBS[obsIndex];
                SK = 1.0f/varInnovVelPos[obsIndex];
                for (uint8_t i= 0; i<=9; i++) {
                    Kfusion[i] = P[i][stateIndex]*SK;
                }

                // inhibit delta angle bias state estimation by setting Kalman gains to zero
                if (!inhibitDelAngBiasStates) {
                    for (uint8_t i = 10; i<=12; i++) {
                        // Don't try to learn gyro bias if not aiding and the axis is
                        // less than 45 degrees from vertical because the bias is poorly observable
                        bool poorObservability = false;
                        if (PV_AidingMode == AID_NONE) {
                            const uint8_t axisIndex = i - 10;
                            if (axisIndex == 0) {
                                poorObservability = fabsF(prevTnb.a.z) > M_SQRT1_2;
                            } else if (axisIndex == 1) {
                                poorObservability = fabsF(prevTnb.b.z) > M_SQRT1_2;
                            } else {
                                poorObservability = fabsF(prevTnb.c.z) > M_SQRT1_2;
                            }
                        }
                        if (poorObservability) {
                            Kfusion[i] = 0.0;
                        } else {
                            Kfusion[i] = P[i][stateIndex]*SK;
                        }
                    }
                } else {
                    // zero indexes 10 to 12
                    zero_range(&Kfusion[0], 10, 12);
                }

                // Inhibit delta velocity bias state estimation by setting Kalman gains to zero
                // Don't use 'fake' horizontal measurements used to constrain attitude drift during
                // periods of non-aiding to learn bias as these can give incorrect esitmates.
                const bool horizInhibit = PV_AidingMode == AID_NONE && obsIndex != 2 && obsIndex != 5;
                if (!horizInhibit && !inhibitDelVelBiasStates && !badIMUdata) {
                    for (uint8_t i = 13; i<=15; i++) {
                        if (!dvelBiasAxisInhibit[i-13]) {
                            Kfusion[i] = P[i][stateIndex]*SK;
                        } else {
                            Kfusion[i] = 0.0f;
                        }
                    }
                } else {
                    // zero indexes 13 to 15
                    zero_range(&Kfusion[0], 13, 15);
                }

                // inhibit magnetic field state estimation by setting Kalman gains to zero
                if (!inhibitMagStates) {
                    for (uint8_t i = 16; i<=21; i++) {
                        Kfusion[i] = P[i][stateIndex]*SK;
                    }
                } else {
                    // zero indexes 16 to 21
                    zero_range(&Kfusion[0], 16, 21);
                }

                // inhibit wind state estimation by setting Kalman gains to zero
                if (!inhibitWindStates && !treatWindStatesAsTruth) {
                    Kfusion[22] = P[22][stateIndex]*SK;
                    Kfusion[23] = P[23][stateIndex]*SK;
                } else {
                    // zero indexes 22 to 23
                    zero_range(&Kfusion[0], 22, 23);
                }

                // update the covariance - take advantage of direct observation of a single state at index = stateIndex to reduce computations
                // this is a numerically optimised implementation of standard equation P = (I - K*H)*P;
                for (uint8_t i= 0; i<=stateIndexLim; i++) {
                    for (uint8_t j= 0; j<=stateIndexLim; j++) {
                        KHP[i][j] = Kfusion[i] * P[stateIndex][j];
                    }
                }
                // Check that we are not going to drive any variances negative and skip the update if so
                bool healthyFusion = true;
                for (uint8_t i= 0; i<=stateIndexLim; i++) {
                    if (KHP[i][i] > P[i][i]) {
                        healthyFusion = false;
                    }
                }
                if (healthyFusion) {
                    // update the covariance matrix
                    for (uint8_t i= 0; i<=stateIndexLim; i++) {
                        for (uint8_t j= 0; j<=stateIndexLim; j++) {
                            P[i][j] = P[i][j] - KHP[i][j];
                        }
                    }

                    // force the covariance matrix to be symmetrical and limit the variances to prevent ill-conditioning.
                    ForceSymmetry();
                    ConstrainVariances();

                    // update states and renormalise the quaternions
                    for (uint8_t i = 0; i<=stateIndexLim; i++) {
                        statesArray[i] = statesArray[i] - Kfusion[i] * innovVelPos[obsIndex];
                    }
                    stateStruct.quat.normalize();

                    // record good fusion status
                    if (obsIndex == 0) {
                        faultStatus.bad_nvel = false;
                    } else if (obsIndex == 1) {
                        faultStatus.bad_evel = false;
                    } else if (obsIndex == 2) {
                        faultStatus.bad_dvel = false;
                    } else if (obsIndex == 3) {
                        faultStatus.bad_npos = false;
                    } else if (obsIndex == 4) {
                        faultStatus.bad_epos = false;
                    } else if (obsIndex == 5) {
                        faultStatus.bad_dpos = false;
                    }
                } else {
                    // record bad fusion status
                    if (obsIndex == 0) {
                        faultStatus.bad_nvel = true;
                    } else if (obsIndex == 1) {
                        faultStatus.bad_evel = true;
                    } else if (obsIndex == 2) {
                        faultStatus.bad_dvel = true;
                    } else if (obsIndex == 3) {
                        faultStatus.bad_npos = true;
                    } else if (obsIndex == 4) {
                        faultStatus.bad_epos = true;
                    } else if (obsIndex == 5) {
                        faultStatus.bad_dpos = true;
                    }
                }
            }
        }
    }
}

/********************************************************
*                   MISC FUNCTIONS                      *
********************************************************/

// select the height measurement to be fused from the available baro, range finder and GPS sources
void NavEKF3_core::selectHeightForFusion()
{
#if AP_RANGEFINDER_ENABLED
    // Read range finder data and check for new data in the buffer
    // This data is used by both height and optical flow fusion processing
    readRangeFinder();
    rangeDataToFuse = storedRange.recall(rangeDataDelayed,imuDataDelayed.time_ms);

    // correct range data for the body frame position offset relative to the IMU
    // the corrected reading is the reading that would have been taken if the sensor was
    // co-located with the IMU
    const auto *_rng = dal.rangefinder();
    if (_rng && rangeDataToFuse) {
        auto *sensor = _rng->get_backend(rangeDataDelayed.sensor_idx);
        if (sensor != nullptr) {
            Vector3F posOffsetBody = sensor->get_pos_offset().toftype() - accelPosOffset;
            if (!posOffsetBody.is_zero()) {
                Vector3F posOffsetEarth = prevTnb.mul_transpose(posOffsetBody);
                rangeDataDelayed.rng += posOffsetEarth.z / prevTnb.c.z;
            }
        }
    }
#endif  // AP_RANGEFINDER_ENABLED

    // read baro height data from the sensor and check for new data in the buffer
    readBaroData();
    baroDataToFuse = storedBaro.recall(baroDataDelayed, imuDataDelayed.time_ms);

    bool rangeFinderDataIsFresh = (imuSampleTime_ms - rngValidMeaTime_ms < 500);
#if EK3_FEATURE_EXTERNAL_NAV
    const bool extNavDataIsFresh = (imuSampleTime_ms - extNavMeasTime_ms < 500);
#endif
    // select height source
    if ((frontend->sources.getPosZSource() == AP_NavEKF_Source::SourceZ::NONE)) {
        // user has specified no height sensor
        activeHgtSource = AP_NavEKF_Source::SourceZ::NONE;
#if AP_RANGEFINDER_ENABLED
    } else if ((frontend->sources.getPosZSource() == AP_NavEKF_Source::SourceZ::RANGEFINDER) && _rng && rangeFinderDataIsFresh) {
        // user has specified the range finder as a primary height source
        activeHgtSource = AP_NavEKF_Source::SourceZ::RANGEFINDER;
    } else if ((frontend->_useRngSwHgt > 0) && ((frontend->sources.getPosZSource() == AP_NavEKF_Source::SourceZ::BARO) || (frontend->sources.getPosZSource() == AP_NavEKF_Source::SourceZ::GPS)) && _rng && rangeFinderDataIsFresh) {
        // determine if we are above or below the height switch region
        ftype rangeMaxUse = 1e-4 * (ftype)_rng->max_distance_cm_orient(ROTATION_PITCH_270) * (ftype)frontend->_useRngSwHgt;
        bool aboveUpperSwHgt = (terrainState - stateStruct.position.z) > rangeMaxUse;
        bool belowLowerSwHgt = ((terrainState - stateStruct.position.z) < 0.7f * rangeMaxUse) && (imuSampleTime_ms - gndHgtValidTime_ms < 1000);

        // If the terrain height is consistent and we are moving slowly, then it can be
        // used as a height reference in combination with a range finder
        // apply a hysteresis to the speed check to prevent rapid switching
        bool dontTrustTerrain, trustTerrain;
        if (filterStatus.flags.horiz_vel) {
            // We can use the velocity estimate
            ftype horizSpeed = stateStruct.velocity.xy().length();
            dontTrustTerrain = (horizSpeed > frontend->_useRngSwSpd) || !terrainHgtStable;
            ftype trust_spd_trigger = MAX((frontend->_useRngSwSpd - 1.0f),(frontend->_useRngSwSpd * 0.5f));
            trustTerrain = (horizSpeed < trust_spd_trigger) && terrainHgtStable;
        } else {
            // We can't use the velocity estimate
            dontTrustTerrain = !terrainHgtStable;
            trustTerrain = terrainHgtStable;
        }

        /*
            * Switch between range finder and primary height source using height above ground and speed thresholds with
            * hysteresis to avoid rapid switching. Using range finder for height requires a consistent terrain height
            * which cannot be assumed if the vehicle is moving horizontally.
        */
        if ((aboveUpperSwHgt || dontTrustTerrain) && (activeHgtSource == AP_NavEKF_Source::SourceZ::RANGEFINDER)) {
            // cannot trust terrain or range finder so stop using range finder height
            if (frontend->sources.getPosZSource() == AP_NavEKF_Source::SourceZ::BARO) {
                activeHgtSource = AP_NavEKF_Source::SourceZ::BARO;
            } else if (frontend->sources.getPosZSource() == AP_NavEKF_Source::SourceZ::GPS) {
                activeHgtSource = AP_NavEKF_Source::SourceZ::GPS;
            }
        } else if (belowLowerSwHgt && trustTerrain && (prevTnb.c.z >= 0.7f)) {
            // reliable terrain and range finder so start using range finder height
            activeHgtSource = AP_NavEKF_Source::SourceZ::RANGEFINDER;
        }
#endif
    } else if (frontend->sources.getPosZSource() == AP_NavEKF_Source::SourceZ::BARO) {
        activeHgtSource = AP_NavEKF_Source::SourceZ::BARO;
    } else if ((frontend->sources.getPosZSource() == AP_NavEKF_Source::SourceZ::GPS) && ((imuSampleTime_ms - lastTimeGpsReceived_ms) < 500) && validOrigin && gpsAccuracyGood) {
        activeHgtSource = AP_NavEKF_Source::SourceZ::GPS;
#if EK3_FEATURE_BEACON_FUSION
    } else if ((frontend->sources.getPosZSource() == AP_NavEKF_Source::SourceZ::BEACON) && validOrigin && rngBcn.goodToAlign) {
        activeHgtSource = AP_NavEKF_Source::SourceZ::BEACON;
#endif
#if EK3_FEATURE_EXTERNAL_NAV
    } else if ((frontend->sources.getPosZSource() == AP_NavEKF_Source::SourceZ::EXTNAV) && extNavDataIsFresh) {
        activeHgtSource = AP_NavEKF_Source::SourceZ::EXTNAV;
#endif
    }

    // Use Baro alt as a fallback if we lose range finder, GPS, external nav or Beacon
    bool lostRngHgt = ((activeHgtSource == AP_NavEKF_Source::SourceZ::RANGEFINDER) && !rangeFinderDataIsFresh);
    bool lostGpsHgt = ((activeHgtSource == AP_NavEKF_Source::SourceZ::GPS) && ((imuSampleTime_ms - lastTimeGpsReceived_ms) > 2000 || !gpsAccuracyGoodForAltitude));
#if EK3_FEATURE_BEACON_FUSION
    bool lostRngBcnHgt = ((activeHgtSource == AP_NavEKF_Source::SourceZ::BEACON) && ((imuSampleTime_ms - rngBcn.dataDelayed.time_ms) > 2000));
#endif
    bool fallback_to_baro =
        lostRngHgt
        || lostGpsHgt
#if EK3_FEATURE_BEACON_FUSION
        || lostRngBcnHgt
#endif
        ;
#if EK3_FEATURE_EXTERNAL_NAV
    bool lostExtNavHgt = ((activeHgtSource == AP_NavEKF_Source::SourceZ::EXTNAV) && !extNavDataIsFresh);
    fallback_to_baro |= lostExtNavHgt;
#endif
    if (fallback_to_baro) {
        activeHgtSource = AP_NavEKF_Source::SourceZ::BARO;
    }

    // if there is new baro data to fuse, calculate filtered baro data required by other processes
    if (baroDataToFuse) {
        // calculate offset to baro data that enables us to switch to Baro height use during operation
        if (activeHgtSource != AP_NavEKF_Source::SourceZ::BARO) {
            calcFiltBaroOffset();
        }
        // filtered baro data used to provide a reference for takeoff
        // it is is reset to last height measurement on disarming in performArmingChecks()
        if (!dal.get_takeoff_expected()) {
            const ftype gndHgtFiltTC = 0.5;
            const ftype dtBaro = frontend->hgtAvg_ms*1.0e-3;
            ftype alpha = constrain_ftype(dtBaro / (dtBaro+gndHgtFiltTC),0.0,1.0);
            meaHgtAtTakeOff += (baroDataDelayed.hgt-meaHgtAtTakeOff)*alpha;
        }
    }

    // If we are not using GPS as the primary height sensor, correct EKF origin height so that
    // combined local NED position height and origin height remains consistent with the GPS altitude
    // This also enables the GPS height to be used as a backup height source
    if (gpsDataToFuse &&
            (((frontend->_originHgtMode & (1 << 0)) && (activeHgtSource == AP_NavEKF_Source::SourceZ::BARO)) ||
            ((frontend->_originHgtMode & (1 << 1)) && (activeHgtSource == AP_NavEKF_Source::SourceZ::RANGEFINDER)))
            ) {
            correctEkfOriginHeight();
    }

    // Select the height measurement source
#if EK3_FEATURE_EXTERNAL_NAV
    if (extNavDataToFuse && (activeHgtSource == AP_NavEKF_Source::SourceZ::EXTNAV)) {
        hgtMea = -extNavDataDelayed.pos.z;
        velPosObs[5] = -hgtMea;
        posDownObsNoise = sq(constrain_ftype(extNavDataDelayed.posErr, 0.1f, 10.0f));
        fuseHgtData = true;
    } else
#endif // EK3_FEATURE_EXTERNAL_NAV
        if (rangeDataToFuse && (activeHgtSource == AP_NavEKF_Source::SourceZ::RANGEFINDER)) {
        // using range finder data
        // correct for tilt using a flat earth model
        if (prevTnb.c.z >= 0.7) {
            // calculate height above ground
            hgtMea  = MAX(rangeDataDelayed.rng * prevTnb.c.z, rngOnGnd);
            // correct for terrain position relative to datum
            hgtMea -= terrainState;
            // correct sensor so that local position height adjusts to match GPS
            if (frontend->_originHgtMode & (1 << 1) && frontend->_originHgtMode & (1 << 2)) {
                // offset has to be applied to the measurement, not the NED origin
                hgtMea += (float)(ekfGpsRefHgt - 0.01 * (double)EKF_origin.alt);
            }
            velPosObs[5] = -hgtMea;
            // enable fusion
            fuseHgtData = true;
            // set the observation noise
            posDownObsNoise = sq(constrain_ftype(frontend->_rngNoise, 0.1f, 10.0f));
            // add uncertainty created by terrain gradient and vehicle tilt
            posDownObsNoise += sq(rangeDataDelayed.rng * frontend->_terrGradMax) * MAX(0.0f , (1.0f - sq(prevTnb.c.z)));
        } else {
            // disable fusion if tilted too far
            fuseHgtData = false;
        }
    } else if (gpsDataToFuse && (activeHgtSource == AP_NavEKF_Source::SourceZ::GPS)) {
        // using GPS data
        hgtMea = gpsDataDelayed.hgt;
        velPosObs[5] = -hgtMea;
        // enable fusion
        fuseHgtData = true;
        // set the observation noise using receiver reported accuracy or the horizontal noise scaled for typical VDOP/HDOP ratio
        if (gpsHgtAccuracy > 0.0f) {
            posDownObsNoise = sq(constrain_ftype(gpsHgtAccuracy, 1.5f * frontend->_gpsHorizPosNoise, 100.0f));
        } else {
            posDownObsNoise = sq(constrain_ftype(1.5f * frontend->_gpsHorizPosNoise, 0.1f, 10.0f));
        }
    } else if (baroDataToFuse && (activeHgtSource == AP_NavEKF_Source::SourceZ::BARO)) {
        // using Baro data
        hgtMea = baroDataDelayed.hgt - baroHgtOffset;
        // correct sensor so that local position height adjusts to match GPS
        if (frontend->_originHgtMode & (1 << 0) && frontend->_originHgtMode & (1 << 2)) {
            hgtMea += (float)(ekfGpsRefHgt - 0.01 * (double)EKF_origin.alt);
        }
        // enable fusion
        fuseHgtData = true;
        // set the observation noise
        posDownObsNoise = sq(constrain_ftype(frontend->_baroAltNoise, 0.1f, 100.0f));
        // reduce weighting (increase observation noise) on baro if we are likely to be experiencing rotor wash ground interaction
        if (dal.get_takeoff_expected() || dal.get_touchdown_expected()) {
            posDownObsNoise *= frontend->gndEffectBaroScaler;
        }
        velPosObs[5] = -hgtMea;
    } else if ((activeHgtSource == AP_NavEKF_Source::SourceZ::NONE && imuSampleTime_ms - lastHgtPassTime_ms > 70)) {
        // fuse a constant height of 0 at 14 Hz
        hgtMea = 0.0f;
        fuseHgtData = true;
        velPosObs[5] = -hgtMea;
        if (onGround) {
            // use a typical vertical positoin observation noise when not flying for faster IMU delta velocity bias estimation
            posDownObsNoise = sq(2.0f);
        } else {
            // alow a larger value when flying to accomodate vertical maneouvres
            posDownObsNoise = sq(constrain_ftype(frontend->_baroAltNoise, 2.0f, 100.0f));
        }
    } else {
        fuseHgtData = false;
    }

    // detect changes in source and reset height
    if ((activeHgtSource != prevHgtSource) && fuseHgtData) {
        prevHgtSource = activeHgtSource;
        ResetPositionD(-hgtMea);
    }

    // If we haven't fused height data for a while or have bad IMU data, then declare the height data as being timed out
    // set height timeout period based on whether we have vertical GPS velocity available to constrain drift
    hgtRetryTime_ms = ((useGpsVertVel || useExtNavVel) && !velTimeout) ? frontend->hgtRetryTimeMode0_ms : frontend->hgtRetryTimeMode12_ms;
    if (imuSampleTime_ms - lastHgtPassTime_ms > hgtRetryTime_ms ||
        (badIMUdata &&
        (imuSampleTime_ms - goodIMUdata_ms > BAD_IMU_DATA_TIMEOUT_MS))) {
        hgtTimeout = true;
    } else {
        hgtTimeout = false;
    }
}

#if EK3_FEATURE_BODY_ODOM
/*
 * Fuse body frame velocity measurements using explicit algebraic equations generated with Matlab symbolic toolbox.
 * The script file used to generate these and other equations in this filter can be found here:
 * https://github.com/PX4/ecl/blob/master/matlab/script#include "AP_NavEKF3.h"
#include "AP_NavEKF3_core.h"

#if EK3_FEATURE_BEACON_FUSION

// initialise state:
void NavEKF3_core::BeaconFusion::InitialiseVariables()
{
    memset((void *)&dataDelayed, 0, sizeof(dataDelayed));
    lastPassTime_ms = 0;
    testRatio = 0.0f;
    health = false;
    varInnov = 0.0f;
    innov = 0.0f;
    memset(&lastTime_ms, 0, sizeof(lastTime_ms));
    dataToFuse = false;
    vehiclePosNED.zero();
    vehiclePosErr = 1.0f;
    last3DmeasTime_ms = 0;
    goodToAlign = false;
    lastChecked = 0;
    receiverPos.zero();
    memset(&receiverPosCov, 0, sizeof(receiverPosCov));
    alignmentStarted =  false;
    alignmentCompleted = false;
    lastIndex = 0;
    posSum.zero();
    numMeas = 0;
    sum = 0.0f;
    N = 0;
    maxPosD = 0.0f;
    minPosD = 0.0f;
    posDownOffsetMax = 0.0f;
    posOffsetMaxVar = 0.0f;
    maxOffsetStateChangeFilt = 0.0f;
    posDownOffsetMin = 0.0f;
    posOffsetMinVar = 0.0f;
    minOffsetStateChangeFilt = 0.0f;
    fuseDataReportIndex = 0;
    delete[] fusionReport;
    fusionReport = nullptr;
    numFusionReports = 0;
    auto *beacon = AP::dal().beacon();
    if (beacon != nullptr) {
        const uint8_t count = beacon->count();
        fusionReport = NEW_NOTHROW BeaconFusion::FusionReport[count];
        if (fusionReport != nullptr) {
            numFusionReports = count;
        }
    }
    posOffsetNED.zero();
    originEstInit = false;
}

/********************************************************
*                   FUSE MEASURED_DATA                  *
********************************************************/

// select fusion of range beacon measurements
void NavEKF3_core::SelectRngBcnFusion()
{
    // read range data from the sensor and check for new data in the buffer
    readRngBcnData();

    // Determine if we need to fuse range beacon data on this time step
    if (rngBcn.dataToFuse) {
        if (PV_AidingMode == AID_ABSOLUTE) {
            if ((frontend->sources.getPosXYSource() == AP_NavEKF_Source::SourceXY::BEACON) && rngBcn.alignmentCompleted) {
                if (!rngBcn.originEstInit) {
                    rngBcn.originEstInit = true;
                    rngBcn.posOffsetNED.x = rngBcn.receiverPos.x - stateStruct.position.x;
                    rngBcn.posOffsetNED.y = rngBcn.receiverPos.y - stateStruct.position.y;
                }
                // beacons are used as the primary means of position reference
                FuseRngBcn();
            } else {
                // If another source (i.e. GPS, ExtNav) is the primary reference, we continue to use the beacon data
                // to calculate an independent position that is used to update the beacon position offset if we need to
                // start using beacon data as the primary reference.
                FuseRngBcnStatic();
                // record that the beacon origin needs to be initialised
                rngBcn.originEstInit = false;
            }
        } else {
            // If we aren't able to use the data in the main filter, use a simple 3-state filter to estimate position only
            FuseRngBcnStatic();
            // record that the beacon origin needs to be initialised
            rngBcn.originEstInit = false;
        }
    }
}

void NavEKF3_core::FuseRngBcn()
{
    // declarations
    ftype pn;
    ftype pe;
    ftype pd;
    ftype bcn_pn;
    ftype bcn_pe;
    ftype bcn_pd;
    const ftype R_BCN = sq(MAX(rngBcn.dataDelayed.rngErr , 0.1f));
    ftype rngPred;

    // health is set bad until test passed
    rngBcn.health = false;

    if (activeHgtSource != AP_NavEKF_Source::SourceZ::BEACON) {
        // calculate the vertical offset from EKF datum to beacon datum
        CalcRangeBeaconPosDownOffset(R_BCN, stateStruct.position, false);
    } else {
        rngBcn.posOffsetNED.z = 0.0f;
    }

    // copy required states to local variable names
    pn = stateStruct.position.x;
    pe = stateStruct.position.y;
    pd = stateStruct.position.z;
    bcn_pn = rngBcn.dataDelayed.beacon_posNED.x;
    bcn_pe = rngBcn.dataDelayed.beacon_posNED.y;
    bcn_pd = rngBcn.dataDelayed.beacon_posNED.z + rngBcn.posOffsetNED.z;

    // predicted range
    Vector3F deltaPosNED = stateStruct.position - rngBcn.dataDelayed.beacon_posNED;
    rngPred = deltaPosNED.length();

    // calculate measurement innovation
    rngBcn.innov = rngPred - rngBcn.dataDelayed.rng;

    // perform fusion of range measurement
    if (rngPred > 0.1f)
    {
        // calculate observation jacobians
        ftype H_BCN[24];
        memset(H_BCN, 0, sizeof(H_BCN));
        ftype t2 = bcn_pd-pd;
        ftype t3 = bcn_pe-pe;
        ftype t4 = bcn_pn-pn;
        ftype t5 = t2*t2;
        ftype t6 = t3*t3;
        ftype t7 = t4*t4;
        ftype t8 = t5+t6+t7;
        ftype t9 = 1.0f/sqrtF(t8);
        H_BCN[7] = -t4*t9;
        H_BCN[8] = -t3*t9;
        // If we are not using the beacons as a height reference, we pretend that the beacons
        // are at the same height as the flight vehicle when calculating the observation derivatives
        // and Kalman gains
        // TODO  - less hacky way of achieving this, preferably using an alternative derivation
        if (activeHgtSource != AP_NavEKF_Source::SourceZ::BEACON) {
            t2 = 0.0f;
        }
        H_BCN[9] = -t2*t9;

        // calculate Kalman gains
        ftype t10 = P[9][9]*t2*t9;
        ftype t11 = P[8][9]*t3*t9;
        ftype t12 = P[7][9]*t4*t9;
        ftype t13 = t10+t11+t12;
        ftype t14 = t2*t9*t13;
        ftype t15 = P[9][8]*t2*t9;
        ftype t16 = P[8][8]*t3*t9;
        ftype t17 = P[7][8]*t4*t9;
        ftype t18 = t15+t16+t17;
        ftype t19 = t3*t9*t18;
        ftype t20 = P[9][7]*t2*t9;
        ftype t21 = P[8][7]*t3*t9;
        ftype t22 = P[7][7]*t4*t9;
        ftype t23 = t20+t21+t22;
        ftype t24 = t4*t9*t23;
        rngBcn.varInnov = R_BCN+t14+t19+t24;
        ftype t26;
        if (rngBcn.varInnov >= R_BCN) {
            t26 = 1.0f/rngBcn.varInnov;
            faultStatus.bad_rngbcn = false;
        } else {
            // the calculation is badly conditioned, so we cannot perform fusion on this step
            // we reset the covariance matrix and try again next measurement
            CovarianceInit();
            faultStatus.bad_rngbcn = true;
            return;
        }

        Kfusion[0] = -t26*(P[0][7]*t4*t9+P[0][8]*t3*t9+P[0][9]*t2*t9);
        Kfusion[1] = -t26*(P[1][7]*t4*t9+P[1][8]*t3*t9+P[1][9]*t2*t9);
        Kfusion[2] = -t26*(P[2][7]*t4*t9+P[2][8]*t3*t9+P[2][9]*t2*t9);
        Kfusion[3] = -t26*(P[3][7]*t4*t9+P[3][8]*t3*t9+P[3][9]*t2*t9);
        Kfusion[4] = -t26*(P[4][7]*t4*t9+P[4][8]*t3*t9+P[4][9]*t2*t9);
        Kfusion[5] = -t26*(P[5][7]*t4*t9+P[5][8]*t3*t9+P[5][9]*t2*t9);
        Kfusion[7] = -t26*(t22+P[7][8]*t3*t9+P[7][9]*t2*t9);
        Kfusion[8] = -t26*(t16+P[8][7]*t4*t9+P[8][9]*t2*t9);

        if (!inhibitDelAngBiasStates) {
            Kfusion[10] = -t26*(P[10][7]*t4*t9+P[10][8]*t3*t9+P[10][9]*t2*t9);
            Kfusion[11] = -t26*(P[11][7]*t4*t9+P[11][8]*t3*t9+P[11][9]*t2*t9);
            Kfusion[12] = -t26*(P[12][7]*t4*t9+P[12][8]*t3*t9+P[12][9]*t2*t9);
        } else {
            // zero indexes 10 to 12
            zero_range(&Kfusion[0], 10, 12);
        }

        if (!inhibitDelVelBiasStates && !badIMUdata) {
            for (uint8_t index = 0; index < 3; index++) {
                const uint8_t stateIndex = index + 13;
                if (!dvelBiasAxisInhibit[index]) {
                    Kfusion[stateIndex] = -t26*(P[stateIndex][7]*t4*t9+P[stateIndex][8]*t3*t9+P[stateIndex][9]*t2*t9);
                } else {
                    Kfusion[stateIndex] = 0.0f;
                }
            }
        } else {
            // zero indexes 13 to 15
            zero_range(&Kfusion[0], 13, 15);
        }

        // only allow the range observations to modify the vertical states if we are using it as a height reference
        if (activeHgtSource == AP_NavEKF_Source::SourceZ::BEACON) {
            Kfusion[6] = -t26*(P[6][7]*t4*t9+P[6][8]*t3*t9+P[6][9]*t2*t9);
            Kfusion[9] = -t26*(t10+P[9][7]*t4*t9+P[9][8]*t3*t9);
        } else {
            Kfusion[6] = 0.0f;
            Kfusion[9] = 0.0f;
        }

        if (!inhibitMagStates) {
            Kfusion[16] = -t26*(P[16][7]*t4*t9+P[16][8]*t3*t9+P[16][9]*t2*t9);
            Kfusion[17] = -t26*(P[17][7]*t4*t9+P[17][8]*t3*t9+P[17][9]*t2*t9);
            Kfusion[18] = -t26*(P[18][7]*t4*t9+P[18][8]*t3*t9+P[18][9]*t2*t9);
            Kfusion[19] = -t26*(P[19][7]*t4*t9+P[19][8]*t3*t9+P[19][9]*t2*t9);
            Kfusion[20] = -t26*(P[20][7]*t4*t9+P[20][8]*t3*t9+P[20][9]*t2*t9);
            Kfusion[21] = -t26*(P[21][7]*t4*t9+P[21][8]*t3*t9+P[21][9]*t2*t9);
        } else {
            // zero indexes 16 to 21
            zero_range(&Kfusion[0], 16, 21);
        }

        if (!inhibitWindStates && !treatWindStatesAsTruth) {
            Kfusion[22] = -t26*(P[22][7]*t4*t9+P[22][8]*t3*t9+P[22][9]*t2*t9);
            Kfusion[23] = -t26*(P[23][7]*t4*t9+P[23][8]*t3*t9+P[23][9]*t2*t9);
        } else {
            // zero indexes 22 to 23
            zero_range(&Kfusion[0], 22, 23);
        }

        // Calculate innovation using the selected offset value
        Vector3F delta = stateStruct.position - rngBcn.dataDelayed.beacon_posNED;
        rngBcn.innov = delta.length() - rngBcn.dataDelayed.rng;

        // calculate the innovation consistency test ratio
        rngBcn.testRatio = sq(rngBcn.innov) / (sq(MAX(0.01f * (ftype)frontend->_rngBcnInnovGate, 1.0f)) * rngBcn.varInnov);

        // fail if the ratio is > 1, but don't fail if bad IMU data
        rngBcn.health = ((rngBcn.testRatio < 1.0f) || badIMUdata);

        // test the ratio before fusing data
        if (rngBcn.health) {

            // restart the counter
            rngBcn.lastPassTime_ms = imuSampleTime_ms;

            // correct the covariance P = (I - K*H)*P
            // take advantage of the empty columns in KH to reduce the
            // number of operations
            for (unsigned i = 0; i<=stateIndexLim; i++) {
                for (unsigned j = 0; j<=6; j++) {
                    KH[i][j] = 0.0f;
                }
                for (unsigned j = 7; j<=9; j++) {
                    KH[i][j] = Kfusion[i] * H_BCN[j];
                }
                for (unsigned j = 10; j<=23; j++) {
                    KH[i][j] = 0.0f;
                }
            }
            for (unsigned j = 0; j<=stateIndexLim; j++) {
                for (unsigned i = 0; i<=stateIndexLim; i++) {
                    ftype res = 0;
                    res += KH[i][7] * P[7][j];
                    res += KH[i][8] * P[8][j];
                    res += KH[i][9] * P[9][j];
                    KHP[i][j] = res;
                }
            }
            // Check that we are not going to drive any variances negative and skip the update if so
            bool healthyFusion = true;
            for (uint8_t i= 0; i<=stateIndexLim; i++) {
                if (KHP[i][i] > P[i][i]) {
                    healthyFusion = false;
                }
            }
            if (healthyFusion) {
                // update the covariance matrix
                for (uint8_t i= 0; i<=stateIndexLim; i++) {
                    for (uint8_t j= 0; j<=stateIndexLim; j++) {
                        P[i][j] = P[i][j] - KHP[i][j];
                    }
                }

                // force the covariance matrix to be symmetrical and limit the variances to prevent ill-conditioning.
                ForceSymmetry();
                ConstrainVariances();

                // correct the state vector
                for (uint8_t j= 0; j<=stateIndexLim; j++) {
                    statesArray[j] = statesArray[j] - Kfusion[j] * rngBcn.innov;
                }

                // record healthy fusion
                faultStatus.bad_rngbcn = false;

            } else {
                // record bad fusion
                faultStatus.bad_rngbcn = true;

            }
        }

        // Update the fusion report
        if (rngBcn.dataDelayed.beacon_ID < rngBcn.numFusionReports) {
            auto &report = rngBcn.fusionReport[rngBcn.dataDelayed.beacon_ID];
            report.beaconPosNED = rngBcn.dataDelayed.beacon_posNED;
            report.innov = rngBcn.innov;
            report.innovVar = rngBcn.varInnov;
            report.rng = rngBcn.dataDelayed.rng;
            report.testRatio = rngBcn.testRatio;
        }
    }
}

/*
Use range beacon measurements to calculate a static position using a 3-state EKF algorithm.
Algorithm based on the following:
https://github.com/priseborough/InertialNav/blob/master/derivations/range_beacon.m
*/
void NavEKF3_core::FuseRngBcnStatic()
{
    // get the estimated range measurement variance
    const ftype R_RNG = sq(MAX(rngBcn.dataDelayed.rngErr , 0.1f));

    /*
    The first thing to do is to check if we have started the alignment and if not, initialise the
    states and covariance to a first guess. To do this iterate through the available beacons and then
    initialise the initial position to the mean beacon position. The initial position uncertainty
    is set to the mean range measurement.
    */
    if (!rngBcn.alignmentStarted) {
        if (rngBcn.dataDelayed.beacon_ID != rngBcn.lastIndex) {
            rngBcn.posSum += rngBcn.dataDelayed.beacon_posNED;
            rngBcn.lastIndex = rngBcn.dataDelayed.beacon_ID;
            rngBcn.sum += rngBcn.dataDelayed.rng;
            rngBcn.numMeas++;

            // capture the beacon vertical spread
            if (rngBcn.dataDelayed.beacon_posNED.z > rngBcn.maxPosD) {
                rngBcn.maxPosD = rngBcn.dataDelayed.beacon_posNED.z;
            } else if(rngBcn.dataDelayed.beacon_posNED.z < rngBcn.minPosD) {
                rngBcn.minPosD = rngBcn.dataDelayed.beacon_posNED.z;
            }
        }
        if (rngBcn.numMeas >= 100) {
            rngBcn.alignmentStarted = true;
            ftype tempVar = 1.0f / (ftype)rngBcn.numMeas;
            // initialise the receiver position to the centre of the beacons and at zero height
            rngBcn.receiverPos.x = rngBcn.posSum.x * tempVar;
            rngBcn.receiverPos.y = rngBcn.posSum.y * tempVar;
            rngBcn.receiverPos.z = 0.0f;
            rngBcn.receiverPosCov[2][2] = rngBcn.receiverPosCov[1][1] = rngBcn.receiverPosCov[0][0] = rngBcn.sum * tempVar;
            rngBcn.lastIndex  = 0;
            rngBcn.numMeas = 0;
            rngBcn.posSum.zero();
            rngBcn.sum = 0.0f;
        }
    }

    if (rngBcn.alignmentStarted) {
        rngBcn.numMeas++;

        if (rngBcn.numMeas >= 100) {
            // 100 observations is enough for a stable estimate under most conditions
            // TODO monitor stability of the position estimate
            rngBcn.alignmentCompleted = true;

        }

        if (rngBcn.alignmentCompleted) {
            if (activeHgtSource != AP_NavEKF_Source::SourceZ::BEACON) {
                // We are using a different height reference for the main EKF so need to estimate a vertical
                // position offset to be applied to the beacon system that minimises the range innovations
                // The position estimate should be stable after 100 iterations so we use a simple dual
                // hypothesis 1-state EKF to estimate the offset
                Vector3F refPosNED;
                refPosNED.x = rngBcn.receiverPos.x;
                refPosNED.y = rngBcn.receiverPos.y;
                refPosNED.z = stateStruct.position.z;
                CalcRangeBeaconPosDownOffset(R_RNG, refPosNED, true);

            } else {
                // we are using the beacons as the primary height source, so don't modify their vertical position
                rngBcn.posOffsetNED.z = 0.0f;

            }
        } else {
            if (activeHgtSource != AP_NavEKF_Source::SourceZ::BEACON) {
                // The position estimate is not yet stable so we cannot run the 1-state EKF to estimate
                // beacon system vertical position offset. Instead we initialise the dual hypothesis offset states
                // using the beacon vertical position, vertical position estimate relative to the beacon origin
                // and the main EKF vertical position

                // Calculate the mid vertical position of all beacons
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          322322C322322322322322322322322322f322$322 322 322 322 322                  322%322322322322322322322322322322322322322322322[322 322 322                322"322322322322ihh322322322322322\322               322h322322322yyy322322322322'           322322322322322322322322[         322322322322322322322o       322322322322322322s      322322poo322322322322322322322322322322322322a    322322322322322322"v-++*+,'b/322322322322322322%   322322322322"w-(&),,,,*(&+322322322322322   322322322322)' ~-322322322322322322322322322*&,322322322322322$    322322322,&,322322322gff322322322)*322322322322322k     322322322322,(322322322322322,*322322~~~322322322a    322322'c/322322,)322322322322,+322322(]/322322322%   322322
'	&,(322322{zz322,'+%*322322   322322- $$322322322322( $*322322322$    322322,%322322322322322322322322322322322,'322322322k     3220322322,322322322322322322%l.+*,322322322322322322 ~-322322       322d322322322322322322322322,% $	''% $)322322322322322322322322         322+322322A322322322322322* $)(_/322322322,&%,3223223223223223229322x322          322322322,322322+ $,322322322edd322322322)&322322,322322322A            322322322+$& $322322322322322% $&%322322322I             322O322322) $)322322~~~322&h.% $,322322               322x322322*322322322322322322322,+322322322                322322322322322r322322322322322Z322322322322322Q322                 322322322322y322322322322322322322322U322322322322v322 322                  322322322322322322322322322322)[/322322322322322322 322 322                    322322322))&h./B1+ $ ~-322322^322 322 322 322 322                     322j322322	& $ $ $+322322322322 322 322 322 322                     322 322322, $ $)322322322F322 322 322 322 322 322                     322 322322322,'322322322u322 322 322 322 322 322 322                     322 322 3223322322322322322322 322 322 322 322 322 322 322                     322 322 322 322S322322322322 322 322 322 322 322 322 322 322                     322 322 322 322 322 322 322 322 322 322 322 322 322 322 322 322                     322 322 322 322 322 322 322 322 322 322 322 322 322 322 322 322                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          322 322 322 322 322 322 322 322 322 322 322 322 322 322 322 322 322 322 322                  322 322 322 322 322 322 322 322 322 322 322 322 322 322 322*322322322322
                 322 322 322 322 322 322 322 322 322 322 322 322 322 322n322322322322322                 322 322 322 322 322 322 322 322 322 322 322 322322322322322322                 322 322 322 322 322 322 322 322 322 322 322n322322A@@322322                 322 322 322 322 322 322 322 322 322
322322322wvv322322                 322 322 322 322 322 322 322 322]322322A@@322322                 322 322 322 322 322 322
322322322ihh322322322                 322 322 322 322 322;322322322\[[322322322322,                 322 322 322 322322322\[[322322322322L                   322 322;322322322NMM322322322                     322;322322\[[wvv322322322322,322                      322322A@@322322322n322 322 322                      322322ihh322322322322322 322 322 322                      322322322322322322]322 322 322 322 322 322                      322322ihh322322322322322 322 322 322                      322322A@@322322322n322 322 322                      322;322322\[[wvv322322322322,322                      322 322;322322322NMM322322322                     322 322 322 322322322\[[322322322322L                   322 322 322 322 322;322322322\[[322322322322,                 322 322 322 322 322 322
322322322ihh322322322                 322 322 322 322 322 322 322 322]322322A@@322322                 322 322 322 322 322 322 322 322 322
322322322wvv322322                 322 322 322 322 322 322 322 322 322 322 322n322322A@@322322                 322 322 322 322 322 322 322 322 322 322 322 322322322322322322                 322 322 322 322 322 322 322 322 322 322 322 322 322 322n322322322322322                 322 322 322 322 322 322 322 322 322 322 322 322 322 322 322*322322322322
                 322 322 322 322 322 322 322 322 322 322 322 322 322 322 322 322 322 322 322                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     322 322322 322 322 322 322 322 322 322 322 322                         322322322322
322 322 322 322 322 322 322 322                         322A@@322322322]                               322ihh322322322322
                             322322322322322;                            322\[[322322322                           322322322322322,                         322A@@\[[322322322                        322322322wvv322322322322,                       322n322322322NMM322322322n                       322322322322\[[322322322322                       322]322322322A@@322322322                        322322322NMMwvv322322                         322;322322322wvv322322                           322322322NMM322322                         322;322322322wvv322322                        322322322NMMwvv322322                      322]322322322A@@322322322                    322322322322\[[322322322322                    322n322322322NMM322322322n                     322322322wvv322322322322,                      322A@@\[[322322322                        322322322322322,                         322\[[322322322                           322322322322322;                            322ihh322322322322
                             322A@@322322322]                               322322322322
322 322 322 322 322 322 322 322                         322 322322 322 322 322 322 322 322 322 322 322                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             322 322 322 322 322 322 322 322 322 322 322 322 322 322 322 322 322 322 322 322 322 322 322 322 322 322 322 322 322 322 322 322     322 322 322 322 322 322 322 322 322 322 322 322 322 322 322 322 322 322 322 322 322 322 322 322 322 322 322 322 322 322 322 322     322 322 322 322 322 322 322 322 322 322 322 322 322 322322B322e322322322t322N322'322322 322 322 322 322 322322?322c322&322     322 322 322 322 322 322 322 322 322 322 322322322322322322322322322322322322322322?322 322 322&3223223223223229    322 322 322 322 322 322 322 322 322322322322322DCChggqqqQQQ433322322322322N322322'Wdm3223223229   322 322 322 322 322 322 322 322_322322655uttIHH322322322'Ua y3223223229  322 322 322 322 322 322 322322322rrrSRR655322322322DCCkjj666+MU y322322  322 322 322 322 322 322322=<<\[[322322A@@]]]pooutthggJII322322<;;C]e179322322322  322 322 322 322 322322BAAlkk322322RQQ3229RY178322&Xe"v322322  322 322 322 322g322=<<NMM322fee~~~TSSA@@<;;HGGeee9U]19<3224:;
333322322A  322 322 322 322322QQQ322UUU322322322322322322322322544@^e0:<322322 +KT322322   322 322 322]322}||poo322322322LKKA@@0LT0:<322322"du  p322322    322 322!322322gff322}||322322Bdm267322322.@D322322322,    322 322]322}}}322322322322DCC3223223223227MR179322322322.AF322322|      322 322H322mll322322322322322322vvv322322322322322'Ta0:=322322322 j} #dt322322        322 322322322322322322J322322322\322322322322322322322%]l0:=322322322-EL322322322        322 322 322322H322q3224322 322 322 322 322=322z322T32232219<q333322322322334/=A322322j          322 322 322 322 322 322 322 322 322 322 322322t3223220:< $_m322.@D l %\j322322            322 322 322 322 322 322 322 322 3223223223223220<?%]k-CI 	o322322322  
 Z c     322 322 322 322 322 322 322 3223223220;>#br 322322)hx |*NW322322322322,          322 322 322 322 322 322 322 322322#dt } $br	333322322322322322): S         322 322 322 322 322 322 322~322.BG&Zg267322322  	+IQ322322322?U             322 322 322 322 322 322=322322.BG322322322333 m267322322322322322     322-3228     322 322 322 322 322 322322{ $^m322322322245 $]m322322322322322433322322322|322322|322322322322    322 322 322 322 322322,GM 322322322245 ']j322322322322322dccSRR322322322322322VUU_^^322322j   322 322 322 322>32233419;322322322 ;cm322322322322QPP=<<322322322322322   322 322 322	322322| 'Vb322322334;ak322322srr322[ZZVUU877322322j   322 322 322322'Va 322322334 2S\322[ZZmll;::322322322POO322322    322 322Z32219<267322322 =o|ghi=<<322322322322322322322]]]322@??>==322322@    322322322 )Q[322322 /Ze\]]mlledd|{{fee322EDDMLL322322     322Z322"fx q322334?hs888322ONNkjj322322uttONN322322      322322 'Vb3229Ya988322322322>==BAA655322322322mmmA@@322322322      322Z3220:= %[j322NMMeeeXWWUUU[ZZyxxnmm322322322322       322 32232218: #dt322322322322IIIfee322322322322g         322 322 322322322322322322322,322R322322322322322322322322322322322322322322322322322 322 322 322 322 322     322 322 322 322322322322322,322 322 322 3226322322322322322322322322322322322_322322 322 322 322 322 322 322 322     322 322 322 322 322 322 322 322 322 322 322 322 322 322 322 322 322 322 322 322 322 322 322 322 322 322 322 322 322 322 322 322     322 322 322 322 322 322 322 322 322 322 322 322 322 322 322 322 322 322 322 322 322 322 322 322 322 322 322 322 322 322 322 322                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 322 322 322 322@322}322322~322A322 322 322 322 322 322 322 322                     322 322 322322322322322322322322 322 322 322 322 322 322                      322322655766322322                          322322433433322322                        322322877877322322                      322322988:99322322                    322322=<<=<<322322                  322322>==>==322322               322322322DCCBBB322322322            322322322GFFFEE322322           322322322HGGGFF322322322
         322322NMMLKK322322        322_322UTTQPP322322K       322322322322       322_322322322322322322322322322322322322322322322322322322322322322322322322322322322322K        322_322322322322322322322322322322322322322322322322322322322322322322322322322322K                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 322 322 322 322 322 322 322 322 322 322 322 322 322 322 322 322                     322 322 322 322 322 322 322 322 322 322 322 322 322 322 322 322                322,322322322322322322 322 322 322 322 322 322;322322322322322 322 322 322               322322322322322322322322 322 322 322 322 322;322322322322322322322 322 322               322322wvvNMM322322]322 322 322 322 322322322322322322 322               322322322322322 322 322 322;322A@@iii322322E322 322               322322A@@322322*322 322 322322A@@322322322 322               322;322NMM322322322 322 322322322322322 322 322                322322322322322 322;322\[[\[[322322]322 322 322                322322wvvNMM322322;322322322322322 322 322 322                322322322322322322322322322322 322 322 322                 322322322322322iii322322322*322 322 322 322                 322;322NMM\[[322322322322322 322 322 322 322                  322322322322NMM322322;322 322 322 322 322                  322n322iii322wvv322322322 322 322 322 322 322                  322322322iiiwvv322322n322 322 322 322 322 322                   322322322322322322 322 322 322 322 322                   322;322A@@322322322 322 322 322 322 322 322                    322322A@@322322;322 322 322 322 322 322 322                    322]322A@@wvv322322322 322 322 322 322 322 322 322                     322322322322322322322322322 322 322 322 322 322 322 322                     322 322322322322322322322 322 322 322 322 322 322 322 322                     322 322 322 322 322 322 322 322 322 322 322 322 322 322 322 322                     322 322 322 322 322 322 322 322 322 322 322 322 322 322 322 322                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     322 322 322 322 322 322 322 322 322 322 322 322,322322322322322322
                  322 322 322 322 322 322 322 322 322 322 322322322322322322322322                            322322iii\[[322322                          322*322322322322322     322,322322322322322322322322322322]322322322322322322   322322iii322322]    322322322322322322322322322322322322322322322322322322322322
 322322322322    322E322iiiA@@\[[322322322]322\[[iiiNMM322322;   322x322A@@322322322322322322   322x322wvv322322A@@wvv322322322322*  322x322\[[322322\[[322322322322NMM322322  322x322322322iii\[[322322322322322322322 322x322322322iiiNMM322322322iiiiii322322] 322x322322322iiiNMM322322322322322 322x322322322iiiNMM322322NMM322322322322322A@@322322;322x322322322iiiNMM322322NMM322322x322x322x322iii322322x322x322322322\[[A@@322322wvv322322  322322322322322f322;322322NMM322322322iii322322322iii322322\[[322322   322322\[[322322322* 322;322322322322322322,322322322322322322,322322322322322322322322322322    322
322322322322322322;   322;322x322x322;  322*322f322x322E322322322322322x322x322;322;322x322x322;       322;322x322x322;             322322322322322322322L                            322;322\[[322322                            322x322322322                            322x322322322322322322322322                       322x322322322322322322322322322,                      322x322iii322322                      322x322NMM322322L                     322x322322322                     322x322wvv322322322322                     322x322322322322322322                     322x322322322322322322                     322x322322322322322322                     322x322322322322322322                     322x322322322322322322                     322x322322322322322322                     322;322322\[[322322322A@@NMM322322n                      322;322322322322322322 322322322322322322322 322 322 322                     322;322x322x322;322 322 322 322;322x322x322;322 322 322 322 322                                                                                                                                                                                                                                               D                              D                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        PNG

   IHDR     $    4    IDATx}w|UuffzZ>D4(]{A@I{	zH	?f&,!eS|}~o9s????_V{1<qy T|xqHKK u(4N+D#@ c=aY, ;h%Ir9t71c,s kjU-[\8uef7$Iler^v x@ y&FSOZY"H!"r\W_QNv ] [n7m*{<);;>L#GPNNE~{clVRR  =z`X<, PNNu+o#GNg^:v_?:(L=3g$ WVZED$H-QFV5J  l8n' AvrIK, <
@f^hz	wyg~m={:Dg)z 169djz= I& 8@ ""_~Y


N@%xOM'yF,DD].WHEQ{ g4Lks^g[-[FD$Kk3g3fkf$IE())1VJJQuK6'ZEFF.'3 / &Mdome >t,#WXIVi! GoYYYK.=]\\l6/ qeiiiZN3gUoz@txxxjw>11qN<K,vZu@(OXimLL3fPm t  \T_GxFP
1(:Ab08dtY@)1F (im 8[W   n ".PS vy  V=.xb${G p+V|-fp7]1+L? bkv 3m\hdV'yXlt8{ 6cFmM3+)h#v<v=Lv7!,)nof0*j?[v}QSACz[kynS dgw[qtl	i|0 H {|k!f6p-4mnI#IN- *}fI^79p<G  ^:nyNV0)xGjXtzyfSxW"Z^/0v*i^<#;ttxkL9Sga,37aON G`d$E\1><F=-< . 
\,e,t8j/p*C &`,8,BWi@h`P/h3{fn5I @  Ry &=,`R\7e{))jw9uBu+f~p*gSgFRPi7RSSyu3\|.\H<F&A1M+S'$N@h|it:o8+'\-L+f=xj6Wn/TnK?xM-ghCqLY Vk{)x}KKKbbbp#G$<(I?RPPPVC}zjqvAD iC Cn<yp$I2YYYt@|}h-:ydn'I$"N>Muk84Nqn'#Y"^q Sgc k^Z)S[};	4%%E$Z <5ydgyy9N	 H%!cN[7taE1^Bk}PDn 1M#"2Cv|04J?&xMsRQ8W@@< t^IO <<TND{9'Gj;X,=zjgux-QuRRGR8<R4 $vFDks=(qj	[.]D$Q%w, h|o]TdO?z7%%7o~x=$,I$2@zoVVycy,Cohc{DD$I#G_z}BZ7SNUh\8 _wu`CfG{>6tUaxPPPHkW/(QFadDDnCeekuc}5^{d2ie^5o'
 [ |$ (5oZ@QY~G%z29~bU6TbPU:T0GD^x\(Y5%QU7s6V81" -D6fQ"(@	&M%r+Pe $%Dt+Qn!goy8q!A?/IaBDD4jQWO~^/Zu>YvxpQ,XWU  nwX]#|wR|6XgG^% k ZL*IRzyyySQ'DR1<e[:B 6[~tOC Vh^$#"3wx<c%ICD"xNzbId|g|/%7	Jk84FQDw[LOlN @\wI0 h4~ APUUK_1@Gg?sc]e$L} ,`L_y@L'7dB!,<+IxMB0ZS-`)i `=au/|&@3	*}kP}c+x945'fL fu,|Dhd&'%'RbKf$ Mj?Q+Was~#sMmWovY Q,bC^tOKCewJ uQDQ u Qou8UUF~GI`>qQ1{7FIzbcVUDt $I/"
EK.EzAe[j.`/	<ZY#N"@{( d.uo?l6&LY<#,8gn~Ot&D=^ dHD1QTc>7_t_ =3M~B'p/[fvvnG"RWjwe $#8'M+84{=']n>/|c:`$ScE\uX^:/^? e81D9cS^-3ljL+S!(Nu-~}`P1m['s7Pct;3a9s&<??))PeV]wW_{`!1/kr:Df~/h4.kK4}{Wr\O#""YIE""o%^
@S_0mx	R!kW\BR@@z j#/""Q$IEe$Ix6nt1o]+qmZnl6G](He9f/6,eY###1|~Q{DvWaa8R7& ^?v:T"n #VE2.Vws](~~P'&1>s^Q7-1Bl|8YxCX<tXXz^4

u8 jK]vrmBDfo;wI&  _^&NXh6z<N QSNdggcd2kZU6c?]xQ2eJ Fc7pcBBqtnu%I3}t.((xg%"
ioW||,w8!Xe,;^^^.<wIM,}o;Zh@O>Yyf?k!7c1fagwqG=zo&sn11de=wke3H+'_>uK$ N8!}!!!

[oU;={ 3scN	Zh! (n@LL}W V++--e r&\L6.W(	 `Z/ z}NOOG}}1-[m?ty T }vx;RoM65eggnO<oy 9o///7GW{Ucg{BQP^~z~n>	KSVVk@ zJFE*q-j??h*3<kqW58\	cSeKSBQ[k: <7n6mh<z >[uKW~YDDO'  hOO<)XUF8n 
g$I 16KqtMJKKG-] 
y ABc 

zW_/BJOOSjjtag,v_uiOI =eB?>>[nXDFF~A7n^]{<yooV;	~/&O\XPP@&M?swii)u<#"p~={{~PX,7xA5{wad69'?%N<h*"c<ER`` JF$If4i0LC[omrHy <<\f,A233(:I(%I8v6a_>gLnvn $IHE,88xlbbYYYEgGcEQ5)eOHH^RRR`XBvqVccco' %,E;@:\V PBpB0ZLjoUU<j~h=$DS8[k\-?/{<|Qcj[WkVXap5\mz6,--m?V"
t?	p*0(zRSSJ			k
jM>|+8[jLzgSPm-[,p6jUFC_rMf~#+oGG	'v~?CCdjCF'%#iS'^.))}!0fD$feeQ>} lpqoQOP"W "r\2'O;(t!jy =KJ7w^>KxvI D4,C^Au04ls("^E_'TEp%QiUrNwj #N^~kWl6'WP5$IeW^`i@@@(J:,c`e@@@_(+*;"{C*!AGhn<2dh0B#i#{/0i5Ml0@Nd(Dch_?U8rBR5%X#K dCB{%%%tK(u+0ZJ={?sXXXHIIIv #B@K.O>JL@+EmO9rD=DD'-Z8o>""!(-0hb]j wgOYE1uK.q H{xX3w2.\ 169RJF! \?FvD$57#N$qD41f0/}:OX\E JAFDi1`xW^!7=4{&M ,zka5\'(I@l4-r!76y|ibL*X,Gs5.bn.]_S_;wkHp F&)9s&>}xoeH ?9sF/rRR  |j4>m=%P/RWZZ///;&N? WV?f\^^Zp?n[S|Z,r($	OAn[SEtY!11n>}xep ?? ~P+5~0_HNNv2yozv6t~rc0|lc}e??.pRyPLQ+/ \W0 uS/mSar TWt?o>Zx1]t._L~!mDQ{RmOQ8{lGNm&egg{[oDEqI  <gK9|=rss+V8A  Q(ze  %f1vyj5rw)$$( a<HL&<F# _!((H2WlM 1777J:{, w;wZ d;Nww-(a:$-@  60
JlHZ (.pM46U5kb6`??T40r6	 AmP=ceD;bJ D@*8\Mqx+<O?QII	-Z6mJF'x"_~q;N6//O2eJ`Q%9c@pJKK9kE^t0LE lu%n_p!EOff&l6+_}?a.3fec*i/s/'x |y5,sD<zhQIIIQ&M1t$B/A	VBve"2#"&":t8jpYf<P-))x2 \c8*Oy~~sv<!(
FG&rz[k#VG(66 zHE+"/9sqQ@%y2Y!rY1bcnomS&M4mM?EEE}Pg@/s(<~-;vLj=11[n)bD+$ ssss%5 x@,,3A3eU.^xmCyh-	t:u9ro_ Cv7|yJ7ZO"%" 28	Eaoi855Ub0~~~QT>]{(\3j]FBZ%wy+BBB>\o:sK/`F ccR+QwL.++`o 3^|E3gx@(,66^p8R&M?1ls.\k n)x,1cd(''G:q=#`t9s)SN:e+g}_CquRko;Xd	-]  0bDt@ r "<.:j_nE'I r1h yy=%I}7U4KfJ<| 7u,"9z:@( s 	 t,U	]y-tb[B[[Iw %J\llE$"rkER\ll+ezmv}y)Ts?~qoU>DN:=w`sKK-V?cTRSS9[glR^pa>pWsQu|U8>1\rrrDiiY	qbn
}vzMUoQ,|yF6m`P c(/+w}w @yy9 /Of7UI<p *p _h.'Fb ={|cVhJ@:&$).- dYq`'80p'DN_)Tla.~Q+j[*@"1_~NoJ %%%uvl;>|u%%! 2;,V{=*DW6ln.5P?~_1J}?|~SJKKs=giCqAN;1e*+/12u@:jEmpC2dru'OPW \Rr:6L9rrq/rJ2G1F0>6;X6 ";vlj~-_8qXC!jXq&d8hX	{~N?6LV{_VYol;  OstLk6n(=}mNaZ,V^ofr'|=kw:I[&|Up:x0kHJd81/--]t$E?>r]v(>p:7wYEA]jY=jUN_TM|2w:;r8|;$$|D*Nq5t\c8Y;uN;ydVU.~7"?iv<pNfkNE	[;`Nj]GWw/N'v,lq`CR4k#<BDSLfy?Su@&$I18vec?L{Wo(*)]&Rj8;z=>rG2*4*#="$
uUk|r8}Ug_uqOtUG?5x}N?/--q z`//nA>8cX~1[/L}7TnRQA-[xBPPduCII	;SgIjj*HwV^d+" (GOst\\-C&}!Z*,C22nrS5!:t,CzDu]>zX|rD| D-	 MKmY}3Pu B+|29}y/]~\:tZQ=:Y<\	"~N?_zN(
yk${E{omis~@9} /*zO_G]w]~m4ebu'kwet:KO~t'Nd<t(Yb
k~N??JUk*y<{8!V6K J@".pEj" JBHe~hch}{ j*_>|z[n\x@.((toUe4*0@hL&/(//| Qi)RPP9oE.]Wl<22Rc|@+Wu:CI|%] qaYGNNN.f .]^(**u:]AqqqL@@ bccr k$++kk9s, h""'n3gn!"Ah{~=CXN'J%
>jw8pTXXQ9t `hm?`eP3B3ne222
8.\Uca4y ":t:$I:Y9Y!Fi?z!,Z%%%*6.]$=lZr*$IZl/vQ6p!9w^%%%yPDay{`9gA R4mTx<\MvZ`IkbY:u7j'K@"Bc2q6 e*IW^y%,,,S/));6UUPLRv>}:t?q\.&]#"COJJQ]U^f[oI:v"zteeet7 n-]UGv^}c  0a"K.e nX`A&o~ii)\R[.O2Os!jN%55^Y2T+6