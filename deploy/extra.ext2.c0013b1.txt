Bytes(number, bytes, index);
}


/*!
 * Encode a float on a byte stream by floating point scaling to fit in 3 signed
 * bytes in big endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 3 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void float32ScaledTo3SignedBeBytes(float value, uint8_t* bytes, int* index, float scaler)
{
    // scale the number
    float scaledvalue = (float)(value*scaler);
    int32_t number;

    // Make sure number fits in the range
    if(scaledvalue >= 0)
    {
        if(scaledvalue >= 8388607)
            number = 8388607;
        else
            number = (int32_t)(scaledvalue + 0.5f); // account for fractional truncation
    }
    else
    {
        if(scaledvalue <= (-8388607l - 1))
            number = (-8388607l - 1);
        else
            number = (int32_t)(scaledvalue - 0.5f); // account for fractional truncation
    }

    int24ToBeBytes(number, bytes, index);
}


/*!
 * Encode a float on a byte stream by floating point scaling to fit in 3 signed
 * bytes in little endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 3 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void float32ScaledTo3SignedLeBytes(float value, uint8_t* bytes, int* index, float scaler)
{
    // scale the number
    float scaledvalue = (float)(value*scaler);
    int32_t number;

    // Make sure number fits in the range
    if(scaledvalue >= 0)
    {
        if(scaledvalue >= 8388607)
            number = 8388607;
        else
            number = (int32_t)(scaledvalue + 0.5f); // account for fractional truncation
    }
    else
    {
        if(scaledvalue <= (-8388607l - 1))
            number = (-8388607l - 1);
        else
            number = (int32_t)(scaledvalue - 0.5f); // account for fractional truncation
    }

    int24ToLeBytes(number, bytes, index);
}


/*!
 * Encode a float on a byte stream by floating point scaling to fit in 2
 * unsigned bytes in big endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void float32ScaledTo2UnsignedBeBytes(float value, uint8_t* bytes, int* index, float min, float scaler)
{
    // scale the number
    float scaledvalue = (float)((value - min)*scaler);
    uint16_t number;

    // Make sure number fits in the range
    if(scaledvalue >= 65535u)
        number = 65535u;
    else if(scaledvalue <= 0)
        number = 0;
    else
        number = (uint16_t)(scaledvalue + 0.5f); // account for fractional truncation

    uint16ToBeBytes(number, bytes, index);
}


/*!
 * Encode a float on a byte stream by floating point scaling to fit in 2
 * unsigned bytes in little endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void float32ScaledTo2UnsignedLeBytes(float value, uint8_t* bytes, int* index, float min, float scaler)
{
    // scale the number
    float scaledvalue = (float)((value - min)*scaler);
    uint16_t number;

    // Make sure number fits in the range
    if(scaledvalue >= 65535u)
        number = 65535u;
    else if(scaledvalue <= 0)
        number = 0;
    else
        number = (uint16_t)(scaledvalue + 0.5f); // account for fractional truncation

    uint16ToLeBytes(number, bytes, index);
}


/*!
 * Encode a float on a byte stream by floating point scaling to fit in 2 signed
 * bytes in big endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void float32ScaledTo2SignedBeBytes(float value, uint8_t* bytes, int* index, float scaler)
{
    // scale the number
    float scaledvalue = (float)(value*scaler);
    int16_t number;

    // Make sure number fits in the range
    if(scaledvalue >= 0)
    {
        if(scaledvalue >= 32767)
            number = 32767;
        else
            number = (int16_t)(scaledvalue + 0.5f); // account for fractional truncation
    }
    else
    {
        if(scaledvalue <= (-32767 - 1))
            number = (-32767 - 1);
        else
            number = (int16_t)(scaledvalue - 0.5f); // account for fractional truncation
    }

    int16ToBeBytes(number, bytes, index);
}


/*!
 * Encode a float on a byte stream by floating point scaling to fit in 2 signed
 * bytes in little endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void float32ScaledTo2SignedLeBytes(float value, uint8_t* bytes, int* index, float scaler)
{
    // scale the number
    float scaledvalue = (float)(value*scaler);
    int16_t number;

    // Make sure number fits in the range
    if(scaledvalue >= 0)
    {
        if(scaledvalue >= 32767)
            number = 32767;
        else
            number = (int16_t)(scaledvalue + 0.5f); // account for fractional truncation
    }
    else
    {
        if(scaledvalue <= (-32767 - 1))
            number = (-32767 - 1);
        else
            number = (int16_t)(scaledvalue - 0.5f); // account for fractional truncation
    }

    int16ToLeBytes(number, bytes, index);
}


/*!
 * Encode a float on a byte stream by floating point scaling to fit in 1
 * unsigned byte.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 1 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void float32ScaledTo1UnsignedBytes(float value, uint8_t* bytes, int* index, float min, float scaler)
{
    // scale the number
    float scaledvalue = (float)((value - min)*scaler);
    uint8_t number;

    // Make sure number fits in the range
    if(scaledvalue >= 255u)
        number = 255u;
    else if(scaledvalue <= 0)
        number = 0;
    else
        number = (uint8_t)(scaledvalue + 0.5f); // account for fractional truncation

    uint8ToBytes(number, bytes, index);
}


/*!
 * Encode a float on a byte stream by floating point scaling to fit in 1 signed
 * byte.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 1 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void float32ScaledTo1SignedBytes(float value, uint8_t* bytes, int* index, float scaler)
{
    // scale the number
    float scaledvalue = (float)(value*scaler);
    int8_t number;

    // Make sure number fits in the range
    if(scaledvalue >= 0)
    {
        if(scaledvalue >= 127)
            number = 127;
        else
            number = (int8_t)(scaledvalue + 0.5f); // account for fractional truncation
    }
    else
    {
        if(scaledvalue <= (-127 - 1))
            number = (-127 - 1);
        else
            number = (int8_t)(scaledvalue - 0.5f); // account for fractional truncation
    }

    int8ToBytes(number, bytes, index);
}


/*!
 * Scale a uint32_t using integer scaling to the base integer type used for
 * bitfields.
 * \param value is the number to scale.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer.
 * \param bits is the number of bits in the bitfield, used to limit the returned value.
 * \return (value-min)*scaler.
 */
unsigned int uint32ScaledToBitfield(uint32_t value, int32_t min, uint32_t scaler, int bits)
{
    // The largest integer the bitfield can hold
    unsigned int max = (0x1u << bits) - 1;

    // Scale the number
    unsigned int number = (unsigned int)((value - min)*scaler);

    // Protect from underflow
    if(((int32_t)value) < min)
        return 0;

    // Protect from overflow
    if(number > max)
        return max;

    return number;
}


/*!
 * Encode a uint32_t on a byte stream by integer scaling to fit in 4 unsigned
 * bytes in big endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 4 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void uint32ScaledTo4UnsignedBeBytes(uint32_t value, uint8_t* bytes, int* index, int32_t min, uint32_t scaler)
{
    // scale the number
    uint32_t number = 0;

    // Make sure number fits in the range
    if(((int32_t)value) > min)
    {
        number = (uint32_t)((value - min)*scaler);
    }

    uint32ToBeBytes(number, bytes, index);
}


/*!
 * Encode a uint32_t on a byte stream by integer scaling to fit in 4 unsigned
 * bytes in little endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 4 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void uint32ScaledTo4UnsignedLeBytes(uint32_t value, uint8_t* bytes, int* index, int32_t min, uint32_t scaler)
{
    // scale the number
    uint32_t number = 0;

    // Make sure number fits in the range
    if(((int32_t)value) > min)
    {
        number = (uint32_t)((value - min)*scaler);
    }

    uint32ToLeBytes(number, bytes, index);
}


/*!
 * Encode a uint32_t on a byte stream by integer scaling to fit in 4 signed
 * bytes in big endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 4 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void uint32ScaledTo4SignedBeBytes(uint32_t value, uint8_t* bytes, int* index, uint32_t scaler)
{
    // scale the number
    int32_t number = (int32_t)(value*scaler);

    int32ToBeBytes(number, bytes, index);
}


/*!
 * Encode a uint32_t on a byte stream by integer scaling to fit in 4 signed
 * bytes in little endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 4 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void uint32ScaledTo4SignedLeBytes(uint32_t value, uint8_t* bytes, int* index, uint32_t scaler)
{
    // scale the number
    int32_t number = (int32_t)(value*scaler);

    int32ToLeBytes(number, bytes, index);
}


/*!
 * Encode a uint32_t on a byte stream by integer scaling to fit in 3 unsigned
 * bytes in big endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 3 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void uint32ScaledTo3UnsignedBeBytes(uint32_t value, uint8_t* bytes, int* index, int32_t min, uint32_t scaler)
{
    // scale the number
    uint32_t number = 0;

    // Make sure number fits in the range
    if(((int32_t)value) > min)
    {
        number = (uint32_t)((value - min)*scaler);
        if(number > 16777215ul)
            number = 16777215ul;
    }

    uint24ToBeBytes((uint32_t)number, bytes, index);
}


/*!
 * Encode a uint32_t on a byte stream by integer scaling to fit in 3 unsigned
 * bytes in little endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 3 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void uint32ScaledTo3UnsignedLeBytes(uint32_t value, uint8_t* bytes, int* index, int32_t min, uint32_t scaler)
{
    // scale the number
    uint32_t number = 0;

    // Make sure number fits in the range
    if(((int32_t)value) > min)
    {
        number = (uint32_t)((value - min)*scaler);
        if(number > 16777215ul)
            number = 16777215ul;
    }

    uint24ToLeBytes((uint32_t)number, bytes, index);
}


/*!
 * Encode a uint32_t on a byte stream by integer scaling to fit in 3 signed
 * bytes in big endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 3 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void uint32ScaledTo3SignedBeBytes(uint32_t value, uint8_t* bytes, int* index, uint32_t scaler)
{
    // scale the number
    int32_t number = (int32_t)(value*scaler);

    // Make sure number fits in the range
    if(number > 8388607l)
        number = 8388607l;
    else if(number < (-8388607l - 1))
        number = (-8388607l - 1);

    int24ToBeBytes((int32_t)number, bytes, index);
}


/*!
 * Encode a uint32_t on a byte stream by integer scaling to fit in 3 signed
 * bytes in little endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 3 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void uint32ScaledTo3SignedLeBytes(uint32_t value, uint8_t* bytes, int* index, uint32_t scaler)
{
    // scale the number
    int32_t number = (int32_t)(value*scaler);

    // Make sure number fits in the range
    if(number > 8388607l)
        number = 8388607l;
    else if(number < (-8388607l - 1))
        number = (-8388607l - 1);

    int24ToLeBytes((int32_t)number, bytes, index);
}


/*!
 * Encode a uint32_t on a byte stream by integer scaling to fit in 2 unsigned
 * bytes in big endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void uint32ScaledTo2UnsignedBeBytes(uint32_t value, uint8_t* bytes, int* index, int32_t min, uint32_t scaler)
{
    // scale the number
    uint32_t number = 0;

    // Make sure number fits in the range
    if(((int32_t)value) > min)
    {
        number = (uint32_t)((value - min)*scaler);
        if(number > 65535u)
            number = 65535u;
    }

    uint16ToBeBytes((uint16_t)number, bytes, index);
}


/*!
 * Encode a uint32_t on a byte stream by integer scaling to fit in 2 unsigned
 * bytes in little endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void uint32ScaledTo2UnsignedLeBytes(uint32_t value, uint8_t* bytes, int* index, int32_t min, uint32_t scaler)
{
    // scale the number
    uint32_t number = 0;

    // Make sure number fits in the range
    if(((int32_t)value) > min)
    {
        number = (uint32_t)((value - min)*scaler);
        if(number > 65535u)
            number = 65535u;
    }

    uint16ToLeBytes((uint16_t)number, bytes, index);
}


/*!
 * Encode a uint32_t on a byte stream by integer scaling to fit in 2 signed
 * bytes in big endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void uint32ScaledTo2SignedBeBytes(uint32_t value, uint8_t* bytes, int* index, uint32_t scaler)
{
    // scale the number
    int32_t number = (int32_t)(value*scaler);

    // Make sure number fits in the range
    if(number > 32767)
        number = 32767;
    else if(number < (-32767 - 1))
        number = (-32767 - 1);

    int16ToBeBytes((int16_t)number, bytes, index);
}


/*!
 * Encode a uint32_t on a byte stream by integer scaling to fit in 2 signed
 * bytes in little endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void uint32ScaledTo2SignedLeBytes(uint32_t value, uint8_t* bytes, int* index, uint32_t scaler)
{
    // scale the number
    int32_t number = (int32_t)(value*scaler);

    // Make sure number fits in the range
    if(number > 32767)
        number = 32767;
    else if(number < (-32767 - 1))
        number = (-32767 - 1);

    int16ToLeBytes((int16_t)number, bytes, index);
}


/*!
 * Encode a uint32_t on a byte stream by integer scaling to fit in 1 unsigned
 * byte.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 1 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void uint32ScaledTo1UnsignedBytes(uint32_t value, uint8_t* bytes, int* index, int32_t min, uint32_t scaler)
{
    // scale the number
    uint32_t number = 0;

    // Make sure number fits in the range
    if(((int32_t)value) > min)
    {
        number = (uint32_t)((value - min)*scaler);
        if(number > 255u)
            number = 255u;
    }

    uint8ToBytes((uint8_t)number, bytes, index);
}


/*!
 * Encode a uint32_t on a byte stream by integer scaling to fit in 1 signed
 * byte.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 1 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void uint32ScaledTo1SignedBytes(uint32_t value, uint8_t* bytes, int* index, uint32_t scaler)
{
    // scale the number
    int32_t number = (int32_t)(value*scaler);

    // Make sure number fits in the range
    if(number > 127)
        number = 127;
    else if(number < (-127 - 1))
        number = (-127 - 1);

    int8ToBytes((int8_t)number, bytes, index);
}


/*!
 * Scale a int32_t using integer scaling to the base integer type used for
 * bitfields.
 * \param value is the number to scale.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer.
 * \param bits is the number of bits in the bitfield, used to limit the returned value.
 * \return (value-min)*scaler.
 */
unsigned int int32ScaledToBitfield(int32_t value, int32_t min, uint32_t scaler, int bits)
{
    // The largest integer the bitfield can hold
    unsigned int max = (0x1u << bits) - 1;

    // Scale the number
    unsigned int number = (unsigned int)((value - min)*scaler);

    // Protect from underflow
    if(((int32_t)value) < min)
        return 0;

    // Protect from overflow
    if(number > max)
        return max;

    return number;
}


/*!
 * Encode a int32_t on a byte stream by integer scaling to fit in 4 unsigned
 * bytes in big endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 4 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void int32ScaledTo4UnsignedBeBytes(int32_t value, uint8_t* bytes, int* index, int32_t min, uint32_t scaler)
{
    // scale the number
    uint32_t number = 0;

    // Make sure number fits in the range
    if(((int32_t)value) > min)
    {
        number = (uint32_t)((value - min)*scaler);
    }

    uint32ToBeBytes(number, bytes, index);
}


/*!
 * Encode a int32_t on a byte stream by integer scaling to fit in 4 unsigned
 * bytes in little endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 4 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void int32ScaledTo4UnsignedLeBytes(int32_t value, uint8_t* bytes, int* index, int32_t min, uint32_t scaler)
{
    // scale the number
    uint32_t number = 0;

    // Make sure number fits in the range
    if(((int32_t)value) > min)
    {
        number = (uint32_t)((value - min)*scaler);
    }

    uint32ToLeBytes(number, bytes, index);
}


/*!
 * Encode a int32_t on a byte stream by integer scaling to fit in 4 signed
 * bytes in big endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 4 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void int32ScaledTo4SignedBeBytes(int32_t value, uint8_t* bytes, int* index, uint32_t scaler)
{
    // scale the number
    int32_t number = (int32_t)(value*scaler);

    int32ToBeBytes(number, bytes, index);
}


/*!
 * Encode a int32_t on a byte stream by integer scaling to fit in 4 signed
 * bytes in little endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 4 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void int32ScaledTo4SignedLeBytes(int32_t value, uint8_t* bytes, int* index, uint32_t scaler)
{
    // scale the number
    int32_t number = (int32_t)(value*scaler);

    int32ToLeBytes(number, bytes, index);
}


/*!
 * Encode a int32_t on a byte stream by integer scaling to fit in 3 unsigned
 * bytes in big endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 3 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void int32ScaledTo3UnsignedBeBytes(int32_t value, uint8_t* bytes, int* index, int32_t min, uint32_t scaler)
{
    // scale the number
    uint32_t number = 0;

    // Make sure number fits in the range
    if(((int32_t)value) > min)
    {
        number = (uint32_t)((value - min)*scaler);
        if(number > 16777215ul)
            number = 16777215ul;
    }

    uint24ToBeBytes((uint32_t)number, bytes, index);
}


/*!
 * Encode a int32_t on a byte stream by integer scaling to fit in 3 unsigned
 * bytes in little endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 3 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void int32ScaledTo3UnsignedLeBytes(int32_t value, uint8_t* bytes, int* index, int32_t min, uint32_t scaler)
{
    // scale the number
    uint32_t number = 0;

    // Make sure number fits in the range
    if(((int32_t)value) > min)
    {
        number = (uint32_t)((value - min)*scaler);
        if(number > 16777215ul)
            number = 16777215ul;
    }

    uint24ToLeBytes((uint32_t)number, bytes, index);
}


/*!
 * Encode a int32_t on a byte stream by integer scaling to fit in 3 signed
 * bytes in big endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 3 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void int32ScaledTo3SignedBeBytes(int32_t value, uint8_t* bytes, int* index, uint32_t scaler)
{
    // scale the number
    int32_t number = (int32_t)(value*scaler);

    // Make sure number fits in the range
    if(number > 8388607l)
        number = 8388607l;
    else if(number < (-8388607l - 1))
        number = (-8388607l - 1);

    int24ToBeBytes((int32_t)number, bytes, index);
}


/*!
 * Encode a int32_t on a byte stream by integer scaling to fit in 3 signed
 * bytes in little endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 3 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void int32ScaledTo3SignedLeBytes(int32_t value, uint8_t* bytes, int* index, uint32_t scaler)
{
    // scale the number
    int32_t number = (int32_t)(value*scaler);

    // Make sure number fits in the range
    if(number > 8388607l)
        number = 8388607l;
    else if(number < (-8388607l - 1))
        number = (-8388607l - 1);

    int24ToLeBytes((int32_t)number, bytes, index);
}


/*!
 * Encode a int32_t on a byte stream by integer scaling to fit in 2 unsigned
 * bytes in big endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void int32ScaledTo2UnsignedBeBytes(int32_t value, uint8_t* bytes, int* index, int32_t min, uint32_t scaler)
{
    // scale the number
    uint32_t number = 0;

    // Make sure number fits in the range
    if(((int32_t)value) > min)
    {
        number = (uint32_t)((value - min)*scaler);
        if(number > 65535u)
            number = 65535u;
    }

    uint16ToBeBytes((uint16_t)number, bytes, index);
}


/*!
 * Encode a int32_t on a byte stream by integer scaling to fit in 2 unsigned
 * bytes in little endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void int32ScaledTo2UnsignedLeBytes(int32_t value, uint8_t* bytes, int* index, int32_t min, uint32_t scaler)
{
    // scale the number
    uint32_t number = 0;

    // Make sure number fits in the range
    if(((int32_t)value) > min)
    {
        number = (uint32_t)((value - min)*scaler);
        if(number > 65535u)
            number = 65535u;
    }

    uint16ToLeBytes((uint16_t)number, bytes, index);
}


/*!
 * Encode a int32_t on a byte stream by integer scaling to fit in 2 signed
 * bytes in big endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void int32ScaledTo2SignedBeBytes(int32_t value, uint8_t* bytes, int* index, uint32_t scaler)
{
    // scale the number
    int32_t number = (int32_t)(value*scaler);

    // Make sure number fits in the range
    if(number > 32767)
        number = 32767;
    else if(number < (-32767 - 1))
        number = (-32767 - 1);

    int16ToBeBytes((int16_t)number, bytes, index);
}


/*!
 * Encode a int32_t on a byte stream by integer scaling to fit in 2 signed
 * bytes in little endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void int32ScaledTo2SignedLeBytes(int32_t value, uint8_t* bytes, int* index, uint32_t scaler)
{
    // scale the number
    int32_t number = (int32_t)(value*scaler);

    // Make sure number fits in the range
    if(number > 32767)
        number = 32767;
    else if(number < (-32767 - 1))
        number = (-32767 - 1);

    int16ToLeBytes((int16_t)number, bytes, index);
}


/*!
 * Encode a int32_t on a byte stream by integer scaling to fit in 1 unsigned
 * byte.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 1 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void int32ScaledTo1UnsignedBytes(int32_t value, uint8_t* bytes, int* index, int32_t min, uint32_t scaler)
{
    // scale the number
    uint32_t number = 0;

    // Make sure number fits in the range
    if(((int32_t)value) > min)
    {
        number = (uint32_t)((value - min)*scaler);
        if(number > 255u)
            number = 255u;
    }

    uint8ToBytes((uint8_t)number, bytes, index);
}


/*!
 * Encode a int32_t on a byte stream by integer scaling to fit in 1 signed
 * byte.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 1 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void int32ScaledTo1SignedBytes(int32_t value, uint8_t* bytes, int* index, uint32_t scaler)
{
    // scale the number
    int32_t number = (int32_t)(value*scaler);

    // Make sure number fits in the range
    if(number > 127)
        number = 127;
    else if(number < (-127 - 1))
        number = (-127 - 1);

    int8ToBytes((int8_t)number, bytes, index);
}


/*!
 * Scale a uint16_t using integer scaling to the base integer type used for
 * bitfields.
 * \param value is the number to scale.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer.
 * \param bits is the number of bits in the bitfield, used to limit the returned value.
 * \return (value-min)*scaler.
 */
unsigned int uint16ScaledToBitfield(uint16_t value, int16_t min, uint16_t scaler, int bits)
{
    // The largest integer the bitfield can hold
    unsigned int max = (0x1u << bits) - 1;

    // Scale the number
    unsigned int number = (unsigned int)((value - min)*scaler);

    // Protect from underflow
    if(((int32_t)value) < min)
        return 0;

    // Protect from overflow
    if(number > max)
        return max;

    return number;
}


/*!
 * Encode a uint16_t on a byte stream by integer scaling to fit in 2 unsigned
 * bytes in big endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void uint16ScaledTo2UnsignedBeBytes(uint16_t value, uint8_t* bytes, int* index, int16_t min, uint16_t scaler)
{
    // scale the number
    uint16_t number = 0;

    // Make sure number fits in the range
    if(((int16_t)value) > min)
    {
        number = (uint16_t)((value - min)*scaler);
    }

    uint16ToBeBytes(number, bytes, index);
}


/*!
 * Encode a uint16_t on a byte stream by integer scaling to fit in 2 unsigned
 * bytes in little endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void uint16ScaledTo2UnsignedLeBytes(uint16_t value, uint8_t* bytes, int* index, int16_t min, uint16_t scaler)
{
    // scale the number
    uint16_t number = 0;

    // Make sure number fits in the range
    if(((int16_t)value) > min)
    {
        number = (uint16_t)((value - min)*scaler);
    }

    uint16ToLeBytes(number, bytes, index);
}


/*!
 * Encode a uint16_t on a byte stream by integer scaling to fit in 2 signed
 * bytes in big endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void uint16ScaledTo2SignedBeBytes(uint16_t value, uint8_t* bytes, int* index, uint16_t scaler)
{
    // scale the number
    int16_t number = (int16_t)(value*scaler);

    int16ToBeBytes(number, bytes, index);
}


/*!
 * Encode a uint16_t on a byte stream by integer scaling to fit in 2 signed
 * bytes in little endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void uint16ScaledTo2SignedLeBytes(uint16_t value, uint8_t* bytes, int* index, uint16_t scaler)
{
    // scale the number
    int16_t number = (int16_t)(value*scaler);

    int16ToLeBytes(number, bytes, index);
}


/*!
 * Encode a uint16_t on a byte stream by integer scaling to fit in 1 unsigned
 * byte.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 1 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void uint16ScaledTo1UnsignedBytes(uint16_t value, uint8_t* bytes, int* index, int16_t min, uint16_t scaler)
{
    // scale the number
    uint16_t number = 0;

    // Make sure number fits in the range
    if(((int16_t)value) > min)
    {
        number = (uint16_t)((value - min)*scaler);
        if(number > 255u)
            number = 255u;
    }

    uint8ToBytes((uint8_t)number, bytes, index);
}


/*!
 * Encode a uint16_t on a byte stream by integer scaling to fit in 1 signed
 * byte.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 1 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void uint16ScaledTo1SignedBytes(uint16_t value, uint8_t* bytes, int* index, uint16_t scaler)
{
    // scale the number
    int16_t number = (int16_t)(value*scaler);

    // Make sure number fits in the range
    if(number > 127)
        number = 127;
    else if(number < (-127 - 1))
        number = (-127 - 1);

    int8ToBytes((int8_t)number, bytes, index);
}


/*!
 * Scale a int16_t using integer scaling to the base integer type used for
 * bitfields.
 * \param value is the number to scale.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer.
 * \param bits is the number of bits in the bitfield, used to limit the returned value.
 * \return (value-min)*scaler.
 */
unsigned int int16ScaledToBitfield(int16_t value, int16_t min, uint16_t scaler, int bits)
{
    // The largest integer the bitfield can hold
    unsigned int max = (0x1u << bits) - 1;

    // Scale the number
    unsigned int number = (unsigned int)((value - min)*scaler);

    // Protect from underflow
    if(((int32_t)value) < min)
        return 0;

    // Protect from overflow
    if(number > max)
        return max;

    return number;
}


/*!
 * Encode a int16_t on a byte stream by integer scaling to fit in 2 unsigned
 * bytes in big endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void int16ScaledTo2UnsignedBeBytes(int16_t value, uint8_t* bytes, int* index, int16_t min, uint16_t scaler)
{
    // scale the number
    uint16_t number = 0;

    // Make sure number fits in the range
    if(((int16_t)value) > min)
    {
        number = (uint16_t)((value - min)*scaler);
    }

    uint16ToBeBytes(number, bytes, index);
}


/*!
 * Encode a int16_t on a byte stream by integer scaling to fit in 2 unsigned
 * bytes in little endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void int16ScaledTo2UnsignedLeBytes(int16_t value, uint8_t* bytes, int* index, int16_t min, uint16_t scaler)
{
    // scale the number
    uint16_t number = 0;

    // Make sure number fits in the range
    if(((int16_t)value) > min)
    {
        number = (uint16_t)((value - min)*scaler);
    }

    uint16ToLeBytes(number, bytes, index);
}


/*!
 * Encode a int16_t on a byte stream by integer scaling to fit in 2 signed
 * bytes in big endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void int16ScaledTo2SignedBeBytes(int16_t value, uint8_t* bytes, int* index, uint16_t scaler)
{
    // scale the number
    int16_t number = (int16_t)(value*scaler);

    int16ToBeBytes(number, bytes, index);
}


/*!
 * Encode a int16_t on a byte stream by integer scaling to fit in 2 signed
 * bytes in little endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void int16ScaledTo2SignedLeBytes(int16_t value, uint8_t* bytes, int* index, uint16_t scaler)
{
    // scale the number
    int16_t number = (int16_t)(value*scaler);

    int16ToLeBytes(number, bytes, index);
}


/*!
 * Encode a int16_t on a byte stream by integer scaling to fit in 1 unsigned
 * byte.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 1 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void int16ScaledTo1UnsignedBytes(int16_t value, uint8_t* bytes, int* index, int16_t min, uint16_t scaler)
{
    // scale the number
    uint16_t number = 0;

    // Make sure number fits in the range
    if(((int16_t)value) > min)
    {
        number = (uint16_t)((value - min)*scaler);
        if(number > 255u)
            number = 255u;
    }

    uint8ToBytes((uint8_t)number, bytes, index);
}


/*!
 * Encode a int16_t on a byte stream by integer scaling to fit in 1 signed
 * byte.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 1 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void int16ScaledTo1SignedBytes(int16_t value, uint8_t* bytes, int* index, uint16_t scaler)
{
    // scale the number
    int16_t number = (int16_t)(value*scaler);

    // Make sure number fits in the range
    if(number > 127)
        number = 127;
    else if(number < (-127 - 1))
        number = (-127 - 1);

    int8ToBytes((int8_t)number, bytes, index);
}


/*!
 * Scale a uint8_t using integer scaling to the base integer type used for
 * bitfields.
 * \param value is the number to scale.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer.
 * \param bits is the number of bits in the bitfield, used to limit the returned value.
 * \return (value-min)*scaler.
 */
unsigned int uint8ScaledToBitfield(uint8_t value, int8_t min, uint8_t scaler, int bits)
{
    // The largest integer the bitfield can hold
    unsigned int max = (0x1u << bits) - 1;

    // Scale the number
    unsigned int number = (unsigned int)((value - min)*scaler);

    // Protect from underflow
    if(((int32_t)value) < min)
        return 0;

    // Protect from overflow
    if(number > max)
        return max;

    return number;
}


/*!
 * Encode a uint8_t on a byte stream by integer scaling to fit in 1 unsigned
 * byte.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 1 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void uint8ScaledTo1UnsignedBytes(uint8_t value, uint8_t* bytes, int* index, int8_t min, uint8_t scaler)
{
    // scale the number
    uint8_t number = 0;

    // Make sure number fits in the range
    if(((int8_t)value) > min)
    {
        number = (uint8_t)((value - min)*scaler);
    }

    uint8ToBytes(number, bytes, index);
}


/*!
 * Encode a uint8_t on a byte stream by integer scaling to fit in 1 signed
 * byte.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 1 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void uint8ScaledTo1SignedBytes(uint8_t value, uint8_t* bytes, int* index, uint8_t scaler)
{
    // scale the number
    int8_t number = (int8_t)(value*scaler);

    int8ToBytes(number, bytes, index);
}


/*!
 * Scale a int8_t using integer scaling to the base integer type used for
 * bitfields.
 * \param value is the number to scale.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer.
 * \param bits is the number of bits in the bitfield, used to limit the returned value.
 * \return (value-min)*scaler.
 */
unsigned int int8ScaledToBitfield(int8_t value, int8_t min, uint8_t scaler, int bits)
{
    // The largest integer the bitfield can hold
    unsigned int max = (0x1u << bits) - 1;

    // Scale the number
    unsigned int number = (unsigned int)((value - min)*scaler);

    // Protect from underflow
    if(((int32_t)value) < min)
        return 0;

    // Protect from overflow
    if(number > max)
        return max;

    return number;
}


/*!
 * Encode a int8_t on a byte stream by integer scaling to fit in 1 unsigned
 * byte.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 1 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void int8ScaledTo1UnsignedBytes(int8_t value, uint8_t* bytes, int* index, int8_t min, uint8_t scaler)
{
    // scale the number
    uint8_t number = 0;

    // Make sure number fits in the range
    if(((int8_t)value) > min)
    {
        number = (uint8_t)((value - min)*scaler);
    }

    uint8ToBytes(number, bytes, index);
}


/*!
 * Encode a int8_t on a byte stream by integer scaling to fit in 1 signed byte.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 1 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void int8ScaledTo1SignedBytes(int8_t value, uint8_t* bytes, int* index, uint8_t scaler)
{
    // scale the number
    int8_t number = (int8_t)(value*scaler);

    int8ToBytes(number, bytes, index);
}


// end of scaledencode.c
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               // scaledencode.h was generated by ProtoGen version 3.5.c

/*
 * This file is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This file is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Author: Oliver Walters / Currawong Engineering Pty Ltd
 */

#ifndef _SCALEDENCODE_H
#define _SCALEDENCODE_H

// Language target is C, C++ compilers: don't mangle us
#ifdef __cplusplus
extern "C" {
#endif

/*!
 * \file
 * scaledencode routines place scaled numbers into a byte stream.
 * 
 * scaledencode routines place scaled values into a big or little endian byte
 * stream. The values can be any legitimate type (double, float, uint32_t,
 * uint16_t, uint8_t, int32_t, int16_t, int8_t), and are encoded as either a
 * unsigned or signed integer from 1 to 8 bytes in length. Unsigned encodings
 * allow the caller to specify a minimum and a maximum value, with the only
 * limitation that the maximum value must be more than the minimum. Signed
 * encodings only allow the caller to specify a maximum value which gives
 * maximum absolute value that can be encoded.
 * 
 * An example encoding would be: take a float that represents speed in meters
 * per second and encode it in two bytes from -200 to 200 meters per second. In
 * that example the encoding function would be:
 * 
 * float32ScaledTo2SignedBeBytes(speed, bytestream, &index, 200);
 * 
 * This would scale the speed according to (32767/200), and copy the resulting
 * two bytes to bytestream[index] as a signed 16 bit number in big endian
 * order. This would result in a velocity resolution of 0.006 m/s.
 * 
 * Another example encoding is: take a double that represents altitude in
 * meters and encode it in three bytes from -1000 to 49000 meters:
 * 
 * float64ScaledTo3UnsignedLeBytes(alt, bytestream, &index, -1000, 49000);
 * 
 * This would transform the altitude according to (alt *(16777215/50000) +
 * 1000) and copy the resulting three bytes to bytestream[index] as an unsigned
 * 24 bit number in little endian order. This would result in an altitude
 * resolution of 0.003 meters.
 * 
 * scaledencode does not include routines that increase the resolution of the
 * inmemory value. For example the function floatScaledTo5UnsignedBeBytes()
 * does not exist, because expanding a float to 5 bytes does not make any
 * resolution improvement over encoding it in 4 bytes. In general the encoded
 * format must be equal to or less than the number of bytes of the raw data.
 * 
 * Code generation for this module was affected by these global flags:
 * 
 * - 64-bit integers are not supported.
 * 
 * - Normal bitfields are supported, long bitfields are not.
 * 
 * - Double precision floating points are not supported.
 */

#define __STDC_CONSTANT_MACROS
#include <stdint.h>
#include <stdbool.h>


//! Scale a float using floating point scaling to the base integer type used for bitfields.
unsigned int float32ScaledToBitfield(float value, float min, float scaler, int bits);

//! Encode a float on a byte stream by floating point scaling to fit in 4 unsigned bytes in big endian order.
void float32ScaledTo4UnsignedBeBytes(float value, uint8_t* bytes, int* index, float min, float scaler);

//! Encode a float on a byte stream by floating point scaling to fit in 4 unsigned bytes in little endian order.
void float32ScaledTo4UnsignedLeBytes(float value, uint8_t* bytes, int* index, float min, float scaler);

//! Encode a float on a byte stream by floating point scaling to fit in 4 signed bytes in big endian order.
void float32ScaledTo4SignedBeBytes(float value, uint8_t* bytes, int* index, float scaler);

//! Encode a float on a byte stream by floating point scaling to fit in 4 signed bytes in little endian order.
void float32ScaledTo4SignedLeBytes(float value, uint8_t* bytes, int* index, float scaler);

//! Encode a float on a byte stream by floating point scaling to fit in 3 unsigned bytes in big endian order.
void float32ScaledTo3UnsignedBeBytes(float value, uint8_t* bytes, int* index, float min, float scaler);

//! Encode a float on a byte stream by floating point scaling to fit in 3 unsigned bytes in little endian order.
void float32ScaledTo3UnsignedLeBytes(float value, uint8_t* bytes, int* index, float min, float scaler);

//! Encode a float on a byte stream by floating point scaling to fit in 3 signed bytes in big endian order.
void float32ScaledTo3SignedBeBytes(float value, uint8_t* bytes, int* index, float scaler);

//! Encode a float on a byte stream by floating point scaling to fit in 3 signed bytes in little endian order.
void float32ScaledTo3SignedLeBytes(float value, uint8_t* bytes, int* index, float scaler);

//! Encode a float on a byte stream by floating point scaling to fit in 2 unsigned bytes in big endian order.
void float32ScaledTo2UnsignedBeBytes(float value, uint8_t* bytes, int* index, float min, float scaler);

//! Encode a float on a byte stream by floating point scaling to fit in 2 unsigned bytes in little endian order.
void float32ScaledTo2UnsignedLeBytes(float value, uint8_t* bytes, int* index, float min, float scaler);

//! Encode a float on a byte stream by floating point scaling to fit in 2 signed bytes in big endian order.
void float32ScaledTo2SignedBeBytes(float value, uint8_t* bytes, int* index, float scaler);

//! Encode a float on a byte stream by floating point scaling to fit in 2 signed bytes in little endian order.
void float32ScaledTo2SignedLeBytes(float value, uint8_t* bytes, int* index, float scaler);

//! Encode a float on a byte stream by floating point scaling to fit in 1 unsigned byte.
void float32ScaledTo1UnsignedBytes(float value, uint8_t* bytes, int* index, float min, float scaler);

//! Encode a float on a byte stream by floating point scaling to fit in 1 signed byte.
void float32ScaledTo1SignedBytes(float value, uint8_t* bytes, int* index, float scaler);

//! Scale a uint32_t using integer scaling to the base integer type used for bitfields.
unsigned int uint32ScaledToBitfield(uint32_t value, int32_t min, uint32_t scaler, int bits);

//! Encode a uint32_t on a byte stream by integer scaling to fit in 4 unsigned bytes in big endian order.
void uint32ScaledTo4UnsignedBeBytes(uint32_t value, uint8_t* bytes, int* index, int32_t min, uint32_t scaler);

//! Encode a uint32_t on a byte stream by integer scaling to fit in 4 unsigned bytes in little endian order.
void uint32ScaledTo4UnsignedLeBytes(uint32_t value, uint8_t* bytes, int* index, int32_t min, uint32_t scaler);

//! Encode a uint32_t on a byte stream by integer scaling to fit in 4 signed bytes in big endian order.
void uint32ScaledTo4SignedBeBytes(uint32_t value, uint8_t* bytes, int* index, uint32_t scaler);

//! Encode a uint32_t on a byte stream by integer scaling to fit in 4 signed bytes in little endian order.
void uint32ScaledTo4SignedLeBytes(uint32_t value, uint8_t* bytes, int* index, uint32_t scaler);

//! Encode a uint32_t on a byte stream by integer scaling to fit in 3 unsigned bytes in big endian order.
void uint32ScaledTo3UnsignedBeBytes(uint32_t value, uint8_t* bytes, int* index, int32_t min, uint32_t scaler);

//! Encode a uint32_t on a byte stream by integer scaling to fit in 3 unsigned bytes in little endian order.
void uint32ScaledTo3UnsignedLeBytes(uint32_t value, uint8_t* bytes, int* index, int32_t min, uint32_t scaler);

//! Encode a uint32_t on a byte stream by integer scaling to fit in 3 signed bytes in big endian order.
void uint32ScaledTo3SignedBeBytes(uint32_t value, uint8_t* bytes, int* index, uint32_t scaler);

//! Encode a uint32_t on a byte stream by integer scaling to fit in 3 signed bytes in little endian order.
void uint32ScaledTo3SignedLeBytes(uint32_t value, uint8_t* bytes, int* index, uint32_t scaler);

//! Encode a uint32_t on a byte stream by integer scaling to fit in 2 unsigned bytes in big endian order.
void uint32ScaledTo2UnsignedBeBytes(uint32_t value, uint8_t* bytes, int* index, int32_t min, uint32_t scaler);

//! Encode a uint32_t on a byte stream by integer scaling to fit in 2 unsigned bytes in little endian order.
void uint32ScaledTo2UnsignedLeBytes(uint32_t value, uint8_t* bytes, int* index, int32_t min, uint32_t scaler);

//! Encode a uint32_t on a byte stream by integer scaling to fit in 2 signed bytes in big endian order.
void uint32ScaledTo2SignedBeBytes(uint32_t value, uint8_t* bytes, int* index, uint32_t scaler);

//! Encode a uint32_t on a byte stream by integer scaling to fit in 2 signed bytes in little endian order.
void uint32ScaledTo2SignedLeBytes(uint32_t value, uint8_t* bytes, int* index, uint32_t scaler);

//! Encode a uint32_t on a byte stream by integer scaling to fit in 1 unsigned byte.
void uint32ScaledTo1UnsignedBytes(uint32_t value, uint8_t* bytes, int* index, int32_t min, uint32_t scaler);

//! Encode a uint32_t on a byte stream by integer scaling to fit in 1 signed byte.
void uint32ScaledTo1SignedBytes(uint32_t value, uint8_t* bytes, int* index, uint32_t scaler);

//! Scale a int32_t using integer scaling to the base integer type used for bitfields.
unsigned int int32ScaledToBitfield(int32_t value, int32_t min, uint32_t scaler, int bits);

//! Encode a int32_t on a byte stream by integer scaling to fit in 4 unsigned bytes in big endian order.
void int32ScaledTo4UnsignedBeBytes(int32_t value, uint8_t* bytes, int* index, int32_t min, uint32_t scaler);

//! Encode a int32_t on a byte stream by integer scaling to fit in 4 unsigned bytes in little endian order.
void int32ScaledTo4UnsignedLeBytes(int32_t value, uint8_t* bytes, int* index, int32_t min, uint32_t scaler);

//! Encode a int32_t on a byte stream by integer scaling to fit in 4 signed bytes in big endian order.
void int32ScaledTo4SignedBeBytes(int32_t value, uint8_t* bytes, int* index, uint32_t scaler);

//! Encode a int32_t on a byte stream by integer scaling to fit in 4 signed bytes in little endian order.
void int32ScaledTo4SignedLeBytes(int32_t value, uint8_t* bytes, int* index, uint32_t scaler);

//! Encode a int32_t on a byte stream by integer scaling to fit in 3 unsigned bytes in big endian order.
void int32ScaledTo3UnsignedBeBytes(int32_t value, uint8_t* bytes, int* index, int32_t min, uint32_t scaler);

//! Encode a int32_t on a byte stream by integer scaling to fit in 3 unsigned bytes in little endian order.
void int32ScaledTo3UnsignedLeBytes(int32_t value, uint8_t* bytes, int* index, int32_t min, uint32_t scaler);

//! Encode a int32_t on a byte stream by integer scaling to fit in 3 signed bytes in big endian order.
void int32ScaledTo3SignedBeBytes(int32_t value, uint8_t* bytes, int* index, uint32_t scaler);

//! Encode a int32_t on a byte stream by integer scaling to fit in 3 signed bytes in little endian order.
void int32ScaledTo3SignedLeBytes(int32_t value, uint8_t* bytes, int* index, uint32_t scaler);

//! Encode a int32_t on a byte stream by integer scaling to fit in 2 unsigned bytes in big endian order.
void int32ScaledTo2UnsignedBeBytes(int32_t value, uint8_t* bytes, int* index, int32_t min, uint32_t scaler);

//! Encode a int32_t on a byte stream by integer scaling to fit in 2 unsigned bytes in little endian order.
void int32ScaledTo2UnsignedLeBytes(int32_t value, uint8_t* bytes, int* index, int32_t min, uint32_t scaler);

//! Encode a int32_t on a byte stream by integer scaling to fit in 2 signed bytes in big endian order.
void int32ScaledTo2SignedBeBytes(int32_t value, uint8_t* bytes, int* index, uint32_t scaler);

//! Encode a int32_t on a byte stream by integer scaling to fit in 2 signed bytes in little endian order.
void int32ScaledTo2SignedLeBytes(int32_t value, uint8_t* bytes, int* index, uint32_t scaler);

//! Encode a int32_t on a byte stream by integer scaling to fit in 1 unsigned byte.
void int32ScaledTo1UnsignedBytes(int32_t value, uint8_t* bytes, int* index, int32_t min, uint32_t scaler);

//! Encode a int32_t on a byte stream by integer scaling to fit in 1 signed byte.
void int32ScaledTo1SignedBytes(int32_t value, uint8_t* bytes, int* index, uint32_t scaler);

//! Scale a uint16_t using integer scaling to the base integer type used for bitfields.
unsigned int uint16ScaledToBitfield(uint16_t value, int16_t min, uint16_t scaler, int bits);

//! Encode a uint16_t on a byte stream by integer scaling to fit in 2 unsigned bytes in big endian order.
void uint16ScaledTo2UnsignedBeBytes(uint16_t value, uint8_t* bytes, int* index, int16_t min, uint16_t scaler);

//! Encode a uint16_t on a byte stream by integer scaling to fit in 2 unsigned bytes in little endian order.
void uint16ScaledTo2UnsignedLeBytes(uint16_t value, uint8_t* bytes, int* index, int16_t min, uint16_t scaler);

//! Encode a uint16_t on a byte stream by integer scaling to fit in 2 signed bytes in big endian order.
void uint16ScaledTo2SignedBeBytes(uint16_t value, uint8_t* bytes, int* index, uint16_t scaler);

//! Encode a uint16_t on a byte stream by integer scaling to fit in 2 signed bytes in little endian order.
void uint16ScaledTo2SignedLeBytes(uint16_t value, uint8_t* bytes, int* index, uint16_t scaler);

//! Encode a uint16_t on a byte stream by integer scaling to fit in 1 unsigned byte.
void uint16ScaledTo1UnsignedBytes(uint16_t value, uint8_t* bytes, int* index, int16_t min, uint16_t scaler);

//! Encode a uint16_t on a byte stream by integer scaling to fit in 1 signed byte.
void uint16ScaledTo1SignedBytes(uint16_t value, uint8_t* bytes, int* index, uint16_t scaler);

//! Scale a int16_t using integer scaling to the base integer type used for bitfields.
unsigned int int16ScaledToBitfield(int16_t value, int16_t min, uint16_t scaler, int bits);

//! Encode a int16_t on a byte stream by integer scaling to fit in 2 unsigned bytes in big endian order.
void int16ScaledTo2UnsignedBeBytes(int16_t value, uint8_t* bytes, int* index, int16_t min, uint16_t scaler);

//! Encode a int16_t on a byte stream by integer scaling to fit in 2 unsigned bytes in little endian order.
void int16ScaledTo2UnsignedLeBytes(int16_t value, uint8_t* bytes, int* index, int16_t min, uint16_t scaler);

//! Encode a int16_t on a byte stream by integer scaling to fit in 2 signed bytes in big endian order.
void int16ScaledTo2SignedBeBytes(int16_t value, uint8_t* bytes, int* index, uint16_t scaler);

//! Encode a int16_t on a byte stream by integer scaling to fit in 2 signed bytes in little endian order.
void int16ScaledTo2SignedLeBytes(int16_t value, uint8_t* bytes, int* index, uint16_t scaler);

//! Encode a int16_t on a byte stream by integer scaling to fit in 1 unsigned byte.
void int16ScaledTo1UnsignedBytes(int16_t value, uint8_t* bytes, int* index, int16_t min, uint16_t scaler);

//! Encode a int16_t on a byte stream by integer scaling to fit in 1 signed byte.
void int16ScaledTo1SignedBytes(int16_t value, uint8_t* bytes, int* index, uint16_t scaler);

//! Scale a uint8_t using integer scaling to the base integer type used for bitfields.
unsigned int uint8ScaledToBitfield(uint8_t value, int8_t min, uint8_t scaler, int bits);

//! Encode a uint8_t on a byte stream by integer scaling to fit in 1 unsigned byte.
void uint8ScaledTo1UnsignedBytes(uint8_t value, uint8_t* bytes, int* index, int8_t min, uint8_t scaler);

//! Encode a uint8_t on a byte stream by integer scaling to fit in 1 signed byte.
void uint8ScaledTo1SignedBytes(uint8_t value, uint8_t* bytes, int* index, uint8_t scaler);

//! Scale a int8_t using integer scaling to the base integer type used for bitfields.
unsigned int int8ScaledToBitfield(int8_t value, int8_t min, uint8_t scaler, int bits);

//! Encode a int8_t on a byte stream by integer scaling to fit in 1 unsigned byte.
void int8ScaledTo1UnsignedBytes(int8_t value, uint8_t* bytes, int* index, int8_t min, uint8_t scaler);

//! Encode a int8_t on a byte stream by integer scaling to fit in 1 signed byte.
void int8ScaledTo1SignedBytes(int8_t value, uint8_t* bytes, int* index, uint8_t scaler);

#ifdef __cplusplus
}
#endif
#endif // _SCALEDENCODE_H
                 /*
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include "AP_Proximity.h"

#if HAL_PROXIMITY_ENABLED
#include "AP_Proximity_Backend.h"
#include "AP_Proximity_RPLidarA2.h"
#include "AP_Proximity_TeraRangerTower.h"
#include "AP_Proximity_TeraRangerTowerEvo.h"
#include "AP_Proximity_RangeFinder.h"
#include "AP_Proximity_MAV.h"
#include "AP_Proximity_LightWareSF40C.h"
#include "AP_Proximity_LightWareSF45B.h"
#include "AP_Proximity_SITL.h"
#include "AP_Proximity_AirSimSITL.h"
#include "AP_Proximity_Cygbot_D1.h"
#include "AP_Proximity_DroneCAN.h"
#include "AP_Proximity_Scripting.h"
#include "AP_Proximity_LD06.h"
#include "AP_Proximity_MR72_CAN.h"


#include <AP_Logger/AP_Logger.h>

extern const AP_HAL::HAL &hal;

// table of user settable parameters
const AP_Param::GroupInfo AP_Proximity::var_info[] = {
    // 0 is reserved for possible addition of an ENABLED parameter

    // 1 was _TYPE
    // 2 was _ORIENT
    // 3 was _YAW_CORR
    // 4 to 15 was _IGN_ANG1 to _IGN_WID6

    // @Param{Copter}: _IGN_GND
    // @DisplayName: Proximity sensor land detection
    // @Description: Ignore proximity data that is within 1 meter of the ground below the vehicle. This requires a downward facing rangefinder
    // @Values: 0:Disabled, 1:Enabled
    // @User: Standard
    AP_GROUPINFO_FRAME("_IGN_GND", 16, AP_Proximity, _ign_gnd_enable, 0, AP_PARAM_FRAME_COPTER | AP_PARAM_FRAME_HELI | AP_PARAM_FRAME_TRICOPTER),

    // @Param: _LOG_RAW
    // @DisplayName: Proximity raw distances log
    // @Description: Set this parameter to one if logging unfiltered(raw) distances from sensor should be enabled
    // @Values: 0:Off, 1:On
    // @User: Advanced
    AP_GROUPINFO("_LOG_RAW", 17, AP_Proximity, _raw_log_enable, 0),

    // @Param: _FILT
    // @DisplayName: Proximity filter cutoff frequency
    // @Description: Cutoff frequency for low pass filter applied to each face in the proximity boundary
    // @Units: Hz
    // @Range: 0 20
    // @User: Advanced
    AP_GROUPINFO("_FILT", 18, AP_Proximity, _filt_freq, 0.25f),

    // 19 was _MIN
    // 20 was _MAX

    // @Param{Copter}: _ALT_MIN
    // @DisplayName: Proximity lowest altitude.
    // @Description: Minimum altitude below which proximity should not work.
    // @Units: m
    // @Range: 0 10
    // @User: Advanced
    AP_GROUPINFO_FRAME("_ALT_MIN", 25, AP_Proximity, _alt_min, 1.0f, AP_PARAM_FRAME_COPTER | AP_PARAM_FRAME_HELI | AP_PARAM_FRAME_TRICOPTER),

    // @Group: 1
    // @Path: AP_Proximity_Params.cpp
    AP_SUBGROUPINFO(params[0], "1", 21, AP_Proximity, AP_Proximity_Params),

    // @Group: 1_
    // @Path: AP_Proximity_MR72_CAN.cpp
    AP_SUBGROUPVARPTR(drivers[0], "1_",  26, AP_Proximity, backend_var_info[0]),

#if PROXIMITY_MAX_INSTANCES > 1
    // @Group: 2
    // @Path: AP_Proximity_Params.cpp
    AP_SUBGROUPINFO(params[1], "2", 22, AP_Proximity, AP_Proximity_Params),

    // @Group: 2_
    // @Path: AP_Proximity_MR72_CAN.cpp
    AP_SUBGROUPVARPTR(drivers[1], "2_",  27, AP_Proximity, backend_var_info[1]),
#endif

#if PROXIMITY_MAX_INSTANCES > 2
    // @Group: 3
    // @Path: AP_Proximity_Params.cpp
    AP_SUBGROUPINFO(params[2], "3", 23, AP_Proximity, AP_Proximity_Params),

    // @Group: 3_
    // @Path: AP_Proximity_MR72_CAN.cpp
    AP_SUBGROUPVARPTR(drivers[2], "3_",  28, AP_Proximity, backend_var_info[2]),
#endif

#if PROXIMITY_MAX_INSTANCES > 3
    // @Group: 4
    // @Path: AP_Proximity_Params.cpp
    AP_SUBGROUPINFO(params[3], "4", 24, AP_Proximity, AP_Proximity_Params),

    // @Group: 4_
    // @Path: AP_Proximity_MR72_CAN.cpp
    AP_SUBGROUPVARPTR(drivers[3], "4_",  29, AP_Proximity, backend_var_info[3]),
#endif

    AP_GROUPEND
};

const AP_Param::GroupInfo *AP_Proximity::backend_var_info[PROXIMITY_MAX_INSTANCES];

AP_Proximity::AP_Proximity()
{
    AP_Param::setup_object_defaults(this, var_info);
#if CONFIG_HAL_BOARD == HAL_BOARD_SITL
    if (_singleton != nullptr) {
        AP_HAL::panic("AP_Proximity must be singleton");
    }
#endif // CONFIG_HAL_BOARD == HAL_BOARD_SITL
    _singleton = this;
}

// initialise the Proximity class. We do detection of attached sensors here
// we don't allow for hot-plugging of sensors (i.e. reboot required)
void AP_Proximity::init()
{
    if (num_instances != 0) {
        // init called a 2nd time?
        return;
    }

    // instantiate backends
    uint8_t serial_instance = 0;
    (void)serial_instance;  // in case no serial backends are compiled in
    for (uint8_t instance=0; instance<PROXIMITY_MAX_INSTANCES; instance++) {
        switch (get_type(instance)) {
        case Type::None:
            break;
#if AP_PROXIMITY_RPLIDARA2_ENABLED
        case Type::RPLidarA2:
            if (AP_Proximity_RPLidarA2::detect(serial_instance)) {
                state[instance].instance = instance;
                drivers[instance] = NEW_NOTHROW AP_Proximity_RPLidarA2(*this, state[instance], params[instance], serial_instance);
                serial_instance++;
            }
            break;
#endif
#if AP_PROXIMITY_MAV_ENABLED
        case Type::MAV:
            state[instance].instance = instance;
            drivers[instance] = NEW_NOTHROW AP_Proximity_MAV(*this, state[instance], params[instance]);
            break;
#endif
#if AP_PROXIMITY_TERARANGERTOWER_ENABLED
        case Type::TRTOWER:
            if (AP_Proximity_TeraRangerTower::detect(serial_instance)) {
                state[instance].instance = instance;
                drivers[instance] = NEW_NOTHROW AP_Proximity_TeraRangerTower(*this, state[instance], params[instance], serial_instance);
                serial_instance++;
            }
            break;
#endif
#if AP_PROXIMITY_TERARANGERTOWEREVO_ENABLED
        case Type::TRTOWEREVO:
            if (AP_Proximity_TeraRangerTowerEvo::detect(serial_instance)) {
                state[instance].instance = instance;
                drivers[instance] = NEW_NOTHROW AP_Proximity_TeraRangerTowerEvo(*this, state[instance], params[instance], serial_instance);
                serial_instance++;
            }
            break;
#endif
#if AP_PROXIMITY_RANGEFINDER_ENABLED
        case Type::RangeFinder:
            state[instance].instance = instance;
            drivers[instance] = NEW_NOTHROW AP_Proximity_RangeFinder(*this, state[instance], params[instance]);
            break;
#endif
#if AP_PROXIMITY_LIGHTWARE_SF40C_ENABLED
        case Type::SF40C:
            if (AP_Proximity_LightWareSF40C::detect(serial_instance)) {
                state[instance].instance = instance;
                drivers[instance] = NEW_NOTHROW AP_Proximity_LightWareSF40C(*this, state[instance], params[instance], serial_instance);
                serial_instance++;
            }
            break;
#endif
#if AP_PROXIMITY_LIGHTWARE_SF45B_ENABLED
        case Type::SF45B:
            if (AP_Proximity_LightWareSF45B::detect(serial_instance)) {
                state[instance].instance = instance;
                drivers[instance] = NEW_NOTHROW AP_Proximity_LightWareSF45B(*this, state[instance], params[instance], serial_instance);
                serial_instance++;
            }
            break;
#endif
#if AP_PROXIMITY_CYGBOT_ENABLED
        case Type::CYGBOT_D1:
        if (AP_Proximity_Cygbot_D1::detect(serial_instance)) {
            state[instance].instance = instance;
            drivers[instance] = NEW_NOTHROW AP_Proximity_Cygbot_D1(*this, state[instance], params[instance], serial_instance);
            serial_instance++;
        }
            break;
# endif
#if AP_PROXIMITY_DRONECAN_ENABLED
        case  Type::DroneCAN:
            num_instances = instance+1;
        break;
#endif
#if AP_PROXIMITY_SCRIPTING_ENABLED
        case Type::Scripting:
            state[instance].instance = instance;
            drivers[instance] = NEW_NOTHROW AP_Proximity_Scripting(*this, state[instance], params[instance]);
        break;
#endif
#if AP_PROXIMITY_MR72_ENABLED
        case Type::MR72:
            state[instance].instance = instance;
            drivers[instance] = NEW_NOTHROW AP_Proximity_MR72_CAN(*this, state[instance], params[instance]);
            break;
# endif
#if AP_PROXIMITY_SITL_ENABLED
        case Type::SITL:
            state[instance].instance = instance;
            drivers[instance] = NEW_NOTHROW AP_Proximity_SITL(*this, state[instance], params[instance]);
            break;
#endif
#if AP_PROXIMITY_AIRSIMSITL_ENABLED
        case Type::AirSimSITL:
            state[instance].instance = instance;
            drivers[instance] = NEW_NOTHROW AP_Proximity_AirSimSITL(*this, state[instance], params[instance]);
            break;
#endif
#if AP_PROXIMITY_LD06_ENABLED
        case Type::LD06:
            if (AP_Proximity_LD06::detect(serial_instance)) {
                state[instance].instance = instance;
                drivers[instance] = NEW_NOTHROW AP_Proximity_LD06(*this, state[instance], params[instance], serial_instance);
                serial_instance++;
            }
            break;
#endif
        }

        if (drivers[instance] != nullptr) {
            // we loaded a driver for this instance, so it must be
            // present (although it may not be healthy)
            num_instances = instance+1;
        }

        // initialise status
        state[instance].status = Status::NotConnected;

        // if the backend has some local parameters then make those available in the tree
        if (drivers[instance] && state[instance].var_info) {
            backend_var_info[instance] = state[instance].var_info;
            AP_Param::load_object_from_eeprom(drivers[instance], backend_var_info[instance]);
        }
    }
}

// update Proximity state for all instances. This should be called at a high rate by the main loop
void AP_Proximity::update()
{
    for (uint8_t i=0; i<num_instances; i++) {
        if (!valid_instance(i)) {
            continue;
        }
        drivers[i]->update();
    }

    // set boundary cutoff freq for low pass filter
    boundary.set_filter_freq(get_filter_freq());

    // check if any face has valid distance when it should not
    boundary.check_face_timeout();
}

AP_Proximity::Type AP_Proximity::get_type(uint8_t instance) const
{
    if (instance < PROXIMITY_MAX_INSTANCES) {
        return (Type)((uint8_t)params[instance].type);
    }
    return Type::None;
}

// return sensor health
AP_Proximity::Status AP_Proximity::get_instance_status(uint8_t instance) const
{
    // sanity check instance number
    if (!valid_instance(instance)) {
        return Status::NotConnected;
    }

    return state[instance].status;
}

// Returns status of first good sensor. If no good sensor found, returns status of last instance sensor
AP_Proximity::Status AP_Proximity::get_status() const
{
    Status sensors_status = Status::NotConnected;
    for (uint8_t i=0; i<num_instances; i++) {
        sensors_status = get_instance_status(i);
        if (sensors_status == Status::Good) {
            // return first good status
            return sensors_status;
        }
    }
    // no good sensor found
    return sensors_status;
}

// return proximity backend for Lua scripting
AP_Proximity_Backend *AP_Proximity::get_backend(uint8_t id) const
{
    if (!valid_instance(id)) {
        return nullptr;
    }
    return drivers[id];
}

// prearm checks
bool AP_Proximity::prearm_healthy(char *failure_msg, const uint8_t failure_msg_len) const
{
    for (uint8_t i=0; i<num_instances; i++) {
        switch (get_instance_status(i)) {
        case Status::NoData:
            hal.util->snprintf(failure_msg, failure_msg_len, "PRX%d: No Data", i + 1);
            return false;
        case Status::NotConnected:
            hal.util->snprintf(failure_msg, failure_msg_len, "PRX%d: Not Connected", i + 1);
            return false;
        case Status::Good:
            break;
        }
    }
    return true;
}

// get maximum and minimum distances (in meters)
float AP_Proximity::distance_max() const
{
    float dist_max = 0;

    // return longest distance from all backends
    for (uint8_t i=0; i<num_instances; i++) {
        if (valid_instance(i)) {
            dist_max = MAX(dist_max, drivers[i]->distance_max());
        }
    }
    return dist_max;
}
float AP_Proximity::distance_min() const
{
    float dist_min = 0;
    bool found_dist_min = false;

    // calculate shortest distance from all backends
    for (uint8_t i=0; i<num_instances; i++) {
        if (valid_instance(i)) {
            const float disti_min = drivers[i]->distance_min();
            if (!found_dist_min || (disti_min <= dist_min)) {
                dist_min = disti_min;
                found_dist_min = true;
            }
        }
    }

    if (found_dist_min) {
        return dist_min;
    }
    return 0;
}


// get distances in 8 directions. used for sending distances to ground station
bool AP_Proximity::get_horizontal_distances(Proximity_Distance_Array &prx_dist_array) const
{
    Proximity_Distance_Array prx_filt_dist_array; // unused
    return boundary.get_layer_distances(PROXIMITY_MIDDLE_LAYER, distance_max(), prx_dist_array, prx_filt_dist_array);
}

// get total number of obstacles, used in GPS based Simple Avoidance
uint8_t AP_Proximity::get_obstacle_count() const
{
    return boundary.get_obstacle_count();
}

// get vector to obstacle based on obstacle_num passed, used in GPS based Simple Avoidance
bool AP_Proximity::get_obstacle(uint8_t obstacle_num, Vector3f& vec_to_obstacle) const
{
    return boundary.get_obstacle(obstacle_num, vec_to_obstacle);
}

// returns shortest distance to "obstacle_num" obstacle, from a line segment formed between "seg_start" and "seg_end"
// returns FLT_MAX if it's an invalid instance.
bool AP_Proximity::closest_point_from_segment_to_obstacle(uint8_t obstacle_num, const Vector3f& seg_start, const Vector3f& seg_end, Vector3f& closest_point) const
{
    return boundary.closest_point_from_segment_to_obstacle(obstacle_num , seg_start, seg_end, closest_point);
}

// get distance and angle to closest object (used for pre-arm check)
//   returns true on success, false if no valid readings
bool AP_Proximity::get_closest_object(float& angle_deg, float &distance) const
{
    return boundary.get_closest_object(angle_deg, distance);
}

// get number of objects, angle and distance - used for non-GPS avoidance
uint8_t AP_Proximity::get_object_count() const
{
    return boundary.get_horizontal_object_count();
}

// get number of objects, angle and distance - used for non-GPS avoidance
bool AP_Proximity::get_object_angle_and_distance(uint8_t object_number, float& angle_deg, float &distance) const
{
    return boundary.get_horizontal_object_angle_and_distance(object_number, angle_deg, distance);
}

// get obstacle pitch and angle for a particular obstacle num
bool AP_Proximity::get_obstacle_info(uint8_t obstacle_num, float &angle_deg, float &pitch, float &distance) const
{
    return boundary.get_obstacle_info(obstacle_num, angle_deg, pitch, distance);
}

// handle mavlink messages
void AP_Proximity::handle_msg(const mavlink_message_t &msg)
{
    for (uint8_t i=0; i<num_instances; i++) {
        if (valid_instance(i)) {
            drivers[i]->handle_msg(msg);
        }
    }
}

// methods for mavlink SYS_STATUS message (send_sys_status)
bool AP_Proximity::sensor_present() const
{
    return get_status() != Status::NotConnected;
}

bool AP_Proximity::sensor_enabled() const
{
    // check atleast one sensor is enabled
    return (num_instances > 0);
}

bool AP_Proximity::sensor_failed() const
{
    for (uint8_t i=0; i<num_instances; i++) {
        if (get_instance_status(i) != Status::Good) {
            // return first bad status
            return true;
        }
    }
    return false;
}

// get distance in meters upwards, returns true on success
bool AP_Proximity::get_upward_distance(uint8_t instance, float &distance) const
{
    if (!valid_instance(instance)) {
        return false;
    }
    // get upward distance from backend
    return drivers[instance]->get_upward_distance(distance);
}

bool AP_Proximity::get_upward_distance(float &distance) const
{
    // get upward distance from backend
    for (uint8_t i=0; i<num_instances; i++) {
        // return first good upward distance
        if (get_upward_distance(i, distance)) {
            return true;
        }
    }
    return false;
}

#if HAL_LOGGING_ENABLED
// Write proximity sensor distances
void AP_Proximity::log()
{
    // exit immediately if no sensors
    if (num_sensors() == 0) {
        return;
    }

    Proximity_Distance_Array dist_array{}; // raw distances stored here
    Proximity_Distance_Array filt_dist_array{}; //filtered distances stored here
    auto &logger { AP::logger() };
    for (uint8_t i = 0; i < boundary.get_num_layers(); i++) {
        const bool active = boundary.get_layer_distances(i, distance_max(), dist_array, filt_dist_array);
        if (!active) {
            // nothing on this layer
            continue;
        }
        float dist_up;
        if (!get_upward_distance(dist_up)) {
            dist_up = 0.0f;
        }

        float closest_ang = 0.0f;
        float closest_dist = 0.0f;
        get_closest_object(closest_ang, closest_dist);

        const struct log_Proximity pkt_proximity{
                LOG_PACKET_HEADER_INIT(LOG_PROXIMITY_MSG),
                time_us         : AP_HAL::micros64(),
                instance        : i,
                health          : (uint8_t)get_status(),
                dist0           : filt_dist_array.distance[0],
                dist45          : filt_dist_array.distance[1],
                dist90          : filt_dist_array.distance[2],
                dist135         : filt_dist_array.distance[3],
                dist180         : filt_dist_array.distance[4],
                dist225         : filt_dist_array.distance[5],
                dist270         : filt_dist_array.distance[6],
                dist315         : filt_dist_array.distance[7],
                distup          : dist_up,
                closest_angle   : closest_ang,
                closest_dist    : closest_dist
        };
        logger.WriteBlock(&pkt_proximity, sizeof(pkt_proximity));

        if (_raw_log_enable) {
            const struct log_Proximity_raw pkt_proximity_raw{
                LOG_PACKET_HEADER_INIT(LOG_RAW_PROXIMITY_MSG),
                time_us         : AP_HAL::micros64(),
                instance        : i,
                raw_dist0       : dist_array.distance[0],
                raw_dist45      : dist_array.distance[1],
                raw_dist90      : dist_array.distance[2],
                raw_dist135     : dist_array.distance[3],
                raw_dist180     : dist_array.distance[4],
                raw_dist225     : dist_array.distance[5],
                raw_dist270     : dist_array.distance[6],
                raw_dist315     : dist_array.distance[7],
            };
            logger.WriteBlock(&pkt_proximity_raw, sizeof(pkt_proximity_raw));
        }
    }
}
#endif

// return true if the given instance exists
bool AP_Proximity::valid_instance(uint8_t i) const
{
    if (i >= PROXIMITY_MAX_INSTANCES) {
        return false;
    }

    if (drivers[i] == nullptr) {
        return false;
    }
    return (Type)params[i].type.get() != Type::None;
}

AP_Proximity *AP_Proximity::_singleton;

namespace AP {

AP_Proximity *proximity()
{
    return AP_Proximity::get_singleton();
}

}

#endif // HAL_PROXIMITY_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                /*
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
#pragma once

#include "AP_Proximity_config.h"

#if HAL_PROXIMITY_ENABLED

#include <AP_Common/AP_Common.h>
#include <AP_Param/AP_Param.h>
#include <AP_Math/AP_Math.h>
#include <GCS_MAVLink/GCS_MAVLink.h>
#include "AP_Proximity_Params.h"
#include "AP_Proximity_Boundary_3D.h"
#include <AP_Vehicle/AP_Vehicle_Type.h>

#include <AP_HAL/Semaphores.h>

#define PROXIMITY_MAX_INSTANCES             3   // Maximum number of proximity sensor instances available on this platform
#define PROXIMITY_SENSOR_ID_START 10

class AP_Proximity_Backend;

class AP_Proximity
{
public:
    friend class AP_Proximity_Backend;
    friend class AP_Proximity_DroneCAN;

    AP_Proximity();

    /* Do not allow copies */
    CLASS_NO_COPY(AP_Proximity);

    // Proximity driver types
    enum class Type {
        None    = 0,
        // 1 was SF40C_v09
#if AP_PROXIMITY_MAV_ENABLED
        MAV     = 2,
#endif
#if AP_PROXIMITY_TERARANGERTOWER_ENABLED
        TRTOWER = 3,
#endif
#if AP_PROXIMITY_RANGEFINDER_ENABLED
        RangeFinder = 4,
#endif
#if AP_PROXIMITY_RPLIDARA2_ENABLED
        RPLidarA2 = 5,
#endif
#if AP_PROXIMITY_TERARANGERTOWEREVO_ENABLED
        TRTOWEREVO = 6,
#endif
#if AP_PROXIMITY_LIGHTWARE_SF40C_ENABLED
        SF40C = 7,
#endif
#if AP_PROXIMITY_LIGHTWARE_SF45B_ENABLED
        SF45B = 8,
#endif
#if AP_PROXIMITY_SITL_ENABLED
        SITL    = 10,
#endif
#if AP_PROXIMITY_AIRSIMSITL_ENABLED
        AirSimSITL = 12,
#endif
#if AP_PROXIMITY_CYGBOT_ENABLED
        CYGBOT_D1 = 13,
#endif
#if AP_PROXIMITY_DRONECAN_ENABLED
        DroneCAN = 14,
#endif
#if AP_PROXIMITY_SCRIPTING_ENABLED
        Scripting = 15,
#endif
#if AP_PROXIMITY_LD06_ENABLED
        LD06 = 16,
#endif
#if AP_PROXIMITY_MR72_ENABLED
        MR72 = 17,
#endif
    };

    enum class Status {
        NotConnected = 0,
        NoData,
        Good
    };

    // detect and initialise any available proximity sensors
    void init();

    // update state of all proximity sensors. Should be called at high rate from main loop
    void update();

    // return the number of proximity sensor backends
    uint8_t num_sensors() const { return num_instances; }

    // return sensor type of a given instance
    Type get_type(uint8_t instance) const;

    // return distance filter frequency
    float get_filter_freq() const { return _filt_freq; }

    // return sensor health
    Status get_instance_status(uint8_t instance) const;

    // Returns status of first good sensor. If no good sensor found, returns status of last instance sensor 
    Status get_status() const;

    // prearm checks
    bool prearm_healthy(char *failure_msg, const uint8_t failure_msg_len) const;

    // get maximum and minimum distances (in meters)
    float distance_max() const;
    float distance_min() const;

    //
    // 3D boundary related methods
    //

    // get distances in PROXIMITY_MAX_DIRECTION directions. used for sending distances to ground station
    bool get_horizontal_distances(Proximity_Distance_Array &prx_dist_array) const;

    // get total number of obstacles, used in GPS based Simple Avoidance
    uint8_t get_obstacle_count() const;

    // get vector to obstacle based on obstacle_num passed, used in GPS based Simple Avoidance
    bool get_obstacle(uint8_t obstacle_num, Vector3f& vec_to_obstacle) const;

    // returns shortest distance to "obstacle_num" obstacle, from a line segment formed between "seg_start" and "seg_end"
    // returns FLT_MAX if it's an invalid instance.
    bool closest_point_from_segment_to_obstacle(uint8_t obstacle_num, const Vector3f& seg_start, const Vector3f& seg_end, Vector3f& closest_point) const;

    // get distance and angle to closest object (used for pre-arm check)
    //   returns true on success, false if no valid readings
    bool get_closest_object(float& angle_deg, float &distance) const;

    // get number of objects
    uint8_t get_object_count() const;
    bool get_object_angle_and_distance(uint8_t object_number, float& angle_deg, float &distance) const;

    // get obstacle pitch and angle for a particular obstacle num
    bool get_obstacle_info(uint8_t obstacle_num, float &angle_deg, float &pitch, float &distance) const;

    //
    // mavlink related methods
    //

    // handle mavlink messages
    void handle_msg(const mavlink_message_t &msg);

    // methods for mavlink SYS_STATUS message (send_sys_status)
    bool sensor_present() const;
    bool sensor_enabled() const;
    bool sensor_failed() const;

    //
    // support for upwards and downwards facing sensors
    //

    // get distance upwards in meters. returns true on success
    bool get_upward_distance(uint8_t instance, float &distance) const;
    bool get_upward_distance(float &distance) const;

    // set alt as read from downward facing rangefinder. Tilt is already adjusted for
    void set_rangefinder_alt(bool use, bool healthy, float alt_cm);

    // method called by vehicle to have AP_Proximity write onboard log messages
    void log();

    // The Proximity_State structure is filled in by the backend driver
    struct Proximity_State {
        uint8_t instance;   // the instance number of this proximity sensor
        Status status;      // sensor status

        const struct AP_Param::GroupInfo *var_info; // stores extra parameter information for the sensor (if it exists)
    };

    static const struct AP_Param::GroupInfo *backend_var_info[PROXIMITY_MAX_INSTANCES];

    // parameter list
    static const struct AP_Param::GroupInfo var_info[];

    static AP_Proximity *get_singleton(void) { return _singleton; };

    // return backend object for Lua scripting
    AP_Proximity_Backend *get_backend(uint8_t id) const;

    // 3D boundary
    AP_Proximity_Boundary_3D boundary;

    // Check if Obstacle defined by body-frame yaw and pitch is near ground
    bool check_obstacle_near_ground(float pitch, float yaw, float distance) const;

    // get proximity address (for AP_Periph CAN)
    uint8_t get_address(uint8_t id) const {
        return id >= PROXIMITY_MAX_INSTANCES? 0 : uint8_t(params[id].address.get());
    }

protected:

    // parameters for backends
    AP_Proximity_Params params[PROXIMITY_MAX_INSTANCES];

private:
    static AP_Proximity *_singleton;
    Proximity_State state[PROXIMITY_MAX_INSTANCES];
    AP_Proximity_Backend *drivers[PROXIMITY_MAX_INSTANCES];
    uint8_t num_instances;

    // return true if the given instance exists
    bool valid_instance(uint8_t i) const;

    // parameters for all instances
    AP_Int8 _raw_log_enable;                           // enable logging raw distances
    AP_Int8 _ign_gnd_enable;                           // true if land detection should be enabled
    AP_Float _filt_freq;                               // cutoff frequency for low pass filter
    AP_Float _alt_min;                                 // Minimum altitude -in meters- below which proximity should not work.

    // get alt from rangefinder in meters. This reading is corrected for vehicle tilt
    bool get_rangefinder_alt(float &alt_m) const;

    struct RangeFinderState {
        bool use;                          // true if enabled
        bool healthy;                      // true if we can trust the altitude from the rangefinder
        int16_t alt_cm;                    // tilt compensated altitude (in cm) from rangefinder
        uint32_t last_downward_update_ms;  // last update ms
    } _rangefinder_state;

    HAL_Semaphore detect_sem;
};

namespace AP {
    AP_Proximity *proximity();
};

#endif // HAL_PROXIMITY_ENABLED
                 /*
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include "AP_Proximity_config.h"

#if AP_PROXIMITY_AIRSIMSITL_ENABLED

#include "AP_Proximity_AirSimSITL.h"

#define PROXIMITY_MAX_RANGE 100.0f
#define PROXIMITY_ACCURACY  0.1f        // minimum distance (in meters) between objects sent to object database

// update the state of the sensor
void AP_Proximity_AirSimSITL::update(void)
{
    SITL::vector3f_array &points = sitl->state.scanner.points;
    if (points.length == 0) {
        set_status(AP_Proximity::Status::NoData);
        return;
    }

    set_status(AP_Proximity::Status::Good);

    // reset all faces to default so that it can be filled with the fresh lidar data
    frontend.boundary.reset();

    // precalculate sq of min distance
    const float distance_min_sq = sq(distance_min());

    // variables used to reduce data sent to object database
    const float accuracy_sq = sq(PROXIMITY_ACCURACY);
    bool prev_pos_valid = false;
    Vector2f prev_pos;
    // clear temp boundary since we have a new message
    temp_boundary.reset();

    for (uint16_t i=0; i<points.length; i++) {
        Vector3f &point = points.data[i];
        if (point.is_zero()) {
            continue;
        }

        // calculate distance to point and check larger than min distance
        const Vector2f new_pos = Vector2f{point.x, point.y};
        const float distance_sq = new_pos.length_squared();
        if (distance_sq > distance_min_sq) {

            // add distance to the 3D boundary
            const float yaw_angle_deg = wrap_360(degrees(atan2f(point.y, point.x)));
            const AP_Proximity_Boundary_3D::Face face = frontend.boundary.get_face(yaw_angle_deg);
            // store the min distance in each face in a temp boundary
            temp_boundary.add_distance(face, yaw_angle_deg, safe_sqrt(distance_sq));

            // check distance from previous point to reduce amount of data sent to object database
            if (!prev_pos_valid || ((new_pos - prev_pos).length_squared() >= accuracy_sq)) {
                // update OA database
                database_push(yaw_angle_deg, safe_sqrt(distance_sq));
                // store point
                prev_pos_valid = true;
                prev_pos = new_pos;
            }
        }
    }
    // copy temp boundary to real boundary
    temp_boundary.update_3D_boundary(state.instance, frontend.boundary);
}

// get maximum and minimum distances (in meters) of primary sensor
float AP_Proximity_AirSimSITL::distance_max() const
{
    return PROXIMITY_MAX_RANGE;
}

float AP_Proximity_AirSimSITL::distance_min() const
{
    return 0.0f;
}

// get distance upwards in meters. returns true on success
bool AP_Proximity_AirSimSITL::get_upward_distance(float &distance) const
{
    // we don't have an upward facing laser
    return false;
}

#endif // AP_PROXIMITY_AIRSIMSITL_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   /*
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#pragma once

#include "AP_Proximity_config.h"

#if AP_PROXIMITY_AIRSIMSITL_ENABLED

#include "AP_Proximity_Backend.h"

#include <SITL/SITL.h>

class AP_Proximity_AirSimSITL : public AP_Proximity_Backend
{

public:
    // constructor
    using AP_Proximity_Backend::AP_Proximity_Backend;

    // update state
    void update(void) override;

    // get maximum and minimum distances (in meters) of sensor
    float distance_max() const override;
    float distance_min() const override;

    // get distance upwards in meters. returns true on success
    bool get_upward_distance(float &distance) const override;

private:
    SITL::SIM *sitl = AP::sitl();
    AP_Proximity_Temp_Boundary temp_boundary;

};

#endif // AP_PROXIMITY_AIRSIMSITL_ENABLED

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       /*
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include "AP_Proximity_Backend.h"

#if HAL_PROXIMITY_ENABLED
#include <AP_Common/Location.h>
#include <AP_AHRS/AP_AHRS.h>
#include <AC_Avoidance/AP_OADatabase.h>

/*
  base class constructor. 
  This incorporates initialisation as well.
*/
AP_Proximity_Backend::AP_Proximity_Backend(AP_Proximity& _frontend, AP_Proximity::Proximity_State& _state, AP_Proximity_Params& _params) :
        frontend(_frontend),
        state(_state),
        params(_params)
{
    _backend_type = (AP_Proximity::Type )_params.type.get();
}

static_assert(PROXIMITY_MAX_DIRECTION <= 8,
              "get_horizontal_distances assumes 8-bits is enough for validity bitmask");

// set status and update valid count
void AP_Proximity_Backend::set_status(AP_Proximity::Status status)
{
    state.status = status;
}

// correct an angle (in degrees) based on the orientation and yaw correction parameters
float AP_Proximity_Backend::correct_angle_for_orientation(float angle_degrees) const
{
    const float angle_sign = (params.orientation == 1) ? -1.0f : 1.0f;
    return wrap_360(angle_degrees * angle_sign + params.yaw_correction);
}

// check if a reading should be ignored because it falls into an ignore area (check_for_ign_area should be sent as false if this check is not needed)
// pitch is the vertical body-frame angle (in degrees) to the obstacle (0=directly ahead, 90 is above the vehicle)
// yaw is the horizontal body-frame angle (in degrees) to the obstacle (0=directly ahead of the vehicle, 90 is to the right of the vehicle)
// Also checks if obstacle is near land or out of range
// angles should be in degrees and in the range of 0 to 360, distance should be in meteres
bool AP_Proximity_Backend::ignore_reading(float pitch, float yaw, float distance_m, bool check_for_ign_area) const
{
    // check if distances are supposed to be in a particular range
    if (!is_zero(params.max_m)) {
        if (distance_m > params.max_m) {
            // too far away
            return true;
        }
    }

    if (!is_zero(params.min_m)) {
        if (distance_m < params.min_m) {
            // too close
            return true;
        }
    }

    if (check_for_ign_area) {
        // check angle vs each ignore area
        for (uint8_t i=0; i < PROXIMITY_MAX_IGNORE; i++) {
            if (params.ignore_width_deg[i] != 0) {
                if (abs(yaw - params.ignore_angle_deg[i]) <= (params.ignore_width_deg[i]/2)) {
                    return true;
                }
            }
        }
    }

   // check if obstacle is near land
   return frontend.check_obstacle_near_ground(pitch, yaw, distance_m);
}

// returns true if database is ready to be pushed to and all cached data is ready
bool AP_Proximity_Backend::database_prepare_for_push(Vector3f &current_pos, Matrix3f &body_to_ned)
{
#if AP_OADATABASE_ENABLED
    AP_OADatabase *oaDb = AP::oadatabase();
    if (oaDb == nullptr || !oaDb->healthy()) {
        return false;
    }

    if (!AP::ahrs().get_relative_position_NED_origin(current_pos)) {
        return false;
    }

    body_to_ned = AP::ahrs().get_rotation_body_to_ned();

    return true;
#else
    return false;
#endif
}

// update Object Avoidance database with Earth-frame point
void AP_Proximity_Backend::database_push(float angle, float pitch, float distance)
{
    Vector3f current_pos;
    Matrix3f body_to_ned;

    if (database_prepare_for_push(current_pos, body_to_ned)) {
        database_push(angle, pitch, distance, AP_HAL::millis(), current_pos, body_to_ned);
    }
}

// update Object Avoidance database with Earth-frame point
// pitch can be optionally provided if needed
void AP_Proximity_Backend::database_push(float angle, float pitch, float distance, uint32_t timestamp_ms, const Vector3f &current_pos, const Matrix3f &body_to_ned)
{

#if AP_OADATABASE_ENABLED
    AP_OADatabase *oaDb = AP::oadatabase();
    if (oaDb == nullptr || !oaDb->healthy()) {
        return;
    }
    if ((pitch > 90.0f) || (pitch < -90.0f)) {
        // sanity check on pitch
        return;
    }
    //Assume object is angle and pitch bearing and distance meters away from the vehicle 
    Vector3f object_3D;
    object_3D.offset_bearing(wrap_180(angle), (pitch * -1.0f), distance);
    const Vector3f rotated_object_3D = body_to_ned * object_3D;

    //Calculate the position vector from origin
    Vector3f temp_pos = current_pos + rotated_object_3D;
    //Convert the vector to a NEU frame from NED
    temp_pos.z = temp_pos.z * -1.0f;

    oaDb->queue_push(temp_pos, timestamp_ms, distance);
#endif  // AP_OADATABASE_ENABLED
}

#endif // HAL_PROXIMITY_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             /*
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
#pragma once

#include "AP_Proximity.h"

#if HAL_PROXIMITY_ENABLED
#include <AP_Common/AP_Common.h>
#include <AP_HAL/Semaphores.h>

class AP_Proximity_Backend
{
public:
    // constructor. This incorporates initialisation as well.
	AP_Proximity_Backend(AP_Proximity &_frontend, AP_Proximity::Proximity_State &_state, AP_Proximity_Params &_params);

    // we declare a virtual destructor so that Proximity drivers can
    // override with a custom destructor if need be
    virtual ~AP_Proximity_Backend(void) {}

    // update the state structure
    virtual void update() = 0;

    // get maximum and minimum distances (in meters) of sensor
    virtual float distance_max() const = 0;
    virtual float distance_min() const = 0;

    // get distance upwards in meters. returns true on success
    virtual bool get_upward_distance(float &distance) const { return false; }

    // handle mavlink messages
    virtual void handle_msg(const mavlink_message_t &msg) {}

#if AP_SCRIPTING_ENABLED
    // handle scripting obstacle messages
    virtual bool set_distance_min_max(float min, float max) { return false; }
    // this is in body frame
    virtual bool handle_script_distance_msg(float dist_m, float yaw_deg, float pitch_deg, bool push_to_boundary) { return false; }
    virtual bool handle_script_3d_msg(const Vector3f &vec_to_obstacle, bool push_to_boundary) { return false; }
    virtual bool update_virtual_boundary() { return false; }
#endif

    // return the type of sensor
    AP_Proximity::Type type() const { return (AP_Proximity::Type)params.type.get(); }

protected:

    // set status and update valid_count
    void set_status(AP_Proximity::Status status);

    // correct an angle (in degrees) based on the orientation and yaw correction parameters
    float correct_angle_for_orientation(float angle_degrees) const;

    // check if a reading should be ignored because it falls into an ignore area (check_for_ign_area should be sent as false if this check is not needed)
    // pitch is the vertical body-frame angle (in degrees) to the obstacle (0=directly ahead, 90 is above the vehicle)
    // yaw is the horizontal body-frame angle (in degrees) to the obstacle (0=directly ahead of the vehicle, 90 is to the right of the vehicle)
    // Also checks if obstacle is near land or out of range
    // angles should be in degrees and in the range of 0 to 360, distance should be in meteres
    bool ignore_reading(float pitch, float yaw, float distance_m, bool check_for_ign_area = true) const;
    bool ignore_reading(float yaw, float distance_m, bool check_for_ign_area = true) const { return ignore_reading(0.0f, yaw, distance_m, check_for_ign_area); }

    // database helpers. All angles are in degrees
    static bool database_prepare_for_push(Vector3f &current_pos, Matrix3f &body_to_ned);
    // Note: "angle" refers to yaw (in body frame) towards the obstacle
    static void database_push(float angle, float pitch, float distance);
    static void database_push(float angle, float distance) {
        database_push(angle, 0.0f, distance);
    }

    static void database_push(float angle, float distance, uint32_t timestamp_ms, const Vector3f &current_pos, const Matrix3f &body_to_ned) {
        database_push(angle, 0.0f, distance, timestamp_ms, current_pos, body_to_ned);
    };
    static void database_push(float angle, float pitch, float distance, uint32_t timestamp_ms, const Vector3f &current_pos, const Matrix3f &body_to_ned);

    // semaphore for access to shared frontend data
    HAL_Semaphore _sem;

    AP_Proximity::Type _backend_type;

    AP_Proximity &frontend;
    AP_Proximity::Proximity_State &state;   // reference to this instances state
    AP_Proximity_Params &params;            // parameters for this backend
};

#endif // HAL_PROXIMITY_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             /*
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include "AP_Proximity_Backend_Serial.h"

#if HAL_PROXIMITY_ENABLED
#include <AP_SerialManager/AP_SerialManager.h>

/*
   The constructor also initialises the proximity sensor. Note that this
   constructor is not called until detect() returns true, so we
   already know that we should setup the proximity sensor
*/
AP_Proximity_Backend_Serial::AP_Proximity_Backend_Serial(AP_Proximity &_frontend,
                                                         AP_Proximity::Proximity_State &_state,
                                                         AP_Proximity_Params &_params,
                                                         uint8_t serial_instance) :
    AP_Proximity_Backend(_frontend, _state, _params)
{
    const AP_SerialManager &serial_manager = AP::serialmanager();
    _uart = serial_manager.find_serial(AP_SerialManager::SerialProtocol_Lidar360, serial_instance);
    if (_uart != nullptr) {
        // start uart with larger receive buffer
        _uart->begin(serial_manager.find_baudrate(AP_SerialManager::SerialProtocol_Lidar360, serial_instance), rxspace(), 0);
    }
}

// static detection function
// detect if a proximity sensor is connected by looking for a configured serial port
// serial_instance affects which serial port is used.  Should be 0 or 1 depending on whether this is the 1st or 2nd proximity sensor with a serial interface
bool AP_Proximity_Backend_Serial::detect(uint8_t serial_instance)
{
    return AP::serialmanager().have_serial(AP_SerialManager::SerialProtocol_Lidar360, serial_instance);
}

#endif // HAL_PROXIMITY_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             #pragma once

#include "AP_Proximity_Backend.h"

#if HAL_PROXIMITY_ENABLED

class AP_Proximity_Backend_Serial : public AP_Proximity_Backend
{
public:
    AP_Proximity_Backend_Serial(AP_Proximity &_frontend,
                                AP_Proximity::Proximity_State &_state,
                                AP_Proximity_Params& _params,
                                uint8_t serial_instance);

    // static detection function
    // detect if a proximity sensor is connected by looking for a configured serial port
    // serial_instance affects which serial port is used.  Should be 0 or 1 depending on whether this is the 1st or 2nd proximity sensor with a serial interface
    static bool detect(uint8_t serial_instance);

protected:
    virtual uint16_t rxspace() const { return 0; };

    AP_HAL::UARTDriver *_uart;              // uart for communicating with sensor
};

#endif // HAL_PROXIMITY_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              