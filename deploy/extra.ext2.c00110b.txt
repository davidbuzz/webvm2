/*
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
/*
  implementation of MSP and BLHeli-4way protocols for pass-through ESC
  calibration and firmware update

  With thanks to betaflight for a great reference implementation
 */

#pragma once

#include <AP_Common/AP_Common.h>
#include <AP_HAL/AP_HAL.h>

#define HAVE_AP_BLHELI_SUPPORT HAL_SUPPORT_RCOUT_SERIAL

#if HAL_SUPPORT_RCOUT_SERIAL

#include <AP_ESC_Telem/AP_ESC_Telem_Backend.h>

#include <AP_Param/AP_Param.h>
#include <Filter/LowPassFilter.h>
#include <AP_MSP/msp_protocol.h>
#include "blheli_4way_protocol.h"

#define AP_BLHELI_MAX_ESCS 8

class AP_BLHeli : public AP_ESC_Telem_Backend {

public:
    AP_BLHeli();
    
    void update(void);
    void init(uint32_t motor_mask, AP_HAL::RCOutput::output_mode mode);
    void update_telemetry(void);
    bool process_input(uint8_t b);

    static const struct AP_Param::GroupInfo var_info[];

    bool has_bidir_dshot(uint8_t esc_index) const {
        return channel_bidir_dshot_mask.get() & (1U << motor_map[esc_index]);
    }

    uint32_t get_bidir_dshot_mask() const { return channel_bidir_dshot_mask.get(); }
    uint8_t get_motor_poles() const { return motor_poles.get(); }
    uint16_t get_telemetry_rate() const { return telem_rate.get(); }

    static AP_BLHeli *get_singleton(void) {
        return _singleton;
    }
    
private:
    static AP_BLHeli *_singleton;
    
    // mask of channels to use for BLHeli protocol
    AP_Int32 channel_mask;
    AP_Int32 channel_reversible_mask;
    AP_Int32 channel_reversed_mask;
    AP_Int8 channel_auto;
    AP_Int8 run_test;
    AP_Int16 timeout_sec;
    AP_Int16 telem_rate;
    AP_Int8 debug_level;
    AP_Int8 output_type;
    AP_Int8 control_port;
    AP_Int8 motor_poles;
    // mask of channels with bi-directional dshot enabled
    AP_Int32 channel_bidir_dshot_mask;
    
    enum mspState {
        MSP_IDLE=0,
        MSP_HEADER_START,
        MSP_HEADER_M,
        MSP_HEADER_ARROW,
        MSP_HEADER_SIZE,
        MSP_HEADER_CMD,
        MSP_COMMAND_RECEIVED
    };

    enum mspPacketType {
        MSP_PACKET_COMMAND,
        MSP_PACKET_REPLY
    };

    enum escProtocol {
        PROTOCOL_SIMONK = 0,
        PROTOCOL_BLHELI = 1,
        PROTOCOL_KISS = 2,
        PROTOCOL_KISSALL = 3,
        PROTOCOL_CASTLE = 4,
        PROTOCOL_MAX = 5,
        PROTOCOL_NONE = 0xfe,
        PROTOCOL_4WAY = 0xff
    };

    enum motorPwmProtocol {
        PWM_TYPE_STANDARD = 0,
        PWM_TYPE_ONESHOT125,
        PWM_TYPE_ONESHOT42,
        PWM_TYPE_MULTISHOT,
        PWM_TYPE_BRUSHED,
        PWM_TYPE_DSHOT150,
        PWM_TYPE_DSHOT300,
        PWM_TYPE_DSHOT600,
        PWM_TYPE_DSHOT1200,
        PWM_TYPE_PROSHOT1000,
    };

    enum MSPFeatures {
        FEATURE_RX_PPM = 1 << 0,
        FEATURE_INFLIGHT_ACC_CAL = 1 << 2,
        FEATURE_RX_SERIAL = 1 << 3,
        FEATURE_MOTOR_STOP = 1 << 4,
        FEATURE_SERVO_TILT = 1 << 5,
        FEATURE_SOFTSERIAL = 1 << 6,
        FEATURE_GPS = 1 << 7,
        FEATURE_RANGEFINDER = 1 << 9,
        FEATURE_TELEMETRY = 1 << 10,
        FEATURE_3D = 1 << 12,
        FEATURE_RX_PARALLEL_PWM = 1 << 13,
        FEATURE_RX_MSP = 1 << 14,
        FEATURE_RSSI_ADC = 1 << 15,
        FEATURE_LED_STRIP = 1 << 16,
        FEATURE_DASHBOARD = 1 << 17,
        FEATURE_OSD = 1 << 18,
        FEATURE_CHANNEL_FORWARDING = 1 << 20,
        FEATURE_TRANSPONDER = 1 << 21,
        FEATURE_AIRMODE = 1 << 22,
        FEATURE_RX_SPI = 1 << 25,
        FEATURE_SOFTSPI = 1 << 26,
        FEATURE_ESC_SENSOR = 1 << 27,
        FEATURE_ANTI_GRAVITY = 1 << 28,
        FEATURE_DYNAMIC_FILTER = 1 << 29,
    };


    /*
      state of MSP command processing
    */
    struct {
        enum mspState state;
        enum mspPacketType packetType;
        uint8_t offset;
        uint8_t dataSize;
        uint8_t checksum;
        uint8_t buf[192];
        uint8_t cmdMSP;
        enum escProtocol escMode;
        uint8_t portIndex;
    } msp;

    enum blheliState {
        BLHELI_IDLE=0,
        BLHELI_HEADER_START,
        BLHELI_HEADER_CMD,
        BLHELI_HEADER_ADDR_LOW,
        BLHELI_HEADER_ADDR_HIGH,
        BLHELI_HEADER_LEN,
        BLHELI_CRC1,
        BLHELI_CRC2,
        BLHELI_COMMAND_RECEIVED
    };

    /*
      state of blheli 4way protocol handling
    */
    struct {
        enum blheliState state;
        uint8_t command;
        uint16_t address;
        uint16_t param_len;
        uint16_t offset;
        uint8_t buf[256+3+8];
        uint8_t crc1;
        uint16_t crc;
        bool connected[AP_BLHELI_MAX_ESCS];
        uint8_t interface_mode[AP_BLHELI_MAX_ESCS];
        uint8_t deviceInfo[AP_BLHELI_MAX_ESCS][4];
        uint8_t chan;
        uint8_t ack;
    } blheli;

    const uint16_t esc_status_addr = 0xEB00;
    
    // protocol reported by ESC in esc_status
    enum esc_protocol {
        ESC_PROTOCOL_NONE=0,
        ESC_PROTOCOL_NORMAL=1,
        ESC_PROTOCOL_ONESHOT125=2,
        ESC_PROTOCOL_DSHOT=5,
    };

    // ESC status structure at address 0xEB00
    struct PACKED esc_status {
        uint8_t unknown[3];
        enum esc_protocol protocol;
        uint32_t good_frames;
        uint32_t bad_frames;
        uint32_t unknown2;
    };
    
    
    AP_HAL::UARTDriver *uart;
    AP_HAL::UARTDriver *debug_uart;
    AP_HAL::UARTDriver *telem_uart;

    static const uint8_t max_motors = AP_BLHELI_MAX_ESCS;
    uint8_t num_motors;

    // last log output to avoid beat frequencies
    uint32_t last_log_ms[max_motors];

    // have we initialised the interface?
    bool initialised;

    // last valid packet timestamp
    uint32_t last_valid_ms;

    // when did we start the serial ESC output?
    uint32_t serial_start_ms;

    // have we disabled motor outputs?
    bool motors_disabled;
    // mask of channels that should normally be disabled
    uint32_t motors_disabled_mask;

    // have we locked the UART?
    bool uart_locked;

    // true if we have a mix of reversible and normal ESC
    bool mixed_type;

    // mapping from BLHeli motor numbers to RC output channels
    uint8_t motor_map[max_motors];
    uint32_t motor_mask;

    // convert between servo number and FMU channel number for ESC telemetry
    uint8_t chan_offset;

    // when did we last request telemetry?
    uint32_t last_telem_request_us;
    uint8_t last_telem_esc;
    static const uint8_t telem_packet_size = 10;
    bool telem_uart_started;
    uint32_t last_telem_byte_read_us;
    int8_t last_control_port;

    bool msp_process_byte(uint8_t c);
    void blheli_crc_update(uint8_t c);
    bool blheli_4way_process_byte(uint8_t c);
    void msp_send_ack(uint8_t cmd);
    void msp_send_reply(uint8_t cmd, const uint8_t *buf, uint8_t len);
    void putU16(uint8_t *b, uint16_t v);
    uint16_t getU16(const uint8_t *b);
    void putU32(uint8_t *b, uint32_t v);
    void putU16_BE(uint8_t *b, uint16_t v);
    void msp_process_command(void);
    void blheli_send_reply(const uint8_t *buf, uint16_t len);
    uint16_t BL_CRC(const uint8_t *buf, uint16_t len);
    bool isMcuConnected(void);
    void setDisconnected(void);
    bool BL_SendBuf(const uint8_t *buf, uint16_t len);
    bool BL_ReadBuf(uint8_t *buf, uint16_t len);
    uint8_t BL_GetACK(uint16_t timeout_ms=2);
    bool BL_SendCMDSetAddress();
    bool BL_ReadA(uint8_t cmd, uint8_t *buf, uint16_t n);
    bool BL_ConnectEx(void);
    bool BL_SendCMDKeepAlive(void);
    bool BL_PageErase(void);
    void BL_SendCMDRunRestartBootloader(void);
    uint8_t BL_SendCMDSetBuffer(const uint8_t *buf, uint16_t nbytes);
    bool BL_WriteA(uint8_t cmd, const uint8_t *buf, uint16_t nbytes, uint32_t timeout);
    uint8_t BL_WriteFlash(const uint8_t *buf, uint16_t n);
    bool BL_VerifyFlash(const uint8_t *buf, uint16_t n);
    void blheli_process_command(void);
    void run_connection_test(uint8_t chan);
    void read_telemetry_packet(void);
    void log_bidir_telemetry(void);

    // protocol handler hook
    bool protocol_handler(uint8_t , AP_HAL::UARTDriver *);
};

#endif // HAL_SUPPORT_RCOUT_SERIAL
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 /*
  blheli 4way protocol. Based on serial_4way.c from betaflight
 */
/*
 * Cleanflight is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Cleanflight is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Cleanflight.  If not, see <http://www.gnu.org/licenses/>.
 * Author: 4712
*/

// Interface related only
// establish and test connection to the Interface

// Send Structure
// ESC + CMD PARAM_LEN [PARAM (if len > 0)] CRC16_Hi CRC16_Lo
// Return
// ESC CMD PARAM_LEN [PARAM (if len > 0)] + ACK (uint8_t OK or ERR) + CRC16_Hi CRC16_Lo

#define cmd_Remote_Escape 0x2E // '.'
#define cmd_Local_Escape  0x2F // '/'

// Test Interface still present
#define cmd_InterfaceTestAlive 0x30 // '0' alive
// RETURN: ACK

// get Protocol Version Number 01..255
#define cmd_ProtocolGetVersion 0x31  // '1' version
// RETURN: uint8_t VersionNumber + ACK

// get Version String
#define cmd_InterfaceGetName 0x32 // '2' name
// RETURN: String + ACK

//get Version Number 01..255
#define cmd_InterfaceGetVersion 0x33  // '3' version
// RETURN: uint8_t AVersionNumber + ACK


// Exit / Restart Interface - can be used to switch to Box Mode
#define cmd_InterfaceExit 0x34       // '4' exit
// RETURN: ACK

// Reset the Device connected to the Interface
#define cmd_DeviceReset 0x35        // '5' reset
// RETURN: ACK

// Get the Device ID connected
// #define cmd_DeviceGetID 0x36      //'6' device id removed since 06/106
// RETURN: uint8_t DeviceID + ACK

// Initialize Flash Access for Device connected
#define cmd_DeviceInitFlash 0x37    // '7' init flash access
// RETURN: ACK

// Erase the whole Device Memory of connected Device
#define cmd_DeviceEraseAll 0x38     // '8' erase all
// RETURN: ACK

// Erase one Page of Device Memory of connected Device
#define cmd_DevicePageErase 0x39    // '9' page erase
// PARAM: uint8_t APageNumber
// RETURN: ACK

// Read to Buffer from Device Memory of connected Device // Buffer Len is Max 256 Bytes
// BuffLen = 0 means 256 Bytes
#define cmd_DeviceRead 0x3A  // ':' read Device
// PARAM: uint8_t ADRESS_Hi + ADRESS_Lo + BuffLen[0..255]
// RETURN: PARAM: uint8_t ADRESS_Hi + ADRESS_Lo + BUffLen + Buffer[0..255] ACK

// Write to Buffer for Device Memory of connected Device // Buffer Len is Max 256 Bytes
// BuffLen = 0 means 256 Bytes
#define cmd_DeviceWrite 0x3B    // ';' write
// PARAM: uint8_t ADRESS_Hi + ADRESS_Lo + BUffLen + Buffer[0..255]
// RETURN: ACK

// Set C2CK low infinite ) permanent Reset state
#define cmd_DeviceC2CK_LOW 0x3C // '<'
// RETURN: ACK

// Read to Buffer from Device Memory of connected Device //Buffer Len is Max 256 Bytes
// BuffLen = 0 means 256 Bytes
#define cmd_DeviceReadEEprom 0x3D  // '=' read Device
// PARAM: uint8_t ADRESS_Hi + ADRESS_Lo + BuffLen[0..255]
// RETURN: PARAM: uint8_t ADRESS_Hi + ADRESS_Lo + BUffLen + Buffer[0..255] ACK

// Write to Buffer for Device Memory of connected Device // Buffer Len is Max 256 Bytes
// BuffLen = 0 means 256 Bytes
#define cmd_DeviceWriteEEprom 0x3E  // '>' write
// PARAM: uint8_t ADRESS_Hi + ADRESS_Lo + BUffLen + Buffer[0..255]
// RETURN: ACK

// Set Interface Mode
#define cmd_InterfaceSetMode 0x3F   // '?'
// #define imC2 0
// #define imSIL_BLB 1
// #define imATM_BLB 2
// #define imSK 3
// PARAM: uint8_t Mode
// RETURN: ACK or ACK_I_INVALID_CHANNEL

//Write to Buffer for Verify Device Memory of connected Device //Buffer Len is Max 256 Bytes
//BuffLen = 0 means 256 Bytes
#define cmd_DeviceVerify 0x40   //'@' write
//PARAM: uint8_t ADRESS_Hi + ADRESS_Lo + BUffLen + Buffer[0..255]
//RETURN: ACK

/*
  local defines
 */
#define SERIAL_4WAY_VER_MAIN 20
#define SERIAL_4WAY_VER_SUB_1 (uint8_t) 0
#define SERIAL_4WAY_VER_SUB_2 (uint8_t) 05

#define SERIAL_4WAY_PROTOCOL_VER 107
// *** end

#if (SERIAL_4WAY_VER_MAIN > 24)
#error "beware of SERIAL_4WAY_VER_SUB_1 is uint8_t"
#endif

#define SERIAL_4WAY_VERSION (uint16_t) ((SERIAL_4WAY_VER_MAIN * 1000) + (SERIAL_4WAY_VER_SUB_1 * 100) + SERIAL_4WAY_VER_SUB_2)

#define SERIAL_4WAY_VERSION_HI (uint8_t) (SERIAL_4WAY_VERSION / 100)
#define SERIAL_4WAY_VERSION_LO (uint8_t) (SERIAL_4WAY_VERSION % 100)

#define brSUCCESS           0x30
#define brERRORVERIFY       0xC0
#define brERRORCOMMAND      0xC1
#define brERRORCRC          0xC2
#define brNONE              0xFF

#define CMD_RUN             0x00
#define CMD_PROG_FLASH      0x01
#define CMD_ERASE_FLASH     0x02
#define CMD_READ_FLASH_SIL  0x03
#define CMD_VERIFY_FLASH    0x03
#define CMD_VERIFY_FLASH_ARM 0x04
#define CMD_READ_EEPROM     0x04
#define CMD_PROG_EEPROM     0x05
#define CMD_READ_SRAM       0x06
#define CMD_READ_FLASH_ATM  0x07
#define CMD_KEEP_ALIVE      0xFD
#define CMD_SET_ADDRESS     0xFF
#define CMD_SET_BUFFER      0xFE

#define RestartBootloader   0
#define ExitBootloader      1

#define ACK_OK                  0x00
#define ACK_I_INVALID_CMD       0x02
#define ACK_I_INVALID_CRC       0x03
#define ACK_I_VERIFY_ERROR      0x04
#define ACK_I_INVALID_CHANNEL   0x08
#define ACK_I_INVALID_PARAM     0x09
#define ACK_D_GENERAL_ERROR     0x0F

// interface modes
#define imC2 0
#define imSIL_BLB 1
#define imATM_BLB 2
#define imSK 3
#define imARM_BLB 4
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   /*
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/*
 *       APM_Baro.cpp - barometer driver
 *
 */
#include "AP_Baro.h"

#include <utility>
#include <stdio.h>

#include <GCS_MAVLink/GCS.h>
#include <AP_Common/AP_Common.h>
#include <AP_HAL/AP_HAL.h>
#include <AP_Math/AP_Math.h>
#include <AP_BoardConfig/AP_BoardConfig.h>
#include <AP_CANManager/AP_CANManager.h>
#include <AP_Vehicle/AP_Vehicle_Type.h>
#include <AP_HAL/I2CDevice.h>

#include "AP_Baro_SITL.h"
#include "AP_Baro_BMP085.h"
#include "AP_Baro_BMP280.h"
#include "AP_Baro_BMP388.h"
#include "AP_Baro_BMP581.h"
#include "AP_Baro_SPL06.h"
#include "AP_Baro_KellerLD.h"
#include "AP_Baro_MS5611.h"
#include "AP_Baro_ICM20789.h"
#include "AP_Baro_LPS2XH.h"
#include "AP_Baro_FBM320.h"
#include "AP_Baro_DPS280.h"
#include "AP_Baro_Dummy.h"
#include "AP_Baro_DroneCAN.h"
#include "AP_Baro_MSP.h"
#include "AP_Baro_ExternalAHRS.h"
#include "AP_Baro_ICP101XX.h"
#include "AP_Baro_ICP201XX.h"

#include <AP_Airspeed/AP_Airspeed.h>
#include <AP_AHRS/AP_AHRS.h>
#include <AP_Arming/AP_Arming.h>
#include <AP_Logger/AP_Logger.h>
#include <AP_GPS/AP_GPS.h>
#include <AP_Vehicle/AP_Vehicle.h>

#define INTERNAL_TEMPERATURE_CLAMP 35.0f

#ifndef HAL_BARO_FILTER_DEFAULT
 #define HAL_BARO_FILTER_DEFAULT 0 // turned off by default
#endif

#ifndef HAL_BARO_PROBE_EXT_DEFAULT
 #define HAL_BARO_PROBE_EXT_DEFAULT 0
#endif

#ifndef HAL_BARO_EXTERNAL_BUS_DEFAULT
 #define HAL_BARO_EXTERNAL_BUS_DEFAULT -1
#endif

#ifdef HAL_BUILD_AP_PERIPH
#define HAL_BARO_ALLOW_INIT_NO_BARO
#endif

#ifndef AP_FIELD_ELEVATION_ENABLED
#define AP_FIELD_ELEVATION_ENABLED !defined(HAL_BUILD_AP_PERIPH) && !APM_BUILD_TYPE(APM_BUILD_ArduSub)
#endif

extern const AP_HAL::HAL& hal;

// table of user settable parameters
const AP_Param::GroupInfo AP_Baro::var_info[] = {
    // NOTE: Index numbers 0 and 1 were for the old integer
    // ground temperature and pressure

#ifndef HAL_BUILD_AP_PERIPH
    // @Param: 1_GND_PRESS
    // @DisplayName: Ground Pressure
    // @Description: calibrated ground pressure in Pascals
    // @Units: Pa
    // @Increment: 1
    // @ReadOnly: True
    // @Volatile: True
    // @User: Advanced
    AP_GROUPINFO_FLAGS("1_GND_PRESS", 2, AP_Baro, sensors[0].ground_pressure, 0, AP_PARAM_FLAG_INTERNAL_USE_ONLY),

    // @Param: _GND_TEMP
    // @DisplayName: ground temperature
    // @Description: User provided ambient ground temperature in degrees Celsius. This is used to improve the calculation of the altitude the vehicle is at. This parameter is not persistent and will be reset to 0 every time the vehicle is rebooted. A value of 0 means use the internal measurement ambient temperature.
    // @Units: degC
    // @Increment: 1
    // @Volatile: True
    // @User: Advanced
    AP_GROUPINFO("_GND_TEMP", 3, AP_Baro, _user_ground_temperature, 0),

    // index 4 reserved for old AP_Int8 version in legacy FRAM
    //AP_GROUPINFO("ALT_OFFSET", 4, AP_Baro, _alt_offset, 0),

    // @Param: _ALT_OFFSET
    // @DisplayName: altitude offset
    // @Description: altitude offset in meters added to barometric altitude. This is used to allow for automatic adjustment of the base barometric altitude by a ground station equipped with a barometer. The value is added to the barometric altitude read by the aircraft. It is automatically reset to 0 when the barometer is calibrated on each reboot or when a preflight calibration is performed.
    // @Units: m
    // @Increment: 0.1
    // @User: Advanced
    AP_GROUPINFO("_ALT_OFFSET", 5, AP_Baro, _alt_offset, 0),

    // @Param: _PRIMARY
    // @DisplayName: Primary barometer
    // @Description: This selects which barometer will be the primary if multiple barometers are found
    // @Values: 0:FirstBaro,1:2ndBaro,2:3rdBaro
    // @User: Advanced
    AP_GROUPINFO("_PRIMARY", 6, AP_Baro, _primary_baro, 0),
#endif // HAL_BUILD_AP_PERIPH

    // @Param: _EXT_BUS
    // @DisplayName: External baro bus
    // @Description: This selects the bus number for looking for an I2C barometer. When set to -1 it will probe all external i2c buses based on the BARO_PROBE_EXT parameter.
    // @Values: -1:Disabled,0:Bus0,1:Bus1,6:Bus6
    // @User: Advanced
    AP_GROUPINFO("_EXT_BUS", 7, AP_Baro, _ext_bus, HAL_BARO_EXTERNAL_BUS_DEFAULT),

    // @Param{Sub}: _SPEC_GRAV
    // @DisplayName: Specific Gravity (For water depth measurement)
    // @Description: This sets the specific gravity of the fluid when flying an underwater ROV.
    // @Values: 1.0:Freshwater,1.024:Saltwater
    AP_GROUPINFO_FRAME("_SPEC_GRAV", 8, AP_Baro, _specific_gravity, 1.0, AP_PARAM_FRAME_SUB),

#if BARO_MAX_INSTANCES > 1
    // @Param: 2_GND_PRESS
    // @DisplayName: Ground Pressure
    // @Description: calibrated ground pressure in Pascals
    // @Units: Pa
    // @Increment: 1
    // @ReadOnly: True
    // @Volatile: True
    // @User: Advanced
    AP_GROUPINFO_FLAGS("2_GND_PRESS", 9, AP_Baro, sensors[1].ground_pressure, 0, AP_PARAM_FLAG_INTERNAL_USE_ONLY),

    // Slot 10 used to be TEMP2
#endif

#if BARO_MAX_INSTANCES > 2
    // @Param: 3_GND_PRESS
    // @DisplayName: Absolute Pressure
    // @Description: calibrated ground pressure in Pascals
    // @Units: Pa
    // @Increment: 1
    // @ReadOnly: True
    // @Volatile: True
    // @User: Advanced
    AP_GROUPINFO_FLAGS("3_GND_PRESS", 11, AP_Baro, sensors[2].ground_pressure, 0, AP_PARAM_FLAG_INTERNAL_USE_ONLY),

    // Slot 12 used to be TEMP3
#endif

    // @Param: _FLTR_RNG
    // @DisplayName: Range in which sample is accepted
    // @Description: This sets the range around the average value that new samples must be within to be accepted. This can help reduce the impact of noise on sensors that are on long I2C cables. The value is a percentage from the average value. A value of zero disables this filter.
    // @Units: %
    // @Range: 0 100
    // @Increment: 1
    AP_GROUPINFO("_FLTR_RNG", 13, AP_Baro, _filter_range, HAL_BARO_FILTER_DEFAULT),

#if AP_BARO_PROBE_EXT_PARAMETER_ENABLED
    // @Param: _PROBE_EXT
    // @DisplayName: External barometers to probe
    // @Description: This sets which types of external i2c barometer to look for. It is a bitmask of barometer types. The I2C buses to probe is based on BARO_EXT_BUS. If BARO_EXT_BUS is -1 then it will probe all external buses, otherwise it will probe just the bus number given in BARO_EXT_BUS.
    // @Bitmask: 0:BMP085,1:BMP280,2:MS5611,3:MS5607,4:MS5637,5:FBM320,6:DPS280,7:LPS25H,8:Keller,9:MS5837,10:BMP388,11:SPL06,12:MSP,13:BMP581
    // @User: Advanced
    AP_GROUPINFO("_PROBE_EXT", 14, AP_Baro, _baro_probe_ext, HAL_BARO_PROBE_EXT_DEFAULT),
#endif

    // @Param: 1_DEVID
    // @DisplayName: Baro ID
    // @Description: Barometer sensor ID, taking into account its type, bus and instance
    // @ReadOnly: True
    // @User: Advanced
    AP_GROUPINFO_FLAGS("1_DEVID", 15, AP_Baro, sensors[0].bus_id, 0, AP_PARAM_FLAG_INTERNAL_USE_ONLY),

#if BARO_MAX_INSTANCES > 1
    // @Param: 2_DEVID
    // @DisplayName: Baro ID2
    // @Description: Barometer2 sensor ID, taking into account its type, bus and instance
    // @ReadOnly: True
    // @User: Advanced
    AP_GROUPINFO_FLAGS("2_DEVID", 16, AP_Baro, sensors[1].bus_id, 0, AP_PARAM_FLAG_INTERNAL_USE_ONLY),
#endif

#if BARO_MAX_INSTANCES > 2
    // @Param: 3_DEVID
    // @DisplayName: Baro ID3
    // @Description: Barometer3 sensor ID, taking into account its type, bus and instance
    // @ReadOnly: True
    // @User: Advanced
    AP_GROUPINFO_FLAGS("3_DEVID", 17, AP_Baro, sensors[2].bus_id, 0, AP_PARAM_FLAG_INTERNAL_USE_ONLY),
#endif

#if HAL_BARO_WIND_COMP_ENABLED
    // @Group: 1_WCF_
    // @Path: AP_Baro_Wind.cpp
    AP_SUBGROUPINFO(sensors[0].wind_coeff, "1_WCF_", 18, AP_Baro, WindCoeff),

#if BARO_MAX_INSTANCES > 1
    // @Group: 2_WCF_
    // @Path: AP_Baro_Wind.cpp
    AP_SUBGROUPINFO(sensors[1].wind_coeff, "2_WCF_", 19, AP_Baro, WindCoeff),
#endif
#if BARO_MAX_INSTANCES > 2
    // @Group: 3_WCF_
    // @Path: AP_Baro_Wind.cpp
    AP_SUBGROUPINFO(sensors[2].wind_coeff, "3_WCF_", 20, AP_Baro, WindCoeff),
#endif
#endif  // HAL_BARO_WIND_COMP_ENABLED

#if AP_FIELD_ELEVATION_ENABLED
    // @Param: _FIELD_ELV
    // @DisplayName: field elevation
    // @Description: User provided field elevation in meters. This is used to improve the calculation of the altitude the vehicle is at. This parameter is not persistent and will be reset to 0 every time the vehicle is rebooted. Changes to this parameter will only be used when disarmed. A value of 0 means the EKF origin height is used for takeoff height above sea level.
    // @Units: m
    // @Increment: 0.1
    // @Volatile: True
    // @User: Advanced
    AP_GROUPINFO("_FIELD_ELV", 22, AP_Baro, _field_elevation, 0),
#endif

#if APM_BUILD_COPTER_OR_HELI || APM_BUILD_TYPE(APM_BUILD_ArduPlane)
    // @Param: _ALTERR_MAX
    // @DisplayName: Altitude error maximum
    // @Description: This is the maximum acceptable altitude discrepancy between GPS altitude and barometric presssure altitude calculated against a standard atmosphere for arming checks to pass. If you are getting an arming error due to this parameter then you may have a faulty or substituted barometer. A common issue is vendors replacing a MS5611 in a "Pixhawk" with a MS5607. If you have that issue then please see BARO_OPTIONS parameter to force the MS5611 to be treated as a MS5607. This check is disabled if the value is zero.
    // @Units: m
    // @Increment: 1
    // @Range: 0 5000
    // @User: Advanced
    AP_GROUPINFO("_ALTERR_MAX", 23, AP_Baro, _alt_error_max, 2000),

    // @Param: _OPTIONS
    // @DisplayName: Barometer options
    // @Description: Barometer options
    // @Bitmask: 0:Treat MS5611 as MS5607
    // @User: Advanced
    AP_GROUPINFO("_OPTIONS", 24, AP_Baro, _options, 0),
#endif
    
    AP_GROUPEND
};

// singleton instance
AP_Baro *AP_Baro::_singleton;

/*
  AP_Baro constructor
 */
AP_Baro::AP_Baro()
{
    _singleton = this;

    AP_Param::setup_object_defaults(this, var_info);
    _field_elevation_active = _field_elevation;
}

// calibrate the barometer. This must be called at least once before
// the altitude() or climb_rate() interfaces can be used
void AP_Baro::calibrate(bool save)
{
    // start by assuming all sensors are calibrated (for healthy() test)
    for (uint8_t i=0; i<_num_sensors; i++) {
        sensors[i].calibrated = true;
        sensors[i].alt_ok = true;
    }

    if (hal.util->was_watchdog_reset()) {
        GCS_SEND_TEXT(MAV_SEVERITY_INFO, "Baro: skipping calibration after WDG reset");
        return;
    }

#if AP_SIM_BARO_ENABLED
    if (AP::sitl()->baro_count == 0) {
        return;
    }
#endif

    #ifdef HAL_BARO_ALLOW_INIT_NO_BARO
    if (_num_drivers == 0 || _num_sensors == 0 || drivers[0] == nullptr) {
            GCS_SEND_TEXT(MAV_SEVERITY_INFO, "Baro: no sensors found, skipping calibration");
            return;
    }
    #endif
    
    GCS_SEND_TEXT(MAV_SEVERITY_INFO, "Calibrating barometer");

    // reset the altitude offset when we calibrate. The altitude
    // offset is supposed to be for within a flight
    _alt_offset.set_and_save(0);

    // let the barometer settle for a full second after startup
    // the MS5611 reads quite a long way off for the first second,
    // leading to about 1m of error if we don't wait
    for (uint8_t i = 0; i < 10; i++) {
        uint32_t tstart = AP_HAL::millis();
        do {
            update();
            if (AP_HAL::millis() - tstart > 500) {
                AP_BoardConfig::config_error("Baro: unable to calibrate");
            }
            hal.scheduler->delay(10);
        } while (!healthy());
        hal.scheduler->delay(100);
    }

    // now average over 5 values for the ground pressure settings
    float sum_pressure[BARO_MAX_INSTANCES] = {0};
    uint8_t count[BARO_MAX_INSTANCES] = {0};
    const uint8_t num_samples = 5;

    for (uint8_t c = 0; c < num_samples; c++) {
        uint32_t tstart = AP_HAL::millis();
        do {
            update();
            if (AP_HAL::millis() - tstart > 500) {
                AP_BoardConfig::config_error("Baro: unable to calibrate");
            }
        } while (!healthy());
        for (uint8_t i=0; i<_num_sensors; i++) {
            if (healthy(i)) {
                sum_pressure[i] += sensors[i].pressure;
                count[i] += 1;
            }
        }
        hal.scheduler->delay(100);
    }
    for (uint8_t i=0; i<_num_sensors; i++) {
        if (count[i] == 0) {
            sensors[i].calibrated = false;
        } else {
            if (save) {
                float p0_sealevel = get_sealevel_pressure(sum_pressure[i] / count[i], _field_elevation_active);
                sensors[i].ground_pressure.set_and_save(p0_sealevel);
            }
        }
    }

    _guessed_ground_temperature = get_external_temperature();

    // panic if all sensors are not calibrated
    uint8_t num_calibrated = 0;
    for (uint8_t i=0; i<_num_sensors; i++) {
        if (sensors[i].calibrated) {
            GCS_SEND_TEXT(MAV_SEVERITY_INFO, "Barometer %u calibration complete", i+1);
            num_calibrated++;
        }
    }
    if (num_calibrated) {
        return;
    }
    AP_BoardConfig::config_error("Baro: all sensors uncalibrated");
}

/*
   update the barometer calibration
   this updates the baro ground calibration to the current values. It
   can be used before arming to keep the baro well calibrated
*/
void AP_Baro::update_calibration()
{
    const uint32_t now = AP_HAL::millis();
    const bool do_notify = now - _last_notify_ms > 10000;
    if (do_notify) {
        _last_notify_ms = now;
    }
    for (uint8_t i=0; i<_num_sensors; i++) {
        if (healthy(i)) {
            float corrected_pressure = get_sealevel_pressure(get_pressure(i) + sensors[i].p_correction, _field_elevation_active);
            sensors[i].ground_pressure.set(corrected_pressure);
        }

        // don't notify the GCS too rapidly or we flood the link
        if (do_notify) {
            sensors[i].ground_pressure.notify();
        }
    }

    // always update the guessed ground temp
    _guessed_ground_temperature = get_external_temperature();
}


// return air density / sea level density - decreases as altitude climbs
float AP_Baro::_get_air_density_ratio(void)
{
    const float eas2tas = _get_EAS2TAS();
    if (eas2tas > 0.0f) {
        return 1.0f/(sq(eas2tas));
    } else {
        return 1.0f;
    }
}

// return current climb_rate estimate relative to time that calibrate()
// was called. Returns climb rate in meters/s, positive means up
// note that this relies on read() being called regularly to get new data
float AP_Baro::get_climb_rate(void)
{
    // we use a 7 point derivative filter on the climb rate. This seems
    // to produce somewhat reasonable results on real hardware
    return _climb_rate_filter.slope() * 1.0e3f;
}

// returns the ground temperature in degrees C, selecting either a user
// provided one, or the internal estimate
float AP_Baro::get_ground_temperature(void) const
{
    if (is_zero(_user_ground_temperature)) {
        return _guessed_ground_temperature;
    } else {
        return _user_ground_temperature;
    }
}


/*
  set external temperature to be used for calibration (degrees C)
 */
void AP_Baro::set_external_temperature(float temperature)
{
    _external_temperature = temperature;
    _last_external_temperature_ms = AP_HAL::millis();
}

/*
  get the temperature in degrees C to be used for calibration purposes
 */
float AP_Baro::get_external_temperature(const uint8_t instance) const
{
    // if we have a recent external temperature then use it
    if (_last_external_temperature_ms != 0 && AP_HAL::millis() - _last_external_temperature_ms < 10000) {
        return _external_temperature;
    }
    
#ifndef HAL_BUILD_AP_PERIPH
#if AP_AIRSPEED_ENABLED
    // if we don't have an external temperature then try to use temperature
    // from the airspeed sensor
    AP_Airspeed *airspeed = AP_Airspeed::get_singleton();
    if (airspeed != nullptr) {
        float temperature;
        if (airspeed->healthy() && airspeed->get_temperature(temperature)) {
            return temperature;
        }
    }
#endif
#endif
    
    // if we don't have an external temperature and airspeed temperature
    // then use the minimum of the barometer temperature and 35 degrees C.
    // The reason for not just using the baro temperature is it tends to read high,
    // often 30 degrees above the actual temperature. That means the
    // EAS2TAS tends to be off by quite a large margin, as well as
    // the calculation of altitude difference between two pressures
    // reporting a high temperature will cause the aircraft to
    // estimate itself as flying higher then it actually is.
    return MIN(get_temperature(instance), INTERNAL_TEMPERATURE_CLAMP);
}


bool AP_Baro::_add_backend(AP_Baro_Backend *backend)
{
    if (!backend) {
        return false;
    }
    if (_num_drivers >= BARO_MAX_DRIVERS) {
        AP_HAL::panic("Too many barometer drivers");
    }
    drivers[_num_drivers++] = backend;
    return true;
}

/*
  wrapper around hal.i2c_mgr->get_device() that prevents duplicate devices being opened
 */
bool AP_Baro::_have_i2c_driver(uint8_t bus, uint8_t address) const
{
    for (int i=0; i<_num_drivers; ++i) {
        if (AP_HAL::Device::make_bus_id(AP_HAL::Device::BUS_TYPE_I2C, bus, address, 0) ==
            AP_HAL::Device::change_bus_id(uint32_t(sensors[i].bus_id.get()), 0)) {
            // device already has been defined.
            return true;
        }
    }
    return false;
}

/*
  macro to add a backend with check for too many sensors
 We don't try to start more than the maximum allowed
 */
#define ADD_BACKEND(backend) \
    do { _add_backend(backend);     \
       if (_num_drivers == BARO_MAX_DRIVERS || \
          _num_sensors == BARO_MAX_INSTANCES) { \
          return; \
       } \
    } while (0)

/*
  initialise the barometer object, loading backend drivers
 */
void AP_Baro::init(void)
{
    init_done = true;

    // always set field elevation to zero on reboot in the case user
    // fails to update.  TBD automate sanity checking error bounds on
    // on previously saved value at new location etc.
    if (!is_zero(_field_elevation)) {
        _field_elevation.set_and_save(0.0f);
        _field_elevation.notify();
    }

    // zero bus IDs before probing
    for (uint8_t i = 0; i < BARO_MAX_INSTANCES; i++) {
        sensors[i].bus_id.set(0);
    }

#if AP_SIM_BARO_ENABLED
    SITL::SIM *sitl = AP::sitl();
    if (sitl == nullptr) {
        AP_HAL::panic("No SITL pointer");
    }
#if !AP_TEST_DRONECAN_DRIVERS
    // use dronecan instances instead of SITL instances
    for(uint8_t i = 0; i < sitl->baro_count; i++) {
        ADD_BACKEND(NEW_NOTHROW AP_Baro_SITL(*this));
    }
#endif
#endif

#if AP_BARO_DRONECAN_ENABLED
    // Detect UAVCAN Modules, try as many times as there are driver slots
    for (uint8_t i = 0; i < BARO_MAX_DRIVERS; i++) {
        ADD_BACKEND(AP_Baro_DroneCAN::probe(*this));
    }
#endif

#if AP_BARO_EXTERNALAHRS_ENABLED
    const int8_t serial_port = AP::externalAHRS().get_port(AP_ExternalAHRS::AvailableSensor::BARO);
    if (serial_port >= 0) {
        ADD_BACKEND(NEW_NOTHROW AP_Baro_ExternalAHRS(*this, serial_port));
    }
#endif

// macro for use by HAL_INS_PROBE_LIST
#define GET_I2C_DEVICE(bus, address) _have_i2c_driver(bus, address)?nullptr:hal.i2c_mgr->get_device(bus, address)

#if AP_SIM_BARO_ENABLED
#if CONFIG_HAL_BOARD == HAL_BOARD_SITL && AP_BARO_MS56XX_ENABLED
    ADD_BACKEND(AP_Baro_MS56XX::probe(*this,
                                      std::move(GET_I2C_DEVICE(_ext_bus, HAL_BARO_MS5611_I2C_ADDR))));
#endif
    // do not probe for other drivers when using simulation:
    return;
#endif

#if defined(HAL_BARO_PROBE_LIST)
    // probe list from BARO lines in hwdef.dat
    HAL_BARO_PROBE_LIST;
#elif AP_FEATURE_BOARD_DETECT
    switch (AP_BoardConfig::get_board_type()) {
    case AP_BoardConfig::PX4_BOARD_PX4V1:
#if AP_BARO_MS56XX_ENABLED && defined(HAL_BARO_MS5611_I2C_BUS)
        ADD_BACKEND(AP_Baro_MS56XX::probe(*this,
                                          std::move(GET_I2C_DEVICE(HAL_BARO_MS5611_I2C_BUS, HAL_BARO_MS5611_I2C_ADDR))));
#endif
        break;

    case AP_BoardConfig::PX4_BOARD_PIXHAWK:
    case AP_BoardConfig::PX4_BOARD_PHMINI:
    case AP_BoardConfig::PX4_BOARD_AUAV21:
    case AP_BoardConfig::PX4_BOARD_PH2SLIM:
    case AP_BoardConfig::PX4_BOARD_PIXHAWK_PRO:
#if AP_BARO_MS56XX_ENABLED
        ADD_BACKEND(AP_Baro_MS56XX::probe(*this,
                                          std::move(hal.spi->get_device(HAL_BARO_MS5611_NAME))));
#endif
        break;

    case AP_BoardConfig::PX4_BOARD_PIXHAWK2:
    case AP_BoardConfig::PX4_BOARD_SP01:
#if AP_BARO_MS56XX_ENABLED
        ADD_BACKEND(AP_Baro_MS56XX::probe(*this,
                                          std::move(hal.spi->get_device(HAL_BARO_MS5611_SPI_EXT_NAME))));
        ADD_BACKEND(AP_Baro_MS56XX::probe(*this,
                                          std::move(hal.spi->get_device(HAL_BARO_MS5611_NAME))));
#endif
        break;

    case AP_BoardConfig::PX4_BOARD_MINDPXV2:
#if AP_BARO_MS56XX_ENABLED
        ADD_BACKEND(AP_Baro_MS56XX::probe(*this,
                                          std::move(hal.spi->get_device(HAL_BARO_MS5611_NAME))));
#endif
        break;

    case AP_BoardConfig::PX4_BOARD_AEROFC:
#if AP_BARO_MS56XX_ENABLED
#ifdef HAL_BARO_MS5607_I2C_BUS
        ADD_BACKEND(AP_Baro_MS56XX::probe(*this,
                                          std::move(GET_I2C_DEVICE(HAL_BARO_MS5607_I2C_BUS, HAL_BARO_MS5607_I2C_ADDR)),
                                          AP_Baro_MS56XX::BARO_MS5607));
#endif
#endif  // AP_BARO_MS56XX_ENABLED
        break;

    case AP_BoardConfig::VRX_BOARD_BRAIN54:
#if AP_BARO_MS56XX_ENABLED
        ADD_BACKEND(AP_Baro_MS56XX::probe(*this,
                                          std::move(hal.spi->get_device(HAL_BARO_MS5611_NAME))));
        ADD_BACKEND(AP_Baro_MS56XX::probe(*this,
                                          std::move(hal.spi->get_device(HAL_BARO_MS5611_SPI_EXT_NAME))));
#ifdef HAL_BARO_MS5611_SPI_IMU_NAME
        ADD_BACKEND(AP_Baro_MS56XX::probe(*this,
                                          std::move(hal.spi->get_device(HAL_BARO_MS5611_SPI_IMU_NAME))));
#endif
#endif  // AP_BARO_MS56XX_ENABLED
        break;

    case AP_BoardConfig::VRX_BOARD_BRAIN51:
    case AP_BoardConfig::VRX_BOARD_BRAIN52:
    case AP_BoardConfig::VRX_BOARD_BRAIN52E:
    case AP_BoardConfig::VRX_BOARD_CORE10:
    case AP_BoardConfig::VRX_BOARD_UBRAIN51:
    case AP_BoardConfig::VRX_BOARD_UBRAIN52:
#if AP_BARO_MS56XX_ENABLED
        ADD_BACKEND(AP_Baro_MS56XX::probe(*this,
                                          std::move(hal.spi->get_device(HAL_BARO_MS5611_NAME))));
#endif  // AP_BARO_MS56XX_ENABLED
        break;

    case AP_BoardConfig::PX4_BOARD_PCNC1:
#if AP_BARO_ICM20789_ENABLED
        ADD_BACKEND(AP_Baro_ICM20789::probe(*this,
                                            std::move(GET_I2C_DEVICE(1, 0x63)),
                                            std::move(hal.spi->get_device(HAL_INS_MPU60x0_NAME))));
#endif
        break;

    case AP_BoardConfig::PX4_BOARD_FMUV5:
    case AP_BoardConfig::PX4_BOARD_FMUV6:
#if AP_BARO_MS56XX_ENABLED
        ADD_BACKEND(AP_Baro_MS56XX::probe(*this,
                                          std::move(hal.spi->get_device(HAL_BARO_MS5611_NAME))));
#endif
        break;

    default:
        break;
    }
#elif HAL_BARO_DEFAULT == HAL_BARO_LPS25H_IMU_I2C
	ADD_BACKEND(AP_Baro_LPS2XH::probe_InvensenseIMU(*this,
                                                    std::move(GET_I2C_DEVICE(HAL_BARO_LPS25H_I2C_BUS, HAL_BARO_LPS25H_I2C_ADDR)),
                                                    HAL_BARO_LPS25H_I2C_IMU_ADDR));
#elif HAL_BARO_DEFAULT == HAL_BARO_20789_I2C_I2C
    ADD_BACKEND(AP_Baro_ICM20789::probe(*this,
                                        std::move(GET_I2C_DEVICE(HAL_BARO_20789_I2C_BUS, HAL_BARO_20789_I2C_ADDR_PRESS)),
                                        std::move(GET_I2C_DEVICE(HAL_BARO_20789_I2C_BUS, HAL_BARO_20789_I2C_ADDR_ICM))));
#elif HAL_BARO_DEFAULT == HAL_BARO_20789_I2C_SPI
    ADD_BACKEND(AP_Baro_ICM20789::probe(*this,
                                        std::move(GET_I2C_DEVICE(HAL_BARO_20789_I2C_BUS, HAL_BARO_20789_I2C_ADDR_PRESS)),
                                        std::move(hal.spi->get_device("icm20789"))));
#endif

    // can optionally have baro on I2C too
    if (_ext_bus >= 0) {
#if APM_BUILD_TYPE(APM_BUILD_ArduSub)
#if AP_BARO_MS56XX_ENABLED
        ADD_BACKEND(AP_Baro_MS56XX::probe(*this,
                                          std::move(GET_I2C_DEVICE(_ext_bus, HAL_BARO_MS5837_I2C_ADDR)), AP_Baro_MS56XX::BARO_MS5837));
#endif
#if AP_BARO_KELLERLD_ENABLED
        ADD_BACKEND(AP_Baro_KellerLD::probe(*this,
                                          std::move(GET_I2C_DEVICE(_ext_bus, HAL_BARO_KELLERLD_I2C_ADDR))));
#endif
#else
#if AP_BARO_MS56XX_ENABLED
        ADD_BACKEND(AP_Baro_MS56XX::probe(*this,
                                          std::move(GET_I2C_DEVICE(_ext_bus, HAL_BARO_MS5611_I2C_ADDR))));
#endif
#endif
    }

#if AP_BARO_PROBE_EXTERNAL_I2C_BUSES
    _probe_i2c_barometers();
#endif

#if AP_BARO_MSP_ENABLED
    if ((_baro_probe_ext.get() & PROBE_MSP) && msp_instance_mask == 0) {
        // allow for late addition of MSP sensor
        msp_instance_mask |= 1;
    }
    for (uint8_t i=0; i<8; i++) {
        if (msp_instance_mask & (1U<<i)) {
            ADD_BACKEND(NEW_NOTHROW AP_Baro_MSP(*this, i));
        }
    }
#endif

#if !defined(HAL_BARO_ALLOW_INIT_NO_BARO) // most boards requires external baro
#if AP_SIM_BARO_ENABLED
    if (sitl->baro_count == 0) {
        return;
    }
#endif
    if (_num_drivers == 0 || _num_sensors == 0 || drivers[0] == nullptr) {
        AP_BoardConfig::config_error("Baro: unable to initialise driver");
    }
#endif
#ifdef HAL_BUILD_AP_PERIPH
    // AP_Periph always is set calibrated. We only want the pressure,
    // so ground calibration is unnecessary
    for (uint8_t i=0; i<_num_sensors; i++) {
        sensors[i].calibrated = true;
        sensors[i].alt_ok = true;
    }
#endif
}

/*
  probe all the i2c barometers enabled with BARO_PROBE_EXT. This is
  used on boards without a builtin barometer
 */
void AP_Baro::_probe_i2c_barometers(void)
{
    uint32_t probe = _baro_probe_ext.get();
    (void)probe;  // may be unused if most baros compiled out
    uint32_t mask = hal.i2c_mgr->get_bus_mask_external();
    if (AP_BoardConfig::get_board_type() == AP_BoardConfig::PX4_BOARD_PIXHAWK2) {
        // for the purpose of baro probing, treat CubeBlack internal i2c as external. It has
        // no internal i2c baros, so this is safe
        mask |= hal.i2c_mgr->get_bus_mask_internal();
    }
    // if the user has set BARO_EXT_BUS then probe the bus given by that parameter
    int8_t ext_bus = _ext_bus;
    if (ext_bus >= 0) {
        mask = 1U << (uint8_t)ext_bus;
    }

    static const struct BaroProbeSpec {
        uint32_t bit;
        AP_Baro_Backend* (*probefn)(AP_Baro&, AP_HAL::OwnPtr<AP_HAL::Device>);
        uint8_t addr;
    } baroprobespec[] {
#if AP_BARO_BMP085_ENABLED
        { PROBE_BMP085, AP_Baro_BMP085::probe, HAL_BARO_BMP085_I2C_ADDR },
#endif
#if AP_BARO_BMP280_ENABLED
        { PROBE_BMP280, AP_Baro_BMP280::probe, HAL_BARO_BMP280_I2C_ADDR },
        { PROBE_BMP280, AP_Baro_BMP280::probe, HAL_BARO_BMP280_I2C_ADDR2 },
#endif
#if AP_BARO_SPL06_ENABLED
        { PROBE_SPL06, AP_Baro_SPL06::probe, HAL_BARO_SPL06_I2C_ADDR },
        { PROBE_SPL06, AP_Baro_SPL06::probe, HAL_BARO_SPL06_I2C_ADDR2 },
#endif
#if AP_BARO_BMP388_ENABLED
        { PROBE_BMP388, AP_Baro_BMP388::probe, HAL_BARO_BMP388_I2C_ADDR },
        { PROBE_BMP388, AP_Baro_BMP388::probe, HAL_BARO_BMP388_I2C_ADDR2 },
#endif
#if AP_BARO_BMP581_ENABLED
        { PROBE_BMP581, AP_Baro_BMP581::probe, HAL_BARO_BMP581_I2C_ADDR },
        { PROBE_BMP581, AP_Baro_BMP581::probe, HAL_BARO_BMP581_I2C_ADDR2 },
#endif
#if AP_BARO_MS56XX_ENABLED
        { PROBE_MS5611, AP_Baro_MS56XX::probe_5611, HAL_BARO_MS5611_I2C_ADDR },
        { PROBE_MS5611, AP_Baro_MS56XX::probe_5611, HAL_BARO_MS5611_I2C_ADDR2 },
        { PROBE_MS5607, AP_Baro_MS56XX::probe_5607, HAL_BARO_MS5607_I2C_ADDR },
        { PROBE_MS5637, AP_Baro_MS56XX::probe_5637, HAL_BARO_MS5637_I2C_ADDR },
#endif
#if AP_BARO_FBM320_ENABLED
        { PROBE_FBM320, AP_Baro_FBM320::probe, HAL_BARO_FBM320_I2C_ADDR },
        { PROBE_FBM320, AP_Baro_FBM320::probe, HAL_BARO_FBM320_I2C_ADDR2 },
#endif
#if AP_BARO_DPS280_ENABLED
        { PROBE_DPS280, AP_Baro_DPS280::probe_280, HAL_BARO_DPS280_I2C_ADDR },
        { PROBE_DPS280, AP_Baro_DPS280::probe_280, HAL_BARO_DPS280_I2C_ADDR2 },
#endif
#if AP_BARO_LPS2XH_ENABLED
        { PROBE_LPS25H, AP_Baro_LPS2XH::probe, HAL_BARO_LPS25H_I2C_ADDR },
#endif

#if APM_BUILD_TYPE(APM_BUILD_ArduSub)
#if AP_BARO_KELLERLD_ENABLED
        { PROBE_KELLER, AP_Baro_KellerLD::probe, HAL_BARO_KELLERLD_I2C_ADDR },
#endif
#if AP_BARO_MS56XX_ENABLED
        { PROBE_MS5837, AP_Baro_MS56XX::probe_5837, HAL_BARO_MS5837_I2C_ADDR },
#endif
#endif  // APM_BUILD_TYPE(APM_BUILD_ArduSub)
    };

    for (const auto &spec : baroprobespec) {
        if (!(probe & spec.bit)) {
            // not in mask to be probed for
            continue;
        }
        FOREACH_I2C_MASK(i, mask) {
            ADD_BACKEND(spec.probefn(*this, std::move(GET_I2C_DEVICE(i, spec.addr))));
        }
    }
}

#if HAL_LOGGING_ENABLED
bool AP_Baro::should_log() const
{
    AP_Logger *logger = AP_Logger::get_singleton();
    if (logger == nullptr) {
        return false;
    }
    if (_log_baro_bit == (uint32_t)-1) {
        return false;
    }
    if (!logger->should_log(_log_baro_bit)) {
        return false;
    }
    return true;
}
#endif

/*
  call update on all drivers
 */
void AP_Baro::update(void)
{
    WITH_SEMAPHORE(_rsem);

    if (fabsf(_alt_offset - _alt_offset_active) > 0.01f) {
        // If there's more than 1cm difference then slowly slew to it via LPF.
        // The EKF does not like step inputs so this keeps it happy.
        _alt_offset_active = (0.98f*_alt_offset_active) + (0.02f*_alt_offset);
    } else {
        _alt_offset_active = _alt_offset;
    }

#if HAL_LOGGING_ENABLED
    bool old_primary_healthy = sensors[_primary].healthy;
#endif

    for (uint8_t i=0; i<_num_drivers; i++) {
        drivers[i]->backend_update(i);
    }

    for (uint8_t i=0; i<_num_sensors; i++) {
        if (sensors[i].healthy) {
            // update altitude calculation
            float ground_pressure = sensors[i].ground_pressure;
            if (!is_positive(ground_pressure) || isnan(ground_pressure) || isinf(ground_pressure)) {
                sensors[i].ground_pressure.set(sensors[i].pressure);
            }
            float altitude = sensors[i].altitude;
            float corrected_pressure = sensors[i].pressure + sensors[i].p_correction;
            if (sensors[i].type == BARO_TYPE_AIR) {
#if HAL_BARO_WIND_COMP_ENABLED
                corrected_pressure -= wind_pressure_correction(i);
#endif
                altitude = get_altitude_difference(sensors[i].ground_pressure, corrected_pressure);

                // the ground pressure is references against the field elevation
                altitude -= _field_elevation_active;
            } else if (sensors[i].type == BARO_TYPE_WATER) {
                //101325Pa is sea level air pressure, 9800 Pascal/ m depth in water.
                //No temperature or depth compensation for density of water.
                altitude = (sensors[i].ground_pressure - corrected_pressure) / 9800.0f / _specific_gravity;
            }
            // sanity check altitude
            sensors[i].alt_ok = !(isnan(altitude) || isinf(altitude));
            if (sensors[i].alt_ok) {
                sensors[i].altitude = altitude + _alt_offset_active;
            }
        }
    }

    // ensure the climb rate filter is updated
    if (healthy()) {
        _climb_rate_filter.update(get_altitude(), get_last_update());
    }

    // choose primary sensor
    if (_primary_baro >= 0 && _primary_baro < _num_sensors && healthy(_primary_baro)) {
        _primary = _primary_baro;
    } else {
        _primary = 0;
        for (uint8_t i=0; i<_num_sensors; i++) {
            if (healthy(i)) {
                _primary = i;
                break;
            }
        }
    }
#if AP_FIELD_ELEVATION_ENABLED
    update_field_elevation();
#endif

    // logging
#if HAL_LOGGING_ENABLED
    if (should_log()) {
        Write_Baro();
    }

#define MASK_LOG_ANY                    0xFFFF

    // log sensor healthy state change:
    if (sensors[_primary].healthy != old_primary_healthy) {
        if (AP::logger().should_log(MASK_LOG_ANY)) {
            const LogErrorCode code = sensors[_primary].healthy ? LogErrorCode::ERROR_RESOLVED : LogErrorCode::UNHEALTHY;
            AP::logger().Write_Error(LogErrorSubsystem::BARO, code);
        }
    }
#endif
}

#ifdef HAL_BUILD_AP_PERIPH
// calibration and alt check not valid for AP_Periph
bool AP_Baro::healthy(uint8_t instance) const {
    // If the requested instance was outside max instances it is not healthy (it doesn't exist)
    if (instance >= BARO_MAX_INSTANCES) {
        return false;
    }
    return sensors[instance].healthy;
}
#else
bool AP_Baro::healthy(uint8_t instance) const {
    // If the requested instance was outside max instances it is not healthy (it doesn't exist)
    if (instance >= BARO_MAX_INSTANCES) {
        return false;
    }
    return sensors[instance].healthy && sensors[instance].alt_ok && sensors[instance].calibrated;
}
#endif

/*
  update field elevation value
 */
void AP_Baro::update_field_elevation(void)
{
#if AP_FIELD_ELEVATION_ENABLED
    const uint32_t now_ms = AP_HAL::millis();
    bool new_field_elev = false;
    const bool armed = hal.util->get_soft_armed();
    if (now_ms - _field_elevation_last_ms >= 1000) {
        if (is_zero(_field_elevation_active) &&
            is_zero(_field_elevation)) {
            // auto-set based on origin
            Location origin;
            if (!armed && AP::ahrs().get_origin(origin)) {
                _field_elevation_active = origin.alt * 0.01;
                new_field_elev = true;
            }
        } else if (fabsf(_field_elevation_active-_field_elevation) > 1.0 &&
                   !is_zero(_field_elevation)) {
            // user has set field elevation
            if (!armed) {
                _field_elevation_active = _field_elevation;
                new_field_elev = true;
            } else {
                _field_elevation.set(_field_elevation_active);
                _field_elevation.notify();
                GCS_SEND_TEXT(MAV_SEVERITY_ALERT, "Failed to Set Field Elevation: Armed");
            }
        }
    }
    if (new_field_elev && !armed) {
        _field_elevation_last_ms = now_ms;
        AP::ahrs().resetHeightDatum();
        update_calibration();
        GCS_SEND_TEXT(MAV_SEVERITY_INFO, "Field Elevation Set: %.0fm", _field_elevation_active);
    }
#endif
}


/* register a new sensor, claiming a sensor slot. If we are out of
   slots it will panic
*/
uint8_t AP_Baro::register_sensor(void)
{
    if (_num_sensors >= BARO_MAX_INSTANCES) {
        AP_HAL::panic("Too many barometers");
    }
    return _num_sensors++;
}


/*
  check if all barometers are healthy
 */
bool AP_Baro::all_healthy(void) const
{
     for (uint8_t i=0; i<_num_sensors; i++) {
         if (!healthy(i)) {
             return false;
         }
     }
     return _num_sensors > 0;
}

// set a pressure correction from AP_TempCalibration
void AP_Baro::set_pressure_correction(uint8_t instance, float p_correction)
{
    if (instance < _num_sensors) {
        sensors[instance].p_correction = p_correction;
    }
}

#if AP_BARO_MSP_ENABLED
/*
  handle MSP barometer data
 */
void AP_Baro::handle_msp(const MSP::msp_baro_data_message_t &pkt)
{
    if (pkt.instance > 7) {
        return;
    }
    if (!init_done) {
        msp_instance_mask |= 1U<<pkt.instance;
    } else if (msp_instance_mask != 0) {
        for (uint8_t i=0; i<_num_drivers; i++) {
            drivers[i]->handle_msp(pkt);
        }
    }
}
#endif

#if AP_BARO_EXTERNALAHRS_ENABLED
/*
  handle ExternalAHRS barometer data
 */
void AP_Baro::handle_external(const AP_ExternalAHRS::baro_data_message_t &pkt)
{
    for (uint8_t i=0; i<_num_drivers; i++) {
        drivers[i]->handle_external(pkt);
    }
}
#endif  // AP_BARO_EXTERNALAHRS_ENABLED

// returns false if we fail arming checks, in which case the buffer will be populated with a failure message
bool AP_Baro::arming_checks(size_t buflen, char *buffer) const
{
    if (!all_healthy()) {
        hal.util->snprintf(buffer, buflen, "not healthy");
        return false;
    }

#if APM_BUILD_COPTER_OR_HELI || APM_BUILD_TYPE(APM_BUILD_ArduPlane)
    /*
      check for a pressure altitude discrepancy between GPS alt and
      baro alt this catches bad barometers, such as when a MS5607 has
      been substituted for a MS5611
     */
    const auto &gps = AP::gps();
    if (_alt_error_max > 0 && gps.status() >= AP_GPS::GPS_Status::GPS_OK_FIX_3D) {
        const float alt_amsl = gps.location().alt*0.01;
        // note the addition of _field_elevation_active as this is subtracted in get_altitude_difference()
        const float alt_pressure = get_altitude_difference(SSL_AIR_PRESSURE, get_pressure());
        const float error = fabsf(alt_amsl - alt_pressure);
        if (error > _alt_error_max) {
            hal.util->snprintf(buffer, buflen, "GPS alt error %.0fm (see BARO_ALTERR_MAX)", error);
            return false;
        }
    }
#endif
    return true;
}

namespace AP {

AP_Baro &baro()
{
    return *AP_Baro::get_singleton();
}

};
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 #pragma once

#include "AP_Baro_config.h"

#include <AP_HAL/AP_HAL.h>
#include <AP_Param/AP_Param.h>
#include <AP_Math/AP_Math.h>
#include <Filter/DerivativeFilter.h>
#include <AP_MSP/msp.h>
#include <AP_ExternalAHRS/AP_ExternalAHRS.h>

// maximum number of sensor instances
#ifndef BARO_MAX_INSTANCES
#define BARO_MAX_INSTANCES 3
#endif

// maximum number of drivers. Note that a single driver can provide
// multiple sensor instances
#define BARO_MAX_DRIVERS 3

// timeouts for health reporting
#define BARO_TIMEOUT_MS                 500     // timeout in ms since last successful read
#define BARO_DATA_CHANGE_TIMEOUT_MS     2000    // timeout in ms since last successful read that involved temperature of pressure changing

class AP_Baro_Backend;

class AP_Baro
{
    friend class AP_Baro_Backend;
    friend class AP_Baro_SITL; // for access to sensors[]
    friend class AP_Baro_DroneCAN; // for access to sensors[]

public:
    AP_Baro();

    /* Do not allow copies */
    CLASS_NO_COPY(AP_Baro);

    // get singleton
    static AP_Baro *get_singleton(void) {
        return _singleton;
    }

    // barometer types
    typedef enum {
        BARO_TYPE_AIR,
        BARO_TYPE_WATER
    } baro_type_t;

    // initialise the barometer object, loading backend drivers
    void init(void);

    // update the barometer object, asking backends to push data to
    // the frontend
    void update(void);

    // healthy - returns true if sensor and derived altitude are good
    bool healthy(void) const { return healthy(_primary); }
#ifdef HAL_BUILD_AP_PERIPH
    // calibration and alt check not valid for AP_Periph
    bool healthy(uint8_t instance) const;
#else
    bool healthy(uint8_t instance) const;
#endif

    // check if all baros are healthy - used for SYS_STATUS report
    bool all_healthy(void) const;

    // returns false if we fail arming checks, in which case the buffer will be populated with a failure message
    bool arming_checks(size_t buflen, char *buffer) const;

    // get primary sensor
    uint8_t get_primary(void) const { return _primary; }

    // pressure in Pascal. Divide by 100 for millibars or hectopascals
    float get_pressure(void) const { return get_pressure(_primary); }
    float get_pressure(uint8_t instance) const { return sensors[instance].pressure; }
#if HAL_BARO_WIND_COMP_ENABLED
    // dynamic pressure in Pascal. Divide by 100 for millibars or hectopascals
    const Vector3f& get_dynamic_pressure(uint8_t instance) const { return sensors[instance].dynamic_pressure; }
#endif

    // temperature in degrees C
    float get_temperature(void) const { return get_temperature(_primary); }
    float get_temperature(uint8_t instance) const { return sensors[instance].temperature; }

    // get pressure correction in Pascal. Divide by 100 for millibars or hectopascals
    float get_pressure_correction(void) const { return get_pressure_correction(_primary); }
    float get_pressure_correction(uint8_t instance) const { return sensors[instance].p_correction; }

    // calibrate the barometer. This must be called on startup if the
    // altitude/climb_rate/acceleration interfaces are ever used
    void calibrate(bool save=true);

    // update the barometer calibration to the current pressure. Can
    // be used for incremental preflight update of baro
    void update_calibration(void);

    // get current altitude in meters relative to altitude at the time
    // of the last calibrate() call
    float get_altitude(void) const { return get_altitude(_primary); }
    float get_altitude(uint8_t instance) const { return sensors[instance].altitude; }

    // get altitude above mean sea level
    float get_altitude_AMSL(uint8_t instance) const { return get_altitude(instance) + _field_elevation_active; }
    float get_altitude_AMSL(void) const { return get_altitude_AMSL(_primary); }

    // returns which i2c bus is considered "the" external bus
    uint8_t external_bus() const { return _ext_bus; }

    // Atmospheric Model Functions
    static float geometric_alt_to_geopotential(float alt);
    static float geopotential_alt_to_geometric(float alt);

    float get_temperature_from_altitude(float alt) const;
    float get_altitude_from_pressure(float pressure) const;

    // EAS2TAS for SITL
    static float get_EAS2TAS_for_alt_amsl(float alt_amsl);

#if AP_BARO_1976_STANDARD_ATMOSPHERE_ENABLED
    // lookup expected pressure for a given altitude. Used for SITL backend
    static void get_pressure_temperature_for_alt_amsl(float alt_amsl, float &pressure, float &temperature_K);
#endif

    // lookup expected temperature in degrees C for a given altitude. Used for SITL backend
    static float get_temperatureC_for_alt_amsl(const float alt_amsl);

    // lookup expected pressure in Pa for a given altitude. Used for SITL backend
    static float get_pressure_for_alt_amsl(const float alt_amsl);
    
    // get air density for SITL
    static float get_air_density_for_alt_amsl(float alt_amsl);

    // get altitude difference in meters relative given a base
    // pressure in Pascal
    float get_altitude_difference(float base_pressure, float pressure) const;

    // get sea level pressure relative to 1976 standard atmosphere model
    // pressure in Pascal
    float get_sealevel_pressure(float pressure, float altitude) const;

    // get scale factor required to convert equivalent to true
    // airspeed. This should only be used to update the AHRS value
    // once per loop. Please use AP::ahrs().get_EAS2TAS()
    float _get_EAS2TAS(void) const;

    // get air density / sea level density - decreases as altitude climbs
    // please use AP::ahrs()::get_air_density_ratio()
    float _get_air_density_ratio(void);

    // get current climb rate in meters/s. A positive number means
    // going up
    float get_climb_rate(void);

    // ground temperature in degrees C
    // the ground values are only valid after calibration
    float get_ground_temperature(void) const;

    // ground pressure in Pascal
    // the ground values are only valid after calibration
    float get_ground_pressure(void) const { return get_ground_pressure(_primary); }
    float get_ground_pressure(uint8_t i)  const { return sensors[i].ground_pressure.get(); }

    // set the temperature to be used for altitude calibration. This
    // allows an external temperature source (such as a digital
    // airspeed sensor) to be used as the temperature source
    void set_external_temperature(float temperature);

    // get last time sample was taken (in ms)
    uint32_t get_last_update(void) const { return get_last_update(_primary); }
    uint32_t get_last_update(uint8_t instance) const { return sensors[instance].last_update_ms; }

    // settable parameters
    static const struct AP_Param::GroupInfo var_info[];

    float get_external_temperature(void) const { return get_external_temperature(_primary); };
    float get_external_temperature(const uint8_t instance) const;

    // Set the primary baro
    void set_primary_baro(uint8_t primary) { _primary_baro.set_and_save(primary); };

    // Set the type (Air or Water) of a particular instance
    void set_type(uint8_t instance, baro_type_t type) { sensors[instance].type = type; };

    // Get the type (Air or Water) of a particular instance
    baro_type_t get_type(uint8_t instance) { return sensors[instance].type; };

    // register a new sensor, claiming a sensor slot. If we are out of
    // slots it will panic
    uint8_t register_sensor(void);

    // return number of registered sensors
    uint8_t num_instances(void) const { return _num_sensors; }

    // set baro drift amount
    void set_baro_drift_altitude(float alt) { _alt_offset.set(alt); }

    // get baro drift amount
    float get_baro_drift_offset(void) const { return _alt_offset_active; }

    // simple underwater atmospheric model
    static void SimpleUnderWaterAtmosphere(float alt, float &rho, float &delta, float &theta);

    // set a pressure correction from AP_TempCalibration
    void set_pressure_correction(uint8_t instance, float p_correction);

    uint8_t get_filter_range() const { return _filter_range; }

    // indicate which bit in LOG_BITMASK indicates baro logging enabled
    void set_log_baro_bit(uint32_t bit) { _log_baro_bit = bit; }
    bool should_log() const;

    // allow threads to lock against baro update
    HAL_Semaphore &get_semaphore(void) {
        return _rsem;
    }

#if AP_BARO_MSP_ENABLED
    void handle_msp(const MSP::msp_baro_data_message_t &pkt);
#endif
#if AP_BARO_EXTERNALAHRS_ENABLED
    void handle_external(const AP_ExternalAHRS::baro_data_message_t &pkt);
#endif

    enum Options : uint16_t {
        TreatMS5611AsMS5607     = (1U << 0U),
    };

    // check if an option is set
    bool option_enabled(const Options option) const
    {
        return (uint16_t(_options.get()) & uint16_t(option)) != 0;
    }

private:
    // singleton
    static AP_Baro *_singleton;
    
    // how many drivers do we have?
    uint8_t _num_drivers;
    AP_Baro_Backend *drivers[BARO_MAX_DRIVERS];

    // how many sensors do we have?
    uint8_t _num_sensors;

    // what is the primary sensor at the moment?
    uint8_t _primary;

    uint32_t _log_baro_bit = -1;

    bool init_done;

    uint8_t msp_instance_mask;

    // bitmask values for GND_PROBE_EXT
    enum {
        PROBE_BMP085=(1<<0),
        PROBE_BMP280=(1<<1),
        PROBE_MS5611=(1<<2),
        PROBE_MS5607=(1<<3),
        PROBE_MS5637=(1<<4),
        PROBE_FBM320=(1<<5),
        PROBE_DPS280=(1<<6),
        PROBE_LPS25H=(1<<7),
        PROBE_KELLER=(1<<8),
        PROBE_MS5837=(1<<9),
        PROBE_BMP388=(1<<10),
        PROBE_SPL06 =(1<<11),
        PROBE_MSP   =(1<<12),
        PROBE_BMP581=(1<<13),
    };
    
#if HAL_BARO_WIND_COMP_ENABLED
    class WindCoeff {
    public:
        static const struct AP_Param::GroupInfo var_info[];

        AP_Int8  enable; // enable compensation for this barometer
        AP_Float xp;     // ratio of static pressure rise to dynamic pressure when flying forwards
        AP_Float xn;     // ratio of static pressure rise to dynamic pressure when flying backwards
        AP_Float yp;     // ratio of static pressure rise to dynamic pressure when flying to the right
        AP_Float yn;     // ratio of static pressure rise to dynamic pressure when flying to the left
        AP_Float zp;     // ratio of static pressure rise to dynamic pressure when flying up
        AP_Float zn;     // ratio of static pressure rise to dynamic pressure when flying down
    };
#endif

    struct sensor {
        uint32_t last_update_ms;        // last update time in ms
        uint32_t last_change_ms;        // last update time in ms that included a change in reading from previous readings
        float pressure;                 // pressure in Pascal
        float temperature;              // temperature in degrees C
        float altitude;                 // calculated altitude
        AP_Float ground_pressure;
        float p_correction;
        baro_type_t type;               // 0 for air pressure (default), 1 for water pressure
        bool healthy;                   // true if sensor is healthy
        bool alt_ok;                    // true if calculated altitude is ok
        bool calibrated;                // true if calculated calibrated successfully
        AP_Int32 bus_id;
#if HAL_BARO_WIND_COMP_ENABLED
        WindCoeff wind_coeff;
        Vector3f dynamic_pressure;      // calculated dynamic pressure
#endif
    } sensors[BARO_MAX_INSTANCES];

    AP_Float                            _alt_offset;
    float                               _alt_offset_active;
    AP_Float                            _field_elevation;       // field elevation in meters
    float                               _field_elevation_active;
    uint32_t                            _field_elevation_last_ms;
    AP_Int8                             _primary_baro; // primary chosen by user
    AP_Int8                             _ext_bus; // bus number for external barometer
    float                               _external_temperature;
    uint32_t                            _last_external_temperature_ms;
    DerivativeFilterFloat_Size7         _climb_rate_filter;
    AP_Float                            _specific_gravity; // the specific gravity of fluid for an ROV 1.00 for freshwater, 1.024 for salt water
    AP_Float                            _user_ground_temperature; // user override of the ground temperature used for EAS2TAS
    float                               _guessed_ground_temperature; // currently ground temperature estimate using our best available source

    // when did we last notify the GCS of new pressure reference?
    uint32_t                            _last_notify_ms;

    // see if we already have probed a i2c driver by bus number and address
    bool _have_i2c_driver(uint8_t bus_num, uint8_t address) const;
    bool _add_backend(AP_Baro_Backend *backend);
    void _probe_i2c_barometers(void);
    AP_Int8                            _filter_range;  // valid value range from mean value
    AP_Int32                           _baro_probe_ext;

#ifndef HAL_BUILD_AP_PERIPH
    AP_Float                           _alt_error_max;
#endif

    AP_Int16                           _options;

    // semaphore for API access from threads
    HAL_Semaphore                      _rsem;

#if HAL_BARO_WIND_COMP_ENABLED
    /*
      return pressure correction for wind based on GND_WCOEF parameters
    */
    float wind_pressure_correction(uint8_t instance);
#endif

    // Logging function
    void Write_Baro(void);
    void Write_Baro_instance(uint64_t time_us, uint8_t baro_instance);

    void update_field_elevation();

    // atmosphere model functions
    float get_altitude_difference_extended(float base_pressure, float pressure) const;
    float get_EAS2TAS_extended(float pressure) const;
    static float get_temperature_by_altitude_layer(float alt, int8_t idx);

    float get_altitude_difference_simple(float base_pressure, float pressure) const;
    float get_EAS2TAS_simple(float altitude, float pressure) const;
};

namespace AP {
    AP_Baro &baro();
};
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              /*
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
#include "AP_Baro_BMP085.h"

#if AP_BARO_BMP085_ENABLED

#include <utility>
#include <stdio.h>

#include <AP_Common/AP_Common.h>
#include <AP_HAL/AP_HAL.h>

extern const AP_HAL::HAL &hal;

#define BMP085_OVERSAMPLING_ULTRALOWPOWER 0
#define BMP085_OVERSAMPLING_STANDARD      1
#define BMP085_OVERSAMPLING_HIGHRES       2
#define BMP085_OVERSAMPLING_ULTRAHIGHRES  3

#ifndef BMP085_EOC
#define BMP085_EOC -1
#define OVERSAMPLING BMP085_OVERSAMPLING_ULTRAHIGHRES
#else
#define OVERSAMPLING BMP085_OVERSAMPLING_HIGHRES
#endif

AP_Baro_BMP085::AP_Baro_BMP085(AP_Baro &baro, AP_HAL::OwnPtr<AP_HAL::Device> dev)
    : AP_Baro_Backend(baro)
    , _dev(std::move(dev))
{ }

AP_Baro_Backend * AP_Baro_BMP085::probe(AP_Baro &baro, AP_HAL::OwnPtr<AP_HAL::Device> dev)
{

    if (!dev) {
        return nullptr;
    }

    AP_Baro_BMP085 *sensor = NEW_NOTHROW AP_Baro_BMP085(baro, std::move(dev));
    if (!sensor || !sensor->_init()) {
        delete sensor;
        return nullptr;
    }
    return sensor;

}

bool AP_Baro_BMP085::_init()
{
    if (!_dev) {
        return false;
    }
    union {
        uint8_t buff[22];
        uint16_t wb[11];
    } bb;

    // get pointer to i2c bus semaphore
    AP_HAL::Semaphore *sem = _dev->get_semaphore();

    // take i2c bus semaphore
    WITH_SEMAPHORE(sem);

    if (BMP085_EOC >= 0) {
        _eoc = hal.gpio->channel(BMP085_EOC);
        _eoc->mode(HAL_GPIO_INPUT);
    }


    uint8_t id;

    if (!_dev->read_registers(0xD0, &id, 1)) {
        return false;
    }

    if (id!=0x55) {
        return false;    // not BMP180
    }


    _dev->read_registers(0xD1, &_vers, 1);

    bool prom_ok=false;
    _type=0;

    // We read the calibration data registers
    if (_dev->read_registers(0xAA, bb.buff, sizeof(bb.buff))) {
        prom_ok=true;

    }

    if (!prom_ok) {
        if (_read_prom((uint16_t *)&bb.wb[0]))  { // BMP180 requires reads by 2 bytes
            prom_ok=true;
            _type=1;
        }
    }
    if (!prom_ok) {
        return false;
    }

    ac1 = ((int16_t)bb.buff[0] << 8) | bb.buff[1];
    ac2 = ((int16_t)bb.buff[2] << 8) | bb.buff[3];
    ac3 = ((int16_t)bb.buff[4] << 8) | bb.buff[5];
    ac4 = ((int16_t)bb.buff[6] << 8) | bb.buff[7];
    ac5 = ((int16_t)bb.buff[8] << 8) | bb.buff[9];
    ac6 = ((int16_t)bb.buff[10]<< 8) | bb.buff[11];
    b1 = ((int16_t)bb.buff[12] << 8) | bb.buff[13];
    b2 = ((int16_t)bb.buff[14] << 8) | bb.buff[15];
    mb = ((int16_t)bb.buff[16] << 8) | bb.buff[17];
    mc = ((int16_t)bb.buff[18] << 8) | bb.buff[19];
    md = ((int16_t)bb.buff[20] << 8) | bb.buff[21];

    if ((ac1==0 || ac1==-1) ||
        (ac2==0 || ac2==-1) ||
        (ac3==0 || ac3==-1) ||
        (ac4==0 || ac4==0xFFFF) ||
        (ac5==0 || ac5==0xFFFF) ||
        (ac6==0 || ac6==0xFFFF)) {
        return false;
    }

    _last_press_read_command_time = 0;
    _last_temp_read_command_time = 0;

    // Send a command to read temperature
    _cmd_read_temp();

    _state = 0;

    _instance = _frontend.register_sensor();

    _dev->set_device_type(DEVTYPE_BARO_BMP085);
    set_bus_id(_instance, _dev->get_bus_id());
    
    _dev->register_periodic_callback(20000, FUNCTOR_BIND_MEMBER(&AP_Baro_BMP085::_timer, void));
    return true;
}

uint16_t AP_Baro_BMP085::_read_prom_word(uint8_t word)
{
    const uint8_t reg = 0xAA + (word << 1);
    uint8_t val[2];
    if (!_dev->transfer(&reg, 1, val, sizeof(val))) {
        return 0;
    }
    return (val[0] << 8) | val[1];
}

bool AP_Baro_BMP085::_read_prom(uint16_t *prom)
{
    bool all_zero = true;
    for (uint8_t i = 0; i < 11; i++) {
        prom[i] = _read_prom_word(i);
        if (prom[i] != 0) {
            all_zero = false;
        }
    }

    if (all_zero) {
        return false;
    }

    return true;
}

/*
  This is a state machine. Accumulate a new sensor reading.
 */
void AP_Baro_BMP085::_timer(void)
{
    if (!_data_ready()) {
        return;
    }

    if (_state == 0) {
        _read_temp();
    } else if (_read_pressure()) {
        _calculate();
    }

    _state++;
    if (_state == 25) {
        _state = 0;
        _cmd_read_temp();
    } else {
        _cmd_read_pressure();
    }
}

/*
  transfer data to the frontend
 */
void AP_Baro_BMP085::update(void)
{
    WITH_SEMAPHORE(_sem);

    if (!_has_sample) {
        return;
    }

    float temperature = 0.1f * _temp;
    float pressure = _pressure_filter.getf();

    _copy_to_frontend(_instance, pressure, temperature);
}

// Send command to Read Pressure
void AP_Baro_BMP085::_cmd_read_pressure()
{
    _dev->write_register(0xF4, 0x34 + (OVERSAMPLING << 6));
    _last_press_read_command_time = AP_HAL::millis();
}

// Read raw pressure values
bool AP_Baro_BMP085::_read_pressure()
{
    uint8_t buf[3];
    if (_dev->read_registers(0xF6, buf, sizeof(buf))) {
        _raw_pressure = (((uint32_t)buf[0] << 16)
                         | ((uint32_t)buf[1] << 8)
                         | ((uint32_t)buf[2])) >> (8 - OVERSAMPLING);
        return true;
    }

    uint8_t xlsb;
    if (_dev->read_registers(0xF6, buf, 2) && _dev->read_registers(0xF8, &xlsb, 1)) {
        _raw_pressure = (((uint32_t)buf[0] << 16)
                         | ((uint32_t)buf[1] << 8)
                         | ((uint32_t)xlsb)) >> (8 - OVERSAMPLING);
        return true;
    }

    _last_press_read_command_time = AP_HAL::millis() + 1000;
    _dev->set_speed(AP_HAL::Device::SPEED_LOW);
    return false;
}

// Send Command to Read Temperature
void AP_Baro_BMP085::_cmd_read_temp()
{
    _dev->write_register(0xF4, 0x2E);
    _last_temp_read_command_time = AP_HAL::millis();
}

// Read raw temperature values
void AP_Baro_BMP085::_read_temp()
{
    uint8_t buf[2];
    int32_t _temp_sensor;

    if (!_dev->read_registers(0xF6, buf, sizeof(buf))) {
        _dev->set_speed(AP_HAL::Device::SPEED_LOW);
        return;
    }
    _temp_sensor = buf[0];
    _temp_sensor = (_temp_sensor << 8) | buf[1];

    _raw_temp = _temp_sensor;
}

// _calculate Temperature and Pressure in real units.
void AP_Baro_BMP085::_calculate()
{
    int32_t x1, x2, x3, b3, b5, b6, p;
    uint32_t b4, b7;
    int32_t tmp;

    // See Datasheet page 13 for this formulas
    // Based also on Jee Labs BMP085 example code. Thanks for share.
    // Temperature calculations
    x1 = ((int32_t)_raw_temp - ac6) * ac5 >> 15;
    x2 = ((int32_t) mc << 11) / (x1 + md);
    b5 = x1 + x2;
    _temp = (b5 + 8) >> 4;

    // Pressure calculations
    b6 = b5 - 4000;
    x1 = (b2 * (b6 * b6 >> 12)) >> 11;
    x2 = ac2 * b6 >> 11;
    x3 = x1 + x2;
    //b3 = (((int32_t) ac1 * 4 + x3)<<OVERSAMPLING + 2) >> 2; // BAD
    //b3 = ((int32_t) ac1 * 4 + x3 + 2) >> 2;  //OK for OVERSAMPLING=0
    tmp = ac1;
    tmp = (tmp*4 + x3)<<OVERSAMPLING;
    b3 = (tmp+2)/4;
    x1 = ac3 * b6 >> 13;
    x2 = (b1 * (b6 * b6 >> 12)) >> 16;
    x3 = ((x1 + x2) + 2) >> 2;
    b4 = (ac4 * (uint32_t)(x3 + 32768)) >> 15;
    b7 = ((uint32_t) _raw_pressure - b3) * (50000 >> OVERSAMPLING);
    p = b7 < 0x80000000 ? (b7 * 2) / b4 : (b7 / b4) * 2;

    x1 = (p >> 8) * (p >> 8);
    x1 = (x1 * 3038) >> 16;
    x2 = (-7357 * p) >> 16;
    p += ((x1 + x2 + 3791) >> 4);

    if (!pressure_ok(p)) {
        return;
    }

    WITH_SEMAPHORE(_sem);

    _pressure_filter.apply(p);
    _has_sample = true;
}

bool AP_Baro_BMP085::_data_ready()
{
    if (BMP085_EOC >= 0) {
        return _eoc->read();
    }

    // No EOC pin: use time from last read instead.
    if (_state == 0) {
        return AP_HAL::millis() - _last_temp_read_command_time > 5u;
    }

    uint32_t conversion_time_msec;

    switch (OVERSAMPLING) {
    case BMP085_OVERSAMPLING_ULTRALOWPOWER:
        conversion_time_msec = 5;
        break;
    case BMP085_OVERSAMPLING_STANDARD:
        conversion_time_msec = 8;
        break;
    case BMP085_OVERSAMPLING_HIGHRES:
        conversion_time_msec = 14;
        break;
    case BMP085_OVERSAMPLING_ULTRAHIGHRES:
        conversion_time_msec = 26;
        break;
    default:
        break;
    }

    return AP_HAL::millis() - _last_press_read_command_time > conversion_time_msec;
}

#endif // AP_BARO_BMP085_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            #pragma once

#include "AP_Baro_Backend.h"

#if AP_BARO_BMP085_ENABLED

#include <AP_HAL/AP_HAL.h>
#include <AP_HAL/I2CDevice.h>
#include <AP_HAL/utility/OwnPtr.h>
#include <Filter/Filter.h>

#ifndef HAL_BARO_BMP085_I2C_ADDR
#define HAL_BARO_BMP085_I2C_ADDR        (0x77)
#endif

class AP_Baro_BMP085 : public AP_Baro_Backend {
public:
    AP_Baro_BMP085(AP_Baro &baro, AP_HAL::OwnPtr<AP_HAL::Device> dev);

    /* AP_Baro public interface: */
    void update() override;

    static AP_Baro_Backend *probe(AP_Baro &baro, AP_HAL::OwnPtr<AP_HAL::Device> dev);


private:
    bool _init();

    void _cmd_read_pressure();
    void _cmd_read_temp();
    bool _read_pressure();
    void _read_temp();
    void _calculate();
    bool _data_ready();

    void _timer(void);

    uint16_t _read_prom_word(uint8_t word);
    bool     _read_prom(uint16_t *prom);


    AP_HAL::OwnPtr<AP_HAL::Device> _dev;
    AP_HAL::DigitalSource *_eoc;

    uint8_t _instance;
    bool _has_sample;

    // Boards with no EOC pin: use times instead
    uint32_t _last_press_read_command_time;
    uint32_t _last_temp_read_command_time;

    // State machine
    uint8_t _state;

    // Internal calibration registers
    int16_t ac1, ac2, ac3, b1, b2, mb, mc, md;
    uint16_t ac4, ac5, ac6;

    int32_t _raw_pressure;
    int32_t _raw_temp;
    int32_t _temp;
    AverageIntegralFilter<int32_t, int32_t, 10> _pressure_filter;

    uint8_t _vers;
    uint8_t _type;
};

#endif  // AP_BARO_BMP085_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      /*
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
#include "AP_Baro_BMP280.h"

#if AP_BARO_BMP280_ENABLED

#include <AP_Math/definitions.h>
#include <utility>

extern const AP_HAL::HAL &hal;

#define BMP280_MODE_SLEEP  0
#define BMP280_MODE_FORCED 1
#define BMP280_MODE_NORMAL 3
#define BMP280_MODE BMP280_MODE_NORMAL

#define BMP280_OVERSAMPLING_1  1
#define BMP280_OVERSAMPLING_2  2
#define BMP280_OVERSAMPLING_4  3
#define BMP280_OVERSAMPLING_8  4
#define BMP280_OVERSAMPLING_16 5
#define BMP280_OVERSAMPLING_P BMP280_OVERSAMPLING_16
#define BMP280_OVERSAMPLING_T BMP280_OVERSAMPLING_2

#define BMP280_FILTER_COEFFICIENT 2

#define BMP280_ID            0x58
#define BME280_ID            0x60

#define BMP280_REG_CALIB     0x88
#define BMP280_REG_ID        0xD0
#define BMP280_REG_RESET     0xE0
#define BMP280_REG_STATUS    0xF3
#define BMP280_REG_CTRL_MEAS 0xF4
#define BMP280_REG_CONFIG    0xF5
#define BMP280_REG_DATA      0xF7

AP_Baro_BMP280::AP_Baro_BMP280(AP_Baro &baro, AP_HAL::OwnPtr<AP_HAL::Device> dev)
    : AP_Baro_Backend(baro)
    , _dev(std::move(dev))
{
}

AP_Baro_Backend *AP_Baro_BMP280::probe(AP_Baro &baro,
                                       AP_HAL::OwnPtr<AP_HAL::Device> dev)
{
    if (!dev) {
        return nullptr;
    }

    AP_Baro_BMP280 *sensor = NEW_NOTHROW AP_Baro_BMP280(baro, std::move(dev));
    if (!sensor || !sensor->_init()) {
        delete sensor;
        return nullptr;
    }
    return sensor;
}

bool AP_Baro_BMP280::_init()
{
    if (!_dev) {
        return false;
    }
    WITH_SEMAPHORE(_dev->get_semaphore());

    _dev->set_speed(AP_HAL::Device::SPEED_HIGH);

    uint8_t whoami;
    if (!_dev->read_registers(BMP280_REG_ID, &whoami, 1)  ||
        (whoami != BME280_ID && whoami != BMP280_ID)) {
        // not a BMP280 or BME280
        return false;
    }

    // read the calibration data
    uint8_t buf[24];
    _dev->read_registers(BMP280_REG_CALIB, buf, sizeof(buf));

    _t1 = ((int16_t)buf[1] << 8) | buf[0];
    _t2 = ((int16_t)buf[3] << 8) | buf[2];
    _t3 = ((int16_t)buf[5] << 8) | buf[4];
    _p1 = ((int16_t)buf[7] << 8) | buf[6];
    _p2 = ((int16_t)buf[9] << 8) | buf[8];
    _p3 = ((int16_t)buf[11] << 8) | buf[10];
    _p4 = ((int16_t)buf[13] << 8) | buf[12];
    _p5 = ((int16_t)buf[15] << 8) | buf[14];
    _p6 = ((int16_t)buf[17] << 8) | buf[16];
    _p7 = ((int16_t)buf[19] << 8) | buf[18];
    _p8 = ((int16_t)buf[21] << 8) | buf[20];
    _p9 = ((int16_t)buf[23] << 8) | buf[22];

    // SPI write needs bit mask
    uint8_t mask = 0xFF;
    if (_dev->bus_type() == AP_HAL::Device::BUS_TYPE_SPI) {
        mask = 0x7F;
    }

    _dev->setup_checked_registers(2, 20);
    
    _dev->write_register((BMP280_REG_CTRL_MEAS & mask), (BMP280_OVERSAMPLING_T << 5) |
                         (BMP280_OVERSAMPLING_P << 2) | BMP280_MODE, true);

    _dev->write_register((BMP280_REG_CONFIG & mask), BMP280_FILTER_COEFFICIENT << 2, true);

    _instance = _frontend.register_sensor();

    _dev->set_device_type(DEVTYPE_BARO_BMP280);
    set_bus_id(_instance, _dev->get_bus_id());
    
    // request 50Hz update
    _dev->register_periodic_callback(20 * AP_USEC_PER_MSEC, FUNCTOR_BIND_MEMBER(&AP_Baro_BMP280::_timer, void));

    return true;
}



//  accumulate a new sensor reading
void AP_Baro_BMP280::_timer(void)
{
    uint8_t buf[6];

    _dev->read_registers(BMP280_REG_DATA, buf, sizeof(buf));

    _update_temperature((buf[3] << 12) | (buf[4] << 4) | (buf[5] >> 4));
    _update_pressure((buf[0] << 12) | (buf[1] << 4) | (buf[2] >> 4));

    _dev->check_next_register();
}

// transfer data to the frontend
void AP_Baro_BMP280::update(void)
{
    WITH_SEMAPHORE(_sem);

    if (_pressure_count == 0) {
        return;
    }

    _copy_to_frontend(_instance, _pressure_sum/_pressure_count, _temperature);
    _pressure_count = 0;
    _pressure_sum = 0;
}

// calculate temperature
void AP_Baro_BMP280::_update_temperature(int32_t temp_raw)
{
    int32_t var1, var2, t;

    // according to datasheet page 22
    var1 = ((((temp_raw >> 3) - ((int32_t)_t1 << 1))) * ((int32_t)_t2)) >> 11;
    var2 = (((((temp_raw >> 4) - ((int32_t)_t1)) * ((temp_raw >> 4) - ((int32_t)_t1))) >> 12) * ((int32_t)_t3)) >> 14;
    _t_fine = var1 + var2;
    t = (_t_fine * 5 + 128) >> 8;

    const float temp = ((float)t) * 0.01f;

    WITH_SEMAPHORE(_sem);
    
    _temperature = temp;
}

// calculate pressure
void AP_Baro_BMP280::_update_pressure(int32_t press_raw)
{
    int64_t var1, var2, p;

    // according to datasheet page 22
    var1 = ((int64_t)_t_fine) - 128000;
    var2 = var1 * var1 * (int64_t)_p6;
    var2 = var2 + ((var1 * (int64_t)_p5) << 17);
    var2 = var2 + (((int64_t)_p4) << 35);
    var1 = ((var1 * var1 * (int64_t)_p3) >> 8) + ((var1 * (int64_t)_p2) << 12);
    var1 = (((((int64_t)1) << 47) + var1)) * ((int64_t)_p1) >> 33;

    if (var1 == 0) {
        return;
    }

    p = 1048576 - press_raw;
    p = (((p << 31) - var2) * 3125) / var1;
    var1 = (((int64_t)_p9) * (p >> 13) * (p >> 13)) >> 25;
    var2 = (((int64_t)_p8) * p) >> 19;
    p = ((p + var1 + var2) >> 8) + (((int64_t)_p7) << 4);


    const float press = (float)p / 256.0f;
    if (!pressure_ok(press)) {
        return;
    }
    
    WITH_SEMAPHORE(_sem);
    
    _pressure_sum += press;
    _pressure_count++;
}

#endif  // AP_BARO_BMP280_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      #pragma once

#include "AP_Baro_Backend.h"

#if AP_BARO_BMP280_ENABLED

#include <AP_HAL/AP_HAL.h>
#include <AP_HAL/Device.h>
#include <AP_HAL/utility/OwnPtr.h>

#ifndef HAL_BARO_BMP280_I2C_ADDR
 #define HAL_BARO_BMP280_I2C_ADDR  (0x76)
#endif
#ifndef HAL_BARO_BMP280_I2C_ADDR2
 #define HAL_BARO_BMP280_I2C_ADDR2 (0x77)
#endif

class AP_Baro_BMP280 : public AP_Baro_Backend
{
public:
    AP_Baro_BMP280(AP_Baro &baro, AP_HAL::OwnPtr<AP_HAL::Device> dev);

    /* AP_Baro public interface: */
    void update() override;

    static AP_Baro_Backend *probe(AP_Baro &baro, AP_HAL::OwnPtr<AP_HAL::Device> dev);

private:

    bool _init(void);
    void _timer(void);
    void _update_temperature(int32_t);
    void _update_pressure(int32_t);

    AP_HAL::OwnPtr<AP_HAL::Device> _dev;

    uint8_t _instance;
    int32_t _t_fine;
    float _pressure_sum;
    uint32_t _pressure_count;
    float _temperature;

    // Internal calibration registers
    int16_t _t2, _t3, _p2, _p3, _p4, _p5, _p6, _p7, _p8, _p9;
    uint16_t _t1, _p1;
};

#endif  // AP_BARO_BMP280_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      /*
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
#include "AP_Baro_BMP388.h"

#if AP_BARO_BMP388_ENABLED

#include <utility>
#include <AP_Math/AP_Math.h>

extern const AP_HAL::HAL &hal;

#define BMP388_MODE_SLEEP  0
#define BMP388_MODE_FORCED 1
#define BMP388_MODE_NORMAL 3
#define BMP388_MODE BMP388_MODE_NORMAL

#define BMP388_ID            0x50
#define BMP390_ID            0x60

#define BMP388_REG_ID        0x00
#define BMP388_REV_ID_ADDR   0x01
#define BMP388_REG_ERR       0x02
#define BMP388_REG_STATUS    0x03
#define BMP388_REG_PRESS     0x04 // 24 bit
#define BMP388_REG_TEMP      0x07 // 24 bit
#define BMP388_REG_TIME      0x0C // 24 bit
#define BMP388_REG_EVENT     0x10
#define BMP388_REG_INT_STS   0x11
#define BMP388_REG_FIFO_LEN  0x12 // 9 bit
#define BMP388_REG_FIFO_DATA 0x14
#define BMP388_REG_FIFO_WTMK 0x15 // 9 bit
#define BMP388_REG_FIFO_CNF1 0x17
#define BMP388_REG_FIFO_CNF2 0x18
#define BMP388_REG_INT_CTRL  0x19
#define BMP388_REG_PWR_CTRL  0x1B
#define BMP388_REG_OSR       0x1C
#define BMP388_REG_ODR       0x1D
#define BMP388_REG_CONFIG    0x1F
#define BMP388_REG_CMD       0x7E

#define BMP388_REG_CAL_P     0x36
#define BMP388_REG_CAL_T     0x31

AP_Baro_BMP388::AP_Baro_BMP388(AP_Baro &baro, AP_HAL::OwnPtr<AP_HAL::Device> _dev)
    : AP_Baro_Backend(baro)
    , dev(std::move(_dev))
{
}

AP_Baro_Backend *AP_Baro_BMP388::probe(AP_Baro &baro,
                                       AP_HAL::OwnPtr<AP_HAL::Device> _dev)
{
    if (!_dev) {
        return nullptr;
    }

    AP_Baro_BMP388 *sensor = NEW_NOTHROW AP_Baro_BMP388(baro, std::move(_dev));
    if (!sensor || !sensor->init()) {
        delete sensor;
        return nullptr;
    }
    return sensor;
}

bool AP_Baro_BMP388::init()
{
    if (!dev) {
        return false;
    }
    WITH_SEMAPHORE(dev->get_semaphore());

    dev->set_speed(AP_HAL::Device::SPEED_HIGH);

    // setup to allow reads on SPI
    if (dev->bus_type() == AP_HAL::Device::BUS_TYPE_SPI) {
        dev->set_read_flag(0x80);
    }

    // normal mode, temp and pressure
    dev->write_register(BMP388_REG_PWR_CTRL, 0x33, true);
    
    uint8_t whoami;
    if (!read_registers(BMP388_REG_ID, &whoami, 1)) {
        return false;
    }

    switch (whoami) {
    case BMP388_ID:
        dev->set_device_type(DEVTYPE_BARO_BMP388);
        break;
    case BMP390_ID:
        dev->set_device_type(DEVTYPE_BARO_BMP390);
        break;
    default:
        return false;
    }

    // read the calibration data
    read_registers(BMP388_REG_CAL_P, (uint8_t *)&calib_p, sizeof(calib_p));
    read_registers(BMP388_REG_CAL_T, (uint8_t *)&calib_t, sizeof(calib_t));

    scale_calibration_data();

    dev->setup_checked_registers(4);

    // normal mode, temp and pressure
    dev->write_register(BMP388_REG_PWR_CTRL, 0x33, true);

    instance = _frontend.register_sensor();

    set_bus_id(instance, dev->get_bus_id());

    // request 50Hz update
    dev->register_periodic_callback(20 * AP_USEC_PER_MSEC, FUNCTOR_BIND_MEMBER(&AP_Baro_BMP388::timer, void));

    return true;
}



//  accumulate a new sensor reading
void AP_Baro_BMP388::timer(void)
{
    uint8_t buf[7];

    if (!read_registers(BMP388_REG_STATUS, buf, sizeof(buf))) {
        return;
    }
    const uint8_t status = buf[0];
    if ((status & 0x20) != 0) {
        // we have pressure data
        update_pressure((buf[3] << 16) | (buf[2] << 8) | buf[1]);
    }
    if ((status & 0x40) != 0) {
        // we have temperature data
        update_temperature((buf[6] << 16) | (buf[5] << 8) | buf[4]);
    }

    dev->check_next_register();
}

// transfer data to the frontend
void AP_Baro_BMP388::update(void)
{
    WITH_SEMAPHORE(_sem);

    if (pressure_count == 0) {
        return;
    }

    _copy_to_frontend(instance,
                      pressure_sum/pressure_count,
                      temperature);

    pressure_sum = 0;
    pressure_count = 0;
}

/*
  convert calibration data from NVM values to values ready for
  compensation calculations
 */
void AP_Baro_BMP388::scale_calibration_data(void)
{
    // note that this assumes little-endian MCU
    calib.par_t1 = calib_t.nvm_par_t1 * 256.0;
    calib.par_t2 = calib_t.nvm_par_t2 / 1073741824.0f;
    calib.par_t3 = calib_t.nvm_par_t3 / 281474976710656.0f;

    calib.par_p1 = (calib_p.nvm_par_p1 - 16384) / 1048576.0f;
    calib.par_p2 = (calib_p.nvm_par_p2 - 16384) / 536870912.0f;
    calib.par_p3 = calib_p.nvm_par_p3 / 4294967296.0f;
    calib.par_p4 = calib_p.nvm_par_p4 / 137438953472.0;
    calib.par_p5 = calib_p.nvm_par_p5 * 8.0f;
    calib.par_p6 = calib_p.nvm_par_p6 / 64.0;
    calib.par_p7 = calib_p.nvm_par_p7 / 256.0f;
    calib.par_p8 = calib_p.nvm_par_p8 / 32768.0f;
    calib.par_p9 = calib_p.nvm_par_p9 / 281474976710656.0f;
    calib.par_p10 = calib_p.nvm_par_p10 / 281474976710656.0f;
    calib.par_p11 = calib_p.nvm_par_p11 / 36893488147419103232.0f;
}

/*
  update temperature from raw sample
 */
void AP_Baro_BMP388::update_temperature(uint32_t data)
{
    float partial1 = data - calib.par_t1;
    float partial2 = partial1 * calib.par_t2;

    WITH_SEMAPHORE(_sem);
    temperature = partial2 + sq(partial1) * calib.par_t3;
}

/*
  update pressure from raw pressure data
 */
void AP_Baro_BMP388::update_pressure(uint32_t data)
{
    float partial1 = calib.par_p6 * temperature;
    float partial2 = calib.par_p7 * powf(temperature, 2);
    float partial3 = calib.par_p8 * powf(temperature, 3);
    float partial_out1 = calib.par_p5 + partial1 + partial2 + partial3;

    partial1 = calib.par_p2 * temperature;
    partial2 = calib.par_p3 * powf(temperature, 2);
    partial3 = calib.par_p4 * powf(temperature, 3);
    float partial_out2 = data * (calib.par_p1 + partial1 + partial2 + partial3);

    partial1 = powf(data, 2);
    partial2 = calib.par_p9 + calib.par_p10 * temperature;
    partial3 = partial1 * partial2;
    float partial4 = partial3 + powf(data, 3) * calib.par_p11;
    float press = partial_out1 + partial_out2 + partial4;

    WITH_SEMAPHORE(_sem);

    pressure_sum += press;
    pressure_count++;
}

/*
  read registers, special SPI handling needed
*/
bool AP_Baro_BMP388::read_registers(uint8_t reg, uint8_t *data, uint8_t len)
{
    // when on I2C we just read normally
    if (dev->bus_type() != AP_HAL::Device::BUS_TYPE_SPI) {
        return dev->read_registers(reg, data, len);
    }
    // for SPI we need to discard the first returned byte. See
    // datasheet for explanation
    uint8_t b[len+2];
    b[0] = reg | 0x80;
    memset(&b[1], 0, len+1);
    if (!dev->transfer(b, len+2, b, len+2)) {
        return false;
    }
    memcpy(data, &b[2], len);
    return true;
}

#endif  // AP_BARO_BMP388_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     #pragma once

#include "AP_Baro_Backend.h"

#if AP_BARO_BMP388_ENABLED

#include <AP_HAL/AP_HAL.h>
#include <AP_HAL/Device.h>
#include <AP_HAL/utility/OwnPtr.h>

#ifndef HAL_BARO_BMP388_I2C_ADDR
 #define HAL_BARO_BMP388_I2C_ADDR  (0x76)
#endif
#ifndef HAL_BARO_BMP388_I2C_ADDR2
 #define HAL_BARO_BMP388_I2C_ADDR2 (0x77)
#endif

class AP_Baro_BMP388 : public AP_Baro_Backend
{
public:
    AP_Baro_BMP388(AP_Baro &baro, AP_HAL::OwnPtr<AP_HAL::Device> _dev);

    /* AP_Baro public interface: */
    void update() override;

    static AP_Baro_Backend *probe(AP_Baro &baro, AP_HAL::OwnPtr<AP_HAL::Device> _dev);

private:

    bool init(void);
    void timer(void);
    void update_temperature(uint32_t);
    void update_pressure(uint32_t);

    AP_HAL::OwnPtr<AP_HAL::Device> dev;

    uint8_t instance;
    float pressure_sum;
    uint32_t pressure_count;
    float temperature;

    // Internal calibration registers
    struct PACKED {
        int16_t nvm_par_p1; // at 0x36
        int16_t nvm_par_p2;
        int8_t nvm_par_p3;
        int8_t nvm_par_p4;
        int16_t nvm_par_p5;
        int16_t nvm_par_p6;
        int8_t nvm_par_p7;
        int8_t nvm_par_p8;
        int16_t nvm_par_p9;
        int8_t nvm_par_p10;
        int8_t nvm_par_p11;
    } calib_p;

    struct PACKED {
        uint16_t nvm_par_t1; // at 0x31
        uint16_t nvm_par_t2;
        int8_t nvm_par_t3;
    } calib_t;

    // scaled calibration data
    struct {
        float par_t1;
        float par_t2;
        float par_t3;
        float par_p1;
        float par_p2;
        float par_p3;
        float par_p4;
        float par_p5;
        float par_p6;
        float par_p7;
        float par_p8;
        float par_p9;
        float par_p10;
        float par_p11;
        float t_lin;
    } calib;

    void scale_calibration_data(void);
    bool read_registers(uint8_t reg, uint8_t *data, uint8_t len);
};

#endif  // AP_BARO_BMP388_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    /*
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
#include "AP_Baro_BMP581.h"

#if AP_BARO_BMP581_ENABLED

#include <utility>
#include <AP_Math/AP_Math.h>

extern const AP_HAL::HAL &hal;

#define BMP581_ID                     0x50

#define BMP581_REG_CHIP_ID            0x01
#define BMP581_REG_REV_ID             0x02
#define BMP581_REG_CHIP_STATUS        0x11
#define BMP581_REG_DRIVE_CONFIG       0x13
#define BMP581_REG_INT_CONFIG         0x14
#define BMP581_REG_INT_SOURCE         0x15
#define BMP581_REG_FIFO_CONFIG        0x16
#define BMP581_REG_FIFO_COUNT         0x17
#define BMP581_REG_FIFO_SEL           0x18
#define BMP581_REG_TEMP_DATA_XLSB     0x1D
#define BMP581_REG_TEMP_DATA_LSB      0x1E
#define BMP581_REG_TEMP_DATA_MSB      0x1F
#define BMP581_REG_PRESS_DATA_XLSB    0x20
#define BMP581_REG_PRESS_DATA_LSB     0x21
#define BMP581_REG_PRESS_DATA_MSB     0x22
#define BMP581_REG_INT_STATUS         0x27
#define BMP581_REG_STATUS             0x28
#define BMP581_REG_FIFO_DATA          0x29
#define BMP581_REG_NVM_ADDR           0x2B
#define BMP581_REG_NVM_DATA_LSB       0x2C
#define BMP581_REG_NVM_DATA_MSB       0x2D
#define BMP581_REG_DSP_CONFIG         0x30
#define BMP581_REG_DSP_IIR            0x31
#define BMP581_REG_OOR_THR_P_LSB      0x32
#define BMP581_REG_OOR_THR_P_MSB      0x33
#define BMP581_REG_OOR_RANGE          0x34
#define BMP581_REG_OOR_CONFIG         0x35
#define BMP581_REG_OSR_CONFIG         0x36
#define BMP581_REG_ODR_CONFIG         0x37
#define BMP581_REG_OSR_EFF            0x38
#define BMP581_REG_CMD                0x7E

AP_Baro_BMP581::AP_Baro_BMP581(AP_Baro &baro, AP_HAL::OwnPtr<AP_HAL::Device> dev)
    : AP_Baro_Backend(baro)
    , _dev(std::move(dev))
{
}

AP_Baro_Backend *AP_Baro_BMP581::probe(AP_Baro &baro,
                                       AP_HAL::OwnPtr<AP_HAL::Device> dev)
{
    if (!dev) {
        return nullptr;
    }

    AP_Baro_BMP581 *sensor = NEW_NOTHROW AP_Baro_BMP581(baro, std::move(dev));
    if (!sensor || !sensor->init()) {
        delete sensor;
        return nullptr;
    }
    return sensor;
}

bool AP_Baro_BMP581::init()
{
    if (!_dev) {
        return false;
    }

    WITH_SEMAPHORE(_dev->get_semaphore());

    _dev->set_speed(AP_HAL::Device::SPEED_HIGH);

    uint8_t whoami;

    // setup to allow reads on SPI
    if (_dev->bus_type() == AP_HAL::Device::BUS_TYPE_SPI) {
        _dev->set_read_flag(0x80);

        if (!_dev->read_registers(BMP581_REG_CHIP_ID, &whoami, 1)) {
            return false;
        }
    }

    if (!_dev->read_registers(BMP581_REG_CHIP_ID, &whoami, 1)) {
        return false;
    }

    switch (whoami) {
    case BMP581_ID:
        _dev->set_device_type(DEVTYPE_BARO_BMP581);
        break;
    default:
        return false;
    }

    uint8_t status;
    if (!_dev->read_registers(BMP581_REG_STATUS, &status, 1)) {
        return false;
    }

    if ((status & 0b10) == 0  || (status & 0b100) == 1) {
        return false;
    }

    uint8_t int_status;
    if (!_dev->read_registers(BMP581_REG_INT_STATUS, &int_status, 1)) {
        return false;
    }

    if ((int_status & 0x10) == 0) {
        return false;
    }

    _dev->setup_checked_registers(4);

    // Standby mode
    _dev->write_register(BMP581_REG_ODR_CONFIG, 0, true);

    // Press EN | osr_p 64X | osr_t 4X
    _dev->write_register(BMP581_REG_OSR_CONFIG, 0b01110010, true);

    // ORD 50Hz | Normal Mode
    _dev->write_register(BMP581_REG_ODR_CONFIG, 0b0111101, true);

    instance = _frontend.register_sensor();

    set_bus_id(instance, _dev->get_bus_id());

    // request 50Hz update
    _dev->register_periodic_callback(20 * AP_USEC_PER_MSEC, FUNCTOR_BIND_MEMBER(&AP_Baro_BMP581::timer, void));

    return true;
}

// acumulate a new sensor reading
void AP_Baro_BMP581::timer(void)
{
    uint8_t buf[6];

    if (!_dev->read_registers(BMP581_REG_TEMP_DATA_XLSB, buf, sizeof(buf))) {
        return;
    }

    WITH_SEMAPHORE(_sem);

    if (buf[0] != 0x7f || buf[1] != 0x7f || buf[2] != 0x7f) {
        // we have temperature data
        temperature = (float)((int32_t)(((uint32_t)buf[2] << 24) | ((uint32_t)buf[1] << 16) | ((uint32_t)buf[0] << 8)) >> 8) * (1.0f / 65536.0f);
    }

    if (buf[3] != 0x7f || buf[4] != 0x7f || buf[5] != 0x7f) {
        // we have pressure data
        pressure_sum += (float)(((uint32_t)buf[5] << 16) | ((uint32_t)buf[4] << 8) | (uint32_t)buf[3]) * (1.0f / 64.0f);
        pressure_count++;
    }

    _dev->check_next_register();
}

// transfer data to the frontend
void AP_Baro_BMP581::update(void)
{
    WITH_SEMAPHORE(_sem);

    if (pressure_count == 0) {
        return;
    }

    _copy_to_frontend(instance,
                      pressure_sum/pressure_count,
                      temperature);

    pressure_sum = 0;
    pressure_count = 0;
}

#endif  // AP_BARO_BMP581_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             #pragma once

#include "AP_Baro_Backend.h"

#if AP_BARO_BMP581_ENABLED

#include <AP_HAL/AP_HAL.h>
#include <AP_HAL/Device.h>
#include <AP_HAL/utility/OwnPtr.h>

#ifndef HAL_BARO_BMP581_I2C_ADDR
 #define HAL_BARO_BMP581_I2C_ADDR  (0x46)
#endif
#ifndef HAL_BARO_BMP581_I2C_ADDR2
 #define HAL_BARO_BMP581_I2C_ADDR2 (0x47)
#endif

class AP_Baro_BMP581 : public AP_Baro_Backend
{
public:
    AP_Baro_BMP581(AP_Baro &baro, AP_HAL::OwnPtr<AP_HAL::Device> dev);

    /* AP_Baro public interface: */
    void update() override;

    static AP_Baro_Backend *probe(AP_Baro &baro, AP_HAL::OwnPtr<AP_HAL::Device> dev);

private:

    bool init(void);
    void timer(void);

    AP_HAL::OwnPtr<AP_HAL::Device> _dev;

    uint8_t instance;
    float pressure_sum;
    uint32_t pressure_count;
    float temperature;
};

#endif  // AP_BARO_BMP581_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        