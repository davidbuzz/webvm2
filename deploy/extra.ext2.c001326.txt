const ftype SB2 = -SB0*q3 + SB1*q2;
        const ftype SB4 = -sq(q0) + sq(q1) - sq(q2) + sq(q3);
        ftype SB3, SB5_inv;
        if (is_positive(sq(SB2))) {
            SB3 = 1.0F/sq(SB2);
            SB5_inv = SB3*sq(SB4) + 1;
            canUseB = is_positive(fabsF(SB5_inv));
        }

        if (canUseA && (!canUseB || fabsF(SA5_inv) >= fabsF(SB5_inv))) {
            const ftype SA5 = 1.0F/SA5_inv;
            const ftype SA6 = 1.0F/SA3;
            const ftype SA7 = SA2*SA4;
            const ftype SA8 = 2*SA7;
            const ftype SA9 = 2*SA6;

            H_YAW[0] = SA5*(SA0*SA6 - SA8*q0);
            H_YAW[1] = SA5*(-SA1*SA6 + SA8*q1);
            H_YAW[2] = SA5*(-SA1*SA7 - SA9*q1);
            H_YAW[3] = SA5*(SA0*SA7 + SA9*q0);
        } else if (canUseB && (!canUseA || fabsF(SB5_inv) > fabsF(SA5_inv))) {
            const ftype SB5 = 1.0F/SB5_inv;
            const ftype SB6 = 1.0F/SB2;
            const ftype SB7 = SB3*SB4;
            const ftype SB8 = 2*SB7;
            const ftype SB9 = 2*SB6;

            H_YAW[0] = -SB5*(-SB0*SB6 + SB8*q3);
            H_YAW[1] = -SB5*(SB1*SB6 - SB8*q2);
            H_YAW[2] = -SB5*(-SB1*SB7 - SB9*q2);
            H_YAW[3] = -SB5*(SB0*SB7 + SB9*q3);
        } else {
            return false;
        }

        // Get the 312 Tait Bryan rotation angles
        Vector3F euler312 = stateStruct.quat.to_vector312();
        yawAngPredicted = euler312.z;

        // set the yaw to zero and calculate the zero yaw rotation from body to earth frame
        Tbn_zeroYaw.from_euler312(euler312.x, euler312.y, 0.0f);
    } else {
        // order not supported
        return false;
    }

    // Calculate the innovation
    switch (method) {
    case yawFusionMethod::MAGNETOMETER:
    {
        // Use the difference between the horizontal projection and declination to give the measured yaw
        // rotate measured mag components into earth frame
        Vector3F magMeasNED = Tbn_zeroYaw*magDataDelayed.mag;
        ftype yawAngMeasured = wrap_PI(-atan2F(magMeasNED.y, magMeasNED.x) + MagDeclination());
        innovYaw = wrap_PI(yawAngPredicted - yawAngMeasured);
        break;
    }

    case yawFusionMethod::GPS:
        innovYaw = wrap_PI(yawAngPredicted - yawAngDataDelayed.yawAng);
        break;

    case yawFusionMethod::STATIC:
        innovYaw = wrap_PI(yawAngPredicted - yawAngDataStatic.yawAng);
        break;

    case yawFusionMethod::GSF:
        innovYaw = wrap_PI(yawAngPredicted - gsfYaw);
        break;

    case yawFusionMethod::PREDICTED:
    default:
        innovYaw = 0.0f;
        break;

#if EK3_FEATURE_EXTERNAL_NAV
    case yawFusionMethod::EXTNAV:
        innovYaw = wrap_PI(yawAngPredicted - extNavYawAngDataDelayed.yawAng);
        break;
#endif
    }

    // Calculate innovation variance and Kalman gains, taking advantage of the fact that only the first 4 elements in H are non zero
    ftype PH[4];
    ftype varInnov = R_YAW;
    for (uint8_t rowIndex=0; rowIndex<=3; rowIndex++) {
        PH[rowIndex] = 0.0f;
        for (uint8_t colIndex=0; colIndex<=3; colIndex++) {
            PH[rowIndex] += P[rowIndex][colIndex]*H_YAW[colIndex];
        }
        varInnov += H_YAW[rowIndex]*PH[rowIndex];
    }
    ftype varInnovInv;
    if (varInnov >= R_YAW) {
        varInnovInv = 1.0f / varInnov;
        // output numerical health status
        faultStatus.bad_yaw = false;
    } else {
        // the calculation is badly conditioned, so we cannot perform fusion on this step
        // we reset the covariance matrix and try again next measurement
        CovarianceInit();
        // output numerical health status
        faultStatus.bad_yaw = true;
        return false;
    }

    // calculate Kalman gain
    for (uint8_t rowIndex=0; rowIndex<=stateIndexLim; rowIndex++) {
        Kfusion[rowIndex] = 0.0f;
        for (uint8_t colIndex=0; colIndex<=3; colIndex++) {
            Kfusion[rowIndex] += P[rowIndex][colIndex]*H_YAW[colIndex];
        }
        Kfusion[rowIndex] *= varInnovInv;
    }

    // calculate the innovation test ratio
    yawTestRatio = sq(innov#include <AP_HAL/AP_HAL.h>

#include "AP_NavEKF3_core.h"
#include <GCS_MAVLink/GCS.h>
#include <AP_Logger/AP_Logger.h>
#include <AP_DAL/AP_DAL.h>
#include <AP_InternalError/AP_InternalError.h>

#if AP_RANGEFINDER_ENABLED
/********************************************************
*              OPT FLOW AND RANGE FINDER                *
********************************************************/

// Read the range finder and take new measurements if available
// Apply a median filter
void NavEKF3_core::readRangeFinder(void)
{
    uint8_t midIndex;
    uint8_t maxIndex;
    uint8_t minIndex;
    // get theoretical correct range when the vehicle is on the ground
    // don't allow range to go below 5cm because this can cause problems with optical flow processing
    const auto *_rng = dal.rangefinder();
    if (_rng == nullptr) {
        return;
    }
    rngOnGnd = MAX(_rng->ground_clearance_cm_orient(ROTATION_PITCH_270) * 0.01f, 0.05f);

    // limit update rate to maximum allowed by data buffers
    if ((imuSampleTime_ms - lastRngMeasTime_ms) > frontend->sensorIntervalMin_ms) {

        // reset the timer used to control the measurement rate
        lastRngMeasTime_ms =  imuSampleTime_ms;

        // store samples and sample time into a ring buffer if valid
        // use data from two range finders if available

        for (uint8_t sensorIndex = 0; sensorIndex < ARRAY_SIZE(rngMeasIndex); sensorIndex++) {
            const auto *sensor = _rng->get_backend(sensorIndex);
            if (sensor == nullptr) {
                continue;
            }
            if ((sensor->orientation() == ROTATION_PITCH_270) && (sensor->status() == AP_DAL_RangeFinder::Status::Good)) {
                rngMeasIndex[sensorIndex] ++;
                if (rngMeasIndex[sensorIndex] > 2) {
                    rngMeasIndex[sensorIndex] = 0;
                }
                storedRngMeasTime_ms[sensorIndex][rngMeasIndex[sensorIndex]] = imuSampleTime_ms - 25;
                storedRngMeas[sensorIndex][rngMeasIndex[sensorIndex]] = sensor->distance_cm() * 0.01f;
            } else {
                continue;
            }

            // check for three fresh samples
            bool sampleFresh[DOWNWARD_RANGEFINDER_MAX_INSTANCES][3] = {};
            for (uint8_t index = 0; index <= 2; index++) {
                sampleFresh[sensorIndex][index] = (imuSampleTime_ms - storedRngMeasTime_ms[sensorIndex][index]) < 500;
            }

            // find the median value if we have three fresh samples
            if (sampleFresh[sensorIndex][0] && sampleFresh[sensorIndex][1] && sampleFresh[sensorIndex][2]) {
                if (storedRngMeas[sensorIndex][0] > storedRngMeas[sensorIndex][1]) {
                    minIndex = 1;
                    maxIndex = 0;
                } else {
                    minIndex = 0;
                    maxIndex = 1;
                }
                if (storedRngMeas[sensorIndex][2] > storedRngMeas[sensorIndex][maxIndex]) {
                    midIndex = maxIndex;
                } else if (storedRngMeas[sensorIndex][2] < storedRngMeas[sensorIndex][minIndex]) {
                    midIndex = minIndex;
                } else {
                    midIndex = 2;
                }

                // don't allow time to go backwards
                if (storedRngMeasTime_ms[sensorIndex][midIndex] > rangeDataNew.time_ms) {
                    rangeDataNew.time_ms = storedRngMeasTime_ms[sensorIndex][midIndex];
                }

                // limit the measured range to be no less than the on-ground range
                rangeDataNew.rng = MAX(storedRngMeas[sensorIndex][midIndex],rngOnGnd);

                // get position in body frame for the current sensor
                rangeDataNew.sensor_idx = sensorIndex;

                // write data to buffer with time stamp to be fused when the fusion time horizon catches up with it
                storedRange.push(rangeDataNew);

                // indicate we have updated the measurement
                rngValidMeaTime_ms = imuSampleTime_ms;

            } else if (onGround && ((imuSampleTime_ms - rngValidMeaTime_ms) > 200)) {
                // before takeoff we assume on-ground range value if there is no data
                rangeDataNew.time_ms = imuSampleTime_ms;
                rangeDataNew.rng = rngOnGnd;

                // write data to buffer with time stamp to be fused when the fusion time horizon catches up with it
                storedRange.push(rangeDataNew);

                // indicate we have updated the measurement
                rngValidMeaTime_ms = imuSampleTime_ms;

            }
        }
    }
}
#endif  // AP_RANGEFINDER_ENABLED

void NavEKF3_core::writeBodyFrameOdom(float quality, const Vector3f &delPos, const Vector3f &delAng, float delTime, uint32_t timeStamp_ms, uint16_t delay_ms, const Vector3f &posOffset)
{
#if EK3_FEATURE_BODY_ODOM
    // protect against NaN
    if (isnan(quality) || delPos.is_nan() || delAng.is_nan() || isnan(delTime) || posOffset.is_nan()) {
        return;
    }

    // limit update rate to maximum allowed by sensor buffers and fusion process
    // don't try to write to buffer until the filter has been initialised
    if (((timeStamp_ms - bodyOdmMeasTime_ms) < frontend->sensorIntervalMin_ms) || (delTime < dtEkfAvg) || !statesInitialised) {
        return;
    }

    // subtract delay from timestamp
    timeStamp_ms -= delay_ms;

    bodyOdmDataNew.body_offset = posOffset.toftype();
    bodyOdmDataNew.vel = delPos.toftype() * (1.0/delTime);
    bodyOdmDataNew.time_ms = timeStamp_ms;
    bodyOdmDataNew.angRate = (delAng * (1.0/delTime)).toftype();
    bodyOdmMeasTime_ms = timeStamp_ms;

    // simple model of accuracy
    // TODO move this calculation outside of EKF into the sensor driver
    bodyOdmDataNew.velErr = frontend->_visOdmVelErrMin + (frontend->_visOdmVelErrMax - frontend->_visOdmVelErrMin) * (1.0f - 0.01f * quality);

    storedBodyOdm.push(bodyOdmDataNew);
#endif // EK3_FEATURE_BODY_ODOM
}

void NavEKF3_core::writeWheelOdom(float delAng, float delTime, uint32_t timeStamp_ms, const Vector3f &posOffset, float radius)
{
#if EK3_FEATURE_BODY_ODOM
    // This is a simple hack to get wheel encoder data into the EKF and verify the interface sign conventions and units
    // It uses the exisiting body frame velocity fusion.
    // TODO implement a dedicated wheel odometry observation model

    // rate limiting to 50hz should be done by the caller
    // limit update rate to maximum allowed by sensor buffers and fusion process
    // don't try to write to buffer until the filter has been initialised
    if ((delTime < dtEkfAvg) || !statesInitialised) {
        return;
    }

    wheel_odm_elements wheelOdmDataNew = {};
    wheelOdmDataNew.hub_offset = posOffset.toftype();
    wheelOdmDataNew.delAng = delAng;
    wheelOdmDataNew.radius = radius;
    wheelOdmDataNew.delTime = delTime;

    // because we are currently converting to an equivalent velocity measurement before fusing
    // the measurement time is moved back to the middle of the sampling period
    wheelOdmDataNew.time_ms = timeStamp_ms - (uint32_t)(500.0f * delTime);

    storedWheelOdm.push(wheelOdmDataNew);
#endif // EK3_FEATURE_BODY_ODOM
}

// write the raw optical flow measurements
// this needs to be called externally.
void NavEKF3_core::writeOptFlowMeas(const uint8_t rawFlowQuality, const Vector2f &rawFlowRates, const Vector2f &rawGyroRates, const uint32_t msecFlowMeas, const Vector3f &posOffset, float heightOverride)
{
    // limit update rate to maximum allowed by sensor buffers
    if ((imuSampleTime_ms - flowMeaTime_ms) < frontend->sensorIntervalMin_ms) {
        return;
    }

    // The raw measurements need to be optical flow rates in radians/second averaged across the time since the last update
    // The PX4Flow sensor outputs flow rates with the following axis and sign conventions:
    // A positive X rate is produced by a positive sensor rotation about the X axis
    // A positive Y rate is produced by a positive sensor rotation about the Y axis
    // This filter uses a different definition of optical flow rates to the sensor with a positive optical flow rate produced by a
    // negative rotation about that axis. For example a positive rotation of the flight vehicle about its X (roll) axis would produce a negative X flow rate
    flowMeaTime_ms = imuSampleTime_ms;
    // calculate bias errors on flow sensor gyro rates, but protect against spikes in data
    // reset the accumulated body delta angle and time
    // don't do the calculation if not enough time lapsed for a reliable body rate measurement
    if (delTimeOF > 0.01f) {
        flowGyroBias.x = 0.99f * flowGyroBias.x + 0.01f * constrain_ftype((rawGyroRates.x - delAngBodyOF.x/delTimeOF),-0.1f,0.1f);
        flowGyroBias.y = 0.99f * flowGyroBias.y + 0.01f * constrain_ftype((rawGyroRates.y - delAngBodyOF.y/delTimeOF),-0.1f,0.1f);
        delAngBodyOF.zero();
        delTimeOF = 0.0f;
    }
    // by definition if this function is called, then flow measurements have been provided so we
    // need to run the optical flow takeoff detection
    detectOptFlowTakeoff();

    // don't use data with a low quality indicator or extreme rates (helps catch corrupt sensor data)
    if ((rawFlowQuality > 0) && rawFlowRates.length() < 4.2f && rawGyroRates.length() < 4.2f) {
        // correct flow sensor body rates for bias and write
        of_elements ofDataNew {};
        ofDataNew.bodyRadXYZ.x = rawGyroRates.x - flowGyroBias.x;
        ofDataNew.bodyRadXYZ.y = rawGyroRates.y - flowGyroBias.y;
        // the sensor interface doesn't provide a z axis rate so use the rate from the nav sensor instead
        if (delTimeOF > 0.001f) {
            // first preference is to use the rate averaged over the same sampling period as the flow sensor
            ofDataNew.bodyRadXYZ.z = delAngBodyOF.z / delTimeOF;
        } else if (imuDataNew.delAngDT > 0.001f){
            // second preference is to use most recent IMU data
            ofDataNew.bodyRadXYZ.z = imuDataNew.delAng.z / imuDataNew.delAngDT;
        } else {
            // third preference is use zero
            ofDataNew.bodyRadXYZ.z =  0.0f;
        }
        // write uncorrected flow rate measurements
        // note correction for different axis and sign conventions used by the px4flow sensor
        ofDataNew.flowRadXY = - rawFlowRates.toftype(); // raw (non motion compensated) optical flow angular rate about the X axis (rad/sec)
        // write the flow sensor position in body frame
        ofDataNew.body_offset = posOffset.toftype();
        // write the flow sensor height override
        ofDataNew.heightOverride = heightOverride;
        // write flow rate measurements corrected for body rates
        ofDataNew.flowRadXYcomp.x = ofDataNew.flowRadXY.x + ofDataNew.bodyRadXYZ.x;
        ofDataNew.flowRadXYcomp.y = ofDataNew.flowRadXY.y + ofDataNew.bodyRadXYZ.y;
        // record time last observation was received so we can detect loss of data elsewhere
        flowValidMeaTime_ms = imuSampleTime_ms;
        // estimate sample time of the measurement
        ofDataNew.time_ms = imuSampleTime_ms - frontend->_flowDelay_ms - frontend->flowTimeDeltaAvg_ms/2;
        // Correct for the average intersampling delay due to the filter updaterate
        ofDataNew.time_ms -= localFilterTimeStep_ms/2;
        // Prevent time delay exceeding age of oldest IMU data in the buffer
        ofDataNew.time_ms = MAX(ofDataNew.time_ms,imuDataDelayed.time_ms);
        // Save data to buffer
        storedOF.push(ofDataNew);
    }
}


/********************************************************
*                      MAGNETOMETER                     *
********************************************************/

// try changing compass, return true if a new compass is found
void NavEKF3_core::tryChangeCompass(void)
{
    const auto &compass = dal.compass();
    const uint8_t maxCount = compass.get_count();

    // search through the list of magnetometers
    for (uint8_t i=1; i<maxCount; i++) {
        uint8_t tempIndex = magSelectIndex + i;
        // loop back to the start index if we have exceeded the bounds
        if (tempIndex >= maxCount) {
            tempIndex -= maxCount;
        }
        // if the magnetometer is allowed to be used for yaw and has a different index, we start using it
        if (compass.healthy(tempIndex) && compass.use_for_yaw(tempIndex) && tempIndex != magSelectIndex) {
            magSelectIndex = tempIndex;
            GCS_SEND_TEXT(MAV_SEVERITY_INFO, "EKF3 IMU%u switching to compass %u",(unsigned)imu_index,magSelectIndex);
            // reset the timeout flag and timer
            magTimeout = false;
            lastHealthyMagTime_ms = imuSampleTime_ms;
            // zero the learned magnetometer bias states
            stateStruct.body_magfield.zero();
            // clear the measurement buffer
            storedMag.reset();
            // clear the data waiting flag so that we do not use any data pending from the previous sensor
            magDataToFuse = false;
            // request a reset of the magnetic field states
            magStateResetRequest = true;
            // declare the field unlearned so that the reset request will be obeyed
            magFieldLearned = false;
            // reset body mag variances on next CovariancePrediction
            needMagBodyVarReset = true;
            return;
        }
    }
}

// check for new magnetometer data and update store measurements if available
void NavEKF3_core::readMagData()
{
    const auto &compass = dal.compass();

    if (!compass.available()) {
        allMagSensorsFailed = true;
        return;        
    }

    // If we are a vehicle with a sideslip constraint to aid yaw estimation and we have timed out on our last avialable
    // magnetometer, then declare the magnetometers as failed for this flight
    const uint8_t maxCount = compass.get_count();
    if (allMagSensorsFailed || (magTimeout && assume_zero_sideslip() && magSelectIndex >= maxCount-1 && inFlight)) {
        allMagSensorsFailed = true;
        return;
    }

    if (compass.learn_offsets_enabled()) {
        wasLearningCompass_ms = imuSampleTime_ms;
    } else if (wasLearningCompass_ms != 0 && imuSampleTime_ms - wasLearningCompass_ms > 1000) {
        // allow time for old data to clear the buffer before signalling other code that compass data can be used
        wasLearningCompass_ms = 0;
    }

    // If the magnetometer has timed out (been rejected for too long), we find another magnetometer to use if available
    // Don't do this if we are on the ground because there can be magnetic interference and we need to know if there is a problem
    // before taking off. Don't do this within the first 30 seconds from startup because the yaw error could be due to large yaw gyro bias affsets
    // if the timeout is due to a sensor failure, then declare a timeout regardless of onground status
    if (maxCount > 1) {
        bool fusionTimeout = magTimeout && !onGround && imuSampleTime_ms - ekfStartTime_ms > 30000 && !(frontend->_affinity & EKF_AFFINITY_MAG);
        bool sensorTimeout = !compass.healthy(magSelectIndex) && imuSampleTime_ms - lastMagRead_ms > frontend->magFailTimeLimit_ms;
        if (fusionTimeout || sensorTimeout) {
            tryChangeCompass();
        }
    }

    // limit compass update rate to prevent high processor loading because magnetometer fusion is an expensive step and we could overflow the FIFO buffer
    if (use_compass() &&
        compass.healthy(magSelectIndex) &&
        ((compass.last_update_usec(magSelectIndex) - lastMagUpdate_us) > 1000 * frontend->sensorIntervalMin_ms)) {

        // detect changes to magnetometer offset parameters and reset states
        Vector3F nowMagOffsets = compass.get_offsets(magSelectIndex).toftype();
        bool changeDetected = lastMagOffsetsValid && (nowMagOffsets != lastMagOffsets);
        if (changeDetected) {
            // zero the learned magnetometer bias states
            stateStruct.body_magfield.zero();
            // clear the measurement buffer
            storedMag.reset();

            // reset body mag variances on next
            // CovariancePrediction. This copes with possible errors
            // in the new offsets
            needMagBodyVarReset = true;
        }
        lastMagOffsets = nowMagOffsets;
        lastMagOffsetsValid = true;

        // store time of last measurement update
        lastMagUpdate_us = compass.last_update_usec(magSelectIndex);

        // Magnetometer data at the current time horizon
        mag_elements magDataNew;

        // estimate of time magnetometer measurement was taken, allowing for delays
        magDataNew.time_ms = imuSampleTime_ms - frontend->magDelay_ms;

        // Correct for the average intersampling delay due to the filter updaterate
        magDataNew.time_ms -= localFilterTimeStep_ms/2;

        // read compass data and scale to improve numerical conditioning
        magDataNew.mag = (compass.get_field(magSelectIndex) * 0.001f).toftype();

        // check for consistent data between magnetometers
        consistentMagData = compass.consistent();

        // save magnetometer measurement to buffer to be fused later
        storedMag.push(magDataNew);

        // remember time we read compass, to detect compass sensor failure
        lastMagRead_ms = imuSampleTime_ms;
    }
}

/********************************************************
*                Inertial Measurements                  *
********************************************************/

/*
 *  Read IMU delta angle and delta velocity measurements and downsample to 100Hz
 *  for storage in the data buffers used by the EKF. If the IMU data arrives at
 *  lower rate than 100Hz, then no downsampling or upsampling will be performed.
 *  Downsampling is done using a method that does not introduce coning or sculling
 *  errors.
 */
void NavEKF3_core::readIMUData(bool startPredictEnabled)
{
    const auto &ins = dal.ins();

    // calculate an averaged IMU update rate using a spike and lowpass filter combination
    dtIMUavg = 0.02f * constrain_ftype(ins.get_loop_delta_t(),0.5f * dtIMUavg, 2.0f * dtIMUavg) + 0.98f * dtIMUavg;

    // the imu sample time is used as a common time reference throughout the filter
    imuSampleTime_ms = frontend->imuSampleTime_us / 1000;

    uint8_t accel_active, gyro_active;

    if (ins.use_accel(imu_index)) {
        accel_active = imu_index;
    } else {
        accel_active = ins.get_first_usable_accel();
    }

    if (ins.use_gyro(imu_index)) {
        gyro_active = imu_index;
    } else {
        gyro_active = ins.get_first_usable_gyro();
    }

    if (gyro_active != gyro_index_active) {
        // we are switching active gyro at runtime. Copy over the
        // bias we have learned from the previously inactive
        // gyro. We don't re-init the bias uncertainty as it should
        // have the same uncertainty as the previously active gyro
        stateStruct.gyro_bias = inactiveBias[gyro_active].gyro_bias;
        gyro_index_active = gyro_active;
    }

    if (accel_active != accel_index_active) {
        // switch to the learned accel bias for this IMU
        stateStruct.accel_bias = inactiveBias[accel_active].accel_bias;
        accel_index_active = accel_active;
    }

    // update the inactive bias states
    learnInactiveBiases();

    // run movement check using IMU data
    updateMovementCheck();

    readDeltaVelocity(accel_index_active, imuDataNew.delVel, imuDataNew.delVelDT);
    accelPosOffset = ins.get_imu_pos_offset(accel_index_active).toftype();
    imuDataNew.accel_index = accel_index_active;
    
    // Get delta angle data from primary gyro or primary if not available
    readDeltaAngle(gyro_index_active, imuDataNew.delAng, imuDataNew.delAngDT);
    imuDataNew.delAngDT = MAX(imuDataNew.delAngDT, 1.0e-4f);
    imuDataNew.gyro_index = gyro_index_active;

    // Get current time stamp
    imuDataNew.time_ms = imuSampleTime_ms;

    // Accumulate the measurement time interval for the delta velocity and angle data
    imuDataDownSampledNew.delAngDT += imuDataNew.delAngDT;
    imuDataDownSampledNew.delVelDT += imuDataNew.delVelDT;

    // use the most recent IMU index for the downsampled IMU
    // data. This isn't strictly correct if we switch IMUs between
    // samples
    imuDataDownSampledNew.gyro_index = imuDataNew.gyro_index;
    imuDataDownSampledNew.accel_index = imuDataNew.accel_index;

    // Rotate quaternon atitude from previous to new and normalise.
    // Accumulation using quaternions prevents introduction of coning errors due to downsampling
    imuQuatDownSampleNew.rotate(imuDataNew.delAng);
    imuQuatDownSampleNew.normalize();

    // Rotate the latest delta velocity into body frame at the start of accumulation
    Matrix3F deltaRotMat;
    imuQuatDownSampleNew.rotation_matrix(deltaRotMat);

    // Apply the delta velocity to the delta velocity accumulator
    imuDataDownSampledNew.delVel += deltaRotMat*imuDataNew.delVel;

    // Keep track of the number of IMU frames since the last state prediction
    framesSincePredict++;

    /*
     * If the target EKF time step has been accumulated, and the frontend has allowed start of a new predict cycle,
     * then store the accumulated IMU data to be used by the state prediction, ignoring the frontend permission if more
     * than twice the target time has lapsed. Adjust the target EKF step time threshold to allow for timing jitter in the
     * IMU data.
     */
    if ((imuDataDownSampledNew.delAngDT >= (EKF_TARGET_DT-(dtIMUavg*0.5f)) && startPredictEnabled) ||
        (imuDataDownSampledNew.delAngDT >= 2.0f*EKF_TARGET_DT)) {

        // convert the accumulated quaternion to an equivalent delta angle
        imuQuatDownSampleNew.to_axis_angle(imuDataDownSampledNew.delAng);

        // Time stamp the data
        imuDataDownSampledNew.time_ms = imuSampleTime_ms;

        // Write data to the FIFO IMU buffer
        storedIMU.push_youngest_element(imuDataDownSampledNew);

        // calculate the achieved average time step rate for the EKF using a combination spike and LPF
        ftype dtNow = constrain_ftype(0.5f*(imuDataDownSampledNew.delAngDT+imuDataDownSampledNew.delVelDT),0.5f * dtEkfAvg, 2.0f * dtEkfAvg);
        dtEkfAvg = 0.98f * dtEkfAvg + 0.02f * dtNow;

        // do an addtional down sampling for data used to sample XY body frame drag specific forces
        SampleDragData(imuDataDownSampledNew);

        // zero the accumulated IMU data and quaternion
        imuDataDownSampledNew.delAng.zero();
        imuDataDownSampledNew.delVel.zero();
        imuDataDownSampledNew.delAngDT = 0.0f;
        imuDataDownSampledNew.delVelDT = 0.0f;
        imuQuatDownSampleNew[0] = 1.0f;
        imuQuatDownSampleNew[3] = imuQuatDownSampleNew[2] = imuQuatDownSampleNew[1] = 0.0f;

        // reset the counter used to let the frontend know how many frames have elapsed since we started a new update cycle
        framesSincePredict = 0;

        // set the flag to let the filter know it has new IMU data and needs to run
        runUpdates = true;

        // extract the oldest available data from the FIFO buffer
        imuDataDelayed = storedIMU.get_oldest_element();

        // protect against delta time going to zero
        ftype minDT = 0.1f * dtEkfAvg;
        imuDataDelayed.delAngDT = MAX(imuDataDelayed.delAngDT,minDT);
        imuDataDelayed.delVelDT = MAX(imuDataDelayed.delVelDT,minDT);

        updateTimingStatistics();
        
        // correct the extracted IMU data for sensor errors
        delAngCorrected = imuDataDelayed.delAng;
        delVelCorrected = imuDataDelayed.delVel;
        correctDeltaAngle(delAngCorrected, imuDataDelayed.delAngDT, imuDataDelayed.gyro_index);
        correctDeltaVelocity(delVelCorrected, imuDataDelayed.delVelDT, imuDataDelayed.accel_index);

    } else {
        // we don't have new IMU data in the buffer so don't run filter updates on this time step
        runUpdates = false;
    }
}

// read the delta velocity and corresponding time interval from the IMU
// return false if data is not available
bool NavEKF3_core::readDeltaVelocity(uint8_t ins_index, Vector3F &dVel, ftype &dVel_dt) {
    const auto &ins = dal.ins();

    if (ins_index < ins.get_accel_count()) {
        Vector3f dVelF;
        float dVel_dtF;
        ins.get_delta_velocity(ins_index, dVelF, dVel_dtF);
        dVel = dVelF.toftype();
        dVel_dt = dVel_dtF;
        dVel_dt = MAX(dVel_dt,1.0e-4);
        return true;
    }
    return false;
}

/********************************************************
*             Global Position Measurement               *
********************************************************/

// check for new valid GPS data and update stored measurement if available
void NavEKF3_core::readGpsData()
{
    // check for new GPS data
    const auto &gps = dal.gps();

    // limit update rate to avoid overflowing the FIFO buffer
    if (gps.last_message_time_ms(selected_gps) - lastTimeGpsReceived_ms <= frontend->sensorIntervalMin_ms) {
        return;
    }

    if (gps.status(selected_gps) < AP_DAL_GPS::GPS_OK_FIX_3D) {
        // report GPS fix status
        gpsCheckStatus.bad_fix = true;
        dal.snprintf(prearm_fail_string, sizeof(prearm_fail_string), "Waiting for 3D fix");
        return;
    }

    // report GPS fix status
    gpsCheckStatus.bad_fix = false;

    // store fix time from previous read
    const uint32_t secondLastGpsTime_ms = lastTimeGpsReceived_ms;

    // get current fix time
    lastTimeGpsReceived_ms = gps.last_message_time_ms(selected_gps);

    // estimate when the GPS fix was valid, allowing for GPS processing and other delays
    // ideally we should be using a timing signal from the GPS receiver to set this time
    // Use the driver specified delay
    float gps_delay_sec = 0;
    gps.get_lag(selected_gps, gps_delay_sec);
    gpsDataNew.time_ms = lastTimeGpsReceived_ms - (uint32_t)(gps_delay_sec * 1000.0f);

    // Correct for the average intersampling delay due to the filter updaterate
    gpsDataNew.time_ms -= localFilterTimeStep_ms/2;

    // Prevent the time stamp falling outside the oldest and newest IMU data in the buffer
    gpsDataNew.time_ms = MIN(MAX(gpsDataNew.time_ms,imuDataDelayed.time_ms),imuDataDownSampledNew.time_ms);

    // Get which GPS we are using for position information
    gpsDataNew.sensor_idx = selected_gps;

    // read the NED velocity from the GPS
    gpsDataNew.vel = gps.velocity(selected_gps).toftype();
    gpsDataNew.have_vz = gps.have_vertical_velocity(selected_gps);

    // position and velocity are not yet corrected for sensor position
    gpsDataNew.corrected = false;

    // Use the speed and position accuracy from the GPS if available, otherwise set it to zero.
    // Apply a decaying envelope filter with a 5 second time constant to the raw accuracy data
    ftype alpha = constrain_ftype(0.0002f * (lastTimeGpsReceived_ms - secondLastGpsTime_ms),0.0f,1.0f);
    gpsSpdAccuracy *= (1.0f - alpha);
    float gpsSpdAccRaw;
    if (!gps.speed_accuracy(selected_gps, gpsSpdAccRaw)) {
        gpsSpdAccuracy = 0.0f;
    } else {
        gpsSpdAccuracy = MAX(gpsSpdAccuracy,gpsSpdAccRaw);
        gpsSpdAccuracy = MIN(gpsSpdAccuracy,50.0f);
        gpsSpdAccuracy = MAX(gpsSpdAccuracy,frontend->_gpsHorizVelNoise);
    }
    gpsPosAccuracy *= (1.0f - alpha);
    float gpsPosAccRaw;
    if (!gps.horizontal_accuracy(selected_gps, gpsPosAccRaw)) {
        gpsPosAccuracy = 0.0f;
    } else {
        gpsPosAccuracy = MAX(gpsPosAccuracy,gpsPosAccRaw);
        gpsPosAccuracy = MIN(gpsPosAccuracy,100.0f);
        gpsPosAccuracy = MAX(gpsPosAccuracy, frontend->_gpsHorizPosNoise);
    }
    gpsHgtAccuracy *= (1.0f - alpha);
    float gpsHgtAccRaw;
    if (!gps.vertical_accuracy(selected_gps, gpsHgtAccRaw)) {
        gpsHgtAccuracy = 0.0f;
    } else {
        gpsHgtAccuracy = MAX(gpsHgtAccuracy,gpsHgtAccRaw);
        gpsHgtAccuracy = MIN(gpsHgtAccuracy,100.0f);
        gpsHgtAccuracy = MAX(gpsHgtAccuracy, 1.5f * frontend->_gpsHorizPosNoise);
    }

    // check if we have enough GPS satellites and increase the gps noise scaler if we don't
    if (gps.num_sats(selected_gps) >= 6 && (PV_AidingMode == AID_ABSOLUTE)) {
        gpsNoiseScaler = 1.0f;
    } else if (gps.num_sats(selected_gps) == 5 && (PV_AidingMode == AID_ABSOLUTE)) {
        gpsNoiseScaler = 1.4f;
    } else { // <= 4 satellites or in constant position mode
        gpsNoiseScaler = 2.0f;
    }

    // Check if GPS can output vertical velocity, vertical velocity use is permitted and set GPS fusion mode accordingly
    if (gpsDataNew.have_vz && frontend->sources.useVelZSource(AP_NavEKF_Source::SourceZ::GPS)) {
        useGpsVertVel = true;
    } else {
        useGpsVertVel = false;
    }

    if ((frontend->_options & (int32_t)NavEKF3::Options::JammingExpected) &&
        (lastTimeGpsReceived_ms - secondLastGpsTime_ms) > frontend->gpsNoFixTimeout_ms) {
        const bool doingBodyVelNav = (imuSampleTime_ms - prevBodyVelFuseTime_ms < 1000);
        const bool doingFlowNav = (imuSampleTime_ms - prevFlowFuseTime_ms < 1000);;
        const bool canDoWindRelNav = assume_zero_sideslip();
        const bool canDeadReckon = ((doingFlowNav && gndOffsetValid) || canDoWindRelNav || doingBodyVelNav);
        if (canDeadReckon) {
            // If we can do dead reckoning with a data source other than GPS there is time to wait
            // for GPS alignment checks to pass before using GPS inside the EKF.
            // this gets set back to false in calcGpsGoodToAlign() when GPS checks pass
            waitingForGpsChecks = true;
            // force GPS checks to restart
            lastPreAlignGpsCheckTime_ms = 0;
            lastGpsVelFail_ms = imuSampleTime_ms;
            lastGpsVelPass_ms = 0;
            gpsGoodToAlign = false;
        } else {
            waitingForGpsChecks = false;
        }
    }

    // Monitor quality of the GPS velocity data before and after alignment
    calcGpsGoodToAlign();

    // Post-alignment checks
    calcGpsGoodForFlight();

    // Read the GPS location in WGS-84 lat,long,height coordinates
    const Location &gpsloc = gps.location(selected_gps);

    // Set the EKF origin and magnetic field declination if not previously set and GPS checks have passed
    if (gpsGoodToAlign && !validOrigin) {
        Location gpsloc_fieldelevation = gpsloc; 
        // if flying, correct for height change from takeoff so that the origin is at field elevation
        if (inFlight) {
            gpsloc_fieldelevation.alt += (int32_t)(100.0f * stateStruct.position.z);
        }

        if (!setOrigin(gpsloc_fieldelevation)) {
            // set an error as an attempt was made to set the origin more than once
            INTERNAL_ERROR(AP_InternalError::error_t::flow_of_control);
            return;
        }

        // set the NE earth magnetic field states using the published declination
        // and set the corresponding variances and covariances
        alignMagStateDeclination();

        // Set the height of the NED origin
        ekfGpsRefHgt = (double)0.01 * (double)gpsloc.alt + (double)outputDataNew.position.z;

        // Set the uncertainty of the GPS origin height
        ekfOriginHgtVar = sq(gpsHgtAccuracy);

    }

    if (gpsGoodToAlign && !have_table_earth_field) {
        setEarthFieldFromLocation(gpsloc);
    }

    // convert GPS measurements to local NED and save to buffer to be fused later if we have a valid origin
    // and are not waiting for GPs checks to pass
    if (validOrigin && !waitingForGpsChecks) {
        gpsDataNew.lat = gpsloc.lat;
        gpsDataNew.lng = gpsloc.lng;
        if ((frontend->_originHgtMode & (1<<2)) == 0) {
            // the height adjustment to match GPS is being achieved by adjusting the origin height
            gpsDataNew.hgt = (ftype)((double)0.01 * (double)gpsloc.alt - ekfGpsRefHgt);
        } else {
            // the height adjustment to match GPS is being achieved by adjusting the measurements
            gpsDataNew.hgt = 0.01 * (gpsloc.alt - EKF_origin.alt);
        }
        storedGPS.push(gpsDataNew);
        // declare GPS in use
        gpsIsInUse = true;
    }
}

// check for new valid GPS yaw data
void NavEKF3_core::readGpsYawData()
{
    const auto &gps = dal.gps();

    // if the GPS has yaw data then fuse it as an Euler yaw angle
    float yaw_deg, yaw_accuracy_deg;
    uint32_t yaw_time_ms;
    if (gps.status(selected_gps) >= AP_DAL_GPS::GPS_OK_FIX_3D &&
        dal.gps().gps_yaw_deg(selected_gps, yaw_deg, yaw_accuracy_deg, yaw_time_ms) &&
        yaw_time_ms != yawMeasTime_ms) {
        /avYawAngDataNew.order = rotationOrder::TAIT_BRYAN_321; // Euler rotation order is 321 (ZYX)
        extNavYawAngDataNew.time_ms = timeStamp_ms;
        storedExtNavYawAng.push(extNavYawAngDataNew);
    }
#endif // EK3_FEATURE_EXTERNAL_NAV
}

void NavEKF3_core::writeExtNavVelData(const Vector3f &vel, float err, uint32_t timeStamp_ms, uint16_t delay_ms)
{
#if EK3_FEATURE_EXTERNAL_NAV
    // sanity check for NaNs
    if (vel.is_nan() || isnan(err)) {
        return;
    }

    if ((timeStamp_ms - extNavVelMeasTime_ms) < frontend->extNavIntervalMin_ms) {
        return;
    }

    extNavVelMeasTime_ms = timeStamp_ms;
    useExtNavVel = true;
    // calculate timestamp
    timeStamp_ms = timeStamp_ms - delay_ms;
    // Correct for the average intersampling delay due to the filter updaterate
    timeStamp_ms -= localFilterTimeStep_ms/2;
    // Prevent time delay exceeding age of oldest IMU data in the buffer
    timeStamp_ms = MAX(timeStamp_ms,imuDataDelayed.time_ms);

    ext_nav_vel_elements extNavVelNew;
    extNavVelNew.time_ms = timeStamp_ms;
    extNavVelNew.vel = vel.toftype();
    extNavVelNew.err = err;
    extNavVelNew.corrected = false;

    storedExtNavVel.push(extNavVelNew);
#endif // EK3_FEATURE_EXTERNAL_NAV
}

/*
  update the GPS selection
 */
void NavEKF3_core::update_gps_selection(void)
{
    const auto &gps = dal.gps();

    // in normal operation use the primary GPS
    selected_gps = gps.primary_sensor();
    preferred_gps = selected_gps;

    if (frontend->_affinity & EKF_AFFINITY_GPS) {
        if (core_index < gps.num_sensors() ) {
            // always prefer our core_index, unless we don't have that
            // many GPS sensors available
            preferred_gps = core_index;
        }
        if (gps.status(preferred_gps) >= AP_DAL_GPS::GPS_OK_FIX_3D) {
            // select our preferred_gps if it has a 3D fix, otherwise
            // use the primary GPS
            selected_gps = preferred_gps;
        }
    }
}

/*
  update the mag selection
 */
void NavEKF3_core::update_mag_selection(void)
{
    const auto &compass = dal.compass();

    if (frontend->_affinity & EKF_AFFINITY_MAG) {
        if (core_index < compass.get_count() &&
            compass.healthy(core_index) &&
            compass.use_for_yaw(core_index)) {
            // use core_index compass if it is healthy
            magSelectIndex = core_index;
        }
    }
}

/*
  update the baro selection
 */
void NavEKF3_core::update_baro_selection(void)
{
    auto &baro = dal.baro();

    // in normal operation use the primary baro
    selected_baro = baro.get_primary();

    if (frontend->_affinity & EKF_AFFINITY_BARO) {
        if (core_index < baro.num_instances() &&
            baro.healthy(core_index)) {
            // use core_index baro if it is healthy
            selected_baro = core_index;
        }
    }
}

/*
  update the airspeed selection
 */
void NavEKF3_core::update_airspeed_selection(void)
{
    const auto *arsp = dal.airspeed();
    if (arsp == nullptr) {
        return;
    }

    // in normal operation use the primary airspeed sensor
    selected_airspeed = arsp->get_primary();

    if (frontend->_affinity & EKF_AFFINITY_ARSP) {
        if (core_index < arsp->get_num_sensors() &&
            arsp->healthy(core_index) &&
            arsp->use(core_index)) {
            // use core_index airspeed if it is healthy
            selected_airspeed = core_index;
        }
    }
}

/*
  update sensor selections
 */
void NavEKF3_core::update_sensor_selection(void)
{
    update_gps_selection();
    update_mag_selection();
    update_baro_selection();
    update_airspeed_selection();
}

/*
  update timing statistics structure
 */
void NavEKF3_core::updateTimingStatistics(void)
{
    if (timing.count == 0) {
        timing.dtIMUavg_max = dtIMUavg;
        timing.dtIMUavg_min = dtIMUavg;
        timing.dtEKFavg_max = dtEkfAvg;
        timing.dtEKFavg_min = dtEkfAvg;
        timing.delAngDT_max = imuDataDelayed.delAngDT;
        timing.delAngDT_min = imuDataDelayed.delAngDT;
        timing.delVelDT_max = imuDataDelayed.delVelDT;
 /*
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
#pragma once

#include "AP_Notify_config.h"

#if AP_NOTIFY_GPIO_LED_2_ENABLED

#include <AP_Common/AP_Common.h>
#include <AP_HAL/AP_HAL_Boards.h>

#include "NotifyDevice.h"

class AP_BoardLED2: public NotifyDevice
{
public:
    // initialise the LED driver
    bool init(void) override;

    // should be called at 50Hz
    void update(void) override;

private:
    // counter incremented at 50Hz
    uint8_t _counter;
    uint16_t _sat_cnt;
    uint8_t save_trim_counter;
    uint8_t arm_counter = 0;
};

#endif  // AP_NOTIFY_GPIO_LED_2_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     /*
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include "AP_Notify/AP_Notify.h"
#include <AP_HAL/RCOutput.h>
#include "DShotLED.h"
#include "SRV_Channel/SRV_Channel.h"

extern const AP_HAL::HAL& hal;

bool DShotLED::hw_set_rgb(uint8_t red, uint8_t green, uint8_t blue)
{
    // don't play the motor LEDs while flying
    if (hal.util->get_soft_armed() || (hal.rcout->get_dshot_esc_type() != AP_HAL::RCOutput::DSHOT_ESC_BLHELI
        && hal.rcout->get_dshot_esc_type() != AP_HAL::RCOutput::DSHOT_ESC_BLHELI_EDT)) {
        return false;
    }

    hal.rcout->send_dshot_command(red ? AP_HAL::RCOutput::DSHOT_LED1_ON : AP_HAL::RCOutput::DSHOT_LED1_OFF);
    hal.rcout->send_dshot_command(green ? AP_HAL::RCOutput::DSHOT_LED2_ON : AP_HAL::RCOutput::DSHOT_LED2_OFF);
    hal.rcout->send_dshot_command(blue ? AP_HAL::RCOutput::DSHOT_LED0_ON : AP_HAL::RCOutput::DSHOT_LED0_OFF);

    return true;
}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        /*
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
#pragma once

#include "RGBLed.h"
#include "DShotLED.h"
#include <AP_Common/AP_Common.h>

class DShotLED : public RGBLed {
public:
    DShotLED() : RGBLed(0, 1, 1, 1) {}

    bool init(void) override { return true; }

protected:
    bool hw_set_rgb(uint8_t r, uint8_t g, uint8_t b) override;
};
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                #pragma once

#include <AP_HAL/AP_HAL_Boards.h>
#include <AP_MSP/AP_MSP_config.h>
#include <GCS_MAVLink/GCS_config.h>

#ifndef AP_OPTICALFLOW_ENABLED
#define AP_OPTICALFLOW_ENABLED 1
#endif

#ifndef AP_OPTICALFLOW_CALIBRATOR_ENABLED
#define AP_OPTICALFLOW_CALIBRATOR_ENABLED AP_OPTICALFLOW_ENABLED
#endif

#ifndef AP_OPTICALFLOW_BACKEND_DEFAULT_ENABLED
#define AP_OPTICALFLOW_BACKEND_DEFAULT_ENABLED AP_OPTICALFLOW_ENABLED
#endif

#ifndef AP_OPTICALFLOW_CXOF_ENABLED
#define AP_OPTICALFLOW_CXOF_ENABLED AP_OPTICALFLOW_BACKEND_DEFAULT_ENABLED
#endif

#ifndef AP_OPTICALFLOW_HEREFLOW_ENABLED
#define AP_OPTICALFLOW_HEREFLOW_ENABLED (AP_OPTICALFLOW_BACKEND_DEFAULT_ENABLED && HAL_ENABLE_DRONECAN_DRIVERS)
#endif

#ifndef AP_OPTICALFLOW_MAV_ENABLED
#define AP_OPTICALFLOW_MAV_ENABLED (AP_OPTICALFLOW_BACKEND_DEFAULT_ENABLED && HAL_GCS_ENABLED)
#endif

#ifndef HAL_MSP_OPTICALFLOW_ENABLED
#define HAL_MSP_OPTICALFLOW_ENABLED (AP_OPTICALFLOW_BACKEND_DEFAULT_ENABLED && HAL_MSP_ENABLED)
#endif

#ifndef AP_OPTICALFLOW_ONBOARD_ENABLED
#define AP_OPTICALFLOW_ONBOARD_ENABLED (AP_OPTICALFLOW_BACKEND_DEFAULT_ENABLED && CONFIG_HAL_BOARD == HAL_BOARD_LINUX && CONFIG_HAL_BOARD_SUBTYPE == HAL_BOARD_SUBTYPE_LINUX_BEBOP)
#endif

#ifndef AP_OPTICALFLOW_PIXART_ENABLED
#define AP_OPTICALFLOW_PIXART_ENABLED AP_OPTICALFLOW_BACKEND_DEFAULT_ENABLED
#endif

#ifndef AP_OPTICALFLOW_PX4FLOW_ENABLED
#define AP_OPTICALFLOW_PX4FLOW_ENABLED AP_OPTICALFLOW_BACKEND_DEFAULT_ENABLED
#endif

#ifndef AP_OPTICALFLOW_SITL_ENABLED
#define AP_OPTICALFLOW_SITL_ENABLED (AP_OPTICALFLOW_BACKEND_DEFAULT_ENABLED && AP_SIM_ENABLED)
#endif

#ifndef AP_OPTICALFLOW_UPFLOW_ENABLED
#define AP_OPTICALFLOW_UPFLOW_ENABLED AP_OPTICALFLOW_BACKEND_DEFAULT_ENABLED
#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    /*
 *  Example of AP_OpticalFlow library.
 *  Code by Randy Mackay. DIYDrones.com
 */

#include <AP_AHRS/AP_AHRS.h>
#include <AP_Baro/AP_Baro.h>
#include <AP_Compass/AP_Compass.h>
#include <AP_GPS/AP_GPS.h>
#include <AP_HAL/AP_HAL.h>
#include <AP_InertialSensor/AP_InertialSensor.h>
#include <AP_NavEKF2/AP_NavEKF2.h>
#include <AP_NavEKF3/AP_NavEKF3.h>
#include <AP_OpticalFlow/AP_OpticalFlow.h>
#include <AP_RangeFinder/AP_RangeFinder.h>
#include <AP_SerialManager/AP_SerialManager.h>

void setup();
void loop();

const AP_HAL::HAL& hal = AP_HAL::get_HAL();

class DummyVehicle {
public:
    AP_GPS gps;
    AP_Baro barometer;
    Compass compass;
    AP_InertialSensor ins;
    AP_SerialManager serial_manager;
    RangeFinder sonar;
    AP_AHRS ahrs{AP_AHRS::FLAG_ALWAYS_USE_EKF};
};

static DummyVehicle vehicle;
#if AP_OPTICALFLOW_ENABLED
static AP_OpticalFlow optflow;
#endif

void setup()
{
    hal.console->printf("OpticalFlow library test ver 1.6\n");

    hal.scheduler->delay(1000);

#if AP_OPTICALFLOW_ENABLED
    // flowSensor initialization
    optflow.init(-1);

    if (!optflow.healthy()) {
        hal.console->printf("Failed to initialise OpticalFlow");
    }
#else
    hal.console->printf("OpticalFlow compiled out");
#endif

    hal.scheduler->delay(1000);
}

void loop()
{
    hal.console->printf("this only tests compilation succeeds\n");

    hal.scheduler->delay(5000);
}

AP_HAL_MAIN();
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           BootloaderPacket
// end of ServoCommands.c
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ture
 * \param dutyCycle receives Motor duty cycle
 * \param speed receives Servo output shaft speed
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeServo_StatusBPacket(const void* _pg_pkt, uint16_t* current, uint16_t* voltage, int8_t* temperature, int8_t* dutyCycle, int16_t* speed)
{
    int _pg_byteindex = 0;
    const uint8_t* _pg_data = getServoPacketDataConst(_pg_pkt);
    int _pg_numbytes = getServoPacketSize(_pg_pkt);

    // Verify the packet identifier
    if(getServoPacketID(_pg_pkt) != getServo_StatusBPacketID())
        return 0;

    if(_pg_numbytes < getServo_StatusBMinDataLength())
        return 0;

    // this packet has default fields, make sure they are set
    (*dutyCycle) = 0;
    (*speed) = 0;

    // Servo current
    // Range of current is 0 to 65535.
    (*current) = uint16FromBeBytes(_pg_data, &_pg_byteindex);

    // Servo supply voltage
    // Range of voltage is 0 to 65535.
    (*voltage) = uint16FromBeBytes(_pg_data, &_pg_byteindex);

    // Servo temperature
    // Range of temperature is -128 to 127.
    (*temperature) = int8FromBytes(_pg_data, &_pg_byteindex);

    if(_pg_byteindex + 1 > _pg_numbytes)
        return 1;

    // Motor duty cycle
    // Range of dutyCycle is -128 to 127.
    (*dutyCycle) = int8FromBytes(_pg_data, &_pg_byteindex);

    if(_pg_byteindex + 2 > _pg_numbytes)
        return 1;

    // Servo output shaft speed
    // Range of speed is -32768 to 32767.
    (*speed) = int16FromBeBytes(_pg_data, &_pg_byteindex);

    return 1;

}// decodeServo_StatusBPacket

/*!
 * \brief Create the Servo_StatusC packet
 *
 * The *SERVO_STATUS_C* packet contains servo position data. It is a cut-down
 * packet to allow high-speed feedback on servo position
 * \param _pg_pkt points to the packet which will be created by this function
 * \param _pg_user points to the user data that will be encoded in _pg_pkt
 */
void encodeServo_StatusCPacketStructure(void* _pg_pkt, const Servo_StatusC_t* _pg_user)
{
    uint8_t* _pg_data = getServoPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    // Servo position, mapped to input units
    // Range of position is -32768 to 32767.
    int16ToBeBytes(_pg_user->position, _pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finishServoPacket(_pg_pkt, _pg_byteindex, getServo_StatusCPacketID());

}// encodeServo_StatusCPacketStructure

/*!
 * \brief Decode the Servo_StatusC packet
 *
 * The *SERVO_STATUS_C* packet contains servo position data. It is a cut-down
 * packet to allow high-speed feedback on servo position
 * \param _pg_pkt points to the packet being decoded by this function
 * \param _pg_user receives the data decoded from the packet
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeServo_StatusCPacketStructure(const void* _pg_pkt, Servo_StatusC_t* _pg_user)
{
    int _pg_numbytes;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data;

    // Verify the packet identifier
    if(getServoPacketID(_pg_pkt) != getServo_StatusCPacketID())
        return 0;

    // Verify the packet size
    _pg_numbytes = getServoPacketSize(_pg_pkt);
    if(_pg_numbytes < getServo_StatusCMinDataLength())
        return 0;

    // The raw data from the packet
    _pg_data = getServoPacketDataConst(_pg_pkt);

    // Servo position, mapped to input units
    // Range of position is -32768 to 32767.
    _pg_user->position = int16FromBeBytes(_pg_data, &_pg_byteindex);

    return 1;

}// decodeServo_StatusCPacketStructure

/*!
 * \brief Create the Servo_StatusC packet
 *
 * The *SERVO_STATUS_C* packet contains servo position data. It is a cut-down
 * packet to allow high-speed feedback on servo position
 * \param _pg_pkt points to the packet which will be created by this function
 * \param position is Servo position, mapped to input units
 */
void encodeServo_StatusCPacket(void* _pg_pkt, int16_t position)
{
    uint8_t* _pg_data = getServoPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    // Servo position, mapped to input units
    // Range of position is -32768 to 32767.
    int16ToBeBytes(position, _pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finishServoPacket(_pg_pkt, _pg_byteindex, getServo_StatusCPacketID());

}// encodeServo_StatusCPacket

/*!
 * \brief Decode the Servo_StatusC packet
 *
 * The *SERVO_STATUS_C* packet contains servo position data. It is a cut-down
 * packet to allow high-speed feedback on servo position
 * \param _pg_pkt points to the packet being decoded by this function
 * \param position receives Servo position, mapped to input units
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeServo_StatusCPacket(const void* _pg_pkt, int16_t* position)
{
    int _pg_byteindex = 0;
    const uint8_t* _pg_data = getServoPacketDataConst(_pg_pkt);
    int _pg_numbytes = getServoPacketSize(_pg_pkt);

    // Verify the packet identifier
    if(getServoPacketID(_pg_pkt) != getServo_StatusCPacketID())
        return 0;

    if(_pg_numbytes < getServo_StatusCMinDataLength())
        return 0;

    // Servo position, mapped to input units
    // Range of position is -32768 to 32767.
    (*position) = int16FromBeBytes(_pg_data, &_pg_byteindex);

    return 1;

}// decodeServo_StatusCPacket

/*!
 * \brief Create the Servo_Accelerometer packet
 *
 * Raw accelerometer data. To convert these raw readings to 'real' units, use
 * the formula acc = 0.5 * raw * fullscale / (2^resolution)
 * \param _pg_pkt points to the packet which will be created by this function
 * \param xAcc is X axis acceleration value
 * \param yAcc is Y axis acceleration value
 * \param zAcc is Z axis acceleration value
 * \param fullscale is Accelerometer full-scale range
 * \param resolution is Accelerometer measurement resolution, in 'bits'.
 */
void encodeServo_AccelerometerPacket(void* _pg_pkt, int16_t xAcc, int16_t yAcc, int16_t zAcc, uint8_t fullscale, uint8_t resolution)
{
    uint8_t* _pg_data = getServoPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    // X axis acceleration value
    // Range of xAcc is -32768 to 32767.
    int16ToBeBytes(xAcc, _pg_data, &_pg_byteindex);

    // Y axis acceleration value
    // Range of yAcc is -32768 to 32767.
    int16ToBeBytes(yAcc, _pg_data, &_pg_byteindex);

    // Z axis acceleration value
    // Range of zAcc is -32768 to 32767.
    int16ToBeBytes(zAcc, _pg_data, &_pg_byteindex);

    // Accelerometer full-scale range
    // Range of fullscale is 0 to 255.
    uint8ToBytes(fullscale, _pg_data, &_pg_byteindex);

    // Accelerometer measurement resolution, in 'bits'.
    // Range of resolution is 0 to 255.
    uint8ToBytes(resolution, _pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finishServoPacket(_pg_pkt, _pg_byteindex, getServo_AccelerometerPacketID());

}// encodeServo_AccelerometerPacket

/*!
 * \brief Decode the Servo_Accelerometer packet
 *
 * Raw accelerometer data. To convert these raw readings to 'real' units, use
 * the formula acc = 0.5 * raw * fullscale / (2^resolution)
 * \param _pg_pkt points to the packet being decoded by this function
 * \param xAcc receives X axis acceleration value
 * \param yAcc receives Y axis acceleration value
 * \param zAcc receives Z axis acceleration value
 * \param fullscale receives Accelerometer full-scale range
 * \param resolution receives Accelerometer measurement resolution, in 'bits'.
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeServo_AccelerometerPacket(const void* _pg_pkt, int16_t* xAcc, int16_t* yAcc, int16_t* zAcc, uint8_t* fullscale, uint8_t* resolution)
{
    int _pg_byteindex = 0;
    const uint8_t* _pg_data = getServoPacketDataConst(_pg_pkt);
    int _pg_numbytes = getServoPacketSize(_pg_pkt);

    // Verify the packet identifier
    if(getServoPacketID(_pg_pkt) != getServo_AccelerometerPacketID())
        return 0;

    if(_pg_numbytes < getServo_AccelerometerMinDataLength())
        return 0;

    // X axis acceleration value
    // Range of xAcc is -32768 to 32767.
    (*xAcc) = int16FromBeBytes(_pg_data, &_pg_byteindex);

    // Y axis acceleration value
    // Range of yAcc is -32768 to 32767.
    (*yAcc) = int16FromBeBytes(_pg_data, &_pg_byteindex);

    // Z axis acceleration value
    // Range of zAcc is -32768 to 32767.
    (*zAcc) = int16FromBeBytes(_pg_data, &_pg_byteindex);

    // Accelerometer full-scale range
    // Range of fullscale is 0 to 255.
    (*fullscale) = uint8FromBytes(_pg_data, &_pg_byteindex);

    // Accelerometer measurement resolution, in 'bits'.
    // Range of resolution is 0 to 255.
    (*resolution) = uint8FromBytes(_pg_data, &_pg_byteindex);

    return 1;

}// decodeServo_AccelerometerPacket

/*!
 * \brief Create the Servo_Address packet
 *
 * Servo address information
 * \param _pg_pkt points to the packet which will be created by this function
 * \param _pg_user points to the user data that will be encoded in _pg_pkt
 */
void encodeServo_AddressPacketStructure(void* _pg_pkt, const Servo_Address_t* _pg_user)
{
    uint8_t* _pg_data = getServoPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    // Hardware revision
    // Range of hwRev is 0 to 255.
    uint8ToBytes(_pg_user->hwRev, _pg_data, &_pg_byteindex);

    // Servo serial number
    // Range of serialNumber is 0 to 16777215.
    uint24ToBeBytes((uint32_t)(limitMax(_pg_user->serialNumber, 16777215)), _pg_data, &_pg_byteindex);

    // Programmable User ID value 1/2
    // Range of userIDA is 0 to 65535.
    uint16ToBeBytes(_pg_user->userIDA, _pg_data, &_pg_byteindex);

    // Programmable User ID value 2/2
    // Range of userIDB is 0 to 65535.
    uint16ToBeBytes(_pg_user->userIDB, _pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finishServoPacket(_pg_pkt, _pg_byteindex, getServo_AddressPacketID());

}// encodeServo_AddressPacketStructure

/*!
 * \brief Decode the Servo_Address packet
 *
 * Servo address information
 * \param _pg_pkt points to the packet being decoded by this function
 * \param _pg_user receives the data decoded from the packet
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeServo_AddressPacketStructure(const void* _pg_pkt, Servo_Address_t* _pg_user)
{
    int _pg_numbytes;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data;

    // Verify the packet identifier
    if(getServoPacketID(_pg_pkt) != getServo_AddressPacketID())
        return 0;

    // Verify the packet size
    _pg_numbytes = getServoPacketSize(_pg_pkt);
    if(_pg_numbytes < getServo_AddressMinDataLength())
        return 0;

    // The raw data from the packet
    _pg_data = getServoPacketDataConst(_pg_pkt);

    // Hardware revision
    // Range of hwRev is 0 to 255.
    _pg_user->hwRev = uint8FromBytes(_pg_data, &_pg_byteindex);

    // Servo serial number
    // Range of serialNumber is 0 to 16777215.
    _pg_user->serialNumber = (uint32_t)uint24FromBeBytes(_pg_data, &_pg_byteindex);

    // Programmable User ID value 1/2
    // Range of userIDA is 0 to 65535.
    _pg_user->userIDA = uint16FromBeBytes(_pg_data, &_pg_byteindex);

    // Programmable User ID value 2/2
    // Range of userIDB is 0 to 65535.
    _pg_user->userIDB = uint16FromBeBytes(_pg_data, &_pg_byteindex);

    return 1;

}// decodeServo_AddressPacketStructure

/*!
 * \brief Create the Servo_Address packet
 *
 * Servo address information
 * \param _pg_pkt points to the packet which will be created by this function
 * \param hwRev is Hardware revision
 * \param serialNumber is Servo serial number
 * \param userIDA is Programmable User ID value 1/2
 * \param userIDB is Programmable User ID value 2/2
 */
void encodeServo_AddressPacket(void* _pg_pkt, uint8_t hwRev, uint32_t serialNumber, uint16_t userIDA, uint16_t userIDB)
{
    uint8_t* _pg_data = getServoPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    // Hardware revision
    // Range of hwRev is 0 to 255.
    uint8ToBytes(hwRev, _pg_data, &_pg_byteindex);

    // Servo serial number
    // Range of serialNumber is 0 to 16777215.
    uint24ToBeBytes((uint32_t)(limitMax(serialNumber, 16777215)), _pg_data, &_pg_byteindex);

    // Programmable User ID value 1/2
    // Range of userIDA is 0 to 65535.
    uint16ToBeBytes(userIDA, _pg_data, &_pg_byteindex);

    // Programmable User ID value 2/2
    // Range of userIDB is 0 to 65535.
    uint16ToBeBytes(userIDB, _pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finishServoPacket(_pg_pkt, _pg_byteindex, getServo_AddressPacketID());

}// encodeServo_AddressPacket

/*!
 * \brief Decode the Servo_Address packet
 *
 * Servo address information
 * \param _pg_pkt points to the packet being decoded by this function
 * \param hwRev receives Hardware revision
 * \param serialNumber receives Servo serial number
 * \param userIDA receives Programmable User ID value 1/2
 * \param userIDB receives Programmable User ID value 2/2
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeServo_AddressPacket(const void* _pg_pkt, uint8_t* hwRev, uint32_t* serialNumber, uint16_t* userIDA, uint16_t* userIDB)
{
    int _pg_byteindex = 0;
    const uint8_t* _pg_data = getServoPacketDataConst(_pg_pkt);
    int _pg_numbytes = getServoPacketSize(_pg_pkt);

    // Verify the packet identifier
    if(getServoPacketID(_pg_pkt) != getServo_AddressPacketID())
        return 0;

    if(_pg_numbytes < getServo_AddressMinDataLength())
        return 0;

    // Hardware revision
    // Range of hwRev is 0 to 255.
    (*hwRev) = uint8FromBytes(_pg_data, &_pg_byteindex);

    // Servo serial number
    // Range of serialNumber is 0 to 16777215.
    (*serialNumber) = (uint32_t)uint24FromBeBytes(_pg_data, &_pg_byteindex);

    // Programmable User ID value 1/2
    // Range of userIDA is 0 to 65535.
    (*userIDA) = uint16FromBeBytes(_pg_data, &_pg_byteindex);

    // Programmable User ID value 2/2
    // Range of userIDB is 0 to 65535.
    (*userIDB) = uint16FromBeBytes(_pg_data, &_pg_byteindex);

    return 1;

}// decodeServo_AddressPacket

/*!
 * \brief Create the Servo_Title packet
 *
 * Servo title information
 * \param _pg_pkt points to the packet which will be created by this function
 * \param title is Human readable description string for the servo
 */
void encodeServo_TitlePacket(void* _pg_pkt, const uint8_t title[8])
{
    uint8_t* _pg_data = getServoPacketData(_pg_pkt);
    int _pg_byteindex = 0;
    unsigned _pg_i = 0;

    // Human readable description string for the servo
    // Range of title is 0 to 255.
    for(_pg_i = 0; _pg_i < 8; _pg_i++)
        uint8ToBytes(title[_pg_i], _pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finishServoPacket(_pg_pkt, _pg_byteindex, getServo_TitlePacketID());

}// encodeServo_TitlePacket

/*!
 * \brief Decode the Servo_Title packet
 *
 * Servo title information
 * \param _pg_pkt points to the packet being decoded by this function
 * \param title receives Human readable description string for the servo
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeServo_TitlePacket(const void* _pg_pkt, uint8_t title[8])
{
    unsigned _pg_i = 0;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data = getServoPacketDataConst(_pg_pkt);
    int _pg_numbytes = getServoPacketSize(_pg_pkt);

    // Verify the packet identifier
    if(getServoPacketID(_pg_pkt) != getServo_TitlePacketID())
        return 0;

    if(_pg_numbytes < getServo_TitleMinDataLength())
        return 0;

    // Human readable description string for the servo
    // Range of title is 0 to 255.
    for(_pg_i = 0; _pg_i < 8; _pg_i++)
        title[_pg_i] = uint8FromBytes(_pg_data, &_pg_byteindex);

    return 1;

}// decodeServo_TitlePacket

/*!
 * \brief Create the Servo_Firmware packet
 *
 * Servo firmware information
 * \param _pg_pkt points to the packet which will be created by this function
 * \param _pg_user points to the user data that will be encoded in _pg_pkt
 */
void encodeServo_FirmwarePacketStructure(void* _pg_pkt, const Servo_Firmware_t* _pg_user)
{
    uint8_t* _pg_data = getServoPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    // Firmware version, major number
    // Range of major is 0 to 255.
    uint8ToBytes(_pg_user->major, _pg_data, &_pg_byteindex);

    // Firmware version, minor number
    // Range of minor is 0 to 255.
    uint8ToBytes(_pg_user->minor, _pg_data, &_pg_byteindex);

    // Firmware release date, day-of-month
    // Range of day is 0 to 255.
    uint8ToBytes(_pg_user->day, _pg_data, &_pg_byteindex);

    // Firmware release date, month-of-year
    // Range of month is 0 to 255.
    uint8ToBytes(_pg_user->month, _pg_data, &_pg_byteindex);

    // Firmware release date, year
    // Range of year is 0 to 65535.
    uint16ToBeBytes(_pg_user->year, _pg_data, &_pg_byteindex);

    // Firmware checksum, 16-bit
    // Range of checksum is 0 to 65535.
    uint16ToBeBytes(_pg_user->checksum, _pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finishServoPacket(_pg_pkt, _pg_byteindex, getServo_FirmwarePacketID());

}// encodeServo_FirmwarePacketStructure

/*!
 * \brief Decode the Servo_Firmware packet
 *
 * Servo firmware information
 * \param _pg_pkt points to the packet being decoded by this function
 * \param _pg_user receives the data decoded from the packet
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeServo_FirmwarePacketStructure(const void* _pg_pkt, Servo_Firmware_t* _pg_user)
{
    int _pg_numbytes;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data;

    // Verify the packet identifier
    if(getServoPacketID(_pg_pkt) != getServo_FirmwarePacketID())
        return 0;

    // Verify the packet size
    _pg_numbytes = getServoPacketSize(_pg_pkt);
    if(_pg_numbytes < getServo_FirmwareMinDataLength())
        return 0;

    // The raw data from the packet
    _pg_data = getServoPacketDataConst(_pg_pkt);

    // Firmware version, major number
    // Range of major is 0 to 255.
    _pg_user->major = uint8FromBytes(_pg_data, &_pg_byteindex);

    // Firmware version, minor number
    // Range of minor is 0 to 255.
    _pg_user->minor = uint8FromBytes(_pg_data, &_pg_byteindex);

    // Firmware release date, day-of-month
    // Range of day is 0 to 255.
    _pg_user->day = uint8FromBytes(_pg_data, &_pg_byteindex);

    // Firmware release date, month-of-year
    // Range of month is 0 to 255.
    _pg_user->month = uint8FromBytes(_pg_data, &_pg_byteindex);

    // Firmware release date, year
    // Range of year is 0 to 65535.
    _pg_user->year = uint16FromBeBytes(_pg_data, &_pg_byteindex);

    // Firmware checksum, 16-bit
    // Range of checksum is 0 to 65535.
    _pg_user->checksum = uint16FromBeBytes(_pg_data, &_pg_byteindex);

    return 1;

}// decodeServo_FirmwarePacketStructure

/*!
 * \brief Create the Servo_Firmware packet
 *
 * Servo firmware information
 * \param _pg_pkt points to the packet which will be created by this function
 * \param major is Firmware version, major number
 * \param minor is Firmware version, minor number
 * \param day is Firmware release date, day-of-month
 * \param month is Firmware release date, month-of-year
 * \param year is Firmware release date, year
 * \param checksum is Firmware checksum, 16-bit
 */
void encodeServo_FirmwarePacket(void* _pg_pkt, uint8_t major, uint8_t minor, uint8_t day, uint8_t month, uint16_t year, uint16_t checksum)
{
    uint8_t* _pg_data = getServoPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    // Firmware version, major number
    // Range of major is 0 to 255.
    uint8ToBytes(major, _pg_data, &_pg_byteindex);

    // Firmware version, minor number
    // Range of minor is 0 to 255.
    uint8ToBytes(minor, _pg_data, &_pg_byteindex);

    // Firmware release date, day-of-month
    // Range of day is 0 to 255.
    uint8ToBytes(day, _pg_data, &_pg_byteindex);

    // Firmware release date, month-of-year
    // Range of month is 0 to 255.
    uint8ToBytes(month, _pg_data, &_pg_byteindex);

    // Firmware release date, year
    // Range of year is 0 to 65535.
    uint16ToBeBytes(year, _pg_data, &_pg_byteindex);

    // Firmware checksum, 16-bit
    // Range of checksum is 0 to 65535.
    uint16ToBeBytes(checksum, _pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finishServoPacket(_pg_pkt, _pg_byteindex, getServo_FirmwarePacketID());

}// encodeServo_FirmwarePacket

/*!
 * \brief Decode the Servo_Firmware packet
 *
 * Servo firmware information
 * \param _pg_pkt points to the packet being decoded by this function
 * \param major receives Firmware version, major number
 * \param minor receives Firmware version, minor number
 * \param day receives Firmware release date, day-of-month
 * \param month receives Firmware release date, month-of-year
 * \param year receives Firmware release date, year
 * \param checksum receives Firmware checksum, 16-bit
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeServo_FirmwarePacket(const void* _pg_pkt, uint8_t* major, uint8_t* minor, uint8_t* day, uint8_t* month, uint16_t* year, uint16_t* checksum)
{
    int _pg_byteindex = 0;
    const uint8_t* _pg_data = getServoPacketDataConst(_pg_pkt);
    int _pg_numbytes = getServoPacketSize(_pg_pkt);

    // Verify the packet identifier
    if(getServoPacketID(_pg_pkt) != getServo_FirmwarePacketID())
        return 0;

    if(_pg_numbytes < getServo_FirmwareMinDataLength())
        return 0;

    // Firmware version, major number
    // Range of major is 0 to 255.
    (*major) = uint8FromBytes(_pg_data, &_pg_byteindex);

    // Firmware version, minor number
    // Range of minor is 0 to 255.
    (*minor) = uint8FromBytes(_pg_data, &_pg_byteindex);

    // Firmware release date, day-of-month
    // Range of day is 0 to 255.
    (*day) = uint8FromBytes(_pg_data, &_pg_byteindex);

    // Firmware release date, month-of-year
    // Range of month is 0 to 255.
    (*month) = uint8FromBytes(_pg_data, &_pg_byteindex);

    // Firmware release date, year
    // Range of year is 0 to 65535.
    (*year) = uint16FromBeBytes(_pg_data, &_pg_byteindex);

    // Firmware checksum, 16-bit
    // Range of checksum is 0 to 65535.
    (*checksum) = uint16FromBeBytes(_pg_data, &_pg_byteindex);

    return 1;

}// decodeServo_FirmwarePacket

/*!
 * \brief Create the Servo_SystemInfo packet
 *
 * Servo system info (uptime, etc)
 * \param _pg_pkt points to the packet which will be created by this function
 * \param _pg_user points to the user data that will be encoded in _pg_pkt
 */
void encodeServo_SystemInfoPacketStructure(void* _pg_pkt, const Servo_SystemInfo_t* _pg_user)
{
    uint8_t* _pg_data = getServoPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    // Time since last power cycle (milliseconds)
    // Range of msSinceReset is 0 to 4294967295.
    uint32ToBeBytes(_pg_user->msSinceReset, _pg_data, &_pg_byteindex);

    // Number of recorded power cycles
    // Range of powerCycles is 0 to 65535.
    uint16ToBeBytes(_pg_user->powerCycles, _pg_data, &_pg_byteindex);

    // Processor code indicating cause of most recent reset event
    // Range of resetCode is 0 to 255.
    uint8ToBytes(_pg_user->resetCode, _pg_data, &_pg_byteindex);

    // Range of cpuOccupancy is 0 to 255.
    uint8ToBytes(_pg_user->cpuOccupancy, _pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finishServoPacket(_pg_pkt, _pg_byteindex, getServo_SystemInfoPacketID());

}// encodeServo_SystemInfoPacketStructure

/*!
 * \brief Decode the Servo_SystemInfo packet
 *
 * Servo system info (uptime, etc)
 * \param _pg_pkt points to the packet being decoded by this function
 * \param _pg_user receives the data decoded from the packet
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeServo_SystemInfoPacketStructure(const void* _pg_pkt, Servo_SystemInfo_t* _pg_user)
{
    int _pg_numbytes;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data;

    // Verify the packet identifier
    if(getServoPacketID(_pg_pkt) != getServo_SystemInfoPacketID())
        return 0;

    // Verify the packet size
    _pg_numbytes = getServoPacketSize(_pg_pkt);
    if(_pg_numbytes < getServo_SystemInfoMinDataLength())
        return 0;

    // The raw data from the packet
    _pg_data = getServoPacketDataConst(_pg_pkt);

    // Time since last power cycle (milliseconds)
    // Range of msSinceReset is 0 to 4294967295.
    _pg_user->msSinceReset = uint32FromBeBytes(_pg_data, &_pg_byteindex);

    // Number of recorded power cycles
    // Range of powerCycles is 0 to 65535.
    _pg_user->powerCycles = uint16FromBeBytes(_pg_data, &_pg_byteindex);

    // Processor code indicating cause of most recent reset event
    // Range of resetCode is 0 to 255.
    _pg_user->resetCode = uint8FromBytes(_pg_data, &_pg_byteindex);

    // Range of cpuOccupancy is 0 to 255.
    _pg_user->cpuOccupancy = uint8FromBytes(_pg_data, &_pg_byteindex);

    return 1;

}// decodeServo_SystemInfoPacketStructure

/*!
 * \brief Create the Servo_SystemInfo packet
 *
 * Servo system info (uptime, etc)
 * \param _pg_pkt points to the packet which will be created by this function
 * \param msSinceReset is Time since last power cycle (milliseconds)
 * \param powerCycles is Number of recorded power cycles
 * \param resetCode is Processor code indicating cause of most recent reset event
 * \param cpuOccupancy is 
 */
void encodeServo_SystemInfoPacket(void* _pg_pkt, uint32_t msSinceReset, uint16_t powerCycles, uint8_t resetCode, uint8_t cpuOccupancy)
{
    uint8_t* _pg_data = getServoPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    // Time since last power cycle (milliseconds)
    // Range of msSinceReset is 0 to 4294967295.
    uint32ToBeBytes(msSinceReset, _pg_data, &_pg_byteindex);

    // Number of recorded power cycles
    // Range of powerCycles is 0 to 65535.
    uint16ToBeBytes(powerCycles, _pg_data, &_pg_byteindex);

    // Processor code indicating cause of most recent reset event
    // Range of resetCode is 0 to 255.
    uint8ToBytes(resetCode, _pg_data, &_pg_byteindex);

    // Range of cpuOccupancy is 0 to 255.
    uint8ToBytes(cpuOccupancy, _pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finishServoPacket(_pg_pkt, _pg_byteindex, getServo_SystemInfoPacketID());

}// encodeServo_SystemInfoPacket

/*!
 * \brief Decode the Servo_SystemInfo packet
 *
 * Servo system info (uptime, etc)
 * \param _pg_pkt points to the packet being decoded by this function
 * \param msSinceReset receives Time since last power cycle (milliseconds)
 * \param powerCycles receives Number of recorded power cycles
 * \param resetCode receives Processor code indicating cause of most recent reset event
 * \param cpuOccupancy receives 
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeServo_SystemInfoPacket(const void* _pg_pkt, uint32_t* msSinceReset, uint16_t* powerCycles, uint8_t* resetCode, uint8_t* cpuOccupancy)
{
    int _pg_byteindex = 0;
    const uint8_t* _pg_data = getServoPacketDataConst(_pg_pkt);
    int _pg_numbytes = getServoPacketSize(_pg_pkt);

    // Verify the packet identifier
    if(getServoPacketID(_pg_pkt) != getServo_SystemInfoPacketID())
        return 0;

    if(_pg_numbytes < getServo_SystemInfoMinDataLength())
        return 0;

    // Time since last power cycle (milliseconds)
    // Range of msSinceReset is 0 to 4294967295.
    (*msSinceReset) = uint32FromBeBytes(_pg_data, &_pg_byteindex);

    // Number of recorded power cycles
    // Range of powerCycles is 0 to 65535.
    (*powerCycles) = uint16FromBeBytes(_pg_data, &_pg_byteindex);

    // Processor code indicating cause of most recent reset event
    // Range of resetCode is 0 to 255.
    (*resetCode) = uint8FromBytes(_pg_data, &_pg_byteindex);

    // Range of cpuOccupancy is 0 to 255.
    (*cpuOccupancy) = uint8FromBytes(_pg_data, &_pg_byteindex);

    return 1;

}// decodeServo_SystemInfoPacket

/*!
 * \brief Create the Servo_TelemetryConfig packet
 *
 * Telemetry settings configuration packet
 * \param _pg_pkt points to the packet which will be created by this function
 * \param _pg_user points to the user data that will be encoded in _pg_pkt
 */
void encodeServo_TelemetryConfigPacketStructure(void* _pg_pkt, const Servo_TelemetryConfig_t* _pg_user)
{
    uint8_t* _pg_data = getServoPacketData(_pg_pkt);
    int _pg_byteindex = 0;
    unsigned _pg_i = 0;

    // Servo telemetry settings
    encodeServo_TelemetrySettings_t(_pg_data, &_pg_byteindex, &_pg_user->settings);

    // Reserved for future use
    for(_pg_i = 0; _pg_i < 3; _pg_i++)
        uint8ToBytes((uint8_t)(0), _pg_data, &_pg_byteindex);

    // Servo ICD revision
    uint8ToBytes((uint8_t)(getServoApi()), _pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finishServoPacket(_pg_pkt, _pg_byteindex, getServo_TelemetryConfigPacketID());

}// encodeServo_TelemetryConfigPacketStructure

/*!
 * \brief Decode the Servo_TelemetryConfig packet
 *
 * Telemetry settings configuration packet
 * \param _pg_pkt points to the packet being decoded by this function
 * \param _pg_user receives the data decoded from the packet
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeServo_TelemetryConfigPacketStructure(const void* _pg_pkt, Servo_TelemetryConfig_t* _pg_user)
{
    int _pg_numbytes;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data;

    // Verify the packet identifier
    if(getServoPacketID(_pg_pkt) != getServo_TelemetryConfigPacketID())
        return 0;

    // Verify the packet size
    _pg_numbytes = getServoPacketSize(_pg_pkt);
    if(_pg_numbytes < getServo_TelemetryConfigMinDataLength())
        return 0;

    // The raw data from the packet
    _pg_data = getServoPacketDataConst(_pg_pkt);

    // Servo telemetry settings
    if(decodeServo_TelemetrySettings_t(_pg_data, &_pg_byteindex, &_pg_user->settings) == 0)
        return 0;

    // Reserved for future use
    _pg_byteindex += 1*3;

    // Servo ICD revision
    // Range of icdVersion is 0 to 255.
    _pg_user->icdVersion = uint8FromBytes(_pg_data, &_pg_byteindex);

    return 1;

}// decodeServo_TelemetryConfigPacketStructure

/*!
 * \brief Create the Servo_TelemetryConfig packet
 *
 * Telemetry settings configuration packet
 * \param _pg_pkt points to the packet which will be created by this function
 * \param settings is Servo telemetry settings
 */
void encodeServo_TelemetryConfigPacket(void* _pg_pkt, const Servo_TelemetrySettings_t* settings)
{
    uint8_t* _pg_data = getServoPacketData(_pg_pkt);
    int _pg_byteindex = 0;
    unsigned _pg_i = 0;

    // Servo telemetry settings
    encodeServo_TelemetrySettings_t(_pg_data, &_pg_byteindex, settings);

    // Reserved for future use
    for(_pg_i = 0; _pg_i < 3; _pg_i++)
        uint8ToBytes((uint8_t)(0), _pg_data, &_pg_byteindex);

    // Servo ICD revision
    uint8ToBytes((uint8_t)(getServoApi()), _pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finishServoPacket(_pg_pkt, _pg_byteindex, getServo_TelemetryConfigPacketID());

}// encodeServo_TelemetryConfigPacket

/*!
 * \brief Decode the Servo_TelemetryConfig packet
 *
 * Telemetry settings configuration packet
 * \param _pg_pkt points to the packet being decoded by this function
 * \param settings receives Servo telemetry settings
 * \param icdVersion receives Servo ICD revision
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeServo_TelemetryConfigPacket(const void* _pg_pkt, Servo_TelemetrySettings_t* settings, uint8_t* icdVersion)
{
    int _pg_byteindex = 0;
    const uint8_t* _pg_data = getServoPacketDataConst(_pg_pkt);
    int _pg_numbytes = getServoPacketSize(_pg_pkt);

    // Verify the packet identifier
    if(getServoPacketID(_pg_pkt) != getServo_TelemetryConfigPacketID())
        return 0;

    if(_pg_numbytes < getServo_TelemetryConfigMinDataLength())
        return 0;

    // Servo telemetry settings
    if(decodeServo_TelemetrySettings_t(_pg_data, &_pg_byteindex, settings) == 0)
        return 0;

    // Reserved for future use
    _pg_byteindex += 1*3;

    // Servo ICD revision
    // Range of icdVersion is 0 to 255.
    (*icdVersion) = uint8FromBytes(_pg_data, &_pg_byteindex);

    return 1;

}// decodeServo_TelemetryConfigPacket

/*!
 * \brief Create the Servo_SettingsInfo packet
 *
 * Non-volatile settings configuration information
 * \param _pg_pkt points to the packet which will be created by this function
 * \param _pg_user points to the user data that will be encoded in _pg_pkt
 */
void encodeServo_Settin// ServoPackets.h was generated by ProtoGen version 3.2.a

/*
 * This file is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This file is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Author: Oliver Walters / Currawong Engineering Pty Ltd
 */

#ifndef _SERVOPACKETS_H
#define _SERVOPACKETS_H

// Language target is C, C++ compilers: don't mangle us
#ifdef __cplusplus
extern "C" {
#endif

/*!
 * \file
 */

#include <stdbool.h>
#include "ServoProtocol.h"
#include "ServoDefines.h"

/*!
 * General servo configuration settings
 */
typedef struct
{
    Servo_ConfigBits_t options;        //!< Servo configuration parameters
    uint16_t           commandTimeout; //!< Servo command timeout
    int16_t            homePosition;   //!< Servo neutral position. Servo can be configured to return to this position at powerup, or after loss of communication
    uint8_t            reserved[2];    //!< Reserved for future use
}Servo_Config_t;

//! Create the Servo_Config packet
void encodeServo_ConfigPacketStructure(void* pkt, const Servo_Config_t* user);

//! Decode the Servo_Config packet
int decodeServo_ConfigPacketStructure(const void* pkt, Servo_Config_t* user);

//! Create the Servo_Config packet from parameters
void encodeServo_ConfigPacket(void* pkt, const Servo_ConfigBits_t* options, uint16_t commandTimeout, int16_t homePosition, const uint8_t reserved[2]);

//! Decode the Servo_Config packet to parameters
int decodeServo_ConfigPacket(const void* pkt, Servo_ConfigBits_t* options, uint16_t* commandTimeout, int16_t* homePosition, uint8_t reserved[2]);

//! Encode a Servo_Config_t into a byte array
void encodeServo_Config_t(uint8_t* data, int* bytecount, const Servo_Config_t* user);

//! Decode a Servo_Config_t from a byte array
int decodeServo_Config_t(const uint8_t* data, int* bytecount, Servo_Config_t* user);

//! return the packet ID for the Servo_Config packet
#define getServo_ConfigPacketID() (PKT_SERVO_CONFIG)

//! return the minimum encoded length for the Servo_Config packet
#define getServo_ConfigMinDataLength() (8)

//! return the maximum encoded length for the Servo_Config packet
#define getServo_ConfigMaxDataLength() (8)

/*!
 * This packet can be used to simultaneously command multiple servos which have
 * sequential CAN ID values. This packet must be sent as a broadcast packet
 * (address = 0xFF) such that all servos can receive it. These commands can be
 * sent to groups of servos with ID values up to 64, using different
 * PKT_SERVO_MULTI_COMMAND_x packet ID values.
 */
typedef struct
{
    int16_t commandA; //!< Servo command for servo with address offset 0
    int16_t commandB; //!< Servo command for servo with address offset 1
    int16_t commandC; //!< Servo command for servo with address offset 3
    int16_t commandD; //!< Servo command for servo with address offset 3
}Servo_MultiPositionCommand_t;

//! Create the Servo_MultiPositionCommand packet from parameters
void encodeServo_MultiPositionCommandPacket(void* pkt, int16_t commandA, int16_t commandB, int16_t commandC, int16_t commandD, uint32_t id);

//! Decode the Servo_MultiPositionCommand packet to parameters
int decodeServo_MultiPositionCommandPacket(const void* pkt, int16_t* commandA, int16_t* commandB, int16_t* commandC, int16_t* commandD);

//! return the minimum encoded length for the Servo_MultiPositionCommand packet
#define getServo_MultiPositionCommandMinDataLength() (8)

//! return the maximum encoded length for the Servo_MultiPositionCommand packet
#define getServo_MultiPositionCommandMaxDataLength() (8)

/*!
 * Send this command to move the servo(s) to the commanded position. Position
 * command units depend on the configuration of the servo. Send with the
 * broadcast ID (0xFF) to send the position command to *all* servos.
 */
typedef struct
{
    int16_t command; //!< Servo command
}Servo_PositionCommand_t;

//! Create the Servo_PositionCommand packet from parameters
void encodeServo_PositionCommandPacket(void* pkt, int16_t command);

//! Decode the Servo_PositionCommand packet to parameters
int decodeServo_PositionCommandPacket(const void* pkt, int16_t* command);

//! return the packet ID for the Servo_PositionCommand packet
#define getServo_PositionCommandPacketID() (PKT_SERVO_POSITION_COMMAND)

//! return the minimum encoded length for the Servo_PositionCommand packet
#define getServo_PositionCommandMinDataLength() (2)

//! return the maximum encoded length for the Servo_PositionCommand packet
#define getServo_PositionCommandMaxDataLength() (2)

//! Create the Servo_NeutralPositionCommand packet from parameters
void encodeServo_NeutralPositionCommandPacket(void* pkt);

//! Decode the Servo_NeutralPositionCommand packet to parameters
int decodeServo_NeutralPositionCommandPacket(const void* pkt);

//! return the packet ID for the Servo_NeutralPositionCommand packet
#define getServo_NeutralPositionCommandPacketID() (PKT_SERVO_NEUTRAL_COMMAND)

//! return the minimum encoded length for the Servo_NeutralPositionCommand packet
#define getServo_NeutralPositionCommandMinDataLength() 0

//! return the maximum encoded length for the Servo_NeutralPositionCommand packet
#define getServo_NeutralPositionCommandMaxDataLength() 0

//! Create the Servo_Disable packet from parameters
void encodeServo_DisablePacket(void* pkt);

//! Decode the Servo_Disable packet to parameters
int decodeServo_DisablePacket(const void* pkt);

//! return the packet ID for the Servo_Disable packet
#define getServo_DisablePacketID() (PKT_SERVO_DISABLE)

//! return the minimum encoded length for the Servo_Disable packet
#define getServo_DisableMinDataLength() 0

//! return the maximum encoded length for the Servo_Disable packet
#define getServo_DisableMaxDataLength() 0

//! Create the Servo_Enable packet from parameters
void encodeServo_EnablePacket(void* pkt);

//! Decode the Servo_Enable packet to parameters
int decodeServo_EnablePacket(const void* pkt);

//! return the packet ID for the Servo_Enable packet
#define getServo_EnablePacketID() (PKT_SERVO_ENABLE)

//! return the minimum encoded length for the Servo_Enable packet
#define getServo_EnableMinDataLength() 0

//! return the maximum encoded length for the Servo_Enable packet
#define getServo_EnableMaxDataLength() 0

/*!
 * Set the human-readable description of this servo
 */
typedef struct
{
    uint8_t title[8];
}Servo_SetTitle_t;

//! Create the Servo_SetTitle packet from parameters
void encodeServo_SetTitlePacket(void* pkt, const uint8_t title[8]);

//! Decode the Servo_SetTitle packet to parameters
int decodeServo_SetTitlePacket(const void* pkt, uint8_t title[8]);

//! return the packet ID for the Servo_SetTitle packet
#define getServo_SetTitlePacketID() (PKT_SERVO_SET_TITLE)

//! return the minimum encoded length for the Servo_SetTitle packet
#define getServo_SetTitleMinDataLength() (8)

//! return the maximum encoded length for the Servo_SetTitle packet
#define getServo_SetTitleMaxDataLength() (8)

/*!
 * The *SERVO_STATUS_A* packet contains status, warning and error information,
 * in addition to the servo position
 */
typedef struct
{
    Servo_StatusBits_t  status;   //!< Status bits contain information on servo operation
    Servo_WarningBits_t warnings; //!< Warning bits indicate servo is operation outside of desired range
    Servo_ErrorBits_t   errors;   //!< These bits indicate critical system error information
    int16_t             position; //!< Servo position, mapped to input units
    int16_t             command;  //!< Servo commanded position
}Servo_StatusA_t;

//! Create the Servo_StatusA packet
void encodeServo_StatusAPacketStructure(void* pkt, const Servo_StatusA_t* user);

//! Decode the Servo_StatusA packet
int decodeServo_StatusAPacketStructure(const void* pkt, Servo_StatusA_t* user);

//! Create the Servo_StatusA packet from parameters
void encodeServo_StatusAPacket(void* pkt, const Servo_StatusBits_t* status, const Servo_WarningBits_t* warnings, const Servo_ErrorBits_t* errors, int16_t position, int16_t command);

//! Decode the Servo_StatusA packet to parameters
int decodeServo_StatusAPacket(const void* pkt, Servo_StatusBits_t* status, Servo_WarningBits_t* warnings, Servo_ErrorBits_t* errors, int16_t* position, int16_t* command);

//! return the packet ID for the Servo_StatusA packet
#define getServo_StatusAPacketID() (PKT_SERVO_STATUS_A)

//! return the minimum encoded length for the Servo_StatusA packet
#define getServo_StatusAMinDataLength() (8)

//! return the maximum encoded length for the Servo_StatusA packet
#define getServo_StatusAMaxDataLength() (8)

/*!
 * The *SERVO_STATUS_B* packet contains various servo feedback data
 */
typedef struct
{
    uint16_t current;     //!< Servo current
    uint16_t voltage;     //!< Servo supply voltage
    int8_t   temperature; //!< Servo temperature
    int8_t   dutyCycle;   //!< Motor duty cycle
    int16_t  speed;       //!< Servo output shaft speed
}Servo_StatusB_t;

//! Create the Servo_StatusB packet
void encodeServo_StatusBPacketStructure(void* pkt, const Servo_StatusB_t* user);

//! Decode the Servo_StatusB packet
int decodeServo_StatusBPacketStructure(const void* pkt, Servo_StatusB_t* user);

//! Create the Servo_StatusB packet from parameters
void encodeServo_StatusBPacket(void* pkt, uint16_t current, uint16_t voltage, int8_t temperature, int8_t dutyCycle, int16_t speed);

//! Decode the Servo_StatusB packet to parameters
int decodeServo_StatusBPacket(const void* pkt, uint16_t* current, uint16_t* voltage, int8_t* temperature, int8_t* dutyCycle, int16_t* speed);

//! return the packet ID for the Servo_StatusB packet
#define getServo_StatusBPacketID() (PKT_SERVO_STATUS_B)

//! return the minimum encoded length for the Servo_StatusB packet
#define getServo_StatusBMinDataLength() (5)

//! return the maximum encoded length for the Servo_StatusB packet
#define getServo_StatusBMaxDataLength() (8)

/*!
 * The *SERVO_STATUS_C* packet contains servo position data. It is a cut-down
 * packet to allow high-speed feedback on servo position
 */
typedef struct
{
    int16_t position; //!< Servo position, mapped to input units
}Servo_StatusC_t;

//! Create the Servo_StatusC packet
void encodeServo_StatusCPacketStructure(void* pkt, const Servo_StatusC_t* user);

//! Decode the Servo_StatusC packet
int decodeServo_StatusCPacketStructure(const void* pkt, Servo_StatusC_t* user);

//! Create the Servo_StatusC packet from parameters
void encodeServo_StatusCPacket(void* pkt, int16_t position);

//! Decode the Servo_StatusC packet to parameters
int decodeServo_StatusCPacket(const void* pkt, int16_t* position);

//! return the packet ID for the Servo_StatusC packet
#define getServo_StatusCPacketID() (PKT_SERVO_STATUS_C)

//! return the minimum encoded length for the Servo_StatusC packet
#define getServo_StatusCMinDataLength() (2)

//! return the maximum encoded length for the Servo_StatusC packet
#define getServo_StatusCMaxDataLength() (2)

/*!
 * Raw accelerometer data. To convert these raw readings to 'real' units, use
 * the formula acc = 0.5 * raw * fullscale / (2^resolution)
 */
typedef struct
{
    int16_t xAcc;       //!< X axis acceleration value
    int16_t yAcc;       //!< Y axis acceleration value
    int16_t zAcc;       //!< Z axis acceleration value
    uint8_t fullscale;  //!< Accelerometer full-scale range
    uint8_t resolution; //!< Accelerometer measurement resolution, in 'bits'.
}Servo_Accelerometer_t;

//! Create the Servo_Accelerometer packet from parameters
void encodeServo_AccelerometerPacket(void* pkt, int16_t xAcc, int16_t yAcc, int16_t zAcc, uint8_t fullscale, uint8_t resolution);

//! Decode the Servo_Accelerometer packet to parameters
int decodeServo_AccelerometerPacket(const void* pkt, int16_t* xAcc, int16_t* yAcc, int16_t* zAcc, uint8_t* fullscale, uint8_t* resolution);

//! return the packet ID for the Servo_Accelerometer packet
#define getServo_AccelerometerPacketID() (PKT_SERVO_ACCELEROMETER)

//! return the minimum encoded length for the Servo_Accelerometer packet
#define getServo_AccelerometerMinDataLength() (8)

//! return the maximum encoded length for the Servo_Accelerometer packet
#define getServo_AccelerometerMaxDataLength() (8)

/*!
 * Servo address information
 */
typedef struct
{
    uint8_t  hwRev;        //!< Hardware revision
    uint32_t serialNumber; //!< Servo serial number
    uint16_t userIDA;      //!< Programmable User ID value 1/2
    uint16_t userIDB;      //!< Programmable User ID value 2/2
}Servo_Address_t;

//! Create the Servo_Address packet
void encodeServo_AddressPacketStructure(void* pkt, const Servo_Address_t* user);

//! Decode the Servo_Address packet
int decodeServo_AddressPacketStructure(const void* pkt, Servo_Address_t* user);

//! Create the Servo_Address packet from parameters
void encodeServo_AddressPacket(void* pkt, uint8_t hwRev, uint32_t serialNumber, uint16_t userIDA, uint16_t userIDB);

//! Decode the Servo_Address packet to parameters
int decodeServo_AddressPacket(const void* pkt, uint8_t* hwRev, uint32_t* serialNumber, uint16_t* userIDA, uint16_t* userIDB);

//! return the packet ID for the Servo_Address packet
#define getServo_AddressPacketID() (PKT_SERVO_ADDRESS)

//! return the minimum encoded length for the Servo_Address packet
#define getServo_AddressMinDataLength() (8)

//! return the maximum encoded length for the Servo_Address packet
#define getServo_AddressMaxDataLength() (8)

/*!
 * Servo title information
 */
typedef struct
{
    uint8_t title[8]; //!< Human readable description string for the servo
}Servo_Title_t;

//! Create the Servo_Title packet from parameters
void encodeServo_TitlePacket(void* pkt, const uint8_t title[8]);

//! Decode the Servo_Title packet to parameters
int decodeServo_TitlePacket(const void* pkt, uint8_t title[8]);

//! return the packet ID for the Servo_Title packet
#define getServo_TitlePacketID() (PKT_SERVO_TITLE)

//! return the minimum encoded length for the Servo_Title packet
#define getServo_TitleMinDataLength() (8)

//! return the maximum encoded length for the Servo_Title packet
#define getServo_TitleMaxDataLength() (8)

/*!
 * Servo firmware information
 */
typedef struct
{
    uint8_t  major;    //!< Firmware version, major number
    uint8_t  minor;    //!< Firmware version, minor number
    uint8_t  day;      //!< Firmware release date, day-of-month
    uint8_t  month;    //!< Firmware release date, month-of-year
    uint16_t year;     //!< Firmware release date, year
    uint16_t checksum; //!< Firmware checksum, 16-bit
}Servo_Firmware_t;

//! Create the Servo_Firmware packet
void encodeServo_FirmwarePacketStructure(void* pkt, const Servo_Firmware_t* user);

//! Decode the Servo_Firmware packet
int decodeServo_FirmwarePacketStructure(const void* pkt, Servo_Firmware_t* user);

//! Create the Servo_Firmware packet from parameters
void encodeServo_FirmwarePacket(void* pkt, uint8_t major, uint8_t minor, uint8_t day, uint8_t month, uint16_t year, uint16_t checksum);

//! Decode the Servo_Firmware packet to parameters
int decodeServo_FirmwarePacket(const void* pkt, uint8_t* major, uint8_t* minor, uint8_t* day, uint8_t* month, uint16_t* year, uint16_t* checksum);

//! return the packet ID for the Servo_Firmware packet
#define getServo_FirmwarePacketID() (PKT_SERVO_FIRMWARE)

//! return the minimum encoded length for the Servo_Firmware packet
#define getServo_FirmwareMinDataLength() (8)

//! return the maximum encoded length for the Servo_Firmware packet
#define getServo_FirmwareMaxDataLength() (8)

/*!
 * Servo system info (uptime, etc)
 */
typedef struct
{
    uint32_t msSinceReset; //!< Time since last power cycle (milliseconds)
    uint16_t powerCycles;  //!< Number of recorded power cycles
    uint8_t  resetCode;    //!< Processor code indicating cause of most recent reset event
    uint8_t  cpuOccupancy;
}Servo_SystemInfo_t;

//! Create the Servo_SystemInfo packet
void encodeServo_SystemInfoPacketStructure(void* pkt, const Servo_SystemInfo_t* user);

//! Decode the Servo_SystemInfo packet
int decodeServo_SystemInfoPacketStructure(const void* pkt, Servo_SystemInfo_t* user);

//! Create the Servo_SystemInfo packet from parameters
void encodeServo_SystemInfoPacket(void* pkt, uint32_t msSinceReset, uint16_t powerCycles, uint8_t resetCode, uint8_t cpuOccupancy);

//! Decode the Servo_SystemInfo packet to parameters
int decodeServo_SystemInfoPacket(const void* pkt, uint32_t* msSinceReset, uint16_t* powerCycles, uint8_t* resetCode, uint8_t* cpuOccupancy);

//! return the packet ID for the Servo_SystemInfo packet
#define getServo_SystemInfoPacketID() (PKT_SERVO_SYSTEM_INFO)

//! return the minimum encoded length for the Servo_SystemInfo packet
#define getServo_SystemInfoMinDataLength() (8)

//! return the maximum encoded length for the Servo_SystemInfo packet
#define getServo_SystemInfoMaxDataLength() (8)

/*!
 * Telemetry settings configuration packet
 */
typedef struct
{
    Servo_TelemetrySettings_t settings;   //!< Servo telemetry settings
    uint8_t                   icdVersion; //!< Servo ICD revision. Field is encoded constant.
}Servo_TelemetryConfig_t;

//! Create the Servo_TelemetryConfig packet
void encodeServo_TelemetryConfigPacketStructure(void* pkt, const Servo_TelemetryConfig_t* user);

//! Decode the Servo_TelemetryConfig packet
int decodeServo_TelemetryConfigPacketStructure(const void* pkt, Servo_TelemetryConfig_t* user);

//! Create the Servo_TelemetryConfig packet from parameters
void encodeServo_TelemetryConfigPacket(void* pkt, const Servo_TelemetrySettings_t* settings);

//! Decode the Servo_TelemetryConfig packet to parameters
int decodeServo_TelemetryConfigPacket(const void* pkt, Servo_TelemetrySettings_t* settings, uint8_t* icdVersion);

//! return the packet ID for the Servo_TelemetryConfig packet
#define getServo_TelemetryConfigPacketID() (PKT_SERVO_TELEMETRY_CONFIG)

//! return the minimum encoded length for the Servo_TelemetryConfig packet
#define getServo_TelemetryConfigMinDataLength() (8)

//! return the maximum encoded length for the Servo_TelemetryConfig packet
#define getServo_TelemetryConfigMaxDataLength() (8)

/*!
 * Non-volatile settings configuration information
 */
typedef struct
{
    unsigned eeUnlocked : 1; //!< Set if the servo is unlocked and ready to receive settings updates
    unsigned eeVersion : 7;  //!< Version of non-volatile settings configuration
    uint16_t eeSize;         //!< Size of non-volatile settings data
    uint16_t eeChecksum;     //!< NV settings checksum
    uint8_t  mramVersion;   
    uint16_t mramSize;      
}Servo_SettingsInfo_t;

//! Create the Servo_SettingsInfo packet
void encodeServo_SettingsInfoPacketStructure(void* pkt, const Servo_SettingsInfo_t* user);

//! Decode the Servo_SettingsInfo packet
int decodeServo_SettingsInfoPacketStructure(const void* pkt, Servo_SettingsInfo_t* user);

//! Create the Servo_SettingsInfo packet from parameters
void encodeServo_SettingsInfoPacket(void* pkt, unsigned eeUnlocked, unsigned eeVersion, uint16_t eeSize, uint16_t eeChecksum, uint8_t mramVersion, uint16_t mramSize);

//! Decode the Servo_SettingsInfo packet to parameters
int decodeServo_SettingsInfoPacket(const void* pkt, unsigned* eeUnlocked, unsigned* eeVersion, uint16_t* eeSize, uint16_t* eeChecksum, uint8_t* mramVersion, uint16_t* mramSize);

//! return the packet ID for the Servo_SettingsInfo packet
#define getServo_SettingsInfoPacketID() (PKT_SERVO_SETTINGS_INFO)

//! return the minimum encoded length for the Servo_SettingsInfo packet
#define getServo_SettingsInfoMinDataLength() (8)

//! return the maximum encoded length for the Servo_SettingsInfo packet
#define getServo_SettingsInfoMaxDataLength() (8)

/*!
 * Servo telltale data
 */
typedef struct
{
    int8_t minTemperature; //!< Minimum temperature seen by the servo
    int8_t maxTemperature; //!< Maximum temperature seen by the servo
}Servo_TelltaleA_t;

//! Create the Servo_TelltaleA packet from parameters
void encodeServo_TelltaleAPacket(void* pkt, int8_t minTemperature, int8_t maxTemperature);

//! Decode the Servo_TelltaleA packet to parameters
int decodeServo_TelltaleAPacket(const void* pkt, int8_t* minTemperature, int8_t* maxTemperature);

//! return the packet ID for the Servo_TelltaleA packet
#define getServo_TelltaleAPacketID() (PKT_SERVO_TELLTALE_A)

//! return the minimum encoded length for the Servo_TelltaleA packet
#define getServo_TelltaleAMinDataLength() (2)

//! return the maximum encoded length for the Servo_TelltaleA packet
#define getServo_TelltaleAMaxDataLength() (2)

#ifdef __cplusplus
}
#endif
#endif // _SERVOPACKETS_H
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     // ServoProtocol.c was generated by ProtoGen version 3.2.a

/*
 * This file is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This file is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Author: Oliver Walters / Currawong Engineering Pty Ltd
 */

#include "ServoProtocol.h"

/*!
 * \brief Lookup label for 'ServoModes' enum entry
 * 
 * \param value is the integer value of the enum entry
 * \return string label of the given entry
 */
const char* ServoModes_EnumLabel(int value)
{
    switch (value)
    {
    default:
        return "";
    case SERVO_MODE_NORMAL:
        return translateServo("SERVO_MODE_NORMAL");
    case SERVO_MODE_CALIBRATING:
        return translateServo("SERVO_MODE_CALIBRATING");
    case SERVO_MODE_TEST:
        return translateServo("SERVO_MODE_TEST");
    case SERVO_MODE_NUM_MODES:
        return translateServo("SERVO_MODE_NUM_MODES");
    }
}


/*!
 * \brief Lookup label for 'ServoMultiCommandPackets' enum entry
 * 
 * \param value is the integer value of the enum entry
 * \return string label of the given entry
 */
const char* ServoMultiCommandPackets_EnumLabel(int value)
{
    switch (value)
    {
    default:
        return "";
    case PKT_SERVO_MULTI_COMMAND_1:
        return translateServo("PKT_SERVO_MULTI_COMMAND_1");
    case PKT_SERVO_MULTI_COMMAND_2:
        return translateServo("PKT_SERVO_MULTI_COMMAND_2");
    case PKT_SERVO_MULTI_COMMAND_3:
        return translateServo("PKT_SERVO_MULTI_COMMAND_3");
    case PKT_SERVO_MULTI_COMMAND_4:
        return translateServo("PKT_SERVO_MULTI_COMMAND_4");
    case PKT_SERVO_MULTI_COMMAND_5:
        return translateServo("PKT_SERVO_MULTI_COMMAND_5");
    case PKT_SERVO_MULTI_COMMAND_6:
        return translateServo("PKT_SERVO_MULTI_COMMAND_6");
    case PKT_SERVO_MULTI_COMMAND_7:
        return translateServo("PKT_SERVO_MULTI_COMMAND_7");
    case PKT_SERVO_MULTI_COMMAND_8:
        return translateServo("PKT_SERVO_MULTI_COMMAND_8");
    case PKT_SERVO_MULTI_COMMAND_9:
        return translateServo("PKT_SERVO_MULTI_COMMAND_9");
    case PKT_SERVO_MULTI_COMMAND_10:
        return translateServo("PKT_SERVO_MULTI_COMMAND_10");
    case PKT_SERVO_MULTI_COMMAND_11:
        return translateServo("PKT_SERVO_MULTI_COMMAND_11");
    case PKT_SERVO_MULTI_COMMAND_12:
        return translateServo("PKT_SERVO_MULTI_COMMAND_12");
    case PKT_SERVO_MULTI_COMMAND_13:
        return translateServo("PKT_SERVO_MULTI_COMMAND_13");
    case PKT_SERVO_MULTI_COMMAND_14:
        return translateServo("PKT_SERVO_MULTI_COMMAND_14");
    case PKT_SERVO_MULTI_COMMAND_15:
        return translateServo("PKT_SERVO_MULTI_COMMAND_15");
    case PKT_SERVO_MULTI_COMMAND_16:
        return translateServo("PKT_SERVO_MULTI_COMMAND_16");
    }
}


/*!
 * \brief Lookup label for 'ServoPackets' enum entry
 * 
 * \param value is the integer value of the enum entry
 * \return string label of the given entry
 */
const char* ServoPackets_EnumLabel(int value)
{
    switch (value)
    {
    default:
        return "";
    case PKT_SERVO_POSITION_COMMAND:
        return translateServo("PKT_SERVO_POSITION_COMMAND");
    case PKT_SERVO_NEUTRAL_COMMAND:
        return translateServo("PKT_SERVO_NEUTRAL_COMMAND");
    case PKT_SERVO_DISABLE:
        return translateServo("PKT_SERVO_DISABLE");
    case PKT_SERVO_ENABLE:
        return translateServo("PKT_SERVO_ENABLE");
    case PKT_SERVO_SYSTEM_COMMAND:
        return translateServo("PKT_SERVO_SYSTEM_COMMAND");
    case PKT_SERVO_SET_TITLE:
        return translateServo("PKT_SERVO_SET_TITLE");
    case PKT_SERVO_STATUS_A:
        return translateServo("PKT_SERVO_STATUS_A");
    case PKT_SERVO_STATUS_B:
        return translateServo("PKT_SERVO_STATUS_B");
    case PKT_SERVO_STATUS_C:
        return translateServo("PKT_SERVO_STATUS_C");
    case PKT_SERVO_STATUS_D:
        return translateServo("PKT_SERVO_STATUS_D");
    case PKT_SERVO_ACCELEROMETER:
        return translateServo("PKT_SERVO_ACCELEROMETER");
    case PKT_SERVO_ADDRESS:
        return translateServo("PKT_SERVO_ADDRESS");
    case PKT_SERVO_TITLE:
        return translateServo("PKT_SERVO_TITLE");
    case PKT_SERVO_FIRMWARE:
        return translateServo("PKT_SERVO_FIRMWARE");
    case PKT_SERVO_SYSTEM_INFO:
        return translateServo("PKT_SERVO_SYSTEM_INFO");
    case PKT_SERVO_TELEMETRY_CONFIG:
        return translateServo("PKT_SERVO_TELEMETRY_CONFIG");
    case PKT_SERVO_SETTINGS_INFO:
        return translateServo("PKT_SERVO_SETTINGS_INFO");
    case PKT_SERVO_FACTORY:
        return translateServo("PKT_SERVO_FACTORY");
    case PKT_SERVO_TELLTALE_A:
        return translateServo("PKT_SERVO_TELLTALE_A");
    case PKT_SERVO_LIMITS:
        return translateServo("PKT_SERVO_LIMITS");
    case PKT_SERVO_CURRENT_LIMITS:
        return translateServo("PKT_SERVO_CURRENT_LIMITS");
    case PKT_SERVO_POTENTIOMETER:
        return translateServo("PKT_SERVO_POTENTIOMETER");
    case PKT_SERVO_BACKLASH:
        return translateServo("PKT_SERVO_BACKLASH");
    case PKT_SERVO_BIN_DATA:
        return translateServo("PKT_SERVO_BIN_DATA");
    case PKT_SERVO_WEAR_LEVEL_A:
        return translateServo("PKT_SERVO_WEAR_LEVEL_A");
    case PKT_SERVO_WEAR_LEVEL_B:
        return translateServo("PKT_SERVO_WEAR_LEVEL_B");
    case PKT_SERVO_LOOKUP_TABLE:
        return translateServo("PKT_SERVO_LOOKUP_TABLE");
    case PKT_SERVO_LOOKUP_ELEMENT:
        return translateServo("PKT_SERVO_LOOKUP_ELEMENT");
    case PKT_SERVO_CONFIG:
        return translateServo("PKT_SERVO_CONFIG");
    case PKT_SERVO_DELTA_CONFIG:
        return translateServo("PKT_SERVO_DELTA_CONFIG");
    case PKT_SERVO_CALIBRATION:
        return translateServo("PKT_SERVO_CALIBRATION");
    case PKT_SERVO_MOTION_CONTROL:
        return translateServo("PKT_SERVO_MOTION_CONTROL");
    case PKT_SERVO_LIMIT_VALUES:
        return translateServo("PKT_SERVO_LIMIT_VALUES");
    case PKT_SERVO_DEBUG_DELTA:
        return translateServo("PKT_SERVO_DEBUG_DELTA");
    case PKT_SERVO_DEBUG_CTRL_LOOP:
        return translateServo("PKT_SERVO_DEBUG_CTRL_LOOP");
    case PKT_SERVO_DEBUG_MOTOR:
        return translateServo("PKT_SERVO_DEBUG_MOTOR");
    case PKT_SERVO_DEBUG_MOTION_CTRL:
        return translateServo("PKT_SERVO_DEBUG_MOTION_CTRL");
    case PKT_SERVO_CTRL_LOOP_SETTINGS:
        return translateServo("PKT_SERVO_CTRL_LOOP_SETTINGS");
    case PKT_SERVO_TELLTALE_SETTINGS:
        return translateServo("PKT_SERVO_TELLTALE_SETTINGS");
    case PKT_SERVO_USER_SETTINGS:
        return translateServo("PKT_SERVO_USER_SETTINGS");
    case PKT_SERVO_SYSTEM_SETTINGS:
        return translateServo("PKT_SERVO_SYSTEM_SETTINGS");
    }
}


/*!
 * \brief Lookup label for 'ServoCommands' enum entry
 * 
 * \param value is the integer value of the enum entry
 * \return string label of the given entry
 */
const char* ServoCommands_EnumLabel(int value)
{
    switch (value)
    {
    default:
        return "";
    case CMD_SERVO_CONFIGURE_LOOKUP_TABLE:
        return translateServo("CMD_SERVO_CONFIGURE_LOOKUP_TABLE");
    case CMD_SERVO_SET_LOOKUP_TABLE_ELEMENT:
        return translateServo("CMD_SERVO_SET_LOOKUP_TABLE_ELEMENT");
    case CMD_SERVO_GET_LOOKUP_TABLE_ELEMENT:
        return translateServo("CMD_SERVO_GET_LOOKUP_TABLE_ELEMENT");
    case CMD_SERVO_SET_CONFIG:
        return translateServo("CMD_SERVO_SET_CONFIG");
    case CMD_SERVO_SET_CURRENT_LIMIT:
        return translateServo("CMD_SERVO_SET_CURRENT_LIMIT");
    case CMD_SERVO_SET_TEMPERATURE_LIMIT:
        return translateServo("CMD_SERVO_SET_TEMPERATURE_LIMIT");
    case CMD_SERVO_SET_RATE_LIMIT:
        return translateServo("CMD_SERVO_SET_RATE_LIMIT");
    case CMD_SERVO_SET_STRENGTH:
     