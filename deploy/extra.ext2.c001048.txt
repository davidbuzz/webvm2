050	5.0
19.6100	4.9
19.6150	5.0
19.6200	4.9
19.6250	5.0
19.6300	4.9
19.6350	5.0
19.6400	4.9
19.6450	5.0
19.6500	4.9
19.6550	5.0
19.6600	4.9
19.6650	5.0
19.6700	4.9
19.6750	4.9
19.6800	4.9
19.6850	4.9
19.6900	4.9
19.6950	4.9
19.7000	4.9
19.7050	4.9
19.7100	5.0
19.7150	4.9
19.7200	5.0
19.7250	4.9
19.7300	4.9
19.7350	4.9
19.7400	4.9
19.7450	4.9
19.7500	4.9
19.7550	4.9
19.7600	4.9
19.7650	4.9
19.7700	5.0
19.7750	4.9
19.7800	5.0
19.7850	4.9
19.7900	4.9
19.7950	4.9
19.8000	4.9
19.8050	4.9
19.8100	4.9
19.8150	4.9
19.8200	4.9
19.8250	4.9
19.8300	4.9
19.8350	4.9
19.8400	4.9
19.8450	4.9
19.8500	5.0
19.8550	4.9
19.8600	5.0
19.8650	4.9
19.8700	5.0
19.8750	4.9
19.8800	5.0
19.8850	4.9
19.8900	5.0
19.8950	4.9
19.9000	4.9
19.9050	4.9
19.9100	4.9
19.9150	4.9
19.9200	5.0
19.9250	4.9
19.9300	5.0
19.9350	4.9
19.9400	4.9
19.9450	4.9
19.9500	4.9
19.9550	4.9
19.9600	4.9
19.9650	5.0
19.9700	4.9
19.9750	4.9
19.9800	4.9
19.9850	4.9
19.9900	4.9
19.9950	4.9
20.0000	4.9
20.0050	5.0
20.0100	4.9
20.0150	4.9
20.0200	4.9
20.0250	4.9
20.0300	4.9
20.0350	4.9
20.0400	4.9
20.0450	5.0
20.0500	4.9
20.0550	5.0
20.0600	4.9
20.0650	4.9
20.0700	4.9
20.0750	4.9
20.0800	4.9
20.0850	5.0
20.0900	4.9
20.0950	5.0
20.1000	4.9
20.1050	5.0
20.1100	4.9
20.1150	5.0
20.1200	4.9
20.1250	5.0
20.1300	4.9
20.1350	4.9
20.1400	4.9
20.1450	4.9
20.1500	4.9
20.1550	4.9
20.1600	4.9
20.1650	5.0
20.1700	4.9
20.1750	5.0
20.1800	4.9
20.1850	4.9
20.1900	4.9
20.1950	4.9
20.2000	4.9
20.2050	4.9
20.2100	4.9
20.2150	4.9
20.2200	4.9
20.2250	4.9
20.2300	4.9
20.2350	4.9
20.2400	4.9
20.2450	4.9
20.2500	4.9
20.2550	4.9
20.2600	5.0
20.2650	4.9
20.2700	4.9
20.2750	4.9
20.2800	5.0
20.2850	4.9
20.2900	5.0
20.2950	4.9
20.3000	5.0
20.3050	4.9
20.3100	5.0
20.3150	4.9
20.3200	4.9
20.3250	4.9
20.3300	5.0
20.3350	4.9
20.3400	5.0
20.3450	4.9
20.3500	5.0
20.3550	4.9
20.3600	5.0
20.3650	4.9
20.3700	5.0
20.3750	4.9
20.3800	5.0
20.3850	4.9
20.3900	5.0
20.3950	4.9
20.4000	4.9
20.4050	4.9
20.4100	4.9
20.4150	4.9
20.4200	5.0
20.4250	4.9
20.4300	4.9
20.4350	4.9
20.4400	4.9
20.4450	4.9
20.4500	4.9
20.4550	5.0
20.4600	4.9
20.4650	4.9
20.4700	4.9
20.4750	4.9
20.4800	4.9
20.4850	4.9
20.4900	4.9
20.4950	4.9
20.5000	4.9
20.5050	5.0
20.5100	4.9
20.5150	4.9
20.5200	4.9
20.5250	4.9
20.5300	4.9
20.5350	5.0
20.5400	4.9
20.5450	5.0
20.5500	4.9
20.5550	4.9
20.5600	4.9
20.5650	4.9
20.5700	4.8
20.5750	4.9
20.5800	4.9
20.5850	4.9
20.5900	4.9
20.5950	4.9
20.6000	4.9
20.6050	4.9
20.6100	4.9
20.6150	5.0
20.6200	4.9
20.6250	5.0
20.6300	4.9
20.6350	5.0
20.6400	4.9
20.6450	4.9
20.6500	4.9
20.6550	4.9
20.6600	4.9
20.6650	4.9
20.6700	4.9
20.6750	4.9
20.6800	4.9
20.6850	4.9
20.6900	5.0
20.6950	4.9
20.7000	4.9
20.7050	4.9
20.7100	4.9
20.7150	4.9
20.7200	4.9
20.7250	4.9
20.7300	4.9
20.7350	4.9
20.7400	4.9
20.7450	4.9
20.7500	4.9
20.7550	4.9
20.7600	4.9
20.7650	4.9
20.7700	4.9
20.7750	4.9
20.7800	4.9
20.7850	4.9
20.7900	4.9
20.7950	4.9
20.8000	4.9
20.8050	4.8
20.8100	4.9
20.8150	4.8
20.8200	4.9
20.8250	4.9
20.8300	4.9
20.8350	4.9
20.8400	4.9
20.8450	4.9
20.8500	5.0
20.8550	4.9
20.8600	5.0
20.8650	4.9
20.8700	4.9
20.8750	4.9
20.8800	4.9
20.8850	4.9
20.8900	4.9
20.8950	4.9
20.9000	4.9
20.9050	4.9
20.9100	4.9
20.9150	4.9
20.9200	4.9
20.9250	4.9
20.9300	4.9
20.9350	4.9
20.9400	4.9
20.9450	4.9
20.9500	4.9
20.9550	4.9
20.9600	4.9
20.9650	4.9
20.9700	4.9
20.9750	4.9
20.9800	4.9
20.9850	4.9
20.9900	4.9
20.9950	4.9
21.0000	4.9
21.0050	5.0
21.0100	4.9
21.0150	4.9
21.0200	4.9
21.0250	4.9
21.0300	4.9
21.0350	4.9
21.0400	4.8
21.0450	4.9
21.0500	4.8
21.0550	4.9
21.0600	4.9
21.0650	4.9
21.0700	4.9
21.0750	5.0
21.0800	4.9
21.0850	4.9
21.0900	4.9
21.0950	4.9
21.1000	4.9
21.1050	4.9
21.1100	4.9
21.1150	4.9
21.1200	4.8
21.1250	4.9
21.1300	4.9
21.1350	4.9
21.1400	4.9
21.1450	4.9
21.1500	4.9
21.1550	4.9
21.1600	4.9
21.1650	4.9
21.1700	4.9
21.1750	4.9
21.1800	4.9
21.1850	4.9
21.1900	4.9
21.1950	4.9
21.2000	4.9
21.2050	4.9
21.2100	4.9
21.2150	4.9
21.2200	4.9
21.2250	4.9
21.2300	4.9
21.2350	4.9
21.2400	4.9
21.2450	4.9
21.2500	4.9
21.2550	4.9
21.2600	4.9
21.2650	4.9
21.2700	4.9
21.2750	4.8
21.2800	4.9
21.2850	4.9
21.2900	4.9
21.2950	4.9
21.3000	5.0
21.3050	4.9
21.3100	<?xml version="1.0"?>
<?xml-stylesheet type="text/xsl" href="http://jsbsim.sourceforge.net/JSBSim.xsl"?>
<fdm_config xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" name="dflyer" version="2.0" release="ALPHA" xsi:noNamespaceSchemaLocation="http://jsbsim.sourceforge.net/JSBSim.xsd">
  <fileheader>
    <author> James Goppert </author>
    <filecreationdate> 2010-03-11 </filecreationdate>
    <version>0.0 </version>
    <description> Arducopter DIY Drones UAV. </description>
  </fileheader>
  <metrics>
    <wingarea unit="M2">   0.017</wingarea>
    <wingspan unit="M">   0.13 </wingspan>
    <chord unit="FT">  0.0 </chord>
    <htailarea unit="FT2">  0.0 </htailarea>
    <htailarm unit="FT">  0.0 </htailarm>
    <vtailarea unit="FT2">  0.0 </vtailarea>
    <vtailarm unit="FT">  0.0 </vtailarm>
    <location name="AERORP" unit="IN">
      <x>   0.00 </x>
      <y>   0.00 </y>
      <z>   0.00 </z>
    </location>
    <location name="EYEPOINT" unit="IN">
      <x>  0.0 </x>
      <y>  0.0 </y>
      <z>  0.0 </z>
    </location>
    <location name="VRP" unit="IN">
      <x>0</x>
      <y>0</y>
      <z>0</z>
    </location>
  </metrics>
  <mass_balance>
    <!--roughtly approximating this as a solid sphere with correct mass-->
    <ixx unit="KG*M2"> 0.036 </ixx>
    <iyy unit="KG*M2"> 0.036 </iyy>
    <izz unit="KG*M2">  0.036 </izz>
    <emptywt unit="KG"> 1.0 </emptywt>
    <location name="CG" unit="IN">
      <x>  0.0 </x>
      <y>  0.0 </y>
      <z>  0.0 </z>
    </location>
    <pointmass name="Payload">
      <weight unit="KG"> 0.0 </weight>
      <location unit="IN">
        <x>  0.0 </x>
        <y>  0.0 </y>
        <z>  0.0 </z>
      </location>
    </pointmass>
  </mass_balance>
  <ground_reactions>
    <contact type="BOGEY" name="frontbase">
      <location unit="M">
        <x>  -0.283 </x>
        <y>   0.00 </y>
        <z>  -0.033</z>
      </location>
      <static_friction>  0.80 </static_friction>
      <dynamic_friction> 0.50 </dynamic_friction>
      <spring_coeff unit="N/M">       800 </spring_coeff>
      <damping_coeff unit="N/M2/SEC2" type="SQUARE">  7 </damping_coeff>
      <damping_coeff_rebound unit="N/M2/SEC2" type="SQUARE">  300 </damping_coeff_rebound>
    </contact>
    <contact type="BOGEY" name="rearbase">
      <location unit="M">
        <x>   0.283 </x>
        <y>   0.00 </y>
        <z>  -0.033</z>
      </location>
      <static_friction>  0.80 </static_friction>
      <dynamic_friction> 0.50 </dynamic_friction>
      <spring_coeff unit="N/M">       800 </spring_coeff>
      <damping_coeff unit="N/M2/SEC2" type="SQUARE">  7 </damping_coeff>
      <damping_coeff_rebound unit="N/M2/SEC2" type="SQUARE">  300 </damping_coeff_rebound>
    </contact>
    <contact type="BOGEY" name="leftbase">
      <location unit="M">
        <x>   0.00 </x>
        <y>   0.283 </y>
        <z>  -0.033</z>
      </location>
      <static_friction>  0.80 </static_friction>
      <dynamic_friction> 0.50 </dynamic_friction>
      <spring_coeff unit="N/M">       800 </spring_coeff>
      <damping_coeff unit="N/M2/SEC2" type="SQUARE">  7 </damping_coeff>
      <damping_coeff_rebound unit="N/M2/SEC2" type="SQUARE">  300 </damping_coeff_rebound>
    </contact>
    <contact type="BOGEY" name="rightbase">
      <location unit="M">
        <x>   0.00 </x>
        <y>  -0.283 </y>
        <z>  -0.033</z>
      </location>
      <static_friction>  0.80 </static_friction>
      <dynamic_friction> 0.50 </dynamic_friction>
      <spring_coeff unit="N/M">       800 </spring_coeff>
      <damping_coeff unit="N/M2/SEC2" type="SQUARE">  7 </damping_coeff>
      <damping_coeff_rebound unit="N/M2/SEC2" type="SQUARE">  300 </damping_coeff_rebound>
    </contact>
  </ground_reactions>
  <!-- the front and rear motors spin clockwise, and the left and right motors spin counter-clockwise. -->
  <propulsion>
    <engine file="a2830-12" name="front">
      <location unit="M">
        <x>  -0.283 </x>
        <y>   0.00  </y>
        <z>   0.00  </z>
      </location>
      <orient unit="DEG">
        <pitch> 90.00 </pitch>
        <roll>   0.00 </roll>
        <yaw>    0.00 </yaw>
      </orient>
      <feed>0</feed>
      <thruster file="prop10x4.5">
        <location unit="M">
          <x>  -0.283 </x>
          <y>   0.00  </y>
          <z>   0.125 </z>
        </location>
        <orient unit="DEG">
          <pitch> 90.00 </pitch>
          <roll>   0.00 </roll>
          <yaw>    0.00 </yaw>
        </orient>
        <sense> 1 </sense>
        <p_factor> 10 </p_factor>
      </thruster>
    </engine>
    <engine file="a2830-12" name="rear">
      <location unit="M">
        <x>   0.283 </x>
        <y>   0.000 </y>
        <z>   0.000 </z>
      </location>
      <orient unit="DEG">
        <pitch> 90.00 </pitch>
        <roll>   0.00 </roll>
        <yaw>    0.00 </yaw>
      </orient>
      <feed>0</feed>
      <thruster file="prop10x4.5">
        <location unit="M">
          <x>   0.283 </x>
          <y>   0.000 </y>
          <z>   0.125 </z>
        </location>
        <orient unit="DEG">
          <pitch> 90.00 </pitch>
          <roll>   0.00 </roll>
          <yaw>    0.00 </yaw>
        </orient>
        <sense> 1 </sense>
        <p_factor> 10 </p_factor>
      </thruster>
    </engine>
    <engine file="a2830-12" name="left">
      <location unit="M">
        <x>   0.00 </x>
        <y>   0.283 </y>
        <z>   0.00 </z>
      </location>
      <orient unit="DEG">
        <pitch> 90.00 </pitch>
        <roll>   0.00 </roll>
        <yaw>    0.00 </yaw>
      </orient>
      <feed>0</feed>
      <thruster file="prop10x4.5">
        <location unit="M">
          <x>   0.00 </x>
          <y>   0.283 </y>
          <z>   0.125 </z>
        </location>
        <orient unit="DEG">
          <pitch> 90.00 </pitch>
          <roll>   0.00 </roll>
          <yaw>    0.00 </yaw>
        </orient>
        <sense> -1 </sense>
        <p_factor> 10 </p_factor>
      </thruster>
    </engine>
    <engine file="a2830-12" name="right">
      <location unit="M">
        <x>   0.000 </x>
        <y>  -0.283 </y>
        <z>   0.000 </z>
      </location>
      <orient unit="DEG">
        <pitch> 90.00 </pitch>
        <roll>   0.00 </roll>
        <yaw>    0.00 </yaw>
      </orient>
      <feed>0</feed>
      <thruster file="prop10x4.5">
        <location unit="M">
          <x>   0.000 </x>
          <y>  -0.283 </y>
          <z>   0.125 </z>
        </location>
        <orient unit="DEG">
          <pitch> 90.00 </pitch>
          <roll>   0.00 </roll>
          <yaw>    0.00 </yaw>
        </orient>
        <sense> -1 </sense>
        <p_factor> 10 </p_factor>
      </thruster>
    </engine>
    <tank type="FUEL" number="0">
      <location unit="M">
        <x>   0.00 </x>
        <y>   0.00 </y>
        <z>  -0.07 </z>
      </location>
      <!--have to have a fuel capacity, so setting it small-->
      <capacity unit="KG"> 0.00000000001 </capacity>
      <contents unit="KG"> 0.0 </contents>
    </tank>
  </propulsion>
  <aerodynamics>
    <axis name="LIFT">
        </axis>
    <axis name="DRAG">
      <function name="aero/coefficient/CD0">
        <description>Overall Drag</description>
        <product>
          <property>aero/qbar-psf</property>
          <property>metrics/Sw-sqft</property>
          <value>1</value>
        </product>
      </function>
    </axis>
    <axis name="SIDE">
        </axis>
    <axis name="ROLL">
        </axis>
    <axis name="PITCH">
        </axis>
    <axis name="YAW">
        </axis>
  </aerodynamics>
</fdm_config>
<!-- vim:ts=2:sw=2:expandtab -->
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         round10 = func(v) {
	if (v == nil) return 0;
	return 0.1*int(v*10);
}

round100 = func(v) {
	if (v == nil) return 0;
	return 0.01*int(v*100);
}

var update_quad = func( ) {
    asl_ft = getprop("/position/altitude-ft");
    ground = getprop("/position/ground-elev-ft");
    agl_m = (asl_ft - ground) * 0.3048;

    setprop("/apm/altitude", round10(agl_m));

    setprop("/apm/pitch",   round10(getprop("/orientation/pitch-deg")));
    setprop("/apm/roll",    round10(getprop("/orientation/roll-deg")));
    setprop("/apm/heading", round10(getprop("/orientation/heading-deg")));

    # airspeed-kt is actually in feet per second (FDM NET bug)
    setprop("/apm/airspeed", round10(0.3048*getprop("/velocities/airspeed-kt")));

    setprop("/apm/motor_right",  round10(getprop("/engines/engine[0]/rpm")/10.0));
    setprop("/apm/motor_left",   round10(getprop("/engines/engine[1]/rpm")/10.0));
    setprop("/apm/motor_front",  round10(getprop("/engines/engine[2]/rpm")/10.0));
    setprop("/apm/motor_back",   round10(getprop("/engines/engine[3]/rpm")/10.0));
}

var main_loop = func {
    update_quad();
    settimer(main_loop, 0);
}


setlistener("/sim/signals/fdm-initialized",
	    func {
		main_loop();
	    });
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  '''
Test AntennaTracker vehicle in SITL

AP_FLAKE8_CLEAN

'''

from __future__ import print_function

import math
import operator
import os

from pymavlink import mavextra
from pymavlink import mavutil

import vehicle_test_suite
from vehicle_test_suite import NotAchievedException

# get location of scripts
testdir = os.path.dirname(os.path.realpath(__file__))
SITL_START_LOCATION = mavutil.location(-27.274439, 151.290064, 343, 8.7)


class AutoTestTracker(vehicle_test_suite.TestSuite):

    def log_name(self):
        return "AntennaTracker"

    def default_speedup(self):
        '''Tracker seems to be race-free'''
        return 100

    def test_filepath(self):
        return os.path.realpath(__file__)

    def sitl_start_location(self):
        return SITL_START_LOCATION

    def default_mode(self):
        return "AUTO"

    def is_tracker(self):
        return True

    def default_frame(self):
        return "tracker"

    def set_current_test_name(self, name):
        self.current_test_name_directory = "AntennaTracker_Tests/" + name + "/"

    def apply_defaultfile_parameters(self):
        # tracker doesn't have a default parameters file
        pass

    def sysid_thismav(self):
        return 2

    def achieve_attitude(self, desyaw, despitch, tolerance=1, target_system=2, target_component=1):
        '''use set_attitude_target to achieve desyaw / despitch'''
        tstart = self.get_sim_time()
        last_attitude_target_sent = 0
        last_debug = 0
        self.progress("Using set_attitude_target to achieve attitude")
        while True:
            now = self.get_sim_time()
            if now - tstart > 60:
                raise NotAchievedException("Did not achieve attitude")
            if now - last_attitude_target_sent > 0.5:
                last_attitude_target_sent = now
                type_mask = (
                    1 << 0 | # ignore roll rate
                    1 << 6 # ignore throttle
                )
                self.mav.mav.set_attitude_target_send(
                    0, # time_boot_ms
                    target_system, # target sysid
                    target_component, # target compid
                    type_mask, # bitmask of things to ignore
                    mavextra.euler_to_quat([0,
                                            math.radians(despitch),
                                            math.radians(desyaw)]), # att
                    0, # yaw rate (rad/s)
                    0, # pitch rate
                    0, # yaw rate
                    0) # thrust, 0 to 1, translated to a climb/descent rate
            m = self.assert_receive_message('ATTITUDE', timeout=2)
            if now - last_debug > 1:
                last_debug = now
                self.progress("yaw=%f desyaw=%f pitch=%f despitch=%f" %
                              (math.degrees(m.yaw), desyaw,
                               math.degrees(m.pitch), despitch))
            yaw_ok = abs(math.degrees(m.yaw) - desyaw) < tolerance
            pitch_ok = abs(math.degrees(m.pitch) - despitch) < tolerance
            if yaw_ok and pitch_ok:
                self.progress("Achieved attitude")
                break

    def reboot_sitl(self, *args, **kwargs):
        self.disarm_vehicle()
        super(AutoTestTracker, self).reboot_sitl(*args, **kwargs)

    def GUIDED(self):
        '''Test GUIDED mode'''
        self.reboot_sitl() # temporary hack around control issues
        self.change_mode(4) # "GUIDED"
        self.achieve_attitude(desyaw=10, despitch=30)
        self.achieve_attitude(desyaw=0, despitch=0)
        self.achieve_attitude(desyaw=45, despitch=10)

    def MANUAL(self):
        '''Test MANUAL mode'''
        self.change_mode(0) # "MANUAL"
        for chan in 1, 2:
            for pwm in 1200, 1600, 1367:
                self.set_rc(chan, pwm)
                self.wait_servo_channel_value(chan, pwm)

    def MAV_CMD_DO_SET_SERVO(self):
        '''Test SERVOTEST mode'''
        self.change_mode(0) # "MANUAL"
        # magically changes to SERVOTEST (3)
        for method in self.run_cmd, self.run_cmd_int:
            for value in 1900, 1200:
                channel = 1
                method(
                    mavutil.mavlink.MAV_CMD_DO_SET_SERVO,
                    p1=channel,
                    p2=value,
                    timeout=1,
                )
                self.wait_servo_channel_value(channel, value)
            for value in 1300, 1670:
                channel = 2
                method(
                    mavutil.mavlink.MAV_CMD_DO_SET_SERVO,
                    p1=channel,
                    p2=value,
                    timeout=1,
                )
                self.wait_servo_channel_value(channel, value)

    def MAV_CMD_MISSION_START(self):
        '''test MAV_CMD_MISSION_START mavlink command'''
        for method in self.run_cmd, self.run_cmd_int:
            self.change_mode(0)  # "MANUAL"
            method(mavutil.mavlink.MAV_CMD_MISSION_START)
            self.wait_mode("AUTO")

    def SCAN(self):
        '''Test SCAN mode'''
        self.change_mode(2) # "SCAN"
        self.set_parameter("SCAN_SPEED_YAW", 20)
        for channel in 1, 2:
            self.wait_servo_channel_value(channel,
                                          1900,
                                          timeout=90,
                                          comparator=operator.ge)
        for channel in 1, 2:
            self.wait_servo_channel_value(channel,
                                          1200,
                                          timeout=90,
                                          comparator=operator.le)

    def BaseMessageSet(self):
        '''ensure we're getting messages we expect'''
        self.set_parameter('BATT_MONITOR', 4)
        self.reboot_sitl()
        for msg in 'BATTERY_STATUS', :
            self.assert_receive_message(msg)

    def disabled_tests(self):
        return {
            "ArmFeatures": "See https://github.com/ArduPilot/ardupilot/issues/10652",
            "CPUFailsafe": " tracker doesn't have a CPU failsafe",
        }

    def GPSForYaw(self):
        '''Moving baseline GPS yaw'''
        self.load_default_params_file("tracker-gps-for-yaw.parm")
        self.reboot_sitl()

        self.wait_gps_fix_type_gte(6, message_type="GPS2_RAW", verbose=True)
        tstart = self.get_sim_time()
        while True:
            if self.get_sim_time_cached() - tstart > 20:
                break
            m_gps_raw = self.assert_receive_message("GPS2_RAW", verbose=True)
            m_sim = self.assert_receive_message("SIMSTATE", verbose=True)
            gps_raw_hdg = m_gps_raw.yaw * 0.01
            sim_hdg = mavextra.wrap_360(math.degrees(m_sim.yaw))
            if abs(gps_raw_hdg - sim_hdg) > 5:
                raise NotAchievedException("GPS_RAW not tracking simstate yaw")
            self.progress(f"yaw match ({gps_raw_hdg} vs {sim_hdg}")

    def tests(self):
        '''return list of all tests'''
        ret = super(AutoTestTracker, self).tests()
        ret.extend([
            self.GUIDED,
            self.MANUAL,
            self.MAV_CMD_DO_SET_SERVO,
            self.MAV_CMD_MISSION_START,
            self.NMEAOutput,
            self.SCAN,
            self.BaseMessageSet,
            self.GPSForYaw,
        ])
        return ret
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    '''
Fly Copter in SITL

AP_FLAKE8_CLEAN
'''

from __future__ import print_function
import copy
import math
import os
import shutil
import time
import numpy

from pymavlink import quaternion
from pymavlink import mavutil
from pymavlink import mavextra
from pymavlink import rotmat

from pysim import util
from pysim import vehicleinfo

import vehicle_test_suite

from vehicle_test_suite import NotAchievedException, AutoTestTimeoutException, PreconditionFailedException
from vehicle_test_suite import Test
from vehicle_test_suite import MAV_POS_TARGET_TYPE_MASK
from vehicle_test_suite import WaitAndMaintainArmed
from vehicle_test_suite import WaitModeTimeout

from pymavlink.rotmat import Vector3

# get location of scripts
testdir = os.path.dirname(os.path.realpath(__file__))
SITL_START_LOCATION = mavutil.location(-35.362938, 149.165085, 584, 270)

# Flight mode switch positions are set-up in arducopter.param to be
#   switch 1 = Circle
#   switch 2 = Land
#   switch 3 = RTL
#   switch 4 = Auto
#   switch 5 = Loiter
#   switch 6 = Stabilize


class AutoTestCopter(vehicle_test_suite.TestSuite):
    @staticmethod
    def get_not_armable_mode_list():
        return ["AUTO", "AUTOTUNE", "BRAKE", "CIRCLE", "FLIP", "LAND", "RTL", "SMART_RTL", "AVOID_ADSB", "FOLLOW"]

    @staticmethod
    def get_not_disarmed_settable_modes_list():
        return ["FLIP", "AUTOTUNE"]

    @staticmethod
    def get_no_position_not_settable_modes_list():
        return []

    @staticmethod
    def get_position_armable_modes_list():
        return ["DRIFT", "GUIDED", "LOITER", "POSHOLD", "THROW"]

    @staticmethod
    def get_normal_armable_modes_list():
        return ["ACRO", "ALT_HOLD", "STABILIZE", "GUIDED_NOGPS"]

    def log_name(self):
        return "ArduCopter"

    def test_filepath(self):
        return os.path.realpath(__file__)

    def default_speedup(self):
        return 100

    def set_current_test_name(self, name):
        self.current_test_name_directory = "ArduCopter_Tests/" + name + "/"

    def sitl_start_location(self):
        return SITL_START_LOCATION

    def mavproxy_options(self):
        ret = super(AutoTestCopter, self).mavproxy_options()
        if self.frame != 'heli':
            ret.append('--quadcopter')
        return ret

    def sitl_streamrate(self):
        return 5

    def vehicleinfo_key(self):
        return 'ArduCopter'

    def default_frame(self):
        return "+"

    def apply_defaultfile_parameters(self):
        # Copter passes in a defaults_filepath in place of applying
        # parameters afterwards.
        pass

    def defaults_filepath(self):
        return self.model_defaults_filepath(self.frame)

    def wait_disarmed_default_wait_time(self):
        return 120

    def close(self):
        super(AutoTestCopter, self).close()

        # [2014/05/07] FC Because I'm doing a cross machine build
        # (source is on host, build is on guest VM) I cannot hard link
        # This flag tells me that I need to copy the data out
        if self.copy_tlog:
            shutil.copy(self.logfile, self.buildlog)

    def is_copter(self):
        return True

    def get_stick_arming_channel(self):
        return int(self.get_parameter("RCMAP_YAW"))

    def get_disarm_delay(self):
        return int(self.get_parameter("DISARM_DELAY"))

    def set_autodisarm_delay(self, delay):
        self.set_parameter("DISARM_DELAY", delay)

    def takeoff(self,
                alt_min=30,
                takeoff_throttle=1700,
                require_absolute=True,
                mode="STABILIZE",
                timeout=120,
                max_err=5):
        """Takeoff get to 30m altitude."""
        self.progress("TAKEOFF")
        self.change_mode(mode)
        if not self.armed():
            self.wait_ready_to_arm(require_absolute=require_absolute, timeout=timeout)
            self.zero_throttle()
            self.arm_vehicle()
        if mode == 'GUIDED':
            self.user_takeoff(alt_min=alt_min, timeout=timeout, max_err=max_err)
        else:
            self.set_rc(3, takeoff_throttle)
        self.wait_altitude(alt_min-1, alt_min+max_err, relative=True, timeout=timeout)
        self.hover()
        self.progress("TAKEOFF COMPLETE")

    def land_and_disarm(self, timeout=60):
        """Land the quad."""
        self.progress("STARTING LANDING")
        self.change_mode("LAND")
        self.wait_landed_and_disarmed(timeout=timeout)

    def wait_landed_and_disarmed(self, min_alt=6, timeout=60):
        """Wait to be landed and disarmed"""
        m = self.mav.recv_match(type='GLOBAL_POSITION_INT', blocking=True)
        alt = m.relative_alt / 1000.0 # mm -> m
        if alt > min_alt:
            self.wait_altitude(min_alt-1, min_alt+5, relative=True, timeout=timeout)
#        self.wait_statustext("SIM Hit ground", timeout=timeout)
        self.wait_disarmed()

    def hover(self, hover_throttle=1500):
        self.set_rc(3, hover_throttle)

    # Climb/descend to a given altitude
    def setAlt(self, desiredAlt=50):
        pos = self.mav.location(relative_alt=True)
        if pos.alt > desiredAlt:
            self.set_rc(3, 1300)
            self.wait_altitude((desiredAlt-5), desiredAlt, relative=True)
        if pos.alt < (desiredAlt-5):
            self.set_rc(3, 1800)
            self.wait_altitude((desiredAlt-5), desiredAlt, relative=True)
        self.hover()

    # Takeoff, climb to given altitude, and fly east for 10 seconds
    def takeoffAndMoveAway(self, dAlt=50, dDist=50):
        self.progress("Centering sticks")
        self.set_rc_from_map({
            1: 1500,
            2: 1500,
            3: 1000,
            4: 1500,
        })
        self.takeoff(alt_min=dAlt, mode='GUIDED')
        self.change_mode("ALT_HOLD")

        self.progress("Yaw to east")
        self.set_rc(4, 1580)
        self.wait_heading(90)
        self.set_rc(4, 1500)

        self.progress("Fly eastbound away from home")
        self.set_rc(2, 1800)
        self.delay_sim_time(10)
        self.set_rc(2, 1500)
        self.hover()
        self.progress("Copter staging 50 meters east of home at 50 meters altitude In mode Alt Hold")

    # loiter - fly south west, then loiter within 5m position and altitude
    def ModeLoiter(self, holdtime=10, maxaltchange=5, maxdistchange=5):
        """Hold loiter position."""
        self.takeoff(10, mode="LOITER")

        # first aim south east
        self.progress("turn south east")
        self.set_rc(4, 1580)
        self.wait_heading(170)
        self.set_rc(4, 1500)

        # fly south east 50m
        self.set_rc(2, 1100)
        self.wait_distance(50)
        self.set_rc(2, 1500)

        # wait for copter to slow moving
        self.wait_groundspeed(0, 2)

        m = self.mav.recv_match(type='VFR_HUD', blocking=True)
        start_altitude = m.alt
        start = self.mav.location()
        tstart = self.get_sim_time()
        self.progress("Holding loiter at %u meters for %u seconds" %
                      (start_altitude, holdtime))
        while self.get_sim_time_cached() < tstart + holdtime:
            m = self.mav.recv_match(type='VFR_HUD', blocking=True)
            pos = self.mav.location()
            delta = self.get_distance(start, pos)
            alt_delta = math.fabs(m.alt - start_altitude)
            self.progress("Loiter Dist: %.2fm, alt:%u" % (delta, m.alt))
            if alt_delta > maxaltchange:
                raise NotAchievedException(
                    "Loiter alt shifted %u meters (> limit %u)" %
                    (alt_delta, maxaltchange))
            if delta > maxdistchange:
                raise NotAchievedException(
                    "Loiter shifted %u meters (> limit of %u)" %
                    (delta, maxdistchange))
        self.progress("Loiter OK for %u seconds" % holdtime)

        self.progress("Climb to 30m")
        self.change_alt(30)

        self.progress("Descend to 20m")
        self.change_alt(20)

        self.do_RTL()

    def ModeAltHold(self):
        '''Test AltHold Mode'''
        self.takeoff(10, mode="ALT_HOLD")
        self.watch_altitude_maintained(altitude_min=9, altitude_max=11)
        # feed in full elevator and aileron input and make sure we
        # retain altitude:
        self.set_rc_from_map({
            1: 1000,
            2: 1000,
        })
        self.watch_altitude_maintained(altitude_min=9, altitude_max=11)
        self.set_rc_from_map({
            1: 1500,
            2: 1500,
        })
        self.do_RTL()

    def fly_to_origin(self, final_alt=10):
        origin = self.poll_message("GPS_GLOBAL_ORIGIN")
        self.change_mode("GUIDED")
        self.guided_move_global_relative_alt(origin.latitude,
                                             origin.longitude,
                                             final_alt)

    def change_alt(self, alt_min, climb_throttle=1920, descend_throttle=1080):
        """Change altitude."""
        def adjust_altitude(current_alt, target_alt, accuracy):
            if math.fabs(current_alt - target_alt) <= accuracy:
                self.hover()
            elif current_alt < target_alt:
                self.set_rc(3, climb_throttle)
            else:
                self.set_rc(3, descend_throttle)
        self.wait_altitude(
            (alt_min - 5),
            alt_min,
            relative=True,
            called_function=lambda current_alt, target_alt: adjust_altitude(current_alt, target_alt, 1)
        )
        self.hover()

    def RecordThenPlayMission(self, side=50, timeout=300):
        '''Use switches to toggle in mission, then fly it'''
        self.takeoff(20, mode="ALT_HOLD")

        """Fly a square, flying N then E ."""
        tstart = self.get_sim_time()

        # ensure all sticks in the middle
        self.set_rc_from_map({
            1: 1500,
            2: 1500,
            3: 1500,
            4: 1500,
        })

        # switch to loiter mode temporarily to stop us from rising
        self.change_mode('LOITER')

        # first aim north
        self.progress("turn right towards north")
        self.set_rc(4, 1580)
        self.wait_heading(10)
        self.set_rc(4, 1500)

        # save bottom left corner of box as waypoint
        self.progress("Save WP 1 & 2")
        self.save_wp()

        # switch back to ALT_HOLD mode
        self.change_mode('ALT_HOLD')

        # pitch forward to fly north
        self.progress("Going north %u meters" % side)
        self.set_rc(2, 1300)
        self.wait_distance(side)
        self.set_rc(2, 1500)

        # save top left corner of square as waypoint
        self.progress("Save WP 3")
        self.save_wp()

        # roll right to fly east
        self.progress("Going east %u meters" % side)
        self.set_rc(1, 1700)
        self.wait_distance(side)
        self.set_rc(1, 1500)

        # save top right corner of square as waypoint
        self.progress("Save WP 4")
        self.save_wp()

        # pitch back to fly south
        self.progress("Going south %u meters" % side)
        self.set_rc(2, 1700)
        self.wait_distance(side)
        self.set_rc(2, 1500)

        # save bottom right corner of square as waypoint
        self.progress("Save WP 5")
        self.save_wp()

        # roll left to fly west
        self.progress("Going west %u meters" % side)
        self.set_rc(1, 1300)
        self.wait_distance(side)
        self.set_rc(1, 1500)

        # save bottom left corner of square (should be near home) as waypoint
        self.progress("Save WP 6")
        self.save_wp()

        # reduce throttle again
        self.set_rc(3, 1500)

        # descend to 10m
        self.progress("Descend to 10m in Loiter")
        self.change_mode('LOITER')
        self.set_rc(3, 1200)
        time_left = timeout - (self.get_sim_time() - tstart)
        self.progress("timeleft = %u" % time_left)
        if time_left < 20:
            time_left = 20
        self.wait_altitude(-10, 10, timeout=time_left, relative=True)
        self.set_rc(3, 1500)
        self.save_wp()

        # save the stored mission to file
        mavproxy = self.start_mavproxy()
        num_wp = self.save_mission_to_file_using_mavproxy(
            mavproxy,
            os.path.join(testdir, "ch7_mission.txt"))
        self.stop_mavproxy(mavproxy)
        if not num_wp:
            raise NotAchievedException("save_mission_to_file failed")

        self.progress("test: Fly a mission from 1 to %u" % num_wp)
        self.change_mode('AUTO')
        self.set_current_waypoint(1)
        self.wait_waypoint(0, num_wp-1, timeout=500)
        self.progress("test: MISSION COMPLETE: passed!")
        self.land_and_disarm()

    # enter RTL mode and wait for the vehicle to disarm
    def do_RTL(self, distance_min=None, check_alt=True, distance_max=10, timeout=250, quiet=False):
        """Enter RTL mode and wait for the vehicle to disarm at Home."""
        self.change_mode("RTL")
        self.hover()
        self.wait_rtl_complete(check_alt=check_alt, distance_max=distance_max, timeout=timeout, quiet=True)

    def wait_rtl_complete(self, check_alt=True, distance_max=10, timeout=250, quiet=False):
        """Wait for RTL to reach home and disarm"""
        self.progress("Waiting RTL to reach Home and disarm")
        tstart = self.get_sim_time()
        while self.get_sim_time_cached() < tstart + timeout:
            m = self.mav.recv_match(type='GLOBAL_POSITION_INT', blocking=True)
            alt = m.relative_alt / 1000.0 # mm -> m
            home_distance = self.distance_to_home(use_cached_home=True)
            home = ""
            alt_valid = alt <= 1
            distance_valid = home_distance < distance_max
            if check_alt:
                if alt_valid and distance_valid:
                    home = "HOME"
            else:
                if distance_valid:
                    home = "HOME"
            if not quiet:
                self.progress("Alt: %.02f  HomeDist: %.02f %s" %
                              (alt, home_distance, home))

            # our post-condition is that we are disarmed:
            if not self.armed():
                if home == "":
                    raise NotAchievedException("Did not get home")
                # success!
                return

        raise AutoTestTimeoutException("Did not get home and disarm")

    def LoiterToAlt(self):
        """Loiter-To-Alt"""

        self.context_push()

        self.set_parameters({
            "PLND_ENABLED": 1,
            "PLND_TYPE": 4,
        })

        self.set_analog_rangefinder_parameters()

        self.reboot_sitl()

        num_wp = self.load_mission("copter_loiter_to_alt.txt")

        self.change_mode('LOITER')

        self.install_terrain_handlers_context()
        self.wait_ready_to_arm()

        self.arm_vehicle()

        self.change_mode('AUTO')

        self.set_rc(3, 1550)

        self.wait_current_waypoint(2)

        self.set_rc(3, 1500)

        self.wait_waypoint(0, num_wp-1, timeout=500)

        self.wait_disarmed()

        self.context_pop()
        self.reboot_sitl()

    # Tests all actions and logic behind the radio failsafe
    def ThrottleFailsafe(self, side=60, timeout=360):
        '''Test Throttle Failsafe'''
        self.start_subtest("If you haven't taken off yet RC failure should be instant disarm")
        self.change_mode("STABILIZE")
        self.set_parameter("DISARM_DELAY", 0)
        self.arm_vehicle()
        self.set_parameter("SIM_RC_FAIL", 1)
        self.disarm_wait(timeout=1)
        self.set_parameter("SIM_RC_FAIL", 0)
        self.set_parameter("DISARM_DELAY", 10)

        # Trigger an RC failure with the failsafe disabled. Verify no action taken.
        self.start_subtest("Radio failsafe disabled test: FS_THR_ENABLE=0 should take no failsafe action")
        self.set_parameter('FS_THR_ENABLE', 0)
        self.set_parameter('FS_OPTIONS', 0)
        self.takeoffAndMoveAway()
        self.set_parameter("SIM_RC_FAIL", 1)
        self.delay_sim_time(5)
        self.wait_mode("ALT_HOLD")
        self.set_parameter("SIM_RC_FAIL", 0)
        self.delay_sim_time(5)
        self.wait_mode("ALT_HOLD")
        self.end_subtest("Completed Radio failsafe disabled test")

        # Trigger an RC failure, verify radio failsafe triggers,
        # restore radio, verify RC function by changing modes to cicle
        # and stabilize.
        self.start_subtest("Radio failsafe recovery test")
        self.set_parameter('FS_THR_ENABLE', 1)
        self.set_parameter("SIM_RC_FAIL", 1)
        self.wait_mode("RTL")
        self.delay_sim_time(5)
        self.set_parameter("SIM_RC_FAIL", 0)
        self.delay_sim_time(5)
        self.set_rc(5, 1050)
        self.wait_mode("CIRCLE")
        self.set_rc(5, 1950)
        self.wait_mode("STABILIZE")
        self.end_subtest("Completed Radio failsafe recovery test")

        # Trigger and RC failure, verify failsafe triggers and RTL completes
        self.start_subtest("Radio failsafe RTL with no options test: FS_THR_ENABLE=1 & FS_OPTIONS=0")
        self.set_parameter("SIM_RC_FAIL", 1)
        self.wait_mode("RTL")
        self.wait_rtl_complete()
        self.set_parameter("SIM_RC_FAIL", 0)
        self.end_subtest("Completed Radio failsafe RTL with no options test")

        # Trigger and RC failure, verify failsafe triggers and land completes
        self.start_subtest("Radio failsafe LAND with no options test: FS_THR_ENABLE=3 & FS_OPTIONS=0")
        self.set_parameter('FS_THR_ENABLE', 3)
        self.takeoffAndMoveAway()
        self.set_parameter("SIM_RC_FAIL", 1)
        self.wait_mode("LAND")
        self.wait_landed_and_disarmed()
        self.set_parameter("SIM_RC_FAIL", 0)
        self.end_subtest("Completed Radio failsafe LAND with no options test")

        # Trigger and RC failure, verify failsafe triggers and SmartRTL completes
        self.start_subtest("Radio failsafe SmartRTL->RTL with no options test: FS_THR_ENABLE=4 & FS_OPTIONS=0")
        self.set_parameter('FS_THR_ENABLE', 4)
        self.takeoffAndMoveAway()
        self.set_parameter("SIM_RC_FAIL", 1)
        self.wait_mode("SMART_RTL")
        self.wait_disarmed()
        self.set_parameter("SIM_RC_FAIL", 0)
        self.end_subtest("Completed Radio failsafe SmartRTL->RTL with no options test")

        # Trigger and RC failure, verify failsafe triggers and SmartRTL completes
        self.start_subtest("Radio failsafe SmartRTL->Land with no options test: FS_THR_ENABLE=5 & FS_OPTIONS=0")
        self.set_parameter('FS_THR_ENABLE', 5)
        self.takeoffAndMoveAway()
        self.set_parameter("SIM_RC_FAIL", 1)
        self.wait_mode("SMART_RTL")
        self.wait_disarmed()
        self.set_parameter("SIM_RC_FAIL", 0)
        self.end_subtest("Completed Radio failsafe SmartRTL_Land with no options test")

        # Trigger a GPS failure and RC failure, verify RTL fails into
        # land mode and completes
        self.start_subtest("Radio failsafe RTL fails into land mode due to bad position.")
        self.set_parameter('FS_THR_ENABLE', 1)
        self.takeoffAndMoveAway()
        self.set_parameter('SIM_GPS_DISABLE', 1)
        self.delay_sim_time(5)
        self.set_parameter("SIM_RC_FAIL", 1)
        self.wait_mode("LAND")
        self.wait_landed_and_disarmed()
        self.set_parameter("SIM_RC_FAIL", 0)
        self.set_parameter('SIM_GPS_DISABLE', 0)
        self.wait_ekf_happy()
        self.end_subtest("Completed Radio failsafe RTL fails into land mode due to bad position.")

        # Trigger a GPS failure and RC failure, verify SmartRTL fails
        # into land mode and completes
        self.start_subtest("Radio failsafe SmartRTL->RTL fails into land mode due to bad position.")
        self.set_parameter('FS_THR_ENABLE', 4)
        self.takeoffAndMoveAway()
        self.set_parameter('SIM_GPS_DISABLE', 1)
        self.delay_sim_time(5)
        self.set_parameter("SIM_RC_FAIL", 1)
        self.wait_mode("LAND")
        self.wait_landed_and_disarmed()
        self.set_parameter("SIM_RC_FAIL", 0)
        self.set_parameter('SIM_GPS_DISABLE', 0)
        self.wait_ekf_happy()
        self.end_subtest("Completed Radio failsafe SmartRTL->RTL fails into land mode due to bad position.")

        # Trigger a GPS failure and RC failure, verify SmartRTL fails
        # into land mode and completes
        self.start_subtest("Radio failsafe SmartRTL->LAND fails into land mode due to bad position.")
        self.set_parameter('FS_THR_ENABLE', 5)
        self.takeoffAndMoveAway()
        self.set_parameter('SIM_GPS_DISABLE', 1)
        self.delay_sim_time(5)
        self.set_parameter("SIM_RC_FAIL", 1)
        self.wait_mode("LAND")
        self.wait_landed_and_disarmed()
        self.set_parameter("SIM_RC_FAIL", 0)
        self.set_parameter('SIM_GPS_DISABLE', 0)
        self.wait_ekf_happy()
        self.end_subtest("Completed Radio failsafe SmartRTL->LAND fails into land mode due to bad position.")

        # Trigger a GPS failure, then restore the GPS. Trigger an RC
        # failure, verify SmartRTL fails into RTL and completes
        self.start_subtest("Radio failsafe SmartRTL->RTL fails into RTL mode due to no path.")
        self.set_parameter('FS_THR_ENABLE', 4)
        self.takeoffAndMoveAway()
        self.set_parameter('SIM_GPS_DISABLE', 1)
        self.wait_statustext("SmartRTL deactivated: bad position", timeout=60)
        self.set_parameter('SIM_GPS_DISABLE', 0)
        self.wait_ekf_happy()
        self.delay_sim_time(5)
        self.set_parameter("SIM_RC_FAIL", 1)
        self.wait_mode("RTL")
        self.wait_rtl_complete()
        self.set_parameter("SIM_RC_FAIL", 0)
        self.end_subtest("Completed Radio failsafe SmartRTL->RTL fails into RTL mode due to no path.")

        # Trigger a GPS failure, then restore the GPS. Trigger an RC
        # failure, verify SmartRTL fails into Land and completes
        self.start_subtest("Radio failsafe SmartRTL->LAND fails into land mode due to no path.")
        self.set_parameter('FS_THR_ENABLE', 5)
        self.takeoffAndMoveAway()
        self.set_parameter('SIM_GPS_DISABLE', 1)
        self.wait_statustext("SmartRTL deactivated: bad position", timeout=60)
        self.set_parameter('SIM_GPS_DISABLE', 0)
        self.wait_ekf_happy()
        self.delay_sim_time(5)
        self.set_parameter("SIM_RC_FAIL", 1)
        self.wait_mode("LAND")
        self.wait_landed_and_disarmed()
        self.set_parameter("SIM_RC_FAIL", 0)
        self.end_subtest("Completed Radio failsafe SmartRTL->LAND fails into land mode due to no path.")

        # Trigger an RC failure in guided mode with the option enabled
        # to continue in guided. Verify no failsafe action takes place
        self.start_subtest("Radio failsafe with option to continue in guided mode: FS_THR_ENABLE=1 & FS_OPTIONS=4")
        self.set_parameter("SYSID_MYGCS", self.mav.source_system)
        self.setGCSfailsafe(1)
        self.set_parameter('FS_THR_ENABLE', 1)
        self.set_parameter('FS_OPTIONS', 4)
        self.takeoffAndMoveAway()
        self.change_mode("GUIDED")
        self.set_parameter("SIM_RC_FAIL", 1)
        self.delay_sim_time(5)
        self.wait_mode("GUIDED")
        self.set_parameter("SIM_RC_FAIL", 0)
        self.delay_sim_time(5)
        self.change_mode("ALT_HOLD")
        self.setGCSfailsafe(0)
        # self.change_mode("RTL")
        # self.wait_disarmed()
        self.end_subtest("Completed Radio failsafe with option to continue in guided mode")

        # Trigger an RC failure in AUTO mode with the option enabled
        # to continue the mission. Verify no failsafe action takes
        # place
        self.start_subtest("Radio failsafe RTL with option to continue mission: FS_THR_ENABLE=1 & FS_OPTIONS=1")
        self.set_parameter('FS_OPTIONS', 1)
        self.progress("# Load copter_mission")
        num_wp = self.load_mission("copter_mission.txt", strict=False)
        if not num_wp:
            raise NotAchievedException("load copter_mission failed")
#        self.takeoffAndMoveAway()
        self.change_mode("AUTO")
        self.set_parameter("SIM_RC_FAIL", 1)
        self.delay_sim_time(5)
        self.wait_mode("AUTO")
        self.set_parameter("SIM_RC_FAIL", 0)
        self.delay_sim_time(5)
        self.wait_mode("AUTO")
        # self.change_mode("RTL")
        # self.wait_disarmed()
        self.end_subtest("Completed Radio failsafe RTL with option to continue mission")

        # Trigger an RC failure in AUTO mode without the option
        # enabled to continue. Verify failsafe triggers and RTL
        # completes
        self.start_subtest("Radio failsafe RTL in mission without "
                           "option to continue should RTL: FS_THR_ENABLE=1 & FS_OPTIONS=0")
        self.set_parameter('FS_OPTIONS', 0)
        self.set_parameter("SIM_RC_FAIL", 1)
        self.wait_mode("RTL")
        self.wait_rtl_complete()
        self.clear_mission(mavutil.mavlink.MAV_MISSION_TYPE_MISSION)
        self.set_parameter("SIM_RC_FAIL", 0)
        self.end_subtest("Completed Radio failsafe RTL in mission without option to continue")

        self.progress("All radio failsafe tests complete")
        self.set_parameter('FS_THR_ENABLE', 0)
        self.reboot_sitl()

    def ThrottleFailsafePassthrough(self):
        '''check servo passthrough on RC failsafe.  Make sure it doesn't glitch to the bad RC input value'''
        channel = 7
        trim_value = 1450
        self.set_parameters({
            'RC%u_MIN' % channel: 1000,
            'RC%u_MAX' % channel: 2000,
            'SERVO%u_MIN' % channel: 1000,
            'SERVO%u_MAX' % channel: 2000,
            'SERVO%u_TRIM' % channel: trim_value,
            'SERVO%u_FUNCTION' % channel: 146,  # scaled passthrough for channel 7
            'FS_THR_ENABLE': 1,
            'RC_FS_TIMEOUT': 10,
            'SERVO_RC_FS_MSK': 1 << (channel-1),
        })

        self.reboot_sitl()

        self.context_set_message_rate_hz('SERVO_OUTPUT_RAW', 200)

        self.set_rc(channel, 1799)
        expected_servo_output_value = 1778  # 1778 because of weird trim
        self.wait_servo_channel_value(channel, expected_servo_output_value)
        # receiver goes into failsafe with wild override values:

        def ensure_SERVO_values_never_input(mav, m):
            if m.get_type() != "SERVO_OUTPUT_RAW":
                return
            value = getattr(m, "servo%u_raw" % channel)
            if value != expected_servo_output_value and value != trim_value:
                raise NotAchievedException("Bad servo value %u received" % value)

        self.install_message_hook_context(ensure_SERVO_values_never_input)
        self.progress("Forcing receiver into failsafe")
        self.set_rc_from_map({
            3: 800,
            channel: 1300,
        })
        self.wait_servo_channel_value(channel, trim_value)
        self.delay_sim_time(10)

    # Tests all actions and logic behind the GCS failsafe
    def GCSFailsafe(self, side=60, timeout=360):
        '''Test GCS Failsafe'''
        try:
            self.test_gcs_failsafe(side=side, timeout=timeout)
        except Exception as ex:
            self.setGCSfailsafe(0)
            self.set_parameter('FS_OPTIONS', 0)
            self.disarm_vehicle(force=True)
            self.reboot_sitl()
            raise ex

    def test_gcs_failsafe(self, side=60, timeout=360):
        # Test double-SmartRTL; ensure we do SmarRTL twice rather than
        # landing (tests fix for actual bug)
        self.set_parameter("SYSID_MYGCS", self.mav.source_system)
        self.context_push()
        self.start_subtest("GCS failsafe SmartRTL twice")
        self.setGCSfailsafe(3)
        self.set_parameter('FS_OPTIONS', 8)
        self.takeoffAndMoveAway()
        self.set_heartbeat_rate(0)
        self.wait_mode("SMART_RTL")
        self.wait_disarmed()
        self.set_heartbeat_rate(self.speedup)
        self.wait_statustext("GCS Failsafe Cleared", timeout=60)

        self.takeoffAndMoveAway()
        self.set_heartbeat_rate(0)
        self.wait_statustext("GCS Failsafe")

        def ensure_smartrtl(mav, m):
            if m.get_type() != "HEARTBEAT":
                return
            # can't use mode_is here because we're in the message hook
            print("Mode: %s" % self.mav.flightmode)
            if self.mav.flightmode != "SMART_RTL":
                raise NotAchievedException("Not in SMART_RTL")
        self.install_message_hook_context(ensure_smartrtl)

        self.set_heartbeat_rate(self.speedup)
        self.wait_statustext("GCS Failsafe Cleared", timeout=60)
        self.set_heartbeat_rate(0)
        self.wait_statustext("GCS Failsafe")

        self.wait_disarmed()

        self.end_subtest("GCS failsafe SmartRTL twice")
        self.set_heartbeat_rate(self.speedup)
        self.wait_statustext("GCS Failsafe Cleared", timeout=60)
        self.context_pop()

        # Trigger telemetry loss with failsafe disabled. Verify no action taken.
        self.start_subtest("GCS failsafe disabled test: FS_GCS_ENABLE=0 should take no failsafe action")
        self.setGCSfailsafe(0)
        self.takeoffAndMoveAway()
        self.set_heartbeat_rate(0)
        self.delay_sim_time(5)
        self.wait_mode("ALT_HOLD")
        self.set_heartbeat_rate(self.speedup)
        self.delay_sim_time(5)
        self.wait_mode("ALT_HOLD")
        self.end_subtest("Completed GCS failsafe disabled test")

        # Trigger telemetry loss with failsafe enabled. Verify
        # failsafe triggers to RTL. Restore telemetry, verify failsafe
        # clears, and change modes.
        self.start_subtest("GCS failsafe recovery test: FS_GCS_ENABLE=1 & FS_OPTIONS=0")
        self.setGCSfailsafe(1)
        self.set_parameter('FS_OPTIONS', 0)
        self.set_heartbeat_rate(0)
        self.wait_mode("RTL")
        self.set_heartbeat_rate(self.speedup)
        self.wait_statustext("GCS Failsafe Cleared", timeout=60)
        self.change_mode("LOITER")
        self.end_subtest("Completed GCS failsafe recovery test")

        # Trigger telemetry loss with failsafe enabled. Verify
        # failsafe triggers to RTL. Restore telemetry, verify failsafe
        # clears, and change modes.
        self.start_subtest("GCS failsafe recovery test: FS_GCS_ENABLE=1 & FS_OPTIONS=0 & FS_GCS_TIMEOUT=10")
        self.setGCSfailsafe(1)
        self.set_parameter('FS_OPTIONS', 0)
        old_gcs_timeout = self.get_parameter("FS_GCS_TIMEOUT")
        new_gcs_timeout = old_gcs_timeout * 2
        self.set_parameter("FS_GCS_TIMEOUT", new_gcs_timeout)
        self.set_heartbeat_rate(0)
        self.delay_sim_time(old_gcs_timeout + (new_gcs_timeout - old_gcs_timeout) / 2)
        self.assert_mode("LOITER")
        self.wait_mode("RTL")
        self.set_heartbeat_rate(self.speedup)
        self.wait_statustext("GCS Failsafe Cleared", timeout=60)
        self.change_mode("LOITER")
        self.set_parameter('FS_GCS_TIMEOUT', old_gcs_timeout)
        self.end_subtest("Completed GCS failsafe recovery test")

        # Trigger telemetry loss with failsafe enabled. Verify failsafe triggers and RTL completes
        self.start_subtest("GCS failsafe RTL with no options test: FS_GCS_ENABLE=1 & FS_OPTIONS=0")
        self.setGCSfailsafe(1)
        self.set_parameter('FS_OPTIONS', 0)
        self.set_heartbeat_rate(0)
        self.wait_mode("RTL")
        self.wait_rtl_complete()
        self.set_heartbeat_rate(self.speedup)
        self.wait_statustext("GCS Failsafe Cleared", timeout=60)
        self.end_subtest("Completed GCS failsafe RTL with no options test")

        # Trigger telemetry loss with failsafe enabled. Verify failsafe triggers and land completes
        self.start_subtest("GCS failsafe LAND with no options test: FS_GCS_ENABLE=5 & FS_OPTIONS=0")
        self.setGCSfailsafe(5)
        self.takeoffAndMoveAway()
        self.set_heartbeat_rate(0)
        self.wait_mode("LAND")
        self.wait_landed_and_disarmed()
        self.set_heartbeat_rate(self.speedup)
        self.wait_statustext("GCS Failsafe Cleared", timeout=60)
        self.end_subtest("Completed GCS failsafe land with no options test")

        # Trigger telemetry loss with failsafe enabled. Verify failsafe triggers and SmartRTL completes
        self.start_subtest("GCS failsafe SmartRTL->RTL with no options test: FS_GCS_ENABLE=3 & FS_OPTIONS=0")
        self.setGCSfailsafe(3)
        self.takeoffAndMoveAway()
        self.set_heartbeat_rate(0)
        self.wait_mode("SMART_RTL")
        self.wait_disarmed()
        self.set_heartbeat_rate(self.speedup)
        self.wait_statustext("GCS Failsafe Cleared", timeout=60)
        self.end_subtest("Completed GCS failsafe SmartRTL->RTL with no options test")

        # Trigger telemetry loss with failsafe enabled. Verify failsafe triggers and SmartRTL completes
        self.start_subtest("GCS failsafe SmartRTL->Land with no options test: FS_GCS_ENABLE=4 & FS_OPTIONS=0")
        self.setGCSfailsafe(4)
        self.takeoffAndMoveAway()
        self.set_heartbeat_rate(0)
        self.wait_mode("SMART_RTL")
        self.wait_disarmed()
        self.set_heartbeat_rate(self.speedup)
        self.wait_statustext("GCS Failsafe Cleared", timeout=60)
        self.end_subtest("Completed GCS failsafe SmartRTL->Land with no options test")

        # Trigger telemetry loss with an invalid failsafe value. Verify failsafe triggers and RTL completes
        self.start_subtest("GCS failsafe invalid value with no options test: FS_GCS_ENABLE=99 & FS_OPTIONS=0")
        self.setGCSfailsafe(99)
        self.takeoffAndMoveAway()
        self.set_heartbeat_rate(0)
        self.wait_mode("RTL")
        self.wait_rtl_complete()
        self.set_heartbeat_rate(self.speedup)
        self.wait_statustext("GCS Failsafe Cleared", timeout=60)
        self.end_subtest("Completed GCS failsafe invalid value with no options test")

        # Trigger telemetry loss with failsafe enabled to test FS_OPTIONS settings
        self.start_subtest("GCS failsafe with option bit tests: FS_GCS_ENABLE=1 & FS_OPTIONS=64/2/16")
        num_wp = self.load_mission("copter_mission.txt", strict=False)
        if not num_wp:
            raise NotAchievedException("load copter_mission failed")
        self.setGCSfailsafe(1)
        self.set_parameter('FS_OPTIONS', 16)
        self.takeoffAndMoveAway()
        self.progress("Testing continue in pilot controlled modes")
        self.set_heartbeat_rate(0)
        self.wait_statustext("GCS Failsafe - Continuing Pilot Control", timeout=60)
        self.delay_sim_time(5)
        self.wait_mode("ALT_HOLD")
        self.set_heartbeat_rate(self.speedup)
        self.wait_statustext("GCS Failsafe Cleared", timeout=60)

        self.progress("Testing continue in auto mission")
        self.set_parameter('FS_OPTIONS', 2)
        self.change_mode("AUTO")
        self.delay_sim_time(5)
        self.set_heartbeat_rate(0)
        self.wait_statustext("GCS Failsafe - Continuing Auto Mode", timeout=60)
        self.delay_sim_time(5)
        self.wait_mode("AUTO")
        self.set_heartbeat_rate(self.speedup)
        self.wait_statustext("GCS Failsafe Cleared", timeout=60)

        self.progress("Testing continue landing in land mode")
        self.set_parameter('FS_OPTIONS', 8)
        self.change_mode("LAND")
        self.delay_sim_time(5)
        self.set_heartbeat_rate(0)
        self.wait_statustext("GCS Failsafe - Continuing Landing", timeout=60)
        self.delay_sim_time(5)
        self.wait_mode("LAND")
        self.wait_landed_and_disarmed()
        self.set_heartbeat_rate(self.speedup)
        self.wait_statustext("GCS Failsafe Cleared", timeout=60)
        self.end_subtest("Completed GCS failsafe with option bits")

        self.setGCSfailsafe(0)
        self.set_parameter('FS_OPTIONS', 0)
        self.progress("All GCS failsafe tests complete")

    def CustomController(self, timeout=300):
        '''Test Custom Controller'''
        self.progress("Configure custom controller parameters")
        self.set_parameters({
            'CC_TYPE': 2,
            'CC_AXIS_MASK': 7,
            'RC6_OPTION': 109,
        })
        self.set_rc(6, 1000)
        self.reboot_sitl()

        if self.get_parameter("CC_TYPE") != 2 :
            raise NotAchievedException("Custom controller is not switched to PID backend.")

        # check if we can retrive any param inside PID backend
        self.get_parameter("CC2_RAT_YAW_P")

        # takeoff in GPS mode and switch to CIRCLE
        self.takeoff(10, mode="LOITER", takeoff_throttle=2000)
        self.change_mode("CIRCLE")

        self.context_push()
        self.context_collect('STATUSTEXT')

        # switch custom controller on
        self.set_rc(6, 2000)
        self.wait_statustext("Custom controller is ON", check_context=True)

        # wait 20 second to see if the custom controller destabilize the aircraft
        if self.wait_altitude(7, 13, relative=True, minimum_duration=20) :
            raise NotAchievedException("Custom controller is not stable.")

        # switch custom controller off
        self.set_rc(6, 1000)
        self.wait_statustext("Custom controller is OFF", check_context=True)

        self.context_pop()
        self.do_RTL()
        self.progress("Custom controller test complete")

    # Tests all actions and logic behind the battery failsafe
    def BatteryFailsafe(self, timeout=300):
        '''Fly Battery Failsafe'''
        self.progress("Configure battery failsafe parameters")
        self.set_parameters({
            'SIM_SPEEDUP': 4,
            'BATT_LOW_VOLT': 11.5,
            'BATT_CRT_VOLT': 10.1,
            'BATT_FS_LOW_ACT': 0,
            'BATT_FS_CRT_ACT': 0,
            'FS_OPTIONS': 0,
            'SIM_BATT_VOLTAGE': 12.5,
        })

        # Trigger low battery condition with failsafe disabled. Verify
        # no action taken.
        self.start_subtest("Batt failsafe disabled test")
        self.takeoffAndMoveAway()
        m = self.mav.recv_match(type='BATTERY_STATUS', blocking=True, timeout=1)
        if m.charge_state != mavutil.mavlink.MAV_BATTERY_CHARGE_STATE_OK:
            raise NotAchievedException("Expected state ok")
        self.set_parameter('SIM_BATT_VOLTAGE', 11.4)
        self.wait_statustext("Battery 1 is low", timeout=60)
        m = self.mav.recv_match(type='BATTERY_STATUS', blocking=True, timeout=1)
        if m.charge_state != mavutil.mavlink.MAV_BATTERY_CHARGE_STATE_LOW:
            raise NotAchievedException("Expected state low")
        self.delay_sim_time(5)
        self.wait_mode("ALT_HOLD")
        self.set_parameter('SIM_BATT_VOLTAGE', 10.0)
        self.wait_statustext("Battery 1 is critical", timeout=60)
        m = self.mav.recv_match(type='BATTERY_STATUS', blocking=True, timeout=1)
        if m.charge_state != mavutil.mavlink.MAV_BATTERY_CHARGE_STATE_CRITICAL:
            raise NotAchievedException("Expected state critical")
        self.delay_sim_time(5)
        self.wait_mode("ALT_HOLD")
        self.change_mode("RTL")
        self.wait_rtl_complete()
        self.set_parameter('SIM_BATT_VOLTAGE', 12.5)
        self.reboot_sitl()
        self.end_subtest("Completed Batt failsafe disabled test")

        # TWO STAGE BATTERY FAILSAFE: Trigger low battery condition,
        # then critical battery condition. Verify RTL and Land actions
        # complete.
        self.start_subtest("Two stage battery failsafe test with RTL and Land")
        self.takeoffAndMoveAway()
        self.delay_sim_time(3)
        self.set_parameters({
            'BATT_FS_LOW_ACT': 2,
            'BATT_FS_CRT_ACT': 1,
            'SIM_BATT_VOLTAGE': 11.4,
        })
        self.wait_statustext("Battery 1 is low", timeout=60)
        self.delay_sim_time(5)
        self.wait_mode("RTL")
        self.delay_sim_time(10)
        self.set_parameter('SIM_BATT_VOLTAGE', 10.0)
        self.wait_statustext("Battery 1 is critical", timeout=60)
        self.delay_sim_time(5)
        self.wait_mode("LAND")
        self.wait_landed_and_disarmed()
        self.set_parameter('SIM_BATT_VOLTAGE', 12.5)
        self.reboot_sitl()
        self.end_subtest("Completed two stage battery failsafe test with RTL and Land")

        # TWO STAGE BATTERY FAILSAFE: Trigger low battery condition,
        # then critical battery condition. Verify both SmartRTL
        # actions complete
        self.start_subtest("Two stage battery failsafe test with SmartRTL")
        self.takeoffAndMoveAway()
        self.set_parameter('BATT_FS_LOW_ACT', 3)
        self.set_parameter('BATT_FS_CRT_ACT', 4)
        self.delay_sim_time(10)
        self.set_parameter('SIM_BATT_VOLTAGE', 11.4)
        self.wait_statustext("Battery 1 is low", timeout=60)
        self.delay_sim_time(5)
        self.wait_mode("SMART_RTL")
        self.change_mode("LOITER")
        self.delay_sim_time(10)
        self.set_parameter('SIM_BATT_VOLTAGE', 10.0)
        self.wait_statustext("Battery 1 is critical", timeout=60)
        self.delay_sim_time(5)
        self.wait_mode("SMART_RTL")
        self.wait_disarmed()
        self.set_parameter('SIM_BATT_VOLTAGE', 12.5)
        self.reboot_sitl()
        self.end_subtest("Completed two stage battery failsafe test with SmartRTL")

        # Trigger low battery condition in land mode with FS_OPTIONS
        # set to allow land mode to continue. Verify landing completes
        # uninterrupted.
        self.start_subtest("Battery failsafe with FS_OPTIONS set to continue landing")
        self.takeoffAndMoveAway()
        self.set_parameter('FS_OPTIONS', 8)
        self.change_mode("LAND")
        self.delay_sim_time(5)
        self.set_parameter('SIM_BATT_VOLTAGE', 11.4)
        self.wait_statustext("Battery 1 is low", timeout=60)
        self.delay_sim_time(5)
        self.wait_mode("LAND")
        self.wait_landed_and_disarmed()
        self.set_parameter('SIM_BATT_VOLTAGE', 12.5)
        self.reboot_sitl()
        self.end_subtest("Completed battery failsafe with FS_OPTIONS set to continue landing")

        # Trigger a critical battery condition, which triggers a land
        # mode failsafe. Trigger an RC failure. Verify the RC failsafe
        # is prevented from stopping the low battery landing.
        self.start_subtest("Battery failsafe critical landing")
        self.takeoffAndMoveAway(100, 50)
        self.set_parameters({
            'FS_OPTIONS': 0,
            'BATT_FS_LOW_ACT': 1,
            'BATT_FS_CRT_ACT': 1,
            'FS_THR_ENABLE': 1,
        })
        self.delay_sim_time(5)
        self.set_parameter('SIM_BATT_VOLTAGE', 10.0)
        self.wait_statustext("Battery 1 is critical", timeout=60)
        self.wait_mode("LAND")
        self.delay_sim_time(10)
        self.set_parameter("SIM_RC_FAIL", 1)
        self.delay_sim_time(10)
        self.wait_mode("LAND")
        self.wait_landed_and_disarmed()
        self.set_parameter('SIM_BATT_VOLTAGE', 12.5)
        self.set_parameter("SIM_RC_FAIL", 0)
        self.reboot_sitl()
        self.end_subtest("Completed battery failsafe critical landing")

        # Trigger low battery condition with failsafe set to terminate. Copter will disarm and crash.
        self.start_subtest("Battery failsafe terminate")
        self.takeoffAndMoveAway()
        self.set_parameter('BATT_FS_LOW_ACT', 5)
        self.delay_sim_time(10)
        self.set_parameter('SIM_BATT_VOLTAGE', 11.4)
        self.wait_statustext("Battery 1 is low", timeout=60)
        self.wait_disarmed()
        self.end_subtest("Completed terminate failsafe test")

        self.progress("All Battery failsafe tests complete")

    def BatteryMissing(self):
        ''' Test battery health pre-arm and missing failsafe'''
        self.context_push()

        # Should be good to arm with no changes
        self.wait_ready_to_arm()

        # Make monitor unhealthy, this should result in unhealthy prearm
        self.set_parameters({
            'BATT_VOLT_PIN': -1,
        })

        self.drain_mav()

        # Battery should go unhealthy immediately
        self.assert_prearm_failure("Battery 1 unhealthy", other_prearm_failures_fatal=False)

        # Return monitor to health
        self.context_pop()
        self.context_push()

        self.wait_ready_to_arm()

        # take off and then trigger in flight
        self.takeoff(10, mode="LOITER")
        self.set_parameters({
            'BATT_VOLT_PIN': -1,
        })

        # Should trigger missing failsafe
        self.wait_statustext("Battery 1 is missing")

        # Done, reset params and reboot to clear failsafe
        self.land_and_disarm()
        self.context_pop()
        self.reboot_sitl()

    def VibrationFailsafe(self):
        '''Test Vibration Failsafe'''
        self.context_push()

        # takeoff in Loiter to 20m
        self.takeoff(20, mode="LOITER")

        # simulate accel bias caused by high vibration
        self.set_parameters({
            'SIM_ACC1_BIAS_Z': 2,
            'SIM_ACC2_BIAS_Z': 2,
            'SIM_ACC3_BIAS_Z': 2,
        })

        # wait for Vibration compensation warning and change to LAND mode
        self.wait_statustext("Vibration compensation ON", timeout=30)
        self.change_mode("LAND")

        # check vehicle descends to 2m or less within 40 seconds
        self.wait_altitude(-5, 2, timeout=50, relative=True)

        # force disarm of vehicle (it will likely not automatically disarm)
        self.disarm_vehicle(force=True)

        # revert simulated accel bias and reboot to restore EKF health
        self.context_pop()
        self.reboot_sitl()

    def test_takeoff_check_mode(self, mode, user_takeoff=False):
        # stabilize check
        self.progress("Motor takeoff check in %s" % mode)
        self.change_mode(mode)
        self.zero_throttle()
        self.wait_ready_to_arm()
        self.context_push()
        self.context_collect('STATUSTEXT')
        self.arm_vehicle()
        if user_takeoff:
            self.run_cmd(
                mavutil.mavlink.MAV_CMD_NAV_TAKEOFF,
                p7=10,
            )
        else:
            self.set_rc(3, 1700)
        # we may never see ourselves as armed in a heartbeat
        self.wait_statustext("Takeoff blocked: ESC RPM out of range", check_context=True)
        self.context_pop()
        self.zero_throttle()
        self.disarm_vehicle()
        self.wait_disarmed()

    # Tests the motor failsafe
    def TakeoffCheck(self):
        '''Test takeoff check'''
        self.set_parameters({
            "AHRS_EKF_TYPE": 10,
            'SIM_ESC_TELEM': 1,
            'SIM_ESC_ARM_RPM': 500,
            'TKOFF_RPM_MIN': 1000,
        })

        self.test_takeoff_check_mode("STABILIZE")
        self.test_takeoff_check_mode("ACRO")
        self.test_takeoff_check_mode("LOITER")
        self.test_takeoff_check_mode("ALT_HOLD")
        # self.test_takeoff_check_mode("FLOWHOLD")
        self.test_takeoff_check_mode("GUIDED", True)
        self.test_takeoff_check_mode("POSHOLD")
        # self.test_takeoff_check_mode("SPORT")

        self.set_parameters({
            "AHRS_EKF_TYPE": 10,
            'SIM_ESC_TELEM': 1,
            'TKOFF_RPM_MIN': 1,
            'TKOFF_RPM_MAX': 3,
        })
        self.test_takeoff_check_mode("STABILIZE")
        self.test_takeoff_check_mode("ACRO")
        self.test_takeoff_check_mode("LOITER")
        self.test_takeoff_check_mode("ALT_HOLD")
        # self.test_takeoff_check_mode("FLOWHOLD")
        self.test_takeoff_check_mode("GUIDED", True)
        self.test_takeoff_check_mode("POSHOLD")
        # self.test_takeoff_check_mode("SPORT")

    def assert_dataflash_message_field_level_at(self,
                                                mtype,
                                                field,
                                                level,
                                                maintain=1,
                                                tolerance=0.05,
                                                timeout=30,
                                                condition=None,
                                                dfreader_start_timestamp=None,
                                                verbose=False):
        '''wait for EKF's accel bias to reach a level and maintain it'''

        if verbose:
            self.progress("current onboard log filepath: %s" % self.current_onboard_log_filepath())
        dfreader = self.dfreader_for_current_onboard_log()

        achieve_start = None
        current_value = None
        while True:
            m = dfreader.recv_match(type=mtype, condition=condition)
            if m is None:
                raise NotAchievedException("%s.%s did not maintain %f" %
                                           (mtype, field, level))
            if dfreader_start_timestamp is not None:
                if m.TimeUS < dfreader_start_timestamp:
                    continue
            if verbose:
                print("m=%s" % str(m))
            current_value = getattr(m, field)

            if abs(current_value - level) > tolerance:
                if achieve_start is not None:
                    self.progress("Achieve stop at %u" % m.TimeUS)
                    achieve_start = None
                continue

            dfreader_now = m.TimeUS
            if achieve_start is None:
                self.progress("Achieve start at %u (got=%f want=%f)" %
                              (dfreader_now, current_value, level))
                if maintain is None:
                    return
                achieve_start = m.TimeUS
                continue

            # we're achieving....
            if dfreader_now - achieve_start > maintain*1e6:
                return dfreader_now

    # Tests any EK3 accel bias is subtracted from the correct IMU data
    def EK3AccelBias(self):
        '''Test EK3 Accel Bias data'''
        self.context_push()

        self.start_test("Test zero bias")
        dfreader_tstart = self.assert_dataflash_message_field_level_at(
            "XKF2",
            "AZ",
            0.0,
            condition="XKF2.C==1",
        )

        # Add 2m/s/s bias to the second IMU
        self.set_parameters({
            'SIM_ACC2_BIAS_Z': 0.7,
        })

        self.start_subtest("Ensuring second core has bias")
        self.delay_sim_time(30)
        dfreader_tstart = self.assert_dataflash_message_field_level_at(
            "XKF2", "AZ", 0.7,
            condition="XKF2.C==1",
        )

        self.start_subtest("Ensuring earth frame is compensated")
        self.assert_dataflash_message_field_level_at(
            "RATE", "A", 0,
            maintain=1,
            tolerance=2,    # RATE.A is in cm/s/s
            dfreader_start_timestamp=dfreader_tstart,
        )

        # now switch the EKF to only using the second core:
        self.set_parameters({
            'SIM_ACC2_BIAS_Z': 0.0,
            "EK3_IMU_MASK": 0b10,
        })
        self.reboot_sitl()

        self.delay_sim_time(30)
        dfreader_tstart = self.assert_dataflash_message_field_level_at(
            "XKF2", "AZ", 0.0,
            condition="XKF2.C==0",
        )

        # Add 2m/s/s bias to the second IMU
        self.set_parameters({
            'SIM_ACC2_BIAS_Z': 0.7,
        })

        self.start_subtest("Ensuring first core now has bias")
        self.delay_sim_time(30)
        dfreader_tstart = self.assert_dataflash_message_field_level_at(
            "XKF2", "AZ", 0.7,
            condition="XKF2.C==0",
        )

        self.start_subtest("Ensuring earth frame is compensated")
        self.assert_dataflash_message_field_level_at(
            "RATE", "A", 0,
            maintain=1,
            tolerance=2,  # RATE.A is in cm/s/s
            dfreader_start_timestamp=dfreader_tstart,
            verbose=True,
        )

        # revert simulated accel bias and reboot to restore EKF health
        self.context_pop()
        self.reboot_sitl()

    # StabilityPatch - fly south, then hold loiter within 5m
    # position and altitude and reduce 1 motor to 60% efficiency
    def StabilityPatch(self,
                       holdtime=30,
                       maxaltchange=5,
                       maxdistchange=10):
        '''Fly stability patch'''
        self.takeoff(10, mode="LOITER")

        # first south
        self.progress("turn south")
        self.set_rc(4, 1580)
        self.wait_heading(180)
        self.set_rc(4, 1500)

        # fly west 80m
        self.set_rc(2, 1100)
        self.wait_distance(80)
        self.set_rc(2, 1500)

        # wait for copter to slow moving
        self.wait_groundspeed(0, 2)

        m = self.mav.recv_match(type='VFR_HUD', blocking=True)
        start_altitude = m.alt
        start = self.mav.location()
        tstart = self.get_sim_time()
        self.progress("Holding loiter at %u meters for %u seconds" %
                      (start_altitude, holdtime))

        # cut motor 1's to efficiency
        self.progress("Cutting motor 1 to 65% efficiency")
        self.set_parameter("SIM_ENGINE_MUL", 0.65)

        while self.get_sim_time_cached() < tstart + holdtime:
            m = self.mav.recv_match(type='VFR_HUD', blocking=True)
            pos = self.mav.location()
            delta = self.get_distance(start, pos)
            alt_delta = math.fabs(m.alt - start_altitude)
            self.progress("Loiter Dist: %.2fm, alt:%u" % (delta, m.alt))
            if alt_delta > maxaltchange:
                raise NotAchievedException(
                    "Loiter alt shifted %u meters (> limit %u)" %
                    (alt_delta, maxaltchange))
            if delta > maxdistchange:
                raise NotAchievedException(
                    ("Loiter shifted %u meters (> limit of %u)" %
                     (delta, maxdistchange)))

        # restore motor 1 to 100% efficiency
        self.set_parameter("SIM_ENGINE_MUL", 1.0)

        self.progress("Stability patch and Loiter OK for %us" % holdtime)

        self.progress("RTL after stab patch")
        self.do_RTL()

    def debug_arming_issue(self):
        while True:
            self.send_mavlink_arm_command()
            m = self.mav.recv_match(blocking=True, timeout=1)
            if m is None:
                continue
            if m.get_type() in ["STATUSTEXT", "COMMAND_ACK"]:
                print("Got: %s" % str(m))
            if self.mav.motors_armed():
                self.progress("Armed")
                return

    # fly_fence_test - fly east until you hit the horizontal circular fence
    avoid_behave_slide = 0

    def fly_fence_avoid_test_radius_check(self, timeout=180, avoid_behave=avoid_behave_slide):
        using_mode = "LOITER" # must be something which adjusts velocity!
        self.change_mode(using_mode)
        fence_radius = 15
        fence_margin = 3
        self.set_parameters({
            "FENCE_ENABLE": 1, # fence
            "FENCE_TYPE": 2, # circle
            "FENCE_RADIUS": fence_radius,
            "FENCE_MARGIN": fence_margin,
            "AVOID_ENABLE": 1,
            "AVOID_BEHAVE": avoid_behave,
            "RC10_OPTION": 40, # avoid-enable
        })
        self.wait_ready_to_arm()
        self.set_rc(10, 2000)
        home_distance = self.distance_to_home(use_cached_home=True)
        if home_distance > 5:
            raise PreconditionFailedException("Expected to be within 5m of home")
        self.zero_throttle()
        self.arm_vehicle()
        self.set_rc(3, 1700)
        self.wait_altitude(10, 100, relative=True)
        self.set_rc(3, 1500)
        self.set_rc(2, 1400)
        self.wait_distance_to_home(12, 20, timeout=30)
        tstart = self.get_sim_time()
        push_time = 70 # push against barrier for 60 seconds
        failed_max = False
        failed_min = False
        while True:
            if self.get_sim_time() - tstart > push_time:
                self.progress("Push time up")
                break
            # make sure we don't RTL:
            if not self.mode_is(using_mode):
                raise NotAchievedException("Changed mode away from %s" % using_mode)
            distance = self.distance_to_home(use_cached_home=True)
            inner_radius = fence_radius - fence_margin
            want_min = inner_radius - 1 # allow 1m either way
            want_max = inner_radius + 1 # allow 1m either way
            self.progress("Push: distance=%f %f<want<%f" %
                          (distance, want_min, want_max))
            if distance < want_min:
                if failed_min is False:
                    self.progress("Failed min")
                    failed_min = True
            if distance > want_max:
                if failed_max is False:
                    self.progress("Failed max")
                    failed_max = True
        if failed_min and failed_max:
            raise NotAchievedException("Failed both min and max checks.  Clever")
        if failed_min:
            raise NotAchievedException("Failed min")
        if failed_max:
            raise NotAchievedException("Failed max")
        self.set_rc(2, 1500)
        self.do_RTL()

    def HorizontalAvoidFence(self, timeout=180):
        '''Test horizontal Avoidance fence'''
        self.fly_fence_avoid_test_radius_check(avoid_behave=1, timeout=timeout)
        self.fly_fence_avoid_test_radius_check(avoid_behave=0, timeout=timeout)

    # fly_fence_test - fly east until you hit the horizontal circular fence
    def HorizontalFence(self, timeout=180):
        '''Test horizontal fence'''
        # enable fence, disable avoidance
        self.set_parameters({
            "FENCE_ENABLE": 1,
            "AVOID_ENABLE": 0,
        })

        self.change_mode("LOITER")
        self.wait_ready_to_arm()

        # fence requires home to be set:
        m = self.poll_home_position(quiet=False)

        self.start_subtest("ensure we can't arm if outside fence")
        self.load_fence("fence-in-middle-of-nowhere.txt")

        self.delay_sim_time(5) # let fence check run so it loads-from-eeprom
        self.assert_prearm_failure("Vehicle breaching Polygon fence")
        self.progress("Failed to arm outside fence (good!)")
        self.clear_fence()
        self.delay_sim_time(5) # let fence breach clear
        self.drain_mav()
        self.end_subtest("ensure we can't arm if outside fence")

        self.start_subtest("ensure we can't arm with bad radius")
        self.context_push()
        self.set_parameter("FENCE_RADIUS", -1)
        self.assert_prearm_failure("Invalid Circle FENCE_RADIUS value")
        self.context_pop()
        self.progress("Failed to arm with bad radius")
        self.drain_mav()
        self.end_subtest("ensure we can't arm with bad radius")

        self.start_subtest("ensure we can't arm with bad alt")
        self.context_push()
        self.set_parameter("FENCE_ALT_MAX", -1)
        self.assert_prearm_failure("Invalid FENCE_ALT_MAX value")
        self.context_pop()
        self.progress("Failed to arm with bad altitude")
        self.end_subtest("ensure we can't arm with bad radius")

        self.start_subtest("Check breach-fence behaviour")
        self.set_parameter("FENCE_TYPE", 2)
        self.takeoff(10, mode="LOITER")

        # first east
        self.progress("turn east")
        self.set_rc(4, 1580)
        self.wait_heading(160, timeout=60)
        self.set_rc(4, 1500)

        fence_radius = self.get_parameter("FENCE_RADIUS")

        self.progress("flying forward (east) until we hit fence")
        pitching_forward = True
        self.set_rc(2, 1100)

        self.progress("Waiting for fence breach")
        tstart = self.get_sim_time()
        while not self.mode_is("RTL"):
            if self.get_sim_time_cached() - tstart > 30:
                raise NotAchievedException("Did not breach fence")

            m = self.mav.recv_match(type='GLOBAL_POSITION_INT', blocking=True)
            alt = m.relative_alt / 1000.0 # mm -> m
            home_distance = self.distance_to_home(use_cached_home=True)
            self.progress("Alt: %.02f  HomeDistance: %.02f (fence radius=%f)" %
                          (alt, home_distance, fence_radius))

        self.progress("Waiting until we get home and disarm")
        tstart = self.get_sim_time()
        while self.get_sim_time_cached() < tstart + timeout:
            m = self.mav.recv_match(type='GLOBAL_POSITION_INT', blocking=True)
            alt = m.relative_alt / 1000.0 # mm -> m
            home_distance = self.distance_to_home(use_cached_home=True)
            self.progress("Alt: %.02f  HomeDistance: %.02f" %
                          (alt, home_distance))
            # recenter pitch sticks once we're home so we don't fly off again
            if pitching_forward and home_distance < 50:
                pitching_forward = False
                self.set_rc(2, 1475)
                # disable fence
                self.set_parameter("FENCE_ENABLE", 0)
            if (alt <= 1 and home_distance < 10) or (not self.armed() and home_distance < 10):
                # reduce throttle
                self.zero_throttle()
                self.change_mode("LAND")
                self.wait_landed_and_disarmed()
                self.progress("Reached home OK")
                self.zero_throttle()
                return

        # give we're testing RTL, doing one here probably doesn't make sense
        home_distance = self.distance_to_home(use_cached_home=True)
        raise AutoTestTimeoutException(
            "Fence test failed to reach home (%fm distance) - "
            "timed out after %u seconds" % (home_distance, timeout,))

    # MaxAltFence - fly up until you hit the fence ceiling
    def MaxAltFence(self):
        '''Test Max Alt Fence'''
        self.takeoff(10, mode="LOITER")
        """Hold loiter position."""

        # enable fence, disable avoidance
        self.set_parameters({
            "FENCE_ENABLE": 1,
            "AVOID_ENABLE": 0,
            "FENCE_TYPE": 1,
            "FENCE_ENABLE" : 1,
        })

        self.change_alt(10)

        # first east
        self.progress("turning east")
        self.set_rc(4, 1580)
        self.wait_heading(160, timeout=60)
        self.set_rc(4, 1500)

        self.progress("flying east 20m")
        self.set_rc(2, 1100)
        self.wait_distance(20)

        self.progress("flying up")
        self.set_rc_from_map({
            2: 1500,
            3: 1800,
        })

        # wait for fence to trigger
        self.wait_mode('RTL', timeout=120)

        self.wait_rtl_complete()

        self.zero_throttle()

    # MaxAltFence - fly up and make sure fence action does not trigger
    # Also check that the vehicle will not try and descend too fast when trying to backup from a max alt fence due to avoidance
    def MaxAltFenceAvoid(self):
        '''Test Max Alt Fence Avoidance'''
        self.takeoff(10, mode="LOITER")
        """Hold loiter position."""

        # enable fence, only max altitude, defualt is 100m
        # No action, rely on avoidance to prevent the breach
        self.set_parameters({
            "FENCE_ENABLE": 1,
            "FENCE_TYPE": 1,
            "FENCE_ACTION": 0,
        })

        # Try and fly past the fence
        self.set_rc(3, 1920)

        # Avoid should prevent the vehicle flying past the fence, so the altitude wait should timeouts
        try:
            self.wait_altitude(140, 150, timeout=90, relative=True)
            raise NotAchievedException("Avoid should prevent reaching altitude")
        except AutoTestTimeoutException:
            pass
        except Exception as e:
            raise e

        # Check descent is not too fast, allow 10% above the configured backup speed
        max_descent_rate = -self.get_parameter("AVOID_BACKUP_SPD") * 1.1

        def get_climb_rate(mav, m):
            m_type = m.get_type()
            if m_type != 'VFR_HUD':
                return
            if m.climb < max_descent_rate:
                raise NotAchievedException("Decending too fast want %f got %f" % (max_descent_rate, m.climb))

        self.context_push()
        self.install_message_hook_context(get_climb_rate)

        # Reduce fence alt, this will result in a fence breach, but there is no action.
        # Avoid should then backup the vehicle to be under the new fence alt.
        self.set_parameters({
            "FENCE_ALT_MAX": 50,
        })
        self.wait_altitude(40, 50, timeout=90, relative=True)

        self.context_pop()

        self.set_rc(3, 1500)
        self.do_RTL()

    # fly_alt_min_fence_test - fly down until you hit the fence floor
    def MinAltFence(self):
        '''Test Min Alt Fence'''
        self.takeoff(30, mode="LOITER", timeout=60)

        # enable fence, disable avoidance
        self.set_parameters({
            "AVOID_ENABLE": 0,
            "FENCE_ENABLE" : 1,
            "FENCE_TYPE": 8,
            "FENCE_ALT_MIN": 20,
        })

        self.change_alt(30)

        # Activate the floor fence
        # TODO this test should run without requiring this
        self.do_fence_enable()

        # first east
        self.progress("turn east")
        self.set_rc(4, 1580)
        self.wait_heading(160, timeout=60)
        self.set_rc(4, 1500)

        # fly forward (east) at least 20m
        self.set_rc(2, 1100)
        self.wait_distance(20)

        # stop flying forward and start flying down:
        self.set_rc_from_map({
            2: 1500,
            3: 1200,
        })

        # wait for fensors_enabled & fence_bit):
            raise NotAchievedException("Fence enabled before being configured")

        self.change_mode('MANUAL')
        self.wait_ready_to_arm()

        self.load_fence("CMAC-fence.txt")

        self.set_parameter("RC7_OPTION", 11) # AC_Fence uses Aux switch functionality
        self.set_parameter("FENCE_ACTION", 4) # Fence action Brake
        self.set_rc_from_map({
            3: 1000,
            7: 2000,
        }) # Turn fence on with aux function

        m = self.mav.recv_match(type='FENCE_STATUS', blocking=True, timeout=2)
        self.progress("Got (%s)" % str(m))
        if m is None:
            raise NotAchievedException("Got FENCE_STATUS unexpectedly")

        self.progress("Checking fence is initially OK")
        self.wait_sensor_state(mavutil.mavlink.MAV_SYS_STATUS_GEOFENCE,
                               present=True,
                               enabled=True,
                               healthy=True,
                               verbose=True,
                               timeout=30)

        self.set_parameter("THR_FS_VALUE", 960)
        self.progress("Failing receiver (throttle-to-950)")
        self.set_parameter("SIM_RC_FAIL", 2) # throttle-to-950
        self.wait_mode("CIRCLE")
        self.delay_sim_time(1) # give
        self.do_timesync_roundtrip()

        self.progress("Checking fence is OK after receiver failure (bind-values)")
        fence_bit = mavutil.mavlink.MAV_SYS_STATUS_GEOFENCE
        m = self.assert_receive_message('SYS_STATUS')
        if (not (m.onboard_control_sensors_enabled & fence_bit)):
            raise NotAchievedException("Fence not enabled after RC fail")
        self.do_fence_disable() # Ensure the fence is disabled after test

    def GCSFailsafe(self):
        '''Ensure Long-Failsafe works on GCS loss'''
        self.start_subtest("Test Failsafe: RTL")
        self.load_sample_mission()
        self.set_parameters({
            "FS_GCS_ENABL": 1,
            "FS_LONG_ACTN": 1,
            "RTL_AUTOLAND": 1,
            "SYSID_MYGCS": self.mav.source_system,
        })
        self.takeoff()
        self.change_mode('LOITER')
        self.progress("Disconnecting GCS")
        self.set_heartbeat_rate(0)
        self.wait_mode("RTL", timeout=10)
        self.set_heartbeat_rate(self.speedup)
        self.end_subtest("Completed RTL Failsafe test")

        self.start_subtest("Test Failsafe: FBWA Glide")
        self.set_parameters({
            "FS_LONG_ACTN": 2,
        })
        self.change_mode('AUTO')
        self.progress("Disconnecting GCS")
        self.set_heartbeat_rate(0)
        self.wait_mode("FBWA", timeout=10)
        self.set_heartbeat_rate(self.speedup)
        self.end_subtest("Completed FBWA Failsafe test")

        self.start_subtest("Test Failsafe: Deploy Parachute")
        self.load_mission("plane-parachute-mission.txt")
        self.set_current_waypoint(1)
        self.set_parameters({
            "CHUTE_ENABLED": 1,
            "CHUTE_TYPE": 10,
            "SERVO9_FUNCTION": 27,
            "SIM_PARA_ENABLE": 1,
            "SIM_PARA_PIN": 9,
            "FS_LONG_ACTN": 3,
        })
        self.change_mode("AUTO")
        self.progress("Disconnecting GCS")
        self.set_heartbeat_rate(0)
        self.wait_statustext("BANG", timeout=60)
        self.set_heartbeat_rate(self.speedup)
        self.disarm_vehicle(force=True)
        self.reboot_sitl()
        self.end_subtest("Completed Parachute Failsafe test")

    def TestGripperMission(self):
        '''Test Gripper mission items'''
        self.set_parameter("RTL_AUTOLAND", 1)
        self.load_mission("plane-gripper-mission.txt")
        self.set_current_waypoint(1)
        self.change_mode('AUTO')
        self.wait_ready_to_arm()
        self.arm_vehicle()
        self.wait_statustext("Gripper Grabbed", timeout=60)
        self.wait_statustext("Gripper Released", timeout=60)
        self.wait_statustext("Auto disarmed", timeout=60)

    def assert_fence_sys_status(self, present, enabled, health):
        self.delay_sim_time(1)
        self.do_timesync_roundtrip()
        m = self.assert_receive_message('SYS_STATUS', timeout=1)
        tests = [
            ("present", present, m.onboard_control_sensors_present),
            ("enabled", enabled, m.onboard_control_sensors_enabled),
            ("health", health, m.onboard_control_sensors_health),
        ]
        bit = mavutil.mavlink.MAV_SYS_STATUS_GEOFENCE
        for test in tests:
            (name, want, field) = test
            got = (field & bit) != 0
            if want != got:
                raise NotAchievedException("fence status incorrect; %s want=%u got=%u" %
                                           (name, want, got))

    def wait_circling_point_with_radius(self, loc, want_radius, epsilon=5.0, min_circle_time=5, timeout=120):
        on_radius_start_heading = None
        average_radius = 0.0
        circle_time_start = 0
        done_time = False
        done_angle = False
        tstart = self.get_sim_time()
        while True:
            if self.get_sim_time() - tstart > timeout:
                raise AutoTestTimeoutException("Did not get onto circle")
            here = self.mav.location()
            got_radius = self.get_distance(loc, here)
            average_radius = 0.95*average_radius + 0.05*got_radius
            on_radius = abs(got_radius - want_radius) < epsilon
            m = self.mav.recv_match(type='VFR_HUD', blocking=True)
            heading = m.heading
            on_string = "off"
            got_angle = ""
            if on_radius_start_heading is not None:
                got_angle = "%0.2f" % abs(on_radius_start_heading - heading) # FIXME
                on_string = "on"

            want_angle = 180 # we don't actually get this (angle-substraction issue.  But we get enough...
            self.progress("wait-circling: got-r=%0.2f want-r=%f avg-r=%f %s want-a=%0.1f got-a=%s" %
                          (got_radius, want_radius, average_radius, on_string, want_angle, got_angle))
            if on_radius:
                if on_radius_start_heading is None:
                    on_radius_start_heading = heading
                    average_radius = got_radius
                    circle_time_start = self.get_sim_time()
                    continue
                if abs(on_radius_start_heading - heading) > want_angle: # FIXME
                    done_angle = True
                if self.get_sim_time() - circle_time_start > min_circle_time:
                    done_time = True
                if done_time and done_angle:
                    return
                continue
            if on_radius_start_heading is not None:
                average_radius = 0.0
            on_radius_start_heading = None
            circle_time_start = 0

    def MODE_SWITCH_RESET(self):
        '''test the MODE_SWITCH_RESET auxiliary function'''
        self.set_parameters({
            "RC9_OPTION": 96,
        })

        self.progress("Using RC to change modes")
        self.set_rc(8, 1500)
        self.wait_mode('FBWA')

        self.progress("Killing RC to engage RC failsafe")
        self.set_parameter('SIM_RC_FAIL', 1)
        self.wait_mode('RTL')

        self.progress("Reinstating RC")
        self.set_parameter('SIM_RC_FAIL', 0)

        self.progress("Ensuring we don't automatically revert mode")
        self.delay_sim_time(2)
        self.assert_mode_is('RTL')

        self.progress("Ensuring MODE_SWITCH_RESET switch resets to pre-failsafe mode")
        self.set_rc(9, 2000)
        self.wait_mode('FBWA')

    def FenceStatic(self):
        '''Test Basic Fence Functionality'''
        self.progress("Checking for bizarre healthy-when-not-present-or-enabled")
        self.set_parameter("FENCE_TYPE", 4) # Start by only setting polygon fences, otherwise fence will report present
        self.assert_fence_sys_status(False, False, True)
        self.load_fence("CMAC-fence.txt")
        m = self.mav.recv_match(type='FENCE_STATUS', blocking=True, timeout=2)
        if m is not None:
            raise NotAchievedException("Got FENCE_STATUS unexpectedly")
        self.set_parameter("FENCE_ACTION", 0) # report only
        self.assert_fence_sys_status(True, False, True)
        self.set_parameter("FENCE_ACTION", 1) # RTL
        self.assert_fence_sys_status(True, False, True)
        self.do_fence_enable()
        self.assert_fence_sys_status(True, True, True)
        m = self.assert_receive_message('FENCE_STATUS', timeout=2)
        if m.breach_status:
            raise NotAchievedException("Breached fence unexpectedly (%u)" %
                                       (m.breach_status))
        self.do_fence_disable()
        self.assert_fence_sys_status(True, False, True)
        self.set_parameter("FENCE_ACTION", 1)
        self.assert_fence_sys_status(True, False, True)
        self.set_parameter("FENCE_ACTION", 0)
        self.assert_fence_sys_status(True, False, True)
        self.clear_fence()
        if self.get_parameter("FENCE_TOTAL") != 0:
            raise NotAchievedException("Expected zero points remaining")
        self.assert_fence_sys_status(False, False, True)
        self.progress("Trying to enable fence with no points")
        self.do_fence_enable(want_result=mavutil.mavlink.MAV_RESULT_FAILED)

        # test a rather unfortunate behaviour:
        self.progress("Killing a live fence with fence-clear")
        self.load_fence("CMAC-fence.txt")
        self.set_parameter("FENCE_ACTION", 1) # AC_FENCE_ACTION_RTL_AND_LAND == 1. mavutil.mavlink.FENCE_ACTION_RTL == 4
        self.do_fence_enable()
        self.assert_fence_sys_status(True, True, True)
        self.clear_fence()
        self.wait_sensor_state(mavutil.mavlink.MAV_SYS_STATUS_GEOFENCE, False, False, True)
        if self.get_parameter("FENCE_TOTAL") != 0:
            raise NotAchievedException("Expected zero points remaining")
        self.assert_fence_sys_status(False, False, True)
        self.do_fence_disable()

        # ensure that a fence is present if it is tin can, min alt or max alt
        self.progress("Test other fence types (tin-can, min alt, max alt")
        self.set_parameter("FENCE_TYPE", 1) # max alt
        self.assert_fence_sys_status(True, False, True)
        self.set_parameter("FENCE_TYPE", 8) # min alt
        self.assert_fence_sys_status(True, False, True)
        self.set_parameter("FENCE_TYPE", 2) # tin can
        self.assert_fence_sys_status(True, False, True)

        # Test cannot arm if outside of fence and fence is enabled
        self.progress("Test Arming while vehicle below FENCE_ALT_MIN")
        default_fence_alt_min = self.get_parameter("FENCE_ALT_MIN")
        self.set_parameter("FENCE_ALT_MIN", 50)
        self.set_parameter("FENCE_TYPE", 8) # Enables minimum altitude breaches
        self.do_fence_enable()
        self.delay_sim_time(2) # Allow breach to propagate
        self.assert_fence_enabled()

        self.try_arm(False, "Vehicle breaching Min Alt fence")
        self.do_fence_disable()
        self.set_parameter("FENCE_ALT_MIN", default_fence_alt_min)

        # Test arming outside inclusion zone
        self.progress("Test arming while Vehicle breaching of inclusion zone")
        self.set_parameter("FENCE_TYPE", 4) # Enables polygon fence types
        self.upload_fences_from_locations([(
            mavutil.mavlink.MAV_CMD_NAV_FENCE_POLYGON_VERTEX_INCLUSION, [
                mavutil.location(1.000, 1.000, 0, 0),
                mavutil.location(1.000, 1.001, 0, 0),
                mavutil.location(1.001, 1.001, 0, 0),
                mavutil.location(1.001, 1.000, 0, 0)
            ]
        )])
        self.delay_sim_time(10) # let fence check run so it loads-from-eeprom
        self.do_fence_enable()
        self.assert_fence_enabled()
        self.delay_sim_time(2) # Allow breach to propagate
        self.try_arm(False, "Vehicle breaching Polygon fence")
        self.do_fence_disable()
        self.clear_fence()

        self.progress("Test arming while vehicle inside exclusion zone")
        self.set_parameter("FENCE_TYPE", 4) # Enables polygon fence types
        home_loc = self.mav.location()
        locs = [
            mavutil.location(home_loc.lat - 0.001, home_loc.lng - 0.001, 0, 0),
            mavutil.location(home_loc.lat - 0.001, home_loc.lng + 0.001, 0, 0),
            mavutil.location(home_loc.lat + 0.001, home_loc.lng + 0.001, 0, 0),
            mavutil.location(home_loc.lat + 0.001, home_loc.lng - 0.001, 0, 0),
        ]
        self.upload_fences_from_locations([
            (mavutil.mavlink.MAV_CMD_NAV_FENCE_POLYGON_VERTEX_EXCLUSION, locs),
        ])
        self.delay_sim_time(10) # let fence check run so it loads-from-eeprom
        self.do_fence_enable()
        self.assert_fence_enabled()
        self.delay_sim_time(2) # Allow breach to propagate
        self.try_arm(False, "Vehicle breaching Polygon fence")
        self.do_fence_disable()

    def test_fence_breach_circle_at(self, loc, disable_on_breach=False):
        self.load_fence("CMAC-fence.txt")
        want_radius = 100
        # when ArduPlane is fixed, remove this fudge factor
        REALLY_BAD_FUDGE_FACTOR = 1.16
        expected_radius = REALLY_BAD_FUDGE_FACTOR * want_radius
        self.set_parameters({
            "RTL_RADIUS": want_radius,
            "NAVL1_LIM_BANK": 60,
            "FENCE_ACTION": 1, # AC_FENCE_ACTION_RTL_AND_LAND == 1. mavutil.mavlink.FENCE_ACTION_RTL == 4
        })

        self.wait_ready_to_arm()  # need an origin to load fence

        self.do_fence_enable()
        self.assert_fence_sys_status(True, True, True)

        self.takeoff(alt=45, alt_max=300)

        tstart = self.get_sim_time()
        while True:
            if self.get_sim_time() - tstart > 30:
                raise NotAchievedException("Did not breach fence")
            m = self.assert_receive_message('FENCE_STATUS', timeout=2)
            if m.breach_status == 0:
                continue

            # we've breached; check our state;
            if m.breach_type != mavutil.mavlink.FENCE_BREACH_BOUNDARY:
                raise NotAchievedException("Unexpected breach type %u" %
                                           (m.breach_type,))
            if m.breach_count == 0:
                raise NotAchievedException("Unexpected breach count %u" %
                                           (m.breach_count,))
            self.assert_fence_sys_status(True, True, False)
            break

        self.wait_circling_point_with_radius(loc, expected_radius)
        self.do_fence_disable()
        self.disarm_vehicle(force=True)
        self.reboot_sitl()

    def FenceRTL(self):
        '''Test Fence RTL'''
        self.progress("Testing FENCE_ACTION_RTL no rally point")
        # have to disable the fence once we've breached or we breach
        # it as part of the loiter-at-home!
        self.test_fence_breach_circle_at(self.home_position_as_mav_location())

    def FenceRTLRally(self):
        '''Test Fence RTL Rally'''
        self.progress("Testing FENCE_ACTION_RTL with rally point")

        self.wait_ready_to_arm()
        loc = self.home_relative_loc_ne(50, -50)
        self.upload_rally_points_from_locations([loc])
        self.test_fence_breach_circle_at(loc)

    def FenceRetRally(self):
        """ Tests the FENCE_RET_RALLY flag, either returning to fence return point,
            or rally point """
        target_system = 1
        target_component = 1
        self.progress("Testing FENCE_ACTION_RTL with fence rally point")

        self.wait_ready_to_arm()

        # Grab a location for fence return point, and upload it.
        fence_loc = self.home_position_as_mav_location()
        self.location_offset_ne(fence_loc, 50, 50)
        fence_return_mission_items = [
            self.mav.mav.mission_item_int_encode(
                target_system,
                target_component,
                0, # seq
                mavutil.mavlink.MAV_FRAME_GLOBAL_INT,
                mavutil.mavlink.MAV_CMD_NAV_FENCE_RETURN_POINT,
                0, # current
                0, # autocontinue
                0, # p1
                0, # p2
                0, # p3
                0, # p4
                int(fence_loc.lat * 1e7), # latitude
                int(fence_loc.lng * 1e7), # longitude
                0, # altitude'''
Dive ArduSub in SITL

Depth of water is 50m, the ground is flat
Parameters are in-code defaults plus default_params/sub.parm

AP_FLAKE8_CLEAN
'''

from __future__ import print_function
import os
import sys

from pymavlink import mavutil

import vehicle_test_suite
from vehicle_test_suite import NotAchievedException
from vehicle_test_suite import AutoTestTimeoutException
from vehicle_test_suite import PreconditionFailedException

if sys.version_info[0] < 3:
    ConnectionResetError = AutoTestTimeoutException

# get location of scripts
testdir = os.path.dirname(os.path.realpath(__file__))

SITL_START_LOCATION = mavutil.location(33.810313, -118.393867, 0, 185)


class Joystick():
    Pitch = 1
    Roll = 2
    Throttle = 3
    Yaw = 4
    Forward = 5
    Lateral = 6


# Values for EK3_MAG_CAL
class MagCal():
    WHEN_FLYING = 0
    WHEN_MANOEUVRING = 1
    NEVER = 2
    AFTER_FIRST_CLIMB = 3
    ALWAYS = 4


# Values for XKFS.MAG_FUSION
class MagFuseSel():
    NOT_FUSING = 0
    FUSE_YAW = 1
    FUSE_MAG = 2


class AutoTestSub(vehicle_test_suite.TestSuite):
    @staticmethod
    def get_not_armable_mode_list():
        return []

    @staticmethod
    def get_not_disarmed_settable_modes_list():
        return []

    @staticmethod
    def get_no_position_not_settable_modes_list():
        return ["AUTO", "GUIDED", "CIRCLE", "POSHOLD"]

    @staticmethod
    def get_position_armable_modes_list():
        return []

    @staticmethod
    def get_normal_armable_modes_list():
        return ["ACRO", "ALT_HOLD", "MANUAL", "STABILIZE", "SURFACE"]

    def log_name(self):
        return "ArduSub"

    def default_speedup(self):
        '''Sub seems to be race-free'''
        return 100

    def test_filepath(self):
        return os.path.realpath(__file__)

    def set_current_test_name(self, name):
        self.current_test_name_directory = "ArduSub_Tests/" + name + "/"

    def default_mode(self):
        return 'MANUAL'

    def sitl_start_location(self):
        return SITL_START_LOCATION

    def default_frame(self):
        return 'vectored'

    def is_sub(self):
        return True

    def watch_altitude_maintained(self, delta=0.3, timeout=5.0):
        """Watch and wait for the actual altitude to be maintained

        Keyword Arguments:
            delta {float} -- Maximum altitude range to be allowed from actual point (default: {0.5})
            timeout {float} -- Timeout time in simulation seconds (default: {5.0})

        Raises:
            NotAchievedException: Exception when altitude fails to hold inside the time and
                altitude range
        """
        tstart = self.get_sim_time_cached()
        previous_altitude = self.mav.recv_match(type='VFR_HUD', blocking=True).alt
        self.progress('Altitude to be watched: %f' % (previous_altitude))
        while True:
            m = self.mav.recv_match(type='VFR_HUD', blocking=True)
            if self.get_sim_time_cached() - tstart > timeout:
                self.progress('Altitude hold done: %f' % (previous_altitude))
                return
            if abs(m.alt - previous_altitude) > delta:
                raise NotAchievedException(
                    "Altitude not maintained: want %.2f (+/- %.2f) got=%.2f" %
                    (previous_altitude, delta, m.alt))

    def AltitudeHold(self):
        """Test ALT_HOLD mode"""
        self.wait_ready_to_arm()
        self.arm_vehicle()
        self.change_mode('ALT_HOLD')

        msg = self.mav.recv_match(type='GLOBAL_POSITION_INT', blocking=True, timeout=5)
        if msg is None:
            raise NotAchievedException("Did not get GLOBAL_POSITION_INT")
        pwm = 1300
        if msg.relative_alt/1000.0 < -6.0:
            # need to go up, not down!
            pwm = 1700
        self.set_rc(Joystick.Throttle, pwm)
        self.wait_altitude(altitude_min=-6, altitude_max=-5)
        self.set_rc(Joystick.Throttle, 1500)

        # let the vehicle settle (momentum / stopping point shenanigans....)
        self.delay_sim_time(1)

        self.watch_altitude_maintained()

        self.set_rc(Joystick.Throttle, 1000)
        self.wait_altitude(altitude_min=-20, altitude_max=-19)
        self.set_rc(Joystick.Throttle, 1500)

        # let the vehicle settle (momentum / stopping point shenanigans....)
        self.delay_sim_time(1)

        self.watch_altitude_maintained()

        self.set_rc(Joystick.Throttle, 1900)
        self.wait_altitude(altitude_min=-14, altitude_max=-13)
        self.set_rc(Joystick.Throttle, 1500)

        # let the vehicle settle (momentum / stopping point shenanigans....)
        self.delay_sim_time(1)

        self.watch_altitude_maintained()

        self.set_rc(Joystick.Throttle, 1900)
        self.wait_altitude(altitude_min=-5, altitude_max=-4)
        self.set_rc(Joystick.Throttle, 1500)

        # let the vehicle settle (momentum / stopping point shenanigans....)
        self.delay_sim_time(1)
        self.watch_altitude_maintained()

        # Make sure the code can handle buoyancy changes
        self.set_parameter("SIM_BUOYANCY", 10)
        self.watch_altitude_maintained()
        self.set_parameter("SIM_BUOYANCY", -10)
        self.watch_altitude_maintained()

        # Make sure that the ROV will dive with a small input down even if there is a 10N buoyancy force upwards
        self.set_parameter("SIM_BUOYANCY", 10)
        self.set_rc(Joystick.Throttle, 1350)
        self.wait_altitude(altitude_min=-6, altitude_max=-5.5)

        self.set_rc(Joystick.Throttle, 1500)
        self.watch_altitude_maintained()
        self.disarm_vehicle()

    def RngfndQuality(self):
        """Check lua Range Finder quality information flow"""
        self.context_push()
        self.context_collect('STATUSTEXT')

        ex = None
        try:
            self.set_parameters({
                "SCR_ENABLE": 1,
                "RNGFND1_TYPE": 36,
                "RNGFND1_ORIENT": 25,
                "RNGFND1_MIN_CM": 10,
                "RNGFND1_MAX_CM": 5000,
            })

            self.install_example_script_context("rangefinder_quality_test.lua")

            # These string must match those sent by the lua test script.
            complete_str = "#complete#"
            failure_str = "!!failure!!"

            self.reboot_sitl()

            self.wait_statustext(complete_str, timeout=20, check_context=True)
            found_failure = self.statustext_in_collections(failure_str)

            if found_failure is not None:
                raise NotAchievedException("RngfndQuality test failed: " + found_failure.text)

        except Exception as e:
            self.print_exception_caught(e)
            ex = e

        self.context_pop()

        # restart SITL RF driver
        self.reboot_sitl()

        if ex:
            raise ex

    def watch_distance_maintained(self, delta=0.3, timeout=5.0):
        """Watch and wait for the rangefinder reading to be maintained"""
        tstart = self.get_sim_time_cached()
        previous_distance = self.mav.recv_match(type='RANGEFINDER', blocking=True).distance
        self.progress('Distance to be watched: %.2f' % previous_distance)
        while True:
            m = self.mav.recv_match(type='RANGEFINDER', blocking=True)
            if self.get_sim_time_cached() - tstart > timeout:
                self.progress('Distance hold done: %f' % previous_distance)
                return
            if abs(m.distance - previous_distance) > delta:
                raise NotAchievedException(
                    "Distance not maintained: want %.2f (+/- %.2f) got=%.2f" %
                    (previous_distance, delta, m.distance))

    def Surftrak(self):
        """Test SURFTRAK mode"""

        if self.get_parameter('RNGFND1_MAX_CM') != 3000.0:
            raise PreconditionFailedException("RNGFND1_MAX_CM is not %g" % 3000.0)

        # Something closer to Bar30 noise
        self.context_push()
        self.set_parameter("SIM_BARO_RND", 0.01)

        self.wait_ready_to_arm()
        self.arm_vehicle()
        self.change_mode('MANUAL')

        # Dive to -5m, outside of rangefinder range, will act like ALT_HOLD
        pwm = 1300 if self.get_altitude(relative=True) > -6 else 1700
        self.set_rc(Joystick.Throttle, pwm)
        self.wait_altitude(altitude_min=-6, altitude_max=-5, relative=False, timeout=60)
        self.set_rc(Joystick.Throttle, 1500)
        self.delay_sim_time(1)
        self.context_collect('STATUSTEXT')
        self.change_mode(21)
        self.wait_statustext('waiting for a rangefinder reading', check_context=True)
        self.context_clear_collection('STATUSTEXT')
        self.watch_altitude_maintained()

        # Move into range, should set a rangefinder target and maintain it
        self.set_rc(Joystick.Throttle, 1300)
        self.wait_altitude(altitude_min=-26, altitude_max=-25, relative=False, timeout=60)
        self.set_rc(Joystick.Throttle, 1500)
        self.delay_sim_time(4)
        self.wait_statustext('rangefinder target is', check_context=True)
        self.context_clear_collection('STATUSTEXT')
        self.watch_distance_maintained()

        # Move a few meters, should apply a delta and maintain the new rangefinder target
        self.set_rc(Joystick.Throttle, 1300)
        self.wait_altitude(altitude_min=-31, altitude_max=-30, relative=False, timeout=60)
        self.set_rc(Joystick.Throttle, 1500)
        self.delay_sim_time(4)
        self.wait_statustext('rangefinder target is', check_context=True)
        self.watch_distance_maintained()

        self.disarm_vehicle()
        self.context_pop()

    def prepare_synthetic_seafloor_test(self, sea_floor_depth):
        self.set_parameters({
            "SCR_ENABLE": 1,
            "RNGFND1_TYPE": 36,
            "RNGFND1_ORIENT": 25,
            "RNGFND1_MIN_CM": 10,
            "RNGFND1_MAX_CM": 3000,
            "SCR_USER1": 2,                 # Configuration bundle
            "SCR_USER2": sea_floor_depth,   # Depth in meters
            "SCR_USER3": 101,               # Output log records
        })

        self.install_example_script_context("sub_test_synthetic_seafloor.lua")

        # Reboot to enable scripting.
        self.reboot_sitl()
        self.set_rc_default()
        self.wait_ready_to_arm()

    def watch_true_distance_maintained(self, match_distance, delta=0.3, timeout=5.0, final_waypoint=0):
        """Watch and wait for the rangefinder reading to be maintained"""

        def get_true_distance():
            """Return the True distance from the simulated range finder"""
            m_true = self.mav.recv_match(type='STATUSTEXT', blocking=True, timeout=3.0)
            if m_true is None:
                return m_true
            idx_tr = m_true.text.find('#TR#')
            if idx_tr < 0:
                return None
            return float(m_true.text[(idx_tr+4):(idx_tr+12)])

        tstart = self.get_sim_time_cached()
        self.progress('Distance to be watched: %.2f (+/- %.2f)' % (match_distance, delta))
        max_delta = 0.0

        while True:
            timed_out = self.get_sim_time_cached() - tstart > timeout
            # If final_waypoint>0 then timeout is failure, otherwise success
            if timed_out and final_waypoint > 0:
                raise NotAchievedException(
                    "Mission not complete: want waypoint %i, only made it to waypoint %i" %
                    (final_waypoint, self.mav.waypoint_current()))
            if timed_out:
                self.progress('Distance hold done. Max delta:%.2fm' % max_delta)
                return

            true_distance = get_true_distance()
            if true_distance is None:
                continue
            match_delta = abs(true_distance - match_distance)
            if match_delta > max_delta:
                max_delta = match_delta
            if match_delta > delta:
                raise NotAchievedException(
                    "Distance not maintained: want %.2f (+/- %.2f) got=%.2f (%.2f)" %
                    (match_distance, delta, true_distance, match_delta))
            if final_waypoint > 0:
                if self.mav.waypoint_current() >= final_waypoint:
                    self.progress('Distance hold during mission done. Max delta:%.2fm' % max_delta)
                    return

    def SimTerrainSurftrak(self):
        """Move at a constant height above synthetic sea floor"""

        sea_floor_depth = 50    # Depth of sea floor at location of test
        match_distance = 15     # Desired sub distance from sea floor
        start_altitude = -sea_floor_depth+match_distance
        end_altitude = start_altitude - 10
        validation_delta = 1.5  # Largest allowed distance between sub height and desired height

        self.context_push()
        self.prepare_synthetic_seafloor_test(sea_floor_depth)
        self.change_mode('MANUAL')
        self.arm_vehicle()

        # Dive to match_distance off the bottom in preparation for the mission
        pwm = 1300 if self.get_altitude(relative=True) > start_altitude else 1700
        self.set_rc(Joystick.Throttle, pwm)
        self.wait_altitude(altitude_min=start_altitude-1, altitude_max=start_altitude, relative=False, timeout=120)
        self.set_rc(Joystick.Throttle, 1500)
        self.delay_sim_time(1)

        # Turn on surftrak and move around
        self.change_mode(21)

        # Go south over the ridge.
        self.reach_heading_manual(180)
        self.set_rc(Joystick.Forward, 1650)
        self.watch_true_distance_maintained(match_distance, delta=validation_delta, timeout=60)
        self.set_rc(Joystick.Forward, 1500)

        # Shift west a bit
        self.reach_heading_manual(270)
        self.set_rc(Joystick.Forward, 1650)
        self.watch_true_distance_maintained(match_distance, delta=validation_delta, timeout=5)
        self.set_rc(Joystick.Forward, 1500)

        # Go south over the plateau
        self.reach_heading_manual(180)
        self.set_rc(Joystick.Forward, 1650)
        self.watch_true_distance_maintained(match_distance, delta=validation_delta, timeout=60)

        # The mission ends at end_altitude. Do a check to insure that the sub is at this altitude
        self.wait_altitude(altitude_min=end_altitude-validation_delta/2, altitude_max=end_altitude+validation_delta/2,
                           relative=False, timeout=1)

        self.set_rc(Joystick.Forward, 1500)

        self.disarm_vehicle()
        self.context_pop()
        self.reboot_sitl()  # e.g. revert rangefinder configuration

    def SimTerrainMission(self):
        """Mission at a constant height above synthetic sea floor"""

        sea_floor_depth = 50    # Depth of sea floor at location of test
        match_distance = 15     # Desired sub distance from sea floor
        start_altitude = -sea_floor_depth+match_distance
        end_altitude = start_altitude - 10
        validation_delta = 1.5  # Largest allowed distance between sub height and desired height

        self.context_push()
        self.prepare_synthetic_seafloor_test(sea_floor_depth)

        # The synthetic seafloor has an east-west ridge south of the sub.
        # The mission contained in terrain_mission.txt instructs the sub
        # to remain at 15m above the seafloor and travel south over the
        # ridge. Then the sub moves west and travels north over the ridge.
        filename = "terrain_mission.txt"
        self.load_mission(filename)

        self.change_mode('MANUAL')
        self.arm_vehicle()

        # Dive to match_distance off the bottom in preparation for the mission
        pwm = 1300 if self.get_altitude(relative=True) > start_altitude else 1700
        self.set_rc(Joystick.Throttle, pwm)
        self.wait_altitude(altitude_min=start_altitude-1, altitude_max=start_altitude, relative=False, timeout=120)
        self.set_rc(Joystick.Throttle, 1500)
        self.delay_sim_time(1)

        self.change_mode('AUTO')
        self.watch_true_distance_maintained(match_distance, delta=validation_delta, timeout=500.0, final_waypoint=4)

        # The mission ends at end_altitude. Do a check to insure that the sub is at this altitude.
        self.wait_altitude(altitude_min=end_altitude-validation_delta/2, altitude_max=end_altitude+validation_delta/2,
                           relative=False, timeout=1)

        self.disarm_vehicle()
        self.context_pop()
        self.reboot_sitl()  # e.g. revert rangefinder configuration

    def ModeChanges(self, delta=0.2):
        """Check if alternating between ALTHOLD, STABILIZE, POSHOLD and SURFTRAK (mode 21) affects altitude"""
        self.wait_ready_to_arm()
        self.arm_vehicle()
        # zero buoyancy and no baro noise
        self.set_parameter("SIM_BUOYANCY", 0)
        self.set_parameter("SIM_BARO_RND", 0)
        # dive a bit to make sure we are not surfaced
        self.change_mode('STABILIZE')
        self.set_rc(Joystick.Throttle, 1350)
        self.delay_sim_time(10)
        self.set_rc(Joystick.Throttle, 1500)
        self.delay_sim_time(3)
        # start the test itself, go through some modes and check if anything changes
        previous_altitude = self.mav.recv_match(type='VFR_HUD', blocking=True).alt
        self.change_mode('ALT_HOLD')
        self.delay_sim_time(2)
        self.change_mode('POSHOLD')
        self.delay_sim_time(2)
        self.change_mode('STABILIZE')
        self.delay_sim_time(2)
        self.change_mode(21)
        self.delay_sim_time(2)
        self.change_mode('ALT_HOLD')
        self.delay_sim_time(2)
        self.change_mode('STABILIZE')
        self.delay_sim_time(2)
        self.change_mode('ALT_HOLD')
        self.delay_sim_time(2)
        self.change_mode(21)
        self.delay_sim_time(2)
        self.change_mode('MANUAL')
        self.disarm_vehicle()
        final_altitude = self.mav.recv_match(type='VFR_HUD', blocking=True).alt
        if abs(previous_altitude - final_altitude) > delta:
            raise NotAchievedException(
                "Changing modes affected depth with no throttle input!, started at {}, ended at {}"
                .format(previous_altitude, final_altitude)
            )

    def PositionHold(self):
        """Test POSHOLD mode"""
        self.wait_ready_to_arm()
        self.arm_vehicle()
        # point North
        self.reach_heading_manual(0)
        self.change_mode('POSHOLD')

        # dive a little
        self.set_rc(Joystick.Throttle, 1300)
        self.delay_sim_time(3)
        self.set_rc(Joystick.Throttle, 1500)
        self.delay_sim_time(2)

        # Save starting point
        msg = self.mav.recv_match(type='GLOBAL_POSITION_INT', blocking=True, timeout=5)
        if msg is None:
            raise NotAchievedException("Did not get GLOBAL_POSITION_INT")
        start_pos = self.mav.location()
        # Hold in perfect conditions
        self.progress("Testing position hold in perfect conditions")
        self.delay_sim_time(10)
        distance_m = self.get_distance(start_pos, self.mav.location())
        if distance_m > 1:
            raise NotAchievedException("Position Hold was unable to keep position in calm waters within 1 meter after 10 seconds, drifted {} meters".format(distance_m))  # noqa

        # Hold in 1 m/s current
        self.progress("Testing position hold in current")
        self.set_parameter("SIM_WIND_SPD", 1)
        self.set_parameter("SIM_WIND_T", 1)
        self.delay_sim_time(10)
        distance_m = self.get_distance(start_pos, self.mav.location())
        if distance_m > 1:
            raise NotAchievedException("Position Hold was unable to keep position in 1m/s current within 1 meter after 10 seconds, drifted {} meters".format(distance_m))  # noqa

        # Move forward slowly in 1 m/s current
        start_pos = self.mav.location()
        self.progress("Testing moving forward in position hold in 1m/s current")
        self.set_rc(Joystick.Forward, 1600)
        self.delay_sim_time(10)
        distance_m = self.get_distance(start_pos, self.mav.location())
        bearing = self.get_bearing(start_pos, self.mav.location())
        if distance_m < 2 or (bearing > 30 and bearing < 330):
            raise NotAchievedException("Position Hold was unable to move north 2 meters, moved {} at {} degrees instead".format(distance_m, bearing))  # noqa
        self.disarm_vehicle()

    def MotorThrustHoverParameterIgnore(self):
        """Test if we are ignoring MOT_THST_HOVER parameter"""

        # Test default parameter value
        mot_thst_hover_value = self.get_parameter("MOT_THST_HOVER")
        if mot_thst_hover_value != 0.5:
            raise NotAchievedException("Unexpected default MOT_THST_HOVER parameter value {}".format(mot_thst_hover_value))

        # Test if parameter is being ignored
        for value in [0.25, 0.75]:
            self.set_parameter("MOT_THST_HOVER", value)
            self.AltitudeHold()

    def DiveManual(self):
        '''Dive manual'''
        self.wait_ready_to_arm()
        self.arm_vehicle()

        self.set_rc(Joystick.Throttle, 1600)
        self.set_rc(Joystick.Forward, 1600)
        self.set_rc(Joystick.Lateral, 1550)

        self.wait_distance(50, accuracy=7, timeout=200)
        self.set_rc(Joystick.Yaw, 1550)

        self.wait_heading(0)
        self.set_rc(Joystick.Yaw, 1500)

        self.wait_distance(50, accuracy=7, timeout=100)
        self.set_rc(Joystick.Yaw, 1550)

        self.wait_heading(0)
        self.set_rc(Joystick.Yaw, 1500)
        self.set_rc(Joystick.Forward, 1500)
        self.set_rc(Joystick.Lateral, 1100)

        self.wait_distance(75, accuracy=7, timeout=100)
        self.set_rc_default()

        self.disarm_vehicle()
        self.progress("Manual dive OK")

        m = self.assert_receive_message('SCALED_PRESSURE3')

        # Note this temperature matches the output of the Atmospheric Model for Air currently
        # And should be within 1 deg C of 40 degC
        if (m.temperature < 3900) or (4100 < m.temperature):
            raise NotAchievedException("Did not get correct TSYS01 temperature: Got %f" % m.temperature)

    def DiveMission(self):
        '''Dive mission'''
        filename = "sub_mission.txt"
        self.progress("Executing mission %s" % filename)
        self.load_mission(filename)
        self.set_rc_default()

        self.arm_vehicle()

        self.change_mode('AUTO')

        self.wait_waypoint(1, 5, max_dist=5)

        self.disarm_vehicle()

        self.progress("Mission OK")

    def GripperMission(self):
        '''Test gripper mission items'''
        self.load_mission("sub-gripper-mission.txt")
        self.wait_ready_to_arm()
        self.arm_vehicle()
        self.change_mode('AUTO')
        self.wait_waypoint(1, 2, max_dist=5)
        self.wait_statustext("Gripper Grabbed", timeout=60)
        self.wait_waypoint(1, 4, max_dist=5)
        self.wait_statustext("Gripper Released", timeout=60)
        self.wait_waypoint(1, 6, max_dist=5)
        self.disarm_vehicle()

    def SET_POSITION_TARGET_GLOBAL_INT(self):
        '''Move vehicle using SET_POSITION_TARGET_GLOBAL_INT'''
        self.change_mode('GUIDED')
        self.wait_ready_to_arm()
        self.arm_vehicle()

        startpos = self.mav.recv_match(type='GLOBAL_POSITION_INT',
                                       blocking=True)

        lat = 5
        lon = 5
        alt = -10

        # send a position-control command
        self.mav.mav.set_position_target_global_int_send(
            0, # timestamp
            1, # target system_id
            1, # target component id
            mavutil.mavlink.MAV_FRAME_GLOBAL_RELATIVE_ALT_INT,
            0b1111111111111000, # mask specifying use-only-lat-lon-alt
            lat, # lat
            lon, # lon
            alt, # alt
            0, # vx
            0, # vy
            0, # vz
            0, # afx
            0, # afy
            0, # afz
            0, # yaw
            0, # yawrate
        )

        tstart = self.get_sim_time()
        while True:
            if self.get_sim_time_cached() - tstart > 200:
                raise NotAchievedException("Did not move far enough")
            pos = self.mav.recv_match(type='GLOBAL_POSITION_INT',
                                      blocking=True)
            delta = self.get_distance_int(startpos, pos)
            self.progress("delta=%f (want >10)" % delta)
            if delta > 10:
                break
        self.change_mode('MANUAL')
        self.disarm_vehicle()

    def DoubleCircle(self):
        '''Test entering circle twice'''
        