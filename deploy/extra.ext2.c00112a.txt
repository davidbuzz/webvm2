ory.
    float lat;               /// Latitude.
    float lon;               /// Longitude.
    union
    {
        sg_svr_surface_t surface;   /// Surface SVR data.
        sg_svr_airborne_t airborne; /// Airborne SVR data.
    };
} sg_svr_t;

typedef enum
{
    msrTypeV0,
    msrTypeV1Airborne,
    msrTypeV1Surface,
    msrTypeV2Airborne,
    msrTypeV2Surface
} sg_msr_type_t;

typedef struct
{
    uint8_t reserved : 2;
    bool priority : 1;
    bool sil : 1;
    bool nacv : 1;
    bool nacp : 1;
    bool opmode : 1;
    bool capcodes : 1;
} sg_msr_validity_t;

typedef enum
{
    adsbVerDO260,
    adsbVerDO260A,
    adsbVerDO260B
} sg_adsb_version_t;

typedef enum
{
    adsbUnknown,
    adsbLight,
    adsbSmall = 0x3,
    adsbLarge = 0x5,
    adsbHighVortex,
    adsbHeavy,
    adsbPerformance,
    adsbRotorcraft = 0x0A,
    adsbGlider,
    adsbAir,
    adsbUnmaned,
    adsbSpace,
    adsbUltralight,
    adsbParachutist,
    adsbVehicle_emg = 0x14,
    adsbVehicle_serv,
    adsbObsticlePoint,
    adsbObsticleCluster,
    adsbObsticleLinear
} sg_adsb_emitter_t;

typedef enum
{
    priNone,
    priGeneral,
    priMedical,
    priFuel,
    priComm,
    priUnlawful,
    priDowned
} sg_priority_t;

typedef enum
{
    tcrNone,
    tcrSingle,
    tcrMultiple
} sg_tcr_t;

typedef struct
{
    bool b2low : 1;
    bool uat : 1;
    bool arv : 1;
    bool tsr : 1;
    bool adsb : 1;
    bool tcas : 1;
    sg_tcr_t tcr;
} sg_capability_t;

typedef enum
{
    gpsLonNodata,
    gpsLonSensorSupplied,
    gpsLon2m,
    gpsLon4m,
    gpsLon6m,
    gpsLon8m,
    gpsLon10m,
    gpsLon12m,
    gpsLon14m,
    gpsLon16m,
    gpsLon18m,
    gpsLon20m,
    gpsLon22m,
    gpsLon24m,
    gpsLon26m,
    gpsLon28m,
    gpsLon30m,
    gpsLon32m,
    gpsLon34m,
    gpsLon36m,
    gpsLon38m,
    gpsLon40m,
    gpsLon42m,
    gpsLon44m,
    gpsLon46m,
    gpsLon48m,
    gpsLon50m,
    gpsLon52m,
    gpsLon54m,
    gpsLon56m,
    gpsLon58m,
    gpsLon60m
} sg_gps_lonofs_t;

typedef enum
{
    gpslatNodata,
    gpslatLeft2m,
    gpslatLeft4m,
    gpslatLeft6m,
    gpslatRight0m,
    gpslatRight2m,
    gpslatRight4m,
    gpslatRight6m,
} sg_gps_latofs_t;

typedef struct
{
    bool gpsLatFmt;
    sg_gps_latofs_t gpsLatOfs;
    bool gpsLonFmt;
    sg_gps_lonofs_t gpsLonOfs;
    bool tcasRA : 1;
    bool ident : 1;
    bool singleAnt : 1;
} sg_adsb_opmode_t;

typedef enum
{
    gvaUnknown,
    gvaLT150m,
    gvaLT45m
} sg_gva_t;

typedef enum
{
    nicGolham,
    nicNonGilham
} sg_nicbaro_t;

typedef enum
{
    svsilUnknown,
    svsilPow3,
    svsilPow5,
    svsilPow7
} sg_svsil_t;

typedef struct
{
    sg_nacp_t nacp;
    sg_nacv_t nacv;
    sg_sda_t sda;
    bool silSupp;
    sg_svsil_t sil;
    sg_gva_t gva;
    sg_nicbaro_t nicBaro;
} sg_sv_qual_t;

typedef enum
{
    trackTrueNorth,
    trackMagNorth,
    headingTrueNorth,
    headingMagNorth
} sg_trackheading_t;

typedef enum
{
    vrateBaroAlt,
    vrateGeoAlt
} sg_vratetype_t;

/**
 * The XPDR ADS-B mode status report Message.
 * Host --> XPDR.
 *
 * @note The time of applicability values are based on the MX system clock that starts
 * at 0 on power up. The time is the floating point number that is the seconds since
 * power up. The time number rolls over at 512.0.
 */
typedef struct
{
    sg_msr_type_t type; /// Report type.

    union
    {
        uint8_t flags;
        sg_msr_validity_t validity; /// Field validity flags.
    };

    uint32_t addr;           /// Participant address.
    sg_addr_type_t addrType; /// Participant address type.

    float toa;
    sg_adsb_version_t version;
    char callsign[9];
    sg_adsb_emitter_t emitter;
    sg_size_t size;
    sg_priority_t priority;
    sg_capability_t capability;
    sg_adsb_opmode_t opMode;
    sg_sv_qual_t svQuality;
    sg_trackheading_t trackHeading;
    sg_vratetype_t vrateType;
} sg_msr_t;

/**
 * Convert install message struct to the raw buffer format.
 *
 * @param[out] buffer An empty buffer to contain the raw install message.
 * @param[in]  stl    The install message struct with fields populated.
 * @param[in]  msgId  The sequence number for the message.
 *
 * @return true if successful or false on failure.
 *
 * @warning data in stl parameter must be pre-validated.
 */
bool sgEncodeInstall(uint8_t *buffer, sg_install_t *stl, uint8_t msgId);

/**
 * Convert flight identification struct to the raw buffer format.
 *
 * @param[out] buffer An empty buffer to contain the raw flight identification message.
 * @param[in]  id     The flight id struct with fields populated.
 * @param[in]  msgId  The sequence number for the message.
 *
 * @return true if successful or false on failure.
 *
 * @warning data in id parameter must be pre-validated.
 */
bool sgEncodeFlightId(uint8_t *buffer, sg_flightid_t *id, uint8_t msgId);

/**
 * Convert operating message struct to the raw buffer format.
 *
 * @param[out] buffer An empty buffer to contain the raw operating message.
 * @param[in]  op     The operating message struct with fields populated.
 * @param[in]  msgId  The sequence number for the message.
 *
 * @return true if successful or false on failure.
 *
 * @warning data in op parameter must be pre-validated.
 */
bool sgEncodeOperating(uint8_t *buffer, sg_operating_t *op, uint8_t msgId);

/* TODO: Create GPS helper functions to convert other data types --> char buffers */

/**
 * Convert GPS message struct to the raw buffer format.
 *
 * @param[out] buffer An empty buffer to contain the raw GPS message.
 * @param[in]  gps    The GPS message struct with fields populated.
 * @param[in]  msgId  The sequence number for the message.
 *
 * @return true if successful or false on failure.
 *
 * @warning data in gps parameter must be pre-validated.
 */
bool sgEncodeGPS(uint8_t *buffer, sg_gps_t *gps, uint8_t msgId);

/**
 * Convert data request message struct to the raw buffer format.
 *
 * @param[out] buffer An empty buffer to contain the raw target request message.
 * @param[in]  data   The data request message struct with fields populated.
 * @param[in]  msgId  The sequence number for the message.
 *
 * @return true if successful or false on failure.
 *
 * @warning data in data parameter must be pre-validated.
 */
bool sgEncodeDataReq(uint8_t *buffer, sg_datareq_t *data, uint8_t msgId);

/**
 * Convert target request message struct to the raw buffer format.
 *
 * @param[out] buffer An empty buffer to contain the raw target request message.
 * @param[in]  tgt    The target request message struct with fields populated.
 * @param[in]  msgId  The sequence number for the message.
 *
 * @return true if successful or false on failure.
 *
 * @warning data in tgt parameter must be pre-validated.
 */
bool sgEncodeTargetReq(uint8_t *buffer, sg_targetreq_t *tgt, uint8_t msgId);

/**
 * Process the ACK message response from the transponder.
 *
 * @param[in]  buffer The raw ACK message buffer.
 * @param[out] ack    The parsed message results.
 *
 * @return true if successful or false on failure.
 */
bool sgDecodeAck(uint8_t *buffer, sg_ack_t *ack);

/**
 * Process the Install message response from the transponder.
 *
 * @param[in]  buffer The raw Install message buffer.
 * @param[out] stl    The parsed message results.
 *
 * @return true if successful or false on failure.
 */
bool sgDecodeInstall(uint8_t *buffer, sg_install_t *stl);

/**
 * Process the Flight ID message response from the transponder.
 *
 * @param[in]  buffer The raw Flight ID message buffer.
 * @param[out] id     The parsed message results.
 *
 * @return true if successful or false on failure.
 */
bool sgDecodeFlightId(uint8_t *buffer, sg_flightid_t *id);

/**
 * Process the state vector report message.
 *
 * @param[in]  buffer The raw SVR message buffer.
 * @param[out] svr    The parsed SVR message.
 *
 * @return true if successful or false on failure.
 */
bool sgDecodeSVR(uint8_t *buffer, sg_svr_t *svr);

/**
 * Process the mode status report message.
 *
 * @param buffer The raw MSR message buffer.
 * @param msr    The parsed MSR message.
 *
 * @return true if successful or false on failure.
 */
bool sgDecodeMSR(uint8_t *buffer, sg_msr_t *msr);

#endif /* SG_H */
                                                   /**
 * @copyright Copyright (c) 2021 Sagetech, Inc. All rights reserved.
 *
 * @file   sgDecodeAck.c
 * @author jimb
 *
 * @date   Feb 10, 2021
 *
 * This file receives a raw Acknowledge message buffer and
 * parses the payload into a data struct.
 */

#include <string.h>
#include <stdbool.h>
#include <math.h>

#include "sg.h"
#include "sgUtil.h"

#define SG_ACK_XPNDR_FAIL 0x01
#define SG_ACK_SYSTEM_FAIL 0x02
#define SG_ACK_CRYPTO_FAIL 0x04
#define SG_ACK_WOW 0x08
#define SG_ACK_MAINT 0x10
#define SG_ACK_ALT_SOURCE 0x20
#define SG_ACK_OP_MODE 0xC0

typedef struct __attribute__((packed))
{
    uint8_t start;
    uint8_t type;
    uint8_t id;
    uint8_t payloadLen;
    uint8_t ackType;
    uint8_t ackId;
    uint8_t state;
    uint8_t alt[3];
    uint8_t checksum;
} ack_t;

/*
 * Documented in the header file.
 */
bool sgDecodeAck(uint8_t *buffer, sg_ack_t *ack)
{
    ack_t sgAck;
    memcpy(&sgAck, buffer, sizeof(ack_t));

    ack->ackType = sgAck.ackType;
    ack->ackId = sgAck.ackId;
    ack->failXpdr = (sgAck.state & SG_ACK_XPNDR_FAIL) > 0;
    ack->failSystem = (sgAck.state & SG_ACK_SYSTEM_FAIL) > 0;
    ack->failCrypto = (sgAck.state & SG_ACK_CRYPTO_FAIL) > 0;
    ack->wow = (sgAck.state & SG_ACK_WOW) > 0;
    ack->maint = (sgAck.state & SG_ACK_MAINT) > 0;
    ack->isHostAlt = (sgAck.state & SG_ACK_ALT_SOURCE) > 0;
    ack->opMode = (sgAck.state & SG_ACK_OP_MODE) >> 6;

    int32_t int24 = toInt32(sgAck.alt);

    // Bitmask altitude field to determine if alt = invalid
    if ((int24 & 0x00FFFFFF) == 0x00800000)
    {
        ack->alt = 0;
        ack->altValid = false;
    }
    else
    {
        ack->alt = int24;
        ack->altValid = true;
    }

    return true;
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       /**
 * @copyright Copyright (c) 2021 Sagetech, Inc. All rights reserved.
 *
 * @file sgDecodeFlightId.c
 * @author Jacob.Garrison
 *
 * @date Mar 10, 2021
 *
 */

#include <string.h>

#include "sg.h"
#include "sgUtil.h"

#define SG_ID_LEN 8 // The number of bytes in the flight id field

typedef struct __attribute__((packed))
{
    uint8_t start;
    uint8_t type;
    uint8_t id;
    uint8_t payloadLen;
    char flightId[SG_ID_LEN];
    uint8_t rsvd[4];
    uint8_t checksum;
} flightid_t;

/*
 * Documented in the header file.
 */
bool sgDecodeFlightId(uint8_t *buffer, sg_flightid_t *id)
{
    flightid_t sgId;
    memcpy(&sgId, buffer, sizeof(flightid_t));

    strcpy(id->flightId, sgId.flightId);
    memset(&id->flightId[SG_ID_LEN], '\0', 1); // Ensure flight id is null-terminated

    return true;
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     /**
 * @copyright Copyright (c) 2021 Sagetech, Inc. All rights reserved.
 *
 * @file sgDecodeInstall.c
 * @author Jacob.Garrison
 *
 * @date Mar 9, 2021
 *      
 */

#include <string.h>
#include <stdbool.h>

#include "sg.h"
#include "sgUtil.h"

#define SG_REG_LEN    7     // The number of bytes in the registration field

#define SG_STL_ANTENNA      0x03
#define SG_STL_ALT_RES      0x08
#define SG_STL_HDG_TYPE     0x10
#define SG_STL_SPD_TYPE     0x20
#define SG_STL_HEATER       0x40
#define SG_STL_WOW          0x80

typedef struct __attribute__((packed))
{
   uint8_t  start;
   uint8_t  type;
   uint8_t  id;
   uint8_t  payloadLen;
   uint8_t  icao[3];
   char     registration[SG_REG_LEN];
   uint8_t  rsvd1[2];
   uint8_t  com0;
   uint8_t  com1;
   uint8_t  ipAddress[4];
   uint8_t  subnetMask[4];
   uint8_t  port[2];
   uint8_t  gpsIntegrity;
   uint8_t  emitterSet;
   uint8_t  emitterType;
   uint8_t  size;
   uint8_t  maxSpeed;
   uint8_t  altOffset[2];
   uint8_t  rsvd2[2];
   uint8_t  config;
   uint8_t  rsvd3[2];
   uint8_t  checksum;
} stl_t;

/*
 * Documented in the header file.
 */
bool sgDecodeInstall(uint8_t *buffer, sg_install_t *stl)
{
   memset(&stl->reg[0], '\0', sizeof(stl->reg));  // Ensure registration is null-terminated

   stl_t sgStl;
   memcpy(&sgStl, buffer, sizeof(stl_t));

   stl->icao           = toIcao(sgStl.icao);
   strcpy(stl->reg,      sgStl.registration);
   memset(&stl->reg[SG_REG_LEN], 0, 1);  // Ensure registration is null-terminated
   stl->com0           = (sg_baud_t)(sgStl.com0);
   stl->com1           = (sg_baud_t)(sgStl.com1);
   stl->eth.ipAddress  = toUint32(sgStl.ipAddress);
   stl->eth.subnetMask = toUint32(sgStl.subnetMask);
   stl->eth.portNumber = toUint16(sgStl.port);
   stl->sil            = (sg_sil_t)(sgStl.gpsIntegrity >> 4);
   stl->sda            = (sg_sda_t)(sgStl.gpsIntegrity & 0x0F);
   stl->emitter        = (sg_emitter_t)(0x10 * sgStl.emitterSet + sgStl.emitterType);
   stl->size           = (sg_size_t)sgStl.size;
   stl->maxSpeed       = (sg_airspeed_t)sgStl.maxSpeed;
   stl->altOffset      = toUint16(sgStl.altOffset);
   stl->antenna        = (sg_antenna_t)sgStl.config & SG_STL_ANTENNA;
   stl->altRes100      = sgStl.config & SG_STL_ALT_RES;
   stl->hdgTrueNorth   = sgStl.config & SG_STL_HDG_TYPE;
   stl->airspeedTrue   = sgStl.config & SG_STL_SPD_TYPE;
   stl->heater         = sgStl.config & SG_STL_HEATER;
   stl->wowConnected   = sgStl.config & SG_STL_WOW;

   return true;
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               /**
 * @copyright Copyright (c) 2020 Sagetech, Inc. All rights reserved.
 *
 * @file sgDecodeMSR.c
 * @author jim.billmeyer
 *
 * @date Mar 17, 2021
 */

#include "sg.h"
#include <stdbool.h>
#include <stdint.h>
#include <string.h>
#include "sgUtil.h"

#define MS_PARAM_TOA (1 << 3)
#define MS_PARAM_ADSBVER (1 << 2)
#define MS_PARAM_CALLSIGN (1 << 1)
#define MS_PARAM_CATEMITTER (1 << 0)

#define MS_PARAM_AVLEN (1 << 7)
#define MS_PARAM_PRIORITY (1 << 6)
#define MS_PARAM_CAPCODES (1 << 5)
#define MS_PARAM_OPMODE (1 << 4)
#define MS_PARAM_NACP (1 << 3)
#define MS_PARAM_NACV (1 << 2)
#define MS_PARAM_SDA (1 << 1)
#define MS_PARAM_GVA (1 << 0)

#define MS_PARAM_NIC (1 << 7)
#define MS_PARAM_HEADING (1 << 6)
#define MS_PARAM_VRATE (1 << 5)

#define MS_CAP_B2LOW (1 << 3)
#define MS_CAP_UAT (1 << 1)
#define MS_CAP_TCR ((1 << 2) | (1 << 3))
#define MS_CAP_TSR (1 << 4)
#define MS_CAP_ARV (1 << 5)
#define MS_CAP_ADSB (1 << 6)
#define MS_CAP_TCAS (1 << 7)

#define MS_OP_GPS_LATFMT (1 << 7)
#define MS_OP_GPS_LONFMT (1 << 6)
#define MS_OP_TCAS_RA (1 << 5)
#define MS_OP_IDENT (1 << 4)
#define MS_OP_SINGLE_ANT (1 << 2)

/// the payload offset.
#define PBASE 4

/*
 * Documented in the header file.
 */
bool sgDecodeMSR(uint8_t *buffer, sg_msr_t *msr)
{
    memset(msr, 0, sizeof(sg_msr_t));

    uint8_t fields[3];
    memcpy(fields, &buffer[PBASE + 0], 3);

    if (buffer[PBASE + 1] == 0x6E && buffer[PBASE + 2] == 0x60)
    {
        msr->type = msrTypeV0;
    }
    else if (buffer[PBASE + 1] == 0x7E && buffer[PBASE + 2] == 0xE0)
    {
        msr->type = msrTypeV1Airborne;
    }
    else if (buffer[PBASE + 1] == 0xFE && buffer[PBASE + 2] == 0xE0)
    {
        msr->type = msrTypeV1Surface;
    }
    else if (buffer[PBASE + 1] == 0x7F && buffer[PBASE + 2] == 0xE0)
    {
        msr->type = msrTypeV2Airborne;
    }
    else if (buffer[PBASE + 1] == 0xFF && buffer[PBASE + 2] == 0xE0)
    {
        msr->type = msrTypeV2Surface;
    }

    msr->flags = buffer[PBASE + 3];
    msr->addr = toInt32(&buffer[PBASE + 4]) & 0xFFFFFF;
    msr->addrType = buffer[PBASE + 7] & 0xFF;

    uint8_t ofs = 8;

    if (fields[0] & MS_PARAM_TOA)
    {
        msr->toa = toTOA(&buffer[PBASE + ofs]);
        ofs += 2;
    }

    if (fields[0] & MS_PARAM_ADSBVER)
    {
        msr->version = buffer[PBASE + ofs];
        ofs++;
    }

    if (fields[0] & MS_PARAM_CALLSIGN)
    {
        memset(msr->callsign, 0, 9);
        memcpy(msr->callsign, &buffer[PBASE + ofs], 8);
        ofs += 8;
    }

    if (fields[0] & MS_PARAM_CATEMITTER)
    {
        msr->emitter = buffer[PBASE + ofs];
        ofs++;
    }

    if (fields[1] & MS_PARAM_AVLEN)
    {
        msr->size = buffer[PBASE + ofs];
        ofs++;
    }

    if (fields[1] & MS_PARAM_PRIORITY)
    {
        msr->priority = buffer[PBASE + ofs];
        ofs++;
    }

    if (fields[1] & MS_PARAM_CAPCODES)
    {
        uint8_t cap = buffer[PBASE + ofs + 0];
        msr->capability.b2low = cap & MS_CAP_B2LOW;

        cap = buffer[PBASE + ofs + 1];
        msr->capability.uat = cap & MS_CAP_UAT;
        msr->capability.tcr = (cap & MS_CAP_TCR) >> 2;
        msr->capability.tsr = cap & MS_CAP_TSR;
        msr->capability.arv = cap & MS_CAP_ARV;
        msr->capability.adsb = cap & MS_CAP_ADSB;
        msr->capability.tcas = cap & MS_CAP_TCAS;

        ofs += 3;
    }

    if (fields[1] & MS_PARAM_OPMODE)
    {
        uint8_t op = buffer[PBASE + ofs + 0];
        msr->opMode.gpsLatFmt = (op & MS_OP_GPS_LATFMT) == 0;
        msr->opMode.gpsLonFmt = (op & MS_OP_GPS_LONFMT) == 0;
        msr->opMode.tcasRA = op & MS_OP_TCAS_RA;
        msr->opMode.ident = op & MS_OP_IDENT;
        msr->opMode.singleAnt = op & MS_OP_SINGLE_ANT;

        op = buffer[PBASE + ofs + 1];
        msr->opMode.gpsLatOfs = op >> 5;
        msr->opMode.gpsLonOfs = op & 0x17;

        ofs += 2;
    }

    if (fields[1] & MS_PARAM_NACP)
    {
        msr->svQuality.nacp = buffer[PBASE + ofs];
        ofs++;
    }

    if (fields[1] & MS_PARAM_NACV)
    {
        msr->svQuality.nacv = buffer[PBASE + ofs];
        ofs++;
    }

    if (fields[1] & MS_PARAM_SDA)
    {
        uint8_t sda = buffer[PBASE + ofs];
        msr->svQuality.sda = (sda & 0x18) >> 3;
        msr->svQuality.silSupp = (sda & 0x04);
        msr->svQuality.sil = (sda & 0x03);
        ofs++;
    }

    if (fields[1] & MS_PARAM_GVA)
    {
        msr->svQuality.gva = buffer[PBASE + ofs];
        ofs++;
    }

    if (fields[2] & MS_PARAM_NIC)
    {
        msr->svQuality.nicBaro = buffer[PBASE + ofs];
        ofs++;
    }

    if (fields[2] & MS_PARAM_HEADING)
    {
        msr->trackHeading = buffer[PBASE + ofs];
        ofs++;
    }

    if (fields[2] & MS_PARAM_VRATE)
    {
        msr->vrateType = buffer[PBASE + ofs];
        ofs++;
    }

    return true;
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             /**
 * @copyright Copyright (c) 2021 Sagetech, Inc. All rights reserved.
 *
 * @file   sgDecodeSVR.c
 * @author jimb
 *
 * @date   Feb 10, 2021
 *
 * This file receives a raw ADS-B target state vector report message buffer and
 * parses the payload into a data struct.
 */

#include <string.h>
#include <stdbool.h>
#include <string.h>
#include <math.h>

#include "sg.h"
#include "sgUtil.h"
#include "target.h"

// airborne surface
// -------- --------
#define SV_PARAM_TOA_EPOS (1 << 3) // x
#define SV_PARAM_TOA_POS (1 << 2)  // x        x
#define SV_PARAM_TOA_VEL (1 << 1)  // x        x
#define SV_PARAM_LATLON (1 << 0)   // x        x

#define SV_PARAM_GEOALT (1 << 7)    // x
#define SV_PARAM_VEL (1 << 6)       // x
#define SV_PARAM_SURF_GS (1 << 5)   //          x
#define SV_PARAM_SURF_HEAD (1 << 4) //          x
#define SV_PARAM_BAROALT (1 << 3)   // x
#define SV_PARAM_VRATE (1 << 2)     // x
#define SV_PARAM_NIC (1 << 1)       // x        x
#define SV_PARAM_ESTLAT (1 << 0)    // x

#define SV_PARAM_ESTLON (1 << 7) // x
#define SV_PARAM_ESTNVEL (1 << 6)
#define SV_PARAM_ESTEVAL (1 << 5)
#define SV_PARAM_SURV (1 << 4)   // x        x
#define SV_PARAM_REPORT (1 << 3) // x        x

/// the payload offset.
#define PBASE 4

/*
 * Documented in the header file.
 */
bool sgDecodeSVR(uint8_t *buffer, sg_svr_t *svr)
{
    //   memset(svr, 0, sizeof(sg_svr_t));

    uint8_t fields[3];
    memcpy(&fields, &buffer[PBASE + 0], 3);

    svr->type = buffer[PBASE + 0] == 0x1F ? svrAirborne : svrSurface;
    svr->flags = buffer[PBASE + 3];
    svr->eflags = buffer[PBASE + 4];
    svr->addr = toInt32(&buffer[PBASE + 5]) & 0xFFFFFF;
    svr->addrType = buffer[PBASE + 8] & 0xFF;

    uint8_t ofs = 9;

    if (fields[0] & SV_PARAM_TOA_EPOS)
    {
        svr->toaEst = toTOA(&buffer[PBASE + ofs]);
        ofs += 2;
    }
    if (fields[0] & SV_PARAM_TOA_POS)
    {
        svr->toaPosition = toTOA(&buffer[PBASE + ofs]);
        ofs += 2;
    }
    if (fields[0] & SV_PARAM_TOA_VEL)
    {
        svr->toaSpeed = toTOA(&buffer[PBASE + ofs]);
        ofs += 2;
    }

    if (fields[0] & SV_PARAM_LATLON)
    {
        if (svr->validity.position)
        {
            svr->lat = toLatLon(&buffer[PBASE + ofs + 0]);
            svr->lon = toLatLon(&buffer[PBASE + ofs + 3]);
        }
        else
        {
            svr->lat = 0.0;
            svr->lon = 0.0;
        }

        ofs += 6;
    }

    if (svr->type == svrAirborne)
    {
        if (fields[1] & SV_PARAM_GEOALT)
        {
            if (svr->validity.geoAlt)
            {
                svr->airborne.geoAlt = toAlt(&buffer[PBASE + ofs]);
            }
            else
            {
                svr->airborne.geoAlt = 0;
            }

            ofs += 3;
        }

        if (fields[1] & SV_PARAM_VEL)
        {
            if (svr->validity.airSpeed)
            {
                int16_t nvel = toVel(&buffer[PBASE + ofs + 0]);
                int16_t evel = toVel(&buffer[PBASE + ofs + 2]);

                svr->airborne.heading = toHeading2((double)nvel, (double)evel);
                svr->airborne.speed = sqrt(nvel * nvel + evel * evel);
                svr->airborne.velEW = evel;
                svr->airborne.velNS = nvel;
            }
            else
            {
                svr->airborne.heading = 0;
                svr->airborne.speed = 0;
                svr->airborne.velEW = 0;
                svr->airborne.velNS = 0;
            }

            ofs += 4;
        }

        if (fields[1] & SV_PARAM_BAROALT)
        {
            if (svr->validity.baroAlt)
            {
                svr->airborne.baroAlt = toAlt(&buffer[PBASE + ofs]);
            }
            else
            {
                svr->airborne.baroAlt = 0;
            }

            ofs += 3;
        }

        if (fields[1] & SV_PARAM_VRATE)
        {
            if (svr->validity.baroVRate || svr->validity.geoVRate)
            {
                svr->airborne.vrate = toInt16(&buffer[PBASE + ofs]);
            }
            else
            {
                svr->airborne.vrate = 0;
            }

            ofs += 2;
        }
    }
    else
    {
        if (fields[1] & SV_PARAM_SURF_GS)
        {
            if (svr->validity.surfSpeed)
            {
                svr->surface.speed = toGS(&buffer[PBASE + ofs]);
            }
            else
            {
                svr->surface.speed = 0;
            }

            ofs += 1;
        }

        if (fields[1] & SV_PARAM_SURF_HEAD)
        {
            if (svr->validity.surfHeading)
            {
                svr->surface.heading = toHeading(&buffer[PBASE + ofs]);
            }
            else
            {
                svr->surface.heading = 0;
            }

            ofs += 1;
        }
    }

    if (fields[1] & SV_PARAM_NIC)
    {
        svr->nic = buffer[PBASE + ofs];

        ofs += 1;
    }

    if (fields[1] & SV_PARAM_ESTLAT)
    {
        if (svr->evalidity.estPosition)
        {
            svr->airborne.estLat = toLatLon(&buffer[PBASE + ofs]);
        }
        else
        {
            svr->airborne.estLat = 0;
        }

        ofs += 3;
    }

    if (fields[2] & SV_PARAM_ESTLON)
    {
        if (svr->evalidity.estPosition)
        {
            svr->airborne.estLon = toLatLon(&buffer[PBASE + ofs]);
        }
        else
        {
            svr->airborne.estLon = 0;
        }

        ofs += 3;
    }

    if (fields[2] & SV_PARAM_SURV)
    {
        svr->survStatus = buffer[PBASE + ofs];
        ofs += 1;
    }

    if (fields[2] & SV_PARAM_REPORT)
    {
        svr->mode = buffer[PBASE + ofs];
    }

    return true;
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         /**
 * @copyright Copyright (c) 2021 Sagetech, Inc. All rights reserved.
 *
 * @file sgEncodeDataReq.c
 * @author Jacob.Garrison
 *
 * @date Feb 23, 2021
 *
 * This file receives a populated data request struct and
 * converts it into a data request message buffer.
 */

#include <stdbool.h>
#include <stdlib.h>

#include "sg.h"
#include "sgUtil.h"

#define SG_PAYLOAD_LEN_DATAREQ SG_MSG_LEN_DATAREQ - 5 /// the payload length.

#define PBASE 4 /// the payload offset.

#define OFFSET_REQ_TYPE 0 /// the requested response message type
#define OFFSET_RSVD_1 1   /// a reserved field
#define OFFSET_RSVD_2 2   /// a reserved field
#define OFFSET_RSVD_3 3   /// a reserved field

/*
 * Documented in the header file.
 */
bool sgEncodeDataReq(uint8_t *buffer, sg_datareq_t *data, uint8_t msgId)
{
    // populate header
    buffer[0] = SG_MSG_START_BYTE;
    buffer[1] = SG_MSG_TYPE_HOST_DATAREQ;
    buffer[2] = msgId;
    buffer[3] = SG_PAYLOAD_LEN_DATAREQ;

    // populate Request Type
    buffer[PBASE + OFFSET_REQ_TYPE] = data->reqType;

    // populate Reserved fields
    buffer[PBASE + OFFSET_RSVD_1] = 0;
    buffer[PBASE + OFFSET_RSVD_2] = 0;
    buffer[PBASE + OFFSET_RSVD_3] = 0;

    // populate checksum
    appendChecksum(buffer, SG_MSG_LEN_DATAREQ);

    return true;
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            /**
 * @copyright Copyright (c) 2021 Sagetech, Inc. All rights reserved.
 *
 * @file sgEncodeFlightId.c
 * @author Jacob.Garrison
 *
 * @date Feb 25, 2021
 *
 */

#include <ctype.h>
#include <stdbool.h>
#include <stdlib.h>

#include "sg.h"
#include "sgUtil.h"

#define SG_PAYLOAD_LEN_FLIGHT SG_MSG_LEN_FLIGHT - 5 /// the payload length.

#define PBASE 4       /// the payload offset.
#define OFFSET_ID 0   /// the flight id offset in the payload.
#define OFFSET_RSVD 8 /// the reserved field offset in the payload.

#define ID_LEN 8 /// the length of the flight identification field.

/*
 * Documented in the header file.
 */
bool sgEncodeFlightId(uint8_t *buffer, sg_flightid_t *id, uint8_t msgId)
{
    // populate header
    buffer[0] = SG_MSG_START_BYTE;
    buffer[1] = SG_MSG_TYPE_HOST_FLIGHT;
    buffer[2] = msgId;
    buffer[3] = SG_PAYLOAD_LEN_FLIGHT;

    // populate flight identification
    charArray2Buf(&buffer[PBASE + OFFSET_ID], id->flightId, ID_LEN);

    // populate reserved field
    uint322Buf(&buffer[PBASE + OFFSET_RSVD], 0);

    // populate checksum
    appendChecksum(buffer, SG_MSG_LEN_FLIGHT);

    return true;
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        /**
 * @copyright Copyright (c) 2021 Sagetech, Inc. All rights reserved.
 *
 * @file sgEncodeGPS.c
 * @author Jacob.Garrison
 *
 * @date Mar 1, 2021
 *
 * This file receives a populated GPS message struct and
 * converts it into a GPS message buffer.
 */

#include <stdbool.h>
#include <stdlib.h>

#include "sg.h"
#include "sgUtil.h"

#define SG_PAYLOAD_LEN_GPS SG_MSG_LEN_GPS - 5 /// the payload length.
#define _UNUSED(x) ((void)(x))

#define PBASE 4            /// the payload offset.
#define OFFSET_LONGITUDE 0 /// the longitude offset in the payload.
#define OFFSET_LATITUDE 11 /// the latitude offset in the payload.
#define OFFSET_SPEED 21    /// the ground speed offset in the payload.
#define OFFSET_TRACK 27    /// the ground track offset in the payload.
#define OFFSET_STATUS 35   /// the hemisphere/data status offset in the payload.
#define OFFSET_TIME 36     /// the time of fix offset in the payload.
#define OFFSET_HEIGHT 46   /// the GNSS height offset in the payload.
#define OFFSET_HPL 50      /// the horizontal protection limit offset in the payload.
#define OFFSET_HFOM 54     /// the horizontal figure of merit offset in the payload.
#define OFFSET_VFOM 58     /// the vertical figure of merit offset in the payload.
#define OFFSET_NACV 62     /// the navigation accuracy for velocity offset in the payload.

#define LEN_LNG 11  /// bytes in the longitude field
#define LEN_LAT 10  /// bytes in the latitude field
#define LEN_SPD 6   /// bytes in the speed over ground field
#define LEN_TRK 8   /// bytes in the ground track field
#define LEN_TIME 10 /// bytes in the time of fix field

/*
 * Documented in the header file.
 */
bool sgEncodeGPS(uint8_t *buffer, sg_gps_t *gps, uint8_t msgId)
{
    // populate header
    buffer[0] = SG_MSG_START_BYTE;
    buffer[1] = SG_MSG_TYPE_HOST_GPS;
    buffer[2] = msgId;
    buffer[3] = SG_PAYLOAD_LEN_GPS;

    // populate longitude
    charArray2Buf(&buffer[PBASE + OFFSET_LONGITUDE], gps->longitude, LEN_LNG);

    // populate latitude
    charArray2Buf(&buffer[PBASE + OFFSET_LATITUDE], gps->latitude, LEN_LAT);

    // populate ground speed
    charArray2Buf(&buffer[PBASE + OFFSET_SPEED], gps->grdSpeed, LEN_SPD);

    // populate ground track
    charArray2Buf(&buffer[PBASE + OFFSET_TRACK], gps->grdTrack, LEN_TRK);

    // populate hemisphere/data status
    buffer[PBASE + OFFSET_STATUS] = !gps->gpsValid << 7 |
                                    gps->fdeFail << 6 |
                                    gps->lngEast << 1 |
                                    gps->latNorth;

    // populate time of fix
    charArray2Buf(&buffer[PBASE + OFFSET_TIME], gps->timeOfFix, LEN_TIME);

    // populate gnss height
    float2Buf(&buffer[PBASE + OFFSET_HEIGHT], gps->height);

    // populate HPL
    float2Buf(&buffer[PBASE + OFFSET_HPL], gps->hpl);

    // populate HFOM
    float2Buf(&buffer[PBASE + OFFSET_HFOM], gps->hfom);

    // populate VFOM
    float2Buf(&buffer[PBASE + OFFSET_VFOM], gps->vfom);

    // populate NACv
    buffer[PBASE + OFFSET_NACV] = gps->nacv << 4;

    // populate checksum
    appendChecksum(buffer, SG_MSG_LEN_GPS);

    return true;
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                /**
 * @copyright Copyright (c) 2021 Sagetech, Inc. All rights reserved.
 *
 * @file   sgEncodeInstall.c
 * @author Jacob.Garrison
 *
 * @date   Feb 23, 2021
 *
 * This file receives a populated installation message struct and
 * converts it into a installation message buffer.
 */

#include <ctype.h>
#include <string.h>
#include <stdbool.h>

#include "sg.h"
#include "sgUtil.h"

#define SG_PAYLOAD_LEN_INSTALL SG_MSG_LEN_INSTALL - 5 /// the payload length.

#define PBASE 4             /// the payload offset.
#define OFFSET_ICAO 0       /// the icao address offset in the payload.
#define OFFSET_REG 3        /// the registration offset in the payload.
#define OFFSET_RSVD1 10     /// the first reserved field offset in the payload.
#define OFFSET_COM0 12      /// the COM port 0 offset in the payload.
#define OFFSET_COM1 13      /// the COM port 1 offset in the payload.
#define OFFSET_IP 14        /// the IP address offset in the payload.
#define OFFSET_MASK 18      /// the net mask offset in the payload.
#define OFFSET_PORT 22      /// the port number offset in the payload.
#define OFFSET_GPS 24       /// the GPS integrity offset in the payload.
#define OFFSET_EMIT_SET 25  /// the emitter category offset in the payload.
#define OFFSET_EMIT_TYPE 26 /// the emitter type offset in the payload.
#define OFFSET_SIZE 27      /// the aircraft size offset in the payload.
#define OFFSET_SPEED 28     /// the maximum airspeed offset in the payload.
#define OFFSET_ENCODER 29   /// the altitude-encoder-offset offset in the payload.
#define OFFSET_RSVD2 31     /// the second reserved field offset in the payload.
#define OFFSET_CONFIG 33    /// the configuration offset in the payload.
#define OFFSET_RSVD3 34     /// the third reserved field offset in the payload.

#define REG_LEN 7 /// the registration field length.
/*
 * Documented in the header file.
 */
bool sgEncodeInstall(uint8_t *buffer, sg_install_t *stl, uint8_t msgId)
{
    // populate header
    buffer[0] = SG_MSG_START_BYTE;
    buffer[1] = SG_MSG_TYPE_HOST_INSTALL;
    buffer[2] = msgId;
    buffer[3] = SG_PAYLOAD_LEN_INSTALL;

    // populate icao address
    icao2Buf(&buffer[PBASE + OFFSET_ICAO], stl->icao);

    // populate aircraft registration
    charArray2Buf(&buffer[PBASE + OFFSET_REG], stl->reg, REG_LEN);

    // populate reserved fields
    uint162Buf(&buffer[PBASE + OFFSET_RSVD1], 0);

    // populate COM port 0, correct enum offset
    buffer[PBASE + OFFSET_COM0] = stl->com0;

    // populate COM port 1, correct enum offset
    buffer[PBASE + OFFSET_COM1] = stl->com1;

    // populate IP address
    uint322Buf(&buffer[PBASE + OFFSET_IP], stl->eth.ipAddress);

    // populate net mask
    uint322Buf(&buffer[PBASE + OFFSET_MASK], stl->eth.subnetMask);

    // populate port number
    uint162Buf(&buffer[PBASE + OFFSET_PORT], stl->eth.portNumber);

    // populate gps integrity
    buffer[PBASE + OFFSET_GPS] = stl->sil << 4 |
                                 stl->sda;

    // populate emitter category set and type
    uint8_t emitSet;
    uint8_t emitType;
    if (stl->emitter < SG_EMIT_OFFSET_B) // group A
    {
        emitSet = SG_EMIT_GROUP_A;
        emitType = stl->emitter - SG_EMIT_OFFSET_A;
    }
    else if (stl->emitter < SG_EMIT_OFFSET_C) // group B
    {
        emitSet = SG_EMIT_GROUP_B;
        emitType = stl->emitter - SG_EMIT_OFFSET_B;
    }
    else if (stl->emitter < SG_EMIT_OFFSET_D) // group C
    {
        emitSet = SG_EMIT_GROUP_C;
        emitType = stl->emitter - SG_EMIT_OFFSET_C;
    }
    else // group D
    {
        emitSet = SG_EMIT_GROUP_D;
        emitType = stl->emitter - SG_EMIT_OFFSET_D;
    }
    buffer[PBASE + OFFSET_EMIT_SET] = emitSet;
    buffer[PBASE + OFFSET_EMIT_TYPE] = emitType;

    // populate aircraft size
    buffer[PBASE + OFFSET_SIZE] = stl->size;

    // populate max airspeed
    buffer[PBASE + OFFSET_SPEED] = stl->maxSpeed;

    // populate altitude encoder offset
    uint162Buf(&buffer[PBASE + OFFSET_ENCODER], stl->altOffset);

    // populate reserved fields
    uint162Buf(&buffer[PBASE + OFFSET_RSVD2], 0);

    // populate install configuration
    buffer[PBASE + OFFSET_CONFIG] = stl->wowConnected << 7 |
                                    stl->heater << 6 |
                                    stl->airspeedTrue << 5 |
                                    stl->hdgTrueNorth << 4 |
                                    stl->altRes100 << 3 |
                                    stl->antenna;

    // populate reserved fields
    uint162Buf(&buffer[PBASE + OFFSET_RSVD3], 0);

    // populate checksum
    appendChecksum(buffer, SG_MSG_LEN_INSTALL);

    return true;
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           /**
 * @copyright Copyright (c) 2021 Sagetech, Inc. All rights reserved.
 *
 * @file   sgEncodeOperating.c
 * @author Jacob.Garrison
 *
 * @date   Feb 15, 2021
 *
 * This file receives a populated operating message struct and
 * converts it into a operating message buffer.
 */

#include <stdbool.h>
#include <stdlib.h>

#include "sg.h"
#include "sgUtil.h"

#define SG_PAYLOAD_LEN_OPMSG SG_MSG_LEN_OPMSG - 5 /// the payload length.

#define PBASE 4            /// the payload offset.
#define OFFSET_SQUAWK 0    /// the squawk code offset in the payload.
#define OFFSET_CONFIG 2    /// the mode/config offset in the payload.
#define OFFSET_EMRG_ID 3   /// the emergency flag offset in the payload.
#define OFFSET_ALT 4       /// the altitude offset in the payload.
#define OFFSET_RATE 6      /// the climb rate offset in the payload.
#define OFFSET_HEADING 8   /// the heading offset in the payload.
#define OFFSET_AIRSPEED 10 /// the airspeed offset in the payload.

/*
 * Documented in the header file.
 */
bool sgEncodeOperating(uint8_t *buffer, sg_operating_t *op, uint8_t msgId)
{
    // populate header
    buffer[0] = SG_MSG_START_BYTE;
    buffer[1] = SG_MSG_TYPE_HOST_OPMSG;
    buffer[2] = msgId;
    buffer[3] = SG_PAYLOAD_LEN_OPMSG;

    // populate Squawk code
    uint162Buf(&buffer[PBASE + OFFSET_SQUAWK], op->squawk);

    // populate Mode/Config
    buffer[PBASE + OFFSET_CONFIG] = op->milEmergency << 5 |
                                    op->enableXBit << 4 |
                                    op->enableSqt << 3 |
                                    op->savePowerUp << 2 |
                                    op->opMode;

    // populate Emergency/Ident
    buffer[PBASE + OFFSET_EMRG_ID] = op->identOn << 3 |
                                     op->emergcType;

    // populate Altitude
    uint16_t altCode = 0;
    if (op->altUseIntrnl)
    {
        altCode = 0x8000;
    }
    else if (op->altHostAvlbl)
    {
        // 100 foot encoding conversion
        altCode = (op->altitude + 1200) / 100;

        if (op->altRes25)
        {
            altCode *= 4;
        }

        // 'Host altitude available' flag
        altCode += 0x4000;
    }
    uint162Buf(&buffer[PBASE + OFFSET_ALT], altCode);

    // populate Altitude Rate
    int16_t rate = op->climbRate / 64;
    if (!op->climbValid)
    {
        rate = 0x8000;
    }
    uint162Buf(&buffer[PBASE + OFFSET_RATE], rate);

    // populate Heading
    //    conversion: heading * ( pow(2, 15) / 360 )
    uint16_t heading = op->heading * 32768 / 360;
    if (op->headingValid)
    {
        heading += 0x8000;
    }
    uint162Buf(&buffer[PBASE + OFFSET_HEADING], heading);

    // populate Airspeed
    uint16_t airspeed = op->airspd;
    if (op->airspdValid)
    {
        airspeed += 0x8000;
    }
    uint162Buf(&buffer[PBASE + OFFSET_AIRSPEED], airspeed);

    // populate checksum
    appendChecksum(buffer, SG_MSG_LEN_OPMSG);

    return true;
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   /**
 * @copyright Copyright (c) 2021 Sagetech, Inc. All rights reserved.
 *
 * @file   sgEncodeTargetReq.c
 * @author Jacob.Garrison
 *
 * @date Feb 19, 2021
 *
 * This file receives a populated target request struct and
 * converts it into a target request message buffer.
 */

#include <stdbool.h>
#include <stdlib.h>

#include "sg.h"
#include "sgUtil.h"

#define SG_PAYLOAD_LEN_TARGETREQ SG_MSG_LEN_TARGETREQ - 5 /// the payload length.

#define PBASE 4 /// the payload offset.

#define OFFSET_REQ_TYPE 0    /// the adsb reporting type and transmit port offset
#define OFFSET_MAX_TARGETS 1 /// the maximum number of targets offset
#define OFFSET_ICAO 3        /// the requested target icao offset
#define OFFSET_REPORTS 6     /// the requested report type offset
/*
 * Documented in the header file.
 */
bool sgEncodeTargetReq(uint8_t *buffer, sg_targetreq_t *tgt, uint8_t msgId)
{

    // populate header
    buffer[0] = SG_MSG_START_BYTE;
    buffer[1] = SG_MSG_TYPE_HOST_TARGETREQ;
    buffer[2] = msgId;
    buffer[3] = SG_PAYLOAD_LEN_TARGETREQ;

    // populate Request Type
    buffer[PBASE + OFFSET_REQ_TYPE] = tgt->transmitPort << 6 |
                                      tgt->reqType;

    // populate Max Targets
    uint162Buf(&buffer[PBASE + OFFSET_MAX_TARGETS], tgt->maxTargets);

    // populate Requested ICAO
    icao2Buf(&buffer[PBASE + OFFSET_ICAO], tgt->icao);

    // populated Requested Reports
    buffer[PBASE + OFFSET_REPORTS] = tgt->ownship << 7 |
                                     tgt->commA << 6 |
                                     tgt->military << 5 |
                                     tgt->tisb << 4 |
                                     tgt->airRefVel << 3 |
                                     tgt->targetState << 2 |
                                     tgt->modeStatus << 1 |
                                     tgt->stateVector;

    // populate checksum
    appendChecksum(buffer, SG_MSG_LEN_TARGETREQ);

    return true;
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         /**
 * @copyright Copyright (c) 2021 Sagetech, Inc. All rights reserved.
 *
 * @file   sgUtil.h
 * @author jimb
 *
 * @date Feb 2, 2021
 */

#ifndef UTIL_H
#define UTIL_H

#include <stdint.h>

#ifndef swap16
#define swap16(data) \
    ((((data) >> 8) & 0x00FF) | (((data) << 8) & 0xFF00))
#endif

#ifndef swap24
#define swap24(data) \
    (((data) >> 16) | ((data)&0x00FF00) | (((data) << 16) & 0xFF0000))
#endif

#ifndef swap32
#define swap32(data) \
    (((data) >> 24) | (((data)&0x00FF0000) >> 8) | (((data)&0x0000FF00) << 8) | ((data) << 24))
#endif

#ifndef swap64
#define swap64(data) \
   (swap32((data & 0x00000000ffffffffULL))) << 32 | swap32(data >> 32))
#endif

#ifndef PI
#define PI 3.14159265359
#endif

#ifndef toRad
#define toRad(deg) \
    ((deg)*PI / 180.0)
#endif

#ifndef toDeg
#define toDeg(rad) \
    ((rad)*180 / PI)
#endif

#ifndef toMeter
#define toMeter(feet) \
    ((feet)*0.3048)
#endif

#ifndef toFeet
#define toFeet(meter) \
    ((meter)*3.2808)
#endif

/**
 * Converts an array of bytes to a 16 bit integer.
 *
 * @param bytes The array of bytes to convert.
 *
 * @return The 16 bit integer.
 */
int16_t toInt16(const uint8_t bytes[]);

/**
 * Converts an array of bytes to a 32 bit integer.
 *
 * @param bytes The array of bytes to convert.
 *
 * @return The 32 bit integer.
 */
int32_t toInt32(const uint8_t bytes[]);

/**
 * Converts an array of bytes to a 16 unsigned bit integer.
 *
 * @param bytes The array of bytes to convert.
 *
 * @return The 16 bit integer.
 */
uint16_t toUint16(const uint8_t bytes[]);

/**
 * Converts an array of bytes to a 24 bit unsigned integer with leading 0s.
 *
 * @param bytes The array of bytes to convert.
 *
 * @return The 24 bit unsigned integer with leading 0s.
 */
uint32_t toUint24(const uint8_t bytes[]);

/**
 * Converts an array of bytes to a 32 bit unsigned integer.
 *
 * @param bytes The array of bytes to convert.
 *
 * @return The 32 bit unsigned integer.
 */
uint32_t toUint32(const uint8_t bytes[]);

/**
 * Converts an array of bytes to a distance.
 *
 * @param bytes The array of bytes to convert.
 *
 * @return The distance value.
 */
double toDist(const uint8_t *bytes);

/**
 * Converts an array of bytes to a 24 bit unsigned integer with leading 0's.
 *
 * @param bytes The array of bytes to convert.
 *
 * @return The 32 bit unsigned integer.
 */
uint32_t toIcao(const uint8_t bytes[]);

/**
 * Converts an array of bytes to a lat/lon floating point number.
 *
 * @param bytes The array of bytes to convert.
 *
 * @return The lat/lon value.
 */
double toLatLon(const uint8_t bytes[]);

/**
 * Convert an array to an altitude.
 *
 * @param bytes The bytes to get the altitude from.
 *
 * @return The converted altitude.
 */
double toAlt(const uint8_t bytes[]);

/**
 * Converts an array of bytes to an airborne velocity.
 *
 * @param bytes The bytes to extract the velocity.
 *
 * @return The converted velocity.
 */
double toVel(const uint8_t bytes[]);

/**
 * Converts the array of bytes to the surface ground speed.
 *
 * @param bytes The bytes to extract the ground speed.
 *
 * @return The converted ground speed.
 */
uint8_t toGS(const uint8_t bytes[]);

/**
 * Converts the bytes into the heading value.
 *
 * @param bytes The bytes holding the heading value.
 *
 * @return The heading.
 */
double toHeading(const uint8_t bytes[]);

/**
 * Determine heading from y and x speed vectors.
 *
 * @param y The y speed vector.
 * @param x The x speed vector.
 *
 * @return The resulting heading.
 */
int16_t toHeading2(double y, double x);

/**
 * Convert the array of bytes to a time of applicability (TOA).
 *
 * @param bytes The bytes to convert to a TOA.
 *
 * @return The converted TOA.
 */
float toTOA(const uint8_t bytes[]);

/**
 * Convert an array of bytes to a float
 *
 * @param bufferPos the address of the field's first corresponding buffer byte.
 *
 * @return The converted float value.
 */

float toFloat(const uint8_t *bufferPos);

/**
 * Convert an array of bytes to a double
 *
 * @param bufferPos the address of the field's first corresponding buffer byte.
 *
 * @return The converted double value.
 */

double toDouble(const uint8_t *bufferPos);

/**
 * Converts a uint16_t into its host message buffer format
 *
 * @param bufferPos The address of the field's first corresponding buffer byte.
 * @param value     The uint16_t to be converted.
 *
 * no return value, two buffer bytes are filled by reference
 */
void uint162Buf(uint8_t *bufferPos, uint16_t value);

/**
 * Converts a int16_t into its host message buffer format
 *
 * @param bufferPos The address of the field's first corresponding buffer byte.
 * @param value     The int32_t to be converted.
 *
 * no return value, two buffer bytes are filled by reference
 */
void int242Buf(uint8_t *bufferPos, int32_t value);

/**
 * Converts a uint32_t into a 24 bit host message buffer format
 *
 * @param bufferPos The address of the field's first corresponding buffer byte.
 * @param value     The int32_t to be converted.
 *
 * no return value, three buffer bytes are filled by reference
 */
void uint242Buf(uint8_t *bufferPos, uint32_t value);

/**
 * Converts a uint32_t into its host message buffer format
 *
 * @param bufferPos The address of the field's first corresponding buffer byte.
 * @param value     The uint32_t to be converted.
 *
 * no return value, two buffer bytes are filled by reference
 */
void uint322Buf(uint8_t *bufferPos, uint32_t value);

/**
 * Converts a uint32_t containing an ICAO into its 24-bit host message buffer format
 *
 * @param bufferPos The address of the field's first corresponding buffer byte.
 * @param icao      The uint32_t ICAO to be converted.
 *
 * no return value, three buffer bytes are filled by reference
 *
 * @warning icao parameter must be between 0x000000 and 0xFFFFFF
 */
void icao2Buf(uint8_t *bufferPos, uint32_t icao);

/**
 * Converts an array of characters into its host message buffer format
 *
 * @param bufferPos The address of the field's first corresponding buffer byte.
 * @param arr[]     The array of characters.
 * @param len       The number of characters in the array.
 *
 * no return value, the specified quantity of buffer bytes are filled by reference
 */
void charArray2Buf(uint8_t *bufferPos, char arr[], uint8_t len);

/**
 * Converts a float into its host message buffer format
 *
 * @param bufferPos The address of the field's first corresponding buffer byte.
 * @param value     The float to be converted.
 *
 * no return value, four buffer bytes are filled by reference
 *
 * @warning The output of this function depends on the machine's endianness. It is designed
 *          for Little-Endian machines, only.
 */
void float2Buf(uint8_t *bufferPos, float value);

/**
 * Converts a double into its host message buffer format
 *
 * @param bufferPos The address of the field's first corresponding buffer byte
 * @param value     The double to be converted
 *
 * no return value, eight buffer bytes are filled by reference
 *
 * @warning The output of this function depends on the machine's endianness. It is designed
 *          for Little-Endian machines, only
 */
void double2Buf(uint8_t *bufferPos, double value);

/**
 * Converts a double into an encoded lat/lon buffer format.
 *
 * @param bytes address of the field's first corresponding buffer byte
 * @param value the double to be converted.
 *
 *	no return value, 3 buffer bytes are filled by reference.
 */
void latLon2Buf(uint8_t bytes[], double value);

/**
 * Calculate checksum for a host message.
 *
 * @param buffer The raw message buffer.
 * @param len    The total quantity of bytes in the buffer
 *
 * @return The resulting checksum.
 */
uint8_t calcChecksum(uint8_t *buffer, uint8_t len);

/**
 * Add the checksum to a host message.
 *
 * @param buffer The raw message buffer.
 * @param len    The total quantity of bytes in the buffer
 *
 * no return value, final buffer byte is set to the checksum value.
 */
void appendChecksum(uint8_t *buffer, uint8_t len);

#endif /* UTIL_H */
                                                                                                                                                                                           /**
 * @copyright Copyright (c) 2020 SoftSolutions, Inc. All rights reserved.
 *
 * @File:   target.c
 * @Author: jim billmeyer
 *
 * @date    December 11, 2020, 12:50 AM
 */

#include <stdlib.h>
#include "target.h"

static ownship_t ownship;
static target_t targets[XPNDR_ADSB_TARGETS] = {
    {
        0,
    },
};

/*
 * Documented in the header file.
 */
target_t *targetList(void)
{
    return targets;
}

/*
 * Documented in the header file.
 */
ownship_t *targetOwnship(void)
{
    return &ownship;
}

/*
 * Documented in the header file.
 */
target_t *targetFind(uint32_t icao)
{
    for (uint16_t i = 0; i < XPNDR_ADSB_TARGETS; i++)
    {
        if (icao == targets[i].icao)
        {
            // clear strike counter and set find flag while preserving the used bit.
            targets[i].flag = TARGET_FLAG_FOUND | TARGET_FLAG_USED;
            return &targets[i];
        }
    }

    return 0;
}

/*
 * Documented in the header file.
 */
void targetPurge(void)
{
    for (uint16_t i = 0; i < XPNDR_ADSB_TARGETS; i++)
    {
        // the the found flag was not set increment the strike counter.
        if ((targets[i].flag & TARGET_FLAG_USED) && ((targets[i].flag & TARGET_FLAG_FOUND) == 0))
        {
            uint8_t strikes = (targets[i].flag & 0xFE) >> 2;
            strikes++;

            if (strikes > 5)
            {
                memset(&targets[i], 0, sizeof(target_t));
            }
            else
            {
                // set the strike counter and clear the found flag.
                targets[i].flag = strikes << 2 | TARGET_FLAG_USED;
            }
        }
        else
        {
            // clear the found flag so the target find function can set it
            // to signal that the icao address is still in range.
            targets[i].flag = targets[i].flag & (TARGET_FLAG_STRIKE_MASK | TARGET_FLAG_USED);
        }
    }
}

/*
 * Documented in the header file.
 */
void targetAdd(target_t *target)
{
    for (uint16_t i = 0; i < XPNDR_ADSB_TARGETS; i++)
    {
        if ((targets[i].flag & TARGET_FLAG_USED) == 0x0)
        {
            memcpy(&targets[i], target, sizeof(target_t));
            targets[i].flag = TARGET_FLAG_USED;
            break;
        }
    }
}

/*
 * Documented in the header file.
 */
targetclimb_t targetClimb(int16_t vrate)
{
    if (abs(vrate) < 500)
    {
        return trafLevel;
    }
    else if (vrate > 0)
    {
        return trafClimb;
    }
    else
    {
        return trafDescend;
    }
}

/*
 * Documented in the header file.
 */
targetalert_t targetAlert(double dist,
                          uint16_t alt,
                          int16_t nvel,
                          int16_t evel)
{
    if (alt <= 3000)
    {
        if (dist <= 3.0)
        {
            return trafResolution;
        }
        else if (dist <= 6.0)
        {
            return trafAdvisory;
        }
    }

    return trafTraffic;
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     /**
 * @copyright Copyright (c) 2020 Sagetech, Inc. All rights reserved.
 *
 * @File:   target.h
 * @Author: jim billmeyer
 *
 * @date    December 11, 2020, 12:49 AM
 */

#ifndef TARGET_H
#define TARGET_H

#include <string.h>
#include <stdbool.h>
#include <stdint.h>

#define XPNDR_ADSB_TARGETS 400 // change this to the max number of
                               // target supported in the system.

typedef enum
{
    trafLevel,
    trafClimb,
    trafDescend
} targetclimb_t;

typedef enum
{
    trafTraffic,
    trafAdvisory,
    trafResolution
} targetalert_t;

// bit 0    - target found flag.
// bit 1    - target slot in use.
// bits 2-7 - the strike counter.
#define TARGET_FLAG_FOUND 0x01
#define TARGET_FLAG_USED 0x02
#define TARGET_FLAG_STRIKE_MASK 0xFC

typedef struct __attribute__((packed))
{
    uint32_t icao;
    bool airborne;
    float bearing;
    uint8_t distance;
    int8_t altDiff;
    int16_t nvel;
    int16_t evel;
    targetclimb_t climb;
    targetalert_t alert;
#ifdef TARGET_SVR
    msg_svr_t svr;
#endif
    uint8_t flag; // used internally to purge stale targets.
} target_t;

typedef struct
{
    uint32_t icao;
    bool airborne;
    float lat;
    float lon;
    int32_t alt;
    int16_t heading;
    uint16_t speed;
} ownship_t;

/**
 * Gets the target list.
 *
 * @return The array of traffic targets.
 */
target_t *targetList(void);

/**
 * Gets the ownship target information.
 *
 * @return The ownship target info.
 */
ownship_t *targetOwnship(void);

/**
 * Find a target based on its icao number.
 *
 * @param icao The target's icao number
 *
 * @return A pointer to the target element or null if not found.
 */
target_t *targetFind(uint32_t icao);

/**
 * Purge the traffic target list of stale traffic.
 *
 * The traffic gets purged if a find has not been done based
 * on a strike counter.
 */
void targetPurge(void);

/**
 * Adds a target to the traffic target list.
 *
 * @param target The target to add.
 */
void targetAdd(target_t *target);

/**
 * Gets the target climb flag based on the vertical rate.
 *
 * @param vrate The current vertical rate of climb for the target.
 *
 * @return The level, climb or descend flag.
 */
targetclimb_t targetClimb(int16_t vrate);

/**
 * Gets the traffic alert flag.
 *
 * @param dist The distance of the target to the ownship.
 * @param alt  The altitude difference between the target and ownship.
 * @param nvel The NS speed vector of the target.
 * @param evel The EW speed vector of the target.
 *
 * @return The traffic flag based on the parameters.
 */
targetalert_t targetAlert(double dist,
                          uint16_t alt,
                          int16_t nvel,
                          int16_t evel);

#endif /* TARGET_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    /**
 * @copyright Copyright (c) 2021 Sagetech, Inc. All rights reserved.
 *
 * @file toAlt.c
 * @author Jacob.Garrison
 *
 * @date Mar 2, 2021
 *
 */

#include "sgUtil.h"

#define SV_RES_ALT 0.015625

/*
 * Documented in the header file.
 */
double toAlt(const uint8_t bytes[])
{
    double value = toInt32(bytes);
    value *= SV_RES_ALT;

    return value;
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       /**
 * @copyright Copyright (c) 2021 Sagetech, Inc. All rights reserved.
 *
 * @file toGS.c
 * @author Jacob.Garrison
 *
 * @date Mar 2, 2021
 *
 */

#include "sgUtil.h"

/*
 * Documented in the header file.
 */
uint8_t toGS(const uint8_t bytes[])
{
    uint8_t code = bytes[0];
    float gs = 0.0f;

    if (code <= 0x01)
    {
        gs = 0.0f;
    }
    else if (code <= 0x08)
    {
        gs = 1.0f;
    }
    else if (code <= 0x0C)
    {
        gs = 1.0f + (code - 0x09) * 0.25f;
    }
    else if (code <= 0x26)
    {
        gs = 2.0f + (code - 0x0D) * 0.5f;
    }
    else if (code <= 0x5D)
    {
        gs = 15.0f + (code - 0x27) * 1.0f;
    }
    else if (code <= 0x6C)
    {
        gs = 70.0f + (code - 0x5E) * 2.0f;
    }
    else if (code <= 0x7B)
    {
        gs = 100.0f + (code - 0x6D) * 5.0f;
    }
    else
    {
        gs = 176.0f;
    }

    // first converting to an 16 bit integer is necessary
    // to keep the floating point conversion from
    // truncating to 0.
    return (uint8_t)((int16_t)gs & 0xFF);
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               /**
 * @copyright Copyright (c) 2021 Sagetech, Inc. All rights reserved.
 *
 * @file toHeading.c
 * @author Jacob.Garrison
 *
 * @date Mar 2, 2021
 *
 */

#include "sgUtil.h"

#define SV_RES_HEAD 1.40625

/*
 * Documented in the header file.
 */
double toHeading(const uint8_t bytes[])
{
    double value = bytes[0];
    value *= SV_RES_HEAD;

    return value;
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    /**
 * @copyright Copyright (c) 2021 Sagetech, Inc. All rights reserved.
 *
 * @file toHeading2.c
 * @author Jacob.Garrison
 *
 * @date Mar 2, 2021
 *
 */

#include <math.h>

#include "sgUtil.h"

/*
 * Documented in the header file.
 */
int16_t toHeading2(double y, double x)
{
    int16_t heading = (toDeg(atan2(y, x)) + 0.5);
    heading = 360 - heading + 90; // atan is ccw 0 degrees at x = 1 and y = 0.

    if (heading > 360)
    {
        heading -= 360;
    }
    else
    {
        while (heading < 0)
        {
            heading += 360;
        }
    }

    return heading;
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     /**
 * @copyright Copyright (c) 2021 Sagetech, Inc. All rights reserved.
 *
 * @file toIcao.c
 * @author Jacob.Garrison
 *
 * @date Mar 9, 2021
 *
 */

#include "sgUtil.h"

/*
 * Documented in the header file.
 */
uint32_t toIcao(const uint8_t bytes[])
{
    uint32_t icao = (0 << 24) | ((uint32_t)bytes[0] << 16) | ((uint32_t)bytes[1] << 8) | ((uint32_t)bytes[2]);

    return icao;
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              /**
 * @copyright Copyright (c) 2021 Sagetech, Inc. All rights reserved.
 *
 * @file toInt16.c
 * @author Jacob.Garrison
 *
 * @date Mar 2, 2021
 *
 */

#include "sgUtil.h"

/*
 * Documented in the header file.
 */
int16_t toInt16(const uint8_t bytes[])
{
    int16_t int16 = ((int16_t)bytes[0] << 8) | bytes[1];

    return int16;
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  /**
 * @copyright Copyright (c) 2021 Sagetech, Inc. All rights reserved.
 *
 * @file toInt32.c
 * @author Jacob.Garrison
 *
 * @date Mar 2, 2021
 *
 */

#include "sgUtil.h"

/*
 * Documented in the header file.
 */
int32_t toInt32(const uint8_t bytes[])
{
    int32_t int32 = ((int32_t)bytes[0] << 24) | ((int32_t)bytes[1] << 16) | ((int32_t)bytes[2] << 8);
    int32 = int32 >> 8;

    return int32;
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             /**
 * @copyright Copyright (c) 2021 Sagetech, Inc. All rights reserved.
 *
 * @file toLatLon.c
 * @author Jacob.Garrison
 *
 * @date Mar 2, 2021
 *
 */

#include "sgUtil.h"

#define SV_RES_LATLON 180.0 / 8388608.0 // 180 degrees / 2^23

/*
 * Documented in the header file.
 */
double toLatLon(const uint8_t bytes[])
{
    double value = toInt32(bytes);
    value *= SV_RES_LATLON;

    return value;
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            /**
 * @copyright Copyright (c) 2021 Sagetech, Inc. All rights reserved.
 *
 * @file toTOA.c
 * @author Jacob.Garrison
 *
 * @date Mar 2, 2021
 *
 */

#include "sgUtil.h"

/*
 * Documented in the header file.
 */
float toTOA(const uint8_t bytes[])
{
    float toa = toInt16(bytes) & 0xFFFF;
    return toa / 128.0;
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   /**
 * @copyright Copyright (c) 2021 Sagetech, Inc. All rights reserved.
 *
 * @file toUint16.c
 * @author Jacob.Garrison
 *
 * @date Mar 9, 2021
 *      
 */

#include "sgUtil.h"

/*
 * Documented in the header file.
 */
uint16_t toUint16(const uint8_t bytes[])
{
   uint16_t uint16 = ((uint16_t) bytes[0] << 8 | (uint16_t) bytes[1]);

   return uint16;
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           /**
 * @copyright Copyright (c) 2021 Sagetech, Inc. All rights reserved.
 *
 * @file toUint32.c
 * @author Jacob.Garrison
 *
 * @date Mar 2, 2021
 *      
 */

#include "sgUtil.h"

/*
 * Documented in the header file.
 */
uint32_t toUint32(const uint8_t bytes[])
{
   uint32_t uint32 = ((uint32_t) bytes[0] << 24) | ((uint32_t) bytes[1] << 16) | ((uint32_t) bytes[2] << 8) | ((uint32_t) bytes[3]);

   return uint32;
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             /**
 * @copyright Copyright (c) 2021 Sagetech, Inc. All rights reserved.
 *
 * @file toVel.c
 * @author Jacob.Garrison
 *
 * @date Mar 2, 2021
 *
 */

#include "sgUtil.h"

#define SV_RES_VEL 0.125

/*
 * Documented in the header file.
 */
double toVel(const uint8_t bytes[])
{
    double value = toInt16(bytes);
    value *= SV_RES_VEL;

    return value;
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          