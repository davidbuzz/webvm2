/*
 * This file is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This file is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Code by 
 *         Andy Piper
 *         Siddharth Bharat Purohit, Cubepilot Pty. Ltd.
 */
/*
    Implements Common Flash Interface Driver based on
    Open Standard Published by JEDEC
*/

#include "AP_FlashIface_Abstract.h"


class AP_FlashIface_JEDEC : public AP_FlashIface
{
public:
    bool init() override;

    /**
     * @details Read data from flash chip.
     *
     * @param[in] offset        address offset from where to start the read
     * @param[out] data         data to be read from the device
     * @param[in] size          size of the data to be read
     * @return                  The operation status.
     * @retval false            if the operation failed.
     * @retval true             if the operation succeeded.
     *
     */
    bool read(uint32_t offset, uint8_t *data, uint32_t size) override;


    /**
     * @details Gets number bytes that can be written in one go (page size).
     *
     * @return                  page size in bytes.
     *
     */
    uint32_t get_page_size() const override
    {
        return _desc.page_size;
    }

    /**
     * @details Gets number pages, each page can written in one go
     *
     * @return                  Number of pages.
     *
     */
    uint32_t get_page_count() const override
    {
        return _desc.page_count;
    }

    /**
     * @details Sends command to start programming a page of the chip.
     *
     * @param[in]  page         Page number to be written to
     * @param[in]  data         data to be written
     * @param[out] delay_us     Time to wait until next is_device_busy call
     * @param[out] timeout_us   Time after which the erase should be timedout,
     *                          should be reset at every call.
     * @return                  The operation status.
     * @retval false            if the operation failed.
     * @retval true             if the operation succeeded.
     *
     */
    bool start_program_page(uint32_t page, const uint8_t *data, uint32_t &delay_us, uint32_t &timeout_us) override;

    /**
     * @details Tries to program as much as possible starting from the offset
     *          until size. User needs to call this as many times as needed
     *          taking already programmed bytes into account.
     *
     * @param[in] offset        address offset for program
     * @param[in] data          data to be programmed
     * @param[in] size          size desired to be programmed
     * @param[out] programming  number of bytes programming, taking care of the limits
     * @param[out] delay_us     Time to wait until program typically finishes
     * @param[out] timeout_us   Time by which current program should have timedout.
     * @return                  The operation status.
     * @retval false            if the operation failed.
     * @retval true             if the operation succeeded.
     *
     */
    bool start_program_offset(uint32_t offset, const uint8_t* data, uint32_t size, uint32_t &programming,
                              uint32_t &delay_us, uint32_t &timeout_us) override;

    // Erase Methods

    /**
     * @details Sends command to erase the entire chip.
     *
     * @param[out] delay_ms     Time to wait until next is_device_busy call
     * @param[out] timeout_ms   Time by which the erase should have timedout
     *
     * @return                  The operation status.
     * @retval false            if the operation failed.
     * @retval true             if the operation succeeded.
     *
     */
    bool start_mass_erase(uint32_t &delay_ms, uint32_t &timeout_ms) override;

    /**
     * @details Gets number bytes that can erased in one go(sector size)
     *
     * @return                  Sector size in bytes.
     *
     */
    uint32_t get_sector_size() const override
    {
        return _desc.sector_size;
    }

    /**
     * @details Gets number of sectors, each sector can be erased in one go
     *
     * @return                  Number of sectors.
     *
     */
    uint32_t get_sector_count() const override
    {
        return _desc.sector_count;
    }

    /**
     * @details minimum number of bytes that can be erased
     *
     * @return                  Number of bytes.
     *
     */
    uint32_t min_erase_size() const override
    {
        return _desc.min_erase_size;
    }


    /**
     * @details Sends command to erase a sector of the chip.
     *
     * @param[in]  sector       Sector number to be erased
     * @param[out] delay_ms     Time to wait until next is_device_busy call
     * @param[out] timeout_ms   Time by which the erase should have timedout
     *
     * @return                  The operation status.
     * @retval false            if the operation failed.
     * @retval true             if the operation succeeded.
     *
     */
    bool start_sector_erase(uint32_t sector, uint32_t &delay_ms, uint32_t &timeout_ms) override;

    /**
     * @details Tries to erase as much as possible starting from the offset
     *          until size. User needs to call this as many times as needed
     *          taking already erased bytes into account, until desired erase
     *          has taken place
     *
     * @param[in] offset        address offset for erase
     * @param[in] size          size desired to be erased
     * @param[out] erasing      number of bytes erasing
     * @param[out] delay_ms     Time to wait until next is_device_busy call
     * @param[out] timeout_ms   Time by which the erase should have timedout
     *
     * @return                  The operation status.
     * @retval false            if the operation failed.
     * @retval true             if the operation succeeded.
     *
     */
    bool start_erase_offset(uint32_t offset, uint32_t size, uint32_t &erasing,
                            uint32_t &delay_ms, uint32_t &timeout_ms) override;


    /**
     * @details Check if selected sector is erased.
     *
     * @param[in] sector        sector for which to check erase
     * @return                  The operation status.
     * @retval false            if the operation failed.
     * @retval true             if the operation succeeded.
     *
     */
    bool verify_sector_erase(uint32_t sector) override;


    /**
     * @details Check if the device is busy.
     *
     * @return                  device busy with last op.
     *
     * @retval false            if the device is ready.
     * @retval true             if the device is busy.
     *
     */
    bool is_device_busy() override;


    /**
     * @details Starts execution in place mode
     *
     * @return                  if successfully entered XIP mode.
     *
     * @retval false            the device failed to enter XIP mode.
     * @retval true             the device has entered XIP mode.
     *
     */
    bool start_xip_mode(void** addr) override;

    bool stop_xip_mode() override;
protected:
    void reset_device();

    // Does initial configuration to bring up and setup chip
    bool detect_device();

    // Configures device to normal working state, currently 4-4-4 WSPI
    bool configure_device();

    // Enables commands that modify flash data or settings
    bool write_enable();

    // Disables commands that modify flash data or settings
    bool write_disable();

    // wait for the chip to be ready for the next instruction
    void wait_ready();

    // Read modify write register
    bool modify_reg(uint8_t read_ins, uint8_t write_ins,
                    uint8_t mask, uint8_t va_list);

    // reads a register value of chip using instruction
    bool read_reg(uint8_t read_ins, uint8_t &read_val);

    // sends instruction to write a register value in the chip
    bool write_reg(uint8_t read_ins, uint8_t write_val);

    // Sends WSPI command without data
    bool send_cmd(uint8_t ins);

    // Is device in wide spi mode
    enum class WSPIMode {
        NormalSPI,
        QuadSPI,
        OctoSPI
    } _wide_spi_mode;

    AP_HAL::OwnPtr<AP_HAL::WSPIDevice> _dev;

    enum xip_entry_methods {
        XIP_ENTRY_METHOD_1,
        XIP_ENTRY_METHOD_2,
        XIP_ENTRY_METHOD_3
    };

    // Device description extracted from SFDP
    struct device_desc {
        uint16_t param_rev; //parameter revision
        uint8_t param_table_len; // size of parameter table
        uint32_t param_table_pointer; // location of parameter table
        uint32_t flash_size; // size of flash in bytes
        uint32_t page_size; // maximum size that can be written in one transaction
        uint32_t page_count; // number of pages each of page size
        uint32_t sector_size; // maximum number of bytes that can be erased outside of mass erase
        uint32_t sector_count; // number of sectors
        uint32_t min_erase_size; // minimum amount of bytes that can be erased
        struct {
            uint8_t ins; // instruction for the erase
            uint32_t size; // number of bytes that will be erased
            uint32_t delay_ms; // typical time this command will finish
            uint32_t timeout_ms; // time after which the erase cmd caller should time
        } erase_type[4];
        uint32_t mass_erase_delay_ms; // typical time taken while mass erase
        uint32_t mass_erase_timeout_ms; // time after which mass erase cmd caller should timeout
        uint8_t write_enable_ins; // instruction to allow enabling modification of register and data
        uint32_t page_prog_delay_us; // time taken to write a page worth of data to flash
        uint32_t page_prog_timeout_us; // time after which the page program caller should timeout
        uint8_t fast_read_ins; // instruction to do fast read, i.e. read any number of bytes in single trx
        uint8_t fast_read_dummy_cycles; // number of dummy cycles after which the chip will respond with data
        uint8_t quad_mode_ins; // instruction to enter 4-4-4 mode
        uint8_t wide_mode_enable;
        bool quad_mode_rmw_seq; // use Read modify write sequence to enter 4-4-4 mode supported or not
        uint8_t status_read_ins; // read status of the chip, gets us if busy writing/erasing
        bool legacy_status_polling; // check if legacy status polling supported or not
        bool is_xip_supported; // is execution in place or 0-4-4 mode supported
        uint8_t fast_read_mode_clocks;
        xip_entry_methods entry_method;
    } _desc;

    uint8_t _dev_list_idx;
    bool initialised;
    bool write_enable_called;
};

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                #include <AP_HAL/AP_HAL.h>

#if CONFIG_HAL_BOARD == HAL_BOARD_LINUX

const AP_HAL::HAL& hal = AP_HAL::get_HAL();
void setup() { }

void loop()
{
    // the library simply panics if a JEDEC device can't be found.  We
    // can't really recover from that.
    hal.console->printf("No JEDEC on linux\n");
    hal.scheduler->delay(1000);
}

#else

#include <GCS_MAVLink/GCS_Dummy.h>
#include <AP_SerialManager/AP_SerialManager.h>
#include <AP_BoardConfig/AP_BoardConfig.h>
#include <AP_FlashIface/AP_FlashIface.h>
#include <stdio.h>

AP_FlashIface_JEDEC jedec_dev;
const AP_HAL::HAL& hal = AP_HAL::get_HAL();

void setup();
void loop();

GCS_Dummy _gcs;


#ifdef HAL_BOOTLOADER_BUILD
#define DELAY_MILLIS(x)         do { chThdSleepMilliseconds(x); } while(0)
#define DELAY_MICROS(x)         do { chThdSleepMicroseconds(x); } while(0)
#else
#define DELAY_MILLIS(x)         do { hal.scheduler->delay(x); } while(0)
#define DELAY_MICROS(x)         do { hal.scheduler->delay_microseconds(x); } while(0)
#endif

const AP_Param::GroupInfo GCS_MAVLINK_Parameters::var_info[] = {
        AP_GROUPEND
};

static AP_SerialManager serial_manager;
static AP_BoardConfig board_config;

static UNUSED_FUNCTION void test_page_program()
{
    uint8_t *data = new uint8_t[jedec_dev.get_page_size()];
    if (data == nullptr) {
        hal.console->printf("Failed to allocate data for program");
    }
    uint8_t *rdata = new uint8_t[jedec_dev.get_page_size()];
    if (rdata == nullptr) {
        hal.console->printf("Failed to allocate data for read");
    }

    // fill program data with its own address
    for (uint32_t i = 0; i < jedec_dev.get_page_size(); i++) {
        data[i] = i;
    }
    hal.console->printf("Writing Page #1\n");
    uint32_t delay_us, timeout_us;
    uint64_t start_time_us = AP_HAL::micros64();
    if (!jedec_dev.start_program_page(0, data, delay_us, timeout_us)) {
        hal.console->printf("Page write command failed\n");
        return;
    }
    while (true) {
        DELAY_MICROS(delay_us);
        if (AP_HAL::micros64() > (start_time_us+delay_us)) {
            if (!jedec_dev.is_device_busy()) {
                hal.console->printf("Page Program Successful, elapsed %ld us\n", (unsigned long)(AP_HAL::micros64() - start_time_us));
                break;
            } else {
                hal.console->printf("Typical page program time reached, Still Busy?!\n");
            }
        }
        if (AP_HAL::micros64() > (start_time_us+timeout_us)) {
            hal.console->printf("Page Program Timed out, elapsed %lld us\n", (unsigned long long)(AP_HAL::micros64() - start_time_us));
            return;
        }
    }
    if (!jedec_dev.read(0, rdata, jedec_dev.get_page_size())) {
        hal.console->printf("Failed to read Flash page\n");
    } else {
        if (memcmp(data, rdata, jedec_dev.get_page_size()) != 0) {
            hal.console->printf("Program Data Mismatch!\n");
        } else {
            hal.console->printf("Program Data Verified Good!\n");
        }
    }

    // Now test XIP mode here as well
    uint8_t *chip_data = nullptr;
    if (!jedec_dev.start_xip_mode((void**)&chip_data)) {
        hal.console->printf("Failed to setup XIP mode\n");
    }
    if (chip_data == nullptr) {
        hal.console->printf("Invalid address!\n");
    }
    // Here comes the future!
    if (memcmp(data, chip_data, jedec_dev.get_page_size()) != 0) {
        hal.console->printf("Program Data Mismatch in XIP mode!\n");
    } else {
        hal.console->printf("Program Data Verified Good in XIP mode!\n");
    }
    jedec_dev.stop_xip_mode();
}

static UNUSED_FUNCTION void test_sector_erase()
{
    uint32_t delay_ms, timeout_ms;
    if (!jedec_dev.start_sector_erase(0, delay_ms, timeout_ms)) { // erase first sector
        hal.console->printf("Sector erase command failed\n");
        return;
    }
    uint32_t erase_start = AP_HAL::millis();
    uint32_t next_check_ms = 0;
    hal.console->printf("Erasing Sector #1 ");
    while (true) {
        if (AP_HAL::millis() > next_check_ms) {
            hal.console->printf("\n");
            if (!jedec_dev.is_device_busy()) {
                if (next_check_ms == 0) {
                    hal.console->printf("Sector Erase happened too fast\n");
                    return;
                }
                hal.console->printf("Sector Erase Successful, elapsed %ld ms\n", (unsigned long)(AP_HAL::millis() - erase_start));
                break;
            } else {
                hal.console->printf("Still busy erasing, elapsed %ld ms\n", (unsigned long)(AP_HAL::millis() - erase_start));
            }
            if ((AP_HAL::millis() - erase_start) > timeout_ms) {
                hal.console->printf("Sector Erase Timed Out, elapsed %ld ms\n", (unsigned long)(AP_HAL::millis() - erase_start));
                return;
            }
            next_check_ms = erase_start+delay_ms;
        }
        DELAY_MILLIS((delay_ms/100) + 10);
        hal.console->printf("*");
    }
    if (!jedec_dev.verify_sector_erase(0)) {
        hal.console->printf("Erase Verification Failed!\n");
    } else {
        hal.console->printf("Erase Verification Successful!\n");
    }
}

static UNUSED_FUNCTION void test_mass_erase()
{
    uint32_t delay_ms, timeout_ms;
    if (!jedec_dev.start_mass_erase(delay_ms, timeout_ms)) {
        hal.console->printf("Mass erase command failed\n");
        return;
    }
    uint32_t erase_start = AP_HAL::millis();
    uint32_t next_check_ms = 0;
    hal.console->printf("Mass Erasing ");
    while (true) {
        if (AP_HAL::millis() > next_check_ms) {
            hal.console->printf("\n");
            if (!jedec_dev.is_device_busy()) {
                if (next_check_ms == 0) {
                    hal.console->printf("Sector Erase happened too fast\n");
                    return;
                }
                hal.console->printf("Mass Erase Successful, elapsed %ld ms\n",(unsigned long)(AP_HAL::millis() - erase_start));
                return;
            } else {
                hal.console->printf("Still busy erasing, elapsed %ld ms\n", (unsigned long)(AP_HAL::millis() - erase_start));
            }
            if ((AP_HAL::millis() - erase_start) > timeout_ms) {
                hal.console->printf("Mass Erase Timed Out, elapsed %ld ms\n", (unsigned long)(AP_HAL::millis() - erase_start));
                return;
            }
            next_check_ms = erase_start+delay_ms;
        }
        DELAY_MILLIS(delay_ms/100);
        hal.console->printf("*");
    }
}

void setup()
{
    board_config.init();
    serial_manager.init();
}

void loop()
{
    // Start on user input
    hal.console->printf("\n\n******************Starting Test********************\n");
    jedec_dev.init();
    test_sector_erase();
    test_page_program();
    // test_mass_erase();
    hal.scheduler->delay(1000);
}

#endif

AP_HAL_MAIN();

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       #!/usr/bin/env python
# encoding: utf-8

def build(bld):
    bld.ap_example(
        use='ap',
    )
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           #include <AP_HAL/AP_HAL.h>
#include <AP_FlashIface/AP_FlashIface.h>
#include <stdio.h>
#include <support.h>
#include <hal.h>

AP_FlashIface_JEDEC jedec_dev;

static UNUSED_FUNCTION void test_page_program()
{
    uint8_t *data = new uint8_t[jedec_dev.get_page_size()];
    if (data == nullptr) {
        uprintf("Failed to allocate data for program");
    }
    uint8_t *rdata = new uint8_t[jedec_dev.get_page_size()];
    if (rdata == nullptr) {
        uprintf("Failed to allocate data for read");
    }

    // fill program data with its own address
    for (uint32_t i = 0; i < jedec_dev.get_page_size(); i++) {
        data[i] = i;
    }
    uprintf("Writing Page #1\n");
    uint32_t delay_us, timeout_us;
    uint64_t start_time_us = AP_HAL::micros64();
    if (!jedec_dev.start_program_page(0, data, delay_us, timeout_us)) {
        uprintf("Page write command failed\n");
        return;
    }
    while (true) {
        chThdSleep(chTimeUS2I(delay_us));
        if (AP_HAL::micros64() > (start_time_us+delay_us)) {
            if (!jedec_dev.is_device_busy()) {
                uprintf("Page Program Successful, elapsed %ld us\n", uint32_t(AP_HAL::micros64() - start_time_us));
                break;
            } else {
                uprintf("Typical page program time reached, Still Busy?!\n");
            }
        }
        if (AP_HAL::micros64() > (start_time_us+timeout_us)) {
            uprintf("Page Program Timed out, elapsed %lld us\n", AP_HAL::micros64() - start_time_us);
            return;
        }
    }
    if (!jedec_dev.read(0, rdata, jedec_dev.get_page_size())) {
        uprintf("Failed to read Flash page\n");
    } else {
        if (memcmp(data, rdata, jedec_dev.get_page_size()) != 0) {
            uprintf("Program Data Mismatch!\n");
        } else {
            uprintf("Program Data Verified Good!\n");
        }
    }

    // Now test XIP mode here as well
    uint8_t *chip_data = nullptr;
    if (!jedec_dev.start_xip_mode((void**)&chip_data)) {
        uprintf("Failed to setup XIP mode\n");
    }
    if (chip_data == nullptr) {
        uprintf("Invalid address!\n");
    }
    // Here comes the future!
    if (memcmp(data, chip_data, jedec_dev.get_page_size()) != 0) {
        uprintf("Program Data Mismatch in XIP mode!\n");
    } else {
        uprintf("Program Data Verified Good in XIP mode!\n");
    }
    jedec_dev.stop_xip_mode();
}

static UNUSED_FUNCTION void test_sector_erase()
{
    uint32_t delay_ms, timeout_ms;
    if (!jedec_dev.start_sector_erase(0, delay_ms, timeout_ms)) { // erase first sector
        uprintf("Sector erase command failed\n");
        return;
    }
    uint32_t erase_start = AP_HAL::millis();
    uint32_t next_check_ms = 0;
    uprintf("Erasing Sector #1 ");
    while (true) {
        if (AP_HAL::millis() > next_check_ms) {
            uprintf("\n");
            if (!jedec_dev.is_device_busy()) {
                if (next_check_ms == 0) {
                    uprintf("Sector Erase happened too fast\n");
                    return;
                }
                uprintf("Sector Erase Successful, elapsed %ld ms\n", AP_HAL::millis() - erase_start);
                break;
            } else {
                uprintf("Still busy erasing, elapsed %ld ms\n", AP_HAL::millis() - erase_start);
            }
            if ((AP_HAL::millis() - erase_start) > timeout_ms) {
                uprintf("Sector Erase Timed Out, elapsed %ld ms\n", AP_HAL::millis() - erase_start);
                return;
            }
            next_check_ms = erase_start+delay_ms;
        }
        chThdSleep(chTimeMS2I((delay_ms/100) + 10));
        uprintf("*");
    }
    if (!jedec_dev.verify_sector_erase(0)) {
        uprintf("Erase Verification Failed!\n");
    } else {
        uprintf("Erase Verification Successful!\n");
    }
}

static UNUSED_FUNCTION void test_mass_erase()
{
    uint32_t delay_ms, timeout_ms;
    if (!jedec_dev.start_mass_erase(delay_ms, timeout_ms)) {
        uprintf("Mass erase command failed\n");
        return;
    }
    uint32_t erase_start = AP_HAL::millis();
    uint32_t next_check_ms = 0;
    uprintf("Mass Erasing ");
    while (true) {
        if (AP_HAL::millis() > next_check_ms) {
            uprintf("\n");
            if (!jedec_dev.is_device_busy()) {
                if (next_check_ms == 0) {
                    uprintf("Sector Erase happened too fast\n");
                    return;
                }
                uprintf("Mass Erase Successful, elapsed %ld ms\n", AP_HAL::millis() - erase_start);
                return;
            } else {
                uprintf("Still busy erasing, elapsed %ld ms\n", AP_HAL::millis() - erase_start);
            }
            if ((AP_HAL::millis() - erase_start) > timeout_ms) {
                uprintf("Mass Erase Timed Out, elapsed %ld ms\n", AP_HAL::millis() - erase_start);
                return;
            }
            next_check_ms = erase_start+delay_ms;
        }
        chThdSleep(chTimeMS2I(delay_ms/100));
        uprintf("*");
    }
}

int main()
{
    init_uarts();

    while (true) {
        // Start on user input
        while (cin(0) < 0) {}
        uprintf("\n\n******************Starting Test********************\n");
        jedec_dev.init();
        test_sector_erase();
        test_page_program();
        // test_mass_erase();
        chThdSleep(chTimeMS2I(1000));
    }
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   #!/usr/bin/env python
# encoding: utf-8

def build(bld):
    if bld.env.BOOTLOADER:
        bld.ap_program(
            source=['../../../../Tools/AP_Bootloader/support.cpp', 'jedec_test.cpp'],
            use=['ap','JEDEC_libs'],
            program_groups='examples',
            includes=bld.env.SRCROOT + '/Tools/AP_Bootloader/'
        )
        bld.ap_stlib(name= 'JEDEC_libs',
                    ap_vehicle='AP_Bootloader',
                    ap_libraries= ['AP_FlashIface', 'AP_HAL_Empty'])
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           /*
   Please contribute your ideas! See https://ardupilot.org/dev for details

   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include <AP_HAL/AP_HAL.h>
#include <AP_FlashStorage/AP_FlashStorage.h>
#include <AP_Math/AP_Math.h>
#include <AP_InternalError/AP_InternalError.h>
#include <stdio.h>

#define FLASHSTORAGE_DEBUG 0

#if FLASHSTORAGE_DEBUG
#define debug(fmt, args...)  do { printf(fmt, ##args); } while(0)
#else
#define debug(fmt, args...)  do { } while(0)
#endif

// constructor.
AP_FlashStorage::AP_FlashStorage(uint8_t *_mem_buffer,
                                 uint32_t _flash_sector_size,
                                 FlashWrite _flash_write,
                                 FlashRead _flash_read,
                                 FlashErase _flash_erase,
                                 FlashEraseOK _flash_erase_ok) :
    mem_buffer(_mem_buffer),
    flash_sector_size(_flash_sector_size),
    flash_write(_flash_write),
    flash_read(_flash_read),
    flash_erase(_flash_erase),
    flash_erase_ok(_flash_erase_ok) {}

// initialise storage
bool AP_FlashStorage::init(void)
{
    debug("running init()\n");

    // start with empty memory buffer
    memset(mem_buffer, 0, storage_size);

    // find state of sectors
    struct sector_header header[2];

    // read headers and possibly initialise if bad signature
    for (uint8_t i=0; i<2; i++) {
        if (!flash_read(i, 0, (uint8_t *)&header[i], sizeof(header[i]))) {
            return false;
        }
        bool bad_header = !header[i].signature_ok();
        enum SectorState state = header[i].get_state();
        if (state != SECTOR_STATE_AVAILABLE &&
            state != SECTOR_STATE_IN_USE &&
            state != SECTOR_STATE_FULL) {
            bad_header = true;
        }

        // initialise if bad header
        if (bad_header) {
            return erase_all();
        }
    }

    // work out the first sector to read from using sector states
    enum SectorState states[2] {header[0].get_state(), header[1].get_state()};
    uint8_t first_sector;

    if (states[0] == states[1]) {
        if (states[0] != SECTOR_STATE_AVAILABLE) {
            return erase_all();
        }
        first_sector = 0;
    } else if (states[0] == SECTOR_STATE_FULL) {
        first_sector = 0;
    } else if (states[1] == SECTOR_STATE_FULL) {
        first_sector = 1;
    } else if (states[0] == SECTOR_STATE_IN_USE) {
        first_sector = 0;
    } else if (states[1] == SECTOR_STATE_IN_USE) {
        first_sector = 1;
    } else {
        // doesn't matter which is first
        first_sector = 0;
    }

    // load data from any current sectors
    for (uint8_t i=0; i<2; i++) {
        uint8_t sector = (first_sector + i) & 1;
        if (states[sector] == SECTOR_STATE_IN_USE ||
            states[sector] == SECTOR_STATE_FULL) {
            if (!load_sector(sector)) {
                return erase_all();
            }
        }
    }

    // clear any write error
    write_error = false;
    reserved_space = 0;
    
    // if the first sector is full then write out all data so we can erase it
    if (states[first_sector] == SECTOR_STATE_FULL) {
        current_sector = first_sector ^ 1;
        if (!write_all()) {
            return erase_all();
        }
    }

    // erase any sectors marked full
    for (uint8_t i=0; i<2; i++) {
        if (states[i] == SECTOR_STATE_FULL) {
            if (!erase_sector(i, true)) {
                return false;
            }
        }
    }

    reserved_space = 0;
    
    // ready to use
    return true;
}



// switch full sector - should only be called when safe to have CPU
// offline for considerable periods as an erase will be needed
bool AP_FlashStorage::switch_full_sector(void)
{
    debug("running switch_full_sector()\n");

    if (in_switch_full_sector) {
        INTERNAL_ERROR(AP_InternalError::error_t::switch_full_sector_recursion);
        return false;
    }
    in_switch_full_sector = true;
    bool ret = protected_switch_full_sector();
    in_switch_full_sector = false;
    return ret;
}

// protected_switch_full_sector is protected by switch_full_sector to
// avoid an infinite recursion problem; switch_full_sector calls
// write() which can call switch_full_sector.  This has been seen in
// practice, and while it might be caused by corruption... corruption
// happens.
bool AP_FlashStorage::protected_switch_full_sector(void)
{
    // clear any write error
    write_error = false;
    reserved_space = 0;
    
    if (!write_all()) {
        return false;
    }

    if (!erase_sector(current_sector ^ 1, true)) {
        return false;
    }

    return switch_sectors();
}

// write some data to virtual EEPROM
bool AP_FlashStorage::write(uint16_t offset, uint16_t length)
{
    if (write_error) {
        return false;
    }
    //debug("write at %u for %u write_offset=%u\n", offset, length, write_offset);
    
    while (length > 0) {
        uint8_t n = max_write;
#if AP_FLASHSTORAGE_TYPE != AP_FLASHSTORAGE_TYPE_H7 && AP_FLASHSTORAGE_TYPE != AP_FLASHSTORAGE_TYPE_G4
        if (length < n) {
            n = length;
        }
#endif

        const uint32_t space_available = flash_sector_size - write_offset;
        const uint32_t space_required = sizeof(struct block_header) + max_write + reserved_space;
        if (space_available < space_required) {
            if (!switch_sectors()) {
                if (!flash_erase_ok()) {
                    return false;
                }
                if (!switch_full_sector()) {
                    return false;                    
                }
            }
        }

        struct PACKED {
            struct block_header header;
            uint8_t data[max_write];
        } blk;

        blk.header.state = BLOCK_STATE_WRITING;
        blk.header.block_num = offset / block_size;
        blk.header.num_blocks_minus_one = ((n + (block_size - 1)) / block_size)-1;

        uint16_t block_ofs = blk.header.block_num*block_size;
        uint16_t block_nbytes = (blk.header.num_blocks_minus_one+1)*block_size;

        memcpy(blk.data, &mem_buffer[block_ofs], block_nbytes);

#if AP_FLASHSTORAGE_TYPE == AP_FLASHSTORAGE_TYPE_F4
        if (!flash_write(current_sector, write_offset, (uint8_t*)&blk.header, sizeof(blk.header))) {
            return false;
        }
        if (!flash_write(current_sector, write_offset+sizeof(blk.header), blk.data, block_nbytes)) {
            return false;
        }
        blk.header.state = BLOCK_STATE_VALID;
        if (!flash_write(current_sector, write_offset, (uint8_t*)&blk.header, sizeof(blk.header))) {
            return false;
        }
#elif AP_FLASHSTORAGE_TYPE == AP_FLASHSTORAGE_TYPE_F1
        blk.header.state = BLOCK_STATE_VALID;
        if (!flash_write(current_sector, write_offset, (uint8_t*)&blk, sizeof(blk.header) + block_nbytes)) {
            return false;
        }
#elif AP_FLASHSTORAGE_TYPE == AP_FLASHSTORAGE_TYPE_H7 || AP_FLASHSTORAGE_TYPE == AP_FLASHSTORAGE_TYPE_G4
        blk.header.state = BLOCK_STATE_VALID;
        if (!flash_write(current_sector, write_offset, (uint8_t*)&blk, sizeof(blk.header) + max_write)) {
            return false;
        }
#endif

        write_offset += sizeof(blk.header) + block_nbytes;

        uint8_t n2 = block_nbytes - (offset % block_size);
        //debug("write_block at %u for %u n2=%u\n", block_ofs, block_nbytes, n2);
        if (n2 > length) {
            break;
        }
        offset += n2;
        length -= n2;
    }

    //debug("write_offset %u\n", write_offset);

    // handle wrap to next sector
    // write data
    // write header word
    return true;
}

/*
  load all data from a flash sector into mem_buffer
 */
bool AP_FlashStorage::load_sector(uint8_t sector)
{
    uint32_t ofs = sizeof(sector_header);
    while (ofs < flash_sector_size - sizeof(struct block_header)) {
        struct block_header header;
        if (!flash_read(sector, ofs, (uint8_t *)&header, sizeof(header))) {
            return false;
        }
        enum BlockState state = (enum BlockState)header.state;

        switch (state) {
        case BLOCK_STATE_AVAILABLE:
            // we've reached the end
            write_offset = ofs;
            return true;

        case BLOCK_STATE_WRITING: {
            /*
              we were interrupted while writing a block. We can't
              re-use the data in this block as it may have some bits
              that are not set to 1, so by flash rules can't be set to
              an arbitrary value. So we skip over this block, leaving
              a gap. The gap size is limited to (7+1)*8=64 bytes. That
              gap won't be recovered until we next do an erase of this
              sector
             */
            uint16_t block_nbytes = (header.num_blocks_minus_one+1)*block_size;
            ofs += block_nbytes + sizeof(header);
            break;
        }
            
        case BLOCK_STATE_VALID: {
            uint16_t block_nbytes = (header.num_blocks_minus_one+1)*block_size;
            uint16_t block_ofs = header.block_num*block_size;
            if (block_ofs + block_nbytes > storage_size) {
                // the data is invalid (out of range)
                return false;
            }
            if (!flash_read(sector, ofs+sizeof(header), &mem_buffer[block_ofs], block_nbytes)) {
                return false;
            }
            //debug("read at %u for %u\n", block_ofs, block_nbytes);
            ofs += block_nbytes + sizeof(header);
            break;
        }
        default:
            // invalid state
            return false;
        }
#if AP_FLASHSTORAGE_TYPE == AP_FLASHSTORAGE_TYPE_H7
        // offsets must be advanced to a multiple of 32 on H7
        ofs = (ofs + 31U) & ~31U;
#elif AP_FLASHSTORAGE_TYPE == AP_FLASHSTORAGE_TYPE_G4
        // offsets must be advanced to a multiple of 8 on G4
        ofs = (ofs + 7U) & ~7U;
#endif
    }
    write_offset = ofs;
    return true;
}

/*
  erase one sector
 */
bool AP_FlashStorage::erase_sector(uint8_t sector, bool mark_available)
{
    if (!flash_erase(sector)) {
        return false;
    }
    if (!mark_available) {
        return true;
    }
    struct sector_header header;
    header.set_state(SECTOR_STATE_AVAILABLE);
    return flash_write(sector, 0, (const uint8_t *)&header, sizeof(header));
}

/*
  erase both sectors
 */
bool AP_FlashStorage::erase_all(void)
{
    write_error = false;

    current_sector = 0;
    write_offset = sizeof(struct sector_header);
    
    if (!erase_sector(0, current_sector!=0)) {
        return false;
    }
    if (!erase_sector(1, current_sector!=1)) {
        return false;
    }
    
    // mark current sector as in-use
    struct sector_header header;
    header.set_state(SECTOR_STATE_IN_USE);
    return flash_write(current_sector, 0, (const uint8_t *)&header, sizeof(header));    
}

/*
  write all of mem_buffer to current sector
 */
bool AP_FlashStorage::write_all()
{
    debug("write_all to sector %u at %u with reserved_space=%u\n",
           current_sector, write_offset, reserved_space);
    for (uint16_t ofs=0; ofs<storage_size; ofs += max_write) {
        // local variable needed to overcome problem with MIN() macro and -O0
        const uint8_t max_write_local = max_write;
        uint8_t n = MIN(max_write_local, storage_size-ofs);
        if (!all_zero(ofs, n)) {
            if (!write(ofs, n)) {
                return false;
            }
        }
    }
    return true;
}

// return true if all bytes are zero
bool AP_FlashStorage::all_zero(uint16_t ofs, uint16_t size)
{
    while (size--) {
        if (mem_buffer[ofs++] != 0) {
            return false;
        }
    }
    return true;
}

// switch to next sector for writing
bool AP_FlashStorage::switch_sectors(void)
{
    if (reserved_space != 0) {
        // other sector is already full
        debug("both sectors are full\n");
        return false;
    }

    struct sector_header header;

    uint8_t new_sector = current_sector ^ 1;
    debug("switching to sector %u\n", new_sector);
    
    // check sector is available
    if (!flash_read(new_sector, 0, (uint8_t *)&header, sizeof(header))) {
        return false;
    }
    if (!header.signature_ok()) {
        write_error = true;
        return false;
    }
    if (SECTOR_STATE_AVAILABLE != header.get_state()) {
        write_error = true;
        debug("new sector unavailable; state=0x%02x\n", (unsigned)header.get_state());
        return false;
    }

    // mark current sector as full. This needs to be done before we
    // mark the new sector as in-use so that a power failure between
    // the two steps doesn't leave us with an erase on the
    // reboot. Thanks to night-ghost for spotting this.
    header.set_state(SECTOR_STATE_FULL);
    if (!flash_write(current_sector, 0, (const uint8_t *)&header, sizeof(header))) {
        return false;
    }

    // mark new sector as in-use
    header.set_state(SECTOR_STATE_IN_USE);
    if (!flash_write(new_sector, 0, (const uint8_t *)&header, sizeof(header))) {
        return false;
    }

    // switch sectors
    current_sector = new_sector;
        
    // we need to reserve some space in next sector to ensure we can successfully do a
    // full write out on init()
    reserved_space = reserve_size;
    
    write_offset = sizeof(header);
    return true;    
}

/*
  re-initialise, using current mem_buffer
 */
bool AP_FlashStorage::re_initialise(void)
{
    if (!flash_erase_ok()) {
        return false;
    }
    if (!erase_all()) {
        return false;        
    }
    return write_all();
}

#if AP_FLASHSTORAGE_TYPE == AP_FLASHSTORAGE_TYPE_H7
/*
  H7 specific sector header functions
 */
bool AP_FlashStorage::sector_header::signature_ok(void) const
{
    for (uint8_t i=0; i<ARRAY_SIZE(pad1); i++) {
        if (pad1[i] != 0xFFFFFFFFU || pad2[i] != 0xFFFFFFFFU || pad3[i] != 0xFFFFFFFFU) {
            return false;
        }
    }
    return signature1 == signature;
}

AP_FlashStorage::SectorState AP_FlashStorage::sector_header::get_state(void) const
{
    if (state1 == 0xFFFFFFF1 &&
        state2 == 0xFFFFFFFF &&
        state3 == 0xFFFFFFFF &&
        signature1 == signature &&
        signature2 == 0xFFFFFFFF &&
        signature3 == 0xFFFFFFFF) {
        return SECTOR_STATE_AVAILABLE;
    }
    if (state1 == 0xFFFFFFF1 &&
        state2 == 0xFFFFFFF2 &&
        state3 == 0xFFFFFFFF &&
        signature1 == signature &&
        signature2 == signature &&
        signature3 == 0xFFFFFFFF) {
        return SECTOR_STATE_IN_USE;
    }
    if (state1 == 0xFFFFFFF1 &&
        state2 == 0xFFFFFFF2 &&
        state3 == 0xFFFFFFF3 &&
        signature1 == signature &&
        signature2 == signature &&
        signature3 == signature) {
        return SECTOR_STATE_FULL;
    }
    return SECTOR_STATE_INVALID;
}

void AP_FlashStorage::sector_header::set_state(SectorState state)
{
    memset(pad1, 0xff, sizeof(pad1));
    memset(pad2, 0xff, sizeof(pad2));
    memset(pad3, 0xff, sizeof(pad3));
    switch (state) {
    case SECTOR_STATE_AVAILABLE:
        signature1 = signature;
        signature2 = 0xFFFFFFFF;
        signature3 = 0xFFFFFFFF;
        state1 = 0xFFFFFFF1;
        state2 = 0xFFFFFFFF;
        state3 = 0xFFFFFFFF;
        break;
    case SECTOR_STATE_IN_USE:
        signature1 = signature;
        signature2 = signature;
        signature3 = 0xFFFFFFFF;
        state1 = 0xFFFFFFF1;
        state2 = 0xFFFFFFF2;
        state3 = 0xFFFFFFFF;
        break;
    case SECTOR_STATE_FULL:
        signature1 = signature;
        signature2 = signature;
        signature3 = signature;
        state1 = 0xFFFFFFF1;
        state2 = 0xFFFFFFF2;
        state3 = 0xFFFFFFF3;
        break;
    default:
        break;
    }
}

#elif AP_FLASHSTORAGE_TYPE == AP_FLASHSTORAGE_TYPE_G4
/*
  G4 specific sector header functions
 */
bool AP_FlashStorage::sector_header::signature_ok(void) const
{
    return signature1 == signature;
}

AP_FlashStorage::SectorState AP_FlashStorage::sector_header::get_state(void) const
{
    if (state1 == 0xFFFFFFF1 &&
        state2 == 0xFFFFFFFF &&
        state3 == 0xFFFFFFFF &&
        signature1 == signature &&
        signature2 == 0xFFFFFFFF &&
        signature3 == 0xFFFFFFFF) {
        return SECTOR_STATE_AVAILABLE;
    }
    if (state1 == 0xFFFFFFF1 &&
        state2 == 0xFFFFFFF2 &&
        state3 == 0xFFFFFFFF &&
        signature1 == signature &&
        signature2 == signature &&
        signature3 == 0xFFFFFFFF) {
        return SECTOR_STATE_IN_USE;
    }
    if (state1 == 0xFFFFFFF1 &&
        state2 == 0xFFFFFFF2 &&
        state3 == 0xFFFFFFF3 &&
        signature1 == signature &&
        signature2 == signature &&
        signature3 == signature) {
        return SECTOR_STATE_FULL;
    }
    return SECTOR_STATE_INVALID;
}

void AP_FlashStorage::sector_header::set_state(SectorState state)
{
    switch (state) {
    case SECTOR_STATE_AVAILABLE:
        signature1 = signature;
        signature2 = 0xFFFFFFFF;
        signature3 = 0xFFFFFFFF;
        state1 = 0xFFFFFFF1;
        state2 = 0xFFFFFFFF;
        state3 = 0xFFFFFFFF;
        break;
    case SECTOR_STATE_IN_USE:
        signature1 = signature;
        signature2 = signature;
        signature3 = 0xFFFFFFFF;
        state1 = 0xFFFFFFF1;
        state2 = 0xFFFFFFF2;
        state3 = 0xFFFFFFFF;
        break;
    case SECTOR_STATE_FULL:
        signature1 = signature;
        signature2 = signature;
        signature3 = signature;
        state1 = 0xFFFFFFF1;
        state2 = 0xFFFFFFF2;
        state3 = 0xFFFFFFF3;
        break;
    default:
        break;
    }
}

#elif AP_FLASHSTORAGE_TYPE == AP_FLASHSTORAGE_TYPE_F1
/*
  F1/F3 specific sector header functions
 */
bool AP_FlashStorage::sector_header::signature_ok(void) const
{
    return signature1 == signature;
}

AP_FlashStorage::SectorState AP_FlashStorage::sector_header::get_state(void) const
{
    if (state1 == 0xFFFFFFFF) {
        return SECTOR_STATE_AVAILABLE;
    }
    if (state1 == 0xFFFFFFF1) {
        return SECTOR_STATE_IN_USE;
    }
    if (state1 == 0xFFF2FFF1) {
        return SECTOR_STATE_FULL;
    }
    return SECTOR_STATE_INVALID;
}

void AP_FlashStorage::sector_header::set_state(SectorState state)
{
    signature1 = signature;
    switch (state) {
    case SECTOR_STATE_AVAILABLE:
        state1 = 0xFFFFFFFF;
        break;
    case SECTOR_STATE_IN_USE:
        state1 = 0xFFFFFFF1;
        break;
    case SECTOR_STATE_FULL:
        state1 = 0xFFF2FFF1;
        break;
    default:
        break;
    }
}
#elif AP_FLASHSTORAGE_TYPE == AP_FLASHSTORAGE_TYPE_F4
/*
  F4 specific sector header functions
 */
bool AP_FlashStorage::sector_header::signature_ok(void) const
{
    return signature1 == signature;
}

AP_FlashStorage::SectorState AP_FlashStorage::sector_header::get_state(void) const
{
    if (state1 == 0xFF) {
        return SECTOR_STATE_AVAILABLE;
    }
    if (state1 == 0xFE) {
        return SECTOR_STATE_IN_USE;
    }
    if (state1 == 0xFC) {
        return SECTOR_STATE_FULL;
    }
    return SECTOR_STATE_INVALID;
}

void AP_FlashStorage::sector_header::set_state(SectorState state)
{
    signature1 = signature;
    switch (state) {
    case SECTOR_STATE_AVAILABLE:
        state1 = 0xFF;
        break;
    case SECTOR_STATE_IN_USE:
        state1 = 0xFE;
        break;
    case SECTOR_STATE_FULL:
        state1 = 0xFC;
        break;
    default:
        break;
    }
}
#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                          6|0|)|#|||||m|T{<{${{{{{{{y{a{I{0{{ {{{{{{n~{Vw{>q{&j{c{]{V{O{H{B{|;{d4{L-{3&{{{{{{zzrzZzBz*zzzzzzzzizQz9z!z	z}zuznzgz_zxXz`PzHIz0Bz:z 3z+z$zzzzpzXy@y(yyyyyyyyiyQy9y!y
yyyzyryjyzbycZyKRy3JyBy:y2y*y"yyyu	y]yEx-xxxxxxxxoxXx@x(xxx|xsxkxbxYxkQxSHx<@x$7x.x&xxxxxwhwPw8w!w	wwwwww|wewMw6~wuwlwcwZwQwGw>wz5wc,wK#w4wwwvvvvvyvbvKv3vvvvvv{vqvyhvb^vJTv3KvAv8v.v$vvvvzubuKu4uuuuuuuu{uduM}u6suiu_uUuKuAu7u-u~#uguPu9u"ttttttttjtSt<t%t~tttjt_tUtJt@tn5tX+tA t*tt tsssssts]sFs0ssssusjs_sTszIsd>sM3s6(s s	ssrrrrrkrUr>r(rrrrvrkr`rUrtIr]>rG3r0'rrrrqqqq}qgqQq:q$qqq{qoqdqXqLqrAq[5qE)q/qqqppppp}pgpQp;p%ppwpkp_pSpGp;pt/p^#pHp2
poooooooomoWoAo+woko_oRoFo9o-o o|ofoPn;n%nnnnnnnnw}napnKcn6Wn Jn
=n0n$nn
nmmsm^mHm2mmmmm|mombmUmqHm[:mF-m0 mmmllllllpl[lEl0ltlglYlLl?l1l$llp	l[kFk1kkkkkkkksksfk]XkHJk3=k/k	!kkkjjjjvjajLj7j"j{jmj_jQjCj5j'j{jfjRi=i(iiiiiii}ioimaiXSiDDi/6i(iiihhhhhvhahLh8h#{hlh^hOh@h2h#hhhkgWgBg.ggggggsgdgUgwFgb7gN)g:g&gffffffffpf\ufHff4WfHf9f)fffeeeekeWeCe/eeseceTeEe5e&ee|ehdTdAd-ddddd{dld\dMd{=dg-dTd@d,ccccccccc|qciacUQcAAc.1c!cccbbbbbblbXbEqb2abQbAb1b!bbbaaaqa^aKa7a$aoa^aNa>a-aaa`x`e`R`?`,```x`h`W`G`6`&``o`\_I_6_$_____n_^_M_<_{+_h_U
_C^0^^^^^^^q^`^P^v?^d-^Q^?^,]]]]]]]]q]`]tO]b>]P-]=]+
]\\\\\\\\n\u]\cK\Q:\?)\,\\[[[[[[[y[xh[fV[TE[B3[0![[ZZZZZZZZ~pZl^Z[MZI;Z7)Z%ZZYYYYYYYvYudYcRYR@Y@.Y/Y
YXXXXXXXyXgXoUX^BXL0X;X*XWWWWWWWyWgW}UWlBW[0WJW9W(VVVVVVVwVeVRV~@Vm-V\VKV:U)UUUUUUrU`UMU:U(UpU`UOT>T-TTTT~TkTXTET3T TTwSgSVSFS5S%SSuSbSNS;S(SSSRRqRaRPR@R0|R iRURBR/RRRQQQQ~QnQ^QNnQ>ZQ.GQ3Q QQPPPPPPPpPp]P`IPP6P@"P1P!OOOOOOOqO^OJO6Ou"OeOVNFN7N'NN	NNpN\NHN4N!NNM~MoM`MPMAM2M#mMYMEM1MM	MLLLLL|Lm|L^hLOTL@?L1+L"LLKKKKKKuKaKLK~8Kp$KaKRJCJ5J&JJ	JJlJXJCJ/JJJIIwIhIZIKI=vI/aI MI8I#IIHHHHHH~HiHtUHf@HX+HJH<H-GGGGGGpG[GFG1GGGFwFiF[FMF?F2uF$`FKF6F!FFEEEEEExEcEqNEd9EV$EHE;D-D DDDDzDeDPD;D%DDCCCqCdCWCI{C<eC/PC";C%CCBBBBBBzBdBOB9Bw$BjB]/*
  variant of SocketAPM using either lwip or native sockets
 */
#pragma once

#include <AP_HAL/AP_HAL.h>

#ifndef SOCKET_CLASS_NAME
#define SOCKET_CLASS_NAME SocketAPM
#endif

#include "Socket.hpp"

#undef SOCKET_CLASS_NAME
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              /*
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
/*
  simple socket handling class for systems with BSD socket API
 */

#include <AP_HAL/AP_HAL.h>
#include <AP_Networking/AP_Networking_Config.h>

#if AP_NETWORKING_SOCKETS_ENABLED || defined(AP_SOCKET_NATIVE_ENABLED)

#ifndef SOCKET_CLASS_NAME
#error "Don't include Socket.hpp directly"
#endif

#define IP4_STR_LEN 16

class SOCKET_CLASS_NAME {
public:
    SOCKET_CLASS_NAME(bool _datagram);
    SOCKET_CLASS_NAME(bool _datagram, int _fd);
    ~SOCKET_CLASS_NAME();

    bool connect(const char *address, uint16_t port);
    bool connect_timeout(const char *address, uint16_t port, uint32_t timeout_ms);
    bool bind(const char *address, uint16_t port);
    bool reuseaddress() const;
    bool set_blocking(bool blocking) const;
    bool set_cloexec() const;
    void set_broadcast(void) const;

    ssize_t send(const void *pkt, size_t size) const;
    ssize_t sendto(const void *buf, size_t size, const char *address, uint16_t port);
    ssize_t sendto(const void *buf, size_t size, uint32_t address, uint16_t port);
    ssize_t recv(void *pkt, size_t size, uint32_t timeout_ms);

    // return the IP address and port of the last received packet
    void last_recv_address(const char *&ip_addr, uint16_t &port) const;

    // return the IP address and port of the last received packet, using caller supplied buffer
    const char *last_recv_address(char *ip_addr_buf, uint8_t buflen, uint16_t &port) const;

    // return the IP address and port of the last received packet
    bool last_recv_address(uint32_t &ip_addr, uint16_t &port) const;

    // return true if there is pending data for input
    bool pollin(uint32_t timeout_ms);

    // return true if there is room for output data
    bool pollout(uint32_t timeout_ms);

    // start listening for new tcp connections
    bool listen(uint16_t backlog) const;

    // close socket
    void close(void);

    // accept a new connection. Only valid for TCP connections after
    // listen has been used. A new socket is returned
    SOCKET_CLASS_NAME *accept(uint32_t timeout_ms);

    // get a FD suitable for read selection
    int get_read_fd(void) const {
        return fd_in != -1? fd_in : fd;
    }

    // create a new socket with same fd, but new memory
    // the old socket gets fd of -1
    SOCKET_CLASS_NAME *duplicate(void);

    bool is_connected(void) const {
        return connected;
    }

    // access to inet_ntop
    static const char *inet_addr_to_str(uint32_t addr, char *dst, uint16_t len);

    // access to inet_pton
    static uint32_t inet_str_to_addr(const char *ipstr);
    
private:
    bool datagram;
    // we avoid using struct sockaddr_in here to keep support for
    // mixing native sockets and lwip sockets in SITL
    uint32_t last_in_addr[4];
    bool is_multicast_address(struct sockaddr_in &addr) const;

    int fd = -1;

    // fd_in is used for multicast UDP
    int fd_in = -1;

    bool connected;

    void make_sockaddr(const char *address, uint16_t port, struct sockaddr_in &sockaddr);
};

#endif // AP_NETWORKING_SOCKETS_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                     /*
  variant of SocketAPM using native sockets (not via lwip)
 */
#include <AP_HAL/AP_HAL_Boards.h>

#if CONFIG_HAL_BOARD == HAL_BOARD_SITL || CONFIG_HAL_BOARD == HAL_BOARD_LINUX
#include "Socket_native.h"

#if AP_SOCKET_NATIVE_ENABLED
#undef AP_NETWORKING_BACKEND_PPP
#define IN_SOCKET_NATIVE_CPP
#define SOCKET_CLASS_NAME SocketAPM_native
#include "Socket.cpp"
#endif

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      /*
  variant of SocketAPM using native sockets (not via lwip)
 */
#pragma once

#include <AP_HAL/AP_HAL.h>

#if CONFIG_HAL_BOARD == HAL_BOARD_SITL || CONFIG_HAL_BOARD == HAL_BOARD_LINUX
#define AP_SOCKET_NATIVE_ENABLED 1
#define SOCKET_CLASS_NAME SocketAPM_native
#ifndef AP_NETWORKING_SOCKETS_ENABLED
#define AP_NETWORKING_SOCKETS_ENABLED 1
#endif
#include "Socket.hpp"
#elif !AP_SIM_ENABLED
#error "attempt to use Socket_native.h without native sockets"
#endif

#undef SOCKET_CLASS_NAME



                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    /*
  DSM decoder, based on src/modules/px4iofirmware/dsm.c from PX4Firmware
  modified for use in AP_HAL_* by Andrew Tridgell
 */
/****************************************************************************
 *
 *   Copyright (c) 2012-2014 PX4 Development Team. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 * 3. Neither the name PX4 nor the names of its contributors may be
 *    used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
 * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 ****************************************************************************/

#include <stdint.h>
#include <stdio.h>

#include "dsm.h"

#define DSM_FRAME_SIZE		16		/**<DSM frame size in bytes*/
#define DSM_FRAME_CHANNELS	7		/**<Max supported DSM channels*/

static uint64_t dsm_last_frame_time;		/**< Timestamp for start of last dsm frame */
static unsigned dsm_channel_shift;			/**< Channel resolution, 0=unknown, 10=10 bit, 11=11 bit */

//#define DEBUG

#ifdef DEBUG
# define debug(fmt, args...)	printf(fmt "\n", ##args)
#else
# define debug(fmt, args...)	do {} while(0)
#endif

/**
 * Attempt to decode a single channel raw channel datum
 *
 * The DSM* protocol doesn't provide any explicit framing,
 * so we detect dsm frame boundaries by the inter-dsm frame delay.
 *
 * The minimum dsm frame spacing is 11ms; with 16 bytes at 115200bps
 * dsm frame transmission time is ~1.4ms.
 *
 * We expect to only be called when bytes arrive for processing,
 * and if an interval of more than 5ms passes between calls,
 * the first byte we read will be the first byte of a dsm frame.
 *
 * In the case where byte(s) are dropped from a dsm frame, this also
 * provides a degree of protection. Of course, it would be better
 * if we didn't drop bytes...
 *
 * Upon receiving a full dsm frame we attempt to decode it
 *
 * @param[in] raw 16 bit raw channel value from dsm frame
 * @param[in] shift position of channel number in raw data
 * @param[out] channel pointer to returned channel number
 * @param[out] value pointer to returned channel value
 * @return true=raw value successfully decoded
 */
static bool
dsm_decode_channel(uint16_t raw, unsigned shift, unsigned *channel, unsigned *value)
{

	if (raw == 0xffff)
		return false;

	*channel = (raw >> shift) & 0xf;

	uint16_t data_mask = (1 << shift) - 1;
	*value = raw & data_mask;

	//debug("DSM: %d 0x%04x -> %d %d", shift, raw, *channel, *value);

	return true;
}

/**
 * Attempt to guess if receiving 10 or 11 bit channel values
 *
 * @param[in] reset true=reset the 10/11 bit state to unknown
 */
static void
dsm_guess_format(bool reset, const uint8_t dsm_frame[16])
{
	static uint32_t	cs10;
	static uint32_t	cs11;
	static unsigned samples;

	/* reset the 10/11 bit sniffed channel masks */
	if (reset) {
		cs10 = 0;
		cs11 = 0;
		samples = 0;
		dsm_channel_shift = 0;
		return;
	}

	/* scan the channels in the current dsm_frame in both 10- and 11-bit mode */
	for (unsigned i = 0; i < DSM_FRAME_CHANNELS; i++) {

		const uint8_t *dp = &dsm_frame[2 + (2 * i)];
		uint16_t raw = (dp[0] << 8) | dp[1];
		unsigned channel, value;

		/* if the channel decodes, remember the assigned number */
		if (dsm_decode_channel(raw, 10, &channel, &value) && (channel < 31))
			cs10 |= (1 << channel);

		if (dsm_decode_channel(raw, 11, &channel, &value) && (channel < 31))
			cs11 |= (1 << channel);

		/* XXX if we cared, we could look for the phase bit here to decide 1 vs. 2-dsm_frame format */
	}

	/* wait until we have seen plenty of frames - 5 should normally be enough */
	if (samples++ < 5)
		return;

	/*
	 * Iterate the set of sensible sniffed channel sets and see whether
	 * decoding in 10 or 11-bit mode has yielded anything we recognize.
	 *
	 * XXX Note that due to what seem to be bugs in the DSM2 high-resolution
	 *     stream, we may want to sniff for longer in some cases when we think we
	 *     are talking to a DSM2 receiver in high-resolution mode (so that we can
	 *     reject it, ideally).
	 *     See e.g. http://git.openpilot.org/cru/OPReview-116 for a discussion
	 *     of this issue.
	 */
	static uint32_t masks[] = {
		0x3f,	/* 6 channels (DX6) */
		0x7f,	/* 7 channels (DX7) */
		0xff,	/* 8 channels (DX8) */
		0x1ff,	/* 9 channels (DX9, etc.) */
		0x3ff,	/* 10 channels (DX10) */
		0x1fff,	/* 13 channels (DX10t) */
		0x3fff	/* 18 channels (DX10) */
	};
	unsigned votes10 = 0;
	unsigned votes11 = 0;

	for (unsigned i = 0; i < sizeof(masks)/sizeof(masks[0]); i++) {

		if (cs10 == masks[i])
			votes10++;

		if (cs11 == masks[i])
			votes11++;
	}

	if ((votes11 == 1) && (votes10 == 0)) {
		dsm_channel_shift = 11;
		debug("DSM: 11-bit format");
		return;
	}

	if ((votes10 == 1) && (votes11 == 0)) {
		dsm_channel_shift = 10;
		debug("DSM: 10-bit format");
		return;
	}

	/* call ourselves to reset our state ... we have to try again */
	debug("DSM: format detect fail, 10: 0x%08x %u 11: 0x%08x %u", cs10, votes10, cs11, votes11);
	dsm_guess_format(true, dsm_frame);
}

/**
 * Decode the entire dsm frame (all contained channels)
 *
 */
bool
dsm_decode(uint64_t frame_time, const uint8_t dsm_frame[16], uint16_t *values, uint16_t *num_values, uint16_t max_values)
{
	/*
	debug("DSM dsm_frame %02x%02x %02x%02x %02x%02x %02x%02x %02x%02x %02x%02x %02x%02x %02x%02x",
		dsm_frame[0], dsm_frame[1], dsm_frame[2], dsm_frame[3], dsm_frame[4], dsm_frame[5], dsm_frame[6], dsm_frame[7],
		dsm_frame[8], dsm_frame[9], dsm_frame[10], dsm_frame[11], dsm_frame[12], dsm_frame[13], dsm_frame[14], dsm_frame[15]);
	*/
	/*
	 * If we have lost signal for at least a second, reset the
	 * format guessing heuristic.
	 */
	if (((frame_time - dsm_last_frame_time) > 1000000) && (dsm_channel_shift != 0))
            dsm_guess_format(true, dsm_frame);

	/* we have received something we think is a dsm_frame */
	dsm_last_frame_time = frame_time;

	/* if we don't know the dsm_frame format, update the guessing state machine */
	if (dsm_channel_shift == 0) {
            dsm_guess_format(false, dsm_frame);
            return false;
	}

	/*
	 * The encoding of the first two bytes is uncertain, so we're
	 * going to ignore them for now.
	 *
	 * Each channel is a 16-bit unsigned value containing either a 10-
	 * or 11-bit channel value and a 4-bit channel number, shifted
	 * either 10 or 11 bits. The MSB may also be set to indicate the
	 * second dsm_frame in variants of the protocol where more than
	 * seven channels are being transmitted.
	 */

	for (unsigned i = 0; i < DSM_FRAME_CHANNELS; i++) {

		const uint8_t *dp = &dsm_frame[2 + (2 * i)];
		uint16_t raw = (dp[0] << 8) | dp[1];
		unsigned channel, value;

		if (!dsm_decode_channel(raw, dsm_channel_shift, &channel, &value))
			continue;

		/* ignore channels out of range */
		if (channel >= max_values)
			continue;

		/* update the decoded channel count */
		if (channel >= *num_values)
			*num_values = channel + 1;

		/* convert 0-1024 / 0-2048 values to 1000-2000 ppm encoding. */
		if (dsm_channel_shift == 10)
			value *= 2;

		/*
		 * Spektrum scaling is special. There are these basic considerations
		 *
		 *   * Midpoint is 1520 us
		 *   * 100% travel channels are +- 400 us
		 *
		 * We obey the original Spektrum scaling (so a default setup will scale from
		 * 1100 - 1900 us), but we do not obey the weird 1520 us center point
		 * and instead (correctly) center the center around 1500 us. This is in order
		 * to get something useful without requiring the user to calibrate on a digital
		 * link for no reason.
		 */

		/* scaled integer for decent accuracy while staying efficient */
		value = ((((int)value - 1024) * 1000) / 1700) + 1500;

		/*
		 * Store the decoded channel into the R/C input buffer, taking into
		 * account the different ideas about channel assignement that we have.
		 *
		 * Specifically, the first four channels in rc_channel_data are roll, pitch, thrust, yaw,
		 * but the first four channels from the DSM receiver are thrust, roll, pitch, yaw.
		 */
		switch (channel) {
		case 0:
			channel = 2;
			break;

		case 1:
			channel = 0;
			break;

		case 2:
			channel = 1;
            break;

		default:
			break;
		}

		values[channel] = value;
	}

	/*
	 * Spektrum likes to send junk in higher channel numbers to fill
	 * their packets. We don't know about a 13 channel model in their TX
	 * lines, so if we get a channel count of 13, we'll return 12 (the last
	 * data index that is stable).
	 */
	if (*num_values == 13)
		*num_values = 12;

#if 0
	if (dsm_channel_shift == 11) {
		/* Set the 11-bit data indicator */
		*num_values |= 0x8000;
	}
#endif

	/*
	 * XXX Note that we may be in failsafe here; we need to work out how to detect that.
	 */
	return true;
}

#if defined(TEST_MAIN_PROGRAM) || defined(TEST_HEX_STRING)
static uint8_t dsm_partial_frame_count;
static uint8_t dsm_frame[DSM_FRAME_SIZE];
static enum DSM_DECODE_STATE {
	DSM_DECODE_STATE_DESYNC = 0,
	DSM_DECODE_STATE_SYNC
} dsm_decode_state = DSM_DECODE_STATE_DESYNC;
static uint64_t dsm_last_rx_time;            /**< Timestamp when we last received data */
static uint16_t dsm_chan_count;
static uint16_t dsm_frame_drops;

static bool
dsm_parse(uint64_t now, uint8_t *frame, unsigned len, uint16_t *values,
	  uint16_t *num_values, bool *dsm_11_bit, unsigned *frame_drops, uint16_t max_channels)
{

	/* this is set by the decoding state machine and will default to false
	 * once everything that was decodable has been decoded.
	 */
	bool decode_ret = false;

	/* keep decoding until we have consumed the buffer */
	for (unsigned d = 0; d < len; d++) {

		/* overflow check */
		if (dsm_partial_frame_count == sizeof(dsm_frame) / sizeof(dsm_frame[0])) {
			dsm_partial_frame_count = 0;
			dsm_decode_state = DSM_DECODE_STATE_DESYNC;
#ifdef DSM_DEBUG
			printf("DSM: RESET (BUF LIM)\n");
#endif
		}

		if (dsm_partial_frame_count == DSM_FRAME_SIZE) {
			dsm_partial_frame_count = 0;
			dsm_decode_state = DSM_DECODE_STATE_DESYNC;
#ifdef DSM_DEBUG
			printf("DSM: RESET (PACKET LIM)\n");
#endif
		}

#ifdef DSM_DEBUG
#if 1
		printf("dsm state: %s%s, count: %d, val: %02x\n",
		       (dsm_decode_state == DSM_DECODE_STATE_DESYNC) ? "DSM_DECODE_STATE_DESYNC" : "",
		       (dsm_decode_state == DSM_DECODE_STATE_SYNC) ? "DSM_DECODE_STATE_SYNC" : "",
		       dsm_partial_frame_count,
		       (unsigned)frame[d]);
#endif
#endif

		switch (dsm_decode_state) {
		case DSM_DECODE_STATE_DESYNC:

			/* we are de-synced and only interested in the frame marker */
			if ((now - dsm_last_rx_time) > 5000) {
				printf("resync %u\n", dsm_partial_frame_count);
				dsm_decode_state = DSM_DECODE_STATE_SYNC;
				dsm_partial_frame_count = 0;
				dsm_chan_count = 0;
				dsm_frame[dsm_partial_frame_count++] = frame[d];
			}

			break;

		case DSM_DECODE_STATE_SYNC: {
				dsm_frame[dsm_partial_frame_count++] = frame[d];

				/* decode whatever we got and expect */
				if (dsm_partial_frame_count < DSM_FRAME_SIZE) {
					break;
				}

				/*
				 * Great, it looks like we might have a frame.  Go ahead and
				 * decode it.
				 */
				decode_ret = dsm_decode(now, dsm_frame, values, &dsm_chan_count, max_channels);

#if 1
                                printf("%u %u: ", ((unsigned)(now/1000)) % 1000000, len);
                                for (uint8_t i=0; i<DSM_FRAME_SIZE; i++) {
                                    printf("%02x ", (unsigned)dsm_frame[i]);
                                }
                                printf("\n");
#endif
	
                                
				/* we consumed the partial frame, reset */
				dsm_partial_frame_count = 0;

				/* if decoding failed, set proto to desync */
				if (decode_ret == false) {
					dsm_decode_state = DSM_DECODE_STATE_DESYNC;
					dsm_frame_drops++;
					printf("drop ");
					for (uint8_t i=0; i<DSM_FRAME_SIZE; i++) {
						printf("%02x ", (unsigned)dsm_frame[i]);
					}
					printf("\n");
				}
			}
			break;

		default:
#ifdef DSM_DEBUG
			printf("UNKNOWN PROTO STATE");
#endif
			decode_ret = false;
		}


	}

	if (frame_drops) {
		*frame_drops = dsm_frame_drops;
	}

	if (decode_ret) {
		*num_values = dsm_chan_count;
	}

	dsm_last_rx_time = now;

	/* return false as default */
	return decode_ret;
}
#endif


#ifdef TEST_MAIN_PROGRAM
/*
  test harness for use under Linux with USB serial adapter
 */
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <time.h>
#include <unistd.h>
#include <stdlib.h>
#include <termios.h>
#include <string.h>

static uint64_t micros64(void)
{
    struct timespec ts;
    clock_gettime(CLOCK_MONOTONIC, &ts);
    return 1.0e6*((ts.tv_sec + (ts.tv_nsec*1.0e-9)));
}

int main(int argc, const char *argv[])
{
    int fd = open(argv[1], O_RDONLY|O_CLOEXEC);
    if (fd == -1) {
        perror(argv[1]);
        exit(1);
    }

    struct termios options;

    tcgetattr(fd, &options);

    cfsetispeed(&options, B115200);
    cfsetospeed(&options, B115200);

    options.c_cflag &= ~(PARENB|CSTOPB|CSIZE);
    options.c_cflag |= CS8;

    options.c_lflag &= ~(ICANON|ECHO|ECHOE|ISIG);
    options.c_iflag &= ~(IXON|IXOFF|IXANY);
    options.c_oflag &= ~OPOST;

    if (tcsetattr(fd, TCSANOW, &options) != 0) {
        perror("tcsetattr");
        exit(1);
    }
    tcflush(fd, TCIOFLUSH);

    uint16_t values[18];
    memset(values, 0, sizeof(values));

    while (true) {
        uint8_t b[16];
        uint16_t num_values = 0;
        fd_set fds;
        struct timeval tv;
    
        FD_ZERO(&fds);
        FD_SET(fd, &fds);

        tv.tv_sec = 1;
        tv.tv_usec = 0;

        // check if any bytes are available
        if (select(fd+1, &fds, nullptr, nullptr, &tv) != 1) {
            break;
        }

        ssize_t nread;
        if ((nread = read(fd, b, sizeof(b))) < 1) {
            break;
        }

        bool dsm_11_bit;
        unsigned frame_drops;
        
        if (dsm_parse(micros64(), b, nread, values, &num_values, &dsm_11_bit, &frame_drops, 18)) {
#if 1
            printf("%u: ", num_values);
            for (uint8_t i=0; i<num_values; i++) {
                printf("%u:%4u ", i+1, values[i]);
            }
            printf("\n");
#endif
        }
    }
}
#elif defined(TEST_HEX_STRING)
/*
  test harness providing hex string to decode
 */
#include <string.h>

int main(int argc, const char *argv[])
{
    uint8_t b[16];
    uint64_t t = 0;

    for (uint8_t i=1; i<argc; i++) {
        unsigned v;
        if (sscanf(argv[i], "%02x", &v) != 1 || v > 255) {
            printf("Bad hex value at %u : %s\n", (unsigned)i, argv[i]);
            return 1;
        }
        b[i-1] = v;
    }
    uint16_t values[18];
    memset(values, 0, sizeof(values));
    
    while (true) {
        uint16_t num_values = 0;
        bool dsm_11_bit;
        unsigned frame_drops;

        t += 11000;
        
        if (dsm_parse(t, b, sizeof(b), values, &num_values, &dsm_11_bit, &frame_drops, 18)) {
#if 1
            printf("%u: ", num_values);
            for (uint8_t i=0; i<num_values; i++) {
                printf("%u:%4u ", i+1, values[i]);
            }
            printf("\n");
#endif
        }
    }
}
#endif
                                                                                 /*
  declaration of dsm_decode from dsm.cpp
 */
bool dsm_decode(uint64_t frame_time, const uint8_t dsm_frame[16], 
                uint16_t *values, 
                uint16_t *num_values, 
                uint16_t max_values);

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            /* Copyright (c) 2005, Dmitry Xmelkov
   All rights reserved.

   Rewritten in C by Soren Kuula

   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions are met:

   * Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.
   * Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in
     the documentation and/or other materials provided with the
     distribution.
   * Neither the name of the copyright holders nor the names of
     contributors may be used to endorse or promote products derived
     from this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE. */

#include "ftoa_engine.h"

#include <stdint.h>

#include <AP_Common/AP_Common.h>
#include <AP_HAL/AP_HAL.h>

/*
 * 2^b ~= f * r * 10^e
 * where
 * i = b div 8
 * r = 2^(b mod 8)
 * f = factorTable[i]
 * e = exponentTable[i]
 */
static const int8_t exponentTable[32] = {
    -36, -33, -31, -29, -26, -24, -21, -19,
    -17, -14, -12, -9,  -7, -4, -2,  0,
    3, 5, 8, 10, 12, 15,  17, 20,
    22, 24, 27, 29,  32, 34, 36, 39
};

static const uint32_t factorTable[32] = {
    2295887404UL,
    587747175UL,
    1504632769UL,
    3851859889UL,
    986076132UL,
    2524354897UL,
    646234854UL,
    1654361225UL,
    4235164736UL,
    1084202172UL,
    2775557562UL,
    710542736UL,
    1818989404UL,
    465661287UL,
    1192092896UL,
    3051757813UL,
    781250000UL,
    2000000000UL,
    512000000UL,
    1310720000UL,
    3355443200UL,
    858993459UL,
    2199023256UL,
    562949953UL,
    1441151881UL,
    3689348815UL,
    944473297UL,
    2417851639UL,
    618970020UL,
    1584563250UL,
    4056481921UL,
    1038459372UL
};

int16_t ftoa_engine(float val, char *buf, uint8_t precision, uint8_t maxDecimals) 
{
    uint8_t flags;

    // Bit reinterpretation hacks. This will ONLY work on little endian machines.
    uint8_t *valbits = (uint8_t*)&val;
    union {
        float v;
        uint32_t u;
    } x;
    x.v = val;
    uint32_t frac = x.u & 0x007fffffUL;

    if (precision>7) precision=7;

    // Read the sign, shift the exponent in place and delete it from frac.
    if (valbits[3] & (1<<7)) flags = FTOA_MINUS; else flags = 0;
    uint8_t exp = valbits[3]<<1;
    if(valbits[2] & (1<<7)) exp++;    // TODO possible but in case of subnormal

    // Test for easy cases, zero and NaN
    if(exp==0 && frac==0) {
        buf[0] = flags | FTOA_ZERO;
        uint8_t i;
        for(i=0; i<=precision; i++) {
            buf[i+1] = '0';
        }
        return 0;
    }

    if(exp == 0xff) {
        if(frac == 0) flags |= FTOA_INF; else flags |= FTOA_NAN;
    }

    // The implicit leading 1 is made explicit, except if value subnormal.
    if (exp != 0) frac |= (1UL<<23);

    uint8_t idx = exp>>3;
    int8_t exp10 = exponentTable[idx];

    // We COULD try making the multiplication in situ, where we make
    // frac and a 64 bit int overlap in memory and select/weigh the
    // upper 32 bits that way. For starters, this is less risky:
    int64_t prod = (int64_t)frac * (int64_t)factorTable[idx];

    // The expConvFactorTable are factor are correct iff the lower 3 exponent
    // bits are 1 (=7). Else we need to compensate by dividing frac.
    // If the lower 3 bits are 7 we are right.
    // If the lower 3 bits are 6 we right-shift once
    // ..
    // If the lower 3 bits are 0 we right-shift 7x
    prod >>= (15-(exp & 7));

    // Now convert to decimal.
    uint8_t hadNonzeroDigit = 0; // a flag
    uint8_t outputIdx = 0;
    int64_t decimal = 100000000000000ull;

    do {
        char digit = '0';
        while(1) {// find the first nonzero digit or any of the next digits.
            while ((prod -= decimal) >= 0)
                digit++;
            // Now we got too low. Fix it by adding again, once.
            // it might appear more efficient to check before subtract, or
            // to save and restore last nonnegative value - but in fact
            // they take as long time and more space.
            prod += decimal;
            decimal /= 10;

            // If already found a leading nonzero digit, accept zeros.
            if (hadNonzeroDigit) break;

            // Else, don't return results with a leading zero! Instead
            // skip those and decrement exp10 accordingly.
            if(digit == '0') {
                exp10--;
                continue;
            }

            hadNonzeroDigit = 1;

            // Compute how many digits N to output.
            if(maxDecimals != 0) {                        // If limiting decimals...
                int8_t beforeDP = exp10+1;                // Digits before point
                if (beforeDP < 1) beforeDP = 1;            // Numbers < 1 should also output at least 1 digit.
                /*
                 * Below a simpler version of this:
                int8_t afterDP = outputNum - beforeDP;
                if (afterDP > maxDecimals-1)
                    afterDP = maxDecimals-1;
                outputNum = beforeDP + afterDP;
                */
                maxDecimals = maxDecimals+beforeDP-1;
                if (precision > maxDecimals)
                    precision = maxDecimals;

            } else {
                precision++;                            // Output one more digit than the param value.
            }

            break;
        }

        // Now have a digit.
        outputIdx++;
        if(digit < '0' + 10) // normal case.
            buf[outputIdx] = digit;
        else {
            // Abnormal case, write 9s and bail.
            // We might as well abuse hadNonzeroDigit as counter, it will not be used again.
            for(hadNonzeroDigit=outputIdx; hadNonzeroDigit>0; hadNonzeroDigit--)
                buf[hadNonzeroDigit] = '9';
            goto roundup; // this is ugly but it _is_ code derived from assembler :)
        }
    } while (outputIdx<precision);

    // Rounding:
    decimal *= 10;

    if (prod - (decimal >> 1) >= 0) {

    roundup:
        // Increment digit, cascade
        while(outputIdx != 0) {
            if(++buf[outputIdx] == '0' + 10) {
                if(outputIdx == 1) {
                    buf[outputIdx] = '1';
                    exp10++;
                    flags |= FTOA_CARRY;
                    break;
                } else
                    buf[outputIdx--] = '0'; // and the loop continues, carrying to next digit.
            }
            else break;
        }
    }

    buf[0] = flags;
    return exp10;
}

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  /* Copyright (c) 2005, Dmitry Xmelkov
   All rights reserved.

   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions are met:

   * Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.
   * Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in
     the documentation and/or other materials provided with the
     distribution.
   * Neither the name of the copyright holders nor the names of
     contributors may be used to endorse or promote products derived
     from this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE. */

/* $Id: ftoa_engine.h 1218 2007-02-18 13:18:41Z dmix $ */
#pragma once

#include <AP_HAL/AP_HAL.h>
#include <stdint.h>

int16_t ftoa_engine(float val, char *buf,
		    uint8_t precision, uint8_t maxDecimals);

/* '__ftoa_engine' return next flags (in buf[0]):	*/
#define	FTOA_MINUS	1
#define	FTOA_ZERO	2
#define	FTOA_INF	4
#define	FTOA_NAN	8
#define	FTOA_CARRY	16	/* Carry was to master position.	*/
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               /*
 * Copyright (C) 2015  Intel Corporation. All rights reserved.
 *
 * This file is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This file is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#pragma once

#include <type_traits>

#define FUNCTOR_TYPEDEF(name, rettype, ...) \
    typedef Functor<rettype, ## __VA_ARGS__> name

#define FUNCTOR_DECLARE(name, rettype, ...) \
    Functor<rettype, ## __VA_ARGS__> name

#define FUNCTOR_BIND(obj, func, rettype, ...) \
    Functor<rettype, ## __VA_ARGS__>::bind<std::remove_reference<decltype(*obj)>::type, func>(obj)

#define FUNCTOR_BIND_MEMBER(func, rettype, ...) \
    Functor<rettype, ## __VA_ARGS__>::bind<std::remove_reference<decltype(*this)>::type, func>(this)

template <class RetType, class... Args>
class Functor
{
public:
    constexpr Functor(void *obj, RetType (*method)(void *obj, Args...))
        : _obj(obj)
        , _method(method)
    {
    }

    // Allow to construct an empty Functor
    constexpr Functor(decltype(nullptr))
        : Functor(nullptr, nullptr) { }

    constexpr Functor()
        : Functor(nullptr, nullptr) { }

    // Call the method on the obj this Functor is bound to
    RetType operator()(Args... args) const
    {
        return _method(_obj, args...);
    }

    // Compare if the two Functors are calling the same method in the same
    // object
    inline bool operator==(const Functor<RetType, Args...>& rhs)
    {
        return _obj == rhs._obj && _method == rhs._method;
    }
    inline bool operator!=(const Functor<RetType, Args...>& rhs)
    {
        return _obj != rhs._obj || _method != rhs._method;
    }

    // Allow to check if there's a method set in the Functor
    explicit operator bool() const
    {
        return _method != nullptr;
    }

    template<class T, RetType (T::*method)(Args...)>
    static constexpr Functor bind(T *obj)
    {
        return { obj, method_wrapper<T, method> };
    }

private:
    void *_obj;
    RetType (*_method)(void *obj, Args...);

    template<class T, RetType (T::*method)(Args...)>
    static RetType method_wrapper(void *obj, Args... args)
    {
        T *t = static_cast<T*>(obj);
        return (t->*method)(args...);
    }
};
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       /*
 * getopt_long() -- long options parser
 *
 * Portions Copyright (c) 1987, 1993, 1994
 * The Regents of the University of California.  All rights reserved.
 *
 * Portions Copyright (c) 2003
 * PostgreSQL Global Development Group
 *
 * Simple conversion to C++ by Andrew Tridgell for ArduPilot. Based on
 * getopt_long.cpp from ccache
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <AP_HAL/AP_HAL.h>

#include "getopt_cpp.h"
#include <stdio.h>
#include <string.h>

#define GETOPT_ERROR(...) ::printf(__VA_ARGS__)


/*
  constructor
 */
GetOptLong::GetOptLong(int _argc, char *const _argv[], const char *_optstring, const GetOptLong::option * _longopts) :
    opterr(0),
    optind(1),
    optopt(0),
    longindex(-1),
    optarg(nullptr),
    argc(_argc),
    argv(_argv),
    optstring(_optstring),
    longopts(_longopts),
    place("")
{}

/*
  main parse code
 */
int GetOptLong::getoption(void)
{
    const char        *oli;          /* option letter list index */

    if (!*place)
    { /* update scanning pointer */
        if (optind >= argc)
        {
            place = "";
            return -1;
        }

        place = argv[optind];

        if (place[0] != '-')
        {
            place = "";
            return -1;
        }
        
        place++;
        
        if (place[0] && place[0] == '-' && place[1] == '\0')
        { /* found "--" */
            ++optind;
            place = "";
            return -1;
        }

        if (place[0] && place[0] == '-' && place[1])
        {
            /* long option */
            size_t namelen;
            int    i;
            
            place++;
            
            namelen = strcspn(place, "=");
            for (i = 0; longopts[i].name != nullptr; i++)
            {
                if (strlen(longopts[i].name) == namelen
                    && strncmp(place, longopts[i].name, namelen) == 0)
                {
                    if (longopts[i].has_arg)
                    {
                        if (place[namelen] == '=')
                            optarg = place + namelen + 1;
                        else if (optind < argc - 1)
                        {
                            optind++;
                            optarg = argv[optind];
                        }
                        else
                        {
                            if (optstring[0] == ':')
                                return BADARG;
                            if (opterr) {
                                GETOPT_ERROR("%s: option requires an argument -- %s\n",
                                             argv[0], place);
                            }
                            place = "";
                            optind++;
                            return BADCH;
                        }
                    }
                    else
                    {
                        optarg = nullptr;
                        if (place[namelen] != 0)
                        {
                            /* XXX error? */
                        }
                    }
                    
                    optind++;
                    
                    longindex = i;
                    
                    place = "";
                    
                    if (longopts[i].flag == nullptr)
                        return longopts[i].val;
                    else
                    {
                        *longopts[i].flag = longopts[i].val;
                        return 0;
                    }
                }
            }
            
            if (opterr && optstring[0] != ':') {
                GETOPT_ERROR("%s: illegal option -- %s\n", argv[0], place);
            }
            place = "";
            optind++;
            return BADCH;
        }
    }

    /* short option */
    optopt = (int) *place++;

    oli = strchr(optstring, optopt);
    if (!oli)
    {
        if (!*place)
            ++optind;
        if (opterr && *optstring != ':') {
            GETOPT_ERROR("%s: illegal option -- %c\n", argv[0], optopt);
        }
        return BADCH;
    }
    
    if (oli[1] != ':')
    { /* don't need argument */
        optarg = nullptr;
        if (!*place)
            ++optind;
    }
    else
    { /* need an argument */
        if (*place) /* no white space */
            optarg = place;
        else if (argc <= ++optind)
        { /* no arg */
            place = "";
            if (*optstring == ':')
                return BADARG;
            if (opterr) {
                GETOPT_ERROR("%s: option requires an argument -- %c\n",
                             argv[0], optopt);
            }
            return BADCH;
        }
        else
            /* white space */
            optarg = argv[optind];
        place = "";
        ++optind;
    }
    return optopt;
}

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   /*
 * Portions Copyright (c) 1987, 1993, 1994
 * The Regents of the University of California.  All rights reserved.
 *
 * Portions Copyright (c) 2003-2010, PostgreSQL Global Development
 * Group
 *
 * Simple conversion to C++ by Andrew Tridgell for ArduPilot. Based on
 * getopt_long.h from ccache
 */
#pragma once


class GetOptLong {
public:
    struct option {
	const char *name;
	bool        has_arg;
	int        *flag;
	int         val;
    };

    GetOptLong(int argc, char *const argv[], const char *optstring, const option * longopts);

    int   opterr;
    int   optind;
    int   optopt;
    int   longindex;
    const char *optarg;

    enum error_return {
        BADCH='?',
        BADARG=':'
    };


    int getoption(void);

private:
    int argc;
    char *const *argv;
    const char *optstring;
    const struct option *longopts;
    const char *place;
};
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    /*
  support for sending UDP packets on MAVLink packet boundaries.
 */

#include "packetise.h"

#if AP_MAVLINK_PACKETISE_ENABLED
#include <GCS_MAVLink/GCS_MAVLink.h>

/*
  return the number of bytes to send for a packetised connection
 */
uint16_t mavlink_packetise(ByteBuffer &writebuf, uint16_t n)
{
    int16_t b = writebuf.peek(0);
    if (b != MAVLINK_STX_MAVLINK1 && b != MAVLINK_STX) {
        /*
          we have a non-mavlink packet at the start of the
          buffer. Look ahead for a MAVLink start byte, up to 256 bytes
          ahead
         */
        uint16_t limit = n>256?256:n;
        uint16_t i;
        for (i=0; i<limit; i++) {
            b = writebuf.peek(i);
            if (b == MAVLINK_STX_MAVLINK1 || b == MAVLINK_STX) {
                n = i;
                break;
            }
        }
        // if we didn't find a MAVLink marker then limit the send size to 256
        if (i == limit) {
            n = limit;
        }
        return n;
    }

    // cope with both MAVLink1 and MAVLink2 packets
    uint8_t min_length = (b == MAVLINK_STX_MAVLINK1)?8:12;

    // this looks like a MAVLink packet - try to write on
    // packet boundaries when possible
    if (n < min_length) {
        // we need to wait for more data to arrive
        return 0;
    }

    // the length of the packet is the 2nd byte
    int16_t len = writebuf.peek(1);
    if (b == MAVLINK_STX) {
        // This is Mavlink2. Check for signed packet with extra 13 bytes
        int16_t incompat_flags = writebuf.peek(2);
        if (incompat_flags & MAVLINK_IFLAG_SIGNED) {
            min_length += MAVLINK_SIGNATURE_BLOCK_LEN;
        }
    }

    if (n < len+min_length) {
        // we don't have a full packet yet
        return 0;
    }
    if (n > len+min_length) {
        // send just 1 packet at a time (so MAVLink packets
        // are aligned on UDP boundaries)
        n = len+min_length;
    }
    return n;
}

#endif // AP_MAVLINK_PACKETISE_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        