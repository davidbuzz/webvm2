inCEpath, 'bin', 'x86_'+compiler)]
				incdirs = [os.path.join(winCEpath, 'include'), os.path.join(winCEpath, 'atlmfc', 'include'), include]
				libdirs = [os.path.join(winCEpath, 'lib', platform), os.path.join(winCEpath, 'atlmfc', 'lib', platform), lib]
				def combine_common(obj, compiler_env):
					# TODO this is likely broken, remove in waf 2.1
					(common_bindirs,_1,_2) = compiler_env
					return (bindirs + common_bindirs, incdirs, libdirs)
				targets[platform] = target_compiler(conf, 'msvc', platform, version, 'x86', vsvars, combine_common)
		if targets:
			versions[device + ' ' + version] = targets

@conf
def gather_winphone_targets(conf, versions, version, vc_path, vsvars):
	#Looking for WinPhone compilers
	targets = {}
	for target,realtarget in all_msvc_platforms[::-1]:
		targets[target] = target_compiler(conf, 'winphone', realtarget, version, target, vsvars)
	if targets:
		versions['winphone ' + version] = targets

@conf
def gather_vswhere_versions(conf, versions):
	try:
		import json
	except ImportError:
		Logs.error('Visual Studio 2017 detection requires Python 2.6')
		return

	prg_path = os.environ.get('ProgramFiles(x86)', os.environ.get('ProgramFiles', 'C:\\Program Files (x86)'))

	vswhere = os.path.join(prg_path, 'Microsoft Visual Studio', 'Installer', 'vswhere.exe')
	args = [vswhere, '-products', '*', '-legacy', '-format', 'json']
	try:
		txt = conf.cmd_and_log(args)
	except Errors.WafError as e:
		Logs.debug('msvc: vswhere.exe failed %s', e)
		return

	if sys.version_info[0] < 3:
		txt = txt.decode(Utils.console_encoding())

	arr = json.loads(txt)
	arr.sort(key=lambda x: x['installationVersion'])
	for entry in arr:
		ver = entry['installationVersion']
		ver = str('.'.join(ver.split('.')[:2]))
		path = str(os.path.abspath(entry['installationPath']))
		if os.path.exists(path) and ('msvc %s' % ver) not in versions:
			conf.gather_msvc_targets(versions, ver, path)

@conf
def gather_msvc_versions(conf, versions):
	vc_paths = []
	for (v,version,reg) in gather_msvc_detected_versions():
		try:
			try:
				msvc_version = Utils.winreg.OpenKey(Utils.winreg.HKEY_LOCAL_MACHINE, reg + "\\Setup\\VC")
			except OSError:
				msvc_version = Utils.winreg.OpenKey(Utils.winreg.HKEY_LOCAL_MACHINE, reg + "\\Setup\\Microsoft Visual C++")
			path,type = Utils.winreg.QueryValueEx(msvc_version, 'ProductDir')
		except OSError:
			try:
				msvc_version = Utils.winreg.OpenKey(Utils.winreg.HKEY_LOCAL_MACHINE, "SOFTWARE\\Wow6432node\\Microsoft\\VisualStudio\\SxS\\VS7")
				path,type = Utils.winreg.QueryValueEx(msvc_version, version)
			except OSError:
				continue
			else:
				vc_paths.append((version, os.path.abspath(str(path))))
			continue
		else:
			vc_paths.append((version, os.path.abspath(str(path))))

	wince_supported_platforms = gather_wince_supported_platforms()

	for version,vc_path in vc_paths:
		vs_path = os.path.dirname(vc_path)
		vsvars = os.path.join(vs_path, 'Common7', 'Tools', 'vsvars32.bat')
		if wince_supported_platforms and os.path.isfile(vsvars):
			conf.gather_wince_targets(versions, version, vc_path, vsvars, wince_supported_platforms)

	# WP80 works with 11.0Exp and 11.0, both of which resolve to the same vc_path.
	# Stop after one is found.
	for version,vc_path in vc_paths:
		vs_path = os.path.dirname(vc_path)
		vsvars = os.path.join(vs_path, 'VC', 'WPSDK', 'WP80', 'vcvarsphoneall.bat')
		if os.path.isfile(vsvars):
			conf.gather_winphone_targets(versions, '8.0', vc_path, vsvars)
			break

	for version,vc_path in vc_paths:
		vs_path = os.path.dirname(vc_path)
		conf.gather_msvc_targets(versions, version, vc_path)

@conf
def gather_icl_versions(conf, versions):
	"""
	Checks ICL compilers

	:param versions: list to modify
	:type versions: list
	"""
	version_pattern = re.compile(r'^...?.?\....?.?')
	try:
		all_versions = Utils.winreg.OpenKey(Utils.winreg.HKEY_LOCAL_MACHINE, 'SOFTWARE\\Wow6432node\\Intel\\Compilers\\C++')
	except OSError:
		try:
			all_versions = Utils.winreg.OpenKey(Utils.winreg.HKEY_LOCAL_MACHINE, 'SOFTWARE\\Intel\\Compilers\\C++')
		except OSError:
			return
	index = 0
	while 1:
		try:
			version = Utils.winreg.EnumKey(all_versions, index)
		except OSError:
			break
		index += 1
		if not version_pattern.match(version):
			continue
		targets = {}
		for target,arch in all_icl_platforms:
			if target=='intel64':
				targetDir='EM64T_NATIVE'
			else:
				targetDir=target
			try:
				Utils.winreg.OpenKey(all_versions,version+'\\'+targetDir)
				icl_version=Utils.winreg.OpenKey(all_versions,version)
				path,type=Utils.winreg.QueryValueEx(icl_version,'ProductDir')
			except OSError:
				pass
			else:
				batch_file=os.path.join(path,'bin','iclvars.bat')
				if os.path.isfile(batch_file):
					targets[target] = target_compiler(conf, 'intel', arch, version, target, batch_file)
		for target,arch in all_icl_platforms:
			try:
				icl_version = Utils.winreg.OpenKey(all_versions, version+'\\'+target)
				path,type = Utils.winreg.QueryValueEx(icl_version,'ProductDir')
			except OSError:
				continue
			else:
				batch_file=os.path.join(path,'bin','iclvars.bat')
				if os.path.isfile(batch_file):
					targets[target] = target_compiler(conf, 'intel', arch, version, target, batch_file)
		major = version[0:2]
		versions['intel ' + major] = targets

@conf
def gather_intel_composer_versions(conf, versions):
	"""
	Checks ICL compilers that are part of Intel Composer Suites

	:param versions: list to modify
	:type versions: list
	"""
	version_pattern = re.compile(r'^...?.?\...?.?.?')
	try:
		all_versions = Utils.winreg.OpenKey(Utils.winreg.HKEY_LOCAL_MACHINE, 'SOFTWARE\\Wow6432node\\Intel\\Suites')
	except OSError:
		try:
			all_versions = Utils.winreg.OpenKey(Utils.winreg.HKEY_LOCAL_MACHINE, 'SOFTWARE\\Intel\\Suites')
		except OSError:
			return
	index = 0
	while 1:
		try:
			version = Utils.winreg.EnumKey(all_versions, index)
		except OSError:
			break
		index += 1
		if not version_pattern.match(version):
			continue
		targets = {}
		for target,arch in all_icl_platforms:
			if target=='intel64':
				targetDir='EM64T_NATIVE'
			else:
				targetDir=target
			try:
				try:
					defaults = Utils.winreg.OpenKey(all_versions,version+'\\Defaults\\C++\\'+targetDir)
				except OSError:
					if targetDir == 'EM64T_NATIVE':
						defaults = Utils.winreg.OpenKey(all_versions,version+'\\Defaults\\C++\\EM64T')
					else:
						raise
				uid,type = Utils.winreg.QueryValueEx(defaults, 'SubKey')
				Utils.winreg.OpenKey(all_versions,version+'\\'+uid+'\\C++\\'+targetDir)
				icl_version=Utils.winreg.OpenKey(all_versions,version+'\\'+uid+'\\C++')
				path,type=Utils.winreg.QueryValueEx(icl_version,'ProductDir')
			except OSError:
				pass
			else:
				batch_file=os.path.join(path,'bin','iclvars.bat')
				if os.path.isfile(batch_file):
					targets[target] = target_compiler(conf, 'intel', arch, version, target, batch_file)
				# The intel compilervar_arch.bat is broken when used with Visual Studio Express 2012
				# http://software.intel.com/en-us/forums/topic/328487
				compilervars_warning_attr = '_compilervars_warning_key'
				if version[0:2] == '13' and getattr(conf, compilervars_warning_attr, True):
					setattr(conf, compilervars_warning_attr, False)
					patch_url = 'http://software.intel.com/en-us/forums/topic/328487'
					compilervars_arch = os.path.join(path, 'bin', 'compilervars_arch.bat')
					for vscomntool in ('VS110COMNTOOLS', 'VS100COMNTOOLS'):
						if vscomntool in os.environ:
							vs_express_path = os.environ[vscomntool] + r'..\IDE\VSWinExpress.exe'
							dev_env_path = os.environ[vscomntool] + r'..\IDE\devenv.exe'
							if (r'if exist "%VS110COMNTOOLS%..\IDE\VSWinExpress.exe"' in Utils.readf(compilervars_arch) and
								not os.path.exists(vs_express_path) and not os.path.exists(dev_env_path)):
								Logs.warn(('The Intel compilervar_arch.bat only checks for one Visual Studio SKU '
								'(VSWinExpress.exe) but it does not seem to be installed at %r. '
								'The intel command line set up will fail to configure unless the file %r'
								'is patched. See: %s') % (vs_express_path, compilervars_arch, patch_url))
		major = version[0:2]
		versions['intel ' + major] = targets

@conf
def detect_msvc(self):
	return self.setup_msvc(self.get_msvc_versions())

@conf
def get_msvc_versions(self):
	"""
	:return: platform to compiler configurations
	:rtype: dict
	"""
	dct = Utils.ordered_iter_dict()
	self.gather_icl_versions(dct)
	self.gather_intel_composer_versions(dct)
	self.gather_wsdk_versions(dct)
	self.gather_msvc_versions(dct)
	self.gather_vswhere_versions(dct)
	Logs.debug('msvc: detected versions %r', list(dct.keys()))
	return dct

@conf
def find_lt_names_msvc(self, libname, is_static=False):
	"""
	Win32/MSVC specific code to glean out information from libtool la files.
	this function is not attached to the task_gen class. Returns a triplet:
	(library absolute path, library name without extension, whether the library is static)
	"""
	lt_names=[
		'lib%s.la' % libname,
		'%s.la' % libname,
	]

	for path in self.env.LIBPATH:
		for la in lt_names:
			laf=os.path.join(path,la)
			dll=None
			if os.path.exists(laf):
				ltdict = Utils.read_la_file(laf)
				lt_libdir=None
				if ltdict.get('libdir', ''):
					lt_libdir = ltdict['libdir']
				if not is_static and ltdict.get('library_names', ''):
					dllnames=ltdict['library_names'].split()
					dll=dllnames[0].lower()
					dll=re.sub(r'\.dll$', '', dll)
					return (lt_libdir, dll, False)
				elif ltdict.get('old_library', ''):
					olib=ltdict['old_library']
					if os.path.exists(os.path.join(path,olib)):
						return (path, olib, True)
					elif lt_libdir != '' and os.path.exists(os.path.join(lt_libdir,olib)):
						return (lt_libdir, olib, True)
					else:
						return (None, olib, True)
				else:
					raise self.errors.WafError('invalid libtool object file: %s' % laf)
	return (None, None, None)

@conf
def libname_msvc(self, libname, is_static=False):
	lib = libname.lower()
	lib = re.sub(r'\.lib$','',lib)

	if lib in g_msvc_systemlibs:
		return lib

	lib=re.sub('^lib','',lib)

	if lib == 'm':
		return None

	(lt_path, lt_libname, lt_static) = self.find_lt_names_msvc(lib, is_static)

	if lt_path != None and lt_libname != None:
		if lt_static:
			# file existence check has been made by find_lt_names
			return os.path.join(lt_path,lt_libname)

	if lt_path != None:
		_libpaths = [lt_path] + self.env.LIBPATH
	else:
		_libpaths = self.env.LIBPATH

	static_libs=[
		'lib%ss.lib' % lib,
		'lib%s.lib' % lib,
		'%ss.lib' % lib,
		'%s.lib' %lib,
		]

	dynamic_libs=[
		'lib%s.dll.lib' % lib,
		'lib%s.dll.a' % lib,
		'%s.dll.lib' % lib,
		'%s.dll.a' % lib,
		'lib%s_d.lib' % lib,
		'%s_d.lib' % lib,
		'%s.lib' %lib,
		]

	libnames=static_libs
	if not is_static:
		libnames=dynamic_libs + static_libs

	for path in _libpaths:
		for libn in libnames:
			if os.path.exists(os.path.join(path, libn)):
				Logs.debug('msvc: lib found: %s', os.path.join(path,libn))
				return re.sub(r'\.lib$', '',libn)

	#if no lib can be found, just return the libname as msvc expects it
	self.fatal('The library %r could not be found' % libname)
	return re.sub(r'\.lib$', '', libname)

@conf
def check_lib_msvc(self, libname, is_static=False, uselib_store=None):
	"""
	Ideally we should be able to place the lib in the right env var, either STLIB or LIB,
	but we don't distinguish static libs from shared libs.
	This is ok since msvc doesn't have any special linker flag to select static libs (no env.STLIB_MARKER)
	"""
	libn = self.libname_msvc(libname, is_static)

	if not uselib_store:
		uselib_store = libname.upper()

	if False and is_static: # disabled
		self.env['STLIB_' + uselib_store] = [libn]
	else:
		self.env['LIB_' + uselib_store] = [libn]

@conf
def check_libs_msvc(self, libnames, is_static=False):
	for libname in Utils.to_list(libnames):
		self.check_lib_msvc(libname, is_static)

def configure(conf):
	"""
	Configuration methods to call for detecting msvc
	"""
	conf.autodetect(True)
	conf.find_msvc()
	conf.msvc_common_flags()
	conf.cc_load_tools()
	conf.cxx_load_tools()
	conf.cc_add_flags()
	conf.cxx_add_flags()
	conf.link_add_flags()
	conf.visual_studio_add_flags()

@conf
def no_autodetect(conf):
	conf.env.NO_MSVC_DETECT = 1
	configure(conf)

@conf
def autodetect(conf, arch=False):
	v = conf.env
	if v.NO_MSVC_DETECT:
		return

	compiler, version, path, includes, libdirs, cpu = conf.detect_msvc()
	if arch:
		v.DEST_CPU = cpu

	v.PATH = path
	v.INCLUDES = includes
	v.LIBPATH = libdirs
	v.MSVC_COMPILER = compiler
	try:
		v.MSVC_VERSION = float(version)
	except ValueError:
		v.MSVC_VERSION = float(version[:-3])

def _get_prog_names(conf, compiler):
	if compiler == 'intel':
		compiler_name = 'ICL'
		linker_name = 'XILINK'
		lib_name = 'XILIB'
	else:
		# assumes CL.exe
		compiler_name = 'CL'
		linker_name = 'LINK'
		lib_name = 'LIB'
	return compiler_name, linker_name, lib_name

@conf
def find_msvc(conf):
	"""Due to path format limitations, limit operation only to native Win32. Yeah it sucks."""
	if sys.platform == 'cygwin':
		conf.fatal('MSVC module does not work under cygwin Python!')

	# the autodetection is supposed to be performed before entering in this method
	v = conf.env
	path = v.PATH
	compiler = v.MSVC_COMPILER
	version = v.MSVC_VERSION

	compiler_name, linker_name, lib_name = _get_prog_names(conf, compiler)
	v.MSVC_MANIFEST = (compiler == 'msvc' and version >= 8) or (compiler == 'wsdk' and version >= 6) or (compiler == 'intel' and version >= 11)

	# compiler
	cxx = conf.find_program(compiler_name, var='CXX', path_list=path)

	# before setting anything, check if the compiler is really msvc
	env = dict(conf.environ)
	if path:
		env.update(PATH = ';'.join(path))
	if not conf.cmd_and_log(cxx + ['/nologo', '/help'], env=env):
		conf.fatal('the msvc compiler could not be identified')

	# c/c++ compiler
	v.CC = v.CXX = cxx
	v.CC_NAME = v.CXX_NAME = 'msvc'

	# linker
	if not v.LINK_CXX:
		conf.find_program(linker_name, path_list=path, errmsg='%s was not found (linker)' % linker_name, var='LINK_CXX')

	if not v.LINK_CC:
		v.LINK_CC = v.LINK_CXX

	# staticlib linker
	if not v.AR:
		stliblink = conf.find_program(lib_name, path_list=path, var='AR')
		if not stliblink:
			return
		v.ARFLAGS = ['/nologo']

	# manifest tool. Not required for VS 2003 and below. Must have for VS 2005 and later
	if v.MSVC_MANIFEST:
		conf.find_program('MT', path_list=path, var='MT')
		v.MTFLAGS = ['/nologo']

	try:
		conf.load('winres')
	except Errors.ConfigurationError:
		Logs.warn('Resource compiler not found. Compiling resource file is disabled')

@conf
def visual_studio_add_flags(self):
	"""visual studio flags found in the system environment"""
	v = self.env
	if self.environ.get('INCLUDE'):
		v.prepend_value('INCLUDES', [x for x in self.environ['INCLUDE'].split(';') if x]) # notice the 'S'
	if self.environ.get('LIB'):
		v.prepend_value('LIBPATH', [x for x in self.environ['LIB'].split(';') if x])

@conf
def msvc_common_flags(conf):
	"""
	Setup the flags required for executing the msvc compiler
	"""
	v = conf.env

	v.DEST_BINFMT = 'pe'
	v.append_value('CFLAGS', ['/nologo'])
	v.append_value('CXXFLAGS', ['/nologo'])
	v.append_value('LINKFLAGS', ['/nologo'])
	v.DEFINES_ST   = '/D%s'

	v.CC_SRC_F     = ''
	v.CC_TGT_F     = ['/c', '/Fo']
	v.CXX_SRC_F    = ''
	v.CXX_TGT_F    = ['/c', '/Fo']

	if (v.MSVC_COMPILER == 'msvc' and v.MSVC_VERSION >= 8) or (v.MSVC_COMPILER == 'wsdk' and v.MSVC_VERSION >= 6):
		v.CC_TGT_F = ['/FC'] + v.CC_TGT_F
		v.CXX_TGT_F = ['/FC'] + v.CXX_TGT_F

	v.CPPPATH_ST = '/I%s' # template for adding include paths

	v.AR_TGT_F = v.CCLNK_TGT_F = v.CXXLNK_TGT_F = '/OUT:'

	# CRT specific flags
	v.CFLAGS_CRT_MULTITHREADED     = v.CXXFLAGS_CRT_MULTITHREADED     = ['/MT']
	v.CFLAGS_CRT_MULTITHREADED_DLL = v.CXXFLAGS_CRT_MULTITHREADED_DLL = ['/MD']

	v.CFLAGS_CRT_MULTITHREADED_DBG     = v.CXXFLAGS_CRT_MULTITHREADED_DBG     = ['/MTd']
	v.CFLAGS_CRT_MULTITHREADED_DLL_DBG = v.CXXFLAGS_CRT_MULTITHREADED_DLL_DBG = ['/MDd']

	v.LIB_ST            = '%s.lib'
	v.LIBPATH_ST        = '/LIBPATH:%s'
	v.STLIB_ST          = '%s.lib'
	v.STLIBPATH_ST      = '/LIBPATH:%s'

	if v.MSVC_MANIFEST:
		v.append_value('LINKFLAGS', ['/MANIFEST'])

	v.CFLAGS_cshlib     = []
	v.CXXFLAGS_cxxshlib = []
	v.LINKFLAGS_cshlib  = v.LINKFLAGS_cxxshlib = ['/DLL']
	v.cshlib_PATTERN    = v.cxxshlib_PATTERN = '%s.dll'
	v.implib_PATTERN    = '%s.lib'
	v.IMPLIB_ST         = '/IMPLIB:%s'

	v.LINKFLAGS_cstlib  = []
	v.cstlib_PATTERN    = v.cxxstlib_PATTERN = '%s.lib'

	v.cprogram_PATTERN  = v.cxxprogram_PATTERN = '%s.exe'

	v.def_PATTERN       = '/def:%s'


#######################################################################################################
##### conf above, build below

@after_method('apply_link')
@feature('c', 'cxx')
def apply_flags_msvc(self):
	"""
	Add additional flags implied by msvc, such as subsystems and pdb files::

		def build(bld):
			bld.stlib(source='main.c', target='bar', subsystem='gruik')
	"""
	if self.env.CC_NAME != 'msvc' or not getattr(self, 'link_task', None):
		return

	is_static = isinstance(self.link_task, ccroot.stlink_task)

	subsystem = getattr(self, 'subsystem', '')
	if subsystem:
		subsystem = '/subsystem:%s' % subsystem
		flags = is_static and 'ARFLAGS' or 'LINKFLAGS'
		self.env.append_value(flags, subsystem)

	if not is_static:
		for f in self.env.LINKFLAGS:
			d = f.lower()
			if d[1:] in ('debug', 'debug:full', 'debug:fastlink'):
				pdbnode = self.link_task.outputs[0].change_ext('.pdb')
				self.link_task.outputs.append(pdbnode)

				if getattr(self, 'install_task', None):
					self.pdb_install_task = self.add_install_files(
						install_to=self.install_task.install_to, install_from=pdbnode)
				break

@feature('cprogram', 'cshlib', 'cxxprogram', 'cxxshlib')
@after_method('apply_link')
def apply_manifest(self):
	"""
	Special linker for MSVC with support for embedding manifests into DLL's
	and executables compiled by Visual Studio 2005 or probably later. Without
	the manifest file, the binaries are unusable.
	See: http://msdn2.microsoft.com/en-us/library/ms235542(VS.80).aspx
	"""
	if self.env.CC_NAME == 'msvc' and self.env.MSVC_MANIFEST and getattr(self, 'link_task', None):
		out_node = self.link_task.outputs[0]
		man_node = out_node.parent.find_or_declare(out_node.name + '.manifest')
		self.link_task.outputs.append(man_node)
		self.env.DO_MANIFEST = True

def make_winapp(self, family):
	append = self.env.append_unique
	append('DEFINES', 'WINAPI_FAMILY=%s' % family)
	append('CXXFLAGS', ['/ZW', '/TP'])
	for lib_path in self.env.LIBPATH:
		append('CXXFLAGS','/AI%s'%lib_path)

@feature('winphoneapp')
@after_method('process_use')
@after_method('propagate_uselib_vars')
def make_winphone_app(self):
	"""
	Insert configuration flags for windows phone applications (adds /ZW, /TP...)
	"""
	make_winapp(self, 'WINAPI_FAMILY_PHONE_APP')
	self.env.append_unique('LINKFLAGS', ['/NODEFAULTLIB:ole32.lib', 'PhoneAppModelHost.lib'])

@feature('winapp')
@after_method('process_use')
@after_method('propagate_uselib_vars')
def make_windows_app(self):
	"""
	Insert configuration flags for windows applications (adds /ZW, /TP...)
	"""
	make_winapp(self, 'WINAPI_FAMILY_DESKTOP_APP')
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                #!/usr/bin/env python
# encoding: utf-8
# Thomas Nagy, 2008-2018 (ita)

"""
Nasm tool (asm processing)
"""

import os
import waflib.Tools.asm # leave this
from waflib.TaskGen import feature

@feature('asm')
def apply_nasm_vars(self):
	"""provided for compatibility"""
	self.env.append_value('ASFLAGS', self.to_list(getattr(self, 'nasm_flags', [])))

def configure(conf):
	"""
	Detect nasm/yasm and set the variable *AS*
	"""
	conf.find_program(['nasm', 'yasm'], var='AS')
	conf.env.AS_TGT_F = ['-o']
	conf.env.ASLNK_TGT_F = ['-o']
	conf.load('asm')
	conf.env.ASMPATH_ST = '-I%s' + os.sep
	txt = conf.cmd_and_log(conf.env.AS + ['--version'])
	if 'yasm' in txt.lower():
		conf.env.ASM_NAME = 'yasm'
	else:
		conf.env.ASM_NAME = 'nasm'
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   #! /usr/bin/env python
# encoding: utf-8
# Thomas Nagy, 2015 (ita)

"""
Override the build commands to write empty files.
This is useful for profiling and evaluating the Python overhead.

To use::

    def build(bld):
        ...
        bld.load('nobuild')

"""

from waflib import Task
def build(bld):
	def run(self):
		for x in self.outputs:
			x.write('')
	for (name, cls) in Task.classes.items():
		cls.run = run

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             #!/usr/bin/env python
# encoding: utf-8
# andersg at 0x63.nu 2007
# Thomas Nagy 2016-2018 (ita)

"""
Support for Perl extensions. A C/C++ compiler is required::

	def options(opt):
		opt.load('compiler_c perl')
	def configure(conf):
		conf.load('compiler_c perl')
		conf.check_perl_version((5,6,0))
		conf.check_perl_ext_devel()
		conf.check_perl_module('Cairo')
		conf.check_perl_module('Devel::PPPort 4.89')
	def build(bld):
		bld(
			features     = 'c cshlib perlext',
			source       = 'Mytest.xs',
			target       = 'Mytest',
			install_path = '${ARCHDIR_PERL}/auto')
		bld.install_files('${ARCHDIR_PERL}', 'Mytest.pm')
"""

import os
from waflib import Task, Options, Utils, Errors
from waflib.Configure import conf
from waflib.TaskGen import extension, feature, before_method

@before_method('apply_incpaths', 'apply_link', 'propagate_uselib_vars')
@feature('perlext')
def init_perlext(self):
	"""
	Change the values of *cshlib_PATTERN* and *cxxshlib_PATTERN* to remove the
	*lib* prefix from library names.
	"""
	self.uselib = self.to_list(getattr(self, 'uselib', []))
	if not 'PERLEXT' in self.uselib:
		self.uselib.append('PERLEXT')
	self.env.cshlib_PATTERN = self.env.cxxshlib_PATTERN = self.env.perlext_PATTERN

@extension('.xs')
def xsubpp_file(self, node):
	"""
	Create :py:class:`waflib.Tools.perl.xsubpp` tasks to process *.xs* files
	"""
	outnode = node.change_ext('.c')
	self.create_task('xsubpp', node, outnode)
	self.source.append(outnode)

class xsubpp(Task.Task):
	"""
	Process *.xs* files
	"""
	run_str = '${PERL} ${XSUBPP} -noprototypes -typemap ${EXTUTILS_TYPEMAP} ${SRC} > ${TGT}'
	color   = 'BLUE'
	ext_out = ['.h']

@conf
def check_perl_version(self, minver=None):
	"""
	Check if Perl is installed, and set the variable PERL.
	minver is supposed to be a tuple
	"""
	res = True
	if minver:
		cver = '.'.join(map(str,minver))
	else:
		cver = ''

	self.start_msg('Checking for minimum perl version %s' % cver)

	perl = self.find_program('perl', var='PERL', value=getattr(Options.options, 'perlbinary', None))
	version = self.cmd_and_log(perl + ["-e", 'printf \"%vd\", $^V'])
	if not version:
		res = False
		version = "Unknown"
	elif not minver is None:
		ver = tuple(map(int, version.split(".")))
		if ver < minver:
			res = False

	self.end_msg(version, color=res and 'GREEN' or 'YELLOW')
	return res

@conf
def check_perl_module(self, module):
	"""
	Check if specified perlmodule is installed.

	The minimum version can be specified by specifying it after modulename
	like this::

		def configure(conf):
			conf.check_perl_module("Some::Module 2.92")
	"""
	cmd = self.env.PERL + ['-e', 'use %s' % module]
	self.start_msg('perl module %s' % module)
	try:
		r = self.cmd_and_log(cmd)
	except Errors.WafError:
		self.end_msg(False)
		return None
	self.end_msg(r or True)
	return r

@conf
def check_perl_ext_devel(self):
	"""
	Check for configuration needed to build perl extensions.

	Sets different xxx_PERLEXT variables in the environment.

	Also sets the ARCHDIR_PERL variable useful as installation path,
	which can be overridden by ``--with-perl-archdir`` option.
	"""

	env = self.env
	perl = env.PERL
	if not perl:
		self.fatal('find perl first')

	def cmd_perl_config(s):
		return perl + ['-MConfig', '-e', 'print \"%s\"' % s]
	def cfg_str(cfg):
		return self.cmd_and_log(cmd_perl_config(cfg))
	def cfg_lst(cfg):
		return Utils.to_list(cfg_str(cfg))
	def find_xsubpp():
		for var in ('privlib', 'vendorlib'):
			xsubpp = cfg_lst('$Config{%s}/ExtUtils/xsubpp$Config{exe_ext}' % var)
			if xsubpp and os.path.isfile(xsubpp[0]):
				return xsubpp
		return self.find_program('xsubpp')

	env.LINKFLAGS_PERLEXT = cfg_lst('$Config{lddlflags}')
	env.INCLUDES_PERLEXT = cfg_lst('$Config{archlib}/CORE')
	env.CFLAGS_PERLEXT = cfg_lst('$Config{ccflags} $Config{cccdlflags}')
	env.EXTUTILS_TYPEMAP = cfg_lst('$Config{privlib}/ExtUtils/typemap')
	env.XSUBPP = find_xsubpp()

	if not getattr(Options.options, 'perlarchdir', None):
		env.ARCHDIR_PERL = cfg_str('$Config{sitearch}')
	else:
		env.ARCHDIR_PERL = getattr(Options.options, 'perlarchdir')

	env.perlext_PATTERN = '%s.' + cfg_str('$Config{dlext}')

def options(opt):
	"""
	Add the ``--with-perl-archdir`` and ``--with-perl-binary`` command-line options.
	"""
	opt.add_option('--with-perl-binary', type='string', dest='perlbinary', help = 'Specify alternate perl binary', default=None)
	opt.add_option('--with-perl-archdir', type='string', dest='perlarchdir', help = 'Specify directory where to install arch specific files', default=None)

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           #!/usr/bin/env python
# encoding: utf-8
# Thomas Nagy, 2007-2015 (ita)
# Gustavo Carneiro (gjc), 2007

"""
Support for Python, detect the headers and libraries and provide
*use* variables to link C/C++ programs against them::

	def options(opt):
		opt.load('compiler_c python')
	def configure(conf):
		conf.load('compiler_c python')
		conf.check_python_version((2,4,2))
		conf.check_python_headers()
	def build(bld):
		bld.program(features='pyembed', source='a.c', target='myprog')
		bld.shlib(features='pyext', source='b.c', target='mylib')
"""

import os, sys
from waflib import Errors, Logs, Node, Options, Task, Utils
from waflib.TaskGen import extension, before_method, after_method, feature
from waflib.Configure import conf

FRAG = '''
#include <Python.h>
#ifdef __cplusplus
extern "C" {
#endif
	void Py_Initialize(void);
	void Py_Finalize(void);
#ifdef __cplusplus
}
#endif
int main(int argc, char **argv)
{
   (void)argc; (void)argv;
   Py_Initialize();
   Py_Finalize();
   return 0;
}
'''
"""
Piece of C/C++ code used in :py:func:`waflib.Tools.python.check_python_headers`
"""

INST = '''
import sys, py_compile
py_compile.compile(sys.argv[1], sys.argv[2], sys.argv[3], True)
'''
"""
Piece of Python code used in :py:class:`waflib.Tools.python.pyo` and :py:class:`waflib.Tools.python.pyc` for byte-compiling python files
"""

DISTUTILS_IMP = """
try:
	from distutils.sysconfig import get_config_var, get_python_lib
except ImportError:
	from sysconfig import get_config_var, get_path
	def get_python_lib(*k, **kw):
		keyword='platlib' if kw.get('plat_specific') else 'purelib'
		if 'prefix' in kw:
			return get_path(keyword, vars={'installed_base': kw['prefix'], 'platbase': kw['prefix']})
		return get_path(keyword)
""".splitlines()

@before_method('process_source')
@feature('py')
def feature_py(self):
	"""
	Create tasks to byte-compile .py files and install them, if requested
	"""
	self.install_path = getattr(self, 'install_path', '${PYTHONDIR}')
	install_from = getattr(self, 'install_from', None)
	if install_from and not isinstance(install_from, Node.Node):
		install_from = self.path.find_dir(install_from)
	self.install_from = install_from

	ver = self.env.PYTHON_VERSION
	if not ver:
		self.bld.fatal('Installing python files requires PYTHON_VERSION, try conf.check_python_version')

	if int(ver.replace('.', '')) > 31:
		self.install_32 = True

@extension('.py')
def process_py(self, node):
	"""
	Add signature of .py file, so it will be byte-compiled when necessary
	"""
	assert(hasattr(self, 'install_path')), 'add features="py" for target "%s" in "%s/wscript".' % (self.target, self.path.nice_path())
	self.install_from = getattr(self, 'install_from', None)
	relative_trick = getattr(self, 'relative_trick', True)
	if self.install_from:
		assert isinstance(self.install_from, Node.Node), \
		'add features="py" for target "%s" in "%s/wscript" (%s).' % (self.target, self.path.nice_path(), type(self.install_from))

	# where to install the python file
	if self.install_path:
		if self.install_from:
			self.add_install_files(install_to=self.install_path, install_from=node, cwd=self.install_from, relative_trick=relative_trick)
		else:
			self.add_install_files(install_to=self.install_path, install_from=node, relative_trick=relative_trick)

	lst = []
	if self.env.PYC:
		lst.append('pyc')
	if self.env.PYO:
		lst.append('pyo')

	if self.install_path:
		if self.install_from:
			target_dir = node.path_from(self.install_from) if relative_trick else node.name
			pyd = Utils.subst_vars("%s/%s" % (self.install_path, target_dir), self.env)
		else:
			target_dir = node.path_from(self.path) if relative_trick else node.name
			pyd = Utils.subst_vars("%s/%s" % (self.install_path, target_dir), self.env)
	else:
		pyd = node.abspath()

	for ext in lst:
		if self.env.PYTAG and not self.env.NOPYCACHE:
			# __pycache__ installation for python 3.2 - PEP 3147
			name = node.name[:-3]
			pyobj = node.parent.get_bld().make_node('__pycache__').make_node("%s.%s.%s" % (name, self.env.PYTAG, ext))
			pyobj.parent.mkdir()
		else:
			pyobj = node.change_ext(".%s" % ext)

		tsk = self.create_task(ext, node, pyobj)
		tsk.pyd = pyd

		if self.install_path:
			self.add_install_files(install_to=os.path.dirname(pyd), install_from=pyobj, cwd=node.parent.get_bld(), relative_trick=relative_trick)

class pyc(Task.Task):
	"""
	Byte-compiling python files
	"""
	color = 'PINK'
	def __str__(self):
		node = self.outputs[0]
		return node.path_from(node.ctx.launch_node())
	def run(self):
		cmd = [Utils.subst_vars('${PYTHON}', self.env), '-c', INST, self.inputs[0].abspath(), self.outputs[0].abspath(), self.pyd]
		ret = self.generator.bld.exec_command(cmd)
		return ret

class pyo(Task.Task):
	"""
	Byte-compiling python files
	"""
	color = 'PINK'
	def __str__(self):
		node = self.outputs[0]
		return node.path_from(node.ctx.launch_node())
	def run(self):
		cmd = [Utils.subst_vars('${PYTHON}', self.env), Utils.subst_vars('${PYFLAGS_OPT}', self.env), '-c', INST, self.inputs[0].abspath(), self.outputs[0].abspath(), self.pyd]
		ret = self.generator.bld.exec_command(cmd)
		return ret

@feature('pyext')
@before_method('propagate_uselib_vars', 'apply_link')
@after_method('apply_bundle')
def init_pyext(self):
	"""
	Change the values of *cshlib_PATTERN* and *cxxshlib_PATTERN* to remove the
	*lib* prefix from library names.
	"""
	self.uselib = self.to_list(getattr(self, 'uselib', []))
	if not 'PYEXT' in self.uselib:
		self.uselib.append('PYEXT')
	# override shlib_PATTERN set by the osx module
	self.env.cshlib_PATTERN = self.env.cxxshlib_PATTERN = self.env.macbundle_PATTERN = self.env.pyext_PATTERN
	self.env.fcshlib_PATTERN = self.env.dshlib_PATTERN = self.env.pyext_PATTERN

	try:
		if not self.install_path:
			return
	except AttributeError:
		self.install_path = '${PYTHONARCHDIR}'

@feature('pyext')
@before_method('apply_link', 'apply_bundle')
def set_bundle(self):
	"""Mac-specific pyext extension that enables bundles from c_osx.py"""
	if Utils.unversioned_sys_platform() == 'darwin':
		self.mac_bundle = True

@before_method('propagate_uselib_vars')
@feature('pyembed')
def init_pyembed(self):
	"""
	Add the PYEMBED variable.
	"""
	self.uselib = self.to_list(getattr(self, 'uselib', []))
	if not 'PYEMBED' in self.uselib:
		self.uselib.append('PYEMBED')

@conf
def get_python_variables(self, variables, imports=None):
	"""
	Spawn a new python process to dump configuration variables

	:param variables: variables to print
	:type variables: list of string
	:param imports: one import by element
	:type imports: list of string
	:return: the variable values
	:rtype: list of string
	"""
	if not imports:
		try:
			imports = self.python_imports
		except AttributeError:
			imports = DISTUTILS_IMP

	program = list(imports) # copy
	program.append('')
	for v in variables:
		program.append("print(repr(%s))" % v)
	os_env = dict(os.environ)
	try:
		del os_env['MACOSX_DEPLOYMENT_TARGET'] # see comments in the OSX tool
	except KeyError:
		pass

	try:
		out = self.cmd_and_log(self.env.PYTHON + ['-c', '\n'.join(program)], env=os_env)
	except Errors.WafError:
		self.fatal('Could not run %r' % self.env.PYTHON)
	self.to_log(out)
	return_values = []
	for s in out.splitlines():
		s = s.strip()
		if not s:
			continue
		if s == 'None':
			return_values.append(None)
		elif (s[0] == "'" and s[-1] == "'") or (s[0] == '"' and s[-1] == '"'):
			return_values.append(eval(s))
		elif s[0].isdigit():
			return_values.append(int(s))
		else: break
	return return_values

@conf
def test_pyembed(self, mode, msg='Testing pyembed configuration'):
	self.check(header_name='Python.h', define_name='HAVE_PYEMBED', msg=msg,
		fragment=FRAG, errmsg='Could not build a python embedded interpreter',
		features='%s %sprogram pyembed' % (mode, mode))

@conf
def test_pyext(self, mode, msg='Testing pyext configuration'):
	self.check(header_name='Python.h', define_name='HAVE_PYEXT', msg=msg,
		fragment=FRAG, errmsg='Could not build python extensions',
		features='%s %sshlib pyext' % (mode, mode))

@conf
def python_cross_compile(self, features='pyembed pyext'):
	"""
	For cross-compilation purposes, it is possible to bypass the normal detection and set the flags that you want:
	PYTHON_VERSION='3.4' PYTAG='cpython34' pyext_PATTERN="%s.so" PYTHON_LDFLAGS='-lpthread -ldl' waf configure

	The following variables are used:
	PYTHON_VERSION    required
	PYTAG             required
	PYTHON_LDFLAGS    required
	pyext_PATTERN     required
	PYTHON_PYEXT_LDFLAGS
	PYTHON_PYEMBED_LDFLAGS
	"""
	features = Utils.to_list(features)
	if not ('PYTHON_LDFLAGS' in self.environ or 'PYTHON_PYEXT_LDFLAGS' in self.environ or 'PYTHON_PYEMBED_LDFLAGS' in self.environ):
		return False

	for x in 'PYTHON_VERSION PYTAG pyext_PATTERN'.split():
		if not x in self.environ:
			self.fatal('Please set %s in the os environment' % x)
		else:
			self.env[x] = self.environ[x]

	xx = self.env.CXX_NAME and 'cxx' or 'c'
	if 'pyext' in features:
		flags = self.environ.get('PYTHON_PYEXT_LDFLAGS', self.environ.get('PYTHON_LDFLAGS'))
		if flags is None:
			self.fatal('No flags provided through PYTHON_PYEXT_LDFLAGS as required')
		else:
			self.parse_flags(flags, 'PYEXT')
		self.test_pyext(xx)
	if 'pyembed' in features:
		flags = self.environ.get('PYTHON_PYEMBED_LDFLAGS', self.environ.get('PYTHON_LDFLAGS'))
		if flags is None:
			self.fatal('No flags provided through PYTHON_PYEMBED_LDFLAGS as required')
		else:
			self.parse_flags(flags, 'PYEMBED')
		self.test_pyembed(xx)
	return True

@conf
def check_python_headers(conf, features='pyembed pyext'):
	"""
	Check for headers and libraries necessary to extend or embed python.
	It may use the module *distutils* or sysconfig in newer Python versions.
	On success the environment variables xxx_PYEXT and xxx_PYEMBED are added:

	* PYEXT: for compiling python extensions
	* PYEMBED: for embedding a python interpreter
	"""
	features = Utils.to_list(features)
	assert ('pyembed' in features) or ('pyext' in features), "check_python_headers features must include 'pyembed' and/or 'pyext'"
	env = conf.env
	if not env.CC_NAME and not env.CXX_NAME:
		conf.fatal('load a compiler first (gcc, g++, ..)')

	# bypass all the code below for cross-compilation
	if conf.python_cross_compile(features):
		return

	if not env.PYTHON_VERSION:
		conf.check_python_version()

	pybin = env.PYTHON
	if not pybin:
		conf.fatal('Could not find the python executable')

	# so we actually do all this for compatibility reasons and for obtaining pyext_PATTERN below
	v = 'prefix SO EXT_SUFFIX LDFLAGS LIBDIR LIBPL INCLUDEPY Py_ENABLE_SHARED MACOSX_DEPLOYMENT_TARGET LDSHARED CFLAGS LDVERSION'.split()
	try:
		lst = conf.get_python_variables(["get_config_var('%s') or ''" % x for x in v])
	except RuntimeError:
		conf.fatal("Python development headers not found (-v for details).")

	vals = ['%s = %r' % (x, y) for (x, y) in zip(v, lst)]
	conf.to_log("Configuration returned from %r:\n%s\n" % (pybin, '\n'.join(vals)))

	dct = dict(zip(v, lst))
	x = 'MACOSX_DEPLOYMENT_TARGET'
	if dct[x]:
		env[x] = conf.environ[x] = str(dct[x])
	env.pyext_PATTERN = '%s' + (dct['EXT_SUFFIX'] or dct['SO']) # SO is deprecated in 3.5 and removed in 3.11


	# Try to get pythonX.Y-config
	num = '.'.join(env.PYTHON_VERSION.split('.')[:2])
	conf.find_program([''.join(pybin) + '-config', 'python%s-config' % num, 'python-config-%s' % num, 'python%sm-config' % num], var='PYTHON_CONFIG', msg="python-config", mandatory=False)

	if env.PYTHON_CONFIG:
		# check python-config output only once
		if conf.env.HAVE_PYTHON_H:
			return

		# python2.6-config requires 3 runs
		all_flags = [['--cflags', '--libs', '--ldflags']]
		if sys.hexversion < 0x2070000:
			all_flags = [[k] for k in all_flags[0]]

		xx = env.CXX_NAME and 'cxx' or 'c'

		if 'pyembed' in features:
			for flags in all_flags:
				# Python 3.8 has different flags for pyembed, needs --embed
				embedflags = flags + ['--embed']
				try:
					conf.check_cfg(msg='Asking python-config for pyembed %r flags' % ' '.join(embedflags), path=env.PYTHON_CONFIG, package='', uselib_store='PYEMBED', args=embedflags)
				except conf.errors.ConfigurationError:
					# However Python < 3.8 doesn't accept --embed, so we need a fallback
					conf.check_cfg(msg='Asking python-config for pyembed %r flags' % ' '.join(flags), path=env.PYTHON_CONFIG, package='', uselib_store='PYEMBED', args=flags)

			try:
				conf.test_pyembed(xx)
			except conf.errors.ConfigurationError:
				# python bug 7352
				if dct['Py_ENABLE_SHARED'] and dct['LIBDIR']:
					env.append_unique('LIBPATH_PYEMBED', [dct['LIBDIR']])
					conf.test_pyembed(xx)
				else:
					raise

		if 'pyext' in features:
			for flags in all_flags:
				conf.check_cfg(msg='Asking python-config for pyext %r flags' % ' '.join(flags), path=env.PYTHON_CONFIG, package='', uselib_store='PYEXT', args=flags)

			try:
				conf.test_pyext(xx)
			except conf.errors.ConfigurationError:
				# python bug 7352
				if dct['Py_ENABLE_SHARED'] and dct['LIBDIR']:
					env.append_unique('LIBPATH_PYEXT', [dct['LIBDIR']])
					conf.test_pyext(xx)
				else:
					raise

		conf.define('HAVE_PYTHON_H', 1)
		return

	# No python-config, do something else on windows systems
	all_flags = dct['LDFLAGS'] + ' ' + dct['CFLAGS']
	conf.parse_flags(all_flags, 'PYEMBED')

	all_flags = dct['LDFLAGS'] + ' ' + dct['LDSHARED'] + ' ' + dct['CFLAGS']
	conf.parse_flags(all_flags, 'PYEXT')

	result = None
	if not dct["LDVERSION"]:
		dct["LDVERSION"] = env.PYTHON_VERSION

	# further simplification will be complicated
	for name in ('python' + dct['LDVERSION'], 'python' + env.PYTHON_VERSION + 'm', 'python' + env.PYTHON_VERSION.replace('.', '')):

		# LIBPATH_PYEMBED is already set; see if it works.
		if not result and env.LIBPATH_PYEMBED:
			path = env.LIBPATH_PYEMBED
			conf.to_log("\n\n# Trying default LIBPATH_PYEMBED: %r\n" % path)
			result = conf.check(lib=name, uselib='PYEMBED', libpath=path, mandatory=False, msg='Checking for library %s in LIBPATH_PYEMBED' % name)

		if not result and dct['LIBDIR']:
			path = [dct['LIBDIR']]
			conf.to_log("\n\n# try again with -L$python_LIBDIR: %r\n" % path)
			result = conf.check(lib=name, uselib='PYEMBED', libpath=path, mandatory=False, msg='Checking for library %s in LIBDIR' % name)

		if not result and dct['LIBPL']:
			path = [dct['LIBPL']]
			conf.to_log("\n\n# try again with -L$python_LIBPL (some systems don't install the python library in $prefix/lib)\n")
			result = conf.check(lib=name, uselib='PYEMBED', libpath=path, mandatory=False, msg='Checking for library %s in python_LIBPL' % name)

		if not result:
			path = [os.path.join(dct['prefix'], "libs")]
			conf.to_log("\n\n# try again with -L$prefix/libs, and pythonXY rather than pythonX.Y (win32)\n")
			result = conf.check(lib=name, uselib='PYEMBED', libpath=path, mandatory=False, msg='Checking for library %s in $prefix/libs' % name)

		if not result:
			path = [os.path.normpath(os.path.join(dct['INCLUDEPY'], '..', 'libs'))]
			conf.to_log("\n\n# try again with -L$INCLUDEPY/../libs, and pythonXY rather than pythonX.Y (win32)\n")
			result = conf.check(lib=name, uselib='PYEMBED', libpath=path, mandatory=False, msg='Checking for library %s in $INCLUDEPY/../libs' % name)

		if result:
			break # do not forget to set LIBPATH_PYEMBED

	if result:
		env.LIBPATH_PYEMBED = path
		env.append_value('LIB_PYEMBED', [name])
	else:
		conf.to_log("\n\n### LIB NOT FOUND\n")

	# under certain conditions, python extensions must link to
	# python libraries, not just python embedding programs.
	if Utils.is_win32 or dct['Py_ENABLE_SHARED']:
		env.LIBPATH_PYEXT = env.LIBPATH_PYEMBED
		env.LIB_PYEXT = env.LIB_PYEMBED

	conf.to_log("Found an include path for Python extensions: %r\n" % (dct['INCLUDEPY'],))
	env.INCLUDES_PYEXT = [dct['INCLUDEPY']]
	env.INCLUDES_PYEMBED = [dct['INCLUDEPY']]

	# Code using the Python API needs to be compiled with -fno-strict-aliasing
	if env.CC_NAME == 'gcc':
		env.append_unique('CFLAGS_PYEMBED', ['-fno-strict-aliasing'])
		env.append_unique('CFLAGS_PYEXT', ['-fno-strict-aliasing'])
	if env.CXX_NAME == 'gcc':
		env.append_unique('CXXFLAGS_PYEMBED', ['-fno-strict-aliasing'])
		env.append_unique('CXXFLAGS_PYEXT', ['-fno-strict-aliasing'])

	if env.CC_NAME == "msvc":
		try:
			from distutils.msvccompiler import MSVCCompiler
		except ImportError:
			# From https://github.com/python/cpython/blob/main/Lib/distutils/msvccompiler.py
			env.append_value('CFLAGS_PYEXT', [ '/nologo', '/Ox', '/MD', '/W3', '/GX', '/DNDEBUG'])
			env.append_value('CXXFLAGS_PYEXT', [ '/nologo', '/Ox', '/MD', '/W3', '/GX', '/DNDEBUG'])
			env.append_value('LINKFLAGS_PYEXT', ['/DLL', '/nologo', '/INCREMENTAL:NO'])
		else:
			dist_compiler = MSVCCompiler()
			dist_compiler.initialize()
			env.append_value('CFLAGS_PYEXT', dist_compiler.compile_options)
			env.append_value('CXXFLAGS_PYEXT', dist_compiler.compile_options)
			env.append_value('LINKFLAGS_PYEXT', dist_compiler.ldflags_shared)

	conf.check(header_name='Python.h', define_name='HAVE_PYTHON_H', uselib='PYEMBED', fragment=FRAG, errmsg='Could not build a Python embedded interpreter')

@conf
def check_python_version(conf, minver=None):
	"""
	Check if the python interpreter is found matching a given minimum version.
	minver should be a tuple, eg. to check for python >= 2.4.2 pass (2,4,2) as minver.

	If successful, PYTHON_VERSION is defined as 'MAJOR.MINOR' (eg. '2.4')
	of the actual python version found, and PYTHONDIR and PYTHONARCHDIR
	are defined, pointing to the site-packages directories appropriate for
	this python version, where modules/packages/extensions should be
	installed.

	:param minver: minimum version
	:type minver: tuple of int
	"""
	assert minver is None or isinstance(minver, tuple)
	pybin = conf.env.PYTHON
	if not pybin:
		conf.fatal('could not find the python executable')

	# Get python version string
	cmd = pybin + ['-c', 'import sys\nfor x in sys.version_info: print(str(x))']
	Logs.debug('python: Running python command %r', cmd)
	lines = conf.cmd_and_log(cmd).split()
	assert len(lines) == 5, "found %r lines, expected 5: %r" % (len(lines), lines)
	pyver_tuple = (int(lines[0]), int(lines[1]), int(lines[2]), lines[3], int(lines[4]))

	# Compare python version with the minimum required
	result = (minver is None) or (pyver_tuple >= minver)

	if result:
		# define useful environment variables
		pyver = '.'.join([str(x) for x in pyver_tuple[:2]])
		conf.env.PYTHON_VERSION = pyver

		if 'PYTHONDIR' in conf.env:
			# Check if --pythondir was specified
			pydir = conf.env.PYTHONDIR
		elif 'PYTHONDIR' in conf.environ:
			# Check environment for PYTHONDIR
			pydir = conf.environ['PYTHONDIR']
		else:
			# Finally, try to guess
			if Utils.is_win32:
				(pydir,) = conf.get_python_variables(["get_python_lib(standard_lib=0) or ''"])
			else:
				(pydir,) = conf.get_python_variables(["get_python_lib(standard_lib=0, prefix=%r) or ''" % conf.env.PREFIX])

		if 'PYTHONARCHDIR' in conf.env:
			# Check if --pythonarchdir was specified
			pyarchdir = conf.env.PYTHONARCHDIR
		elif 'PYTHONARCHDIR' in conf.environ:
			# Check environment for PYTHONDIR
			pyarchdir = conf.environ['PYTHONARCHDIR']
		else:
			# Finally, try to guess
			(pyarchdir, ) = conf.get_python_variables(["get_python_lib(plat_specific=1, standard_lib=0, prefix=%r) or ''" % conf.env.PREFIX])
			if not pyarchdir:
				pyarchdir = pydir

		if hasattr(conf, 'define'): # conf.define is added by the C tool, so may not exist
			conf.define('PYTHONDIR', pydir)
			conf.define('PYTHONARCHDIR', pyarchdir)

		conf.env.PYTHONDIR = pydir
		conf.env.PYTHONARCHDIR = pyarchdir

	# Feedback
	pyver_full = '.'.join(map(str, pyver_tuple[:3]))
	if minver is None:
		conf.msg('Checking for python version', pyver_full)
	else:
		minver_str = '.'.join(map(str, minver))
		conf.msg('Checking for python version >= %s' % (minver_str,), pyver_full, color=result and 'GREEN' or 'YELLOW')

	if not result:
		conf.fatal('The python version is too old, expecting %r' % (minver,))

PYTHON_MODULE_TEMPLATE = '''
import %s as current_module
version = getattr(current_module, '__version__', None)
if version is not None:
	print(str(version))
else:
	print('unknown version')
'''

@conf
def check_python_module(conf, module_name, condition=''):
	"""
	Check if the selected python interpreter can import the given python module::

		def configure(conf):
			conf.check_python_module('pygccxml')
			conf.check_python_module('re', condition="ver > num(2, 0, 4) and ver <= num(3, 0, 0)")

	:param module_name: module
	:type module_name: string
	"""
	msg = "Checking for python module %r" % module_name
	if condition:
		msg = '%s (%s)' % (msg, condition)
	conf.start_msg(msg)
	try:
		ret = conf.cmd_and_log(conf.env.PYTHON + ['-c', PYTHON_MODULE_TEMPLATE % module_name])
	except Errors.WafError:
		conf.end_msg(False)
		conf.fatal('Could not find the python module %r' % module_name)

	ret = ret.strip()
	if condition:
		conf.end_msg(ret)
		if ret == 'unknown version':
			conf.fatal('Could not check the %s version' % module_name)

		def num(*k):
			if isinstance(k[0], int):
				return Utils.loose_version('.'.join([str(x) for x in k]))
			else:
				return Utils.loose_version(k[0])
		d = {'num': num, 'ver': Utils.loose_version(ret)}
		ev = eval(condition, {}, d)
		if not ev:
			conf.fatal('The %s version does not satisfy the requirements' % module_name)
	else:
		if ret == 'unknown version':
			conf.end_msg(True)
		else:
			conf.end_msg(ret)

def configure(conf):
	"""
	Detect the python interpreter
	"""
	v = conf.env
	if getattr(Options.options, 'pythondir', None):
		v.PYTHONDIR = Options.options.pythondir
	if getattr(Options.options, 'pythonarchdir', None):
		v.PYTHONARCHDIR = Options.options.pythonarchdir
	if getattr(Options.options, 'nopycache', None):
		v.NOPYCACHE=Options.options.nopycache

	if not v.PYTHON:
		v.PYTHON = [getattr(Options.options, 'python', None) or sys.executable]
	v.PYTHON = Utils.to_list(v.PYTHON)
	conf.find_program('python', var='PYTHON')

	v.PYFLAGS = ''
	v.PYFLAGS_OPT = '-O'

	v.PYC = getattr(Options.options, 'pyc', 1)
	v.PYO = getattr(Options.options, 'pyo', 1)

	try:
		v.PYTAG = conf.cmd_and_log(conf.env.PYTHON + ['-c', "import sys\ntry:\n print(sys.implementation.cache_tag)\nexcept AttributeError:\n import imp\n print(imp.get_tag())\n"]).strip()
	except Errors.WafError:
		pass

def options(opt):
	"""
	Add python-specific options
	"""
	pyopt=opt.add_option_group("Python Options")
	pyopt.add_option('--nopyc', dest = 'pyc', action='store_false', default=1,
					 help = 'Do not install bytecode compiled .pyc files (configuration) [Default:install]')
	pyopt.add_option('--nopyo', dest='pyo', action='store_false', default=1,
					 help='Do not install optimised compiled .pyo files (configuration) [Default:install]')
	pyopt.add_option('--nopycache',dest='nopycache', action='store_true',
					 help='Do not use __pycache__ directory to install objects [Default:auto]')
	pyopt.add_option('--python', dest="python",
					 help='python binary to be used [Default: %s]' % sys.executable)
	pyopt.add_option('--pythondir', dest='pythondir',
					 help='Installation path for python modules (py, platform-independent .py and .pyc files)')
	pyopt.add_option('--pythonarchdir', dest='pythonarchdir',
					 help='Installation path for python extension (pyext, platform-dependent .so or .dylib files)')

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                #!/usr/bin/env python
# encoding: utf-8
# Thomas Nagy, 2006-2018 (ita)
# Rafal Kooi, 2023 (RA-Kooi)

"""
This tool helps with finding Qt5 and Qt6 tools and libraries,
and also provides syntactic sugar for using Qt5 and Qt6 tools.

The following snippet illustrates the tool usage::

	def options(opt):
		opt.load('compiler_cxx qt5')

	def configure(conf):
		conf.load('compiler_cxx qt5')

	def build(bld):
		bld(
			features = 'qt5 cxx cxxprogram',
			uselib   = 'QT5CORE QT5GUI QT5OPENGL QT5SVG',
			source   = 'main.cpp textures.qrc aboutDialog.ui',
			target   = 'window',
		)

Alternatively the following snippet illustrates Qt6 tool usage::

    def options(opt):
        opt.load('compiler_cxx qt5')

    def configure(conf):
        conf.want_qt6 = True
        conf.load('compiler_cxx qt5')

    def build(bld):
        bld(
            features = 'qt6 cxx cxxprogram',
            uselib   = 'QT6CORE QT6GUI QT6OPENGL QT6SVG',
            source   = 'main.cpp textures.qrc aboutDialog.ui',
            target   = 'window',
        )

Here, the UI description and resource files will be processed
to generate code.

Usage
=====

Load the "qt5" tool.

You also need to edit your sources accordingly:

- the normal way of doing things is to have your C++ files
  include the .moc file.
  This is regarded as the best practice (and provides much faster
  compilations).
  It also implies that the include paths have beenset properly.

- to have the include paths added automatically, use the following::

     from waflib.TaskGen import feature, before_method, after_method
     @feature('cxx')
     @after_method('process_source')
     @before_method('apply_incpaths')
     def add_includes_paths(self):
        incs = set(self.to_list(getattr(self, 'includes', '')))
        for x in self.compiled_tasks:
            incs.add(x.inputs[0].parent.path_from(self.path))
        self.includes = sorted(incs)

Note: another tool provides Qt processing that does not require
.moc includes, see 'playground/slow_qt/'.

A few options (--qt{dir,bin,...}) and environment variables
(QT5_{ROOT,DIR,MOC,UIC,XCOMPILE}) allow finer tuning of the tool,
tool path selection, etc; please read the source for more info.
For Qt6 replace the QT5_ prefix with QT6_.

The detection uses pkg-config on Linux by default. The list of
libraries to be requested to pkg-config is formulated by scanning
in the QTLIBS directory (that can be passed via --qtlibs or by
setting the environment variable QT5_LIBDIR or QT6_LIBDIR otherwise is
derived by querying qmake for QT_INSTALL_LIBS directory) for
shared/static libraries present.
Alternatively the list of libraries to be requested via pkg-config
can be set using the qt5_vars attribute, ie:

      conf.qt5_vars = ['Qt5Core', 'Qt5Gui', 'Qt5Widgets', 'Qt5Test'];

For Qt6 use the qt6_vars attribute.

This can speed up configuration phase if needed libraries are
known beforehand, can improve detection on systems with a
sparse QT5/Qt6 libraries installation (ie. NIX) and can improve
detection of some header-only Qt modules (ie. Qt5UiPlugin).

To force static library detection use:
QT5_XCOMPILE=1 QT5_FORCE_STATIC=1 waf configure

To use Qt6 set the want_qt6 attribute, ie:

    conf.want_qt6 = True;
"""

from __future__ import with_statement

try:
	from xml.sax import make_parser
	from xml.sax.handler import ContentHandler
except ImportError:
	has_xml = False
	ContentHandler = object
else:
	has_xml = True

import os, sys, re
from waflib.Tools import cxx
from waflib import Build, Task, Utils, Options, Errors, Context
from waflib.TaskGen import feature, after_method, extension, before_method
from waflib.Configure import conf
from waflib import Logs

MOC_H = ['.h', '.hpp', '.hxx', '.hh']
"""
File extensions associated to .moc files
"""

EXT_RCC = ['.qrc']
"""
File extension for the resource (.qrc) files
"""

EXT_UI  = ['.ui']
"""
File extension for the user interface (.ui) files
"""

EXT_QT5 = ['.cpp', '.cc', '.cxx', '.C']
"""
File extensions of C++ files that may require a .moc processing
"""

class qxx(Task.classes['cxx']):
	"""
	Each C++ file can have zero or several .moc files to create.
	They are known only when the files are scanned (preprocessor)
	To avoid scanning the c++ files each time (parsing C/C++), the results
	are retrieved from the task cache (bld.node_deps/bld.raw_deps).
	The moc tasks are also created *dynamically* during the build.
	"""

	def __init__(self, *k, **kw):
		Task.Task.__init__(self, *k, **kw)
		self.moc_done = 0

	def runnable_status(self):
		"""
		Compute the task signature to make sure the scanner was executed. Create the
		moc tasks by using :py:meth:`waflib.Tools.qt5.qxx.add_moc_tasks` (if necessary),
		then postpone the task execution (there is no need to recompute the task signature).
		"""
		if self.moc_done:
			return Task.Task.runnable_status(self)
		else:
			for t in self.run_after:
				if not t.hasrun:
					return Task.ASK_LATER
			self.add_moc_tasks()
			return Task.Task.runnable_status(self)

	def create_moc_task(self, h_node, m_node):
		"""
		If several libraries use the same classes, it is possible that moc will run several times (Issue 1318)
		It is not possible to change the file names, but we can assume that the moc transformation will be identical,
		and the moc tasks can be shared in a global cache.
		"""
		try:
			moc_cache = self.generator.bld.moc_cache
		except AttributeError:
			moc_cache = self.generator.bld.moc_cache = {}

		try:
			return moc_cache[h_node]
		except KeyError:
			tsk = moc_cache[h_node] = Task.classes['moc'](env=self.env, generator=self.generator)
			tsk.set_inputs(h_node)
			tsk.set_outputs(m_node)
			tsk.env.append_unique('MOC_FLAGS', '-i')

			if self.generator:
				self.generator.tasks.append(tsk)

			# direct injection in the build phase (safe because called from the main thread)
			gen = self.generator.bld.producer
			gen.outstanding.append(tsk)
			gen.total += 1

			return tsk

		else:
			# remove the signature, it must be recomputed with the moc task
			delattr(self, 'cache_sig')

	def add_moc_tasks(self):
		"""
		Creates moc tasks by looking in the list of file dependencies ``bld.raw_deps[self.uid()]``
		"""
		node = self.inputs[0]
		bld = self.generator.bld

		# skip on uninstall due to generated files
		if bld.is_install == Build.UNINSTALL:
			return

		try:
			# compute the signature once to know if there is a moc file to create
			self.signature()
		except KeyError:
			# the moc file may be referenced somewhere else
			pass
		else:
			# remove the signature, it must be recomputed with the moc task
			delattr(self, 'cache_sig')

		include_nodes = [node.parent] + self.generator.includes_nodes

		moctasks = []
		mocfiles = set()
		for d in bld.raw_deps.get(self.uid(), []):
			if not d.endswith('.moc'):
				continue

			# process that base.moc only once
			if d in mocfiles:
				continue
			mocfiles.add(d)

			# find the source associated with the moc file
			h_node = None
			base2 = d[:-4]

			# foo.moc from foo.cpp
			prefix = node.name[:node.name.rfind('.')]
			if base2 == prefix:
				h_node = node
			else:
				# this deviates from the standard
				# if bar.cpp includes foo.moc, then assume it is from foo.h
				for x in include_nodes:
					for e in MOC_H:
						h_node = x.find_node(base2 + e)
						if h_node:
							break
					else:
						continue
					break
			if h_node:
				m_node = h_node.change_ext('.moc')
			else:
				raise Errors.WafError('No source found for %r which is a moc file' % d)

			# create the moc task
			task = self.create_moc_task(h_node, m_node)
			moctasks.append(task)

		# simple scheduler dependency: run the moc task before others
		self.run_after.update(set(moctasks))
		self.moc_done = 1

class trans_update(Task.Task):
	"""Updates a .ts files from a list of C++ files"""
	run_str = '${QT_LUPDATE} ${SRC} -ts ${TGT}'
	color   = 'BLUE'

class XMLHandler(ContentHandler):
	"""
	Parses ``.qrc`` files
	"""
	def __init__(self):
		ContentHandler.__init__(self)
		self.buf = []
		self.files = []
	def startElement(self, name, attrs):
		if name == 'file':
			self.buf = []
	def endElement(self, name):
		if name == 'file':
			self.files.append(str(''.join(self.buf)))
	def characters(self, cars):
		self.buf.append(cars)

@extension(*EXT_RCC)
def create_rcc_task(self, node):
	"Creates rcc and cxx tasks for ``.qrc`` files"
	rcnode = node.change_ext('_rc.%d.cpp' % self.idx)
	self.create_task('rcc', node, rcnode)
	cpptask = self.create_task('cxx', rcnode, rcnode.change_ext('.o'))
	try:
		self.compiled_tasks.append(cpptask)
	except AttributeError:
		self.compiled_tasks = [cpptask]
	return cpptask

@extension(*EXT_UI)
def create_uic_task(self, node):
	"Create uic tasks for user interface ``.ui`` definition files"

	"""
	If UIC file is used in more than one bld, we would have a conflict in parallel execution
	It is not possible to change the file names (like .self.idx. as for objects) as they have
	to be referenced by the source file, but we can assume that the transformation will be identical
	and the tasks can be shared in a global cache.
	"""
	try:
		uic_cache = self.bld.uic_cache
	except AttributeError:
		uic_cache = self.bld.uic_cache = {}

	if node not in uic_cache:
		uictask = uic_cache[node] = self.create_task('ui5', node)
		uictask.outputs = [node.parent.find_or_declare(self.env.ui_PATTERN % node.name[:-3])]

@extension('.ts')
def add_lang(self, node):
	"""Adds all the .ts file into ``self.lang``"""
	self.lang = self.to_list(getattr(self, 'lang', [])) + [node]

@feature('qt5', 'qt6')
@before_method('process_source')
def process_mocs(self):
	"""
	Processes MOC files included in headers::

		def build(bld):
			bld.program(features='qt5', source='main.cpp', target='app', use='QT5CORE', moc='foo.h')

	The build will run moc on foo.h to create moc_foo.n.cpp. The number in the file name
	is provided to avoid name clashes when the same headers are used by several targets.
	"""
	lst = self.to_nodes(getattr(self, 'moc', []))
	self.source = self.to_list(getattr(self, 'source', []))
	for x in lst:
		prefix = x.name[:x.name.rfind('.')] # foo.h -> foo
		moc_target = 'moc_%s.%d.cpp' % (prefix, self.idx)
		moc_node = x.parent.find_or_declare(moc_target)
		self.source.append(moc_node)

		self.create_task('moc', x, moc_node)

@feature('qt5', 'qt6')
@after_method('apply_link')
def apply_qt5(self):
	"""
	Adds MOC_FLAGS which may be necessary for moc::

		def build(bld):
			bld.program(features='qt5', source='main.cpp', target='app', use='QT5CORE')

	The additional parameters are:

	:param lang: list of translation files (\\*.ts) to process
	:type lang: list of :py:class:`waflib.Node.Node` or string without the .ts extension
	:param update: whether to process the C++ files to update the \\*.ts files (use **waf --translate**)
	:type update: bool
	:param langname: if given, transform the \\*.ts files into a .qrc files to include in the binary file
	:type langname: :py:class:`waflib.Node.Node` or string without the .qrc extension
	"""
	if getattr(self, 'lang', None):
		qmtasks = []
		for x in self.to_list(self.lang):
			if isinstance(x, str):
				x = self.path.find_resource(x + '.ts')
			qmtasks.append(self.create_task('ts2qm', x, x.change_ext('.%d.qm' % self.idx)))

		if getattr(self, 'update', None) and Options.options.trans_qt5:
			cxxnodes = [a.inputs[0] for a in self.compiled_tasks] + [
				a.inputs[0] for a in self.tasks if a.inputs and a.inputs[0].name.endswith('.ui')]
			for x in qmtasks:
				self.create_task('trans_update', cxxnodes, x.inputs)

		if getattr(self, 'langname', None):
			qmnodes = [x.outputs[0] for x in qmtasks]
			rcnode = self.langname
			if isinstance(rcnode, str):
				rcnode = self.path.find_or_declare(rcnode + ('.%d.qrc' % self.idx))
			t = self.create_task('qm2rcc', qmnodes, rcnode)
			k = create_rcc_task(self, t.outputs[0])
			self.link_task.inputs.append(k.outputs[0])

	lst = []
	for flag in self.to_list(self.env.CXXFLAGS):
		if len(flag) < 2:
			continue
		f = flag[0:2]
		if f in ('-D', '-I', '/D', '/I'):
			if (f[0] == '/'):
				lst.append('-' + flag[1:])
			else:
				lst.append(flag)
	self.env.append_value('MOC_FLAGS', lst)

@extension(*EXT_QT5)
def cxx_hook(self, node):
	"""
	Re-maps C++ file extensions to the :py:class:`waflib.Tools.qt5.qxx` task.
	"""
	return self.create_compiled_task('qxx', node)

class rcc(Task.Task):
	"""
	Processes ``.qrc`` files
	"""
	color   = 'BLUE'
	run_str = '${QT_RCC} -name ${tsk.rcname()} ${SRC[0].abspath()} ${RCC_ST} -o ${TGT}'
	ext_out = ['.h']

	def rcname(self):
		return os.path.splitext(self.inputs[0].name)[0]

	def scan(self):
		"""Parse the *.qrc* files"""
		if not has_xml:
			Logs.error('No xml.sax support was found, rcc dependencies will be incomplete!')
			return ([], [])

		parser = make_parser()
		curHandler = XMLHandler()
		parser.setContentHandler(curHandler)
		with open(self.inputs[0].abspath(), 'r') as f:
			parser.parse(f)

		nodes = []
		names = []
		root = self.inputs[0].parent
		for x in curHandler.files:
			nd = root.find_resource(x)
			if nd:
				nodes.append(nd)
			else:
				names.append(x)
		return (nodes, names)

	def quote_flag(self, x):
		"""
		Override Task.quote_flag. QT parses the argument files
		differently than cl.exe and link.exe

		:param x: flag
		:type x: string
		:return: quoted flag
		:rtype: string
		"""
		return x


class moc(Task.Task):
	"""
	Creates ``.moc`` files
	"""
	color   = 'BLUE'
	run_str = '${QT_MOC} ${MOC_FLAGS} ${MOCCPPPATH_ST:INCPATHS} ${MOCDEFINES_ST:DEFINES} ${SRC} ${MOC_ST} ${TGT}'

	def quote_flag(self, x):
		"""
		Override Task.quote_flag. QT parses the argument files
		differently than cl.exe and link.exe

		:param x: flag
		:type x: string
		:return: quoted flag
		:rtype: string
		"""
		return x


class ui5(Task.Task):
	"""
	Processes ``.ui`` files
	"""
	color   = 'BLUE'
	run_str = '${QT_UIC} ${SRC} -o ${TGT}'
	ext_out = ['.h']

class ts2qm(Task.Task):
	"""
	Generates ``.qm`` files from ``.ts`` files
	"""
	color   = 'BLUE'
	run_str = '${QT_LRELEASE} ${QT_LRELEASE_FLAGS} ${SRC} -qm ${TGT}'

class qm2rcc(Task.Task):
	"""
	Generates ``.qrc`` files from ``.qm`` files
	"""
	color = 'BLUE'
	after = 'ts2qm'
	def run(self):
		"""Create a qrc file including the inputs"""
		txt = '\n'.join(['<file>%s</file>' % k.path_from(self.outputs[0].parent) for k in self.inputs])
		code = '<!DOCTYPE RCC><RCC version="1.0">\n<qresource>\n%s\n</qresource>\n</RCC>' % txt
		self.outputs[0].write(code)

def configure(self):
	"""
	Besides the configuration options, the environment variable QT5_ROOT may be used
	to give the location of the qt5 libraries (absolute path).

	The detection uses the program ``pkg-config`` through :py:func:`waflib.Tools.config_c.check_cfg`
	"""
	if 'COMPILER_CXX' not in self.env:
		self.fatal('No CXX compiler defined: did you forget to configure compiler_cxx first?')

	self.want_qt6 = getattr(self, 'want_qt6', False)

	if self.want_qt6:
		self.qt_vars = Utils.to_list(getattr(self, 'qt6_vars', []))
	else:
		self.qt_vars = Utils.to_list(getattr(self, 'qt5_vars', []))

	self.find_qt5_binaries()
	self.set_qt5_libs_dir()
	self.set_qt5_libs_to_check()
	self.set_qt5_defines()
	self.find_qt5_libraries()
	self.add_qt5_rpath()
	self.simplify_qt5_libs()

	# warn about this during the configuration too
	if not has_xml:
		Logs.error('No xml.sax support was found, rcc dependencies will be incomplete!')

	feature = 'qt6' if self.want_qt6 else 'qt5'

	# Qt5 may be compiled with '-reduce-relocations' which requires dependent programs to have -fPIE or -fPIC?
	frag = '#include <QMap>\nint main(int argc, char **argv) {QMap<int,int> m;return m.keys().size();}\n'
	uses = 'QT6CORE' if self.want_qt6 else 'QT5CORE'

	# Qt6 requires C++17 (https://www.qt.io/blog/qt-6.0-released)
	flag_list = []
	if self.env.CXX_NAME == 'msvc':
		stdflag = '/std:c++17' if self.want_qt6 else '/std:c++11'
		flag_list = [[], ['/Zc:__cplusplus', '/permissive-', stdflag]]
	else:
		stdflag = '-std=c++17' if self.want_qt6 else '-std=c++11'
		flag_list = [[], '-fPIE', '-fPIC', stdflag, [stdflag, '-fPIE'], [stdflag, '-fPIC']]
	for flag in flag_list:
		msg = 'See if Qt files compile '
		if flag:
			msg += 'with %s' % flag
		try:
			self.check(features=feature + ' cxx', use=uses, uselib_store=feature, cxxflags=flag, fragment=frag, msg=msg)
		except self.errors.ConfigurationError:
			pass
		else:
			break
	else:
		self.fatal('Could not build a simple Qt application')

	# FreeBSD does not add /usr/local/lib and the pkg-config files do not provide it either :-/
	if Utils.unversioned_sys_platform() == 'freebsd':
		frag = '#include <QMap>\nint main(int argc, char **argv) {QMap<int,int> m;return m.keys().size();}\n'
		try:
			self.check(features=feature + ' cxx cxxprogram', use=uses, fragment=frag, msg='Can we link Qt programs on FreeBSD directly?')
		except self.errors.ConfigurationError:
			self.check(features=feature + ' cxx cxxprogram', use=uses, uselib_store=feature, libpath='/usr/local/lib', fragment=frag, msg='Is /usr/local/lib required?')

@conf
def find_qt5_binaries(self):
	"""
	Detects Qt programs such as qmake, moc, uic, lrelease
	"""
	env = self.env
	opt = Options.options

	qtdir = getattr(opt, 'qtdir', '')
	qtbin = getattr(opt, 'qtbin', '')
	qt_ver = '6' if self.want_qt6 else '5'

	paths = []

	if qtdir:
		qtbin = os.path.join(qtdir, 'bin')

	# the qt directory has been given from QT5_ROOT - deduce the qt binary path
	if not qtdir:
		qtdir = self.environ.get('QT' + qt_ver + '_ROOT', '')
		qtbin = self.environ.get('QT' + qt_ver + '_BIN') or os.path.join(qtdir, 'bin')

	if qtbin:
		paths = [qtbin]

	# no qtdir, look in the path and in /usr/local/Trolltech
	if not qtdir:
		paths = self.environ.get('PATH', '').split(os.pathsep)
		paths.extend([
			'/usr/share/qt' + qt_ver + '/bin',
			'/usr/local/lib/qt' + qt_ver + '/bin'])

		try:
			lst = Utils.listdir('/usr/local/Trolltech/')
		except OSError:
			pass
		else:
			if lst:
				lst.sort()
				lst.reverse()

				# keep the highest version
				qtdir = '/usr/local/Trolltech/%s/' % lst[0]
				qtbin = os.path.join(qtdir, 'bin')
				paths.append(qtbin)

	# at the end, try to find qmake in the paths given
	# keep the one with the highest version
	cand = None
	prev_ver = ['0', '0', '0']
	qmake_vars = ['qmake-qt' + qt_ver, 'qmake' + qt_ver, 'qmake']

	for qmk in qmake_vars:
		try:
			qmake = self.find_program(qmk, path_list=paths)
		except self.errors.ConfigurationError:
			pass
		else:
			try:
				version = self.cmd_and_log(qmake + ['-query', 'QT_VERSION']).strip()
			except self.errors.WafError:
				pass
			else:
				if version:
					new_ver = version.split('.')
					if new_ver[0] == qt_ver and new_ver > prev_ver:
						cand = qmake
						prev_ver = new_ver

	# qmake could not be found easily, rely on qtchooser
	if not cand:
		try:
			self.find_program('qtchooser')
		except self.errors.ConfigurationError:
			pass
		else:
			cmd = self.env.QTCHOOSER + ['-qt=' + qt_ver, '-run-tool=qmake']
			try:
				version = self.cmd_and_log(cmd + ['-query', 'QT_VERSION'])
			except self.errors.WafError:
				pass
			else:
				cand = cmd

	if cand:
		self.env.QMAKE = cand
	else:
		self.fatal('Could not find qmake for qt' + qt_ver)

	# Once we have qmake, we want to query qmake for the paths where we want to look for tools instead
	paths = []

	self.env.QT_HOST_BINS = qtbin = self.cmd_and_log(self.env.QMAKE + ['-query', 'QT_HOST_BINS']).strip()
	paths.append(qtbin)

	if self.want_qt6:
		self.env.QT_HOST_LIBEXECS = self.cmd_and_log(self.env.QMAKE + ['-query', 'QT_HOST_LIBEXECS']).strip()
		paths.append(self.env.QT_HOST_LIBEXECS)

	def find_bin(lst, var):
		if var in env:
			return
		for f in lst:
			try:
				ret = self.find_program(f, path_list=paths)
			except self.errors.ConfigurationError:
				pass
			else:
				env[var]=ret
				break

	find_bin(['uic-qt' + qt_ver, 'uic'], 'QT_UIC')
	if not env.QT_UIC:
		self.fatal('cannot find the uic compiler for qt' + qt_ver)

	self.start_msg('Checking for uic version')
	uicver = self.cmd_and_log(env.QT_UIC + ['-version'], output=Context.BOTH)
	uicver = ''.join(uicver).strip()
	uicver = uicver.replace('Qt User Interface Compiler ','').replace('User Interface Compiler for Qt', '')
	self.end_msg(uicver)
	if uicver.find(' 3.') != -1 or uicver.find(' 4.') != -1 or (self.want_qt6 and uicver.find(' 5.') != -1):
		if self.want_qt6:
			self.fatal('this uic compiler is for qt3 or qt4 or qt5, add uic for qt6 to your path')
		else:
			self.fatal('this uic compiler is for qt3 or qt4, add uic for qt5 to your path')

	find_bin(['moc-qt' + qt_ver, 'moc'], 'QT_MOC')
	find_bin(['rcc-qt' + qt_ver, 'rcc'], 'QT_RCC')
	find_bin(['lrelease-qt' + qt_ver, 'lrelease'], 'QT_LRELEASE')
	find_bin(['lupdate-qt' + qt_ver, 'lupdate'], 'QT_LUPDATE')

	env.UIC_ST = '%s -o %s'
	env.MOC_ST = '-o'
	env.ui_PATTERN = 'ui_%s.h'
	env.QT_LRELEASE_FLAGS = ['-silent']
	env.MOCCPPPATH_ST = '-I%s'
	env.MOCDEFINES_ST = '-D%s'

@conf
def set_qt5_libs_dir(self):
	env = self.env
	qt_ver = '6' if self.want_qt6 else '5'

	qtlibs = getattr(Options.options, 'qtlibs', None) or self.environ.get('QT' + qt_ver + '_LIBDIR')

	if not qtlibs:
		try:
			qtlibs = self.cmd_and_log(env.QMAKE + ['-query', 'QT_INSTALL_LIBS']).strip()
		except Errors.WafError:
			qtdir = self.cmd_and_log(env.QMAKE + ['-query', 'QT_INSTALL_PREFIX']).strip()
			qtlibs = os.path.join(qtdir, 'lib')

	self.msg('Found the Qt' + qt_ver + ' library path', qtlibs)

	env.QTLIBS = qtlibs

@conf
def find_single_qt5_lib(self, name, uselib, qtlibs, qtincludes, force_static):
	env = self.env
	qt_ver = '6' if self.want_qt6 else '5'

	if force_static:
		exts = ('.a', '.lib')
		prefix = 'STLIB'
	else:
		exts = ('.so', '.lib')
		prefix = 'LIB'

	def lib_names():
		for x in exts:
			for k in ('', qt_ver) if Utils.is_win32 else ['']:
				for p in ('lib', ''):
					yield (p, name, k, x)

	for tup in lib_names():
		k = ''.join(tup)
		path = os.path.join(qtlibs, k)
		if os.path.exists(path):
			if env.DEST_OS == 'win32':
				libval = ''.join(tup[:-1])
			else:
				libval = name
			env.append_unique(prefix + '_' + uselib, libval)
			env.append_unique('%sPATH_%s' % (prefix, uselib), qtlibs)
			env.append_unique('INCLUDES_' + uselib, qtincludes)
			env.append_unique('INCLUDES_' + uselib, os.path.join(qtincludes, name.replace('Qt' + qt_ver, 'Qt')))
			return k
	return False

@conf
def find_qt5_libraries(self):
	env = self.env
	qt_ver = '6' if self.want_qt6 else '5'

	qtincludes =  self.environ.get('QT' + qt_ver + '_INCLUDES') or self.cmd_and_log(env.QMAKE + ['-query', 'QT_INSTALL_HEADERS']).strip()
	force_static = self.environ.get('QT' + qt_ver + '_FORCE_STATIC')

	try:
		if self.environ.get('QT' + qt_ver + '_XCOMPILE'):
			self.fatal('QT' + qt_ver + '_XCOMPILE Disables pkg-config detection')
		self.check_cfg(atleast_pkgconfig_version='0.1')
	except self.errors.ConfigurationError:
		for i in self.qt_vars:
			uselib = i.upper()
			if Utils.unversioned_sys_platform() == 'darwin':
				# Since at least qt 4.7.3 each library locates in separate directory
				fwk = i.replace('Qt' + qt_ver, 'Qt')
				frameworkName = fwk + '.framework'

				qtDynamicLib = os.path.join(env.QTLIBS, frameworkName, fwk)
				if os.path.exists(qtDynamicLib):
					env.append_unique('FRAMEWORK_' + uselib, fwk)
					env.append_unique('FRAMEWORKPATH_' + uselib, env.QTLIBS)
					self.msg('Checking for %s' % i, qtDynamicLib, 'GREEN')
				else:
					self.msg('Checking for %s' % i, False, 'YELLOW')
				env.append_unique('INCLUDES_' + uselib, os.path.join(env.QTLIBS, frameworkName, 'Headers'))
			else:
				ret = self.find_single_qt5_lib(i, uselib, env.QTLIBS, qtincludes, force_static)
				if not force_static and not ret:
					ret = self.find_single_qt5_lib(i, uselib, env.QTLIBS, qtincludes, True)
				self.msg('Checking for %s' % i, ret, 'GREEN' if ret else 'YELLOW')
	else:
		path = '%s:%s:%s/pkgconfig:/usr/lib/qt%s/lib/pkgconfig:/opt/qt%s/lib/pkgconfig:/usr/lib/qt%s/lib:/opt/qt%s/lib' % (
			self.environ.get('PKG_CONFIG_PATH', ''), env.QTLIBS, env.QTLIBS, qt_ver, qt_ver, qt_ver, qt_ver)
		for i in self.qt_vars:
			self.check_cfg(package=i, args='--cflags --libs', mandatory=False, force_static=force_static, pkg_config_path=path)

@conf
def simplify_qt5_libs(self):
	"""
	Since library paths make really long command-lines,
	and since everything depends on qtcore, remove the qtcore ones from qtgui, etc
	"""
	env = self.env
	def process_lib(vars_, coreval):
		for d in vars_:
			var = d.upper()
			if var == 'QTCORE':
				continue

			value = env['LIBPATH_'+var]
			if value:
				core = env[coreval]
				accu = []
				for lib in value:
					if lib in core:
						continue
					accu.append(lib)
				env['LIBPATH_'+var] = accu
	process_lib(self.qt_vars, 'LIBPATH_QTCORE')

@conf
def add_qt5_rpath(self):
	"""
	Defines rpath entries for Qt libraries
	"""
	env = self.env
	if getattr(Options.options, 'want_rpath', False):
		def process_rpath(vars_, coreval):
			for d in vars_:
				var = d.upper()
				value = env['LIBPATH_' + var]
				if value:
					core = env[coreval]
					accu = []
					for lib in value:
						if var != 'QTCORE':
							if lib in core:
								continue
						accu.append('-Wl,--rpath='+lib)
					env['RPATH_' + var] = accu
		process_rpath(self.qt_vars, 'LIBPATH_QTCORE')

@conf
def set_qt5_libs_to_check(self):
	qt_ver = '6' if self.want_qt6 else '5'

	if not self.qt_vars:
		dirlst = Utils.listdir(self.env.QTLIBS)

		pat = self.env.cxxshlib_PATTERN
		if Utils.is_win32:
			pat = pat.replace('.dll', '.lib')
		if self.environ.get('QT' + qt_ver + '_FORCE_STATIC'):
			pat = self.env.cxxstlib_PATTERN
		if Utils.unversioned_sys_platform() == 'darwin':
			pat = r"%s\.framework"

		if self.want_qt6:
			# match Qt6Name or QtName but not Qt5Name
			mid_pattern = pat % 'Qt6?(?P<name>[^5]\\w+)'
		else:
			# match Qt5Name or QtName but not Qt6Name
			mid_pattern = pat % 'Qt5?(?P<name>[^6]\\w+)'
		re_qt = re.compile('^%s$' % mid_pattern)

		for x in sorted(dirlst):
			m = re_qt.match(x)
			if m:
				self.qt_vars.append("Qt%s%s" % (qt_ver, m.group('name')))
		if not self.qt_vars:
			self.fatal('cannot find any Qt%s library (%r)' % (qt_ver, self.env.QTLIBS))

	qtextralibs = getattr(Options.options, 'qtextralibs', None)
	if qtextralibs:
		self.qt_vars.extend(qtextralibs.split(','))

@conf
def set_qt5_defines(self):
	qt_ver = '6' if self.want_qt6 else '5'

	if sys.platform != 'win32':
		return

	for x in self.qt_vars:
		y=x.replace('Qt' + qt_ver, 'Qt')[2:].upper()
		self.env.append_unique('DEFINES_%s' % x.upper(), 'QT_%s_LIB' % y)

def options(opt):
	"""
	Command-line options
	"""
	opt.add_option('--want-rpath', action='store_true', default=False, dest='want_rpath', help='enable the rpath for qt libraries')
	for i in 'qtdir qtbin qtlibs'.split():
		opt.add_option('--'+i, type='string', default='', dest=i)

	opt.add_option('--translate', action='store_true', help='collect translation strings', dest='trans_qt5', default=False)
	opt.add_option('--qtextralibs', type='string', default='', dest='qtextralibs', help='additional qt libraries on the system to add to default ones, comma separated')

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      #!/usr/bin/env python
# encoding: utf-8
# daniel.svensson at purplescout.se 2008
# Thomas Nagy 2016-2018 (ita)

"""
Support for Ruby extensions. A C/C++ compiler is required::

	def options(opt):
		opt.load('compiler_c ruby')
	def configure(conf):
		conf.load('compiler_c ruby')
		conf.check_ruby_version((1,8,0))
		conf.check_ruby_ext_devel()
		conf.check_ruby_module('libxml')
	def build(bld):
		bld(
			features = 'c cshlib rubyext',
			source = 'rb_mytest.c',
			target = 'mytest_ext',
			install_path = '${ARCHDIR_RUBY}')
		bld.install_files('${LIBDIR_RUBY}', 'Mytest.rb')
"""

import os
from waflib import Errors, Options, Task, Utils
from waflib.TaskGen import before_method, feature, extension
from waflib.Configure import conf

@feature('rubyext')
@before_method('apply_incpaths', 'process_source', 'apply_bundle', 'apply_link')
def init_rubyext(self):
	"""
	Add required variables for ruby extensions
	"""
	self.install_path = '${ARCHDIR_RUBY}'
	self.uselib = self.to_list(getattr(self, 'uselib', ''))
	if not 'RUBY' in self.uselib:
		self.uselib.append('RUBY')
	if not 'RUBYEXT' in self.uselib:
		self.uselib.append('RUBYEXT')

@feature('rubyext')
@before_method('apply_link', 'propagate_uselib_vars')
def apply_ruby_so_name(self):
	"""
	Strip the *lib* prefix from ruby extensions
	"""
	self.env.cshlib_PATTERN = self.env.cxxshlib_PATTERN = self.env.rubyext_PATTERN

@conf
def check_ruby_version(self, minver=()):
	"""
	Checks if ruby is installed.
	If installed the variable RUBY will be set in environment.
	The ruby binary can be overridden by ``--with-ruby-binary`` command-line option.
	"""

	ruby = self.find_program('ruby', var='RUBY', value=Options.options.rubybinary)

	try:
		version = self.cmd_and_log(ruby + ['-e', 'puts defined?(VERSION) ? VERSION : RUBY_VERSION']).strip()
	except Errors.WafError:
		self.fatal('could not determine ruby version')
	self.env.RUBY_VERSION = version

	try:
		ver = tuple(map(int, version.split('.')))
	except Errors.WafError:
		self.fatal('unsupported ruby version %r' % version)

	cver = ''
	if minver:
		cver = '> ' + '.'.join(str(x) for x in minver)
		if ver < minver:
			self.fatal('ruby is too old %r' % ver)

	self.msg('Checking for ruby version %s' % cver, version)

@conf
def check_ruby_ext_devel(self):
	"""
	Check if a ruby extension can be created
	"""
	if not self.env.RUBY:
		self.fatal('ruby detection is required first')

	if not self.env.CC_NAME and not self.env.CXX_NAME:
		self.fatal('load a c/c++ compiler first')

	version = tuple(map(int, self.env.RUBY_VERSION.split(".")))

	def read_out(cmd):
		return Utils.to_list(self.cmd_and_log(self.env.RUBY + ['-rrbconfig', '-e', cmd]))

	def read_config(key):
		return read_out('puts RbConfig::CONFIG[%r]' % key)

	cpppath = archdir = read_config('archdir')

	if version >= (1, 9, 0):
		ruby_hdrdir = read_config('rubyhdrdir')
		cpppath += ruby_hdrdir
		if version >= (2, 0, 0):
			cpppath += read_config('rubyarchhdrdir')
		cpppath += [os.path.join(ruby_hdrdir[0], read_config('arch')[0])]

	self.check(header_name='ruby.h', includes=cpppath, errmsg='could not find ruby header file', link_header_test=False)

	self.env.LIBPATH_RUBYEXT = read_config('libdir')
	self.env.LIBPATH_RUBYEXT += archdir
	self.env.INCLUDES_RUBYEXT = cpppath
	self.env.CFLAGS_RUBYEXT = read_config('CCDLFLAGS')
	self.env.rubyext_PATTERN = '%s.' + read_config('DLEXT')[0]

	# ok this is really stupid, but the command and flags are combined.
	# so we try to find the first argument...
	flags = read_config('LDSHARED')
	while flags and flags[0][0] != '-':
		flags = flags[1:]

	# we also want to strip out the deprecated ppc flags
	if len(flags) > 1 and flags[1] == "ppc":
		flags = flags[2:]

	self.env.LINKFLAGS_RUBYEXT = flags
	self.env.LINKFLAGS_RUBYEXT += read_config('LIBS')
	self.env.LINKFLAGS_RUBYEXT += read_config('LIBRUBYARG_SHARED')

	if Options.options.rubyarchdir:
		self.env.ARCHDIR_RUBY = Options.options.rubyarchdir
	else:
		self.env.ARCHDIR_RUBY = read_config('sitearchdir')[0]

	if Options.options.rubylibdir:
		self.env.LIBDIR_RUBY = Options.options.rubylibdir
	else:
		self.env.LIBDIR_RUBY = read_config('sitelibdir')[0]

@conf
def check_ruby_module(self, module_name):
	"""
	Check if the selected ruby interpreter can require the given ruby module::

		def configure(conf):
			conf.check_ruby_module('libxml')

	:param module_name: module
	:type  module_name: string
	"""
	self.start_msg('Ruby module %s' % module_name)
	try:
		self.cmd_and_log(self.env.RUBY + ['-e', 'require \'%s\';puts 1' % module_name])
	except Errors.WafError:
		self.end_msg(False)
		self.fatal('Could not find the ruby module %r' % module_name)
	self.end_msg(True)

@extension('.rb')
def process(self, node):
	return self.create_task('run_ruby', node)

class run_ruby(Task.Task):
	"""
	Task to run ruby files detected by file extension .rb::

		def options(opt):
			opt.load('ruby')

		def configure(ctx):
			ctx.check_ruby_version()

		def build(bld):
			bld.env.RBFLAGS = '-e puts "hello world"'
			bld(source='a_ruby_file.rb')
	"""
	run_str = '${RUBY} ${RBFLAGS} -I ${SRC[0].parent.abspath()} ${SRC}'

def options(opt):
	"""
	Add the ``--with-ruby-archdir``, ``--with-ruby-libdir`` and ``--with-ruby-binary`` options
	"""
	opt.add_option('--with-ruby-archdir', type='string', dest='rubyarchdir', help='Specify directory where to install arch specific files')
	opt.add_option('--with-ruby-libdir', type='string', dest='rubylibdir', help='Specify alternate ruby library path')
	opt.add_option('--with-ruby-binary', type='string', dest='rubybinary', help='Specify alternate ruby binary')

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     #!/usr/bin/env python
# encoding: utf-8
# Thomas Nagy, 2006-2018 (ita)
# Ralf Habacker, 2006 (rh)

from waflib import Errors
from waflib.Tools import ccroot, ar
from waflib.Configure import conf

@conf
def find_scc(conf):
	"""
	Detects the Sun C compiler
	"""
	v = conf.env
	cc = conf.find_program('cc', var='CC')
	try:
		conf.cmd_and_log(cc + ['-flags'])
	except Errors.WafError:
		conf.fatal('%r is not a Sun compiler' % cc)
	v.CC_NAME = 'sun'
	conf.get_suncc_version(cc)

@conf
def scc_common_flags(conf):
	"""
	Flags required for executing the sun C compiler
	"""
	v = conf.env

	v.CC_SRC_F            = []
	v.CC_TGT_F            = ['-c', '-o', '']

	if not v.LINK_CC:
		v.LINK_CC = v.CC

	v.CCLNK_SRC_F         = ''
	v.CCLNK_TGT_F         = ['-o', '']
	v.CPPPATH_ST          = '-I%s'
	v.DEFINES_ST          = '-D%s'

	v.LIB_ST              = '-l%s' # template for adding libs
	v.LIBPATH_ST          = '-L%s' # template for adding libpaths
	v.STLIB_ST            = '-l%s'
	v.STLIBPATH_ST        = '-L%s'

	v.SONAME_ST           = '-Wl,-h,%s'
	v.SHLIB_MARKER        = '-Bdynamic'
	v.STLIB_MARKER        = '-Bstatic'

	v.cprogram_PATTERN    = '%s'

	v.CFLAGS_cshlib       = ['-xcode=pic32', '-DPIC']
	v.LINKFLAGS_cshlib    = ['-G']
	v.cshlib_PATTERN      = 'lib%s.so'

	v.LINKFLAGS_cstlib    = ['-Bstatic']
	v.cstlib_PATTERN      = 'lib%s.a'

def configure(conf):
	conf.find_scc()
	conf.find_ar()
	conf.scc_common_flags()
	conf.cc_load_tools()
	conf.cc_add_flags()
	conf.link_add_flags()

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             #!/usr/bin/env python
# encoding: utf-8
# Thomas Nagy, 2006-2018 (ita)
# Ralf Habacker, 2006 (rh)

from waflib import Errors
from waflib.Tools import ccroot, ar
from waflib.Configure import conf

@conf
def find_sxx(conf):
	"""
	Detects the sun C++ compiler
	"""
	v = conf.env
	cc = conf.find_program(['CC', 'c++'], var='CXX')
	try:
		conf.cmd_and_log(cc + ['-flags'])
	except Errors.WafError:
		conf.fatal('%r is not a Sun compiler' % cc)
	v.CXX_NAME = 'sun'
	conf.get_suncc_version(cc)

@conf
def sxx_common_flags(conf):
	"""
	Flags required for executing the sun C++ compiler
	"""
	v = conf.env

	v.CXX_SRC_F           = []
	v.CXX_TGT_F           = ['-c', '-o', '']

	if not v.LINK_CXX:
		v.LINK_CXX = v.CXX

	v.CXXLNK_SRC_F        = []
	v.CXXLNK_TGT_F        = ['-o', '']
	v.CPPPATH_ST          = '-I%s'
	v.DEFINES_ST          = '-D%s'

	v.LIB_ST              = '-l%s' # template for adding libs
	v.LIBPATH_ST          = '-L%s' # template for adding libpaths
	v.STLIB_ST            = '-l%s'
	v.STLIBPATH_ST        = '-L%s'

	v.SONAME_ST           = '-Wl,-h,%s'
	v.SHLIB_MARKER        = '-Bdynamic'
	v.STLIB_MARKER        = '-Bstatic'

	v.cxxprogram_PATTERN  = '%s'

	v.CXXFLAGS_cxxshlib   = ['-xcode=pic32', '-DPIC']
	v.LINKFLAGS_cxxshlib  = ['-G']
	v.cxxshlib_PATTERN    = 'lib%s.so'

	v.LINKFLAGS_cxxstlib  = ['-Bstatic']
	v.cxxstlib_PATTERN    = 'lib%s.a'

def configure(conf):
	conf.find_sxx()
	conf.find_ar()
	conf.sxx_common_flags()
	conf.cxx_load_tools()
	conf.cxx_add_flags()
	conf.link_add_flags()

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         #!/usr/bin/env python
# encoding: utf-8
# Thomas Nagy, 2006-2018 (ita)

"""
TeX/LaTeX/PDFLaTeX/XeLaTeX support

Example::

	def configure(conf):
		conf.load('tex')
		if not conf.env.LATEX:
			conf.fatal('The program LaTex is required')

	def build(bld):
		bld(
			features = 'tex',
			type     = 'latex', # pdflatex or xelatex
			source   = 'document.ltx', # mandatory, the source
			outs     = 'ps', # 'pdf' or 'ps pdf'
			deps     = 'crossreferencing.lst', # to give dependencies directly
			prompt   = 1, # 0 for the batch mode
		)

Notes:

- To configure with a special program, use::

     $ PDFLATEX=luatex waf configure

- This tool does not use the target attribute of the task generator
  (``bld(target=...)``); the target file name is built from the source
  base name and the output type(s)
"""

import os, re
from waflib import Utils, Task, Errors, Logs, Node
from waflib.TaskGen import feature, before_method

re_bibunit = re.compile(r'\\(?P<type>putbib)\[(?P<file>[^\[\]]*)\]',re.M)
def bibunitscan(self):
	"""
	Parses TeX inputs and try to find the *bibunit* file dependencies

	:return: list of bibunit files
	:rtype: list of :py:class:`waflib.Node.Node`
	"""
	node = self.inputs[0]

	nodes = []
	if not node:
		return nodes

	code = node.read()
	for match in re_bibunit.finditer(code):
		path = match.group('file')
		if path:
			found = None
			for k in ('', '.bib'):
				# add another loop for the tex include paths?
				Logs.debug('tex: trying %s%s', path, k)
				fi = node.parent.find_resource(path + k)
				if fi:
					found = True
					nodes.append(fi)
					# no break
			if not found:
				Logs.debug('tex: could not find %s', path)

	Logs.debug('tex: found the following bibunit files: %s', nodes)
	return nodes

exts_deps_tex = ['', '.ltx', '.tex', '.bib', '.pdf', '.png', '.eps', '.ps', '.sty']
"""List of typical file extensions included in latex files"""

exts_tex = ['.ltx', '.tex']
"""List of typical file extensions that contain latex"""

re_tex = re.compile(r'\\(?P<type>usepackage|RequirePackage|include|bibliography([^\[\]{}]*)|putbib|includegraphics|input|import|bringin|lstinputlisting)(\[[^\[\]]*\])?{(?P<file>[^{}]*)}',re.M)
"""Regexp for expressions that may include latex files"""

g_bibtex_re = re.compile('bibdata', re.M)
"""Regexp for bibtex files"""

g_glossaries_re = re.compile('\\@newglossary', re.M)
"""Regexp for expressions that create glossaries"""

class tex(Task.Task):
	"""
	Compiles a tex/latex file.

	.. inheritance-diagram:: waflib.Tools.tex.latex waflib.Tools.tex.xelatex waflib.Tools.tex.pdflatex
	   :top-classes: waflib.Tools.tex.tex
	"""

	bibtex_fun, _ = Task.compile_fun('${BIBTEX} ${BIBTEXFLAGS} ${SRCFILE}', shell=False)
	bibtex_fun.__doc__ = """
	Execute the program **bibtex**
	"""

	makeindex_fun, _ = Task.compile_fun('${MAKEINDEX} ${MAKEINDEXFLAGS} ${SRCFILE}', shell=False)
	makeindex_fun.__doc__ = """
	Execute the program **makeindex**
	"""

	makeglossaries_fun, _ = Task.compile_fun('${MAKEGLOSSARIES} ${SRCFILE}', shell=False)
	makeglossaries_fun.__doc__ = """
	Execute the program **makeglossaries**
	"""

	def exec_command(self, cmd, **kw):
		"""
		Executes TeX commands without buffering (latex may prompt for inputs)

		:return: the return code
		:rtype: int
		"""
		if self.env.PROMPT_LATEX:
			# capture the outputs in configuration tests
			kw['stdout'] = kw['stderr'] = None
		return super(tex, self).exec_command(cmd, **kw)

	def scan_aux(self, node):
		"""
		Recursive regex-based scanner that finds included auxiliary files.
		"""
		nodes = [node]
		re_aux = re.compile(r'\\@input{(?P<file>[^{}]*)}', re.M)

		def parse_node(node):
			code = node.read()
			for match in re_aux.finditer(code):
				path = match.group('file')
				found = node.parent.find_or_declare(path)
				if found and found not in nodes:
					Logs.debug('tex: found aux node %r', found)
					nodes.append(found)
					parse_node(found)
		parse_node(node)
		return nodes

	def scan(self):
		"""
		Recursive regex-based scanner that finds latex dependencies. It uses :py:attr:`waflib.Tools.tex.re_tex`

		Depending on your needs you might want:

		* to change re_tex::

			from waflib.Tools import tex
			tex.re_tex = myregex

		* or to change the method scan from the latex tasks::

			from waflib.Task import classes
			classes['latex'].scan = myscanfunction
		"""
		node = self.inputs[0]

		nodes = []
		names = []
		seen = []
		if not node:
			return (nodes, names)

		def parse_node(node):
			if node in seen:
				return
			seen.append(node)
			code = node.read()
			for match in re_tex.finditer(code):

				multibib = match.group('type')
				if multibib and multibib.startswith('bibliography'):
					multibib = multibib[len('bibliography'):]
					if multibib.startswith('style'):
						continue
				else:
					multibib = None

				for path in match.group('file').split(','):
					if path:
						add_name = True
						found = None
						for k in exts_deps_tex:

							# issue 1067, scan in all texinputs folders
							for up in self.texinputs_nodes:
								Logs.debug('tex: trying %s%s', path, k)
								found = up.find_resource(path + k)
								if found:
									break


							for tsk in self.generator.tasks:
								if not found or found in tsk.outputs:
									break
							else:
								nodes.append(found)
								add_name = False
								for ext in exts_tex:
									if found.name.endswith(ext):
										parse_node(found)
										break

							# multibib stuff
							if found and multibib and found.name.endswith('.bib'):
								try:
									self.multibibs.append(found)
								except AttributeError:
									self.multibibs = [found]

							# no break, people are crazy
						if add_name:
							names.append(path)
		parse_node(node)

		for x in nodes:
			x.parent.get_bld().mkdir()

		Logs.debug("tex: found the following : %s and names %s", nodes, names)
		return (nodes, names)

	def check_status(self, msg, retcode):
		"""
		Checks an exit status and raise an error with a particular message

		:param msg: message to display if the code is non-zero
		:type msg: string
		:param retcode: condition
		:type retcode: boolean
		"""
		if retcode != 0:
			raise Errors.WafError('%r command exit status %r' % (msg, retcode))

	def info(self, *k, **kw):
		try:
			info = self.generator.bld.conf.logger.info
		except AttributeError:
			info = Logs.info
		info(*k, **kw)

	def bibfile(self):
		"""
		Parses *.aux* files to find bibfiles to process.
		If present, execute :py:meth:`waflib.Tools.tex.tex.bibtex_fun`
		"""
		for aux_node in self.aux_nodes:
			try:
				ct = aux_node.read()
			except EnvironmentError:
				Logs.error('Error reading %s: %r', aux_node.abspath())
				continue

			if g_bibtex_re.findall(ct):
				self.info('calling bibtex')

				self.env.env = {}
				self.env.env.update(os.environ)
				self.env.env.update({'BIBINPUTS': self.texinputs(), 'BSTINPUTS': self.texinputs()})
				self.env.SRCFILE = aux_node.name[:-4]
				self.check_status('error when calling bibtex', self.bibtex_fun())

		for node in getattr(self, 'multibibs', []):
			self.env.env = {}
			self.env.env.update(os.environ)
			self.env.env.update({'BIBINPUTS': self.texinputs(), 'BSTINPUTS': self.texinputs()})
			self.env.SRCFILE = node.name[:-4]
			self.check_status('error when calling bibtex', self.bibtex_fun())

	def bibunits(self):
		"""
		Parses *.aux* file to find bibunit files. If there are bibunit files,
		runs :py:meth:`waflib.Tools.tex.tex.bibtex_fun`.
		"""
		try:
			bibunits = bibunitscan(self)
		except OSError:
			Logs.error('error bibunitscan')
		else:
			if bibunits:
				fn  = ['bu' + str(i) for i in range(1, len(bibunits) + 1)]
				if fn:
					self.info('calling bibtex on bibunits')

				for f in fn:
					self.env.env = {'BIBINPUTS': self.texinputs(), 'BSTINPUTS': self.texinputs()}
					self.env.SRCFILE = f
					self.check_status('error when calling bibtex', self.bibtex_fun())

	def makeindex(self):
		"""
		Searches the filesystem for *.idx* files to process. If present,
		runs :py:meth:`waflib.Tools.tex.tex.makeindex_fun`
		"""
		self.idx_node = self.inputs[0].change_ext('.idx')
		try:
			idx_path = self.idx_node.abspath()
			os.stat(idx_path)
		except OSError:
			self.info('index file %s absent, not calling makeindex', idx_path)
		else:
			self.info('calling makeindex')

			self.env.SRCFILE = self.idx_node.name
			self.env.env = {}
			self.check_status('error when calling makeindex %s' % idx_path, self.makeindex_fun())

	def bibtopic(self):
		"""
		Lists additional .aux files from the bibtopic package
		"""
		p = self.inputs[0].parent.get_bld()
		if os.path.exists(os.path.join(p.abspath(), 'btaux.aux')):
			self.aux_nodes += p.ant_glob('*[0-9].aux')

	def makeglossaries(self):
		"""
		Lists additional glossaries from .aux files. If present, runs the makeglossaries program.
		"""
		src_file = self.inputs[0].abspath()
		base_file = os.path.basename(src_file)
		base, _ = os.path.splitext(base_file)
		for aux_node in self.aux_nodes:
			try:
				ct = aux_node.read()
			except EnvironmentError:
				Logs.error('Error reading %s: %r', aux_node.abspath())
				continue

			if g_glossaries_re.findall(ct):
				if not self.env.MAKEGLOSSARIES:
					raise Errors.WafError("The program 'makeglossaries' is missing!")
				Logs.warn('calling makeglossaries')
				self.env.SRCFILE = base
				self.check_status('error when calling makeglossaries %s' % base, self.makeglossaries_fun())
				return

	def texinputs(self):
		"""
		Returns the list of texinput nodes as a string suitable for the TEXINPUTS environment variables

		:rtype: string
		"""
		return os.pathsep.join([k.abspath() for k in self.texinputs_nodes]) + os.pathsep

	def run(self):
		"""
		Runs the whole TeX build process

		Multiple passes are required depending on the usage of cross-references,
		bibliographies, glossaries, indexes and additional contents
		The appropriate TeX compiler is called until the *.aux* files stop changing.
		"""
		env = self.env

		if not env.PROMPT_LATEX:
			env.append_value('LATEXFLAGS', '-interaction=nonstopmode')
			env.append_value('PDFLATEXFLAGS', '-interaction=nonstopmode')
			env.append_value('XELATEXFLAGS', '-interaction=nonstopmode')

		# important, set the cwd for everybody
		self.cwd = self.inputs[0].parent.get_bld()

		self.info('first pass on %s', self.__class__.__name__)

		# Hash .aux files before even calling the LaTeX compiler
		cur_hash = self.hash_aux_nodes()

		self.call_latex()

		# Find the .aux files again since bibtex processing can require it
		self.hash_aux_nodes()

		self.bibtopic()
		self.bibfile()
		self.bibunits()
		self.makeindex()
		self.makeglossaries()

		for i in range(10):
			# There is no need to call latex again if the .aux hash value has not changed
			prev_hash = cur_hash
			cur_hash = self.hash_aux_nodes()
			if not cur_hash:
				Logs.error('No aux.h to process')
			if cur_hash and cur_hash == prev_hash:
				break

			# run the command
			self.info('calling %s', self.__class__.__name__)
			self.call_latex()

	def hash_aux_nodes(self):
		"""
		Returns a hash of the .aux file contents

		:rtype: string or bytes
		"""
		try:
			self.aux_nodes
		except AttributeError:
			try:
				self.aux_nodes = self.scan_aux(self.inputs[0].change_ext('.aux'))
			except IOError:
				return None
		return Utils.h_list([Utils.h_file(x.abspath()) for x in self.aux_nodes])

	def call_latex(self):
		"""
		Runs the TeX compiler once
		"""
		self.env.env = {}
		self.env.env.update(os.environ)
		self.env.env.update({'TEXINPUTS': self.texinputs()})
		self.env.SRCFILE = self.inputs[0].abspath()
		self.check_status('error when calling latex', self.texfun())

class latex(tex):
	"Compiles LaTeX files"
	texfun, vars = Task.compile_fun('${LATEX} ${LATEXFLAGS} ${SRCFILE}', shell=False)

class pdflatex(tex):
	"Compiles PdfLaTeX files"
	texfun, vars =  Task.compile_fun('${PDFLATEX} ${PDFLATEXFLAGS} ${SRCFILE}', shell=False)

class xelatex(tex):
	"XeLaTeX files"
	texfun, vars = Task.compile_fun('${XELATEX} ${XELATEXFLAGS} ${SRCFILE}', shell=False)

class dvips(Task.Task):
	"Converts dvi files to postscript"
	run_str = '${DVIPS} ${DVIPSFLAGS} ${SRC} -o ${TGT}'
	color   = 'BLUE'
	after   = ['latex', 'pdflatex', 'xelatex']

class dvipdf(Task.Task):
	"Converts dvi files to pdf"
	run_str = '${DVIPDF} ${DVIPDFFLAGS} ${SRC} ${TGT}'
	color   = 'BLUE'
	after   = ['latex', 'pdflatex', 'xelatex']

class pdf2ps(Task.Task):
	"Converts pdf files to postscript"
	run_str = '${PDF2PS} ${PDF2PSFLAGS} ${SRC} ${TGT}'
	color   = 'BLUE'
	after   = ['latex', 'pdflatex', 'xelatex']

@feature('tex')
@before_method('process_source')
def apply_tex(self):
	"""
	Creates :py:class:`waflib.Tools.tex.tex` objects, and
	dvips/dvipdf/pdf2ps tasks if necessary (outs='ps', etc).
	"""
	if not getattr(self, 'type', None) in ('latex', 'pdflatex', 'xelatex'):
		self.type = 'pdflatex'

	outs = Utils.to_list(getattr(self, 'outs', []))

	# prompt for incomplete files (else the nonstopmode is used)
	try:
		self.generator.bld.conf
	except AttributeError:
		default_prompt = False
	else:
		default_prompt = True
	self.env.PROMPT_LATEX = getattr(self, 'prompt', default_prompt)

	deps_lst = []

	if getattr(self, 'deps', None):
		deps = self.to_list(self.deps)
		for dep in deps:
			if isinstance(dep, str):
				n = self.path.find_resource(dep)
				if not n:
					self.bld.fatal('Could not find %r for %r' % (dep, self))
				if not n in deps_lst:
					deps_lst.append(n)
			elif isinstance(dep, Node.Node):
				deps_lst.append(dep)

	for node in self.to_nodes(self.source):
		if self.type == 'latex':
			task = self.create_task('latex', node, node.change_ext('.dvi'))
		elif self.type == 'pdflatex':
			task = self.create_task('pdflatex', node, node.change_ext('.pdf'))
		elif self.type == 'xelatex':
			task = self.create_task('xelatex', node, node.change_ext('.pdf'))

		task.env = self.env

		# add the manual dependencies
		if deps_lst:
			for n in deps_lst:
				if not n in task.dep_nodes:
					task.dep_nodes.append(n)

		# texinputs is a nasty beast
		if hasattr(self, 'texinputs_nodes'):
			task.texinputs_nodes = self.texinputs_nodes
		else:
			task.texinputs_nodes = [node.parent, node.parent.get_bld(), self.path, self.path.get_bld()]
			lst = os.environ.get('TEXINPUTS', '')
			if self.env.TEXINPUTS:
				lst += os.pathsep + self.env.TEXINPUTS
			if lst:
				lst = lst.split(os.pathsep)
			for x in lst:
				if x:
					if os.path.isabs(x):
						p = self.bld.root.find_node(x)
						if p:
							task.texinputs_nodes.append(p)
						else:
							Logs.error('Invalid TEXINPUTS folder %s', x)
					else:
						Logs.error('Cannot resolve relative paths in TEXINPUTS %s', x)

		if self.type == 'latex':
			if 'ps' in outs:
				tsk = self.create_task('dvips', task.outputs, node.change_ext('.ps'))
				tsk.env.env = dict(os.environ)
			if 'pdf' in outs:
				tsk = self.create_task('dvipdf', task.outputs, node.change_ext('.pdf'))
				tsk.env.env = dict(os.environ)
		elif self.type == 'pdflatex':
			if 'ps' in outs:
				self.create_task('pdf2ps', task.outputs, node.change_ext('.ps'))
	self.source = []

def configure(self):
	"""
	Find the programs tex, latex and others without raising errors.
	"""
	v = self.env
	for p in 'tex latex pdflatex xelatex bibtex dvips dvipdf ps2pdf makeindex pdf2ps makeglossaries'.split():
		try:
			self.find_program(p, var=p.upper())
		except self.errors.ConfigurationError:
			pass
	v.DVIPSFLAGS = '-Ppdf'

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        #!/usr/bin/env python
# encoding: utf-8
# Ali Sabil, 2007
# Radosaw Szkodziski, 2010

"""
At this point, vala is still unstable, so do not expect
this tool to be too stable either (apis, etc)
"""

import re
from waflib import Build, Context, Errors, Logs, Node, Options, Task, Utils
from waflib.TaskGen import extension, taskgen_method
from waflib.Configure import conf

class valac(Task.Task):
	"""
	Compiles vala files
	"""
	#run_str = "${VALAC} ${VALAFLAGS}" # ideally
	#vars = ['VALAC_VERSION']
	vars = ["VALAC", "VALAC_VERSION", "VALAFLAGS"]
	ext_out = ['.h']

	def run(self):
		cmd = self.env.VALAC + self.env.VALAFLAGS
		resources = getattr(self, 'vala_exclude', [])
		cmd.extend([a.abspath() for a in self.inputs if a not in resources])
		ret = self.exec_command(cmd, cwd=self.vala_dir_node.abspath())

		if ret:
			return ret

		if self.generator.dump_deps_node:
			self.generator.dump_deps_node.write('\n'.join(self.generator.packages))

		return ret

@taskgen_method
def init_vala_task(self):
	"""
	Initializes the vala task with the relevant data (acts as a constructor)
	"""
	self.profile = getattr(self, 'profile', 'gobject')

	self.packages = packages = Utils.to_list(getattr(self, 'packages', []))
	self.use = Utils.to_list(getattr(self, 'use', []))
	if packages and not self.use:
		self.use = packages[:] # copy

	if self.profile == 'gobject':
		if not 'GOBJECT' in self.use:
			self.use.append('GOBJECT')

	def addflags(flags):
		self.env.append_value('VALAFLAGS', flags)

	if self.profile:
		addflags('--profile=%s' % self.profile)

	valatask = self.valatask

	# output directory
	if hasattr(self, 'vala_dir'):
		if isinstance(self.vala_dir, str):
			valatask.vala_dir_node = self.path.get_bld().make_node(self.vala_dir)
			try:
				valatask.vala_dir_node.mkdir()
			except OSError:
				raise self.bld.fatal('Cannot create the vala dir %r' % valatask.vala_dir_node)
		else:
			valatask.vala_dir_node = self.vala_dir
	else:
		valatask.vala_dir_node = self.path.get_bld()
	addflags('--directory=%s' % valatask.vala_dir_node.abspath())

	if hasattr(self, 'thread'):
		if self.profile == 'gobject':
			if not 'GTHREAD' in self.use:
				self.use.append('GTHREAD')
		else:
			#Vala doesn't have threading support for dova nor posix
			Logs.warn('Profile %s means no threading support', self.profile)
			self.thread = False

		if self.thread:
			addflags('--thread')

	self.is_lib = 'cprogram' not in self.features
	if self.is_lib:
		addflags('--library=%s' % self.target)

		h_node = valatask.vala_dir_node.find_or_declare('%s.h' % self.target)
		valatask.outputs.append(h_node)
		addflags('--header=%s' % h_node.name)

		valatask.outputs.append(valatask.vala_dir_node.find_or_declare('%s.vapi' % self.target))

		if getattr(self, 'gir', None):
			gir_node = valatask.vala_dir_node.find_or_declare('%s.gir' % self.gir)
			addflags('--gir=%s' % gir_node.name)
			valatask.outputs.append(gir_node)

	self.vala_target_glib = getattr(self, 'vala_target_glib', getattr(Options.options, 'vala_target_glib', None))
	if self.vala_target_glib:
		addflags('--target-glib=%s' % self.vala_target_glib)

	addflags(['--define=%s' % x for x in Utils.to_list(getattr(self, 'vala_defines', []))])

	packages_private = Utils.to_list(getattr(self, 'packages_private', []))
	addflags(['--pkg=%s' % x for x in packages_private])

	def _get_api_version():
		api_version = '1.0'
		if hasattr(Context.g_module, 'API_VERSION'):
			version = Context.g_module.API_VERSION.split(".")
			if version[0] == "0":
				api_version = "0." + version[1]
			else:
				api_version = version[0] + ".0"
		return api_version

	self.includes = Utils.to_list(getattr(self, 'includes', []))
	valatask.install_path = getattr(self, 'install_path', '')

	valatask.vapi_path = getattr(self, 'vapi_path', '${DATAROOTDIR}/vala/vapi')
	valatask.pkg_name = getattr(self, 'pkg_name', self.env.PACKAGE)
	valatask.header_path = getattr(self, 'header_path', '${INCLUDEDIR}/%s-%s' % (valatask.pkg_name, _get_api_version()))
	valatask.install_binding = getattr(self, 'install_binding', True)

	self.vapi_dirs = vapi_dirs = Utils.to_list(getattr(self, 'vapi_dirs', []))
	#includes =  []

	if hasattr(self, 'use'):
		local_packages = Utils.to_list(self.use)[:] # make sure to have a copy
		seen = []
		while len(local_packages) > 0:
			package = local_packages.pop()
			if package in seen:
				continue
			seen.append(package)

			# check if the package exists
			try:
				package_obj = self.bld.get_tgen_by_name(package)
			except Errors.WafError:
				continue

			# in practice the other task is already processed
			# but this makes it explicit
			package_obj.post()
			package_name = package_obj.target
			task = getattr(package_obj, 'valatask', None)
			if task:
				for output in task.outputs:
					if output.name == package_name + ".vapi":
						valatask.set_run_after(task)
						if package_name not in packages:
							packages.append(package_name)
						if output.parent not in vapi_dirs:
							vapi_dirs.append(output.parent)
						if output.parent not in self.includes:
							self.includes.append(output.parent)

			if hasattr(package_obj, 'use'):
				lst = self.to_list(package_obj.use)
				lst.reverse()
				local_packages = [pkg for pkg in lst if pkg not in seen] + local_packages

	addflags(['--pkg=%s' % p for p in packages])

	for vapi_dir in vapi_dirs:
		if isinstance(vapi_dir, Node.Node):
			v_node = vapi_dir
		else:
			v_node = self.path.find_dir(vapi_dir)
		if not v_node:
			Logs.warn('Unable to locate Vala API directory: %r', vapi_dir)
		else:
			addflags('--vapidir=%s' % v_node.abspath())

	self.dump_deps_node = None
	if self.is_lib and self.packages:
		self.dump_deps_node = valatask.vala_dir_node.find_or_declare('%s.deps' % self.target)
		valatask.outputs.append(self.dump_deps_node)

	if self.is_lib and valatask.install_binding:
		headers_list = [o for o in valatask.outputs if o.suffix() == ".h"]
		if headers_list:
			self.install_vheader = self.add_install_files(install_to=valatask.header_path, install_from=headers_list)

		vapi_list = [o for o in valatask.outputs if (o.suffix() in (".vapi", ".deps"))]
		if vapi_list:
			self.install_vapi = self.add_install_files(install_to=valatask.vapi_path, install_from=vapi_list)

		gir_list = [o for o in valatask.outputs if o.suffix() == '.gir']
		if gir_list:
			self.install_gir = self.add_install_files(
				install_to=getattr(self, 'gir_path', '${DATAROOTDIR}/gir-1.0'), install_from=gir_list)

	if hasattr(self, 'vala_resources'):
		nodes = self.to_nodes(self.vala_resources)
		valatask.vala_exclude = getattr(valatask, 'vala_exclude', []) + nodes
		valatask.inputs.extend(nodes)
		for x in nodes:
			addflags(['--gresources', x.abspath()])

@extension('.vala', '.gs')
def vala_file(self, node):
	"""
	Compile a vala file and bind the task to *self.valatask*. If an existing vala task is already set, add the node
	to its inputs. The typical example is::

		def build(bld):
			bld.program(
				packages      = 'gtk+-2.0',
				target        = 'vala-gtk-example',
				use           = 'GTK GLIB',
				source        = 'vala-gtk-example.vala foo.vala',
				vala_defines  = ['DEBUG'] # adds --define=<xyz> values to the command-line

				# the following arguments are for libraries
				#gir          = 'hello-1.0',
				#gir_path     = '/tmp',
				#vapi_path = '/tmp',
				#pkg_name = 'hello'
				# disable installing of gir, vapi and header
				#install_binding = False

				# profile     = 'xyz' # adds --profile=<xyz> to enable profiling
				# thread      = True, # adds --thread, except if profile is on or not on 'gobject'
				# vala_target_glib = 'xyz' # adds --target-glib=<xyz>, can be given through the command-line option --vala-target-glib=<xyz>
			)


	:param node: vala file
	:type node: :py:class:`waflib.Node.Node`
	"""

	try:
		valatask = self.valatask
	except AttributeError:
		valatask = self.valatask = self.create_task('valac')
		self.init_vala_task()

	valatask.inputs.append(node)
	name = node.name[:node.name.rfind('.')] + '.c'
	c_node = valatask.vala_dir_node.find_or_declare(name)
	valatask.outputs.append(c_node)
	self.source.append(c_node)

@extension('.vapi')
def vapi_file(self, node):
	try:
		valatask = self.valatask
	exce