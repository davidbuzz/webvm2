aracters.


<p>
A <em>numeric constant</em> (or <em>numeral</em>)
can be written with an optional fractional part
and an optional decimal exponent,
marked by a letter '<code>e</code>' or '<code>E</code>'.
Lua also accepts hexadecimal constants,
which start with <code>0x</code> or <code>0X</code>.
Hexadecimal constants also accept an optional fractional part
plus an optional binary exponent,
marked by a letter '<code>p</code>' or '<code>P</code>'.
A numeric constant with a radix point or an exponent
denotes a float;
otherwise,
if its value fits in an integer,
it denotes an integer.
Examples of valid integer constants are

<pre>
     3   345   0xff   0xBEBADA
</pre><p>
Examples of valid float constants are

<pre>
     3.0     3.1416     314.16e-2     0.31416E1     34e1
     0x0.1E  0xA23p-4   0X1.921FB54442D18P+1
</pre>

<p>
A <em>comment</em> starts with a double hyphen (<code>--</code>)
anywhere outside a string.
If the text immediately after <code>--</code> is not an opening long bracket,
the comment is a <em>short comment</em>,
which runs until the end of the line.
Otherwise, it is a <em>long comment</em>,
which runs until the corresponding closing long bracket.
Long comments are frequently used to disable code temporarily.





<h2>3.2 &ndash; <a name="3.2">Variables</a></h2>

<p>
Variables are places that store values.
There are three kinds of variables in Lua:
global variables, local variables, and table fields.


<p>
A single name can denote a global variable or a local variable
(or a function's formal parameter,
which is a particular kind of local variable):

<pre>
	var ::= Name
</pre><p>
Name denotes identifiers, as defined in <a href="#3.1">&sect;3.1</a>.


<p>
Any variable name is assumed to be global unless explicitly declared
as a local (see <a href="#3.3.7">&sect;3.3.7</a>).
Local variables are <em>lexically scoped</em>:
local variables can be freely accessed by functions
defined inside their scope (see <a href="#3.5">&sect;3.5</a>).


<p>
Before the first assignment to a variable, its value is <b>nil</b>.


<p>
Square brackets are used to index a table:

<pre>
	var ::= prefixexp &lsquo;<b>[</b>&rsquo; exp &lsquo;<b>]</b>&rsquo;
</pre><p>
The meaning of accesses to table fields can be changed via metatables
(see <a href="#2.4">&sect;2.4</a>).


<p>
The syntax <code>var.Name</code> is just syntactic sugar for
<code>var["Name"]</code>:

<pre>
	var ::= prefixexp &lsquo;<b>.</b>&rsquo; Name
</pre>

<p>
An access to a global variable <code>x</code>
is equivalent to <code>_ENV.x</code>.
Due to the way that chunks are compiled,
<code>_ENV</code> is never a global name (see <a href="#2.2">&sect;2.2</a>).





<h2>3.3 &ndash; <a name="3.3">Statements</a></h2>

<p>
Lua supports an almost conventional set of statements,
similar to those in Pascal or C.
This set includes
assignments, control structures, function calls,
and variable declarations.



<h3>3.3.1 &ndash; <a name="3.3.1">Blocks</a></h3>

<p>
A block is a list of statements,
which are executed sequentially:

<pre>
	block ::= {stat}
</pre><p>
Lua has <em>empty statements</em>
that allow you to separate statements with semicolons,
start a block with a semicolon
or write two semicolons in sequence:

<pre>
	stat ::= &lsquo;<b>;</b>&rsquo;
</pre>

<p>
Function calls and assignments
can start with an open parenthesis.
This possibility leads to an ambiguity in Lua's grammar.
Consider the following fragment:

<pre>
     a = b + c
     (print or io.write)('done')
</pre><p>
The grammar could see it in two ways:

<pre>
     a = b + c(print or io.write)('done')
     
     a = b + c; (print or io.write)('done')
</pre><p>
The current parser always sees such constructions
in the first way,
interpreting the open parenthesis
as the start of the arguments to a call.
To avoid this ambiguity,
it is a good practice to always precede with a semicolon
statements that start with a parenthesis:

<pre>
     ;(print or io.write)('done')
</pre>

<p>
A block can be explicitly delimited to produce a single statement:

<pre>
	stat ::= <b>do</b> block <b>end</b>
</pre><p>
Explicit blocks are useful
to control the scope of variable declarations.
Explicit blocks are also sometimes used to
add a <b>return</b> statement in the middle
of another block (see <a href="#3.3.4">&sect;3.3.4</a>).





<h3>3.3.2 &ndash; <a name="3.3.2">Chunks</a></h3>

<p>
The unit of compilation of Lua is called a <em>chunk</em>.
Syntactically,
a chunk is simply a block:

<pre>
	chunk ::= block
</pre>

<p>
Lua handles a chunk as the body of an anonymous function
with a variable number of arguments
(see <a href="#3.4.11">&sect;3.4.11</a>).
As such, chunks can define local variables,
receive arguments, and return values.
Moreover, such anonymous function is compiled as in the
scope of an external local variable called <code>_ENV</code> (see <a href="#2.2">&sect;2.2</a>).
The resulting function always has <code>_ENV</code> as its only upvalue,
even if it does not use that variable.


<p>
A chunk can be stored in a file or in a string inside the host program.
To execute a chunk,
Lua first <em>loads</em> it,
precompiling the chunk's code into instructions for a virtual machine,
and then Lua executes the compiled code
with an interpreter for the virtual machine.


<p>
Chunks can also be precompiled into binary form;
see program <code>luac</code> and function <a href="#pdf-string.dump"><code>string.dump</code></a> for details.
Programs in source and compiled forms are interchangeable;
Lua automatically detects the file type and acts accordingly (see <a href="#pdf-load"><code>load</code></a>).





<h3>3.3.3 &ndash; <a name="3.3.3">Assignment</a></h3>

<p>
Lua allows multiple assignments.
Therefore, the syntax for assignment
defines a list of variables on the left side
and a list of expressions on the right side.
The elements in both lists are separated by commas:

<pre>
	stat ::= varlist &lsquo;<b>=</b>&rsquo; explist
	varlist ::= var {&lsquo;<b>,</b>&rsquo; var}
	explist ::= exp {&lsquo;<b>,</b>&rsquo; exp}
</pre><p>
Expressions are discussed in <a href="#3.4">&sect;3.4</a>.


<p>
Before the assignment,
the list of values is <em>adjusted</em> to the length of
the list of variables.
If there are more values than needed,
the excess values are thrown away.
If there are fewer values than needed,
the list is extended with as many  <b>nil</b>'s as needed.
If the list of expressions ends with a function call,
then all values returned by that call enter the list of values,
before the adjustment
(except when the call is enclosed in parentheses; see <a href="#3.4">&sect;3.4</a>).


<p>
The assignment statement first evaluates all its expressions
and only then the assignments are performed.
Thus the code

<pre>
     i = 3
     i, a[i] = i+1, 20
</pre><p>
sets <code>a[3]</code> to 20, without affecting <code>a[4]</code>
because the <code>i</code> in <code>a[i]</code> is evaluated (to 3)
before it is assigned&nbsp;4.
Similarly, the line

<pre>
     x, y = y, x
</pre><p>
exchanges the values of <code>x</code> and <code>y</code>,
and

<pre>
     x, y, z = y, z, x
</pre><p>
cyclically permutes the values of <code>x</code>, <code>y</code>, and <code>z</code>.


<p>
An assignment to a global name <code>x = val</code>
is equivalent to the assignment
<code>_ENV.x = val</code> (see <a href="#2.2">&sect;2.2</a>).


<p>
The meaning of assignments to table fields and
global variables (which are actually table fields, too)
can be changed via metatables (see <a href="#2.4">&sect;2.4</a>).





<h3>3.3.4 &ndash; <a name="3.3.4">Control Structures</a></h3><p>
The control structures
<b>if</b>, <b>while</b>, and <b>repeat</b> have the usual meaning and
familiar syntax:




<pre>
	stat ::= <b>while</b> exp <b>do</b> block <b>end</b>
	stat ::= <b>repeat</b> block <b>until</b> exp
	stat ::= <b>if</b> exp <b>then</b> block {<b>elseif</b> exp <b>then</b> block} [<b>else</b> block] <b>end</b>
</pre><p>
Lua also has a <b>for</b> statement, in two flavors (see <a href="#3.3.5">&sect;3.3.5</a>).


<p>
The condition expression of a
control structure can return any value.
Both <b>false</b> and <b>nil</b> are considered false.
All values different from <b>nil</b> and <b>false</b> are considered true
(in particular, the number 0 and the empty string are also true).


<p>
In the <b>repeat</b>&ndash;<b>until</b> loop,
the inner block does not end at the <b>until</b> keyword,
but only after the condition.
So, the condition can refer to local variables
declared inside the loop block.


<p>
The <b>goto</b> statement transfers the program control to a label.
For syntactical reasons,
labels in Lua are considered statements too:



<pre>
	stat ::= <b>goto</b> Name
	stat ::= label
	label ::= &lsquo;<b>::</b>&rsquo; Name &lsquo;<b>::</b>&rsquo;
</pre>

<p>
A label is visible in the entire block where it is defined,
except
inside nested blocks where a label with the same name is defined and
inside nested functions.
A goto may jump to any visible label as long as it does not
enter into the scope of a local variable.


<p>
Labels and empty statements are called <em>void statements</em>,
as they perform no actions.


<p>
The <b>break</b> statement terminates the execution of a
<b>while</b>, <b>repeat</b>, or <b>for</b> loop,
skipping to the next statement after the loop:


<pre>
	stat ::= <b>break</b>
</pre><p>
A <b>break</b> ends the innermost enclosing loop.


<p>
The <b>return</b> statement is used to return values
from a function or a chunk
(which is an anonymous function).

Functions can return more than one value,
so the syntax for the <b>return</b> statement is

<pre>
	stat ::= <b>return</b> [explist] [&lsquo;<b>;</b>&rsquo;]
</pre>

<p>
The <b>return</b> statement can only be written
as the last statement of a block.
If it is really necessary to <b>return</b> in the middle of a block,
then an explicit inner block can be used,
as in the idiom <code>do return end</code>,
because now <b>return</b> is the last statement in its (inner) block.





<h3>3.3.5 &ndash; <a name="3.3.5">For Statement</a></h3>

<p>

The <b>for</b> statement has two forms:
one numerical and one generic.


<p>
The numerical <b>for</b> loop repeats a block of code while a
control variable runs through an arithmetic progression.
It has the following syntax:

<pre>
	stat ::= <b>for</b> Name &lsquo;<b>=</b>&rsquo; exp &lsquo;<b>,</b>&rsquo; exp [&lsquo;<b>,</b>&rsquo; exp] <b>do</b> block <b>end</b>
</pre><p>
The <em>block</em> is repeated for <em>name</em> starting at the value of
the first <em>exp</em>, until it passes the second <em>exp</em> by steps of the
third <em>exp</em>.
More precisely, a <b>for</b> statement like

<pre>
     for v = <em>e1</em>, <em>e2</em>, <em>e3</em> do <em>block</em> end
</pre><p>
is equivalent to the code:

<pre>
     do
       local <em>var</em>, <em>limit</em>, <em>step</em> = tonumber(<em>e1</em>), tonumber(<em>e2</em>), tonumber(<em>e3</em>)
       if not (<em>var</em> and <em>limit</em> and <em>step</em>) then error() end
       <em>var</em> = <em>var</em> - <em>step</em>
       while true do
         <em>var</em> = <em>var</em> + <em>step</em>
         if (<em>step</em> &gt;= 0 and <em>var</em> &gt; <em>limit</em>) or (<em>step</em> &lt; 0 and <em>var</em> &lt; <em>limit</em>) then
           break
         end
         local v = <em>var</em>
         <em>block</em>
       end
     end
</pre>

<p>
Note the following:

<ul>

<li>
All three control expressions are evaluated only once,
before the loop starts.
They must all result in numbers.
</li>

<li>
<code><em>var</em></code>, <code><em>limit</em></code>, and <code><em>step</em></code> are invisible variables.
The names shown here are for explanatory purposes only.
</li>

<li>
If the third expression (the step) is absent,
then a step of&nbsp;1 is used.
</li>

<li>
You can use <b>break</b> and <b>goto</b> to exit a <b>for</b> loop.
</li>

<li>
The loop variable <code>v</code> is local to the loop body.
If you need its value after the loop,
assign it to another variable before exiting the loop.
</li>

</ul>

<p>
The generic <b>for</b> statement works over functions,
called <em>iterators</em>.
On each iteration, the iterator function is called to produce a new value,
stopping when this new value is <b>nil</b>.
The generic <b>for</b> loop has the following syntax:

<pre>
	stat ::= <b>for</b> namelist <b>in</b> explist <b>do</b> block <b>end</b>
	namelist ::= Name {&lsquo;<b>,</b>&rsquo; Name}
</pre><p>
A <b>for</b> statement like

<pre>
     for <em>var_1</em>, &middot;&middot;&middot;, <em>var_n</em> in <em>explist</em> do <em>block</em> end
</pre><p>
is equivalent to the code:

<pre>
     do
       local <em>f</em>, <em>s</em>, <em>var</em> = <em>explist</em>
       while true do
         local <em>var_1</em>, &middot;&middot;&middot;, <em>var_n</em> = <em>f</em>(<em>s</em>, <em>var</em>)
         if <em>var_1</em> == nil then break end
         <em>var</em> = <em>var_1</em>
         <em>block</em>
       end
     end
</pre><p>
Note the following:

<ul>

<li>
<code><em>explist</em></code> is evaluated only once.
Its results are an <em>iterator</em> function,
a <em>state</em>,
and an initial value for the first <em>iterator variable</em>.
</li>

<li>
<code><em>f</em></code>, <code><em>s</em></code>, and <code><em>var</em></code> are invisible variables.
The names are here for explanatory purposes only.
</li>

<li>
You can use <b>break</b> to exit a <b>for</b> loop.
</li>

<li>
The loop variables <code><em>var_i</em></code> are local to the loop;
you cannot use their values after the <b>for</b> ends.
If you need these values,
then assign them to other variables before breaking or exiting the loop.
</li>

</ul>




<h3>3.3.6 &ndash; <a name="3.3.6">Function Calls as Statements</a></h3><p>
To allow possible side-effects,
function calls can be executed as statements:

<pre>
	stat ::= functioncall
</pre><p>
In this case, all returned values are thrown away.
Function calls are explained in <a href="#3.4.10">&sect;3.4.10</a>.





<h3>3.3.7 &ndash; <a name="3.3.7">Local Declarations</a></h3><p>
Local variables can be declared anywhere inside a block.
The declaration can include an initial assignment:

<pre>
	stat ::= <b>local</b> namelist [&lsquo;<b>=</b>&rsquo; explist]
</pre><p>
If present, an initial assignment has the same semantics
of a multiple assignment (see <a href="#3.3.3">&sect;3.3.3</a>).
Otherwise, all variables are initialized with <b>nil</b>.


<p>
A chunk is also a block (see <a href="#3.3.2">&sect;3.3.2</a>),
and so local variables can be declared in a chunk outside any explicit block.


<p>
The visibility rules for local variables are explained in <a href="#3.5">&sect;3.5</a>.







<h2>3.4 &ndash; <a name="3.4">Expressions</a></h2>

<p>
The basic expressions in Lua are the following:

<pre>
	exp ::= prefixexp
	exp ::= <b>nil</b> | <b>false</b> | <b>true</b>
	exp ::= Numeral
	exp ::= LiteralString
	exp ::= functiondef
	exp ::= tableconstructor
	exp ::= &lsquo;<b>...</b>&rsquo;
	exp ::= exp binop exp
	exp ::= unop exp
	prefixexp ::= var | functioncall | &lsquo;<b>(</b>&rsquo; exp &lsquo;<b>)</b>&rsquo;
</pre>

<p>
Numerals and literal strings are explained in <a href="#3.1">&sect;3.1</a>;
variables are explained in <a href="#3.2">&sect;3.2</a>;
function definitions are explained in <a href="#3.4.11">&sect;3.4.11</a>;
function calls are explained in <a href="#3.4.10">&sect;3.4.10</a>;
table constructors are explained in <a href="#3.4.9">&sect;3.4.9</a>.
Vararg expressions,
denoted by three dots ('<code>...</code>'), can only be used when
directly inside a vararg function;
they are explained in <a href="#3.4.11">&sect;3.4.11</a>.


<p>
Binary operators comprise arithmetic operators (see <a href="#3.4.1">&sect;3.4.1</a>),
bitwise operators (see <a href="#3.4.2">&sect;3.4.2</a>),
relational operators (see <a href="#3.4.4">&sect;3.4.4</a>), logical operators (see <a href="#3.4.5">&sect;3.4.5</a>),
and the concatenation operator (see <a href="#3.4.6">&sect;3.4.6</a>).
Unary operators comprise the unary minus (see <a href="#3.4.1">&sect;3.4.1</a>),
the unary bitwise NOT (see <a href="#3.4.2">&sect;3.4.2</a>),
the unary logical <b>not</b> (see <a href="#3.4.5">&sect;3.4.5</a>),
and the unary <em>length operator</em> (see <a href="#3.4.7">&sect;3.4.7</a>).


<p>
Both function calls and vararg expressions can result in multiple values.
If a function call is used as a statement (see <a href="#3.3.6">&sect;3.3.6</a>),
then its return list is adjusted to zero elements,
thus discarding all returned values.
If an expression is used as the last (or the only) element
of a list of expressions,
then no adjustment is made
(unless the expression is enclosed in parentheses).
In all other contexts,
Lua adjusts the result list to one element,
either discarding all values except the first one
or adding a single <b>nil</b> if there are no values.


<p>
Here are some examples:

<pre>
     f()                -- adjusted to 0 results
     g(f(), x)          -- f() is adjusted to 1 result
     g(x, f())          -- g gets x plus all results from f()
     a,b,c = f(), x     -- f() is adjusted to 1 result (c gets nil)
     a,b = ...          -- a gets the first vararg argument, b gets
                        -- the second (both a and b can get nil if there
                        -- is no corresponding vararg argument)
     
     a,b,c = x, f()     -- f() is adjusted to 2 results
     a,b,c = f()        -- f() is adjusted to 3 results
     return f()         -- returns all results from f()
     return ...         -- returns all received vararg arguments
     return x,y,f()     -- returns x, y, and all results from f()
     {f()}              -- creates a list with all results from f()
     {...}              -- creates a list with all vararg arguments
     {f(), nil}         -- f() is adjusted to 1 result
</pre>

<p>
Any expression enclosed in parentheses always results in only one value.
Thus,
<code>(f(x,y,z))</code> is always a single value,
even if <code>f</code> returns several values.
(The value of <code>(f(x,y,z))</code> is the first value returned by <code>f</code>
or <b>nil</b> if <code>f</code> does not return any values.)



<h3>3.4.1 &ndash; <a name="3.4.1">Arithmetic Operators</a></h3><p>
Lua supports the following arithmetic operators:

<ul>
<li><b><code>+</code>: </b>addition</li>
<li><b><code>-</code>: </b>subtraction</li>
<li><b><code>*</code>: </b>multiplication</li>
<li><b><code>/</code>: </b>float division</li>
<li><b><code>//</code>: </b>floor division</li>
<li><b><code>%</code>: </b>modulo</li>
<li><b><code>^</code>: </b>exponentiation</li>
<li><b><code>-</code>: </b>unary minus</li>
</ul>

<p>
With the exception of exponentiation and float division,
the arithmetic operators work as follows:
If both operands are integers,
the operation is performed over integers and the result is an integer.
Otherwise, if both operands are numbers
or strings that can be converted to
numbers (see <a href="#3.4.3">&sect;3.4.3</a>),
then they are converted to floats,
the operation is performed following the usual rules
for floating-point arithmetic
(usually the IEEE 754 standard),
and the result is a float.


<p>
Exponentiation and float division (<code>/</code>)
always convert their operands to floats
and the result is always a float.
Exponentiation uses the ISO&nbsp;C function <code>pow</code>,
so that it works for non-integer exponents too.


<p>
Floor division (<code>//</code>) is a division
that rounds the quotient towards minus infinity,
that is, the floor of the division of its operands.


<p>
Modulo is defined as the remainder of a division
that rounds the quotient towards minus infinity (floor division).


<p>
In case of overflows in integer arithmetic,
all operations <em>wrap around</em>,
according to the usual rules of two-complement arithmetic.
(In other words,
they return the unique representable integer
that is equal modulo <em>2<sup>64</sup></em> to the mathematical result.)



<h3>3.4.2 &ndash; <a name="3.4.2">Bitwise Operators</a></h3><p>
Lua supports the following bitwise operators:

<ul>
<li><b><code>&amp;</code>: </b>bitwise AND</li>
<li><b><code>&#124;</code>: </b>bitwise OR</li>
<li><b><code>~</code>: </b>bitwise exclusive OR</li>
<li><b><code>&gt;&gt;</code>: </b>right shift</li>
<li><b><code>&lt;&lt;</code>: </b>left shift</li>
<li><b><code>~</code>: </b>unary bitwise NOT</li>
</ul>

<p>
All bitwise operations convert its operands to integers
(see <a href="#3.4.3">&sect;3.4.3</a>),
operate on all bits of those integers,
and result in an integer.


<p>
Both right and left shifts fill the vacant bits with zeros.
Negative displacements shift to the other direction;
displacements with absolute values equal to or higher than
the number of bits in an integer
result in zero (as all bits are shifted out).





<h3>3.4.3 &ndash; <a name="3.4.3">Coercions and Conversions</a></h3><p>
Lua provides some automatic conversions between some
types and representations at run time.
Bitwise operators always convert float operands to integers.
Exponentiation and float division
always convert integer operands to floats.
All other arithmetic operations applied to mixed numbers
(integers and floats) convert the integer operand to a float;
this is called the <em>usual rule</em>.
The C API also converts both integers to floats and
floats to integers, as needed.
Moreover, string concatenation accepts numbers as arguments,
besides strings.


<p>
Lua also converts strings to numbers,
whenever a number is expected.


<p>
In a conversion from integer to float,
if the integer value has an exact representation as a float,
that is the result.
Otherwise,
the conversion gets the nearest higher or
the nearest lower representable value.
This kind of conversion never fails.


<p>
The conversion from float to integer
checks whether the float has an exact representation as an integer
(that is, the float has an integral value and
it is in the range of integer representation).
If it does, that representation is the result.
Otherwise, the conversion fails.


<p>
The conversion from strings to numbers goes as follows:
First, the string is converted to an integer or a float,
following its syntax and the rules of the Lua lexer.
(The string may have also leading and trailing spaces and a sign.)
Then, the resulting number (float or integer)
is converted to the type (float or integer) required by the context
(e.g., the operation that forced the conversion).


<p>
All conversions from strings to numbers
accept both a dot and the current locale mark
as the radix character.
(The Lua lexer, however, accepts only a dot.)


<p>
The conversion from numbers to strings uses a
non-specified human-readable format.
For complete control over how numbers are converted to strings,
use the <code>format</code> function from the string library
(see <a href="#pdf-string.format"><code>string.format</code></a>).





<h3>3.4.4 &ndash; <a name="3.4.4">Relational Operators</a></h3><p>
Lua supports the following relational operators:

<ul>
<li><b><code>==</code>: </b>equality</li>
<li><b><code>~=</code>: </b>inequality</li>
<li><b><code>&lt;</code>: </b>less than</li>
<li><b><code>&gt;</code>: </b>greater than</li>
<li><b><code>&lt;=</code>: </b>less or equal</li>
<li><b><code>&gt;=</code>: </b>greater or equal</li>
</ul><p>
These operators always result in <b>false</b> or <b>true</b>.


<p>
Equality (<code>==</code>) first compares the type of its operands.
If the types are different, then the result is <b>false</b>.
Otherwise, the values of the operands are compared.
Strings are compared in the obvious way.
Numbers are equal if they denote the same mathematical value.


<p>
Tables, userdata, and threads
are compared by reference:
two objects are considered equal only if they are the same object.
Every time you create a new object
(a table, userdata, or thread),
this new object is different from any previously existing object.
A closure is always equal to itself.
Closures with any detectable difference
(different behavior, different definition) are always different.
Closures created at different times but with no detectable differences
may be classified as equal or not
(depending on internal caching details).


<p>
You can change the way that Lua compares tables and userdata
by using the "eq" metamethod (see <a href="#2.4">&sect;2.4</a>).


<p>
Equality comparisons do not convert strings to numbers
or vice versa.
Thus, <code>"0"==0</code> evaluates to <b>false</b>,
and <code>t[0]</code> and <code>t["0"]</code> denote different
entries in a table.


<p>
The operator <co#include "AP_Soaring.h"

#if HAL_SOARING_ENABLED

#include <AP_Logger/AP_Logger.h>
#include <AP_TECS/AP_TECS.h>
#include <GCS_MAVLink/GCS.h>
#include <stdint.h>

// ArduSoar parameters
const AP_Param::GroupInfo SoaringController::var_info[] = {
    // @Param: ENABLE
    // @DisplayName: Is the soaring mode enabled or not
    // @Description: Toggles the soaring mode on and off
    // @Values: 0:Disable,1:Enable
    // @User: Advanced
    AP_GROUPINFO_FLAGS("ENABLE", 1, SoaringController, soar_active, 0, AP_PARAM_FLAG_ENABLE),

    // @Param: VSPEED
    // @DisplayName: Vertical v-speed
    // @Description: Rate of climb to trigger themalling speed
    // @Units: m/s
    // @Range: 0 10
    // @User: Advanced
    AP_GROUPINFO("VSPEED", 2, SoaringController, thermal_vspeed, 0.7f),

    // @Param: Q1
    // @DisplayName: Process noise
    // @Description: Standard deviation of noise in process for strength
    // @Range: 0.0001 0.01
    // @User: Advanced
    AP_GROUPINFO("Q1", 3, SoaringController, thermal_q1, 0.001f),

    // @Param: Q2
    // @DisplayName: Process noise
    // @Description: Standard deviation of noise in process for position and radius
    // @Range: 0.01 1
    // @User: Advanced
    AP_GROUPINFO("Q2", 4, SoaringController, thermal_q2, 0.03f),

    // @Param: R
    // @DisplayName: Measurement noise
    // @Description: Standard deviation of noise in measurement
    // @Range: 0.01 1
    // @User: Advanced

    AP_GROUPINFO("R", 5, SoaringController, thermal_r, 0.45f),

    // @Param: DIST_AHEAD
    // @DisplayName: Distance to thermal center
    // @Description: Initial guess of the distance to the thermal center
    // @Units: m
    // @Range: 0 100
    // @User: Advanced
    AP_GROUPINFO("DIST_AHEAD", 6, SoaringController, thermal_distance_ahead, 5.0f),

    // @Param: MIN_THML_S
    // @DisplayName: Minimum thermalling time
    // @Description: Minimum number of seconds to spend thermalling
    // @Units: s
    // @Range: 0 600
    // @User: Advanced
    AP_GROUPINFO("MIN_THML_S", 7, SoaringController, min_thermal_s, 20),

    // @Param: MIN_CRSE_S
    // @DisplayName: Minimum cruising time
    // @Description: Minimum number of seconds to spend cruising
    // @Units: s
    // @Range: 0 600
    // @User: Advanced
    AP_GROUPINFO("MIN_CRSE_S", 8, SoaringController, min_cruise_s, 10),

    // @Param: POLAR_CD0
    // @DisplayName: Zero lift drag coef.
    // @Description: Zero lift drag coefficient
    // @Range: 0.005 0.5
    // @User: Advanced
    AP_GROUPINFO("POLAR_CD0", 9, SoaringController, _polarParams.CD0, 0.027),

    // @Param: POLAR_B
    // @DisplayName: Induced drag coeffient
    // @Description: Induced drag coeffient
    // @Range: 0.005 0.05
    // @User: Advanced
    AP_GROUPINFO("POLAR_B", 10, SoaringController, _polarParams.B, 0.031),

    // @Param: POLAR_K
    // @DisplayName: Cl factor
    // @Description: Cl factor 2*m*g/(rho*S)
    // @Units: m.m/s/s
    // @Range: 20 400
    // @User: Advanced
    AP_GROUPINFO("POLAR_K", 11, SoaringController, _polarParams.K, 25.6),

    // @Param: ALT_MAX
    // @DisplayName: Maximum soaring altitude, relative to the home location
    // @Description: Don't thermal any higher than this.
    // @Units: m
    // @Range: 0 5000.0
    // @User: Advanced
    AP_GROUPINFO("ALT_MAX", 12, SoaringController, alt_max, 350.0),

    // @Param: ALT_MIN
    // @DisplayName: Minimum soaring altitude, relative to the home location
    // @Description: Don't get any lower than this.
    // @Units: m
    // @Range: 0 1000.0
    // @User: Advanced
    AP_GROUPINFO("ALT_MIN", 13, SoaringController, alt_min, 50.0),

    // @Param: ALT_CUTOFF
    // @DisplayName: Maximum power altitude, relative to the home location
    // @Description: Cut off throttle at this alt.
    // @Units: m
    // @Range: 0 5000.0
    // @User: Advanced
    AP_GROUPINFO("ALT_CUTOFF", 14, SoaringController, alt_cutoff, 250.0),
    
    // 15 was SOAR_ENABLE_CH, now RCX_OPTION

    // @Param: MAX_DRIFT
    // @DisplayName: (Optional) Maximum drift distance to allow when thermalling.
    // @Description: The previous mode will be restored if the horizontal distance to the thermalling start location exceeds this value. -1 to disable.
    // @Range: 0 1000
    // @User: Advanced
    AP_GROUPINFO("MAX_DRIFT", 16, SoaringController, max_drift, -1),

    // @Param: MAX_RADIUS
    // @DisplayName: (Optional) Maximum distance from home
    // @Description: RTL will be entered when a thermal is exited and the plane is more than this distance from home. -1 to disable.
    // @Range: 0 1000
    // @User: Advanced
    AP_GROUPINFO("MAX_RADIUS", 17, SoaringController, max_radius, -1),

    // @Param: THML_BANK
    // @DisplayName: Thermalling bank angle
    // @Description: This parameter sets the bank angle to use when thermalling. Typically 30 - 45 degrees works well.
    // @Range: 20 50
    // @User: Advanced
    // @Units: deg
    AP_GROUPINFO("THML_BANK", 18, SoaringController, thermal_bank, 30.0),

    // 19 reserved for POLAR_LEARN.

    // @Param: THML_ARSPD
    // @DisplayName: Specific setting for airspeed when soaring in THERMAL mode.
    // @Description: If non-zero this airspeed will be used when thermalling. A value of 0 will use AIRSPEED_CRUISE.
    // @Range: 0 50
    // @User: Advanced
    AP_GROUPINFO("THML_ARSPD", 20, SoaringController, soar_thermal_airspeed, 0),

    // @Param: CRSE_ARSPD
    // @DisplayName: Specific setting for airspeed when soaring in AUTO mode.
    // @Description: If non-zero this airspeed will be used when cruising between thermals in AUTO. If set to -1, airspeed will be selected based on speed-to-fly theory. If set to 0, then AIRSPEED_CRUISE will be used while cruising between thermals.
    // @Range: -1 50
    // @User: Advanced
    AP_GROUPINFO("CRSE_ARSPD", 21, SoaringController, soar_cruise_airspeed, 0),

    // @Param: THML_FLAP
    // @DisplayName: Flap percent to be used during thermalling flight.
    // @Description: This sets the flap when in LOITER with soaring active. Overrides the usual auto flap behaviour.
    // @Range: 0 100
    // @User: Advanced
    AP_GROUPINFO("THML_FLAP", 22, SoaringController, soar_thermal_flap, 0),

    AP_GROUPEND
};

SoaringController::SoaringController(AP_TECS &tecs, const AP_FixedWing &parms) :
    _tecs(tecs),
    _vario(parms,_polarParams),
    _speedToFly(_polarParams),
    _aparm(parms),
    _throttle_suppressed(true)
{
    AP_Param::setup_object_defaults(this, var_info);
}

void SoaringController::get_target(Location &wp)
{
    wp = AP::ahrs().get_home();
    wp.offset(_position_x_filter.get(), _position_y_filter.get());
}

bool SoaringController::suppress_throttle()
{
    float alt = _vario.alt;

    if (_throttle_suppressed && (alt < alt_min)) {
        // Time to throttle up
        set_throttle_suppressed(false);
    } else if ((!_throttle_suppressed) && (alt > alt_cutoff)) {
        // Start glide
        set_throttle_suppressed(true);

        // Zero the pitch integrator - the nose is currently raised to climb, we need to go back to glide.
        _tecs.reset_pitch_I();

        _cruise_start_time_us = AP_HAL::micros64();

        // Reset the filtered vario rate - it is currently elevated due to the climb rate and would otherwise take a while to fall again,
        // leading to false positives.
        _vario.reset_trigger_filter(0.0f);
    }

    return _throttle_suppressed;
}

bool SoaringController::check_thermal_criteria()
{
    return (_last_update_status == ActiveStatus::AUTO_MODE_CHANGE
            && ((AP_HAL::micros64() - _cruise_start_time_us) > ((unsigned)min_cruise_s * 1e6))
            && (_vario.get_trigger_value() - _vario.get_exp_thermalling_sink()) > thermal_vspeed
            && _vario.alt < alt_max
            && _vario.alt > alt_min);
}


SoaringController::LoiterStatus SoaringController::check_cruise_criteria(Vector2f prev_wp, Vector2f next_wp)
{
    // Check conditions for re-entering cruise. Note that the aircraft needs to also be aligned with the appropriate
    // heading before some of these conditions will actually trigger.
    // The GCS messages are emitted in mode_thermal.cpp. Update these if the logic here is changed.

    if (_last_update_status == ActiveStatus::SOARING_DISABLED) {
        return LoiterStatus::DISABLED;
    }

    LoiterStatus result = LoiterStatus::GOOD_TO_KEEP_LOITERING;
    const float alt = _vario.alt;

    if (_exit_commanded) {
        result = LoiterStatus::EXIT_COMMANDED;
    } else if (alt > alt_max) {
        result = LoiterStatus::ALT_TOO_HIGH;
    } else if (alt < alt_min) {
        result = LoiterStatus::ALT_TOO_LOW;
    } else if ((AP_HAL::micros64() - _thermal_start_time_us) > ((unsigned)min_thermal_s * 1e6)) {
        const float mcCreadyAlt = McCready(alt);
        if (_thermalability < mcCreadyAlt) {
            result = LoiterStatus::THERMAL_WEAK;
        } else if (alt < (-_thermal_start_pos.z) || _vario.get_filtered_climb() < 0.0) {
            result = LoiterStatus::ALT_LOST;
        } else if (check_drift(prev_wp, next_wp)) {
            result = LoiterStatus::DRIFT_EXCEEDED;
        }
    }

    return result;
}

void SoaringController::init_thermalling()
{
    // Calc filter matrices - so that changes to parameters can be updated by switching in and out of thermal mode
    float r      = powf(thermal_r,  2); // Measurement noise
    float cov_q1 = powf(thermal_q1, 2); // Process noise for strength
    float cov_q2 = powf(thermal_q2, 2); // Process noise for position and radius

    const float init_q[4] = {cov_q1,
                             cov_q2,
                             cov_q2,
                             cov_q2};

    const MatrixN<float,4> q{init_q};

    const float init_p[4] = {INITIAL_STRENGTH_COVARIANCE,
                             INITIAL_RADIUS_COVARIANCE,
                             INITIAL_POSITION_COVARIANCE,
                             INITIAL_POSITION_COVARIANCE};

    const MatrixN<float,4> p{init_p};

    Vector3f position;

    const AP_AHRS &_ahrs = AP::ahrs();
    if (!_ahrs.get_relative_position_NED_home(position)) {
        return;
    }

    // New state vector filter will be reset. Thermal location is placed in front of a/c
    const float init_xr[4] = {_vario.get_trigger_value(),
                              INITIAL_THERMAL_RADIUS,
                              position.x + thermal_distance_ahead * cosf(_ahrs.get_yaw()),
                              position.y + thermal_distance_ahead * sinf(_ahrs.get_yaw())};

    const VectorN<float,4> xr{init_xr};

    // Also reset covariance matrix p so filter is not affected by previous data
    _ekf.reset(xr, p, q, r);

    _prev_update_time = AP_HAL::micros64();
    _thermal_start_time_us = AP_HAL::micros64();
    _thermal_start_pos = position;

    _vario.reset_climb_filter(0.0);

    _position_x_filter.reset(_ekf.X[2]);
    _position_y_filter.reset(_ekf.X[3]);

    _exit_commanded = false;
}

void SoaringController::init_cruising()
{
    if (_last_update_status >= ActiveStatus::MANUAL_MODE_CHANGE) {
        _cruise_start_time_us = AP_HAL::micros64();
        // Start glide. Will be updated on the next loop.
        set_throttle_suppressed(true);
    }
}

void SoaringController::update_thermalling()
{
    float deltaT = (AP_HAL::micros64() - _prev_update_time) * 1e-6;

    Vector3f current_position;

    const AP_AHRS &_ahrs = AP::ahrs();
    if (!_ahrs.get_relative_position_NED_home(current_position)) {
        return;
    }

    Vector3f wind_drift = _ahrs.wind_estimate()*deltaT*_vario.get_filtered_climb()/_ekf.X[0];

    // update the filter
    _ekf.update(_vario.reading, current_position.x, current_position.y, wind_drift.x, wind_drift.y);

    
    _thermalability = (_ekf.X[0]*expf(-powf(get_thermalling_radius()/_ekf.X[1], 2))) - _vario.get_exp_thermalling_sink();

    _prev_update_time = AP_HAL::micros64();

    // Compute smoothed estimate of position
    _position_x_filter.set_cutoff_frequency(1/(3*_vario.tau));
    _position_y_filter.set_cutoff_frequency(1/(3*_vario.tau));

    _position_x_filter.apply(_ekf.X[2], deltaT);
    _position_y_filter.apply(_ekf.X[3], deltaT);

#if HAL_LOGGING_ENABLED
    // write log - save the data.
    // @LoggerMessage: SOAR
    // @Vehicles: Plane
    // @Description: Logged data from soaring feature
    // @URL: https://ardupilot.org/plane/docs/soaring.html
    // @Field: TimeUS: microseconds since system startup
    // @Field: nettorate: Estimate of vertical speed of surrounding airmass
    // @Field: x0: Thermal strength estimate
    // @Field: x1: Thermal radius estimate
    // @Field: x2: Thermal position estimate north from home
    // @Field: x3: Thermal position estimate east from home
    // @Field: north: Aircraft position north from home
    // @Field: east: Aircraft position east from home
    // @Field: alt: Aircraft altitude
    // @Field: dx_w: Wind speed north
    // @Field: dy_w: Wind speed east
    // @Field: th: Estimate of achievable climbrate in thermal
    AP::logger().WriteStreaming("SOAR", "TimeUS,nettorate,x0,x1,x2,x3,north,east,alt,dx_w,dy_w,th", "Qfffffffffff",
                                           AP_HAL::micros64(),
                                           (double)_vario.reading,
                                           (double)_ekf.X[0],
                                           (double)_ekf.X[1],
                                           (double)_ekf.X[2],
                                           (double)_ekf.X[3],
                                           current_position.x,
                                           current_position.y,
                                           (double)_vario.alt,
                                           (double)wind_drift.x,
                                           (double)wind_drift.y,
                                           (double)_thermalability);
#endif
}

void SoaringController::update_cruising()
{
    // Calculate the optimal airspeed for the current conditions of wind along current direction,
    // expected lift in next thermal and filtered sink rate.

    Vector3f wind    = AP::ahrs().wind_estimate();
    Vector3f wind_bf = AP::ahrs().earth_to_body(wind);

    const float wx = wind_bf.x;

    const float wz = _vario.get_stf_value();

    // Constraints on the airspeed calculation.
    const float CLmin = _polarParams.K/(_aparm.airspeed_max*_aparm.airspeed_max);
    const float CLmax = _polarParams.K/(_aparm.airspeed_min*_aparm.airspeed_min);

    // Update the calculation.
    _speedToFly.update(wx, wz, thermal_vspeed, CLmin, CLmax);

#if HAL_LOGGING_ENABLED
    AP::logger().WriteStreaming("SORC", "TimeUS,wx,wz,wexp,CLmin,CLmax,Vopt", "Qffffff",
                                       AP_HAL::micros64(),
                                       (double)wx,
                                       (double)wz,
                                       (double)thermal_vspeed,
                                       (double)CLmin,
                                       (double)CLmax,
                                       (double)_speedToFly.speed_to_fly());
#endif
}

void SoaringController::update_vario()
{
    _vario.update(thermal_bank);
}


float SoaringController::McCready(float alt)
{
    // A method shell to be filled in later
    return thermal_vspeed;
}

SoaringController::ActiveStatus SoaringController::active_state(bool override_disable) const
{
    if (override_disable || !soar_active) {
        return ActiveStatus::SOARING_DISABLED;
    }

    return _pilot_desired_state;
}

void SoaringController::update_active_state(bool override_disable)
{
    ActiveStatus status = active_state(override_disable);
    bool state_changed = !(status == _last_update_status);

    if (state_changed) {
        switch (status) {
            case ActiveStatus::SOARING_DISABLED:
                // It's not enabled, but was enabled on the last loop.
                GCS_SEND_TEXT(MAV_SEVERITY_INFO, "Soaring: Disabled.");
                set_throttle_suppressed(false);
                break;
            case ActiveStatus::MANUAL_MODE_CHANGE:
                // It's enabled, but wasn't on the last loop.
                GCS_SEND_TEXT(MAV_SEVERITY_INFO, "Soaring: Enabled, manual mode changes.");
                break;
            case ActiveStatus::AUTO_MODE_CHANGE:
                GCS_SEND_TEXT(MAV_SEVERITY_INFO, "Soaring: Enabled, automatic mode changes.");
                break;
        }

        if (_last_update_status == ActiveStatus::SOARING_DISABLED) {
            // We have switched from disabled into an active mode, start cruising.
            init_cruising();
        } else if (status != ActiveStatus::SOARING_DISABLED) {
            // We switched between active modes. If we're in THERMAL this means we should exit gracefully.
            // This has no effect if we're cruising as it is reset on thermal entry.
            _exit_commanded = true;
        }
    }

    _last_update_status = status;
}


void SoaringController::set_throttle_suppressed(bool suppressed)
{
    _throttle_suppressed = suppressed;

    // Let the TECS know.
    _tecs.set_gliding_requested_flag(suppressed);
}

bool SoaringController::check_drift(Vector2f prev_wp, Vector2f next_wp)
{
    // Check for -1 (disabled)
    if (max_drift<0) {
        return false;
    }

    // Check against the estimated thermal.
    Vector2f position(_ekf.X[2], _ekf.X[3]);

    Vector2f start_pos(_thermal_start_pos.x, _thermal_start_pos.y);

    Vector2f mission_leg = next_wp - prev_wp;

    if (prev_wp.is_zero() || mission_leg.length() < 0.1) {
        // Simple check of distance from initial start point.
        return (position - start_pos).length() > max_drift;
    } else {
        // Regard the effective start point as projected onto mission leg.
        // Calculate drift parallel and perpendicular to mission leg.
        // Drift parallel and in direction of mission leg is acceptable.
        Vector2f effective_start, vec1, vec2;

        // Calculate effective start point (on mission leg).
        vec1 = (start_pos - prev_wp).projected(mission_leg);
        effective_start = prev_wp + vec1;

        // Calculate parallel and perpendicular offsets.
        vec2 = position - effective_start;

        float parallel      = vec2 * mission_leg.normalized();
        float perpendicular = (vec2 - mission_leg.normalized()*parallel).length();

       // Check if we've drifted beyond the next wp.
        if (parallel>(next_wp - effective_start).length()) {
            return true;
        }

        // Check if we've drifted too far laterally or backwards. We don't count positive parallel offsets
        // as these are favourable (towards next wp)
        parallel = parallel>0 ? 0 : parallel;

        return (powf(parallel,2)+powf(perpendicular,2)) > powf(max_drift,2);
    }
}

float SoaringController::get_thermalling_radius() const
{
    // Thermalling radius is controlled by parameter SOAR_THML_BANK and true target airspeed.
    const float target_aspd = _tecs.get_target_airspeed() * AP::ahrs().get_EAS2TAS();
    const float radius = (target_aspd*target_aspd) / (GRAVITY_MSS * tanf(thermal_bank*DEG_TO_RAD));

    return radius;
}

float SoaringController::get_thermalling_target_airspeed()
{
    return soar_thermal_airspeed;
}

float SoaringController::get_cruising_target_airspeed()
{
    if (soar_cruise_airspeed<0) {
        return _speedToFly.speed_to_fly();
    }
    return soar_cruise_airspeed;
}

#endif // HAL_SOARING_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    /*
  Soaring Controller class by Samuel Tabor

  Provides a layer between the thermal centring algorithm and the main
  code for managing navigation targets, data logging, tuning parameters,
  algorithm inputs and eventually other soaring strategies such as
  speed-to-fly. AP_TECS library used for reference.
*/

#pragma once

#include <AP_HAL/AP_HAL_Boards.h>

#ifndef HAL_SOARING_ENABLED
#define HAL_SOARING_ENABLED 1
#endif

#if HAL_SOARING_ENABLED

#include <AP_Param/AP_Param.h>
#include <AP_Math/AP_Math.h>
#include "ExtendedKalmanFilter.h"
#include "Variometer.h"
#include "SpeedToFly.h"

#define INITIAL_THERMAL_RADIUS 80.0
#define INITIAL_STRENGTH_COVARIANCE 0.0049
#define INITIAL_RADIUS_COVARIANCE 400.0
#define INITIAL_POSITION_COVARIANCE 400.0


class SoaringController {
    Variometer::PolarParams _polarParams;
    ExtendedKalmanFilter _ekf{};
    class AP_TECS &_tecs;
    Variometer _vario;
    SpeedToFly _speedToFly;

    const AP_FixedWing &_aparm;

    // store aircraft location at last update
    Vector3f _prev_update_location;

    // store time thermal was entered for hysteresis
    uint64_t _thermal_start_time_us;

    // store position thermal was entered as a backup check
    Vector3f _thermal_start_pos;

    // store time cruise was entered for hysteresis
    uint64_t _cruise_start_time_us;

    // store time of last update
    uint64_t _prev_update_time;

    bool _throttle_suppressed;

    float McCready(float alt);

    float _thermalability;

    LowPassFilter<float> _position_x_filter{1/60.0};
    LowPassFilter<float> _position_y_filter{1/60.0};

protected:
    AP_Int8 soar_active;
    AP_Float thermal_vspeed;
    AP_Float thermal_q1;
    AP_Float thermal_q2;
    AP_Float thermal_r;
    AP_Float thermal_distance_ahead;
    AP_Int16 min_thermal_s;
    AP_Int16 min_cruise_s;
    AP_Float alt_max;
    AP_Float alt_min;
    AP_Float alt_cutoff;
    AP_Float max_drift;
    AP_Float thermal_bank;
    AP_Float soar_thermal_airspeed;
    AP_Float soar_cruise_airspeed;
    AP_Float soar_thermal_flap;

public:
    SoaringController(class AP_TECS &tecs, const AP_FixedWing &parms);

    enum class LoiterStatus {
        DISABLED,
        ALT_TOO_HIGH,
        ALT_TOO_LOW,
        THERMAL_WEAK,
        ALT_LOST,
        DRIFT_EXCEEDED,
        GOOD_TO_KEEP_LOITERING,
        EXIT_COMMANDED,
    };

    enum class ActiveStatus {
        SOARING_DISABLED,
        MANUAL_MODE_CHANGE,
        AUTO_MODE_CHANGE
    };

    AP_Float max_radius;

    // this supports the TECS_* user settable parameters
    static const struct AP_Param::GroupInfo var_info[];
    void get_target(Location & wp);
    bool suppress_throttle();
    bool check_thermal_criteria();
    LoiterStatus check_cruise_criteria(Vector2f prev_wp, Vector2f next_wp);
    void init_thermalling();
    void init_cruising();
    void update_thermalling();
    void update_cruising();
    void set_throttle_suppressed(bool suppressed);

    bool get_throttle_suppressed() const
    {
        return _throttle_suppressed;
    }

    float get_vario_reading() const
    {
        return _vario.get_displayed_value();
    }

    void update_vario();

    bool check_drift(Vector2f prev_wp, Vector2f next_wp);

    void update_active_state(bool override_disable);

    bool is_active() const {return _last_update_status>=SoaringController::ActiveStatus::MANUAL_MODE_CHANGE;};

    void set_pilot_desired_state(ActiveStatus pilot_desired_state) {_pilot_desired_state = pilot_desired_state;};

    float get_alt_cutoff() const {return alt_cutoff;}

    float get_circling_time() const {return _vario.tau;}

    float get_thermalling_radius() const;

    float get_thermalling_target_airspeed();

    float get_cruising_target_airspeed();

    float get_thermalling_flap() const
    {
        return soar_thermal_flap;
    }

private:

    ActiveStatus _last_update_status;

    ActiveStatus _pilot_desired_state = ActiveStatus::AUTO_MODE_CHANGE;

    ActiveStatus active_state(bool override_disable) const;

    bool _exit_commanded;
};

#endif // HAL_SOARING_ENABLED
                        #include "ExtendedKalmanFilter.h"
#include "AP_Math/matrixN.h"


float ExtendedKalmanFilter::measurementpredandjacobian(VectorN<float,N> &A, float Px, float Py)
{
    // This function computes the Jacobian using equations from
    // analytical derivation of Gaussian updraft distribution
    // This expression gets used lots
    float expon = expf(- (powf(X[2]-Px, 2) + powf(X[3]-Py, 2)) / powf(X[1], 2));
    // Expected measurement
    float w = X[0] * expon;

    // Elements of the Jacobian
    A[0] = expon;
    A[1] = 2 * X[0] * ((powf(X[2]-Px,2) + powf(X[3]-Py,2)) / powf(X[1],3)) * expon;
    A[2] = -2 * (X[0] * (X[2]-Px) / powf(X[1],2)) * expon;
    A[3] = -2 * (X[0] * (X[3]-Py) / powf(X[1],2)) * expon;
    return w;
}


void ExtendedKalmanFilter::reset(const VectorN<float,N> &x, const MatrixN<float,N> &p, const MatrixN<float,N> q, float r)
{
    P = p;
    X = x;
    Q = q;
    R = r;
}


void ExtendedKalmanFilter::update(float z, float Px, float Py, float driftX, float driftY)
{
    MatrixN<float,N> tempM;
    VectorN<float,N> H;
    VectorN<float,N> P12;
    VectorN<float,N> K;
    
    // LINE 28
    // Estimate new state from old.
    X[2] += driftX;
    X[3] += driftY;

    // LINE 33
    // Update the covariance matrix
    // P = A*ekf.P*A'+ekf.Q;
    // We know A is identity so
    // P = ekf.P+ekf.Q;
    P += Q;

    // What measurement do we expect to receive in the estimated
    // state
    // LINE 37
    // [z1,H] = ekf.jacobian_h(x1);
    float z1 = measurementpredandjacobian(H, Px, Py);

    // LINE 40
    // P12 = P * H';
    P12.mult(P, H); //cross covariance 
    
    // LINE 41
    // Calculate the KALMAN GAIN
    // K = P12 * inv(H*P12 + ekf.R);                     %Kalman filter gain
    K = P12 * 1.0 / (H * P12 + R);

    // Correct the state estimate using the measurement residual.
    // LINE 44
    // X = x1 + K * (z - z1);
    X += K * (z - z1);

    // Make sure X[1] stays positive.
    X[1] = X[1]>40.0 ? X[1]: 40.0;

    // Correct the covariance too.
    // LINE 46
    // NB should be altered to reflect Stengel
    // P = P_predict - K * P12';
    tempM.mult(K, P12);
    P -= tempM;
    
    P.force_symmetry();
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        /* Variometer class by Samuel Tabor

Manages the estimation of aircraft total energy, drag and vertical air velocity.
*/
#include "Variometer.h"

#include <AP_Logger/AP_Logger.h>

Variometer::Variometer(const AP_FixedWing &parms, const PolarParams &polarParams) :
    _aparm(parms),
    _polarParams(polarParams)
{
}

void Variometer::update(const float thermal_bank)
{
    const AP_AHRS &_ahrs = AP::ahrs();

    _ahrs.get_relative_position_D_home(alt);
    alt = -alt;

    float aspd = 0;
    if (!_ahrs.airspeed_estimate(aspd)) {
        aspd = _aparm.airspeed_cruise;
    }

    float aspd_filt = _sp_filter.apply(aspd);

    // Constrained airspeed.
    const float minV = sqrtf(_polarParams.K/1.5);
    _aspd_filt_constrained = aspd_filt>minV ? aspd_filt : minV;

    tau = calculate_circling_time_constant(radians(thermal_bank));

    float dt = (float)(AP_HAL::micros64() - _prev_update_time)/1e6;

    // Logic borrowed from AP_TECS.cpp
    // Update and average speed rate of change
    // Get DCM
    const Matrix3f &rotMat = _ahrs.get_rotation_body_to_ned();
    // Calculate speed rate of change
    float temp = rotMat.c.x * GRAVITY_MSS + AP::ins().get_accel().x;
    // take 5 point moving average
    float dsp = _vdot_filter.apply(temp);

    // Now we need to high-pass this signal to remove bias.
    _vdotbias_filter.set_cutoff_frequency(1/(20*tau));
    float dsp_bias = _vdotbias_filter.apply(temp, dt);
    
    float dsp_cor = dsp - dsp_bias;


    Vector3f velned;

    float raw_climb_rate = 0.0f;
    if (_ahrs.get_velocity_NED(velned)) {
        // if possible use the EKF vertical velocity
        raw_climb_rate = -velned.z;
    }
    
    _climb_filter.set_cutoff_frequency(1/(3*tau));
    float smoothed_climb_rate = _climb_filter.apply(raw_climb_rate, dt);

    // Compute still-air sinkrate
    float roll = _ahrs.get_roll();
    float sinkrate = calculate_aircraft_sinkrate(roll);

    reading = raw_climb_rate + dsp_cor*_aspd_filt_constrained/GRAVITY_MSS + sinkrate;
    
    // Update filters.

    float filtered_reading = _trigger_filter.apply(reading, dt);

    _audio_filter.apply(reading, dt);

    _stf_filter.apply(reading, dt);

    _prev_update_time = AP_HAL::micros64();

    _expected_thermalling_sink = calculate_aircraft_sinkrate(radians(thermal_bank));

#if HAL_LOGGING_ENABLED
// @LoggerMessage: VAR
// @Vehicles: Plane
// @Description: Variometer data
// @Field: TimeUS: Time since system startup
// @Field: aspd_raw: always zero
// @Field: aspd_filt: filtered and constrained airspeed
// @Field: alt: AHRS altitude
// @Field: roll: AHRS roll
// @Field: raw: estimated air vertical speed
// @Field: filt: low-pass filtered air vertical speed
// @Field: cl: raw climb rate
// @Field: fc: filtered climb rate
// @Field: exs: expected sink rate relative to air in thermalling turn
// @Field: dsp: average acceleration along X axis
// @Field: dspb: detected bias in average acceleration along X axis
    AP::logger().WriteStreaming("VAR", "TimeUS,aspd_raw,aspd_filt,alt,roll,raw,filt,cl,fc,exs,dsp,dspb", "Qfffffffffff",
                       AP_HAL::micros64(),
                       (double)0.0,
                       (double)_aspd_filt_constrained,
                       (double)alt,
                       (double)roll,
                       (double)reading,
                       (double)filtered_reading,
                       (double)_raw_climb_rate,
                       (double)smoothed_climb_rate,
                       (double)_expected_thermalling_sink,
                       (double)dsp,
                       (double)dsp_bias);
#else
    (void)filtered_reading;
    (void)smoothed_climb_rate;
#endif
}

float Variometer::calculate_aircraft_sinkrate(float phi) const
{
    // Remove aircraft sink rate
    float CL0;  // CL0 = 2*W/(rho*S*V^2)
    float C1;   // C1 = CD0/CL0
    float C2;   // C2 = CDi0/CL0 = B*CL0
    CL0 = _polarParams.K / (_aspd_filt_constrained * _aspd_filt_constrained);

    C1 = _polarParams.CD0 / CL0;  // constant describing expected angle to overcome zero-lift drag
    C2 = _polarParams.B * CL0;    // constant describing expected angle to overcome lift induced drag at zero bank

    float cosphi = (1 - phi * phi / 2); // first two terms of mclaurin series for cos(phi)
    
    return _aspd_filt_constrained * (C1 + C2 / (cosphi * cosphi));
}

float Variometer::calculate_circling_time_constant(float thermal_bank) const
{
    // Calculate a time constant to use to filter quantities over a full thermal orbit.
    // This is used for rejecting variation in e.g. climb rate, or estimated climb rate
    // potential, as the aircraft orbits the thermal.
    // Use the time to circle - variations at the circling frequency then have a gain of 25%
    // and the response to a step input will reach 64% of final value in three orbits.
    return 2*M_PI*_aspd_filt_constrained/(GRAVITY_MSS*tanf(thermal_bank));
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           
/* Variometer class by Samuel Tabor

Manages the estimation of aircraft total energy, drag and vertical air velocity.
*/
#pragma once

#include <AP_AHRS/AP_AHRS.h>
#include <AP_Param/AP_Param.h>
#include <Filter/AverageFilter.h>
#include <AP_Vehicle/AP_FixedWing.h>

class Variometer {

    const AP_FixedWing &_aparm;

    // store time of last update
    uint64_t _prev_update_time;

    float _raw_climb_rate;

    float _aspd_filt_constrained;

    float _expected_thermalling_sink;

    // declares a 5point average filter using floats
    AverageFilterFloat_Size5 _vdot_filter;

    AverageFilterFloat_Size5 _sp_filter;

    /*
     low pass filters for various purposes.
     */
    // Climb rate filter for monitoring progress in thermal.
    LowPassFilter<float> _climb_filter{1/60.0};

    // Fast filter for mavlink/audio vario output.
    LowPassFilter<float> _audio_filter{1/0.71};

    // Slower filter for deciding to enter THERMAL mode.
    LowPassFilter<float> _trigger_filter{1/4.06};

    // Longitudinal acceleration bias filter.
    LowPassFilter<float> _vdotbias_filter{1/60.0};

    // Speed to fly vario filter.
    LowPassFilter<float> _stf_filter{1/20.0};

public:
    struct PolarParams {
        AP_Float K;
        AP_Float CD0;
        AP_Float B;
    };

    Variometer(const AP_FixedWing &parms, const PolarParams &polarParams);

    float alt;
    float reading;
    float tau;

    void update(const float thermal_bank);
    float calculate_aircraft_sinkrate(float phi) const;

    void reset_climb_filter(float value) { _climb_filter.reset(value);}

    void reset_trigger_filter(float value) { _trigger_filter.reset(value);}

    float get_airspeed(void) const {return _aspd_filt_constrained;};

    float get_displayed_value(void) const {return _audio_filter.get();};

    float get_filtered_climb(void) const {return _climb_filter.get();};

    float get_trigger_value(void) const {return _trigger_filter.get();};

    float get_stf_value(void) const {return _stf_filter.get();};

    float get_exp_thermalling_sink(void) const {return _expected_thermalling_sink;};

    float calculate_circling_time_constant(const float thermal_bank) const;

private:
    const PolarParams &_polarParams;
};

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       #pragma once

#include <AP_Math/AP_Math.h>
#include <Filter/LowPassFilter.h>
#include <AP_InertialNav/AP_InertialNav.h>
#include <AP_HAL/Semaphores.h>

class AP_SurfaceDistance {
public:
    AP_SurfaceDistance(Rotation rot, const AP_InertialNav& inav, uint8_t i) : rotation(rot), inertial_nav(inav), instance(i) {};

    void update();

    // check if the last healthy range finder reading is too old to be considered valid
    bool data_stale(void);

    // helper to check that rangefinder was last reported as enabled and healthy
    bool enabled_and_healthy(void) const;

    // get inertially interpolated rangefinder height
    bool get_rangefinder_height_interpolated_cm(int32_t& ret) const;

    bool enabled;                          // not to be confused with rangefinder enabled, this state is to be set by the vehicle.
    bool alt_healthy;                      // true if we can trust the altitude from the rangefinder
    int16_t alt_cm;                        // tilt compensated altitude (in cm) from rangefinder
    float inertial_alt_cm;                 // inertial alt at time of last rangefinder sample
    LowPassFilterFloat alt_cm_filt {0.5};  // altitude filter
    int16_t alt_cm_glitch_protected;       // last glitch protected altitude
    int8_t glitch_count;                   // non-zero number indicates rangefinder is glitching
    uint32_t glitch_cleared_ms;            // system time glitch cleared
    float terrain_offset_cm;               // filtered terrain offset (e.g. terrain's height above EKF origin)

private:
#if HAL_LOGGING_ENABLED
    void Log_Write(void) const;
#endif

    // multi-thread access support
    HAL_Semaphore sem;

    const uint8_t instance;
    uint8_t status;
    uint32_t last_healthy_ms;

    const AP_InertialNav& inertial_nav;
    const Rotation rotation;
};
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            #include "AP_TECS.h"

#include <AP_HAL/AP_HAL.h>
#include <AP_Baro/AP_Baro.h>
#include <AP_Logger/AP_Logger.h>
#include <AP_Landing/AP_Landing.h>

extern const AP_HAL::HAL& hal;

#if CONFIG_HAL_BOARD == HAL_BOARD_SITL
#include <stdio.h>
# define Debug(fmt, args ...)  do {printf("%s:%d: " fmt "\n", __FUNCTION__, __LINE__, ## args); hal.scheduler->delay(1); } while(0)
#else
# define Debug(fmt, args ...)
#endif
//Debug("%.2f %.2f %.2f %.2f \n", var1, var2, var3, var4);

// table of user settable parameters
const AP_Param::GroupInfo AP_TECS::var_info[] = {

    // @Param: CLMB_MAX
    // @DisplayName: Maximum Climb Rate (metres/sec)
    // @Description: Maximum demanded climb rate. Do not set higher than the climb speed at THR_MAX at AIRSPEED_CRUISE when the battery is at low voltage. Reduce value if airspeed cannot be maintained on ascent. Increase value if throttle does not increase significantly to ascend.
    // @Increment: 0.1
    // @Range: 0.1 20.0
    // @User: Standard
    AP_GROUPINFO("CLMB_MAX",    0, AP_TECS, _maxClimbRate, 5.0f),

    // @Param: SINK_MIN
    // @DisplayName: Minimum Sink Rate (metres/sec)
    // @Description: Minimum sink rate when at THR_MIN and AIRSPEED_CRUISE.
    // @Increment: 0.1
    // @Range: 0.1 10.0
    // @User: Standard
    AP_GROUPINFO("SINK_MIN",    1, AP_TECS, _minSinkRate, 2.0f),

    // @Param: TIME_CONST
    // @DisplayName: Controller time constant (sec)
    // @Description: Time constant of the TECS control algorithm. Small values make faster altitude corrections but can cause overshoot and aggressive behavior.
    // @Range: 3.0 10.0
    // @Increment: 0.2
    // @User: Advanced
    AP_GROUPINFO("TIME_CONST",  2, AP_TECS, _timeConst, 5.0f),

    // @Param: THR_DAMP
    // @DisplayName: Controller throttle damping
    // @Description: Damping gain for throttle demand loop. Increase to add throttle activity to dampen oscillations in speed and height.
    // @Range: 0.1 1.0
    // @Increment: 0.1
    // @User: Advanced
    AP_GROUPINFO("THR_DAMP",    3, AP_TECS, _thrDamp, 0.5f),

    // @Param: INTEG_GAIN
    // @DisplayName: Controller integrator
    // @Description: Integrator gain to trim out long-term speed and height errors.
    // @Range: 0.0 0.5
    // @Increment: 0.02
    // @User: Advanced
    AP_GROUPINFO("INTEG_GAIN", 4, AP_TECS, _integGain, 0.3f),

    // @Param: VERT_ACC
    // @DisplayName: Vertical Acceleration Limit (metres/sec^2)
    // @Description: Maximum vertical acceleration used to correct speed or height errors.
    // @Range: 1.0 10.0
    // @Increment: 0.5
    // @User: Advanced
    AP_GROUPINFO("VERT_ACC",  5, AP_TECS, _vertAccLim, 7.0f),

    // @Param: HGT_OMEGA
    // @DisplayName: Height complementary filter frequency (radians/sec)
    // @Description: This is the cross-over frequency of the complementary filter used to fuse vertical acceleration and baro alt to obtain an estimate of height rate and height.
    // @Range: 1.0 5.0
    // @Increment: 0.05
    // @User: Advanced
    AP_GROUPINFO("HGT_OMEGA", 6, AP_TECS, _hgtCompFiltOmega, 3.0f),

    // @Param: SPD_OMEGA
    // @DisplayName: Speed complementary filter frequency (radians/sec)
    // @Description: This is the cross-over frequency of the complementary filter used to fuse longitudinal acceleration and airspeed to obtain a lower noise and lag estimate of airspeed.
    // @Range: 0.5 2.0
    // @Increment: 0.05
    // @User: Advanced
    AP_GROUPINFO("SPD_OMEGA", 7, AP_TECS, _spdCompFiltOmega, 2.0f),

    // @Param: RLL2THR
    // @DisplayName: Bank angle compensation gain
    // @Description: Gain from bank angle to throttle to compensate for loss of airspeed from drag in turns. Set to approximately 10x the sink rate in m/s caused by a 45-degree turn. High efficiency models may need less while less efficient aircraft may need more. Should be tuned in an automatic mission with waypoints and turns greater than 90 degrees. Tune with PTCH2SRV_RLL and KFF_RDDRMIX to achieve constant airspeed, constant altitude turns.
    // @Range: 5.0 30.0
    // @Increment: 1.0
    // @User: Advanced
    AP_GROUPINFO("RLL2THR",  8, AP_TECS, _rollComp, 10.0f),

    // @Param: SPDWEIGHT
    // @DisplayName: Weighting applied to speed control
    // @Description: Mixing of pitch and throttle correction for height and airspeed errors. Pitch controls altitude and throttle controls airspeed if set to 0. Pitch controls airspeed and throttle controls altitude if set to 2 (good for gliders). Blended if set to 1.
    // @Range: 0.0 2.0
    // @Increment: 0.1
    // @User: Advanced
    AP_GROUPINFO("SPDWEIGHT", 9, AP_TECS, _spdWeight, 1.0f),

    // @Param: PTCH_DAMP
    // @DisplayName: Controller pitch damping
    // @Description: Damping gain for pitch control from TECS control.  Increasing may correct for oscillations in speed and height, but too much may cause additional oscillation and degraded control.
    // @Range: 0.1 1.0
    // @Increment: 0.1
    // @User: Advanced
    AP_GROUPINFO("PTCH_DAMP", 10, AP_TECS, _ptchDamp, 0.3f),

    // @Param: SINK_MAX
    // @DisplayName: Maximum Descent Rate (metres/sec)
    // @Description: Maximum demanded descent rate. Do not set higher than the vertical speed the aircraft can maintain at THR_MIN, TECS_PITCH_MIN, and AIRSPEED_MAX.
    // @Increment: 0.1
    // @Range: 0.0 20.0
    // @User: Standard
    AP_GROUPINFO("SINK_MAX",  11, AP_TECS, _maxSinkRate, 5.0f),

    // @Param: LAND_ARSPD
    // @DisplayName: Airspeed during landing approach (m/s)
    // @Description: When performing an autonomus landing, this value is used as the goal airspeed during approach.  Max airspeed allowed is Trim Airspeed or AIRSPEED_MAX as defined by LAND_OPTIONS bitmask.  Note that this parameter is not useful if your platform does not have an airspeed sensor (use TECS_LAND_THR instead).  If negative then this value is halfway between AIRSPEED_MIN and TRIM_CRUISE_CM speed for fixed wing autolandings.
    // @Range: -1 127
    // @Increment: 1
    // @User: Standard
    AP_GROUPINFO("LAND_ARSPD", 12, AP_TECS, _landAirspeed, -1),

    // @Param: LAND_THR
    // @DisplayName: Cruise throttle during landing approach (percentage)
    // @Description: Use this parameter instead of LAND_ARSPD if your platform does not have an airspeed sensor.  It is the cruise throttle during landing approach.  If this value is negative then it is disabled and TECS_LAND_ARSPD is used instead.
    // @Range: -1 100
    // @Increment: 0.1
    // @User: Standard
    AP_GROUPINFO("LAND_THR", 13, AP_TECS, _landThrottle, -1),

    // @Param: LAND_SPDWGT
    // @DisplayName: Weighting applied to speed control during landing.
    // @Description: Same as SPDWEIGHT parameter, with the exception that this parameter is applied during landing flight stages.  A value closer to 2 will result in the plane ignoring height error during landing and our experience has been that the plane will therefore keep the nose up -- sometimes good for a glider landing (with the side effect that you will likely glide a ways past the landing point).  A value closer to 0 results in the plane ignoring speed error -- use caution when lowering the value below 1 -- ignoring speed could result in a stall. Values between 0 and 2 are valid values for a fixed landing weight. When using -1 the weight will be scaled during the landing. At the start of the landing approach it starts with TECS_SPDWEIGHT and scales down to 0 by the time you reach the land point. Example: Halfway down the landing approach you'll effectively have a weight of TECS_SPDWEIGHT/2.
    // @Range: -1.0 2.0
    // @Increment: 0.1
    // @User: Advanced
    AP_GROUPINFO("LAND_SPDWGT", 14, AP_TECS, _spdWeightLand, -1.0f),

    // @Param: PITCH_MAX
    // @DisplayName: Maximum pitch in auto flight
    // @Description: Overrides PTCH_LIM_MAX_DEG in automatic throttle modes to reduce climb rates. Uses PTCH_LIM_MAX_DEG if set to 0. For proper TECS tuning, set to the angle that the aircraft can climb at AIRSPEED_CRUISE and THR_MAX.
    // @Range: 0 45
    // @Increment: 1
    // @User: Advanced
    AP_GROUPINFO("PITCH_MAX", 15, AP_TECS, _pitch_max, 15),

    // @Param: PITCH_MIN
    // @DisplayName: Minimum pitch in auto flight
    // @Description: Overrides PTCH_LIM_MIN_DEG in automatic throttle modes to reduce descent rates. Uses PTCH_LIM_MIN_DEG if set to 0. For proper TECS tuning, set to the angle that the aircraft can descend at without overspeeding.
    // @Range: -45 0
    // @Increment: 1
    // @User: Advanced
    AP_GROUPINFO("PITCH_MIN", 16, AP_TECS, _pitch_min, 0),

    // @Param: LAND_SINK
    // @DisplayName: Sink rate for final landing stage
    // @Description: The sink rate in meters/second for the final stage of landing.
    // @Range: 0.0 2.0
    // @Increment: 0.1
    // @User: Advanced
    AP_GROUPINFO("LAND_SINK", 17, AP_TECS, _land_sink, 0.25f),

    // @Param: LAND_TCONST
    // @DisplayName: Land controller time constant (sec)
    // @Description: This is the time constant of the TECS control algorithm when in final landing stage of flight. It should be smaller than TECS_TIME_CONST to allow for faster flare
    // @Range: 1.0 5.0
    // @Increment: 0.2
    // @User: Advanced
    AP_GROUPINFO("LAND_TCONST", 18, AP_TECS, _landTimeConst, 2.0f),

    // @Param: LAND_DAMP
    // @DisplayName: Controller sink rate to pitch gain during flare
    // @Description: This is the sink rate gain for the pitch demand loop when in final landing stage of flight. It should be larger than TECS_PTCH_DAMP to allow for better sink rate control during flare.
    // @Range: 0.1 1.0
    // @Increment: 0.1
    // @User: Advanced
    AP_GROUPINFO("LAND_DAMP", 19, AP_TECS, _landDamp, 0.5f),

    // @Param: LAND_PMAX
    // @DisplayName: Maximum pitch during final stage of landing
    // @Description: This limits the pitch used during the final stage of automatic landing. During the final landing stage most planes need to keep their pitch small to avoid stalling. A maximum of 10 degrees is usually good. A value of zero means to use the normal pitch limits.
    // @Range: -5 40
    // @Increment: 1
    // @User: Advanced
    AP_GROUPINFO("LAND_PMAX", 20, AP_TECS, _land_pitch_max, 10),

    // @Param: APPR_SMAX
    // @DisplayName: Sink rate max for landing approach stage
    // @Description: The sink rate max for the landing approach stage of landing. This will need to be large for steep landing approaches especially when using reverse thrust. If 0, then use TECS_SINK_MAX.
    // @Range: 0.0 20.0
    // @Units: m/s
    // @Increment: 0.1
    // @User: Advanced
    AP_GROUPINFO("APPR_SMAX", 21, AP_TECS, _maxSinkRate_approach, 0),

    // @Param: LAND_SRC
    // @DisplayName: Land sink rate change
    // @Description: When zero, the flare sink rate (TECS_LAND_SINK) is a fixed sink demand. With this enabled the flare sinkrate will increase/decrease the flare sink demand as you get further beyond the LAND waypoint. Has no effect before the waypoint. This value is added to TECS_LAND_SINK proportional to distance traveled after wp. With an increasing sink rate you can still land in a given distance if you're traveling too fast and cruise passed the land point. A positive value will force the plane to land sooner proportional to distance passed land point. A negative number will tell the plane to slowly climb allowing for a pitched-up stall landing. Recommend 0.2 as initial value.
    // @Range: -2.0 2.0
    // @Units: m/s/m
    // @Increment: 0.1
    // @User: Advanced
    AP_GROUPINFO("LAND_SRC", 22, AP_TECS, _land_sink_rate_change, 0),

    // @Param: LAND_TDAMP
    // @DisplayName: Controller throttle damping when landing
    // @Description: Damping gain for the throttle demand loop during an auto-landing. Same as TECS_THR_DAMP but only in effect during an auto-land. Increase to add throttle activity to dampen oscillations in speed and height. When set to 0 landing throttle damping is controlled by TECS_THR_DAMP.
    // @Range: 0.1 1.0
    // @Increment: 0.1
    // @User: Advanced
    AP_GROUPINFO("LAND_TDAMP", 23, AP_TECS, _land_throttle_damp, 0),

    // @Param: LAND_IGAIN
    // @DisplayName: Controller integrator during landing
    // @Description: This is the integrator gain on the control loop during landing. When set to 0 then TECS_INTEG_GAIN is used. Increase to increase the rate at which speed and height offsets are trimmed out. Typically values lower than TECS_INTEG_GAIN work best
    // @Range: 0.0 0.5
    // @Increment: 0.02
    // @User: Advanced
    AP_GROUPINFO("LAND_IGAIN", 24, AP_TECS, _integGain_land, 0),

    // @Param: TKOFF_IGAIN
    // @DisplayName: Controller integrator during takeoff
    // @Description: This is the integrator gain on the control loop during takeoff. Increase to increase the rate at which speed and height offsets are trimmed out.
    // @Range: 0.0 0.5
    // @Increment: 0.02
    // @User: Advanced
    AP_GROUPINFO("TKOFF_IGAIN", 25, AP_TECS, _integGain_takeoff, 0),

    // @Param: LAND_PDAMP
    // @DisplayName: Pitch damping gain when landing
    // @Description: This is the damping gain for the pitch demand loop during landing. Increase to add damping  to correct for oscillations in speed and height. If set to 0 then TECS_PTCH_DAMP will be used instead.
    // @Range: 0.1 1.0
    // @Increment: 0.1
    // @User: Advanced
    AP_GROUPINFO("LAND_PDAMP", 26, AP_TECS, _land_pitch_damp, 0),

    // @Param: SYNAIRSPEED
    // @DisplayName: Enable the use of synthetic airspeed
    // @Description: This enables the use of synthetic airspeed in TECS for aircraft that don't have a real airspeed sensor. This is useful for development testing where the user is aware of the considerable limitations of the synthetic airspeed system, such as very poor estimates when a wind estimate is not accurate. Do not enable this option unless you fully understand the limitations of a synthetic airspeed estimate. This option has no effect if a healthy airspeed sensor is being used for airspeed measurements.
    // @Values: 0:Disable,1:Enable
    // @User: Advanced
    AP_GROUPINFO("SYNAIRSPEED", 27, AP_TECS, _use_synthetic_airspeed, 0),

    // @Param: OPTIONS
    // @DisplayName: Extra TECS options
    // @Description: This allows the enabling of special features in the speed/height controller.
    // @Bitmask: 0:GliderOnly,1:AllowDescentSpeedup
    // @User: Advanced
    AP_GROUPINFO("OPTIONS", 28, AP_TECS, _options, 0),

    // @Param: PTCH_FF_V0
    // @DisplayName: Baseline airspeed for pitch feed-forward.
    // @Description: This parameter sets the airspeed at which no feed-forward is applied between demanded airspeed and pitch. It should correspond to the airspeed in metres per second at which the plane glides at neutral pitch including STAB_PITCH_DOWN.
    // @Range: 5.0 50.0
    // @User: Advanced
    AP_GROUPINFO("PTCH_FF_V0", 29, AP_TECS, _pitch_ff_v0, 12.0),

    // @Param: PTCH_FF_K
    // @DisplayName: Gain for pitch feed-forward.
    // @Description: This parameter sets the gain between demanded airspeed and pitch. It has units of radians per metre per second and should generally be negative. A good starting value is -0.04 for gliders and -0.08 for draggy airframes. The default (0.0) disables this feed-forward.
    // @Range: -5.0 0.0
    // @User: Advanced
    AP_GROUPINFO("PTCH_FF_K", 30, AP_TECS, _pitch_ff_k, 0.0),

    // 31 previously used by TECS_LAND_PTRIM

    // @Param: FLARE_HGT
    // @DisplayName: Flare holdoff height
    // @Description: When height above ground is below this, the sink rate will be held at TECS_LAND_SINK. Use this to perform a hold-off manoeuvre when combined with small values for TECS_LAND_SINK.
    // @Range: 0 15
    // @Units: m
    // @User: Advanced
    AP_GROUPINFO("FLARE_HGT", 32, AP_TECS, _flare_holdoff_hgt, 1.0f),

    // @Param: HDEM_TCONST
    // @DisplayName: Height Demand Time Constant
    // @Description: This sets the time constant of the low pass filter that is applied to the height demand input when bit 1 of TECS_OPTIONS is not selected.
    // @Range: 1.0 5.0
    // @Units: s
    // @Increment: 0.2
    // @User: Advanced
    AP_GROUPINFO("HDEM_TCONST", 33, AP_TECS, _hgt_dem_tconst, 3.0f),

    AP_GROUPEND
};

/*
 *  Written by Paul Riseborough 2013 to provide:
 *  - Combined control of speed and height using throttle to control
 *    total energy and pitch angle to con#include "SIM_BattMonitor_SMBus.h"

SITL::SIM_BattMonitor_SMBus::SIM_BattMonitor_SMBus() :
    SMBusDevice()
{
    add_register("Temperature", SMBusBattDevReg::TEMP, SITL::I2CRegisters::RegMode::RDONLY);
    add_register("Voltage", SMBusBattDevReg::VOLTAGE, SITL::I2CRegisters::RegMode::RDONLY);
    add_register("Current", SMBusBattDevReg::CURRENT, SITL::I2CRegisters::RegMode::RDONLY);
    add_register("Remaining Capacity", SMBusBattDevReg::REMAINING_CAPACITY, SITL::I2CRegisters::RegMode::RDONLY);
    add_register("Full Charge Capacity", SMBusBattDevReg::FULL_CHARGE_CAPACITY, SITL::I2CRegisters::RegMode::RDONLY);
    add_register("Cycle_Count", SMBusBattDevReg::CYCLE_COUNT, SITL::I2CRegisters::RegMode::RDONLY);
    add_register("Design Charge Capacity", SMBusBattDevReg::DESIGN_CAPACITY, SITL::I2CRegisters::RegMode::RDONLY);
    add_register("Design Maximum Voltage", SMBusBattDevReg::DESIGN_VOLTAGE, SITL::I2CRegisters::RegMode::RDONLY);
    add_register("Specification Info", SMBusBattDevReg::SPECIFICATION_INFO, SITL::I2CRegisters::RegMode::RDONLY);
    add_register("Manufacture Date", SMBusBattDevReg::MANUFACTURE_DATE, SITL::I2CRegisters::RegMode::RDONLY);
    add_register("Serial", SMBusBattDevReg::SERIAL, SITL::I2CRegisters::RegMode::RDONLY);
    add_block("Manufacture Name", SMBusBattDevReg::MANUFACTURE_NAME, SITL::I2CRegisters::RegMode::RDONLY);
    add_block("Device Name", SMBusBattDevReg::DEVICE_NAME, SITL::I2CRegisters::RegMode::RDONLY);
    add_block("Device Chemistry", SMBusBattDevReg::DEVICE_CHEMISTRY, SITL::I2CRegisters::RegMode::RDONLY);
    add_register("Manufacture Data", SMBusBattDevReg::MANUFACTURE_DATA, SITL::I2CRegisters::RegMode::RDONLY);

    set_register(SMBusBattDevReg::TEMP, (int16_t)((C_TO_KELVIN(15))*10));
    // see update for voltage
    // see update for current

    set_register(SMBusBattDevReg::DESIGN_VOLTAGE, (uint16_t(50400U)));          // (mV) Design maximum voltage

    // TODO: remaining capacity connect to sim capacity add to update method below?
    // TODO: Battery mode bit set to mAh vs 10 mWh
    set_register(SMBusBattDevReg::REMAINING_CAPACITY, (uint16_t(42042U)));      // (mAh) Remaining Capacity

    // TODO: full capacity fill via SIM parameter
    set_register(SMBusBattDevReg::FULL_CHARGE_CAPACITY, (uint16_t(45000U)));    // (mAh) Full charge capacity
    set_register(SMBusBattDevReg::DESIGN_CAPACITY, (uint16_t(52500U)));         // (mAh) Design capacity

    set_register(SMBusBattDevReg::CYCLE_COUNT, (uint16_t(42U)));

    // Set SPECIFICATION_INFO
    union {
        struct {
            uint8_t revision : 4;
            uint8_t version: 4;
            uint8_t vscale: 4;
            uint8_t ipscale: 4;
        } fields;
        uint16_t word;
    } specinfo;

    // TODO: compute PEC for relevant monitors
    specinfo.fields.revision = 0b0001;  // version 1
//    specinfo.fields.version = 0b0011;  // 1.1 with PEC; TODO!
    specinfo.fields.version = 0b0001;  // 1.0
    specinfo.fields.vscale = 0b0000;  // unknown...
    specinfo.fields.ipscale = 0b0000;  // unknown...
    set_register(SMBusBattDevReg::SPECIFICATION_INFO, specinfo.word);

    set_register(SMBusBattDevReg::SERIAL, (uint16_t)12345);

    const char *manufacturer_name = "ArduPilot";
    set_block(SMBusBattDevReg::MANUFACTURE_NAME, manufacturer_name);

    const char *device_name = "SITLBatMon_V0.99";
    set_block(SMBusBattDevReg::DEVICE_NAME, device_name);

    const char *device_chemistry = "LION";
    set_block(SMBusBattDevReg::DEVICE_CHEMISTRY, device_chemistry);

    // Set Manufacture date to 2021 APR 24th
    const uint16_t manufacturer_date = ((2021 - 1980) << 9) + (04 << 5) + 24;
    set_register(SMBusBattDevReg::MANUFACTURE_DATE, manufacturer_date);

    // TODO: manufacturer data
}

void SITL::SIM_BattMonitor_SMBus::update(const class Aircraft &aircraft)
{
    const uint32_t now = AP_HAL::millis();
    if (now - last_update_ms > 100) {
        const float millivolts = AP::sitl()->state.battery_voltage * 1000.0f;
        set_register(SMBusBattDevReg::VOLTAGE, uint16_t(millivolts));
        // FIXME: is this REALLY what the hardware will do?
        const int16_t current = constrain_int32(AP::sitl()->state.battery_current*-1000, -32768, 32767);
        set_register(SMBusBattDevReg::CURRENT, current);
        last_update_ms = now;
    }
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 #include "SIM_SMBusDevice.h"

#pragma once

namespace SITL {

class SMBusBattDevReg : public SMBusRegEnum {
public:
    static const uint8_t TEMP = 0x08;                 // Temperature
    static const uint8_t VOLTAGE = 0x09;              // Voltage
    static const uint8_t CURRENT = 0x0A;              // Current
    static const uint8_t REMAINING_CAPACITY = 0x0F;   // Remaining Capacity
    static const uint8_t FULL_CHARGE_CAPACITY = 0x10; // Full Charge Capacity (accounting for battery degradation)
    static const uint8_t CYCLE_COUNT = 0x17;          // Cycle Count
    static const uint8_t DESIGN_CAPACITY = 0x18;      // Design capacity (capacity when newly manufactured)
    static const uint8_t DESIGN_VOLTAGE = 0x19;       // Design voltage
    static const uint8_t SPECIFICATION_INFO = 0x1A;   // Specification Info
    static const uint8_t MANUFACTURE_DATE = 0x1B;     // Manufacture date
    static const uint8_t SERIAL = 0x1C;               // Serial Number
    static const uint8_t MANUFACTURE_NAME = 0x20;     // Manufacture Name
    static const uint8_t DEVICE_NAME = 0x21;          // Device Name
    static const uint8_t DEVICE_CHEMISTRY = 0x22;     // Battery chemistry type
    static const uint8_t MANUFACTURE_DATA = 0x23;     // Manufacture Data
};

class SIM_BattMonitor_SMBus : public SMBusDevice
{
public:

    SIM_BattMonitor_SMBus();

    virtual void update(const class Aircraft &aircraft) override;

private:

    uint32_t last_update_ms;
};

} // namespace SITL
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       pe::VECTOR3F},
        FRAME_VAR(num_motors),
    };

    for (uint8_t i=0; i<ARRAY_SIZE(vars); i++) {
        auto v = obj->get(vars[i].label);
        if (v.is<AP_JSON::null>()) {
            // use default value
            continue;
        }
        if (vars[i].t == VarType::FLOAT) {
            parse_float(v, vars[i].label, *((float *)vars[i].ptr));

        } else if (vars[i].t == VarType::VECTOR3F) {
            parse_vector3(v, vars[i].label, *(Vector3f *)vars[i].ptr);

        }
    }

    json_search per_motor_vars[] = {
        {"position", &model.motor_pos, VarType::VECTOR3F},
        {"vector", &model.motor_thrust_vec, VarType::VECTOR3F},
        {"yaw", &model.yaw_factor, VarType::FLOAT},
    };
    char label_name[20];
    for (uint8_t i=0; i<ARRAY_SIZE(per_motor_vars); i++) {
        for (uint8_t j=0; j<12; j++) {
            snprintf(label_name, 20, "motor%i_%s", j+1, per_motor_vars[i].label);
            auto v = obj->get(label_name);
            if (v.is<AP_JSON::null>()) {
                // use default value
                continue;
            }
            if (per_motor_vars[i].t == VarType::FLOAT) {
                parse_float(v, label_name, *(((float *)per_motor_vars[i].ptr) + j));

            } else if (per_motor_vars[i].t == VarType::VECTOR3F) {
                parse_vector3(v, label_name, *(((Vector3f *)per_motor_vars[i].ptr) + j));
            }
        }
    }

    delete obj;

    ::printf("Loaded model params from %s\n", model_json);
}

void Frame::parse_float(AP_JSON::value val, const char* label, float &param) {
    if (!val.is<double>()) {
        AP_HAL::panic("Bad json type for %s: %s", label, val.to_str().c_str());
    }
    param = val.get<double>();
}

void Frame::parse_vector3(AP_JSON::value val, const char* label, Vector3f &param) {
    if (!val.is<AP_JSON::value::array>() || !val.contains(2) || val.contains(3)) {
        AP_HAL::panic("Bad json type for %s: %s", label, val.to_str().c_str());
    }
    for (uint8_t j=0; j<3; j++) {
        parse_float(val.get(j), label, param[j]);
    }
}

#if AP_SIM_ENABLED

/*
  initialise the frame
 */
void Frame::init(const char *frame_str, Battery *_battery)
{
    model = default_model;
    battery = _battery;

    const char *colon = strchr(frame_str, ':');
    size_t slen = strlen(frame_str);
    if (colon != nullptr && slen > 5 && strcmp(&frame_str[slen-5], ".json") == 0) {
        load_frame_params(colon+1);
    }
    mass = model.mass;

    const float drag_force = model.mass * GRAVITY_MSS * tanf(radians(model.refAngle));

    const float cos_tilt = cosf(radians(model.refAngle));
    const float airspeed_bf = model.refSpd * cos_tilt;
    const float ref_thrust = model.mass * GRAVITY_MSS / cos_tilt;
    float ref_air_density = get_air_density(model.refAlt);

    const float momentum_drag = cos_tilt * model.mdrag_coef * airspeed_bf * sqrtf(ref_thrust * ref_air_density * model.disc_area);

    if (momentum_drag > drag_force) {
        model.mdrag_coef *= drag_force / momentum_drag;
        areaCd = 0.0;
        ::printf("Suggested EK3_DRAG_BCOEF_* = 0, EK3_DRAG_MCOEF = %.3f\n", (momentum_drag / (model.mass * airspeed_bf)) * sqrtf(1.225f / ref_air_density));
    } else {
        areaCd = (drag_force - momentum_drag) / (0.5f * ref_air_density * sq(model.refSpd));
        ::printf("Suggested EK3_DRAG_BCOEF_* = %.3f, EK3_DRAG_MCOEF = %.3f\n", model.mass / areaCd, (momentum_drag / (model.mass * airspeed_bf)) * sqrtf(1.225f / ref_air_density));
    }

    terminal_rotation_rate = model.refRotRate;

    float hover_thrust = mass * GRAVITY_MSS;
    float hover_power = model.refCurrent * model.refVoltage;
    float hover_velocity_out = 2 * hover_power / hover_thrust;
    float effective_disc_area = hover_thrust / (0.5 * ref_air_density * sq(hover_velocity_out));
    float velocity_max = hover_velocity_out / sqrtf(model.hoverThrOut);
    float effective_prop_area = effective_disc_area / num_motors;
    float true_prop_area = model.disc_area / num_motors;

    // power_factor is ratio of power consumed per newton of thrust
    float power_factor = hover_power / hover_thrust;

    battery->setup(model.battCapacityAh, model.refBatRes, model.maxVoltage);

    if (uint8_t(model.num_motors) != num_motors) {
        ::printf("Warning model expected %u motors and got %u\n", uint8_t(model.num_motors), num_motors);
    }

    for (uint8_t i=0; i<num_motors; i++) {
        motors[i].setup_params(model.pwmMin, model.pwmMax, model.spin_min, model.spin_max, model.propExpo, model.slew_max,
                               model.diagonal_size, power_factor, model.maxVoltage, effective_prop_area, velocity_max,
                               model.motor_pos[i], model.motor_thrust_vec[i], model.yaw_factor[i], true_prop_area,
                               model.mdrag_coef);
    }

    if (is_zero(model.moment_of_inertia.x) || is_zero(model.moment_of_inertia.y) || is_zero(model.moment_of_inertia.z)) {
        // if no inertia provided, assume 50% of mass on ring around center
        model.moment_of_inertia.x = model.mass * 0.25 * sq(model.diagonal_size*0.5);
        model.moment_of_inertia.y = model.moment_of_inertia.x;
        model.moment_of_inertia.z = model.mass * 0.5 * sq(model.diagonal_size*0.5);
    }

    // setup reasonable defaults for battery
    AP_Param::set_default_by_name("SIM_BATT_VOLTAGE", model.maxVoltage);
    AP_Param::set_default_by_name("SIM_BATT_CAP_AH", model.battCapacityAh);
    if (model.battCapacityAh > 0) {
        AP_Param::set_default_by_name("BATT_CAPACITY", model.battCapacityAh*1000);
    }
}

/*
  find a frame by name
 */
Frame *Frame::find_frame(const char *name)
{
    for (uint8_t i=0; i < ARRAY_SIZE(supported_frames); i++) {
        // do partial name matching to allow for frame variants
        if (strncasecmp(name, supported_frames[i].name, strlen(supported_frames[i].name)) == 0) {
            return &supported_frames[i];
        }
    }
    return nullptr;
}

// calculate rotational and linear accelerations
void Frame::calculate_forces(const Aircraft &aircraft,
                             const struct sitl_input &input,
                             Vector3f &rot_accel,
                             Vector3f &body_accel,
                             float* rpm,
                             bool use_drag)
{
    Vector3f thrust; // newtons
    Vector3f torque;

    const float air_density = get_air_density(aircraft.get_location().alt*0.01);
    const Vector3f gyro = aircraft.get_gyro();

    Vector3f vel_air_bf = aircraft.get_dcm().transposed() * aircraft.get_velocity_air_ef();

    const auto *_sitl = AP::sitl();
    for (uint8_t i=0; i<num_motors; i++) {
        Vector3f mtorque, mthrust;
        motors[i].calculate_forces(input, motor_offset, mtorque, mthrust, vel_air_bf, gyro, air_density, battery->get_voltage(), use_drag);
        torque += mtorque;
        thrust += mthrust;
        // simulate motor rpm
        if (!is_zero(_sitl->vibe_motor)) {
            rpm[motor_offset+i] = motors[i].get_command() * AP::sitl()->vibe_motor * 60.0f;
        }
    }

    // calculate total rotational acceleration
    rot_accel.x = torque.x / model.moment_of_inertia.x;
    rot_accel.y = torque.y / model.moment_of_inertia.y;
    rot_accel.z = torque.z / model.moment_of_inertia.z;

    if (terminal_rotation_rate > 0) {
        // rotational air resistance
        rot_accel.x -= gyro.x * radians(400.0) / terminal_rotation_rate;
        rot_accel.y -= gyro.y * radians(400.0) / terminal_rotation_rate;
        rot_accel.z -= gyro.z * radians(400.0) / terminal_rotation_rate;
    }

    if (use_drag) {
        // use the model params to calculate drag
        Vector3f drag_bf;
        drag_bf.x = areaCd * 0.5f * air_density * sq(vel_air_bf.x);
        if (is_negative(vel_air_bf.x)) {
            drag_bf.x = -drag_bf.x;
        }

        drag_bf.y = areaCd * 0.5f * air_density * sq(vel_air_bf.y);
        if (is_negative(vel_air_bf.y)) {
            drag_bf.y = -drag_bf.y;
        }

        drag_bf.z = areaCd * 0.5f * air_density * sq(vel_air_bf.z);
        if (is_negative(vel_air_bf.z)) {
            drag_bf.z = -drag_bf.z;
        }

        thrust -= drag_bf;
    }

    body_accel = thrust/aircraft.gross_mass();
}


// calculate current and voltage
void Frame::current_and_voltage(float &voltage, float &current)
{
    float param_voltage = AP::sitl()->batt_voltage;
    if (!is_equal(last_param_voltage,param_voltage)) {
        battery->init_voltage(param_voltage);
        last_param_voltage = param_voltage;
    }
    voltage = battery->get_voltage();
    current = 0;
    for (uint8_t i=0; i<num_motors; i++) {
        current += motors[i].get_current();
    }
}
#endif // AP_SIM_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          /*
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
/*
  multicopter simulator class
*/

#pragma once

#include "SIM_Aircraft.h"
#include "SIM_Motor.h"
#include <AP_JSON/AP_JSON.h>

namespace SITL {

/*
  class to describe a multicopter frame type
 */
class Frame {
public:
    const char *name;
    uint8_t num_motors;
    Motor *motors;

    Frame(const char *_name,
          uint8_t _num_motors,
          Motor *_motors) :
          name(_name),
          num_motors(_num_motors),
          motors(_motors) {}

#if AP_SIM_ENABLED
    // find a frame by name
    static Frame *find_frame(const char *name);
    
    // initialise frame
    void init(const char *frame_str, Battery *_battery);

    // calculate rotational and linear accelerations
    void calculate_forces(const Aircraft &aircraft,
                          const struct sitl_input &input,
                          Vector3f &rot_accel, Vector3f &body_accel, float* rpm,
                          bool use_drag=true);
#endif // AP_SIM_ENABLED

    float terminal_velocity;
    float terminal_rotation_rate;
    uint8_t motor_offset;

    // calculate current and voltage
    void current_and_voltage(float &voltage, float &current);

    // get mass in kg
    float get_mass(void) const {
        return mass;
    }

    // set mass in kg
    void set_mass(float new_mass) {
        mass = new_mass;
    }
    
private:
    /*
      parameters that define the multicopter model. Can be loaded from
      a json file to give a custom model
     */
    const struct Model {
        // model mass kg
        float mass = 3.0;

        // diameter of model
        float diagonal_size = 0.35;

        /*
          the ref values are for a test at fixed angle, used to estimate drag
         */
        float refSpd = 15.08; // m/s
        float refAngle = 45;  // degrees
        float refVoltage = 12.09; // Volts
        float refCurrent = 29.3; // Amps
        float refAlt = 593; // altitude AMSL
        float refTempC = 25; // temperature C
        float refBatRes = 0.01; // BAT.Res

        // full pack voltage
        float maxVoltage = 4.2*3;

        // battery capacity in Ah. Use zero for unlimited
        float battCapacityAh = 0.0;

        // CTUN.ThO at hover at refAlt
        float hoverThrOut = 0.39;

        // MOT_THST_EXPO
        float propExpo = 0.65;

        // scaling factor for yaw response, deg/sec
        float refRotRate = 120;

        // MOT params are from the reference test
        // MOT_PWM_MIN
        float pwmMin = 1000;
        // MOT_PWM_MAX
        float pwmMax = 2000;
        // MOT_SPIN_MIN
        float spin_min = 0.15;
        // MOT_SPIN_MAX
        float spin_max = 0.95;

        // maximum slew rate of motors
        float slew_max = 150;

        // rotor disc area in m**2 for 4 x 0.35m dia rotors
        // Note that coaxial rotors count as one rotor only when calculating effective disc area
        float disc_area = 0.385;

        // momentum drag coefficient
        float mdrag_coef = 0.2;

        // if zero value will be estimated from mass
        Vector3f moment_of_inertia;

        // if zero will no be used
        Vector3f motor_pos[12];
        Vector3f motor_thrust_vec[12];
        float yaw_factor[12] = {0};

        // number of motors
        float num_motors = 4;

    } default_model;

protected:
    // load frame parameters from a json model file
    void load_frame_params(const char *model_json);

    // get air density in kg/m^3
    float get_air_density(float alt_amsl) const;

    struct Model model;

private:
    // exposed area times coefficient of drag
    float areaCd;
    float mass;
    float last_param_voltage;
#if AP_SIM_ENABLED
    Battery *battery;
#endif

    // json parsing helpers
    void parse_float(AP_JSON::value val, const char* label, float &param);
    void parse_vector3(AP_JSON::value val, const char* label, Vector3f &param);
};
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       /*
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
/*
  Base class for FrSky telemetry
*/

#include "SIM_Frsky.h"

using namespace SITL;

const char *Frsky::dataid_string(DataID id)
{
    switch (id) {
        case DataID::GPS_ALT_BP: return "GPS_ALT_BP";
        case DataID::TEMP1: return "TEMP1";
        case DataID::FUEL: return "FUEL";
        case DataID::TEMP2: return "TEMP2";
        case DataID::GPS_ALT_AP: return "GPS_ALT_AP";
        case DataID::BARO_ALT_BP: return "BARO_ALT_BP";
        case DataID::GPS_SPEED_BP: return "GPS_SPEED_BP";
        case DataID::GPS_LONG_BP: return "GPS_LONG_BP";
        case DataID::GPS_LAT_BP: return "GPS_LAT_BP";
        case DataID::GPS_COURS_BP: return "GPS_COURS_BP";
        case DataID::GPS_SPEED_AP: return "GPS_SPEED_AP";
        case DataID::GPS_LONG_AP: return "GPS_LONG_AP";
        case DataID::GPS_LAT_AP: return "GPS_LAT_AP";
        case DataID::BARO_ALT_AP: return "BARO_ALT_AP";
        case DataID::GPS_LONG_EW: return "GPS_LONG_EW";
        case DataID::GPS_LAT_NS: return "GPS_LAT_NS";
        case DataID::CURRENT: return "CURRENT";
        case DataID::VFAS: return "VFAS";
    }

    return "UNKNOWN";
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 /*
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
/*
  Base class for serial rangefinders
*/

#pragma once

#include "SIM_Aircraft.h"

#include <SITL/SITL.h>

#include "SIM_SerialDevice.h"

namespace SITL {

class Frsky : public SerialDevice {
public:

    Frsky() {};

    // update state
    virtual void update() = 0;

protected:

    enum class DataID {
        GPS_ALT_BP          = 0x01,
        TEMP1               = 0x02,
        FUEL                = 0x04,
        TEMP2               = 0x05,
        GPS_ALT_AP          = 0x09,
        BARO_ALT_BP         = 0x10,
        GPS_SPEED_BP        = 0x11,
        GPS_LONG_BP         = 0x12,
        GPS_LAT_BP          = 0x13,
        GPS_COURS_BP        = 0x14,
        GPS_SPEED_AP        = 0x19,
        GPS_LONG_AP         = 0x1A,
        GPS_LAT_AP          = 0x1B,
        BARO_ALT_AP         = 0x21,
        GPS_LONG_EW         = 0x22,
        GPS_LAT_NS          = 0x23,
        CURRENT             = 0x28,
        VFAS                = 0x39,
    };

    const char *dataid_string(DataID id);
};

}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   /*
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
/*
  Base class for FrSky D telemetry
*/

#include "SIM_Frsky_D.h"

#include <AP_HAL/AP_HAL.h>

extern const AP_HAL::HAL& hal;

using namespace SITL;

// sadly, this pulls START_STOP_D etc in from the frsky header.
#include <GCS_MAVLink/GCS.h>

static const uint8_t START_STOP_D              = 0x5E;
static const uint8_t BYTESTUFF_D               = 0x5D;

void Frsky_D::handle_data(uint8_t id, uint16_t data)
{
    hal.console->printf(
              "Frsky: id=%s (0x%02X) data=%u\n",
              dataid_string((DataID)id),
              (unsigned)_id,
              (unsigned)data);
}

void Frsky_D::update()
{
    const ssize_t n = read_from_autopilot(&_buffer[_buflen], ARRAY_SIZE(_buffer) - _buflen - 1);
    if (n != -1) {
        _buflen += n;
    }

    if (_buflen == 0) {
        return;
    }

    while (_buflen) {
        switch (_state) {
        case State::WANT_START_STOP_D:
            if (_buffer[0] != START_STOP_D) {
                AP_HAL::panic("Corrupt?");
                // _lost_bytes++;
                continue;
            }
            memcpy(&_buffer[0], &_buffer[1], --_buflen); //srsly?!
            _state = State::WANT_ID;
            break;
        case State::WANT_ID:
            _id = _buffer[0];
            memcpy(&_buffer[0], &_buffer[1], --_buflen); //srsly?!
            _state = State::WANT_BYTE1;
            break;
        case State::WANT_BYTE1:
        case State::WANT_BYTE2: {
            uint8_t byte;
            uint8_t consume = 1;
            if (_buffer[0] == 0x5D) {
                // byte-stuffed
                if (_buflen < 2) {
                    return;
                }
                if (_buffer[1] == 0x3E) {
                    byte = START_STOP_D;
                } else if (_buffer[1] == 0x3D) {
                    byte = BYTESTUFF_D;
                } else {
                    AP_HAL::panic("Unknown stuffed byte");
                }
                consume = 2;
            } else {
                byte = _buffer[0];
            }

            memcpy(&_buffer[0], &_buffer[consume], _buflen-consume);
            _buflen -= consume;

            switch (_state) {
            case State::WANT_ID:
            case State::WANT_START_STOP_D:
                AP_HAL::panic("Should not get here");
            case State::WANT_BYTE1:
                _data = byte;
                _state = State::WANT_BYTE2;
                break;
            case State::WANT_BYTE2:
                _data |= byte << 8;
                handle_data(_id, _data);
                _state = State::WANT_START_STOP_D;
                break;
            }
        }
        }
    }
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         