cy`"""

		# just the structure here
		self.current_group = 0
		"""
		Current build group
		"""

		self.groups = []
		"""
		List containing lists of task generators
		"""

		self.group_names = {}
		"""
		Map group names to the group lists. See :py:meth:`waflib.Build.BuildContext.add_group`
		"""

		for v in SAVED_ATTRS:
			if not hasattr(self, v):
				setattr(self, v, {})

	def get_variant_dir(self):
		"""Getter for the variant_dir attribute"""
		if not self.variant:
			return self.out_dir
		return os.path.join(self.out_dir, os.path.normpath(self.variant))
	variant_dir = property(get_variant_dir, None)

	def __call__(self, *k, **kw):
		"""
		Create a task generator and add it to the current build group. The following forms are equivalent::

			def build(bld):
				tg = bld(a=1, b=2)

			def build(bld):
				tg = bld()
				tg.a = 1
				tg.b = 2

			def build(bld):
				tg = TaskGen.task_gen(a=1, b=2)
				bld.add_to_group(tg, None)

		:param group: group name to add the task generator to
		:type group: string
		"""
		kw['bld'] = self
		ret = TaskGen.task_gen(*k, **kw)
		self.task_gen_cache_names = {} # reset the cache, each time
		self.add_to_group(ret, group=kw.get('group'))
		return ret

	def __copy__(self):
		"""
		Build contexts cannot be copied

		:raises: :py:class:`waflib.Errors.WafError`
		"""
		raise Errors.WafError('build contexts cannot be copied')

	def load_envs(self):
		"""
		The configuration command creates files of the form ``build/c4che/NAMEcache.py``. This method
		creates a :py:class:`waflib.ConfigSet.ConfigSet` instance for each ``NAME`` by reading those
		files and stores them in :py:attr:`waflib.Build.BuildContext.allenvs`.
		"""
		node = self.root.find_node(self.cache_dir)
		if not node:
			raise Errors.WafError('The project was not configured: run "waf configure" first!')
		lst = node.ant_glob('**/*%s' % CACHE_SUFFIX, quiet=True)

		if not lst:
			raise Errors.WafError('The cache directory is empty: reconfigure the project')

		for x in lst:
			name = x.path_from(node).replace(CACHE_SUFFIX, '').replace('\\', '/')
			env = ConfigSet.ConfigSet(x.abspath())
			self.all_envs[name] = env
			for f in env[CFG_FILES]:
				newnode = self.root.find_resource(f)
				if not newnode or not newnode.exists():
					raise Errors.WafError('Missing configuration file %r, reconfigure the project!' % f)

	def init_dirs(self):
		"""
		Initialize the project directory and the build directory by creating the nodes
		:py:attr:`waflib.Build.BuildContext.srcnode` and :py:attr:`waflib.Build.BuildContext.bldnode`
		corresponding to ``top_dir`` and ``variant_dir`` respectively. The ``bldnode`` directory is
		created if necessary.
		"""
		if not (os.path.isabs(self.top_dir) and os.path.isabs(self.out_dir)):
			raise Errors.WafError('The project was not configured: run "waf configure" first!')

		self.path = self.srcnode = self.root.find_dir(self.top_dir)
		self.bldnode = self.root.make_node(self.variant_dir)
		self.bldnode.mkdir()

	def execute(self):
		"""
		Restore data from previous builds and call :py:meth:`waflib.Build.BuildContext.execute_build`.
		Overrides from :py:func:`waflib.Context.Context.execute`
		"""
		self.restore()
		if not self.all_envs:
			self.load_envs()
		self.execute_build()

	def execute_build(self):
		"""
		Execute the build by:

		* reading the scripts (see :py:meth:`waflib.Context.Context.recurse`)
		* calling :py:meth:`waflib.Build.BuildContext.pre_build` to call user build functions
		* calling :py:meth:`waflib.Build.BuildContext.compile` to process the tasks
		* calling :py:meth:`waflib.Build.BuildContext.post_build` to call user build functions
		"""

		Logs.info("Waf: Entering directory `%s'", self.variant_dir)
		self.recurse([self.run_dir])
		self.pre_build()

		# display the time elapsed in the progress bar
		self.timer = Utils.Timer()

		try:
			self.compile()
		finally:
			if self.progress_bar == 1 and sys.stderr.isatty():
				c = self.producer.processed or 1
				m = self.progress_line(c, c, Logs.colors.BLUE, Logs.colors.NORMAL)
				Logs.info(m, extra={'stream': sys.stderr, 'c1': Logs.colors.cursor_off, 'c2' : Logs.colors.cursor_on})
			Logs.info("Waf: Leaving directory `%s'", self.variant_dir)
		try:
			self.producer.bld = None
			del self.producer
		except AttributeError:
			pass
		self.post_build()

	def restore(self):
		"""
		Load data from a previous run, sets the attributes listed in :py:const:`waflib.Build.SAVED_ATTRS`
		"""
		try:
			env = ConfigSet.ConfigSet(os.path.join(self.cache_dir, 'build.config.py'))
		except EnvironmentError:
			pass
		else:
			if env.version < Context.HEXVERSION:
				raise Errors.WafError('Project was configured with a different version of Waf, please reconfigure it')

			for t in env.tools:
				self.setup(**t)

		dbfn = os.path.join(self.variant_dir, Context.DBFILE)
		try:
			data = Utils.readf(dbfn, 'rb')
		except (EnvironmentError, EOFError):
			# handle missing file/empty file
			Logs.debug('build: Could not load the build cache %s (missing)', dbfn)
		else:
			try:
				Node.pickle_lock.acquire()
				Node.Nod3 = self.node_class
				try:
					data = cPickle.loads(data)
				except Exception as e:
					Logs.debug('build: Could not pickle the build cache %s: %r', dbfn, e)
				else:
					for x in SAVED_ATTRS:
						setattr(self, x, data.get(x, {}))
			finally:
				Node.pickle_lock.release()

		self.init_dirs()

	def store(self):
		"""
		Store data for next runs, set the attributes listed in :py:const:`waflib.Build.SAVED_ATTRS`. Uses a temporary
		file to avoid problems on ctrl+c.
		"""
		data = {}
		for x in SAVED_ATTRS:
			data[x] = getattr(self, x)
		db = os.path.join(self.variant_dir, Context.DBFILE)

		try:
			Node.pickle_lock.acquire()
			Node.Nod3 = self.node_class
			x = cPickle.dumps(data, PROTOCOL)
		finally:
			Node.pickle_lock.release()

		Utils.writef(db + '.tmp', x, m='wb')

		try:
			st = os.stat(db)
			os.remove(db)
			if not Utils.is_win32: # win32 has no chown but we're paranoid
				os.chown(db + '.tmp', st.st_uid, st.st_gid)
		except (AttributeError, OSError):
			pass

		# do not use shutil.move (copy is not thread-safe)
		os.rename(db + '.tmp', db)

	def compile(self):
		"""
		Run the build by creating an instance of :py:class:`waflib.Runner.Parallel`
		The cache file is written when at least a task was executed.

		:raises: :py:class:`waflib.Errors.BuildError` in case the build fails
		"""
		Logs.debug('build: compile()')

		# delegate the producer-consumer logic to another object to reduce the complexity
		self.producer = Runner.Parallel(self, self.jobs)
		self.producer.biter = self.get_build_iterator()
		try:
			self.producer.start()
		except KeyboardInterrupt:
			if self.is_dirty():
				self.store()
			raise
		else:
			if self.is_dirty():
				self.store()

		if self.producer.error:
			raise Errors.BuildError(self.producer.error)

	def is_dirty(self):
		return self.producer.dirty

	def setup(self, tool, tooldir=None, funs=None):
		"""
		Import waf tools defined during the configuration::

			def configure(conf):
				conf.load('glib2')

			def build(bld):
				pass # glib2 is imported implicitly

		:param tool: tool list
		:type tool: list
		:param tooldir: optional tool directory (sys.path)
		:type tooldir: list of string
		:param funs: unused variable
		"""
		if isinstance(tool, list):
			for i in tool:
				self.setup(i, tooldir)
			return

		module = Context.load_tool(tool, tooldir)
		if hasattr(module, "setup"):
			module.setup(self)

	def get_env(self):
		"""Getter for the env property"""
		try:
			return self.all_envs[self.variant]
		except KeyError:
			return self.all_envs['']
	def set_env(self, val):
		"""Setter for the env property"""
		self.all_envs[self.variant] = val

	env = property(get_env, set_env)

	def add_manual_dependency(self, path, value):
		"""
		Adds a dependency from a node object to a value::

			def build(bld):
				bld.add_manual_dependency(
					bld.path.find_resource('wscript'),
					bld.root.find_resource('/etc/fstab'))

		:param path: file path
		:type path: string or :py:class:`waflib.Node.Node`
		:param value: value to depend
		:type value: :py:class:`waflib.Node.Node`, byte object, or function returning a byte object
		"""
		if not path:
			raise ValueError('Invalid input path %r' % path)

		if isinstance(path, Node.Node):
			node = path
		elif os.path.isabs(path):
			node = self.root.find_resource(path)
		else:
			node = self.path.find_resource(path)
		if not node:
			raise ValueError('Could not find the path %r' % path)

		if isinstance(value, list):
			self.deps_man[node].extend(value)
		else:
			self.deps_man[node].append(value)

	def launch_node(self):
		"""Returns the launch directory as a :py:class:`waflib.Node.Node` object (cached)"""
		try:
			# private cache
			return self.p_ln
		except AttributeError:
			self.p_ln = self.root.find_dir(self.launch_dir)
			return self.p_ln

	def hash_env_vars(self, env, vars_lst):
		"""
		Hashes configuration set variables::

			def build(bld):
				bld.hash_env_vars(bld.env, ['CXX', 'CC'])

		This method uses an internal cache.

		:param env: Configuration Set
		:type env: :py:class:`waflib.ConfigSet.ConfigSet`
		:param vars_lst: list of variables
		:type vars_list: list of string
		"""

		if not env.table:
			env = env.parent
			if not env:
				return Utils.SIG_NIL

		idx = str(id(env)) + str(vars_lst)
		try:
			cache = self.cache_env
		except AttributeError:
			cache = self.cache_env = {}
		else:
			try:
				return self.cache_env[idx]
			except KeyError:
				pass

		lst = [env[a] for a in vars_lst]
		cache[idx] = ret = Utils.h_list(lst)
		Logs.debug('envhash: %s %r', Utils.to_hex(ret), lst)
		return ret

	def get_tgen_by_name(self, name):
		"""
		Fetches a task generator by its name or its target attribute;
		the name must be unique in a build::

			def build(bld):
				tg = bld(name='foo')
				tg == bld.get_tgen_by_name('foo')

		This method use a private internal cache.

		:param name: Task generator name
		:raises: :py:class:`waflib.Errors.WafError` in case there is no task genenerator by that name
		"""
		cache = self.task_gen_cache_names
		if not cache:
			# create the index lazily
			for g in self.groups:
				for tg in g:
					try:
						cache[tg.name] = tg
					except AttributeError:
						# raised if not a task generator, which should be uncommon
						pass
		try:
			return cache[name]
		except KeyError:
			raise Errors.WafError('Could not find a task generator for the name %r' % name)

	def progress_line(self, idx, total, col1, col2):
		"""
		Computes a progress bar line displayed when running ``waf -p``

		:returns: progress bar line
		:rtype: string
		"""
		if not sys.stderr.isatty():
			return ''

		n = len(str(total))

		Utils.rot_idx += 1
		ind = Utils.rot_chr[Utils.rot_idx % 4]

		pc = (100. * idx)/total
		fs = "[%%%dd/%%d][%%s%%2d%%%%%%s][%s][" % (n, ind)
		left = fs % (idx, total, col1, pc, col2)
		right = '][%s%s%s]' % (col1, self.timer, col2)

		cols = Logs.get_term_cols() - len(left) - len(right) + 2*len(col1) + 2*len(col2)
		if cols < 7:
			cols = 7

		ratio = ((cols * idx)//total) - 1

		bar = ('='*ratio+'>').ljust(cols)
		msg = Logs.indicator % (left, bar, right)

		return msg

	def declare_chain(self, *k, **kw):
		"""
		Wraps :py:func:`waflib.TaskGen.declare_chain` for convenience
		"""
		return TaskGen.declare_chain(*k, **kw)

	def pre_build(self):
		"""Executes user-defined methods before the build starts, see :py:meth:`waflib.Build.BuildContext.add_pre_fun`"""
		for m in getattr(self, 'pre_funs', []):
			m(self)

	def post_build(self):
		"""Executes user-defined methods after the build is successful, see :py:meth:`waflib.Build.BuildContext.add_post_fun`"""
		for m in getattr(self, 'post_funs', []):
			m(self)

	def add_pre_fun(self, meth):
		"""
		Binds a callback method to execute after the scripts are read and before the build starts::

			def mycallback(bld):
				print("Hello, world!")

			def build(bld):
				bld.add_pre_fun(mycallback)
		"""
		try:
			self.pre_funs.append(meth)
		except AttributeError:
			self.pre_funs = [meth]

	def add_post_fun(self, meth):
		"""
		Binds a callback method to execute immediately after the build is successful::

			def call_ldconfig(bld):
				bld.exec_command('/sbin/ldconfig')

			def build(bld):
				if bld.cmd == 'install':
					bld.add_pre_fun(call_ldconfig)
		"""
		try:
			self.post_funs.append(meth)
		except AttributeError:
			self.post_funs = [meth]

	def get_group(self, x):
		"""
		Returns the build group named `x`, or the current group if `x` is None

		:param x: name or number or None
		:type x: string, int or None
		"""
		if not self.groups:
			self.add_group()
		if x is None:
			return self.groups[self.current_group]
		if x in self.group_names:
			return self.group_names[x]
		return self.groups[x]

	def add_to_group(self, tgen, group=None):
		"""Adds a task or a task generator to the build; there is no attempt to remove it if it was already added."""
		assert(isinstance(tgen, TaskGen.task_gen) or isinstance(tgen, Task.Task))
		tgen.bld = self
		self.get_group(group).append(tgen)

	def get_group_name(self, g):
		"""
		Returns the name of the input build group

		:param g: build group object or build group index
		:type g: integer or list
		:return: name
		:rtype: string
		"""
		if not isinstance(g, list):
			g = self.groups[g]
		for x in self.group_names:
			if id(self.group_names[x]) == id(g):
				return x
		return ''

	def get_group_idx(self, tg):
		"""
		Returns the index of the group containing the task generator given as argument::

			def build(bld):
				tg = bld(name='nada')
				0 == bld.get_group_idx(tg)

		:param tg: Task generator object
		:type tg: :py:class:`waflib.TaskGen.task_gen`
		:rtype: int
		"""
		se = id(tg)
		for i, tmp in enumerate(self.groups):
			for t in tmp:
				if id(t) == se:
					return i
		return None

	def add_group(self, name=None, move=True):
		"""
		Adds a new group of tasks/task generators. By default the new group becomes
		the default group for new task generators (make sure to create build groups in order).

		:param name: name for this group
		:type name: string
		:param move: set this new group as default group (True by default)
		:type move: bool
		:raises: :py:class:`waflib.Errors.WafError` if a group by the name given already exists
		"""
		if name and name in self.group_names:
			raise Errors.WafError('add_group: name %s already present' % name)
		g = []
		self.group_names[name] = g
		self.groups.append(g)
		if move:
			self.current_group = len(self.groups) - 1

	def set_group(self, idx):
		"""
		Sets the build group at position idx as current so that newly added
		task generators are added to this one by default::

			def build(bld):
				bld(rule='touch ${TGT}', target='foo.txt')
				bld.add_group() # now the current group is 1
				bld(rule='touch ${TGT}', target='bar.txt')
				bld.set_group(0) # now the current group is 0
				bld(rule='touch ${TGT}', target='truc.txt') # build truc.txt before bar.txt

		:param idx: group name or group index
		:type idx: string or int
		"""
		if isinstance(idx, str):
			g = self.group_names[idx]
			for i, tmp in enumerate(self.groups):
				if id(g) == id(tmp):
					self.current_group = i
					break
		else:
			self.current_group = idx

	def total(self):
		"""
		Approximate task count: this value may be inaccurate if task generators
		are posted lazily (see :py:attr:`waflib.Build.BuildContext.post_mode`).
		The value :py:attr:`waflib.Runner.Parallel.total` is updated during the task execution.

		:rtype: int
		"""
		total = 0
		for group in self.groups:
			for tg in group:
				try:
					total += len(tg.tasks)
				except AttributeError:
					total += 1
		return total

	def get_targets(self):
		"""
		This method returns a pair containing the index of the last build group to post,
		and the list of task generator objects corresponding to the target names.

		This is used internally by :py:meth:`waflib.Build.BuildContext.get_build_iterator`
		to perform partial builds::

			$ waf --targets=myprogram,myshlib

		:return: the minimum build group index, and list of task generators
		:rtype: tuple
		"""
		to_post = []
		min_grp = 0
		for name in self.targets.split(','):
			tg = self.get_tgen_by_name(name)
			m = self.get_group_idx(tg)
			if m > min_grp:
				min_grp = m
				to_post = [tg]
			elif m == min_grp:
				to_post.append(tg)
		return (min_grp, to_post)

	def get_all_task_gen(self):
		"""
		Returns a list of all task generators for troubleshooting purposes.
		"""
		lst = []
		for g in self.groups:
			lst.extend(g)
		return lst

	def post_group(self):
		"""
		Post task generators from the group indexed by self.current_group; used internally
		by :py:meth:`waflib.Build.BuildContext.get_build_iterator`
		"""
		def tgpost(tg):
			try:
				f = tg.post
			except AttributeError:
				pass
			else:
				f()

		if self.targets == '*':
			for tg in self.groups[self.current_group]:
				tgpost(tg)
		elif self.targets:
			if self.current_group < self._min_grp:
				for tg in self.groups[self.current_group]:
					tgpost(tg)
			else:
				for tg in self._exact_tg:
					tg.post()
		else:
			ln = self.launch_node()
			if ln.is_child_of(self.bldnode):
				if Logs.verbose > 1:
					Logs.warn('Building from the build directory, forcing --targets=*')
				ln = self.srcnode
			elif not ln.is_child_of(self.srcnode):
				if Logs.verbose > 1:
					Logs.warn('CWD %s is not under %s, forcing --targets=* (run distclean?)', ln.abspath(), self.srcnode.abspath())
				ln = self.srcnode

			def is_post(tg, ln):
				try:
					p = tg.path
				except AttributeError:
					pass
				else:
					if p.is_child_of(ln):
						return True

			def is_post_group():
				for i, g in enumerate(self.groups):
					if i > self.current_group:
						for tg in g:
							if is_post(tg, ln):
								return True

			if self.post_mode == POST_LAZY and ln != self.srcnode:
				# partial folder builds require all targets from a previous build group
				if is_post_group():
					ln = self.srcnode

			for tg in self.groups[self.current_group]:
				if is_post(tg, ln):
					tgpost(tg)

	def get_tasks_group(self, idx):
		"""
		Returns all task instances for the build group at position idx,
		used internally by :py:meth:`waflib.Build.BuildContext.get_build_iterator`

		:rtype: list of :py:class:`waflib.Task.Task`
		"""
		tasks = []
		for tg in self.groups[idx]:
			try:
				tasks.extend(tg.tasks)
			except AttributeError: # not a task generator
				tasks.append(tg)
		return tasks

	def get_build_iterator(self):
		"""
		Creates a Python generator object that returns lists of tasks that may be processed in parallel.

		:return: tasks which can be executed immediately
		:rtype: generator returning lists of :py:class:`waflib.Task.Task`
		"""
		if self.targets and self.targets != '*':
			(self._min_grp, self._exact_tg) = self.get_targets()

		if self.post_mode != POST_LAZY:
			for self.current_group, _ in enumerate(self.groups):
				self.post_group()

		for self.current_group, _ in enumerate(self.groups):
			# first post the task generators for the group
			if self.post_mode != POST_AT_ONCE:
				self.post_group()

			# then extract the tasks
			tasks = self.get_tasks_group(self.current_group)

			# if the constraints are set properly (ext_in/ext_out, before/after)
			# the call to set_file_constraints may be removed (can be a 15% penalty on no-op rebuilds)
			# (but leave set_file_constraints for the installation step)
			#
			# if the tasks have only files, set_file_constraints is required but set_precedence_constraints is not necessary
			#
			Task.set_file_constraints(tasks)
			Task.set_precedence_constraints(tasks)

			self.cur_tasks = tasks
			if tasks:
				yield tasks

		while 1:
			# the build stops once there are no tasks to process
			yield []

	def install_files(self, dest, files, **kw):
		"""
		Creates a task generator to install files on the system::

			def build(bld):
				bld.install_files('${DATADIR}', self.path.find_resource('wscript'))

		:param dest: path representing the destination directory
		:type dest: :py:class:`waflib.Node.Node` or string (absolute path)
		:param files: input files
		:type files: list of strings or list of :py:class:`waflib.Node.Node`
		:param env: configuration set to expand *dest*
		:type env: :py:class:`waflib.ConfigSet.ConfigSet`
		:param relative_trick: preserve the folder hierarchy when installing whole folders
		:type relative_trick: bool
		:param cwd: parent node for searching srcfile, when srcfile is not an instance of :py:class:`waflib.Node.Node`
		:type cwd: :py:class:`waflib.Node.Node`
		:param postpone: execute the task immediately to perform the installation (False by default)
		:type postpone: bool
		"""
		assert(dest)
		tg = self(features='install_task', install_to=dest, install_from=files, **kw)
		tg.dest = tg.install_to
		tg.type = 'install_files'
		if not kw.get('postpone', True):
			tg.post()
		return tg

	def install_as(self, dest, srcfile, **kw):
		"""
		Creates a task generator to install a file on the system with a different name::

			def build(bld):
				bld.install_as('${PREFIX}/bin', 'myapp', chmod=Utils.O755)

		:param dest: destination file
		:type dest: :py:class:`waflib.Node.Node` or string (absolute path)
		:param srcfile: input file
		:type srcfile: string or :py:class:`waflib.Node.Node`
		:param cwd: parent node for searching srcfile, when srcfile is not an instance of :py:class:`waflib.Node.Node`
		:type cwd: :py:class:`waflib.Node.Node`
		:param env: configuration set for performing substitutions in dest
		:type env: :py:class:`waflib.ConfigSet.ConfigSet`
		:param postpone: execute the task immediately to perform the installation (False by default)
		:type postpone: bool
		"""
		assert(dest)
		tg = self(features='install_task', install_to=dest, install_from=srcfile, **kw)
		tg.dest = tg.install_to
		tg.type = 'install_as'
		if not kw.get('postpone', True):
			tg.post()
		return tg

	def symlink_as(self, dest, src, **kw):
		"""
		Creates a task generator to install a symlink::

			def build(bld):
				bld.symlink_as('${PREFIX}/lib/libfoo.so', 'libfoo.so.1.2.3')

		:param dest: absolute path of the symlink
		:type dest: :py:class:`waflib.Node.Node` or string (absolute path)
		:param src: link contents, which is a relative or absolute path which may exist or not
		:type src: string
		:param env: configuration set for performing substitutions in dest
		:type env: :py:class:`waflib.ConfigSet.ConfigSet`
		:param add: add the task created to a build group - set ``False`` only if the installation task is created after the build has started
		:type add: bool
		:param postpone: execute the task immediately to perform the installation
		:type postpone: bool
		:param relative_trick: make the symlink relative (default: ``False``)
		:type relative_trick: bool
		"""
		assert(dest)
		tg = self(features='install_task', install_to=dest, install_from=src, **kw)
		tg.dest = tg.install_to
		tg.type = 'symlink_as'
		tg.link = src
		# TODO if add: self.add_to_group(tsk)
		if not kw.get('postpone', True):
			tg.post()
		return tg

@TaskGen.feature('install_task')
@TaskGen.before_method('process_rule', 'process_source')
def process_install_task(self):
	"""Creates the installation task for the current task generator; uses :py:func:`waflib.Build.add_install_task` internally."""
	self.add_install_task(**self.__dict__)

@TaskGen.taskgen_method
def add_install_task(self, **kw):
	"""
	Creates the installation task for the current task generator, and executes it immediately if necessary

	:returns: An installation task
	:rtype: :py:class:`waflib.Build.inst`
	"""
	if not self.bld.is_install:
		return
	if not kw['install_to']:
		return

	if kw['type'] == 'symlink_as' and Utils.is_win32:
		if kw.get('win32_install'):
			kw['type'] = 'install_as'
		else:
			# just exit
			return

	tsk = self.install_task = self.create_task('inst')
	tsk.chmod = kw.get('chmod', Utils.O644)
	tsk.link = kw.get('link', '') or kw.get('install_from', '')
	tsk.relative_trick = kw.get('relative_trick', False)
	tsk.type = kw['type']
	tsk.install_to = tsk.dest = kw['install_to']
	tsk.install_from = kw['install_from']
	tsk.relative_base = kw.get('cwd') or kw.get('relative_base', self.path)
	tsk.install_user = kw.get('install_user')
	tsk.install_group = kw.get('install_group')
	tsk.init_files()
	if not kw.get('postpone', True):
		tsk.run_now()
	return tsk

@TaskGen.taskgen_method
def add_install_files(self, **kw):
	"""
	Creates an installation task for files

	:returns: An installation task
	:rtype: :py:class:`waflib.Build.inst`
	"""
	kw['type'] = 'install_files'
	return self.add_install_task(**kw)

@TaskGen.taskgen_method
def add_install_as(self, **kw):
	"""
	Creates an installation task for a single file

	:returns: An installation task
	:rtype: :py:class:`waflib.Build.inst`
	"""
	kw['type'] = 'install_as'
	return self.add_install_task(**kw)

@TaskGen.taskgen_method
def add_symlink_as(self, **kw):
	"""
	Creates an installation task for a symbolic link

	:returns: An installation task
	:rtype: :py:class:`waflib.Build.inst`
	"""
	kw['type'] = 'symlink_as'
	return self.add_install_task(**kw)

class inst(Task.Task):
	"""Task that installs files or symlinks; it is typically executed by :py:class:`waflib.Build.InstallContext` and :py:class:`waflib.Build.UnInstallContext`"""
	def __str__(self):
		"""Returns an empty string to disable the standard task display"""
		return ''

	def uid(self):
		"""Returns a unique identifier for the task"""
		lst = self.inputs + self.outputs + [self.link, self.generator.path.abspath()]
		return Utils.h_list(lst)

	def init_files(self):
		"""
		Initializes the task input and output nodes
		"""
		if self.type == 'symlink_as':
			inputs = []
		else:
			inputs = self.generator.to_nodes(self.install_from)
			if self.type == 'install_as':
				assert len(inputs) == 1
		self.set_inputs(inputs)

		dest = self.get_install_path()
		outputs = []
		if self.type == 'symlink_as':
			if self.relative_trick:
				self.link = os.path.relpath(self.link, os.path.dirname(dest))
			outputs.append(self.generator.bld.root.make_node(dest))
		elif self.type == 'install_as':
			outputs.append(self.generator.bld.root.make_node(dest))
		else:
			for y in inputs:
				if self.relative_trick:
					destfile = os.path.join(dest, y.path_from(self.relative_base))
				else:
					destfile = os.path.join(dest, y.name)
				outputs.append(self.generator.bld.root.make_node(destfile))
		self.set_outputs(outputs)

	def runnable_status(self):
		"""
		Installation tasks are always executed, so this method returns either :py:const:`waflib.Task.ASK_LATER` or :py:const:`waflib.Task.RUN_ME`.
		"""
		ret = super(inst, self).runnable_status()
		if ret == Task.SKIP_ME and self.generator.bld.is_install:
			return Task.RUN_ME
		return ret

	def post_run(self):
		"""
		Disables any post-run operations
		"""
		pass

	def get_install_path(self, destdir=True):
		"""
		Returns the destination path where files will be installed, pre-pending `destdir`.

		Relative paths will be interpreted relative to `PREFIX` if no `destdir` is given.

		:rtype: string
		"""
		if isinstance(self.install_to, Node.Node):
			dest = self.install_to.abspath()
		else:
			dest = os.path.normpath(Utils.subst_vars(self.install_to, self.env))
		if not os.path.isabs(dest):
			dest = os.path.join(self.env.PREFIX, dest)
		if destdir and Options.options.destdir:
			dest = Options.options.destdir.rstrip(os.sep) + os.sep + os.path.splitdrive(dest)[1].lstrip(os.sep)
		return dest

	def copy_fun(self, src, tgt):
		"""
		Copies a file from src to tgt, preserving permissions and trying to work
		around path limitations on Windows platforms. On Unix-like platforms,
		the owner/group of the target file may be set through install_user/install_group

		:param src: absolute path
		:type src: string
		:param tgt: absolute path
		:type tgt: string
		"""
		# override this if you want to strip executables
		# kw['tsk'].source is the task that created the files in the build
		if Utils.is_win32 and len(tgt) > 259 and not tgt.startswith('\\\\?\\'):
			tgt = '\\\\?\\' + tgt
		shutil.copy2(src, tgt)
		self.fix_perms(tgt)

	def rm_empty_dirs(self, tgt):
		"""
		Removes empty folders recursively when uninstalling.

		:param tgt: absolute path
		:type tgt: string
		"""
		while tgt:
			tgt = os.path.dirname(tgt)
			try:
				os.rmdir(tgt)
			except OSError:
				break

	def run(self):
		"""
		Performs file or symlink installation
		"""
		is_install = self.generator.bld.is_install
		if not is_install: # unnecessary?
			return

		for x in self.outputs:
			if is_install == INSTALL:
				x.parent.mkdir()
		if self.type == 'symlink_as':
			fun = is_install == INSTALL and self.do_link or self.do_unlink
			fun(self.link, self.outputs[0].abspath())
		else:
			fun = is_install == INSTALL and self.do_install or self.do_uninstall
			launch_node = self.generator.bld.launch_node()
			for x, y in zip(self.inputs, self.outputs):
				fun(x.abspath(), y.abspath(), x.path_from(launch_node))

	def run_now(self):
		"""
		Try executing the installation task right now

		:raises: :py:class:`waflib.Errors.TaskNotReady`
		"""
		status = self.runnable_status()
		if status not in (Task.RUN_ME, Task.SKIP_ME):
			raise Errors.TaskNotReady('Could not process %r: status %r' % (self, status))
		self.run()
		self.hasrun = Task.SUCCESS

	def do_install(self, src, tgt, lbl, **kw):
		"""
		Copies a file from src to tgt with given file permissions. The actual copy is only performed
		if the source and target file sizes or timestamps differ. When the copy occurs,
		the file is always first removed and then copied so as to prevent stale inodes.

		:param src: file name as absolute path
		:type src: string
		:param tgt: file destination, as absolute path
		:type tgt: string
		:param lbl: file source description
		:type lbl: string
		:param chmod: installation mode
		:type chmod: int
		:raises: :py:class:`waflib.Errors.WafError` if the file cannot be written
		"""
		if not Options.options.force:
			# check if the file is already there to avoid a copy
			try:
				st1 = os.stat(tgt)
				st2 = os.stat(src)
			except OSError:
				pass
			else:
				# same size and identical timestamps -> make no copy
				if st1.st_mtime + 2 >= st2.st_mtime and st1.st_size == st2.st_size:
					if not self.generator.bld.progress_bar:

						c1 = Logs.colors.NORMAL
						c2 = Logs.colors.BLUE

						Logs.info('%s- install %s%s%s (from %s)', c1, c2, tgt, c1, lbl)
					return False

		if not self.generator.bld.progress_bar:

			c1 = Logs.colors.NORMAL
			c2 = Logs.colors.BLUE

			Logs.info('%s+ install %s%s%s (from %s)', c1, c2, tgt, c1, lbl)

		# Give best attempt at making destination overwritable,
		# like the 'install' utility used by 'make install' does.
		try:
			os.chmod(tgt, Utils.O644 | stat.S_IMODE(os.stat(tgt).st_mode))
		except EnvironmentError:
			pass

		# following is for shared libs and stale inodes (-_-)
		try:
			os.remove(tgt)
		except OSError:
			pass

		try:
			self.copy_fun(src, tgt)
		except EnvironmentError as e:
			if not os.path.exists(src):
				Logs.error('File %r does not exist', src)
			elif not os.path.isfile(src):
				Logs.error('Input %r is not a file', src)
			raise Errors.WafError('Could not install the file %r' % tgt, e)

	def fix_perms(self, tgt):
		"""
		Change the ownership of the file/folder/link pointed by the given path
		This looks up for `install_user` or `install_group` attributes
		on the task or on the task generator::

			def build(bld):
				bld.install_as('${PREFIX}/wscript',
					'wscript',
					install_user='nobody', install_group='nogroup')
				bld.symlink_as('${PREFIX}/wscript_link',
					Utils.subst_vars('${PREFIX}/wscript', bld.env),
					install_user='nobody', install_group='nogroup')
		"""
		if not Utils.is_win32:
			user = getattr(self, 'install_user', None) or getattr(self.generator, 'install_user', None)
			group = getattr(self, 'install_group', None) or getattr(self.generator, 'install_group', None)
			if user or group:
				Utils.lchown(tgt, user or -1, group or -1)
		if not os.path.islink(tgt):
			os.chmod(tgt, self.chmod)

	def do_link(self, src, tgt, **kw):
		"""
		Creates a symlink from tgt to src.

		:param src: file name as absolute path
		:type src: string
		:param tgt: file destination, as absolute path
		:type tgt: string
		"""
		if os.path.islink(tgt) and os.readlink(tgt) == src:
			if not self.generator.bld.progress_bar:
				c1 = Logs.colors.NORMAL
				c2 = Logs.colors.BLUE
				Logs.info('%s- symlink %s%s%s (to %s)', c1, c2, tgt, c1, src)
		else:
			try:
				os.remove(tgt)
			except OSError:
				pass
			if not self.generator.bld.progress_bar:
				c1 = Logs.colors.NORMAL
				c2 = Logs.colors.BLUE
				Logs.info('%s+ symlink %s%s%s (to %s)', c1, c2, tgt, c1, src)
			os.symlink(src, tgt)
			self.fix_perms(tgt)

	def do_uninstall(self, src, tgt, lbl, **kw):
		"""
		See :py:meth:`waflib.Build.inst.do_install`
		"""
		if not self.generator.bld.progress_bar:
			c1 = Logs.colors.NORMAL
			c2 = Logs.colors.BLUE
			Logs.info('%s- remove %s%s%s', c1, c2, tgt, c1)

		#self.uninstall.append(tgt)
		try:
			os.remove(tgt)
		except OSError as e:
			if e.errno != errno.ENOENT:
				if not getattr(self, 'uninstall_error', None):
					self.uninstall_error = True
					Logs.warn('build: some files could not be uninstalled (retry with -vv to list them)')
				if Logs.verbose > 1:
					Logs.warn('Could not remove %s (error code %r)', e.filename, e.errno)
		self.rm_empty_dirs(tgt)

	def do_unlink(self, src, tgt, **kw):
		"""
		See :py:meth:`waflib.Build.inst.do_link`
		"""
		try:
			if not self.generator.bld.progress_bar:
				c1 = Logs.colors.NORMAL
				c2 = Logs.colors.BLUE
				Logs.info('%s- remove %s%s%s', c1, c2, tgt, c1)
			os.remove(tgt)
		except OSError:
			pass
		self.rm_empty_dirs(tgt)

class InstallContext(BuildContext):
	'''installs the targets on the system'''
	cmd = 'install'

	def __init__(self, **kw):
		super(InstallContext, self).__init__(**kw)
		self.is_install = INSTALL

class UninstallContext(InstallContext):
	'''removes the targets installed'''
	cmd = 'uninstall'

	def __init__(self, **kw):
		super(UninstallContext, self).__init__(**kw)
		self.is_install = UNINSTALL

class CleanContext(BuildContext):
	'''cleans the project'''
	cmd = 'clean'
	def execute(self):
		"""
		See :py:func:`waflib.Build.BuildContext.execute`.
		"""
		self.restore()
		if not self.all_envs:
			self.load_envs()

		self.recurse([self.run_dir])
		try:
			self.clean()
		finally:
			self.store()

	def clean(self):
		"""
		Remove most files from the build directory, and reset all caches.

		Custom lists of files to clean can be declared as `bld.clean_files`.
		For example, exclude `build/program/myprogram` from getting removed::

			def build(bld):
				bld.clean_files = bld.bldnode.ant_glob('**',
					excl='.lock* config.log c4che/* config.h program/myprogram',
					quiet=True, generator=True)
		"""
		Logs.debug('build: clean called')

		if hasattr(self, 'clean_files'):
			for n in self.clean_files:
				n.delete()
		elif self.bldnode != self.srcnode:
			# would lead to a disaster if top == out
			lst = []
			for env in self.all_envs.values():
				lst.extend(self.root.find_or_declare(f) for f in env[CFG_FILES])
			excluded_dirs = '.lock* *conf_check_*/** config.log %s/*' % CACHE_DIR
			for n in self.bldnode.ant_glob('**/*', excl=excluded_dirs, quiet=True):
				if n in lst:
					continue
				n.delete()
		self.root.children = {}

		for v in SAVED_ATTRS:
			if v == 'root':
				continue
			setattr(self, v, {})

class ListContext(BuildContext):
	'''lists the targets to execute'''
	cmd = 'list'

	def execute(self):
		"""
		In addition to printing the name of each build target,
		a description column will include text for each task
		generator which has a "description" field set.

		See :py:func:`waflib.Build.BuildContext.execute`.
		"""
		self.restore()
		if not self.all_envs:
			self.load_envs()

		self.recurse([self.run_dir])
		self.pre_build()

		# display the time elapsed in the progress bar
		self.timer = Utils.Timer()

		for g in self.groups:
			for tg in g:
				try:
					f = tg.post
				except AttributeError:
					pass
				else:
					f()

		try:
			# force the cache initialization
			self.get_tgen_by_name('')
		except Errors.WafError:
			pass

		targets = sorted(self.task_gen_cache_names)

		# figure out how much to left-justify, for largest target name
		line_just = max(len(t) for t in targets) if targets else 0

		for target in targets:
			tgen = self.task_gen_cache_names[target]

			# Support displaying the description for the target
			# if it was set on the tgen
			descript = getattr(tgen, 'description', '')
			if descript:
				target = target.ljust(line_just)
				descript = ': %s' % descript

			Logs.pprint('GREEN', target, label=descript)

class StepContext(BuildContext):
	'''executes tasks in a step-by-step fashion, for debugging'''
	cmd = 'step'

	def __init__(self, **kw):
		super(StepContext, self).__init__(**kw)
		self.files = Options.options.files

	def compile(self):
		"""
		Overrides :py:meth:`waflib.Build.BuildContext.compile` to perform a partial build
		on tasks matching the input/output pattern given (regular expression matching)::

			$ waf step --files=foo.c,bar.c,in:truc.c,out:bar.o
			$ waf step --files=in:foo.cpp.1.o # link task only

		"""
		if not self.files:
			Logs.warn('Add a pattern for the debug build, for example "waf step --files=main.c,app"')
			BuildContext.compile(self)
			return

		targets = []
		if self.targets and self.targets != '*':
			targets = self.targets.split(',')

		for g in self.groups:
			for tg in g:
				if targets and tg.name not in targets:
					continue

				try:
					f = tg.post
				except AttributeError:
					pass
				else:
					f()

			for pat in self.files.split(','):
				matcher = self.get_matcher(pat)
				for tg in g:
					if isinstance(tg, Task.Task):
						lst = [tg]
					else:
						lst = tg.tasks
					for tsk in lst:
						do_exec = False
						for node in tsk.inputs:
							if matcher(node, output=False):
								do_exec = True
								break
						for node in tsk.outputs:
							if matcher(node, output=True):
								do_exec = True
								break
						if do_exec:
							ret = tsk.run()
							Logs.info('%s -> exit %r', tsk, ret)

	def get_matcher(self, pat):
		"""
		Converts a step pattern into a function

		:param: pat: pattern of the form in:truc.c,out:bar.o
		:returns: Python function that uses Node objects as inputs and returns matches
		:rtype: function
		"""
		# this returns a function
		inn = True
		out = True
		if pat.startswith('in:'):
			out = False
			pat = pat.replace('in:', '')
		elif pat.startswith('out:'):
			inn = False
			pat = pat.replace('out:', '')

		anode = self.root.find_node(pat)
		pattern = None
		if not anode:
			if not pat.startswith('^'):
				pat = '^.+?%s' % pat
			if not pat.endswith('$'):
				pat = '%s$' % pat
			pattern = re.compile(pat)

		def match(node, output):
			if output and not out:
				return False
			if not output and not inn:
				return False

			if anode:
				return anode == node
			else:
				return pattern.match(node.abspath())
		return match

class EnvContext(BuildContext):
	"""Subclass EnvContext to create commands that require configuration data in 'env'"""
	fun = cmd = None
	def execute(self):
		"""
		See :py:func:`waflib.Build.BuildContext.execute`.
		"""
		self.restore()
		if not self.all_envs:
			self.load_envs()
		self.recurse([self.run_dir])

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               #!/usr/bin/env python
# encoding: utf-8
# Thomas Nagy, 2005-2018 (ita)

"""

ConfigSet: a special dict

The values put in :py:class:`ConfigSet` must be serializable (dicts, lists, strings)
"""

import copy, re, os
from waflib import Logs, Utils
re_imp = re.compile(r'^(#)*?([^#=]*?)\ =\ (.*?)$', re.M)

class ConfigSet(object):
	"""
	A copy-on-write dict with human-readable serialized format. The serialization format
	is human-readable (python-like) and performed by using eval() and repr().
	For high performance prefer pickle. Do not store functions as they are not serializable.

	The values can be accessed by attributes or by keys::

		from waflib.ConfigSet import ConfigSet
		env = ConfigSet()
		env.FOO = 'test'
		env['FOO'] = 'test'
	"""
	__slots__ = ('table', 'parent')
	def __init__(self, filename=None):
		self.table = {}
		"""
		Internal dict holding the object values
		"""
		#self.parent = None

		if filename:
			self.load(filename)

	def __contains__(self, key):
		"""
		Enables the *in* syntax::

			if 'foo' in env:
				print(env['foo'])
		"""
		if key in self.table:
			return True
		try:
			return self.parent.__contains__(key)
		except AttributeError:
			return False # parent may not exist

	def keys(self):
		"""Dict interface"""
		keys = set()
		cur = self
		while cur:
			keys.update(cur.table.keys())
			cur = getattr(cur, 'parent', None)
		keys = list(keys)
		keys.sort()
		return keys

	def __iter__(self):
		return iter(self.keys())

	def __str__(self):
		"""Text representation of the ConfigSet (for debugging purposes)"""
		return "\n".join(["%r %r" % (x, self.__getitem__(x)) for x in self.keys()])

	def __getitem__(self, key):
		"""
		Dictionary interface: get value from key::

			def configure(conf):
				conf.env['foo'] = {}
				print(env['foo'])
		"""
		try:
			while 1:
				x = self.table.get(key)
				if not x is None:
					return x
				self = self.parent
		except AttributeError:
			return []

	def __setitem__(self, key, value):
		"""
		Dictionary interface: set value from key
		"""
		self.table[key] = value

	def __delitem__(self, key):
		"""
		Dictionary interface: mark the value as missing
		"""
		self[key] = []

	def __getattr__(self, name):
		"""
		Attribute access provided for convenience. The following forms are equivalent::

			def configure(conf):
				conf.env.value
				conf.env['value']
		"""
		if name in self.__slots__:
			return object.__getattribute__(self, name)
		else:
			return self[name]

	def __setattr__(self, name, value):
		"""
		Attribute access provided for convenience. The following forms are equivalent::

			def configure(conf):
				conf.env.value = x
				env['value'] = x
		"""
		if name in self.__slots__:
			object.__setattr__(self, name, value)
		else:
			self[name] = value

	def __delattr__(self, name):
		"""
		Attribute access provided for convenience. The following forms are equivalent::

			def configure(conf):
				del env.value
				del env['value']
		"""
		if name in self.__slots__:
			object.__delattr__(self, name)
		else:
			del self[name]

	def derive(self):
		"""
		Returns a new ConfigSet deriving from self. The copy returned
		will be a shallow copy::

			from waflib.ConfigSet import ConfigSet
			env = ConfigSet()
			env.append_value('CFLAGS', ['-O2'])
			child = env.derive()
			child.CFLAGS.append('test') # warning! this will modify 'env'
			child.CFLAGS = ['-O3'] # new list, ok
			child.append_value('CFLAGS', ['-O3']) # ok

		Use :py:func:`ConfigSet.detach` to detach the child from the parent.
		"""
		newenv = ConfigSet()
		newenv.parent = self
		return newenv

	def detach(self):
		"""
		Detaches this instance from its parent (if present)

		Modifying the parent :py:class:`ConfigSet` will not change the current object
		Modifying this :py:class:`ConfigSet` will not modify the parent one.
		"""
		tbl = self.get_merged_dict()
		try:
			delattr(self, 'parent')
		except AttributeError:
			pass
		else:
			keys = tbl.keys()
			for x in keys:
				tbl[x] = copy.deepcopy(tbl[x])
			self.table = tbl
		return self

	def get_flat(self, key):
		"""
		Returns a value as a string. If the input is a list, the value returned is space-separated.

		:param key: key to use
		:type key: string
		"""
		s = self[key]
		if isinstance(s, str):
			return s
		return ' '.join(s)

	def _get_list_value_for_modification(self, key):
		"""
		Returns a list value for further modification.

		The list may be modified inplace and there is no need to do this afterwards::

			self.table[var] = value
		"""
		try:
			value = self.table[key]
		except KeyError:
			try:
				value = self.parent[key]
			except AttributeError:
				value = []
			else:
				if isinstance(value, list):
					# force a copy
					value = value[:]
				else:
					value = [value]
			self.table[key] = value
		else:
			if not isinstance(value, list):
				self.table[key] = value = [value]
		return value

	def append_value(self, var, val):
		"""
		Appends a value to the specified config key::

			def build(bld):
				bld.env.append_value('CFLAGS', ['-O2'])

		The value must be a list or a tuple
		"""
		if isinstance(val, str): # if there were string everywhere we could optimize this
			val = [val]
		current_value = self._get_list_value_for_modification(var)
		current_value.extend(val)

	def prepend_value(self, var, val):
		"""
		Prepends a value to the specified item::

			def configure(conf):
				conf.env.prepend_value('CFLAGS', ['-O2'])

		The value must be a list or a tuple
		"""
		if isinstance(val, str):
			val = [val]
		self.table[var] =  val + self._get_list_value_for_modification(var)

	def append_unique(self, var, val):
		"""
		Appends a value to the specified item only if it's not already present::

			def build(bld):
				bld.env.append_unique('CFLAGS', ['-O2', '-g'])

		The value must be a list or a tuple
		"""
		if isinstance(val, str):
			val = [val]
		current_value = self._get_list_value_for_modification(var)

		for x in val:
			if x not in current_value:
				current_value.append(x)

	def get_merged_dict(self):
		"""
		Computes the merged dictionary from the fusion of self and all its parent

		:rtype: a ConfigSet object
		"""
		table_list = []
		env = self
		while 1:
			table_list.insert(0, env.table)
			try:
				env = env.parent
			except AttributeError:
				break
		merged_table = {}
		for table in table_list:
			merged_table.update(table)
		return merged_table

	def store(self, filename):
		"""
		Serializes the :py:class:`ConfigSet` data to a file. See :py:meth:`ConfigSet.load` for reading such files.

		:param filename: file to use
		:type filename: string
		"""
		try:
			os.makedirs(os.path.split(filename)[0])
		except OSError:
			pass

		buf = []
		merged_table = self.get_merged_dict()
		keys = list(merged_table.keys())
		keys.sort()

		try:
			fun = ascii
		except NameError:
			fun = repr

		for k in keys:
			if k != 'undo_stack':
				buf.append('%s = %s\n' % (k, fun(merged_table[k])))
		Utils.writef(filename, ''.join(buf))

	def load(self, filename):
		"""
		Restores contents from a file (current values are not cleared). Files are written using :py:meth:`ConfigSet.store`.

		:param filename: file to use
		:type filename: string
		"""
		tbl = self.table
		code = Utils.readf(filename, m='r')
		for m in re_imp.finditer(code):
			g = m.group
			tbl[g(2)] = eval(g(3))
		Logs.debug('env: %s', self.table)

	def update(self, d):
		"""
		Dictionary interface: replace values with the ones from another dict

		:param d: object to use the value from
		:type d: dict-like object
		"""
		self.table.update(d)

	def stash(self):
		"""
		Stores the object state to provide transactionality semantics::

			env = ConfigSet()
			env.stash()
			try:
				env.append_value('CFLAGS', '-O3')
				call_some_method(env)
			finally:
				env.revert()

		The history is kept in a stack, and is lost during the serialization by :py:meth:`ConfigSet.store`
		"""
		orig = self.table
		tbl = self.table = self.table.copy()
		for x in tbl.keys():
			tbl[x] = copy.deepcopy(tbl[x])
		self.undo_stack = self.undo_stack + [orig]

	def commit(self):
		"""
		Commits transactional changes. See :py:meth:`ConfigSet.stash`
		"""
		self.undo_stack.pop(-1)

	def revert(self):
		"""
		Reverts the object to a previous state. See :py:meth:`ConfigSet.stash`
		"""
		self.table = self.undo_stack.pop(-1)

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          #!/usr/bin/env python
# encoding: utf-8
# Thomas Nagy, 2005-2018 (ita)

"""
Configuration system

A :py:class:`waflib.Configure.ConfigurationContext` instance is created when ``waf configure`` is called, it is used to:

* create data dictionaries (ConfigSet instances)
* store the list of modules to import
* hold configuration routines such as ``find_program``, etc
"""

import os, re, shlex, shutil, sys, time, traceback
from waflib import ConfigSet, Utils, Options, Logs, Context, Build, Errors

WAF_CONFIG_LOG = 'config.log'
"""Name of the configuration log file"""

autoconfig = False
"""Execute the configuration automatically"""

conf_template = '''# project %(app)s configured on %(now)s by
# waf %(wafver)s (abi %(abi)s, python %(pyver)x on %(systype)s)
# using %(args)s
#'''

class ConfigurationContext(Context.Context):
	'''configures the project'''

	cmd = 'configure'

	error_handlers = []
	"""
	Additional functions to handle configuration errors
	"""

	def __init__(self, **kw):
		super(ConfigurationContext, self).__init__(**kw)
		self.environ = dict(os.environ)
		self.all_envs = {}

		self.top_dir = None
		self.out_dir = None

		self.tools = [] # tools loaded in the configuration, and that will be loaded when building

		self.hash = 0
		self.files = []

		self.tool_cache = []

		self.setenv('')

	def setenv(self, name, env=None):
		"""
		Set a new config set for conf.env. If a config set of that name already exists,
		recall it without modification.

		The name is the filename prefix to save to ``c4che/NAME_cache.py``, and it
		is also used as *variants* by the build commands.
		Though related to variants, whatever kind of data may be stored in the config set::

			def configure(cfg):
				cfg.env.ONE = 1
				cfg.setenv('foo')
				cfg.env.ONE = 2

			def build(bld):
				2 == bld.env_of_name('foo').ONE

		:param name: name of the configuration set
		:type name: string
		:param env: ConfigSet to copy, or an empty ConfigSet is created
		:type env: :py:class:`waflib.ConfigSet.ConfigSet`
		"""
		if name not in self.all_envs or env:
			if not env:
				env = ConfigSet.ConfigSet()
				self.prepare_env(env)
			else:
				env = env.derive()
			self.all_envs[name] = env
		self.variant = name

	def get_env(self):
		"""Getter for the env property"""
		return self.all_envs[self.variant]
	def set_env(self, val):
		"""Setter for the env property"""
		self.all_envs[self.variant] = val

	env = property(get_env, set_env)

	def init_dirs(self):
		"""
		Initialize the project directory and the build directory
		"""

		top = self.top_dir
		if not top:
			top = Options.options.top
		if not top:
			top = getattr(Context.g_module, Context.TOP, None)
		if not top:
			top = self.path.abspath()
		top = os.path.abspath(top)

		self.srcnode = (os.path.isabs(top) and self.root or self.path).find_dir(top)
		assert(self.srcnode)

		out = self.out_dir
		if not out:
			out = Options.options.out
		if not out:
			out = getattr(Context.g_module, Context.OUT, None)
		if not out:
			out = Options.lockfile.replace('.lock-waf_%s_' % sys.platform, '').replace('.lock-waf', '')

		# someone can be messing with symlinks
		out = os.path.realpath(out)

		self.bldnode = (os.path.isabs(out) and self.root or self.path).make_node(out)
		self.bldnode.mkdir()

		if not os.path.isdir(self.bldnode.abspath()):
			self.fatal('Could not create the build directory %s' % self.bldnode.abspath())

	def execute(self):
		"""
		See :py:func:`waflib.Context.Context.execute`
		"""
		self.init_dirs()

		self.cachedir = self.bldnode.make_node(Build.CACHE_DIR)
		self.cachedir.mkdir()

		path = os.path.join(self.bldnode.abspath(), WAF_CONFIG_LOG)
		self.logger = Logs.make_logger(path, 'cfg')

		app = getattr(Context.g_module, 'APPNAME', '')
		if app:
			ver = getattr(Context.g_module, 'VERSION', '')
			if ver:
				app = "%s (%s)" % (app, ver)

		params = {'now': time.ctime(), 'pyver': sys.hexversion, 'systype': sys.platform, 'args': " ".join(sys.argv), 'wafver': Context.WAFVERSION, 'abi': Context.ABI, 'app': app}
		self.to_log(conf_template % params)
		self.msg('Setting top to', self.srcnode.abspath())
		self.msg('Setting out to', self.bldnode.abspath())

		if id(self.srcnode) == id(self.bldnode):
			Logs.warn('Setting top == out')
		elif id(self.path) != id(self.srcnode):
			if self.srcnode.is_child_of(self.path):
				Logs.warn('Are you certain that you do not want to set top="." ?')

		super(ConfigurationContext, self).execute()

		self.store()

		Context.top_dir = self.srcnode.abspath()
		Context.out_dir = self.bldnode.abspath()

		# this will write a configure lock so that subsequent builds will
		# consider the current path as the root directory (see prepare_impl).
		# to remove: use 'waf distclean'
		env = ConfigSet.ConfigSet()
		env.argv = sys.argv
		env.options = Options.options.__dict__
		env.config_cmd = self.cmd

		env.run_dir = Context.run_dir
		env.top_dir = Context.top_dir
		env.out_dir = Context.out_dir

		# conf.hash & conf.files hold wscript files paths and hash
		# (used only by Configure.autoconfig)
		env.hash = self.hash
		env.files = self.files
		env.environ = dict(self.environ)
		env.launch_dir = Context.launch_dir

		if not (self.env.NO_LOCK_IN_RUN or env.environ.get('NO_LOCK_IN_RUN') or getattr(Options.options, 'no_lock_in_run')):
			env.store(os.path.join(Context.run_dir, Options.lockfile))
		if not (self.env.NO_LOCK_IN_TOP or env.environ.get('NO_LOCK_IN_TOP') or getattr(Options.options, 'no_lock_in_top')):
			env.store(os.path.join(Context.top_dir, Options.lockfile))
		if not (self.env.NO_LOCK_IN_OUT or env.environ.get('NO_LOCK_IN_OUT') or getattr(Options.options, 'no_lock_in_out')):
			env.store(os.path.join(Context.out_dir, Options.lockfile))

	def prepare_env(self, env):
		"""
		Insert *PREFIX*, *BINDIR* and *LIBDIR* values into ``env``

		:type env: :py:class:`waflib.ConfigSet.ConfigSet`
		:param env: a ConfigSet, usually ``conf.env``
		"""
		if not env.PREFIX:
			if Options.options.prefix or Utils.is_win32:
				env.PREFIX = Options.options.prefix
			else:
				env.PREFIX = '/'
		if not env.BINDIR:
			if Options.options.bindir:
				env.BINDIR = Options.options.bindir
			else:
				env.BINDIR = Utils.subst_vars('${PREFIX}/bin', env)
		if not env.LIBDIR:
			if Options.options.libdir:
				env.LIBDIR = Options.options.libdir
			else:
				env.LIBDIR = Utils.subst_vars('${PREFIX}/lib%s' % Utils.lib64(), env)

	def store(self):
		"""Save the config results into the cache file"""
		n = self.cachedir.make_node('build.config.py')
		n.write('version = 0x%x\ntools = %r\n' % (Context.HEXVERSION, self.tools))

		if not self.all_envs:
			self.fatal('nothing to store in the configuration context!')

		for key in self.all_envs:
			tmpenv = self.all_envs[key]
			tmpenv.store(os.path.join(self.cachedir.abspath(), key + Build.CACHE_SUFFIX))

	def load(self, tool_list, tooldir=None, funs=None, with_sys_path=True, cache=False):
		"""
		Load Waf tools, which will be imported whenever a build is started.

		:param tool_list: waf tools to import
		:type tool_list: list of string
		:param tooldir: paths for the imports
		:type tooldir: list of string
		:param funs: functions to execute from the waf tools
		:type funs: list of string
		:param cache: whether to prevent the tool from running twice
		:type cache: bool
		"""

		tools = Utils.to_list(tool_list)
		if tooldir:
			tooldir = Utils.to_list(tooldir)
		for tool in tools:
			# avoid loading the same tool more than once with the same functions
			# used by composite projects

			if cache:
				mag = (tool, id(self.env), tooldir, funs)
				if mag in self.tool_cache:
					self.to_log('(tool %s is already loaded, skipping)' % tool)
					continue
				self.tool_cache.append(mag)

			module = None
			try:
				module = Context.load_tool(tool, tooldir, ctx=self, with_sys_path=with_sys_path)
			except ImportError as e:
				self.fatal('Could not load the Waf tool %r from %r\n%s' % (tool, getattr(e, 'waf_sys_path', sys.path), e))
			except Exception as e:
				self.to_log('imp %r (%r & %r)' % (tool, tooldir, funs))
				self.to_log(traceback.format_exc())
				raise

			if funs is not None:
				self.eval_rules(funs)
			else:
				func = getattr(module, 'configure', None)
				if func:
					if type(func) is type(Utils.readf):
						func(self)
					else:
						self.eval_rules(func)

			self.tools.append({'tool':tool, 'tooldir':tooldir, 'funs':funs})

	def post_recurse(self, node):
		"""
		Records the path and a hash of the scripts visited, see :py:meth:`waflib.Context.Context.post_recurse`

		:param node: script
		:type node: :py:class:`waflib.Node.Node`
		"""
		super(ConfigurationContext, self).post_recurse(node)
		self.hash = Utils.h_list((self.hash, node.read('rb')))
		self.files.append(node.abspath())

	def eval_rules(self, rules):
		"""
		Execute configuration tests provided as list of functions to run

		:param rules: list of configuration method names
		:type rules: list of string
		"""
		self.rules = Utils.to_list(rules)
		for x in self.rules:
			f = getattr(self, x)
			if not f:
				self.fatal('No such configuration function %r' % x)
			f()

def conf(f):
	"""
	Decorator: attach new configuration functions to :py:class:`waflib.Build.BuildContext` and
	:py:class:`waflib.Configure.ConfigurationContext`. The methods bound will accept a parameter
	named 'mandatory' to disable the configuration errors::

		def configure(conf):
			conf.find_program('abc', mandatory=False)

	:param f: method to bind
	:type f: function
	"""
	def fun(*k, **kw):
		mandatory = kw.pop('mandatory', True)
		try:
			return f(*k, **kw)
		except Errors.ConfigurationError:
			if mandatory:
				raise

	fun.__name__ = f.__name__
	setattr(ConfigurationContext, f.__name__, fun)
	setattr(Build.BuildContext, f.__name__, fun)
	return f

@conf
def add_os_flags(self, var, dest=None, dup=False):
	"""
	Import operating system environment values into ``conf.env`` dict::

		def configure(conf):
			conf.add_os_flags('CFLAGS')

	:param var: variable to use
	:type var: string
	:param dest: destination variable, by default the same as var
	:type dest: string
	:param dup: add the same set of flags again
	:type dup: bool
	"""
	try:
		flags = shlex.split(self.environ[var])
	except KeyError:
		return
	if dup or ''.join(flags) not in ''.join(Utils.to_list(self.env[dest or var])):
		self.env.append_value(dest or var, flags)

@conf
def cmd_to_list(self, cmd):
	"""
	Detect if a command is written in pseudo shell like ``ccache g++`` and return a list.

	:param cmd: command
	:type cmd: a string or a list of string
	"""
	if isinstance(cmd, str):
		if os.path.isfile(cmd):
			# do not take any risk
			return [cmd]
		if os.sep == '/':
			return shlex.split(cmd)
		else:
			try:
				return shlex.split(cmd, posix=False)
			except TypeError:
				# Python 2.5 on windows?
				return shlex.split(cmd)
	return cmd

@conf
def check_waf_version(self, mini='1.9.99', maxi='2.1.0', **kw):
	"""
	Raise a Configuration error if the Waf version does not strictly match the given bounds::

		conf.check_waf_version(mini='1.9.99', maxi='2.1.0')

	:type  mini: number, tuple or string
	:param mini: Minimum required version
	:type  maxi: number, tuple or string
	:param maxi: Maximum allowed version
	"""
	self.start_msg('Checking for waf version in %s-%s' % (str(mini), str(maxi)), **kw)
	ver = Context.HEXVERSION
	if Utils.num2ver(mini) > ver:
		self.fatal('waf version should be at least %r (%r found)' % (Utils.num2ver(mini), ver))
	if Utils.num2ver(maxi) < ver:
		self.fatal('waf version should be at most %r (%r found)' % (Utils.num2ver(maxi), ver))
	self.end_msg('ok', **kw)

@conf
def find_file(self, filename, path_list=[]):
	"""
	Find a file in a list of paths

	:param filename: name of the file to search for
	:param path_list: list of directories to search
	:return: the first matching filename; else a configuration exception is raised
	"""
	for n in Utils.to_list(filename):
		for d in Utils.to_list(path_list):
			p = os.path.expanduser(os.path.join(d, n))
			if os.path.exists(p):
				return p
	self.fatal('Could not find %r' % filename)

@conf
def find_program(self, filename, **kw):
	"""
	Search for a program on the operating system

	When var is used, you may set os.environ[var] to help find a specific program version, for example::

		$ CC='ccache gcc' waf configure

	:param path_list: paths to use for searching
	:type param_list: list of string
	:param var: store the result to conf.env[var] where var defaults to filename.upper() if not provided; the result is stored as a list of strings
	:type var: string
	:param value: obtain the program from the value passed exclusively
	:type value: list or string (list is preferred)
	:param exts: list of extensions for the binary (do not add an extension for portability)
	:type exts: list of string
	:param msg: name to display in the log, by default filename is used
	:type msg: string
	:param interpreter: interpreter for the program
	:type interpreter: ConfigSet variable key
	:raises: :py:class:`waflib.Errors.ConfigurationError`
	"""

	exts = kw.get('exts', Utils.is_win32 and '.exe,.com,.bat,.cmd' or ',.sh,.pl,.py')

	environ = kw.get('environ', getattr(self, 'environ', os.environ))

	ret = ''

	filename = Utils.to_list(filename)
	msg = kw.get('msg', ', '.join(filename))

	var = kw.get('var', '')
	if not var:
		var = re.sub(r'\W', '_', filename[0].upper())

	path_list = kw.get('path_list', '')
	if path_list:
		path_list = Utils.to_list(path_list)
	else:
		path_list = environ.get('PATH', '').split(os.pathsep)

	if kw.get('value'):
		# user-provided in command-line options and passed to find_program
		ret = self.cmd_to_list(kw['value'])
	elif environ.get(var):
		# user-provided in the os environment
		ret = self.cmd_to_list(environ[var])
	elif self.env[var]:
		# a default option in the wscript file
		ret = self.cmd_to_list(self.env[var])
	else:
		if not ret:
			ret = self.find_binary(filename, exts.split(','), path_list)
		if not ret and Utils.winreg:
			ret = Utils.get_registry_app_path(Utils.winreg.HKEY_CURRENT_USER, filename)
		if not ret and Utils.winreg:
			ret = Utils.get_registry_app_path(Utils.winreg.HKEY_LOCAL_MACHINE, filename)
		ret = self.cmd_to_list(ret)

	if ret:
		if len(ret) == 1:
			retmsg = ret[0]
		else:
			retmsg = ret
	else:
		retmsg = False

	self.msg('Checking for program %r' % msg, retmsg, **kw)
	if not kw.get('quiet'):
		self.to_log('find program=%r paths=%r var=%r -> %r' % (filename, path_list, var, ret))

	if not ret:
		self.fatal(kw.get('errmsg', '') or 'Could not find the program %r' % filename)

	interpreter = kw.get('interpreter')
	if interpreter is None:
		if not Utils.check_exe(ret[0], env=environ):
			self.fatal('Program %r is not executable' % ret)
		self.env[var] = ret
	else:
		self.env[var] = self.env[interpreter] + ret

	return ret

@conf
def find_binary(self, filenames, exts, paths):
	for f in filenames:
		for ext in exts:
			exe_name = f + ext
			if os.path.isabs(exe_name):
				if os.path.isfile(exe_name) and os.access(exe_name, os.X_OK):
					return exe_name
			else:
				for path in paths:
					x = os.path.expanduser(os.path.join(path, exe_name))
					if os.path.isfile(x) and os.access(x, os.X_OK):
						return x
	return None

@conf
def run_build(self, *k, **kw):
	"""
	Create a temporary build context to execute a build. A temporary reference to that build
	context is kept on self.test_bld for debugging purposes.
	The arguments to this function are passed to a single task generator for that build.
	Only three parameters are mandatory:

	:param features: features to pass to a task generator created in the build
	:type features: list of string
	:param compile_filename: file to create for the compilation (default: *test.c*)
	:type compile_filename: string
	:param code: input file contents
	:type code: string

	Though this function returns *0* by default, the build may bind attribute named *retval* on the
	build context object to return a particular value. See :py:func:`waflib.Tools.c_config.test_exec_fun` for example.

	The temporary builds creates a temporary folder; the name of that folder is calculated
	by hashing input arguments to this function, with the exception of :py:class:`waflib.ConfigSet.ConfigSet`
	objects which are used for both reading and writing values.

	This function also features a cache which is disabled by default; that cache relies
	on the hash value calculated as indicated above::

		def options(opt):
			opt.add_option('--confcache', dest='confcache', default=0,
				action='count', help='Use a configuration cache')

	And execute the configuration with the following command-line::

		$ waf configure --confcache

	"""
	buf = []
	for key in sorted(kw.keys()):
		v = kw[key]
		if isinstance(v, ConfigSet.ConfigSet):
			# values are being written to, so they are excluded from contributing to the hash
			continue
		elif hasattr(v, '__call__'):
			buf.append(Utils.h_fun(v))
		else:
			buf.append(str(v))
	h = Utils.h_list(buf)
	dir = self.bldnode.abspath() + os.sep + (not Utils.is_win32 and '.' or '') + 'conf_check_' + Utils.to_hex(h)

	cachemode = kw.get('confcache', getattr(Options.options, 'confcache', None))

	if not cachemode and os.path.exists(dir):
		shutil.rmtree(dir)

	try:
		os.makedirs(dir)
	except OSError:
		pass

	try:
		os.stat(dir)
	except OSError:
		self.fatal('cannot use the configuration test folder %r' % dir)

	if cachemode == 1:
		try:
			proj = ConfigSet.ConfigSet(os.path.join(dir, 'cache_run_build'))
		except EnvironmentError:
			pass
		else:
			ret = proj['cache_run_build']
			if isinstance(ret, str) and ret.startswith('Test does not build'):
				self.fatal(ret)
			return ret

	bdir = os.path.join(dir, 'testbuild')

	if not os.path.exists(bdir):
		os.makedirs(bdir)

	cls_name = kw.get('run_build_cls') or getattr(self, 'run_build_cls', 'build')
	self.test_bld = bld = Context.create_context(cls_name, top_dir=dir, out_dir=bdir)
	bld.init_dirs()
	bld.progress_bar = 0
	bld.targets = '*'

	bld.logger = self.logger
	bld.all_envs.update(self.all_envs) # not really necessary
	bld.env = kw['env']

	bld.kw = kw
	bld.conf = self
	kw['build_fun'](bld)
	ret = -1
	try:
		try:
			bld.compile()
		except Errors.WafError:
			ret = 'Test does not build: %s' % traceback.format_exc()
			self.fatal(ret)
		else:
			ret = getattr(bld, 'retval', 0)
	finally:
		if cachemode:
			# cache the results each time
			proj = ConfigSet.ConfigSet()
			proj['cache_run_build'] = ret
			proj.store(os.path.join(dir, 'cache_run_build'))
		else:
			shutil.rmtree(dir)
	return ret

@conf
def ret_msg(self, msg, args):
	if isinstance(msg, str):
		return msg
	return msg(args)

@conf
def test(self, *k, **kw):

	if not 'env' in kw:
		kw['env'] = self.env.derive()

	# validate_c for example
	if kw.get('validate'):
		kw['validate'](kw)

	self.start_msg(kw['msg'], **kw)
	ret = None
	try:
		ret = self.run_build(*k, **kw)
	except self.errors.ConfigurationError:
		self.end_msg(kw['errmsg'], 'YELLOW', **kw)
		if Logs.verbose > 1:
			raise
		else:
			self.fatal('The configuration failed')
	else:
		kw['success'] = ret

	if kw.get('post_check'):
		ret = kw['post_check'](kw)

	if ret:
		self.end_msg(kw['errmsg'], 'YELLOW', **kw)
		self.fatal('The configuration failed %r' % ret)
	else:
		self.end_msg(self.ret_msg(kw['okmsg'], kw), **kw)
	return ret

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        #!/usr/bin/env python
# encoding: utf-8
# Thomas Nagy, 2010-2018 (ita)

"""
Classes and functions enabling the command system
"""

import os, re, sys
from waflib import Utils, Errors, Logs
import waflib.Node

if sys.hexversion > 0x3040000:
	import types
	class imp(object):
		new_module = lambda x: types.ModuleType(x)
else:
	import imp

# the following 3 constants are updated on each new release (do not touch)
HEXVERSION=0x2001b00
"""Constant updated on new releases"""

WAFVERSION="2.0.27"
"""Constant updated on new releases"""

WAFREVISION="c3e645e395505cb5faa115172b1fc9abdaeaf146"
"""Git revision when the waf version is updated"""

WAFNAME="waf"
"""Application name displayed on --help"""

ABI = 20
"""Version of the build data cache file format (used in :py:const:`waflib.Context.DBFILE`)"""

DBFILE = '.wafpickle-%s-%d-%d' % (sys.platform, sys.hexversion, ABI)
"""Name of the pickle file for storing the build data"""

APPNAME = 'APPNAME'
"""Default application name (used by ``waf dist``)"""

VERSION = 'VERSION'
"""Default application version (used by ``waf dist``)"""

TOP  = 'top'
"""The variable name for the top-level directory in wscript files"""

OUT  = 'out'
"""The variable name for the output directory in wscript files"""

WSCRIPT_FILE = 'wscript'
"""Name of the waf script files"""

launch_dir = ''
"""Directory from which waf has been called"""
run_dir = ''
"""Location of the wscript file to use as the entry point"""
top_dir = ''
"""Location of the project directory (top), if the project was configured"""
out_dir = ''
"""Location of the build directory (out), if the project was configured"""
waf_dir = ''
"""Directory containing the waf modules"""

default_encoding = Utils.console_encoding()
"""Encoding to use when reading outputs from other processes"""

g_module = None
"""
Module representing the top-level wscript file (see :py:const:`waflib.Context.run_dir`)
"""

STDOUT = 1
STDERR = -1
BOTH   = 0

classes = []
"""
List of :py:class:`waflib.Context.Context` subclasses that can be used as waf commands. The classes
are added automatically by a metaclass.
"""

def create_context(cmd_name, *k, **kw):
	"""
	Returns a new :py:class:`waflib.Context.Context` instance corresponding to the given command.
	Used in particular by :py:func:`waflib.Scripting.run_command`

	:param cmd_name: command name
	:type cmd_name: string
	:param k: arguments to give to the context class initializer
	:type k: list
	:param k: keyword arguments to give to the context class initializer
	:type k: dict
	:return: Context object
	:rtype: :py:class:`waflib.Context.Context`
	"""
	for x in classes:
		if x.cmd == cmd_name:
			return x(*k, **kw)
	ctx = Context(*k, **kw)
	ctx.fun = cmd_name
	return ctx

class store_context(type):
	"""
	Metaclass that registers command classes into the list :py:const:`waflib.Context.classes`
	Context classes must provide an attribute 'cmd' representing the command name, and a function
	attribute 'fun' representing the function name that the command uses.
	"""
	def __init__(cls, name, bases, dct):
		super(store_context, cls).__init__(name, bases, dct)
		name = cls.__name__

		if name in ('ctx', 'Context'):
			return

		try:
			cls.cmd
		except AttributeError:
			raise Errors.WafError('Missing command for the context class %r (cmd)' % name)

		if not getattr(cls, 'fun', None):
			cls.fun = cls.cmd

		classes.insert(0, cls)

ctx = store_context('ctx', (object,), {})
"""Base class for all :py:class:`waflib.Context.Context` classes"""

class Context(ctx):
	"""
	Default context for waf commands, and base class for new command contexts.

	Context objects are passed to top-level functions::

		def foo(ctx):
			print(ctx.__class__.__name__) # waflib.Context.Context

	Subclasses must define the class attributes 'cmd' and 'fun':

	:param cmd: command to execute as in ``waf cmd``
	:type cmd: string
	:param fun: function name to execute when the command is called
	:type fun: string

	.. inheritance-diagram:: waflib.Context.Context waflib.Build.BuildContext waflib.Build.InstallContext waflib.Build.UninstallContext waflib.Build.StepContext waflib.Build.ListContext waflib.Configure.ConfigurationContext waflib.Scripting.Dist waflib.Scripting.DistCheck waflib.Build.CleanContext
	   :top-classes: waflib.Context.Context
	"""

	errors = Errors
	"""
	Shortcut to :py:mod:`waflib.Errors` provided for convenience
	"""

	tools = {}
	"""
	A module cache for wscript files; see :py:meth:`Context.Context.load`
	"""

	def __init__(self, **kw):
		try:
			rd = kw['run_dir']
		except KeyError:
			rd = run_dir

		# binds the context to the nodes in use to avoid a context singleton
		self.node_class = type('Nod3', (waflib.Node.Node,), {})
		self.node_class.__module__ = 'waflib.Node'
		self.node_class.ctx = self

		self.root = self.node_class('', None)
		self.cur_script = None
		self.path = self.root.find_dir(rd)

		self.stack_path = []
		self.exec_dict = {'ctx':self, 'conf':self, 'bld':self, 'opt':self}
		self.logger = None

	def finalize(self):
		"""
		Called to free resources such as logger files
		"""
		try:
			logger = self.logger
		except AttributeError:
			pass
		else:
			Logs.free_logger(logger)
			delattr(self, 'logger')

	def load(self, tool_list, *k, **kw):
		"""
		Loads a Waf tool as a module, and try calling the function named :py:const:`waflib.Context.Context.fun`
		from it.  A ``tooldir`` argument may be provided as a list of module paths.

		:param tool_list: list of Waf tool names to load
		:type tool_list: list of string or space-separated string
		"""
		tools = Utils.to_list(tool_list)
		path = Utils.to_list(kw.get('tooldir', ''))
		with_sys_path = kw.get('with_sys_path', True)

		for t in tools:
			module = load_tool(t, path, with_sys_path=with_sys_path)
			fun = getattr(module, kw.get('name', self.fun), None)
			if fun:
				fun(self)

	def execute(self):
		"""
		Here, it calls the function name in the top-level wscript file. Most subclasses
		redefine this method to provide additional functionality.
		"""
		self.recurse([os.path.dirname(g_module.root_path)])

	def pre_recurse(self, node):
		"""
		Method executed immediately before a folder is read by :py:meth:`waflib.Context.Context.recurse`.
		The current script is bound as a Node object on ``self.cur_script``, and the current path
		is bound to ``self.path``

		:param node: script
		:type node: :py:class:`waflib.Node.Node`
		"""
		self.stack_path.append(self.cur_script)

		self.cur_script = node
		self.path = node.parent

	def post_recurse(self, node):
		"""
		Restores ``self.cur_script`` and ``self.path`` right after :py:meth:`waflib.Context.Context.recurse` terminates.

		:param node: script
		:type node: :py:class:`waflib.Node.Node`
		"""
		self.cur_script = self.stack_path.pop()
		if self.cur_script:
			self.path = self.cur_script.parent

	def recurse(self, dirs, name=None, mandatory=True, once=True, encoding=None):
		"""
		Runs user-provided functions from the supplied list of directories.
		The directories can be either absolute, or relative to the directory
		of the wscript file

		The methods :py:meth:`waflib.Context.Context.pre_recurse` and
		:py:meth:`waflib.Context.Context.post_recurse` are called immediately before
		and after a script has been executed.

		:param dirs: List of directories to visit
		:type dirs: list of string or space-separated string
		:param name: Name of function to invoke from the wscript
		:type  name: string
		:param mandatory: whether sub wscript files are required to exist
		:type  mandatory: bool
		:param once: read the script file once for a particular context
		:type once: bool
		"""
		try:
			cache = self.recurse_cache
		except AttributeError:
			cache = self.recurse_cache = {}

		for d in Utils.to_list(dirs):

			if not os.path.isabs(d):
				# absolute paths only
				d = os.path.join(self.path.abspath(), d)

			WSCRIPT     = os.path.join(d, WSCRIPT_FILE)
			WSCRIPT_FUN = WSCRIPT + '_' + (name or self.fun)

			node = self.root.find_node(WSCRIPT_FUN)
			if node and (not once or node not in cache):
				cache[node] = True
				self.pre_recurse(node)
				try:
					function_code = node.read('r', encoding)
					exec(compile(function_code, node.abspath(), 'exec'), self.exec_dict)
				finally:
					self.post_recurse(node)
			elif not node:
				node = self.root.find_node(WSCRIPT)
				tup = (node, name or self.fun)
				if node and (not once or tup not in cache):
					cache[tup] = True
					self.pre_recurse(node)
					try:
						wscript_module = load_module(node.abspath(), encoding=encoding)
						user_function = getattr(wscript_module, (name or self.fun), None)
						if not user_function:
							if not mandatory:
								continue
							raise Errors.WafError('No function %r defined in %s' % (name or self.fun, node.abspath()))
						user_function(self)
					finally:
						self.post_recurse(node)
				elif not node:
					if not mandatory:
						continue
					try:
						os.listdir(d)
					except OSError:
						raise Errors.WafError('Cannot read the folder %r' % d)
					raise Errors.WafError('No wscript file in directory %s' % d)

	def log_command(self, cmd, kw):
		if Logs.verbose:
			fmt = os.environ.get('WAF_CMD_FORMAT')
			if fmt == 'string':
				if not isinstance(cmd, str):
					cmd = Utils.shell_escape(cmd)
			Logs.debug('runner: %r', cmd)
			Logs.debug('runner_env: kw=%s', kw)

	def exec_command(self, cmd, **kw):
		"""
		Runs an external process and returns the exit status::

			def run(tsk):
				ret = tsk.generator.bld.exec_command('touch foo.txt')
				return ret

		If the context has the attribute 'log', then captures and logs the process stderr/stdout.
		Unlike :py:meth:`waflib.Context.Context.cmd_and_log`, this method does not return the
		stdout/stderr values captured.

		:param cmd: command argument for subprocess.Popen
		:type cmd: string or list
		:param kw: keyword arguments for subprocess.Popen. The parameters input/timeout will be passed to wait/communicate.
		:type kw: dict
		:returns: process exit status
		:rtype: integer
		:raises: :py:class:`waflib.Errors.WafError` if an invalid executable is specified for a non-shell process
		:raises: :py:class:`waflib.Errors.WafError` in case of execution failure
		"""
		subprocess = Utils.subprocess
		kw['shell'] = isinstance(cmd, str)
		self.log_command(cmd, kw)

		if self.logger:
			self.logger.info(cmd)

		if 'stdout' not in kw:
			kw['stdout'] = subprocess.PIPE
		if 'stderr' not in kw:
			kw['stderr'] = subprocess.PIPE

		if Logs.verbose and not kw['shell'] and not Utils.check_exe(cmd[0], env=kw.get('env', os.environ)):
			# This call isn't a shell command, and if the specified exe doesn't exist, check for a relative path being set
			# with cwd and if so assume the caller knows what they're doing and don't pre-emptively fail
			if not (cmd[0][0] == '.' and 'cwd' in kw):
				raise Errors.WafError('Program %s not found!' % cmd[0])

		cargs = {}
		if 'timeout' in kw:
			if sys.hexversion >= 0x3030000:
				cargs['timeout'] = kw['timeout']
				if not 'start_new_session' in kw:
					kw['start_new_session'] = True
			del kw['timeout']
		if 'input' in kw:
			if kw['input']:
				cargs['input'] = kw['input']
				kw['stdin'] = subprocess.PIPE
			del kw['input']

		if 'cwd' in kw:
			if not isinstance(kw['cwd'], str):
				kw['cwd'] = kw['cwd'].abspath()

		encoding = kw.pop('decode_as', default_encoding)

		try:
			ret, out, err = Utils.run_process(cmd, kw, cargs)
		except Exception as e:
			raise Errors.WafError('Execution failure: %s' % str(e), ex=e)

		if out:
			if not isinstance(out, str):
				out = out.decode(encoding, errors='replace')
			if self.logger:
				self.logger.debug('out: %s', out)
			else:
				Logs.info(out, extra={'stream':sys.stdout, 'c1': ''})
		if err:
			if not isinstance(err, str):
				err = err.decode(encoding, errors='replace')
			if self.logger:
				self.logger.error('err: %s' % err)
			else:
				Logs.info(err, extra={'stream':sys.stderr, 'c1': ''})

		return ret

	def cmd_and_log(self, cmd, **kw):
		"""
		Executes a process and returns stdout/stderr if the execution is successful.
		An exception is thrown when the exit status is non-0. In that case, both stderr and stdout
		will be bound to the WafError object (configuration tests)::

			def configure(conf):
				out = conf.cmd_and_log(['echo', 'hello'], output=waflib.Context.STDOUT, quiet=waflib.Context.BOTH)
				(out, err) = conf.cmd_and_log(['echo', 'hello'], output=waflib.Context.BOTH)
				(out, err) = conf.cmd_and_log(cmd, input='\\n'.encode(), output=waflib.Context.STDOUT)
				try:
					conf.cmd_and_log(['which', 'someapp'], output=waflib.Context.BOTH)
				except Errors.WafError as e:
					print(e.stdout, e.stderr)

		:param cmd: args for subprocess.Popen
		:type cmd: list or string
		:param kw: keyword arguments for subprocess.Popen. The parameters input/timeout will be passed to wait/communicate.
		:type kw: dict
		:returns: a tuple containing the contents of stdout and stderr
		:rtype: string
		:raises: :py:class:`waflib.Errors.WafError` if an invalid executable is specified for a non-shell process
		:raises: :py:class:`waflib.Errors.WafError` in case of execution failure; stdout/stderr/returncode are bound to the exception object
		"""
		subprocess = Utils.subprocess
		kw['shell'] = isinstance(cmd, str)
		self.log_command(cmd, kw)

		quiet = kw.pop('quiet', None)
		to_ret = kw.pop('output', STDOUT)

		if Logs.verbose and not kw['shell'] and not Utils.check_exe(cmd[0], env=kw.get('env', os.environ)):
			# This call isn't a shell command, and if the specified exe doesn't exist, check for a relative path being set
			# with cwd and if so assume the caller knows what they're doing and don't pre-emptively fail
			if not (cmd[0][0] == '.' and 'cwd' in kw):
				raise Errors.WafError('Program %s not found!' % cmd[0])

		kw['stdout'] = kw['stderr'] = subprocess.PIPE
		if quiet is None:
			self.to_log(cmd)

		cargs = {}
		if 'timeout' in kw:
			if sys.hexversion >= 0x3030000:
				cargs['timeout'] = kw['timeout']
				if not 'start_new_session' in kw:
					kw['start_new_session'] = True
			del kw['timeout']
		if 'input' in kw:
			if kw['input']:
				cargs['input'] = kw['input']
				kw['stdin'] = subprocess.PIPE
			del kw['input']

		if 'cwd' in kw:
			if not isinstance(kw['cwd'], str):
				kw['cwd'] = kw['cwd'].abspath()

		encoding = kw.pop('decode_as', default_encoding)

		try:
			ret, out, err = Utils.run_process(cmd, kw, cargs)
		except Exception as e:
			raise Errors.WafError('Execution failure: %s' % str(e), ex=e)

		if not isinstance(out, str):
			out = out.decode(encoding, errors='replace')
		if not isinstance(err, str):
			err = err.decode(encoding, errors='replace')

		if out and quiet != STDOUT and quiet != BOTH:
			self.to_log('out: %s' % out)
		if err and quiet != STDERR and quiet != BOTH:
			self.to_log('err: %s' % err)

		if ret:
			e = Errors.WafError('Command %r returned %r' % (cmd, ret))
			e.returncode = ret
			e.stderr = err
			e.stdout = out
			raise e

		if to_ret == BOTH:
			return (out, err)
		elif to_ret == STDERR:
			return err
		return out

	def fatal(self, msg, ex=None):
		"""
		Prints an error message in red and stops command execution; this is
		usually used in the configuration section::

			def configure(conf):
				conf.fatal('a requirement is missing')

		:param msg: message to display
		:type msg: string
		:param ex: optional exception object
		:type ex: exception
		:raises: :py:class:`waflib.Errors.ConfigurationError`
		"""
		if self.logger:
			self.logger.info('from %s: %s' % (self.path.abspath(), msg))
		try:
			logfile = self.logger.handlers[0].baseFilename
		except AttributeError:
			pass
		else:
			if os.environ.get('WAF_PRINT_FAILURE_LOG'):
				# see #1930
				msg = 'Log from (%s):\n%s\n' % (logfile, Utils.readf(logfile))
			else:
				msg = '%s\n(complete log in %s)' % (msg, logfile)
		raise self.errors.ConfigurationError(msg, ex=ex)

	def to_log(self, msg):
		"""
		Logs information to the logger (if present), or to stderr.
		Empty messages are not printed::

			def build(bld):
				bld.to_log('starting the build')

		Provide a logger on the context class or override this method if necessary.

		:param msg: message
		:type msg: string
		"""
		if not msg:
			return
		if self.logger:
			self.logger.info(msg)
		else:
			sys.stderr.write(str(msg))
			sys.stderr.flush()


	def msg(self, *k, **kw):
		"""
		Prints a configuration message of the form ``msg: result``.
		The second part of the message will be in colors. The output
		can be disabled easily by setting ``in_msg`` to a positive value::

			def configure(conf):
				self.in_msg = 1
				conf.msg('Checking for library foo', 'ok')
				# no output

		:param msg: message to display to the user
		:type msg: string
		:param result: result to display
		:type result: string or boolean
		:param color: color to use, see :py:const:`waflib.Logs.colors_lst`
		:type color: string
		"""
		try:
			msg = kw['msg']
		except KeyError:
			msg = k[0]

		self.start_msg(msg, **kw)

		try:
			result = kw['result']
		except KeyError:
			result = k[1]

		color = kw.get('color')
		if not isinstance(color, str):
			color = result and 'GREEN' or 'YELLOW'

		self.end_msg(result, color, **kw)

	def start_msg(self, *k, **kw):
		"""
		Prints the beginning of a 'Checking for xxx' message. See :py:meth:`waflib.Context.Context.msg`
		"""
		if kw.get('quiet'):
			return

		msg = kw.get('msg') or k[0]
		try:
			if self.in_msg:
				self.in_msg += 1
				return
		except AttributeError:
			self.in_msg = 0
		self.in_msg += 1

		try:
			self.line_just = max(self.line_just, len(msg))
		except AttributeError:
			self.line_just = max(40, len(msg))
		for x in (self.line_just * '-', msg):
			self.to_log(x)
		Logs.pprint('NORMAL', "%s :" % msg.ljust(self.line_just), sep='')

	def end_msg(self, *k, **kw):
		"""Prints the end of a 'Checking for' message. See :py:meth:`waflib.Context.Context.msg`"""
		if kw.get('quiet'):
			return
		self.in_msg -= 1
		if self.in_msg:
			return

		result = kw.get('result') or k[0]

		defcolor = 'GREEN'
		if result is True:
			msg = 'ok'
		elif not result:
			msg = 'not found'
			defcolor = 'YELLOW'
		else:
			msg = str(result)

		self.to_log(msg)
		try:
			color = kw['color']
		except KeyError:
			if len(k) > 1 and k[1] in Logs.colors_lst:
				# compatibility waf 1.7
				color = k[1]
			else:
				color = defcolor
		Logs.pprint(color, msg)

	def load_special_tools(self, var, ban=[]):
		"""
		Loads third-party extensions modules for certain programming languages
		by trying to list certain files in the extras/ directory. This method
		is typically called once for a programming language group, see for
		example :py:mod:`waflib.Tools.compiler_c`

		:param var: glob expression, for example 'cxx\\_\\*.py'
		:type var: string
		:param ban: list of exact file names to exclude
		:type ban: list of string
		"""
		if os.path.isdir(waf_dir):
			lst = self.root.find_node(waf_dir).find_node('waflib/extras').ant_glob(var)
			for x in lst:
				if not x.name in ban:
					load_tool(x.name.replace('.py', ''))
		else:
			from zipfile import PyZipFile
			waflibs = PyZipFile(waf_dir)
			lst = waflibs.namelist()
			for x in lst:
				if not re.match('waflib/extras/%s' % var.replace('*', '.*'), var):
					continue
				f = os.path.basename(x)
				doban = False
				for b in ban:
					r = b.replace('*', '.*')
					if re.match(r, f):
						doban = True
				if not doban:
					f = f.replace('.py', '')
					load_tool(f)

cache_modules = {}
"""
Dictionary holding already loaded modules (wscript), indexed by their absolute path.
The modules are added automatically by :py:func:`waflib.Context.load_module`
"""

def load_module(path, encoding=None):
	"""
	Loads a wscript file as a python module. This method caches results in :py:attr:`waflib.Context.cache_modules`

	:param path: file path
	:type path: string
	:return: Loaded Python module
	:rtype: module
	"""
	try:
		return cache_modules[path]
	except KeyError:
		pass

	module = imp.new_module(WSCRIPT_FILE)
	try:
		code = Utils.readf(path, m='r', encoding=encoding)
	except EnvironmentError:
		raise Errors.WafError('Could not read the file %r' % path)

	module_dir = os.path.dirname(path)
	sys.path.insert(0, module_dir)
	try:
		exec(compile(code, path, 'exec'), module.__dict__)
	finally:
		sys.path.remove(module_dir)

	cache_modules[path] = module
	return module

def load_tool(tool, tooldir=None, ctx=None, with_sys_path=True):
	"""
	Imports a Waf tool as a python module, and stores it in the dict :py:const:`waflib.Context.Context.tools`

	:type  tool: string
	:param tool: Name of the tool
	:type  tooldir: list
	:param tooldir: List of directories to search for the tool module
	:type  with_sys_path: boolean
	:param with_sys_path: whether or not to search the regular sys.path, besides waf_dir and potentially given tooldirs
	"""
	if tool == 'java':
		tool = 'javaw' # jython
	else:
		tool = tool.replace('++', 'xx')

	if not with_sys_path:
		back_path = sys.path
		sys.path = []
	try:
		if tooldir:
			assert isinstance(tooldir, list)
			sys.path = tooldir + sys.path
			try:
				__import__(tool)
			except ImportError as e:
				e.waf_sys_path = list(sys.path)
				raise
			finally:
				for d in tooldir:
					sys.path.remove(d)
			ret = sys.modules[tool]
			Context.tools[tool] = ret
			return ret
		else:
			if not with_sys_path:
				sys.path.insert(0, waf_dir)
			try:
				for x in ('waflib.Tools.%s', 'waflib.extras.%s', 'waflib.%s', '%s'):
					try:
						__import__(x % tool)
						break
					except ImportError:
						x = None
				else: # raise an exception
					__import__(tool)
			except ImportError as e:
				e.waf_sys_path = list(sys.path)
				raise
			finally:
				if not with_sys_path:
					sys.path.remove(waf_dir)
			ret = sys.modules[x % tool]
			Context.tools[tool] = ret
			return ret
	finally:
		if not with_sys_path:
			sys.path += back_path

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            #!/usr/bin/env python
# encoding: utf-8
# Thomas Nagy, 2010-2018 (ita)

"""
Exceptions used in the Waf code
"""

import traceback, sys

class WafError(Exception):
	"""Base class for all Waf errors"""
	def __init__(self, msg='', ex=None):
		"""
		:param msg: error message
		:type msg: string
		:param ex: exception causing this error (optional)
		:type ex: exception
		"""
		Exception.__init__(self)
		self.msg = msg
		assert not isinstance(msg, Exception)

		self.stack = []
		if ex:
			if not msg:
				self.msg = str(ex)
			if isinstance(ex, WafError):
				self.stack = ex.stack
			else:
				self.stack = traceback.extract_tb(sys.exc_info()[2])
		self.stack += traceback.extract_stack()[:-1]
		self.verbose_msg = ''.join(traceback.format_list(self.stack))

	def __str__(self):
		return str(self.msg)

class BuildError(WafError):
	"""Error raised during the build and install phases"""
	def __init__(self, error_tasks=[]):
		"""
		:param error_tasks: tasks that could not complete normally
		:type error_tasks: list of task objects
		"""
		self.tasks = error_tasks
		WafError.__init__(self, self.format_error())

	def format_error(self):
		"""Formats the error messages from the tasks that failed"""
		lst = ['Build failed']
		for tsk in self.tasks:
			txt = tsk.format_error()
			if txt:
				lst.append(txt)
		return '\n'.join(lst)

class ConfigurationError(WafError):
	"""Configuration exception raised in particular by :py:meth:`waflib.Context.Context.fatal`"""
	pass

class TaskRescan(WafError):
	"""Task-specific exception type signalling required signature recalculations"""
	pass

class TaskNotReady(WafError):
	"""Task-specific exception type signalling that task signatures cannot be computed"""
	pass

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               #!/usr/bin/env python
# encoding: utf-8
# Thomas Nagy, 2005-2018 (ita)

"""
logging, colors, terminal width and pretty-print
"""

import os, re, traceback, sys
from waflib import Utils, ansiterm

if not os.environ.get('NOSYNC', False):
	# synchronized output is nearly mandatory to prevent garbled output
	if sys.stdout.isatty() and id(sys.stdout) == id(sys.__stdout__):
		sys.stdout = ansiterm.AnsiTerm(sys.stdout)
	if sys.stderr.isatty() and id(sys.stderr) == id(sys.__stderr__):
		sys.stderr = ansiterm.AnsiTerm(sys.stderr)

# import the logging module after since it holds a reference on sys.stderr
# in case someone uses the root logger
import logging

LOG_FORMAT = os.environ.get('WAF_LOG_FORMAT', '%(asctime)s %(c1)s%(zone)s%(c2)s %(message)s')
HOUR_FORMAT = os.environ.get('WAF_HOUR_FORMAT', '%H:%M:%S')

zones = []
"""
See :py:class:`waflib.Logs.log_filter`
"""

verbose = 0
"""
Global verbosity level, see :py:func:`waflib.Logs.debug` and :py:func:`waflib.Logs.error`
"""

colors_lst = {
'USE' : True,
'BOLD'  :'\x1b[01;1m',
'RED'   :'\x1b[01;31m',
'GREEN' :'\x1b[32m',
'YELLOW':'\x1b[33m',
'PINK'  :'\x1b[35m',
'BLUE'  :'\x1b[01;34m',
'CYAN'  :'\x1b[36m',
'GREY'  :'\x1b[37m',
'NORMAL':'\x1b[0m',
'cursor_on'  :'\x1b[?25h',
'cursor_off' :'\x1b[?25l',
}

indicator = '\r\x1b[K%s%s%s'

try:
	unicode
except NameError:
	unicode = None

def enable_colors(use):
	"""
	If *1* is given, then the system will perform a few verifications
	before enabling colors, such as checking whether the interpreter
	is running in a terminal. A value of zero will disable colors,
	and a value above *1* will force colors.

	:param use: whether to enable colors or not
	:type use: integer
	"""
	if use == 1:
		if not (sys.stderr.isatty() or sys.stdout.isatty()):
			use = 0
		if Utils.is_win32 and os.name != 'java':
			term = os.environ.get('TERM', '') # has ansiterm
		else:
			term = os.environ.get('TERM', 'dumb')

		if term in ('dumb', 'emacs'):
			use = 0

	if use >= 1:
		os.environ['TERM'] = 'vt100'

	colors_lst['USE'] = use

# If console packages are available, replace the dummy function with a real
# implementation
try:
	get_term_cols = ansiterm.get_term_cols
except AttributeError:
	def get_term_cols():
		return 80

get_term_cols.__doc__ = """
	Returns the console width in characters.

	:return: the number of characters per line
	:rtype: int
	"""

def get_color(cl):
	"""
	Returns the ansi sequence corresponding to the given color name.
	An empty string is returned when coloring is globally disabled.

	:param cl: color name in capital letters
	:type cl: string
	"""
	if colors_lst['USE']:
		return colors_lst.get(cl, '')
	return ''

class color_dict(object):
	"""attribute-based color access, eg: colors.PINK"""
	def __getattr__(self, a):
		return get_color(a)
	def __call__(self, a):
		return get_color(a)

colors = color_dict()

re_log = re.compile(r'(\w+): (.*)', re.M)
class log_filter(logging.Filter):
	"""
	Waf logs are of the form 'name: message', and can be filtered by 'waf --zones=name'.
	For example, the following::

		from waflib import Logs
		Logs.debug('test: here is a message')

	Will be displayed only when executing::

		$ waf --zones=test
	"""
	def __init__(self, name=''):
		logging.Filter.__init__(self, name)

	def filter(self, rec):
		"""
		Filters log records by zone and by logging level

		:param rec: log entry
		"""
		rec.zone = rec.module
		if rec.levelno >= logging.INFO:
			return True

		m = re_log.match(rec.msg)
		if m:
			rec.zone = m.group(1)
			rec.msg = m.group(2)

		if zones:
			return getattr(rec, 'zone', '') in zones or '*' in zones
		elif not verbose > 2:
			return False
		return True

class log_handler(logging.StreamHandler):
	"""Dispatches messages to stderr/stdout depending on the severity level"""
	def emit(self, record):
		"""
		Delegates the functionality to :py:meth:`waflib.Log.log_handler.emit_override`
		"""
		# default implementation
		try:
			try:
				self.stream = record.stream
			except AttributeError:
				if record.levelno >= logging.WARNING:
					record.stream = self.stream = sys.stderr
				else:
					record.stream = self.stream = sys.stdout
			self.emit_override(record)
			self.flush()
		except (KeyboardInterrupt, SystemExit):
			raise
		except: # from the python library -_-
			self.handleError(record)

	def emit_override(self, record, **kw):
		"""
		Writes the log record to the desired stream (stderr/stdout)
		"""
		self.terminator = getattr(record, 'terminator', '\n')
		stream = self.stream
		if unicode:
			# python2
			msg = self.formatter.format(record)
			fs = '%s' + self.terminator
			try:
				if (isinstance(msg, unicode) and getattr(stream, 'encoding', None)):
					fs = fs.decode(stream.encoding)
					try:
						stream.write(fs % msg)
					except UnicodeEncodeError:
						stream.write((fs % msg).encode(stream.encoding))
				else:
					stream.write(fs % msg)
			except UnicodeError:
				stream.write((fs % msg).encode('utf-8'))
		else:
			logging.StreamHandler.emit(self, record)

class formatter(logging.Formatter):
	"""Simple log formatter which handles colors"""
	def __init__(self):
		logging.Formatter.__init__(self, LOG_FORMAT, HOUR_FORMAT)

	def format(self, rec):
		"""
		Formats records and adds colors as needed. The records do not get
		a leading hour format if the logging level is above *INFO*.
		"""
		try:
			msg = rec.msg.decode('utf-8')
		except Exception:
			msg = rec.msg

		use = colors_lst['USE']
		if (use == 1 and rec.stream.isatty()) or use == 2:

			c1 = getattr(rec, 'c1', None)
			if c1 is None:
				c1 = ''
				if rec.levelno >= logging.ERROR:
					c1 = colors.RED
				elif rec.levelno >= logging.WARNING:
					c1 = colors.YELLOW
				elif rec.levelno >= logging.INFO:
					c1 = colors.GREEN
			c2 = getattr(rec, 'c2', colors.NORMAL)
			msg = '%s%s%s' % (c1, msg, c2)
		else:
			# remove single \r that make long lines in text files
			# and other terminal commands
			msg = re.sub(r'\r(?!\n)|\x1B\[(K|.*?(m|h|l))', '', msg)

		if rec.levelno >= logging.INFO:
			# the goal of this is to format without the leading "Logs, hour" prefix
			if rec.args:
				try:
					return msg % rec.args
				except UnicodeDecodeError:
					return msg.encode('utf-8') % rec.args
			return msg

		rec.msg = msg
		rec.c1 = colors.PINK
		rec.c2 = colors.NORMAL
		return logging.Formatter.format(self, rec)

log = None
"""global logger for Logs.debug, Logs.error, etc"""

def debug(*k, **kw):
	"""
	Wraps logging.debug and discards messages if the verbosity level :py:attr:`waflib.Logs.verbose` ≤ 0
	"""
	if verbose:
		k = list(k)
		k[0] = k[0].replace('\n', ' ')
		log.debug(*k, **kw)

def error(*k, **kw):
	"""
	Wrap logging.errors, adds the stack trace when the verbosity level :py:attr:`waflib.Logs.verbose` ≥ 2
	"""
	log.error(*k, **kw)
	if verbose > 2:
		st = traceback.extract_stack()
		if st:
			st = st[:-1]
			buf = []
			for filename, lineno, name, line in st:
				buf.append('  File %r, line %d, in %s' % (filename, lineno, name))
				if line:
					buf.append('	%s' % line.strip())
			if buf:
				log.error('\n'.join(buf))

def warn(*k, **kw):
	"""
	Wraps logging.warning
	"""
	log.warning(*k, **kw)

def info(*k, **kw):
	"""
	Wraps logging.info
	"""
	log.info(*k, **kw)

def init_log():
	"""
	Initializes the logger :py:attr:`waflib.Logs.log`
	"""
	global log
	log = logging.getLogger('waflib')
	log.handlers = []
	log.filters = []
	hdlr = log_handler()
	hdlr.setFormatter(formatter())
	log.addHandler(hdlr)
	log.addFilter(log_filter())
	log.setLevel(logging.DEBUG)

def make_logger(path, name):
	"""
	Creates a simple logger, which is often used to redirect the context command output::

		from waflib import Logs
		bld.logger = Logs.make_logger('test.log', 'build')
		bld.check(header_name='sadlib.h', features='cxx cprogram', mandatory=False)

		# have the file closed immediately
		Logs.free_logger(bld.logger)

		# stop logging
		bld.logger = None

	The method finalize() of the command will try to free the logger, if any

	:param path: file name to write the log output to
	:type path: string
	:param name: logger name (loggers are reused)
	:type name: string
	"""
	logger = logging.getLogger(name)
	if sys.hexversion > 0x3000000:
		encoding = sys.stdout.encoding
	else:
		encoding = None
	hdlr = logging.FileHandler(path, 'w', encoding=encoding)
	formatter = logging.Formatter('%(message)s')
	hdlr.setFormatter(formatter)
	logger.addHandler(hdlr)
	logger.setLevel(logging.DEBUG)
	return logger

def make_mem_logger(name, to_log, size=8192):
	"""
	Creates a memory logger to avoid writing concurrently to the main logger
	"""
	from logging.handlers import MemoryHandler
	logger = logging.getLogger(name)
	hdlr = MemoryHandler(size, target=to_log)
	formatter = logging.Formatter('%(message)s')
	hdlr.setFormatter(formatter)
	logger.addHandler(hdlr)
	logger.memhandler = hdlr
	logger.setLevel(logging.DEBUG)
	return logger

def free_logger(logger):
	"""
	Frees the resources held by the loggers created through make_logger or make_mem_logger.
	This is used for file cleanup and for handler removal (logger objects are re-used).
	"""
	try:
		for x in logger.handlers:
			x.close()
			logger.removeHandler(x)
	except Exception:
		pass

def pprint(col, msg, label='', sep='\n'):
	"""
	Prints messages in color immediately on stderr::

		from waflib import Logs
		Logs.pprint('RED', 'Something bad just happened')

	:param col: color name to use in :py:const:`Logs.colors_lst`
	:type col: string
	:param msg: message to display
	:type msg: string or a value that can be printed by %s
	:param label: a message to add after the colored output
	:type label: string
	:param sep: a string to append at the end (line separator)
	:type sep: string
	"""
	info('%s%s%s %s', colors(col), msg, colors.NORMAL, label, extra={'terminator':sep})

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     #!/usr/bin/env python
# encoding: utf-8
# Thomas Nagy, 2005-2018 (ita)

"""
Node: filesystem structure

#. Each file/folder is represented by exactly one node.

#. Some potential class properties are stored on :py:class:`waflib.Build.BuildContext` : nodes to depend on, etc.
   Unused class members can increase the `.wafpickle` file size sensibly.

#. Node objects should never be created directly, use
   the methods :py:func:`Node.make_node` or :py:func:`Node.find_node` for the low-level operations

#. The methods :py:func:`Node.find_resource`, :py:func:`Node.find_dir` :py:func:`Node.find_or_declare` must be
   used when a build context is present

#. Each instance of :py:class:`waflib.Context.Context` has a unique :py:class:`Node` subclass required for serialization.
   (:py:class:`waflib.Node.Nod3`, see the :py:class:`waflib.Context.Context` initializer). A reference to the context
   owning a node is held as *self.ctx*
"""

import os, re, sys, shutil
from waflib import Utils, Errors

exclude_regs = '''
**/*~
**/#*#
**/.#*
**/%*%
**/._*
**/*.swp
**/CVS
**/CVS/**
**/.cvsignore
**/SCCS
**/SCCS/**
**/vssver.scc
**/.svn
**/.svn/**
**/BitKeeper
**/.git
**/.git/**
**/.gitignore
**/.bzr
**/.bzrignore
**/.bzr/**
**/.hg
**/.hg/**
**/_MTN
**/_MTN/**
**/.arch-ids
**/{arch}
**/_darcs
**/_darcs/**
**/.intlcache
**/.DS_Store'''
"""
Ant patterns for files and folders to exclude while doing the
recursive traversal in :py:meth:`waflib.Node.Node.ant_glob`
"""

def ant_matcher(s, ignorecase):
	reflags = re.I if ignorecase else 0
	ret = []
	for x in Utils.to_list(s):
		x = x.replace('\\', '/').replace('//', '/')
		if x.endswith('/'):
			x += '**'
		accu = []
		for k in x.split('/'):
			if k == '**':
				accu.append(k)
			else:
				k = k.replace('.', '[.]').replace('*', '.*').replace('?', '.').replace('+', '\\+')
				k = '^%s$' % k
				try:
					exp = re.compile(k, flags=reflags)
				except Exception as e:
					raise Errors.WafError('Invalid pattern: %s' % k, e)
				else:
					accu.append(exp)
		ret.append(accu)
	return ret

def ant_sub_filter(name, nn):
	ret = []
	for lst in nn:
		if not lst:
			pass
		elif lst[0] == '**':
			ret.append(lst)
			if len(lst) > 1:
				if lst[1].match(name):
					ret.append(lst[2:])
			else:
				ret.append([])
		elif lst[0].match(name):
			ret.append(lst[1:])
	return ret

def ant_sub_matcher(name, pats):
	nacc = ant_sub_filter(name, pats[0])
	nrej = ant_sub_filter(name, pats[1])
	if [] in nrej:
		nacc = []
	return [nacc, nrej]

class Node(object):
	"""
	This class is organized in two parts:

	* The basic methods meant for filesystem access (compute paths, create folders, etc)
	* The methods bound to a :py:class:`waflib.Build.BuildContext` (require ``bld.srcnode`` and ``bld.bldnode``)
	"""

	dict_class = dict
	"""
	Subclasses can provide a dict class to enable case insensitivity for example.
	"""

	__slots__ = ('name', 'parent', 'children', 'cache_abspath', 'cache_isdir')
	def __init__(self, name, parent):
		"""
		.. note:: Use :py:func:`Node.make_node` or :py:func:`Node.find_node` instead of calling this constructor
		"""
		self.name = name
		self.parent = parent
		if parent:
			if name in parent.children:
				raise Errors.WafError('node %s exists in the parent files %r already' % (name, parent))
			parent.children[name] = self

	def __setstate__(self, data):
		"Deserializes node information, used for persistence"
		self.name = data[0]
		self.parent = data[1]
		if data[2] is not None:
			# Issue 1480
			self.children = self.dict_class(data[2])

	def __getstate__(self):
		"Serializes node information, used for persistence"
		return (self.name, self.parent, getattr(self, 'children', None))

	def __str__(self):
		"""
		String representation (abspath), for debugging purposes

		:rtype: string
		"""
		return self.abspath()

	def __repr__(self):
		"""
		String representation (abspath), for debugging purposes

		:rtype: string
		"""
		return self.abspath()

	def __copy__(self):
		"""
		Provided to prevent nodes from being copied

		:raises: :py:class:`waflib.Errors.WafError`
		"""
		raise Errors.WafError('nodes are not supposed to be copied')

	def read(self, flags='r', encoding='latin-1'):
		"""
		Reads and returns the contents of the file represented by this node, see :py:func:`waflib.Utils.readf`::

			def build(bld):
				bld.path.find_node('wscript').read()

		:param flags: Open mode
		:type  flags: string
		:param encoding: encoding value for Python3
		:type encoding: string
		:rtype: string or bytes
		:return: File contents
		"""
		return Utils.readf(self.abspath(), flags, encoding)

	def write(self, data, flags='w', encoding='latin-1'):
		"""
		Writes data to the file represented by this node, see :py:func:`waflib.Utils.writef`::

			def build(bld):
				bld.path.make_node('foo.txt').write('Hello, world!')

		:param data: data to write
		:type  data: string
		:param flags: Write mode
		:type  flags: string
		:param encoding: encoding value for Python3
		:type encoding: string
		"""
		Utils.writef(self.abspath(), data, flags, encoding)

	def read_json(self, convert=True, encoding='utf-8'):
		"""
		Reads and parses the contents of this node as JSON (Python ≥ 2.6)::

			def build(bld):
				bld.path.find_node('abc.json').read_json()

		Note that this by default automatically decodes unicode strings on Python2, unlike what the Python JSON module does.

		:type  convert: boolean
		:param convert: Prevents decoding of unicode strings on Python2
		:type  encoding: string
		:param encoding: The encoding of the file to read. This default to UTF8 as per the JSON standard
		:rtype: object
		:return: Parsed file contents
		"""
		import json # Python 2.6 and up
		object_pairs_hook = None
		if convert and sys.hexversion < 0x3000000:
			try:
				_type = unicode
			except NameError:
				_type = str

			def convert(value):
				if isinstance(value, list):
					return [convert(element) for element in value]
				elif isinstance(value, _type):
					return str(value)
				else:
					return value

			def object_pairs(pairs):
				return dict((str(pair[0]), convert(pair[1])) for pair in pairs)

			object_pairs_hook = object_pairs

		return json.loads(self.read(encoding=encoding), object_pairs_hook=object_pairs_hook)

	def write_json(self, data, pretty=True):
		"""
		Writes a python object as JSON to disk (Python ≥ 2.6) as UTF-8 data (JSON standard)::

			def build(bld):
				bld.path.find_node('xyz.json').write_json(199)

		:type  data: object
		:param data: The data to write to disk
		:type  pretty: boolean
		:param pretty: Determines if the JSON will be nicely space separated
		"""
		import json # Python 2.6 and up
		indent = 2
		separators = (',', ': ')
		sort_keys = pretty
		newline = os.linesep
		if not pretty:
			indent = None
			separators = (',', ':')
			newline = ''
		output = json.dumps(data, indent=indent, separators=separators, sort_keys=sort_keys) + newline
		self.write(output, encoding='utf-8')

	def exists(self):
		"""
		Returns whether the Node is present on the filesystem

		:rtype: bool
		"""
		return os.path.exists(self.abspath())

	def isdir(self):
		"""
		Returns whether the Node represents a folder

		:rtype: bool
		"""
		return os.path.isdir(self.abspath())

	def chmod(self, val):
		"""
		Changes the file/dir permissions::

			def build(bld):
				bld.path.chmod(493) # 0755
		"""
		os.chmod(self.abspath(), val)

	def delete(self, evict=True):
		"""
		Removes the file/folder from the filesystem (equivalent to `rm -rf`), and remove this object from the Node tree.
		Do not use this object after calling this method.
		"""
		try:
			try:
				if os.path.isdir(self.abspath()):
					shutil.rmtree(self.abspath())
				else:
					os.remove(self.abspath())
			except OSError:
				if os.path.exists(self.abspath()):
					raise
		finally:
			if evict:
				self.evict()

	def evict(self):
		"""
		Removes this node from the Node tree
		"""
		del self.parent.children[self.name]

	def suffix(self):
		"""
		Returns the file rightmost extension, for example `a.b.c.d → .d`

		:rtype: string
		"""
		k = max(0, self.name.rfind('.'))
		return self.name[k:]

	def height(self):
		"""
		Returns the depth in the folder hierarchy from the filesystem root or from all the file drives

		:returns: filesystem depth
		:rtype: integer
		"""
		d = self
		val = -1
		while d:
			d = d.parent
			val += 1
		return val

	def listdir(self):
		"""
		Lists the folder contents

		:returns: list of file/folder names ordered alphabetically
		:rtype: list of string
		"""
		lst = Utils.listdir(self.abspath())
		lst.sort()
		return lst

	def mkdir(self):
		"""
		Creates a folder represented by this node. Intermediate folders are created as needed.

		:raises: :py:class:`waflib.Errors.WafError` when the folder is missing
		"""
		if self.isdir():
			return

		try:
			self.parent.mkdir()
		except OSError:
			pass

		if self.name:
			try:
				os.makedirs(self.abspath())
			except OSError:
				pass

			if not self.isdir():
				raise Errors.WafError('Could not create the directory %r' % self)

			try:
				self.children
			except AttributeError:
				self.children = self.dict_class()

	def find_node(self, lst):
		"""
		Finds a node on the file system (files or folders), and creates the corresponding Node objects if it exists

		:param lst: relative path
		:type lst: string or list of string
		:returns: The corresponding Node object or None if no entry was found on the filesystem
		:rtype: :py:class:´waflib.Node.Node´
		"""

		if isinstance(lst, str):
			lst = [x for x in Utils.split_path(lst) if x and x != '.']

		if lst and lst[0].startswith('\\\\') and not self.parent:
			node = self.ctx.root.make_node(lst[0])
			node.cache_isdir = True
			return node.find_node(lst[1:])

		cur = self
		for x in lst:
			if x == '..':
				cur = cur.parent or cur
				continue

			try:
				ch = cur.children
			except AttributeError:
				cur.children = self.dict_class()
			else:
				try:
					cur = ch[x]
					continue
				except KeyError:
					pass

			# optimistic: create the node first then look if it was correct to do so
			cur = self.__class__(x, cur)
			if not cur.exists():
				cur.evict()
				return None

		if not cur.exists():
			cur.evict()
			return None

		return cur

	def make_node(self, lst):
		"""
		Returns or creates a Node object corresponding to the input path without considering the filesystem.

		:param lst: relative path
		:type lst: string or list of string
		:rtype: :py:class:´waflib.Node.Node´
		"""
		if isinstance(lst, str):
			lst = [x for x in Utils.split_path(lst) if x and x != '.']

		cur = self
		for x in lst:
			if x == '..':
				cur = cur.parent or cur
				continue

			try:
				cur = cur.children[x]
			except AttributeError:
				cur.children = self.dict_class()
			except KeyError:
				pass
			else:
				continue
			cur = self.__class__(x, cur)
		return cur

	def search_node(self, lst):
		"""
		Returns a Node previously defined in the data structure. The filesystem is not considered.

		:param lst: relative path
		:type lst: string or list of string
		:rtype: :py:class:´waflib.Node.Node´ or None if there is no entry in the Node datastructure
		"""
		if isinstance(lst, str):
			lst = [x for x in Utils.split_path(lst) if x and x != '.']

		cur = self
		for x in lst:
			if x == '..':
				cur = cur.parent or cur
			else:
				try:
					cur = cur.children[x]
				except (AttributeError, KeyError):
					return None
		return cur

	def path_from(self, node):
		"""
		Path of this node seen from the other::

			def build(bld):
				n1 = bld.path.find_node('foo/bar/xyz.txt')
				n2 = bld.path.find_node('foo/stuff/')
				n1.path_from(n2) # '../bar/xyz.txt'

		:param node: path to use as a reference
		:type node: :py:class:`waflib.Node.Node`
		:returns: a relative path or an absolute one if that is better
		:rtype: string
		"""
		c1 = self
		c2 = node

		c1h = c1.height()
		c2h = c2.height()

		lst = []
		up = 0

		while c1h > c2h:
			lst.append(c1.name)
			c1 = c1.parent
			c1h -= 1

		while c2h > c1h:
			up += 1
			c2 = c2.parent
			c2h -= 1

		while not c1 is c2:
			lst.append(c1.name)
			up += 1

			c1 = c1.parent
			c2 = c2.parent

		if c1.parent:
			lst.extend(['..'] * up)
			lst.reverse()
			return os.sep.join(lst) or '.'
		else:
			return self.abspath()

	def abspath(self):
		"""
		Returns the absolute path. A cache is kept in the context as ``cache_node_abspath``

		:rtype: string
		"""
		try:
			return self.cache_abspath
		except AttributeError:
			pass
		# think twice before touching this (performance + complexity + correctness)

		if not self.parent:
			val = os.sep
		elif not self.parent.name:
			val = os.sep + self.name
		else:
			val = self.parent.abspath() + os.sep + self.name
		self.cache_abspath = val
		return val

	if Utils.is_win32:
		def abspath(self):
			try:
				return self.cache_abspath
			except AttributeError:
				pass
			if not self.parent:
				val = ''
			elif not self.parent.name:
				val = self.name + os.sep
			else:
				val = self.parent.abspath().rstrip(os.sep) + os.sep + self.name
			self.cache_abspath = val
			return val

	def relpath(self):
		"""
		Returns the relative path. This is used in place of abspath() to keep paths short
                for environments like cygwin where path lengths to file operations are severely limited
                (for example, when cross-compiling for arm-none-eabi on cygwin)

		:rtype: string
		"""
		return os.path.relpath(self.abspath())


	def is_child_of(self, node):
		"""
		Returns whether the object belongs to a subtree of the input node::

			def build(bld):
				node = bld.path.find_node('wscript')
				node.is_child_of(bld.path) # True

		:param node: path to use as a reference
		:type node: :py:class:`waflib.Node.Node`
		:rtype: bool
		"""
		p = self
		diff = self.height() - node.height()
		while diff > 0:
			diff -= 1
			p = p.parent
		return p is node

	def ant_iter(self, accept=None, maxdepth=25, pats=[], dir=False, src=True, remove=True, quiet=False):
		"""
		Recursive method used by :py:meth:`waflib.Node.ant_glob`.

		:param accept: function used for accepting/rejecting a node, returns the patterns that can be still accepted in recursion
		:type accept: function
		:param maxdepth: maximum depth in the filesystem (25)
		:type maxdepth: int
		:param pats: list of patterns to accept and list of patterns to exclude
		:type pats: tuple
		:param dir: return folders too (False by default)
		:type dir: bool
		:param src: return files (True by default)
		:type src: bool
		:param remove: remove files/folders that do not exist (True by default)
		:type remove: bool
		:param quiet: disable build directory traversal warnings (verbose mode)
		:type quiet: bool
		:returns: A generator object to iterate from
		:rtype: iterator
		"""
		dircont = self.listdir()

		try:
			lst = set(self.children.keys())
		except AttributeError:
			self.children = self.dict_class()
		else:
			if remove:
				for x in lst - set(dircont):
					self.children[x].evict()

		for name in dircont:
			npats = accept(name, pats)
			if npats and npats[0]:
				accepted = [] in npats[0]

				node = self.make_node([name])

				isdir = node.isdir()
				if accepted:
					if isdir:
						if dir:
							yield node
					elif src:
						yield node

				if isdir:
					node.cache_isdir = True
					if maxdepth:
						for k in node.ant_iter(accept=accept, maxdepth=maxdepth - 1, pats=npats, dir=dir, src=src, remove=remove, quiet=quiet):
							yield k

	def ant_glob(self, *k, **kw):
		"""
		Finds files across folders and returns Node objects:

		* ``**/*`` find all files recursively
		* ``**/*.class`` find all files ending by .class
		* ``..`` find files having two dot characters

		For example::

			def configure(cfg):
				# find all .cpp files
				cfg.path.ant_glob('**/*.cpp')
				# find particular files from the root filesystem (can be slow)
				cfg.root.ant_glob('etc/*.txt')
				# simple exclusion rule example
				cfg.path.ant_glob('*.c*', excl=['*.c'], src=True, dir=False)

		For more information about the patterns, consult http://ant.apache.org/manual/dirtasks.html
		Please remember that the '..' sequence does not represent the parent directory::

			def configure(cfg):
				cfg.path.ant_glob('../*.h') # incorrect
				cfg.path.parent.ant_glob('*.h') # correct

		The Node structure is itself a filesystem cache, so certain precautions must
		be taken while matching files in the build or installati