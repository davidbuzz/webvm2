 is well stopped
                    if self.get_sim_time_cached() - tstop > 3:
                        raise NotAchievedException("Mag calibration didn't stop")
            self.check_zero_mag_parameters(params)
            self.check_zeros_mag_orient()

            #################################################
            self.start_subtest("Try magcal and make it failed")
            self.progress("Compass mask is %s" % "{0:b}".format(target_mask))
            old_cal_fit = self.get_parameter("COMPASS_CAL_FIT")
            self.set_parameter("COMPASS_CAL_FIT", 0.001, add_to_context=False)
            reset_pos_and_start_magcal(mavproxy, target_mask)
            tstart = self.get_sim_time()
            reached_pct = [0] * compass_tnumber
            report_get = [0] * compass_tnumber
            while True:
                if self.get_sim_time_cached() - tstart > timeout:
                    raise NotAchievedException("Cannot receive enough MAG_CAL_PROGRESS")
                m = self.assert_receive_message(["MAG_CAL_PROGRESS", "MAG_CAL_REPORT"], timeout=10)
                if m.get_type() == "MAG_CAL_REPORT":
                    if report_get[m.compass_id] == 0:
                        self.progress("Report: %s" % str(m))
                        if m.cal_status == mavutil.mavlink.MAG_CAL_FAILED:
                            report_get[m.compass_id] = 1
                        else:
                            raise NotAchievedException("Mag calibration didn't failed")
                    if all(ele >= 1 for ele in report_get):
                        self.progress("All Mag report failure")
                        break
                if m is not None and m.get_type() == "MAG_CAL_PROGRESS":
                    self.progress("Mag CAL progress: %s" % str(m))
                    cid = m.compass_id
                    new_pct = int(m.completion_pct)
                    if new_pct != reached_pct[cid]:
                        reached_pct[cid] = new_pct
                        self.progress("Calibration progress compass ID %d: %s%%" % (cid, str(reached_pct[cid])))
                        if cid == 0 and 49 <= reached_pct[0] <= 50:
                            self.progress("Try arming during calibration, should failed")
                            self.try_arm(False, "Compass calibration running")

            self.check_zero_mag_parameters(params)
            self.check_zeros_mag_orient()
            self.set_parameter("COMPASS_CAL_FIT", old_cal_fit, add_to_context=False)

            #################################################
            self.start_subtest("Try magcal and wait success")
            self.progress("Compass mask is %s" % "{0:b}".format(target_mask))
            reset_pos_and_start_magcal(mavproxy, target_mask)
            progress_count = [0] * compass_tnumber
            reached_pct = [0] * compass_tnumber
            report_get = [0] * compass_tnumber
            tstart = self.get_sim_time()
            while True:
                if self.get_sim_time_cached() - tstart > timeout:
                    raise NotAchievedException("Cannot receive enough MAG_CAL_PROGRESS")
                m = self.assert_receive_message(["MAG_CAL_PROGRESS", "MAG_CAL_REPORT"], timeout=5)
                if m.get_type() == "MAG_CAL_REPORT":
                    if report_get[m.compass_id] == 0:
                        self.progress("Report: %s" % self.dump_message_verbose(m))
                        param_names = ["SIM_MAG1_ORIENT"]
                        for i in range(2, compass_tnumber+1):
                            param_names.append("SIM_MAG%u_ORIENT" % i)
                        for param_name in param_names:
                            self.progress("%s=%f" % (param_name, self.get_parameter(param_name)))
                        if m.cal_status == mavutil.mavlink.MAG_CAL_SUCCESS:
                            threshold = 95
                            if reached_pct[m.compass_id] < threshold:
                                raise NotAchievedException(
                                    "Mag calibration report SUCCESS without >=%f%% completion (got %f%%)" %
                                    (threshold, reached_pct[m.compass_id]))
                            report_get[m.compass_id] = 1
                        else:
                            raise NotAchievedException(
                                "Mag calibration didn't SUCCEED (cal_status=%u) (progress_count=%s)" %
                                (m.cal_status, progress_count[m.compass_id],))
                    if all(ele >= 1 for ele in report_get):
                        self.progress("All Mag report SUCCESS")
                        break
                if m is not None and m.get_type() == "MAG_CAL_PROGRESS":
                    cid = m.compass_id
                    new_pct = int(m.completion_pct)
                    progress_count[cid] += 1
                    if new_pct != reached_pct[cid]:
                        reached_pct[cid] = new_pct
                        self.progress("Calibration progress compass ID %d: %s%%" % (cid, str(reached_pct[cid])))
            mavproxy.send("sitl_stop\n")
            mavproxy.send("sitl_attitude 0 0 0\n")
            self.progress("Checking that value aren't changed without acceptation")
            self.check_zero_mag_parameters(params)
            self.check_zeros_mag_orient()
            self.progress("Send acceptation and check value")
            self.wait_heartbeat()
            self.run_cmd(
                mavutil.mavlink.MAV_CMD_DO_ACCEPT_MAG_CAL,
                p1=target_mask, # p1: mag_mask
                want_result=mavutil.mavlink.MAV_RESULT_ACCEPTED,
                timeout=20,
            )
            self.check_mag_parameters(params, compass_tnumber)
            self.verify_parameter_values({"COMPASS_ORIENT": self.get_parameter("SIM_MAG1_ORIENT")})
            for count in range(2, compass_tnumber + 1):
                self.verify_parameter_values({"COMPASS_ORIENT%d" % count: self.get_parameter("SIM_MAG%d_ORIENT" % count)})
            self.try_arm(False, "Compass calibrated requires reboot")

            # test buzzer/notify ?
            self.progress("Rebooting and making sure we could arm with these values")
            self.drain_mav()
            self.reboot_sitl()
            if False:   # FIXME!  This fails with compasses inconsistent!
                self.wait_ready_to_arm(timeout=60)
            self.progress("Setting manually the parameter for other sensor to avoid compass consistency error")
            for idx in range(compass_tnumber, compass_count, 1):
                for param in params[idx]:
                    (_in, _out, value) = param
                    self.set_parameter(_out, value)
            for count in range(compass_tnumber + 1, compass_count + 1):
                self.set_parameter("COMPASS_ORIENT%d" % count, self.get_parameter("SIM_MAG%d_ORIENT" % count))
            self.arm_vehicle()
            self.progress("Test calibration rejection when armed")
            self.run_cmd(
                mavutil.mavlink.MAV_CMD_DO_START_MAG_CAL,
                p1=target_mask, # p1: mag_mask
                p2=0, # retry
                p3=0, # autosave
                p4=0, # delay
                want_result=mavutil.mavlink.MAV_RESULT_FAILED,
                timeout=20,
            )
            self.disarm_vehicle()
            self.mavproxy_unload_module(mavproxy, "relay")
            self.mavproxy_unload_module(mavproxy, "sitl_calibration")

        ex = None

        mavproxy = self.start_mavproxy()
        try:
            self.set_parameter("AHRS_EKF_TYPE", 10)
            self.set_parameter("SIM_GND_BEHAV", 0)

            curr_params = []
            target_mask = 0
            # we test all bitmask plus 0 for all
            for run in range(-1, compass_count, 1):
                ntest_compass = compass_count
                if run < 0:
                    # use bitmask 0 for all compass
                    target_mask = 0
                else:
                    target_mask |= (1 << run)
                    ntest_compass = run + 1
                do_prep_mag_cal_test(mavproxy, curr_params)
                do_test_mag_cal(mavproxy, curr_params, ntest_compass)

        except Exception as e:
            self.progress("Caught exception: %s" %
                          self.get_exception_stacktrace(e))
            ex = e
            self.mavproxy_unload_module(mavproxy, "relay")
            self.mavproxy_unload_module(mavproxy, "sitl_calibration")
        if ex is not None:
            raise ex

        self.stop_mavproxy(mavproxy)

        # need to reboot SITL after moving away from EKF type 10; we
        # can end up with home set but origin not and that will lead
        # to bad things.
        self.reboot_sitl()

    def test_mag_reordering_assert_mag_transform(self, values, transforms):
        '''transforms ought to be read as, "take all the parameter values from
        the first compass parameters and shove them into the second indicating
        compass parameters'''

        # create a set of mappings from one parameter name to another
        # e.g. COMPASS_OFS_X => COMPASS_OFS2_X if the transform is
        # [(1,2)].  [(1,2),(2,1)] should swap the compass values

        parameter_mappings = {}
        for key in values.keys():
            parameter_mappings[key] = key
        for (old_compass_num, new_compass_num) in transforms:
            old_key_compass_bit = str(old_compass_num)
            if old_key_compass_bit == "1":
                old_key_compass_bit = ""
            new_key_compass_bit = str(new_compass_num)
            if new_key_compass_bit == "1":
                new_key_compass_bit = ""
            # vectors first:
            for key_vector_bit in ["OFS", "DIA", "ODI", "MOT"]:
                for axis in "X", "Y", "Z":
                    old_key = "COMPASS_%s%s_%s" % (key_vector_bit,
                                                   old_key_compass_bit,
                                                   axis)
                    new_key = "COMPASS_%s%s_%s" % (key_vector_bit,
                                                   new_key_compass_bit,
                                                   axis)
                    parameter_mappings[old_key] = new_key
            # then non-vectorey bits:
            for key_bit in "SCALE", "ORIENT":
                old_key = "COMPASS_%s%s" % (key_bit, old_key_compass_bit)
                new_key = "COMPASS_%s%s" % (key_bit, new_key_compass_bit)
                parameter_mappings[old_key] = new_key
            # then a sore thumb:
            if old_key_compass_bit == "":
                old_key = "COMPASS_EXTERNAL"
            else:
                old_key = "COMPASS_EXTERN%s" % old_key_compass_bit
            if new_key_compass_bit == "":
                new_key = "COMPASS_EXTERNAL"
            else:
                new_key = "COMPASS_EXTERN%s" % new_key_compass_bit
            parameter_mappings[old_key] = new_key

        for key in values.keys():
            newkey = parameter_mappings[key]
            current_value = self.get_parameter(newkey)
            expected_value = values[key]
            if abs(current_value - expected_value) > 0.001:
                raise NotAchievedException("%s has wrong value; want=%f got=%f transforms=%s (old parameter name=%s)" %
                                           (newkey, expected_value, current_value, str(transforms), key))

    def CompassReordering(self):
        '''Test Compass reordering when priorities are changed'''
        self.context_push()
        ex = None
        try:
            originals = {
                "COMPASS_OFS_X": 1.1,
                "COMPASS_OFS_Y": 1.2,
                "COMPASS_OFS_Z": 1.3,
                "COMPASS_DIA_X": 1.4,
                "COMPASS_DIA_Y": 1.5,
                "COMPASS_DIA_Z": 1.6,
                "COMPASS_ODI_X": 1.7,
                "COMPASS_ODI_Y": 1.8,
                "COMPASS_ODI_Z": 1.9,
                "COMPASS_MOT_X": 1.91,
                "COMPASS_MOT_Y": 1.92,
                "COMPASS_MOT_Z": 1.93,
                "COMPASS_SCALE": 1.94,
                "COMPASS_ORIENT": 1,
                "COMPASS_EXTERNAL": 2,

                "COMPASS_OFS2_X": 2.1,
                "COMPASS_OFS2_Y": 2.2,
                "COMPASS_OFS2_Z": 2.3,
                "COMPASS_DIA2_X": 2.4,
                "COMPASS_DIA2_Y": 2.5,
                "COMPASS_DIA2_Z": 2.6,
                "COMPASS_ODI2_X": 2.7,
                "COMPASS_ODI2_Y": 2.8,
                "COMPASS_ODI2_Z": 2.9,
                "COMPASS_MOT2_X": 2.91,
                "COMPASS_MOT2_Y": 2.92,
                "COMPASS_MOT2_Z": 2.93,
                "COMPASS_SCALE2": 2.94,
                "COMPASS_ORIENT2": 3,
                "COMPASS_EXTERN2": 4,

                "COMPASS_OFS3_X": 3.1,
                "COMPASS_OFS3_Y": 3.2,
                "COMPASS_OFS3_Z": 3.3,
                "COMPASS_DIA3_X": 3.4,
                "COMPASS_DIA3_Y": 3.5,
                "COMPASS_DIA3_Z": 3.6,
                "COMPASS_ODI3_X": 3.7,
                "COMPASS_ODI3_Y": 3.8,
                "COMPASS_ODI3_Z": 3.9,
                "COMPASS_MOT3_X": 3.91,
                "COMPASS_MOT3_Y": 3.92,
                "COMPASS_MOT3_Z": 3.93,
                "COMPASS_SCALE3": 3.94,
                "COMPASS_ORIENT3": 5,
                "COMPASS_EXTERN3": 6,
            }

            # quick sanity check to ensure all values are unique:
            if len(originals.values()) != len(set(originals.values())):
                raise NotAchievedException("Values are not all unique!")

            self.progress("Setting parameters")
            self.set_parameters(originals)

            self.reboot_sitl()

            # no transforms means our originals should be our finals:
            self.test_mag_reordering_assert_mag_transform(originals, [])

            self.start_subtest("Pushing 1st mag to 3rd")
            ey = None
            self.context_push()
            try:
                # now try reprioritising compass 1 to be higher than compass 0:
                prio1_id = self.get_parameter("COMPASS_PRIO1_ID")
                prio2_id = self.get_parameter("COMPASS_PRIO2_ID")
                prio3_id = self.get_parameter("COMPASS_PRIO3_ID")
                self.set_parameter("COMPASS_PRIO1_ID", prio2_id)
                self.set_parameter("COMPASS_PRIO2_ID", prio3_id)
                self.set_parameter("COMPASS_PRIO3_ID", prio1_id)

                self.reboot_sitl()

                self.test_mag_reordering_assert_mag_transform(originals, [(2, 1),
                                                                          (3, 2),
                                                                          (1, 3)])

            except Exception as e:
                self.progress("Caught exception: %s" %
                              self.get_exception_stacktrace(e))
                ey = e
            self.context_pop()
            self.reboot_sitl()
            if ey is not None:
                raise ey

        except Exception as e:
            self.progress("Caught exception: %s" %
                          self.get_exception_stacktrace(e))
            ex = e
        self.context_pop()
        self.reboot_sitl()
        if ex is not None:
            raise ex

    # something about SITLCompassCalibration appears to fail
    # this one, so we put it first:
    def FixedYawCalibration(self):
        '''Test Fixed Yaw Calibration'''
        self.context_push()
        ex = None
        try:
            MAG_OFS_X = 100
            MAG_OFS_Y = 200
            MAG_OFS_Z = 300
            wanted = {
                "COMPASS_OFS_X": (MAG_OFS_X, 3.0),
                "COMPASS_OFS_Y": (MAG_OFS_Y, 3.0),
                "COMPASS_OFS_Z": (MAG_OFS_Z, 3.0),
                "COMPASS_DIA_X": 1,
                "COMPASS_DIA_Y": 1,
                "COMPASS_DIA_Z": 1,
                "COMPASS_ODI_X": 0,
                "COMPASS_ODI_Y": 0,
                "COMPASS_ODI_Z": 0,

                "COMPASS_OFS2_X": (MAG_OFS_X, 3.0),
                "COMPASS_OFS2_Y": (MAG_OFS_Y, 3.0),
                "COMPASS_OFS2_Z": (MAG_OFS_Z, 3.0),
                "COMPASS_DIA2_X": 1,
                "COMPASS_DIA2_Y": 1,
                "COMPASS_DIA2_Z": 1,
                "COMPASS_ODI2_X": 0,
                "COMPASS_ODI2_Y": 0,
                "COMPASS_ODI2_Z": 0,

                "COMPASS_OFS3_X": (MAG_OFS_X, 3.0),
                "COMPASS_OFS3_Y": (MAG_OFS_Y, 3.0),
                "COMPASS_OFS3_Z": (MAG_OFS_Z, 3.0),
                "COMPASS_DIA3_X": 1,
                "COMPASS_DIA3_Y": 1,
                "COMPASS_DIA3_Z": 1,
                "COMPASS_ODI3_X": 0,
                "COMPASS_ODI3_Y": 0,
                "COMPASS_ODI3_Z": 0,
            }
            self.set_parameters({
                "SIM_MAG1_OFS_X": MAG_OFS_X,
                "SIM_MAG1_OFS_Y": MAG_OFS_Y,
                "SIM_MAG1_OFS_Z": MAG_OFS_Z,

                "SIM_MAG2_OFS_X": MAG_OFS_X,
                "SIM_MAG2_OFS_Y": MAG_OFS_Y,
                "SIM_MAG2_OFS_Z": MAG_OFS_Z,

                "SIM_MAG3_OFS_X": MAG_OFS_X,
                "SIM_MAG3_OFS_Y": MAG_OFS_Y,
                "SIM_MAG3_OFS_Z": MAG_OFS_Z,
            })

            # set to some sensible-ish initial values.  If your initial
            # offsets are way, way off you can get some very odd effects.
            for param in wanted:
                value = 0.0
                if "DIA" in param:
                    value = 1.001
                elif "ODI" in param:
                    value = 0.001
                self.set_parameter(param, value)

            self.zero_mag_offset_parameters()

            # wait until we definitely know where we are:
            self.poll_home_position(timeout=120)

            ss = self.assert_receive_message('SIMSTATE', timeout=1, verbose=True)

            self.run_cmd(
                mavutil.mavlink.MAV_CMD_FIXED_MAG_CAL_YAW,
                p1=math.degrees(ss.yaw),
            )
            self.verify_parameter_values(wanted)

            # run same command but as command_int:
            self.zero_mag_offset_parameters()
            self.run_cmd_int(
                mavutil.mavlink.MAV_CMD_FIXED_MAG_CAL_YAW,
                p1=math.degrees(ss.yaw),
            )
            self.verify_parameter_values(wanted)

            self.progress("Rebooting and making sure we could arm with these values")
            self.reboot_sitl()
            self.wait_ready_to_arm(timeout=60)

        except Exception as e:
            ex = e

        self.context_pop()

        if ex is not None:
            raise ex

    def DataFlashOverMAVLink(self):
        '''Test DataFlash over MAVLink'''
        self.context_push()
        ex = None
        mavproxy = self.start_mavproxy()
        try:
            self.set_parameter("LOG_BACKEND_TYPE", 2)
            self.reboot_sitl()
            self.wait_ready_to_arm(check_prearm_bit=False)
            mavproxy.send('arm throttle\n')
            mavproxy.expect('PreArm: Logging failed')
            self.mavproxy_load_module(mavproxy, 'dataflash_logger')
            mavproxy.send("dataflash_logger set verbose 1\n")
            mavproxy.expect('logging started')
            mavproxy.send("dataflash_logger set verbose 0\n")
            self.delay_sim_time(1)
            self.do_timesync_roundtrip()  # drain COMMAND_ACK from that failed arm
            self.arm_vehicle()
            tstart = self.get_sim_time()
            last_status = 0
            mavproxy.send('repeat add 1 dataflash_logger status\n')
            while True:
                now = self.get_sim_time()
                if now - tstart > 60:
                    break
                if now - last_status > 5:
                    last_status = now
                    # seen on autotest: Active Rate(3s):97.790kB/s Block:164 Missing:0 Fixed:0 Abandoned:0
                    mavproxy.expect(r"Active Rate\([0-9]+s\):([0-9]+[.][0-9]+)")
                    rate = float(mavproxy.match.group(1))
                    self.progress("Rate: %f" % rate)
                    desired_rate = 50
                    if self.valgrind or self.callgrind:
                        desired_rate /= 10
                    if rate < desired_rate:
                        raise NotAchievedException("Exceptionally low transfer rate (%u < %u)" % (rate, desired_rate))
            self.disarm_vehicle()
            mavproxy.send('repeat remove 0\n')
        except Exception as e:
            self.print_exception_caught(e)
            self.disarm_vehicle()
            ex = e
        self.mavproxy_unload_module(mavproxy, 'dataflash_logger')

        # the following things won't work - but they shouldn't die either:
        self.mavproxy_load_module(mavproxy, 'log')

        self.progress("Try log list")
        mavproxy.send("log list\n")
        mavproxy.expect("No logs")

        self.progress("Try log erase")
        mavproxy.send("log erase\n")
        # no response to this...

        self.progress("Try log download")
        mavproxy.send("log download 1\n")
        # no response to this...

        self.mavproxy_unload_module(mavproxy, 'log')

        self.context_pop()

        self.stop_mavproxy(mavproxy)
        self.reboot_sitl()
        if ex is not None:
            raise ex

    def DataFlash(self):
        """Test DataFlash SITL backend"""
        self.context_push()
        ex = None
        mavproxy = self.start_mavproxy()
        try:
            self.set_parameter("LOG_BACKEND_TYPE", 4)
            self.set_parameter("LOG_FILE_DSRMROT", 1)
            self.set_parameter("LOG_BLK_RATEMAX", 1)
            self.reboot_sitl()
            # First log created here, but we are in chip erase so ignored
            mavproxy.send("module load log\n")
            mavproxy.send("log erase\n")
            mavproxy.expect("Chip erase complete")

            self.wait_ready_to_arm()
            if self.is_copter() or self.is_plane():
                self.set_autodisarm_delay(0)
            self.arm_vehicle()
            self.delay_sim_time(5)
            self.disarm_vehicle()
            # First log created here
            self.delay_sim_time(2)
            self.arm_vehicle()
            self.delay_sim_time(5)
            self.disarm_vehicle()
            # Second log created here
            self.delay_sim_time(2)
            mavproxy.send("log list\n")
            mavproxy.expect("Log ([0-9]+)  numLogs ([0-9]+) lastLog ([0-9]+) size ([0-9]+)", timeout=120)
            log_num = int(mavproxy.match.group(1))
            numlogs = int(mavproxy.match.group(2))
            lastlog = int(mavproxy.match.group(3))
            size = int(mavproxy.match.group(4))
            if numlogs != 2 or log_num != 1 or size <= 0:
                raise NotAchievedException("Unexpected log information %d %d %d" % (log_num, numlogs, lastlog))
            self.progress("Log size: %d" % size)
            self.reboot_sitl()
            # This starts a new log with a time of 0, wait for arm so that we can insert the correct time
            self.wait_ready_to_arm()
            # Third log created here
            mavproxy.send("log list\n")
            mavproxy.expect("Log 1  numLogs 3 lastLog 3 size")

            # Download second and third logs
            mavproxy.send("log download 2 logs/dataflash-log-002.BIN\n")
            mavproxy.expect("Finished downloading", timeout=120)
            mavproxy.send("log download 3 logs/dataflash-log-003.BIN\n")
            mavproxy.expect("Finished downloading", timeout=120)

            # Erase the logs
            mavproxy.send("log erase\n")
            mavproxy.expect("Chip erase complete")

        except Exception as e:
            self.print_exception_caught(e)
            ex = e
        mavproxy.send("module unload log\n")
        self.stop_mavproxy(mavproxy)
        self.context_pop()
        self.reboot_sitl()
        if ex is not None:
            raise ex

    def validate_log_file(self, logname, header_errors=0):
        """Validate the contents of a log file"""
        # read the downloaded log - it must parse without error
        class Capturing(list):
            def __enter__(self):
                self._stderr = sys.stderr
                sys.stderr = self._stringio = StringIO.StringIO()
                return self

            def __exit__(self, *args):
                self.extend(self._stringio.getvalue().splitlines())
                del self._stringio    # free up some memory
                sys.stderr = self._stderr

        with Capturing() as df_output:
            try:
                mlog = mavutil.mavlink_connection(logname)
                while True:
                    m = mlog.recv_match()
                    if m is None:
                        break
            except Exception as e:
                raise NotAchievedException("Error reading log file %s: %s" % (logname, str(e)))

        herrors = 0

        for msg in df_output:
            if msg.startswith("bad header") or msg.startswith("unknown msg type"):
                herrors = herrors + 1

        if herrors > header_errors:
            raise NotAchievedException("Error parsing log file %s, %d header errors" % (logname, herrors))

    def DataFlashErase(self):
        """Test that erasing the dataflash chip and creating a new log is error free"""
        mavproxy = self.start_mavproxy()

        ex = None
        self.context_push()
        try:
            self.set_parameter("LOG_BACKEND_TYPE", 4)
            self.reboot_sitl()
            mavproxy.send("module load log\n")
            mavproxy.send("log erase\n")
            mavproxy.expect("Chip erase complete")
            self.set_parameter("LOG_DISARMED", 1)
            self.delay_sim_time(3)
            self.set_parameter("LOG_DISARMED", 0)
            mavproxy.send("log download 1 logs/dataflash-log-erase.BIN\n")
            mavproxy.expect("Finished downloading", timeout=120)
            # read the downloaded log - it must parse without error
            self.validate_log_file("logs/dataflash-log-erase.BIN")

            self.start_subtest("Test file wrapping results in a valid file")
            # roughly 4mb
            self.set_parameter("LOG_FILE_DSRMROT", 1)
            self.set_parameter("LOG_BITMASK", 131071)
            self.wait_ready_to_arm()
            if self.is_copter() or self.is_plane():
                self.set_autodisarm_delay(0)
            self.arm_vehicle()
            self.delay_sim_time(30)
            self.disarm_vehicle()
            # roughly 4mb
            self.arm_vehicle()
            self.delay_sim_time(30)
            self.disarm_vehicle()
            # roughly 9mb, should wrap around
            self.arm_vehicle()
            self.delay_sim_time(50)
            self.disarm_vehicle()
            # make sure we have finished logging
            self.delay_sim_time(15)
            mavproxy.send("log list\n")
            try:
                mavproxy.expect("Log ([0-9]+)  numLogs ([0-9]+) lastLog ([0-9]+) size ([0-9]+)", timeout=120)
            except pexpect.TIMEOUT as e:
                if self.sitl_is_running():
                    self.progress("SITL is running")
                else:
                    self.progress("SITL is NOT running")
                raise NotAchievedException("Received %s" % str(e))
            if int(mavproxy.match.group(2)) != 3:
                raise NotAchievedException("Expected 3 logs got %s" % (mavproxy.match.group(2)))

            mavproxy.send("log download 1 logs/dataflash-log-erase2.BIN\n")
            mavproxy.expect("Finished downloading", timeout=120)
            self.validate_log_file("logs/dataflash-log-erase2.BIN", 1)

            mavproxy.send("log download latest logs/dataflash-log-erase3.BIN\n")
            mavproxy.expect("Finished downloading", timeout=120)
            self.validate_log_file("logs/dataflash-log-erase3.BIN", 1)

            # clean up
            mavproxy.send("log erase\n")
            mavproxy.expect("Chip erase complete")

            # clean up
            mavproxy.send("log erase\n")
            mavproxy.expect("Chip erase complete")

        except Exception as e:
            self.print_exception_caught(e)
            ex = e

        mavproxy.send("module unload log\n")

        self.context_pop()
        self.reboot_sitl()

        self.stop_mavproxy(mavproxy)

        if ex is not None:
            raise ex

    def ArmFeatures(self):
        '''Arm features'''
        # TEST ARMING/DISARM
        self.delay_sim_time(12)  # wait for gyros/accels to be happy
        if self.get_parameter("ARMING_CHECK") != 1.0 and not self.is_sub():
            raise ValueError("Arming check should be 1")
        if not self.is_sub() and not self.is_tracker():
            self.set_parameter("ARMING_RUDDER", 2)  # allow arm and disarm with rudder on first tests
        if self.is_copter():
            interlock_channel = 8  # Plane got flighmode_ch on channel 8
            if not self.is_heli():  # heli don't need interlock option
                interlock_channel = 9
                self.set_parameter("RC%u_OPTION" % interlock_channel, 32)
            self.set_rc(interlock_channel, 1000)
        self.zero_throttle()
        # Disable auto disarm for next tests
        # Rover and Sub don't have auto disarm
        if self.is_copter() or self.is_plane():
            self.set_autodisarm_delay(0)
        self.start_subtest("Test normal arm and disarm features")
        self.wait_ready_to_arm()
        self.progress("default arm_vehicle() call")
        if not self.arm_vehicle():
            raise NotAchievedException("Failed to ARM")
        self.progress("default disarm_vehicle() call")
        self.disarm_vehicle()

        self.start_subtest("Arm/disarm vehicle with COMMAND_INT")
        self.run_cmd_int(
            mavutil.mavlink.MAV_CMD_COMPONENT_ARM_DISARM,
            p1=1,  # ARM
        )
        self.run_cmd_int(
            mavutil.mavlink.MAV_CMD_COMPONENT_ARM_DISARM,
            p1=0,  # DISARM
        )

        self.progress("arm with mavproxy")
        mavproxy = self.start_mavproxy()
        if not self.mavproxy_arm_vehicle(mavproxy):
            raise NotAchievedException("Failed to ARM")
        self.progress("disarm with mavproxy")
        self.mavproxy_disarm_vehicle(mavproxy)
        self.stop_mavproxy(mavproxy)

        if not self.is_sub():
            self.start_subtest("Test arm with rc input")
            self.arm_motors_with_rc_input()
            self.progress("disarm with rc input")
            if self.is_balancebot():
                self.progress("balancebot can't disarm with RC input")
                self.disarm_vehicle()
            else:
                self.disarm_motors_with_rc_input()

            self.start_subtest("Test arm and disarm with switch")
            arming_switch = 7
            self.set_parameter("RC%d_OPTION" % arming_switch, 153)
            self.set_rc(arming_switch, 1000)
            # delay so a transition is seen by the RC switch code:
            self.delay_sim_time(0.5)
            self.arm_motors_with_switch(arming_switch)
            self.disarm_motors_with_switch(arming_switch)
            self.set_rc(arming_switch, 1000)

            if self.is_copter():
                self.start_subtest("Test arming failure with throttle too high")
                self.set_rc(3, 1800)
                try:
                    if self.arm_vehicle():
                        raise NotAchievedException("Armed when throttle too high")
                except ValueError:
                    pass
                try:
                    self.arm_motors_with_rc_input()
                except NotAchievedException:
                    pass
                if self.armed():
                    raise NotAchievedException(
                        "Armed via RC when throttle too high")
                try:
                    self.arm_motors_with_switch(arming_switch)
                except NotAchievedException:
                    pass
                if self.armed():
                    raise NotAchievedException("Armed via RC when switch too high")
                self.zero_throttle()
                self.set_rc(arming_switch, 1000)

            # Sub doesn't have 'stick commands'
            self.start_subtest("Test arming failure with ARMING_RUDDER=0")
            self.set_parameter("ARMING_RUDDER", 0)
            try:
                self.arm_motors_with_rc_input()
            except NotAchievedException:
                pass
            if self.armed():
                raise NotAchievedException(
                    "Armed with rudder when ARMING_RUDDER=0")
            self.start_subtest("Test disarming failure with ARMING_RUDDER=0")
            self.arm_vehicle()
            try:
                self.disarm_motors_with_rc_input(watch_for_disabled=True)
            except NotAchievedException:
                pass
            if not self.armed():
                raise NotAchievedException(
                    "Disarmed with rudder when ARMING_RUDDER=0")
            self.disarm_vehicle()
            self.wait_heartbeat()
            self.start_subtest("Test disarming failure with ARMING_RUDDER=1")
            self.set_parameter("ARMING_RUDDER", 1)
            self.arm_vehicle()
            try:
                self.disarm_motors_with_rc_input()
            except NotAchievedException:
                pass
            if not self.armed():
                raise NotAchievedException(
                    "Disarmed with rudder with ARMING_RUDDER=1")
            self.disarm_vehicle()
            self.wait_heartbeat()
            self.set_parameter("ARMING_RUDDER", 2)

            if self.is_copter():
                self.start_subtest("Test arming failure with interlock enabled")
                self.set_rc(interlock_channel, 2000)
                try:
                    self.arm_motors_with_rc_input()
                except NotAchievedException:
                    pass
                if self.armed():
                    raise NotAchievedException(
                        "Armed with RC input when interlock enabled")
                try:
                    self.arm_motors_with_switch(arming_switch)
                except NotAchievedException:
                    pass
                if self.armed():
                    raise NotAchievedException("Armed with switch when interlock enabled")
                self.disarm_vehicle()
                self.wait_heartbeat()
                self.set_rc(arming_switch, 1000)
                self.set_rc(interlock_channel, 1000)
                if self.is_heli():
                    self.start_subtest("Test motor interlock enable can't be set while disarmed")
                    self.set_rc(interlock_channel, 2000)
                    channel_field = "servo%u_raw" % interlock_channel
                    interlock_value = self.get_parameter("SERVO%u_MIN" % interlock_channel)
                    tstart = self.get_sim_time()
                    while True:
                        if self.get_sim_time_cached() - tstart > 20:
                            self.set_rc(interlock_channel, 1000)
                            break # success!
                        m = self.mav.recv_match(type='SERVO_OUTPUT_RAW',
                                                blocking=True,
                                                timeout=2)
                        if m is None:
                            continue
                        m_value = getattr(m, channel_field, None)
                        if m_value is None:
                            self.set_rc(interlock_channel, 1000)
                            raise ValueError("Message has no %s field" %
                                             channel_field)
                        self.progress("SERVO_OUTPUT_RAW.%s=%u want=%u" %
                                      (channel_field, m_value, interlock_value))
                        if m_value != interlock_value:
                            self.set_rc(interlock_channel, 1000)
                            raise NotAchievedException("Motor interlock was changed while disarmed")
                self.set_rc(interlock_channel, 1000)

        self.start_subtest("Test all mode arming")
        self.wait_ready_to_arm()

        if self.arming_test_mission() is not None:
            self.load_mission(self.arming_test_mission())

        for mode in self.mav.mode_mapping():
            self.drain_mav()
            self.start_subtest("Mode : %s" % mode)
            if mode == "FOLLOW":
                self.set_parameter("FOLL_ENABLE", 1)
            if mode in self.get_normal_armable_modes_list():
                self.progress("Armable mode : %s" % mode)
                self.change_mode(mode)
                self.arm_vehicle()
                self.disarm_vehicle()
                self.progress("PASS arm mode : %s" % mode)
            if mode in self.get_not_armable_mode_list():
                if mode in self.get_not_disarmed_settable_modes_list():
                    self.progress("Not settable mode : %s" % mode)
                    try:
                        self.change_mode(mode, timeout=15)
                    except AutoTestTimeoutException:
                        self.progress("PASS not able to set mode : %s disarmed" % mode)
                    except ValueError:
                        self.progress("PASS not able to set mode : %s disarmed" % mode)
                else:
                    self.progress("Not armable mode : %s" % mode)
                    self.change_mode(mode)
                    self.run_cmd(
                        mavutil.mavlink.MAV_CMD_COMPONENT_ARM_DISARM,
                        p1=1,  # ARM
                        want_result=mavutil.mavlink.MAV_RESULT_FAILED,
                    )
                self.progress("PASS not able to arm in mode : %s" % mode)
            if mode in self.get_position_armable_modes_list():
                self.progress("Armable mode needing Position : %s" % mode)
                self.wait_ekf_happy()
                self.change_mode(mode)
                self.arm_vehicle()
                self.wait_heartbeat()
                self.disarm_vehicle()
                self.progress("PASS arm mode : %s" % mode)
                self.progress("Not armable mode without Position : %s" % mode)
                self.wait_gps_disable()
                self.change_mode(mode)
                self.run_cmd(
                    mavutil.mavlink.MAV_CMD_COMPONENT_ARM_DISARM,
                    p1=1,  # ARM
                    want_result=mavutil.mavlink.MAV_RESULT_FAILED,
                )
                self.set_parameter("SIM_GPS_DISABLE", 0)
                self.wait_ekf_happy() # EKF may stay unhappy for a while
                self.progress("PASS not able to arm without Position in mode : %s" % mode)
            if mode in self.get_no_position_not_settable_modes_list():
                self.progress("Setting mode need Position : %s" % mode)
                self.wait_ekf_happy()
                self.wait_gps_disable()
                try:
                    self.change_mode(mode, timeout=15)
                except AutoTestTimeoutException:
                    self.set_parameter("SIM_GPS_DISABLE", 0)
                    self.progress("PASS not able to set mode without Position : %s" % mode)
                except ValueError:
                    self.set_parameter("SIM_GPS_DISABLE", 0)
                    self.progress("PASS not able to set mode without Position : %s" % mode)
            if mode == "FOLLOW":
                self.set_parameter("FOLL_ENABLE", 0)
        self.change_mode(self.default_mode())
        if self.armed():
            self.disarm_vehicle()

        # we should find at least one Armed event and one disarmed
        # event, and at least one ARM message for arm and disarm
        wants = set([
            ("Armed EV message",  "EV", lambda e : e.Id == 10),
            ("Disarmed EV message",  "EV", lambda e : e.Id == 11),
            ("Armed ARM message",  "ARM", lambda a : a.ArmState == 1),
            ("Disarmed ARM message",  "ARM", lambda a : a.ArmState == 0),
        ])

        dfreader = self.dfreader_for_current_onboard_log()
        types = set()
        for (name, msgtype, l) in wants:
            types.add(msgtype)

        while True:
            m = dfreader.recv_match(type=types)
            if m is None:
                break
            wantscopy = copy.copy(wants)
            for want in wantscopy:
                (name, msgtype, l) = want
                if m.get_type() != msgtype:
                    continue
                if l(m):
                    self.progress("Found %s" % name)
                    wants.discard(want)
                    if len(wants) == 0:
                        break

        if len(wants):
            msg = ", ".join([x[0] for x in wants])
            raise NotAchievedException("Did not find (%s)" % msg)

        self.progress("ALL PASS")
    # TODO : Test arming magic;

    def measure_message_rate(self, victim_message, timeout=10, mav=None):
        if mav is None:
            mav = self.mav
        tstart = self.get_sim_time()
        count = 0
        while self.get_sim_time_cached() < tstart + timeout:
            m = mav.recv_match(
                type=victim_message,
                blocking=True,
                timeout=0.1
            )
            if m is not None:
                count += 1
            if mav != self.mav:
                self.drain_mav(self.mav)

        time_delta = self.get_sim_time_cached() - tstart
        self.progress("%s count after %f seconds: %u" %
                      (victim_message, time_delta, count))
        return count/time_delta

    def rate_to_interval_us(self, rate):
        return 1/float(rate)*1000000.0

    def interval_us_to_rate(self, interval):
        if interval == 0:
            raise ValueError("Zero interval is infinite rate")
        return 1000000.0/float(interval)

    def set_message_rate_hz(self, id, rate_hz, mav=None, run_cmd=None):
        '''set a message rate in Hz; 0 for original, -1 to disable'''
        if run_cmd is None:
            run_cmd = self.run_cmd
        if isinstance(id, str):
            id = eval("mavutil.mavlink.MAVLINK_MSG_ID_%s" % id)
        if rate_hz == 0 or rate_hz == -1:
            set_interval = rate_hz
        else:
            set_interval = self.rate_to_interval_us(rate_hz)
        run_cmd(
            mavutil.mavlink.MAV_CMD_SET_MESSAGE_INTERVAL,
            p1=id,
            p2=set_interval,
            mav=mav,
        )

    def get_message_rate_hz(self, id, mav=None, run_cmd=None):
        '''return rate message is being sent, in Hz'''
        if run_cmd is None:
            run_cmd = self.run_cmd

        interval = self.get_message_interval(id, mav=mav, run_cmd=run_cmd)
        return self.interval_us_to_rate(interval)

    def send_get_message_interval(self, victim_message, mav=None):
        if mav is None:
            mav = self.mav
        if isinstance(victim_message, str):
            victim_message = eval("mavutil.mavlink.MAVLINK_MSG_ID_%s" % victim_message)
        mav.mav.command_long_send(
            1,
            1,
            mavutil.mavlink.MAV_CMD_GET_MESSAGE_INTERVAL,
            1,  # confirmation
            float(victim_message),
            0,
            0,
            0,
            0,
            0,
            0)

    def get_message_interval(self, victim_message, mav=None, run_cmd=None):
        '''returns message interval in microseconds'''
        if run_cmd is None:
            run_cmd = self.run_cmd

        self.send_get_message_interval(victim_message, mav=mav)
        m = self.assert_receive_message('MESSAGE_INTERVAL', timeout=1, mav=mav)

        if isinstance(victim_message, str):
            victim_message = eval("mavutil.mavlink.MAVLINK_MSG_ID_%s" % victim_message)
        if m.message_id != victim_message:
            raise NotAchievedException(f"Unexpected ID in MESSAGE_INTERVAL (want={victim_message}, got={m.message_id}")

        return m.interval_us

    def set_message_interval(self, victim_message, interval_us, mav=None):
        '''sets message interval in microseconds'''
        if isinstance(victim_message, str):
            victim_message = eval("mavutil.mavlink.MAVLINK_MSG_ID_%s" % victim_message)
        self.run_cmd(
            mavutil.mavlink.MAV_CMD_SET_MESSAGE_INTERVAL,
            p1=victim_message,
            p2=interval_us,
            mav=mav,
        )

    def test_rate(self,
                  desc,
                  in_rate,
                  expected_rate
                  , mav=None,
                  victim_message="VFR_HUD",
                  ndigits=0,
                  message_rate_sample_period=10):
        if mav is None:
            mav = self.mav

        self.progress("###### %s" % desc)
        self.progress("Setting rate to %f" % round(in_rate, ndigits=ndigits))

        self.set_message_rate_hz(victim_message, in_rate, mav=mav)

        new_measured_rate = self.measure_message_rate(victim_message, timeout=message_rate_sample_period, mav=mav)
        self.progress(
            "Measured rate: %f (want %f)" %
            (round(new_measured_rate, ndigits=ndigits),
             round(expected_rate, ndigits=ndigits))
        )
        notachieved_ex = None
        if round(new_measured_rate, ndigits=ndigits) != round(expected_rate, ndigits=ndigits):
            notachieved_ex = NotAchievedException(
                "Rate not achieved (got %f want %f)" %
                (round(new_measured_rate, ndigits),
                 round(expected_rate, ndigits)))

        # make sure get_message_interval works:
        self.send_get_message_interval(victim_message, mav=mav)

        m = self.assert_receive_message('MESSAGE_INTERVAL', timeout=30, mav=mav)

        if in_rate == 0:
            want = self.rate_to_interval_us(expected_rate)
        elif in_rate == -1:
            want = in_rate
        else:
            want = self.rate_to_interval_us(in_rate)

        if m.interval_us != want:
            raise NotAchievedException("Did not read same interval back from autopilot: want=%d got=%d)" %
                                       (want, m.interval_us))
        m = self.assert_receive_message('COMMAND_ACK', mav=mav)
        if m.result != mavutil.mavlink.MAV_RESULT_ACCEPTED:
            raise NotAchievedException("Expected ACCEPTED for reading message interval")

        if notachieved_ex is not None:
            raise notachieved_ex

    def SET_MESSAGE_INTERVAL(self):
        '''Test MAV_CMD_SET_MESSAGE_INTERVAL'''
        self.set_parameter("CAM1_TYPE", 1) # Camera with servo trigger
        self.reboot_sitl() # needed for CAM1_TYPE to take effect
        self.start_subtest('Basic tests')
        self.test_set_message_interval_basic()
        self.start_subtest('Many-message tests')
        self.test_set_message_interval_many()

    def MESSAGE_INTERVAL_COMMAND_INT(self):
        '''Test MAV_CMD_SET_MESSAGE_INTERVAL works as COMMAND_INT'''
        original_rate = round(self.measure_message_rate("VFR_HUD", 20))
        self.context_set_message_rate_hz('VFR_HUD', original_rate*2, run_cmd=self.run_cmd_int)
        if abs(original_rate*2 - round(self.get_message_rate_hz("VFR_HUD", run_cmd=self.run_cmd_int))) > 1:
            raise NotAchievedException("Did not set rate")

        self.start_subtest("Use REQUEST_MESSAGE via COMMAND_INT")
        # 148 is AUTOPILOT_VERSION:
        self.context_collect('AUTOPILOT_VERSION')
        self.run_cmd_int(mavutil.mavlink.MAV_CMD_REQUEST_MESSAGE, 148)
        self.delay_sim_time(2)
        count = len(self.context_collection('AUTOPILOT_VERSION'))
        if count != 1:
            raise NotAchievedException(f"Did not get single AUTOPILOT_VERSION message (count={count}")

    def test_set_message_interval_many(self):
        messages = [
            'CAMERA_FEEDBACK',
            'RAW_IMU',
            'ATTITUDE',
        ]
        ex = None
        try:
            rate = 5
            for message in messages:
                self.set_message_rate_hz(message, rate)
            for message in messages:
                self.assert_message_rate_hz(message, rate)
        except Exception as e:
            self.print_exception_caught(e)
            ex = e

        # reset message rates to default:
        for message in messages:
            self.set_message_rate_hz(message, -1)

        if ex is not None:
            raise ex

    def assert_message_rate_hz(self, message, want_rate, sample_period=20, ndigits=0, mav=None):
        if mav is None:
            mav = self.mav
        self.drain_mav(mav)
        rate = round(self.measure_message_rate(message, sample_period, mav=mav), ndigits=ndigits)
        self.progress("%s: Want=%f got=%f" % (message, round(want_rate, ndigits=ndigits), round(rate, ndigits=ndigits)))
        if rate != want_rate:
            raise NotAchievedException("Did not get expected rate (want=%f got=%f)" % (want_rate, rate))

    def test_set_message_interval_basic(self):
        ex = None
        try:
            rate = round(self.measure_message_rate("VFR_HUD", 20))
            self.progress("Initial rate: %u" % rate)

            self.test_rate("Test set to %u" % (rate/2,), rate/2, rate/2, victim_message="VFR_HUD")
            # this assumes the streamrates have not been played with:
            self.test_rate("Resetting original rate using 0-value", 0, rate)
            self.test_rate("Disabling using -1-value", -1, 0)
            self.test_rate("Resetting original rate", 0, rate)

            self.progress("try getting a message which is not ordinarily streamed out")
            rate = round(self.measure_message_rate("CAMERA_FEEDBACK", 20))
            if rate != 0:
                raise PreconditionFailedException("Already getting CAMERA_FEEDBACK")
            self.progress("try various message rates")
            for want_rate in range(5, 14):
                self.set_message_rate_hz(mavutil.mavlink.MAVLINK_MSG_ID_CAMERA_FEEDBACK,
                                         want_rate)
                self.assert_message_rate_hz('CAMERA_FEEDBACK', want_rate)

            self.progress("try at the main loop rate")
            # have to reset the speedup as MAVProxy can't keep up otherwise
            old_speedup = self.get_parameter("SIM_SPEEDUP")
            self.set_parameter("SIM_SPEEDUP", 1.0)
            # ArduPilot currently limits message rate to 80% of main loop rate:
            want_rate = self.get_parameter("SCHED_LOOP_RATE") * 0.8
            self.set_message_rate_hz(mavutil.mavlink.MAVLINK_MSG_ID_CAMERA_FEEDBACK,
                                     want_rate)
            rate = round(self.measure_message_rate("CAMERA_FEEDBACK", 20))
            self.set_parameter("SIM_SPEEDUP", old_speedup)
            self.progress("Want=%f got=%f" % (want_rate, rate))
            if abs(rate - want_rate) > 2:
                raise NotAchievedException("Did not get expected rate")

            self.drain_mav()

            non_existant_id = 145
            self.send_get_message_interval(non_existant_id)
            m = self.assert_receive_message('MESSAGE_INTERVAL')
            if m.interval_us != 0:
                raise NotAchievedException("Supposed to get 0 back for unsupported stream")
            m = self.assert_receive_message('COMMAND_ACK')
            if m.result != mavutil.mavlink.MAV_RESULT_FAILED:
                raise NotAchievedException("Getting rate of unsupported message is a failure")

        except Exception as e:
            self.print_exception_caught(e)
            ex = e

        self.progress("Resetting CAMERA_FEEDBACK rate to default rate")
        self.set_message_rate_hz(mavutil.mavlink.MAVLINK_MSG_ID_CAMERA_FEEDBACK, 0)
        self.assert_message_rate_hz('CAMERA_FEEDBACK', 0)

        if ex is not None:
            raise ex

    def send_poll_message(self, message_id, target_sysid=None, target_compid=None, quiet=False, mav=None):
        if mav is None:
            mav = self.mav
        if isinstance(message_id, str):
            message_id = eval("mavutil.mavlink.MAVLINK_MSG_ID_%s" % message_id)
        self.send_cmd(
            mavutil.mavlink.MAV_CMD_REQUEST_MESSAGE,
            p1=message_id,
            target_sysid=target_sysid,
            target_compid=target_compid,
            quiet=quiet,
            mav=mav,
        )

    def poll_message(self, message_id, timeout=10, quiet=False, mav=None, target_sysid=None, target_compid=None):
        if mav is None:
            mav = self.mav
        if target_sysid is None:
            target_sysid = self.sysid_thismav()
        if target_compid is None:
            target_compid = 1
        if isinstance(message_id, str):
            message_id = eval("mavutil.mavlink.MAVLINK_MSG_ID_%s" % message_id)
        tstart = self.get_sim_time() # required for timeout in run_cmd_get_ack to work
        self.send_poll_message(message_id, quiet=quiet, mav=mav, target_sysid=target_sysid, target_compid=target_compid)
        self.run_cmd_get_ack(
            mavutil.mavlink.MAV_CMD_REQUEST_MESSAGE,
            mavutil.mavlink.MAV_RESULT_ACCEPTED,
            timeout,
            quiet=quiet,
            mav=mav,
        )
        while True:
            if self.get_sim_time_cached() - tstart > timeout:
                raise NotAchievedException("Did not receive polled message")
            m = mav.recv_match(blocking=True,
                               timeout=0.1)
            if self.mav != mav:
                self.drain_mav()
            if m is None:
                continue
            if m.id != message_id:
                continue
            if (m.get_srcSystem() != target_sysid or
                    m.get_srcComponent() != target_compid):
                continue
            return m

    def get_messages_frame(self, msg_names):
        '''try to get a "frame" of named messages - a set of messages as close
        in time as possible'''
        msgs = {}

        def get_msgs(mav, m):
            t = m.get_type()
            if t in msg_names:
                msgs[t] = m
        self.do_timesync_roundtrip()
        self.install_message_hook(get_msgs)
        for msg_name in msg_names:
            self.send_poll_message(msg_name)
        while True:
            self.mav.recv_match(blocking=True)
            if len(msgs.keys()) == len(msg_names):
                break

        self.remove_message_hook(get_msgs)

        return msgs

    def REQUEST_MESSAGE(self, timeout=60):
        '''Test MAV_CMD_REQUEST_MESSAGE'''
        self.set_parameter("CAM1_TYPE", 1) # Camera with servo trigger
        self.reboot_sitl() # needed for CAM1_TYPE to take effect
        rate = round(self.measure_message_rate("CAMERA_FEEDBACK", 10))
        if rate != 0:
            raise PreconditionFailedException("Receiving camera feedback")
        self.poll_message("CAMERA_FEEDBACK")

    def clear_mission(self, mission_type, target_system=1, target_component=1):
        '''clear mision_type from autopilot.  Note that this does NOT actually
        send a MISSION_CLEAR_ALL message
        '''
        if mission_type == mavutil.mavlink.MAV_MISSION_TYPE_ALL:
            # recurse
            if not self.is_tracker() and not self.is_blimp():
                self.clear_mission(mavutil.mavlink.MAV_MISSION_TYPE_FENCE)
            if not self.is_blimp():
                self.clear_mission(mavutil.mavlink.MAV_MISSION_TYPE_MISSION)
            if not self.is_sub() and not self.is_tracker() and not self.is_blimp():
                self.clear_mission(mavutil.mavlink.MAV_MISSION_TYPE_RALLY)
            self.last_wp_load = time.time()
            return

        self.mav.mav.mission_count_send(target_system,
                                        target_component,
                                        0,
                                        mission_type)
        self.assert_received_message_field_values('MISSION_ACK', {
            "target_system": self.mav.mav.srcSystem,
            "target_component": self.mav.mav.srcComponent,
            "type": mavutil.mavlink.MAV_MISSION_ACCEPTED,
        })

        if mission_type == mavutil.mavlink.MAV_MISSION_TYPE_MISSION:
            self.last_wp_load = time.time()

    def clear_fence_using_mavproxy(self, mavproxy, timeout=10):
        mavproxy.send("fence clear\n")
        tstart = self.get_sim_time_cached()
        while True:
            now = self.get_sim_time_cached()
            if now - tstart > timeout:
                raise AutoTestTimeoutException("FENCE_TOTAL did not go to zero")
            if self.get_parameter("FENCE_TOTAL") == 0:
                break

    def clear_fence(self):
        self.clear_mission(mavutil.mavlink.MAV_MISSION_TYPE_FENCE)

    # Sub does not instantiate AP_Stats.  Also see https://github.com/ArduPilot/ardupilot/issues/10247  # noqa
    def ConfigErrorLoop(self):
        '''test the sensor config error loop works and that parameter sets are persistent'''
        parameter_name = "SERVO8_MIN"
        old_parameter_value = self.get_parameter(parameter_name)
        old_sim_baro_count = self.get_parameter("SIM_BARO_COUNT")
        new_parameter_value = old_parameter_value + 5
        ex = None
        try:
            self.set_parameter("STAT_BOOTCNT", 0)
            self.set_parameter("SIM_BARO_COUNT", -1)

            if self.is_tracker():
                # starts armed...
                self.progress("Disarming tracker")
                self.disarm_vehicle(force=True)

            self.reboot_sitl(required_bootcount=1)
            self.progress("Waiting for 'Config error'")
            # SYSTEM_TIME not sent in config error loop:
            self.wait_statustext("Config error", wallclock_timeout=True)
            self.progress("Setting %s to %f" % (parameter_name, new_parameter_value))
            self.set_parameter(parameter_name, new_parameter_value)
        except Exception as e:
            ex = e

        self.progress("Resetting SIM_BARO_COUNT")
        self.set_parameter("SIM_BARO_COUNT", old_sim_baro_count)

        if self.is_tracker():
            # starts armed...
            self.progress("Disarming tracker")
            self.disarm_vehicle(force=True)

        self.progress("Calling reboot-sitl ")
        self.reboot_sitl(required_bootcount=2)

        if ex is not None:
            raise ex

        if self.get_parameter(parameter_name) != new_parameter_value:
            raise NotAchievedException("Parameter value did not stick")

    def InitialMode(self):
        '''Test initial mode switching'''
        if self.is_copter():
            init_mode = (9, "LAND")
        if self.is_rover():
            init_mode = (4, "HOLD")
        if self.is_plane():
            init_mode = (13, "TAKEOFF")
        if self.is_tracker():
            init_mode = (1, "STOP")
        if self.is_sub():
            return # NOT Supported yet
        self.context_push()
        self.set_parameter("SIM_RC_FAIL", 1)
        self.progress("Setting INITIAL_MODE to %s" % init_mode[1])
        self.set_parameter("INITIAL_MODE", init_mode[0])
        self.reboot_sitl()
        self.wait_mode(init_mode[1])
        self.progress("Testing back mode switch")
        self.set_parameter("SIM_RC_FAIL", 0)
        self.wait_for_mode_switch_poll()
        self.context_pop()
        self.reboot_sitl()

    def Gripper(self):
        '''Test gripper'''
        self.GripperType(1)  # servo
        self.GripperType(2)  # EPM

    def GripperType(self, gripper_type):
        '''test specific gripper type'''
        self.context_push()
        self.set_parameters({
            "GRIP_ENABLE": 1,
            "GRIP_GRAB": 2000,
            "GRIP_RELEASE": 1000,
            "GRIP_TYPE": gripper_type,
            "SIM_GRPS_ENABLE": 1,
            "SIM_GRPS_PIN": 8,
            "SERVO8_FUNCTION": 28,
            "SERVO8_MIN": 1000,
            "SERVO8_MAX": 2000,
            "SERVO9_MIN": 1000,
            "SERVO9_MAX": 2000,
            "RC9_OPTION": 19,
        })
        self.set_rc(9, 1500)
        self.reboot_sitl()
        self.progress("Waiting for ready to arm")
        self.wait_ready_to_arm()
        self.progress("Test gripper with RC9_OPTION")
        self.progress("Releasing load")
        # non strict string matching because of catching text issue....
        self.context_collect('STATUSTEXT')
        self.set_rc(9, 1000)
        self.wait_text("Gripper load releas", check_context=True)
        self.progress("Grabbing load")
        self.set_rc(9, 2000)
        self.wait_text("Gripper load grabb", check_context=True)
        self.context_clear_collection('STATUSTEXT')
        self.progress("Releasing load")
        self.set_rc(9, 1000)
        self.wait_text("Gripper load releas", check_context=True)
        self.progress("Grabbing load")
        self.set_rc(9, 2000)
        self.wait_text("Gripper load grabb", check_context=True)
        self.progress("Test gripper with Mavlink cmd")

        self.context_collect('STATUSTEXT')
        self.progress("Releasing load")
        self.run_cmd(
            mavutil.mavlink.MAV_CMD_DO_GRIPPER,
            p1=1,
            p2=mavutil.mavlink.GRIPPER_ACTION_RELEASE
        )
        self.wait_text("Gripper load releas", check_context=True)
        self.progress("Grabbing load")
        self.run_cmd(
            mavutil.mavlink.MAV_CMD_DO_GRIPPER,
            p1=1,
            p2=mavutil.mavlink.GRIPPER_ACTION_GRAB
        )
        self.wait_text("Gripper load grabb", check_context=True)

        self.context_clear_collection('STATUSTEXT')
        self.progress("Releasing load")
        self.run_cmd_int(
            mavutil.mavlink.MAV_CMD_DO_GRIPPER,
            p1=1,
            p2=mavutil.mavlink.GRIPPER_ACTION_RELEASE
        )
        self.wait_text("Gripper load releas", check_context=True)

        self.progress("Grabbing load")
        self.run_cmd_int(
            mavutil.mavlink.MAV_CMD_DO_GRIPPER,
            p1=1,
            p2=mavutil.mavlink.GRIPPER_ACTION_GRAB
        )
        self.wait_text("Gripper load grabb", check_context=True)

        self.context_pop()
        self.reboot_sitl()

    def TestLocalHomePosition(self):
        """Test local home position is sent in HOME_POSITION message"""
        self.context_push()
        self.wait_ready_to_arm()

        # set home to a new location
        self.mav.mav.command_long_send(1,
                                       1,
                                       mavutil.mavlink.MAV_CMD_DO_SET_HOME,
                                       0,
                                       0,
                                       0,
                                       0,
                                       0,
                                       -35.357466,
                                       149.142589,
                                       630)

        # check home after home set
        m = self.assert_receive_message("HOME_POSITION", timeout=5)
        if abs(m.x) < 10 or abs(m.y) < 10 or abs(m.z) < 10:
            raise NotAchievedException("Failed to get local home position: (got=%u, %u, %u)", m.x, m.y, m.z)
        else:
            self.progress("Received local home position successfully: (got=%f, %f, %f)" %
                          (m.x, m.y, m.z))

        self.context_pop()
        self.reboot_sitl()

    def install_terrain_handlers_context(self):
        '''install a message handler into the current context which will
        listen for an fulfill terrain requests from ArduPilot.  Will
        die if the data is not available - but
        self.terrain_in_offline_mode can be set to true in the
        constructor to change this behaviour
        '''

        def check_terrain_requests(mav, m):
            if m.get_type() != 'TERRAIN_REQUEST':
                return
            self.progress("Processing TERRAIN_REQUEST (%s)" %
                          self.dump_message_verbose(m))
            # swiped from mav_terrain.py
            for bit in range(56):
                if m.mask & (1 << bit) == 0:
                    continue

                lat = m.lat * 1.0e-7
                lon = m.lon * 1.0e-7
                bit_spacing = m.grid_spacing * 4
                (lat, lon) = mp_util.gps_offset(lat, lon,
                                                east=bit_spacing * (bit % 8),
                                                north=bit_spacing * (bit // 8))
                data = []
                for i in range(4*4):
                    y = i % 4
                    x = i // 4
                    (lat2, lon2) = mp_util.gps_offset(lat, lon,
                                                      east=m.grid_spacing * y,
                                                      north=m.grid_spacing * x)
                    # if we are in online mode then we'll try to fetch
                    # from the internet into the cache dir:
                    for i in range(120):
                        alt = self.elevationmodel.GetElevation(lat2, lon2)
                        if alt is not None:
                            break
                        if self.terrain_in_offline_mode:
                            break
                        self.progress("No elevation data for (%f %f); retry" %
                                      (lat2, lon2))
                        time.sleep(1)
                    if alt is None:
                        # no data - we can't send the packet
                        raise ValueError("No elevation data for (%f %f)" % (lat2, lon2))
                    data.append(int(alt))
                self.terrain_data_messages_sent += 1
                self.mav.mav.terrain_data_send(m.lat,
                                               m.lon,
                                               m.grid_spacing,
                                               bit,
                                               data)

        self.install_message_hook_context(check_terrain_requests)

    def install_messageprinter_handlers_context(self, messages):
        '''monitor incoming messages, print them out'''
        def check_messages(mav, m):
            if m.get_type() not in messages:
                return
            self.progress(self.dump_message_verbose(m))

        self.install_message_hook_context(check_messages)

    def SetpointGlobalPos(self, timeout=100):
        """Test set position message in guided mode."""
        # Disable heading and yaw test on rover type

        if self.is_rover():
            test_alt = True
            test_heading = False
            test_yaw_rate = False
        else:
            test_alt = True
            test_heading = True
            test_yaw_rate = True

        self.install_terrain_handlers_context()

        self.set_parameter("FS_GCS_ENABLE", 0)
        self.change_mode("GUIDED")
        self.wait_ready_to_arm()
        self.arm_vehicle()

        if self.is_copter() or self.is_heli():
            self.user_takeoff(alt_min=50)

        targetpos = self.mav.location()
        wp_accuracy = None
        if self.is_copter() or self.is_heli():
            wp_accuracy = self.get_parameter("WPNAV_RADIUS", attempts=2)
            wp_accuracy = wp_accuracy * 0.01  # cm to m
        if self.is_plane() or self.is_rover():
            wp_accuracy = self.get_parameter("WP_RADIUS", attempts=2)
        if wp_accuracy is None:
            raise ValueError()

        def to_alt_frame(alt, mav_frame):
            if mav_frame in ["MAV_FRAME_GLOBAL_RELATIVE_ALT",
                             "MAV_FRAME_GLOBAL_RELATIVE_ALT_INT",
                             "MAV_FRAME_GLOBAL_TERRAIN_ALT",
                             "MAV_FRAME_GLOBAL_TERRAIN_ALT_INT"]:
                home = self.home_position_as_mav_location()
                return alt - home.alt
            else:
                return alt

        def send_target_position(lat, lng, alt, mav_frame):
            self.mav.mav.set_position_target_global_int_send(
                0,  # timestamp
                self.sysid_thismav(),  # target system_id
                1,  # target component id
                mav_frame,
                MAV_POS_TARGET_TYPE_MASK.VEL_IGNORE |
                MAV_POS_TARGET_TYPE_MASK.ACC_IGNORE |
                MAV_POS_TARGET_TYPE_MASK.YAW_IGNORE |
                MAV_POS_TARGET_TYPE_MASK.YAW_RATE_IGNORE,
                int(lat * 1.0e7),  # lat
                int(lng * 1.0e7),  # lon
                alt,  # alt
                0,  # vx
                0,  # vy
                0,  # vz
                0,  # afx
                0,  # afy
                0,  # afz
                0,  # yaw
                0,  # yawrate
            )

        def testpos(self, targetpos : mavutil.location, test_alt : bool, frame_name : str, frame):
            send_target_position(targetpos.lat, targetpos.lng, to_alt_frame(targetpos.alt, frame_name), frame)
            self.wait_location(
                targetpos,
                accuracy=wp_accuracy,
                timeout=timeout,
                height_accuracy=(2 if test_alt else None),
                minimum_duration=2,
            )

        for frame in MAV_FRAMES_TO_TEST:
            frame_name = mavutil.mavlink.enums["MAV_FRAME"][frame].name
            self.start_subtest("Testing Set Position in %s" % frame_name)
            self.start_subtest("Changing Latitude")
            targetpos.lat += 0.0001
            if test_alt:
                targetpos.alt += 5
            testpos(self, targetpos, test_alt, frame_name, frame)

            self.start_subtest("Changing Longitude")
            targetpos.lng += 0.0001
            if test_alt:
                targetpos.alt -= 5
            testpos(self, targetpos, test_alt, frame_name, frame)

            self.start_subtest("Revert Latitude")
            targetpos.lat -= 0.0001
            if test_alt:
                targetpos.alt += 5
            testpos(self, targetpos, test_alt, frame_name, frame)

            self.start_subtest("Revert Longitude")
            targetpos.lng -= 0.0001
            if test_alt:
                targetpos.alt -= 5
            testpos(self, targetpos, test_alt, frame_name, frame)

            if test_heading:
                self.start_subtest("Testing Yaw targetting in %s" % frame_name)
                self.progress("Changing Latitude and Heading")
                targetpos.lat += 0.0001
                if test_alt:
                    targetpos.alt += 5
                self.mav.mav.set_position_target_global_int_send(
                    0,  # timestamp
                    self.sysid_thismav(),  # target system_id
                    1,  # target component id
                    frame,
                    MAV_POS_TARGET_TYPE_MASK.VEL_IGNORE |
                    MAV_POS_TARGET_TYPE_MASK.ACC_IGNORE |
                    MAV_POS_TARGET_TYPE_MASK.YAW_RATE_IGNORE,
                    int(targetpos.lat * 1.0e7),  # lat
                    int(targetpos.lng * 1.0e7),  # lon
                    to_alt_frame(targetpos.alt, frame_name),  # alt
                    0,  # vx
                    0,  # vy
                    0,  # vz
                    0,  # afx
                    0,  # afy
                    0,  # afz
                    math.radians(42),  # yaw
                    0,  # yawrate
                )
                self.wait_location(
                    targetpos,
                    accuracy=wp_accuracy,
                    timeout=timeout,
                    height_accuracy=(2 if test_alt else None),
                    minimum_duration=2,
                )
                self.wait_heading(42, minimum_duration=5, timeout=timeout)

                self.start_subtest("Revert Latitude and Heading")
                targetpos.lat -= 0.0001
                if test_alt:
                    targetpos.alt -= 5
                self.mav.mav.set_position_target_global_int_send(
                    0,  # timestamp
                    self.sysid_thismav(),  # target system_id
                    1,  # target component id
                    frame,
                    MAV_POS_TARGET_TYPE_MASK.VEL_IGNORE |
                    MAV_POS_TARGET_TYPE_MASK.ACC_IGNORE |
                    MAV_POS_TARGET_TYPE_MASK.YAW_RATE_IGNORE,
                    int(targetpos.lat * 1.0e7),  # lat
                    int(targetpos.lng * 1.0e7),  # lon
                    to_alt_frame(targetpos.alt, frame_name),  # alt
                    0,  # vx
                    0,  # vy
                    0,  # vz
                    0,  # afx
                    0,  # afy
                    0,  # afz
                    math.radians(0),  # yaw
                    0,  # yawrate
                )
                self.wait_location(
                    targetpos,
                    accuracy=wp_accuracy,
                    timeout=timeout,
                    height_accuracy=(2 if test_alt else None),
                    minimum_duration=2,
                )
                self.wait_heading(0, minimum_duration=5, timeout=timeout)

            if test_yaw_rate:
                self.start_subtest("Testing Yaw Rate targetting in %s" % frame_name)

                def send_yaw_rate(rate, target=None):
                    self.mav.mav.set_position_target_global_int_send(
                        0,  # timestamp
                        self.sysid_thismav(),  # target system_id
                        1,  # target component id
                        frame,
                        MAV_POS_TARGET_TYPE_MASK.VEL_IGNORE |
                        MAV_POS_TARGET_TYPE_MASK.ACC_IGNORE |
                        MAV_POS_TARGET_TYPE_MASK.YAW_IGNORE,
                        int(targetpos.lat * 1.0e7),  # lat
                        int(targetpos.lng * 1.0e7),  # lon
                        to_alt_frame(targetpos.alt, frame_name),  # alt
                        0,  # vx
                        0,  # vy
                        0,  # vz
                        0,  # afx
                        0,  # afy
                        0,  # afz
                        0,  # yaw
                        rate,  # yawrate in rad/s
                    )

                self.start_subtest("Changing Latitude and Yaw rate")
                target_rate = 1.0  # in rad/s
                targetpos.lat += 0.0001
                if test_alt:
                    targetpos.alt += 5
                self.wait_yaw_speed(target_rate, timeout=timeout,
                                    called_function=lambda plop, empty: send_yaw_rate(
                                        target_rate, None), minimum_duration=5)
                self.wait_location(
                    targetpos,
                    accuracy=wp_accuracy,
                    timeout=timeout,
                    height_accuracy=(2 if test_alt else None),
                )

                self.start_subtest("Revert Latitude and invert Yaw rate")
                target_rate = -1.0
                targetpos.lat -= 0.0001
                if test_alt:
                    targetpos.alt -= 5
                self.wait_yaw_speed(target_rate, timeout=timeout,
                                    called_function=lambda plop, empty: send_yaw_rate(
                                        target_rate, None), minimum_duration=5)
                self.wait_location(
                    targetpos,
                    accuracy=wp_accuracy,
                    timeout=timeout,
                    height_accuracy=(2 if test_alt else None),
                )
                self.start_subtest("Changing Yaw rate to zero")
                target_rate = 0.0
                self.wait_yaw_speed(target_rate, timeout=timeout,
                                    called_function=lambda plop, empty: send_yaw_rate(
                                        target_rate, None), minimum_duration=5)

        self.progress("Getting back to home and disarm")
        self.do_RTL(distance_min=0, distance_max=wp_accuracy)
        self.disarm_vehicle()

    def SetpointBadVel(self, timeout=30):
        '''try feeding in a very, very bad velocity and make sure it is ignored'''
        self.takeoff(mode='GUIDED')
        # following values from a real log:
        target_speed = Vector3(-3.6019095525029597e+30,
                               1.7796490496925177e-41,
                               3.0557017120313744e-26)

        self.progress("Feeding in bad global data, hoping we don't move")

        def send_speed_vector_global_int(vector , mav_frame):
            self.mav.mav.set_position_target_global_int_send(
                0,  # timestamp
                self.sysid_thismav(),  # target system_id
                1,  # target component id
                mav_frame,
                MAV_POS_TARGET_TYPE_MASK.POS_IGNORE |
                MAV_POS_TARGET_TYPE_MASK.ACC_IGNORE |
                MAV_POS_TARGET_TYPE_MASK.YAW_IGNORE |
                MAV_POS_TARGET_TYPE_MASK.YAW_RATE_IGNORE,
                0,
                0,
                0,
                vector.x,  # vx
                vector.y,  # vy
                vector.z,  # vz
                0,  # afx
                0,  # afy
                0,  # afz
                0,  # yaw
                0,  # yawrate
            )
        self.wait_speed_vector(
            Vector3(0, 0, 0),
            timeout=timeout,
            called_function=lambda plop, empty: send_speed_vector_global_int(target_speed, mavutil.mavlink.MAV_FRAME_GLOBAL_RELATIVE_ALT),  # noqa
            minimum_duration=10
        )

        self.progress("Feeding in bad local data, hoping we don't move")

        def send_speed_vector_local_ned(vector , mav_frame):
            self.mav.mav.set_position_target_local_ned_send(
                0,  # timestamp
                self.sysid_thismav(),  # target system_id
                1,  # target component id
                mav_frame,
                MAV_POS_TARGET_TYPE_MASK.POS_IGNORE |
                MAV_POS_TARGET_TYPE_MASK.ACC_IGNORE |
                MAV_POS_TARGET_TYPE_MASK.YAW_IGNORE |
                MAV_POS_TARGET_TYPE_MASK.YAW_RATE_IGNORE,
                0,
                0,
                0,
                vector.x,  # vx
                vector.y,  # vy
                vector.z,  # vz
                0,  # afx
                0,  # afy
                0,  # afz
                0,  # yaw
                0,  # yawrate
            )
        self.wait_speed_vector(
            Vector3(0, 0, 0),
            timeout=timeout,
            called_function=lambda plop, empty: send_speed_vector_local_ned(target_speed, mavutil.mavlink.MAV_FRAME_LOCAL_NED),  # noqa
            minimum_duration=10
        )

        self.do_RTL()

    def SetpointGlobalVel(self, timeout=30):
        """Test set position message in guided mode."""
        # Disable heading and yaw rate test on rover type
        if self.is_rover():
            test_vz = False
            test_heading = False
            test_yaw_rate = False
        else:
            test_vz = True
            test_heading = True
            test_yaw_rate = True

        self.install_terrain_handlers_context()

        self.set_parameter("FS_GCS_ENABLE", 0)
        self.change_mode("GUIDED")
        self.wait_ready_to_arm()
        self.arm_vehicle()

        if self.is_copter() or self.is_heli():
            self.user_takeoff(alt_min=50)

        target_speed = Vector3(1.0, 0.0, 0.0)

        wp_accuracy = None
        if self.is_copter() or self.is_heli():
            wp_accuracy = self.get_parameter("WPNAV_RADIUS", attempts=2)
            wp_accuracy = wp_accuracy * 0.01  # cm to m
        if self.is_plane() or self.is_rover():
            wp_accuracy = self.get_parameter("WP_RADIUS", attempts=2)
        if wp_accuracy is None:
            raise ValueError()

        def send_speed_vector(vector, mav_frame):
            self.mav.mav.set_position_target_global_int_send(
                0,  # timestamp
                self.sysid_thismav(),  # target system_id
                1,  # target component id
                mav_frame,
                MAV_POS_TARGET_TYPE_MASK.POS_IGNORE |
                MAV_POS_TARGET_TYPE_MASK.ACC_IGNORE |
                MAV_POS_TARGET_TYPE_MASK.YAW_IGNORE |
                MAV_POS_TARGET_TYPE_MASK.YAW_RATE_IGNORE,
                0,
                0,
                0,
                vector.x,  # vx
                vector.y,  # vy
                vector.z,  # vz
                0,  # afx
                0,  # afy
                0,  # afz
                0,  # yaw
                0,  # yawrate
            )

        for frame in MAV_FRAMES_TO_TEST:
            frame_name = mavutil.mavlink.enums["MAV_FRAME"][frame].name
            self.start_subtest("Testing Set Velocity in %s" % frame_name)
            self.progress("Changing Vx speed")
            self.wait_speed_vector(
                target_speed,
                timeout=timeout,
                called_function=lambda plop, empty: send_speed_vector(target_speed, frame),
                minimum_duration=2
            )

            self.start_subtest("Add Vy speed")
            target_speed.y = 1.0
            self.wait_speed_vector(
                target_speed,
                timeout=timeout,
                called_function=lambda plop, empty: send_speed_vector(target_speed, frame),
                minimum_duration=2)

            self.start_subtest("Add Vz speed")
            if test_vz:
                target_speed.z = 1.0
            else:
                target_speed.z = 0.0
            self.wait_speed_vector(
                target_speed,
                timeout=timeout,
                called_function=lambda plop, empty: send_speed_vector(target_speed, frame),
                minimum_duration=2
            )

            self.start_subtest("Invert Vz speed")
            if test_vz:
                target_speed.z = -1.0
            else:
                target_speed.z = 0.0
            self.wait_speed_vector(
                target_speed,
                timeout=timeout,
                called_function=lambda plop, empty: send_speed_vector(target_speed, frame), minimum_duration=2
            )

            self.start_subtest("Invert Vx speed")
            target_speed.x = -1.0
            self.wait_speed_vector(
                target_speed,
                timeout=timeout,
                called_function=lambda plop, empty: send_speed_vector(target_speed, frame),
                minimum_duration=2
            )

            self.start_subtest("Invert Vy speed")
            target_speed.y = -1.0
            self.wait_speed_vector(
                target_speed,
                timeout=timeout,
                called_function=lambda plop, empty: send_speed_vector(target_speed, frame),
                minimum_duration=2
            )

            self.start_subtest("Set Speed to zero")
            target_speed.x = 0.0
            target_speed.y = 0.0
            target_speed.z = 0.0
            self.wait_speed_vector(
                target_speed,
                timeout=timeout,
                called_function=lambda plop, empty: send_speed_vector(target_speed, frame),
                minimum_duration=2
            )

            if test_heading:
                self.start_subtest("Testing Yaw targetting in %s" % frame_name)

                def send_yaw_target(yaw, mav_frame):
                    self.mav.mav.set_position_target_global_int_send(
                        0,  # timestamp
                        self.sysid_thismav(),  # target system_id
                        1,  # target component id
                        mav_frame,
                        MAV_POS_TARGET_TYPE_MASK.POS_IGNORE |
                        MAV_POS_TARGET_TYPE_MASK.ACC_IGNORE |
                        MAV_POS_TARGET_TYPE_MASK.YAW_RATE_IGNORE,
                        0,
                        0,
                        0,
                        0,  # vx
                        0,  # vy
                        0,  # vz
                        0,  # afx
                        0,  # afy
                        0,  # afz
                        math.radians(yaw),  # yaw
                        0,  # yawrate
                    )

                target_speed.x = 1.0
                target_speed.y = 1.0
                if test_vz:
                    target_speed.z = -1.0
                else:
                    target_speed.z = 0.0

                def send_yaw_target_vel(yaw, vector, mav_frame):
                    self.mav.mav.set_position_target_global_int_send(
                        0,  # timestamp
                        self.sysid_thismav(),  # target system_id
                        1,  # target component id
                        mav_frame,
                        MAV_POS_TARGET_TYPE_MASK.POS_IGNORE |
                        MAV_POS_TARGET_TYPE_MASK.ACC_IGNORE |
                        MAV_POS_TARGET_TYPE_MASK.YAW_RATE_IGNORE,
                        0,
                        0,
                        0,
                        vector.x,  # vx
                        vector.y,  # vy
                        vector.z,  # vz
                        0,  # afx
                        0,  # afy
                        0,  # afz
                        math.radians(yaw),  # yaw
                        0,  # yawrate
                    )

                self.start_subtest("Target a fixed Heading")
                target_yaw = 42.0
                self.wait_heading(target_yaw, minimum_duration=5, timeout=timeout,
                                  called_function=lambda plop, empty: send_yaw_target(target_yaw, frame))

                self.start_subtest("Set target Heading")
                target_yaw = 0.0
                self.wait_heading(target_yaw, minimum_duration=5, timeout=timeout,
                                  called_function=lambda plop, empty: send_yaw_target(target_yaw, frame))

                self.start_subtest("Add Vx, Vy, Vz speed and target a fixed Heading")
                target_yaw = 42.0
                self.wait_heading(
                    target_yaw,
                    minimum_duration=5,
                    timeout=timeout,
                    called_function=lambda p, e: send_yaw_target_vel(target_yaw,
                                                                     target_speed,
                                                                     frame)
                )
                self.wait_speed_vector(
                    target_speed,
                    called_function=lambda p, e: send_yaw_target_vel(target_yaw,
                                                                     target_speed,
                                                                     frame)
                )

                self.start_subtest("Stop Vx, Vy, Vz speed and target zero Heading")
                target_yaw = 0.0
                target_speed.x = 0.0
                target_speed.y = 0.0
                target_speed.z = 0.0
                self.wait_heading(target_yaw, minimum_duration=5, timeout=timeout,
                                  called_function=lambda plop, empty: send_yaw_target_vel(target_yaw, target_speed, frame))
                self.wait_speed_vector(
                    target_speed,
                    timeout=timeout,
                    called_function=lambda p, ee: send_yaw_target_vel(target_yaw,
                                                                      target_speed,
                                                                      frame),
                    minimum_duration=2
                )

            if test_yaw_rate:
                self.start_subtest("Testing Yaw Rate targetting in %s" % frame_name)

                def send_yaw_rate(rate, mav_frame):
                    self.mav.mav.set_position_target_global_int_send(
                        0,  # timestamp
                        self.sysid_thismav(),  # target system_id
                        1,  # target component id
                        mav_frame,
                        MAV_POS_TARGET_TYPE_MASK.POS_IGNORE |
                        MAV_POS_TARGET_TYPE_MASK.ACC_IGNORE |
                        MAV_POS_TARGET_TYPE_MASK.YAW_IGNORE,
                        0,
                        0,
                        0,
                        0,  # vx
                        0,  # vy
                        0,  # vz
                        0,  # afx
                        0,  # afy
                        0,  # afz
                        0,  # yaw
                        rate,  # yawrate in rad/s
                    )

                target_speed.x = 1.0
                target_speed.y = 1.0
                if test_vz:
                    target_speed.z = -1.0
                else:
                    target_speed.z = 0.0

                def send_yaw_rate_vel(rate, vector, mav_frame):
                    self.mav.mav.set_position_target_global_int_send(
                        0,  # timestamp
                        self.sysid_thismav(),  # target system_id
                        1,  # target component id
                        mav_frame,
                        MAV_POS_TARGET_TYPE_MASK.POS_IGNORE |
                        MAV_POS_TARGET_TYPE_MASK.ACC_IGNORE |
                        MAV_POS_TARGET_TYPE_MASK.YAW_IGNORE,
                        0,
                        0,
                        0,
                        vector.x,  # vx
                        vector.y,  # vy
                        vector.z,  # vz
                        0,  # afx
                        0,  # afy
                        0,  # afz
                        0,  # yaw
                        rate,  # yawrate in rad/s
                    )

                self.start_subtest("Set Yaw rate")
                target_rate = 1.0
                self.wait_yaw_speed(target_rate, timeout=timeout,
                                    called_function=lambda plop, empty: send_yaw_rate(target_rate, frame), minimum_duration=2)

                self.start_subtest("Invert Yaw rate")
                target_rate = -1.0
                self.wait_yaw_speed(target_rate, timeout=timeout,
                                    called_function=lambda plop, empty: send_yaw_rate(target_rate, frame), minimum_duration=2)

                self.start_subtest("Stop Yaw rate")
                target_rate = 0.0
                self.wait_yaw_speed(target_rate, timeout=timeout,
                                    called_function=lambda plop, empty: send_yaw_rate(target_rate, frame), minimum_duration=2)

                self.start_subtest("Set Yaw Rate and Vx, Vy, Vz speed")
                target_rate = 1.0
                self.wait_yaw_speed(
                    target_rate,
                    called_function=lambda p, e: send_yaw_rate_vel(target_rate,
                                                                   target_speed,
                                                                   frame),
                    minimum_duration=2
                )
                self.wait_speed_vector(
                    target_speed,
                    timeout=timeout,
                    called_function=lambda p, e: send_yaw_rate_vel(target_rate,
                                                                   target_speed,
                                                                   frame),
                    minimum_duration=2
                )

                target_rate = -1.0
                target_speed.x = -1.0
                target_speed.y = -1.0
                if test_vz:
                    target_speed.z = 1.0
                else:
                    target_speed.z = 0.0
                self.start_subtest("Invert Vx, Vy, Vz speed")
                self.wait_yaw_speed(
                    target_rate,
                    timeout=timeout,
                    called_function=lambda p, e: send_yaw_rate_vel(target_rate,
                                                                   target_speed,
                                                                   frame),
                    minimum_duration=2
                )
                self.wait_speed_vector(
                    target_speed,
                    timeout=timeout,
                    called_function=lambda p, e: send_yaw_rate_vel(target_rate,
                                                                   target_speed,
                                                                   frame),
                    minimum_duration=2
                )

                target_rate = 0.0
                target_speed.x = 0.0
                target_speed.y = 0.0
                target_speed.z = 0.0
                self.start_subtest("Stop Yaw rate and all speed")
                self.wait_yaw_speed(
                    target_rate,
                    timeout=timeout,
                    called_function=lambda p, e: send_yaw_rate_vel(target_rate,
                                                                   target_speed,
                                                                   frame),
                    minimum_duration=2
                )
                self.wait_speed_vector(
                    target_speed,
                    timeout=timeout,
                    called_function=lambda p, e: send_yaw_rate_vel(target_rate,
                                                                   target_speed,
                                                                   frame),
                    minimum_duration=2
                )

        self.progress("Getting back to home and disarm")
        self.do_RTL(distance_min=0, distance_max=wp_accuracy)
        self.disarm_vehicle()

    def is_blimp(self):
        return False

    def is_copter(self):
        return False

    def is_sub(self):
        return False

    def is_plane(self):
        return False

    def is_rover(self):
        return False

    def is_balancebot(self):
        return False

    def is_heli(self):
        return False

    def is_tracker(self):
        return False

    def initial_mode(self):
        '''return mode vehicle should start in with no RC inputs set'''
        return None

    def initial_mode_switch_mode(self):
        '''return mode vehicle should start in with default RC inputs set'''
        return None

    def upload_fences_from_locations(self, fences, target_system=1, target_component=1):
        seq = 0
        items = []

        for (vertex_type, locs) in fences:
            if isinstance(locs, dict):
                # circular fence
                item = self.mav.mav.mission_item_int_encode(
                    target_system,
                    target_component,
                    seq, # seq
                    mavutil.mavlink.MAV_FRAME_GLOBAL,
                    vertex_type,
                    0, # current
                    0, # autocontinue
                    locs["radius"], # p1
                    0, # p2
                    0, # p3
                    0, # p4
                    int(locs["loc"].lat * 1e7), # latitude
                    int(locs["loc"].lng * 1e7), # longitude
                    33.0000, # altitude
                    mavutil.mavlink.MAV_MISSION_TYPE_FENCE)
                seq += 1
                items.append(item)
                continue
            count = len(locs)
            for loc in locs:
                item = self.mav.mav.mission_item_int_encode(
                    target_system,
                    target_component,
                    seq, # seq
                    mavutil.mavlink.MAV_FRAME_GLOBAL,
                    vertex_type,
                    0, # current
                    0, # autocontinue
                    count, # p1
                    0, # p2
                    0, # p3
                    0, # p4
                    int(loc.lat * 1e7), # latitude
                    int(loc.lng * 1e7), # longitude
                    33.0000, # altitude
                    mavutil.mavlink.MAV_MISSION_TYPE_FENCE)
                seq += 1
                items.append(item)

        self.check_fence_upload_download(items)

    def rally_MISSION_ITEM_INT_from_loc(self, loc):
        return self.create_MISSION_ITEM_INT(
            mavutil.mavlink.MAV_CMD_NAV_RALLY_POINT,
            x=int(loc.lat*1e7),
            y=int(loc.lng*1e7),
            z=loc.alt,
            frame=mavutil.mavlink.MAV_FRAME_GLOBAL_RELATIVE_ALT,
            mission_type=mavutil.mavlink.MAV_MISSION_TYPE_RALLY
        )

    def upload_rally_points_from_locations(self, rally_point_locs):
        '''takes a sequence of locations, sets vehicle rally points to those locations'''
        items = [self.rally_MISSION_ITEM_INT_from_loc(x) for x in rally_point_locs]
        self.correct_wp_seq_numbers(items)
        self.check_rally_upload_download(items)

    def wait_for_initial_mode(self):
        '''wait until we get a heartbeat with an expected initial mode (the
one specified in the vehicle constructor)'''
        want = self.initial_mode()
        if want is None:
            return
        self.progress("Waiting for initial mode %s" % want)
        self.wait_mode(want)

    def wait_for_mode_switch_poll(self):
        '''look for a transition from boot-up-mode (e.g. the flightmode
specificied in Copter's constructor) to the one specified by the mode
switch value'''
        want = self.initial_mode_switch_mode()
        if want is None:
            return
        self.progress("Waiting for mode-switch mode %s" % want)
        self.wait_mode(want)

    def start_subtest(self, description):
        self.progress("-")
        self.progress("---------- %s  ----------" % description)
        self.progress("-")

    def start_subsubtest(self, description):
        self.progress(".")
        self.progress(".......... %s  .........." % description)
        self.progress(".")

    def end_subtest(self, description):
        '''TODO: sanity checks?'''
        pass

    def end_subsubtest(self, description):
        '''TODO: sanity checks?'''
        pass

    def last_onboard_log(self):
        '''return number of last onboard log'''
        mavproxy = self.start_mavproxy()
        mavproxy.send("module load log\n")
        loaded_module = False
        mavproxy.expect(["Loaded module log", "module log already loaded"])
        if mavproxy.match.group(0) == "Loaded module log":
            loaded_module = True
        mavproxy.send("log list\n")
        mavproxy.expect(["lastLog ([0-9]+)", "No logs"])
        if mavproxy.match.group(0) == "No logs":
            num_log = None
        else:
            num_log = int(mavproxy.match.group(1))
        if loaded_module:
            mavproxy.send("module unload log\n")
            mavproxy.expect("Unloaded module log")
        self.stop_mavproxy(mavproxy)
        return num_log

    def current_onboard_log_filepath(self):
        '''return filepath to currently open dataflash log.  We assume that's
        the latest log...'''
        logs = self.log_list()
        latest = logs[-1]
        return latest

    def dfreader_for_path(self, path):
        return DFReader.DFReader_binary(path,
                                        zero_time_base=True)

    def dfreader_for_current_onboard_log(self):
        return self.dfreader_for_path(self.current_onboard_log_filepath())

    def current_onboard_log_contains_message(self, messagetype):
        self.progress("Checking (%s) for (%s)" %
                      (self.current_onboard_log_filepath(), messagetype))
        dfreader = self.dfreader_for_current_onboard_log()
        m = dfreader.recv_match(type=messagetype)
        print("m=%s" % str(m))
        return m is not None

    def assert_current_onboard_log_contains_message(self, messagetype):
        if not self.current_onboard_log_contains_message(messagetype):
            raise NotAchievedException("Current onboard log does not contain message %s" % messagetype)

    def run_tests(self, tests) -> List[Result]:
        """Autotest vehicle in SITL."""
        if self.run_tests_called:
            raise ValueError("run_tests called twice")
        self.run_tests_called = True

        result_list = []

        try:
            self.init()

            self.progress("Waiting for a heartbeat with mavlink protocol %s"
                          % self.mav.WIRE_PROTOCOL_VERSION)
            self.wait_heartbeat()
            self.wait_for_initial_mode()
            self.progress("Setting up RC parameters")
            self.set_rc_default()
            self.wait_for_mode_switch_poll()
            if not self.is_tracker(): # FIXME - more to the point, fix Tracker's mission handling
                self.clear_mission(mavutil.mavlink.MAV_MISSION_TYPE_ALL)

            for test in tests:
                self.drain_mav_unparsed()
                result_list.append(self.run_one_test(test))

        except pexpect.TIMEOUT:
            self.progress("Failed with timeout")
            result = Result(test)
            result.passed = False
            result.reason = "Failed with timeout"
            result_list.append(result)
            if self.logs_dir:
                if glob.glob("core*") or glob.glob("ap-*.core"):
                    self.check_logs("FRAMEWORK")

        if self.rc_thread is not None:
            self.progress("Joining RC thread")
            self.rc_thread_should_quit = True
            self.rc_thread.join()
            self.rc_thread = None

        if self.mav is not None:
            self.mav.close()
            self.mav = None

        self.stop_SITL()

        valgrind_log = util.valgrind_log_filepath(binary=self.binary,
                                                  model=self.frame)
        files = glob.glob("*" + valgrind_log)
        valgrind_failed = False
        for valgrind_log in files:
            os.chmod(valgrind_log, 0o644)
            if os.path.getsize(valgrind_log) > 0:
                target = self.buildlogs_path("%s-%s" % (
                    self.log_name(),
                    os.path.basename(valgrind_log)))
                self.progress("Valgrind log: moving %s to %s" % (valgrind_log, target))
                shutil.move(valgrind_log, target)
                valgrind_failed = True
        if valgrind_failed:
            result_list.append(ValgrindFailedResult())

        return result_list

    def dictdiff(self, dict1, dict2):
        fred = copy.copy(dict1)
        for key in dict2.keys():
            try:
                del fred[key]
            except KeyError:
                pass
        return fred

    # download parameters tries to cope with its download being
    # interrupted or broken by simply retrying the download a few
    # times.
    def download_parameters(self, target_system, target_component):
        # try a simple fetch-all:
        last_parameter_received = 0
        attempt_count = 0
        start_done = False
        # make flake8 happy:
        count = 0
        expected_count = 0
        seen_ids = {}
        self.progress("Downloading parameters")
        while True:
            now = self.get_sim_time_cached()
            if not start_done or now - last_parameter_received > 10:
                start_done = True
                if attempt_count > 3:
                    raise AutoTestTimeoutException("Failed to download parameters  (have %s/%s) (seen_ids-count=%u)" %
                                                   (str(count), str(expected_count), len(seen_ids.keys())))
                elif attempt_count != 0:
                    self.progress("Download failed; retrying")
                    self.delay_sim_time(1)
                self.drain_mav()
                self.mav.mav.param_request_list_send(target_system, target_component)
                attempt_count += 1
                count = 0
                expected_count = None
                seen_ids = {}
                id_seq = {}
            m = self.mav.recv_match(type='PARAM_VALUE', blocking=True, timeout=10)
            if m is None:
                raise AutoTestTimeoutException("tardy PARAM_VALUE (have %s/%s)" % (
                    str(count), str(expected_count)))
            if m.param_index == 65535:
                self.progress("volunteered parameter: %s" % str(m))
                continue
            if False:
                self.progress("  received (%4u/%4u %s=%f" %
                              (m.param_index, m.param_count, m.param_id, m.param_value))
            if m.param_index >= m.param_count:
                raise ValueError("parameter index (%u) gte parameter count (%u)" %
                                 (m.param_index, m.param_count))
            if expected_count is None:
                expected_count = m.param_count
            else:
                if m.param_count != expected_count:
                    raise ValueError("expected count changed")
            if m.param_id not in seen_ids:
                count += 1
                seen_ids[m.param_id] = m.param_value
                last_parameter_received = now
                if count == expected_count:
                    break

        self.progress("Downloaded %u parameters OK (attempt=%u)" %
                      (count, attempt_count))
        return (seen_ids, id_seq)

    def test_parameters_download(self):
        self.start_subtest("parameter download")
        target_system = self.sysid_thismav()
        target_component = 1
        self.progress("First Download:")
        (parameters, seq_id) = self.download_parameters(target_system, target_component)
        self.reboot_sitl()
        self.progress("Second download:")
        (parameters2, seq2_id) = self.download_parameters(target_system, target_component)

        delta = self.dictdiff(parameters, parameters2)
        if len(delta) != 0:
            raise ValueError("Got %u fewer parameters when downloading second time (before=%u vs after=%u) (delta=%s)" %
                             (len(delta), len(parameters), len(parameters2), str(delta.keys())))

        delta = self.dictdiff(parameters2, parameters)
        if len(delta) != 0:
            raise ValueError("Got %u extra parameters when downloading second time (before=%u vs after=%u) (delta=%s)" %
                             (len(delta), len(parameters), len(parameters2), str(delta.keys())))

        self.end_subsubtest("parameter download")

    def test_enable_parameter(self):
        self.start_subtest("enable parameters")
        target_system = 1
        target_component = 1
        parameters = self.download_parameters(target_system, target_component)
        enable_parameter = self.sample_enable_parameter()
        if enable_parameter is None:
            self.progress("Skipping enable parameter check as no enable parameter supplied")
            return
        self.set_parameter(enable_parameter, 1)
        parameters2 = self.download_parameters(target_system, target_component)
        if len(parameters) == len(parameters2):
            raise NotAchievedException("Enable parameter did not increase no of parameters downloaded")
        self.end_subsubtest("enable download")

    def test_parameters_mis_total(self):
        self.start_subsubtest("parameter mis_total")
        if self.is_tracker():
            # uses CMD_TOTAL not MIS_TOTAL, and it's in a scalr not a
            # group and it's generally all bad.
            return
        self.start_subtest("Ensure GCS is not able to set MIS_TOTAL")
        old_mt = self.get_parameter("MIS_TOTAL", attempts=20) # retries to avoid seeming race condition with MAVProxy
        ex = None
        try:
            self.set_parameter("MIS_TOTAL", 17, attempts=1)
        except ValueError as e:
            ex = e
        if ex is None:
            raise NotAchievedException("Set parameter when I shouldn't have")
        if old_mt != self.get_parameter("MIS_TOTAL"):
            raise NotAchievedException("Total has changed")

        self.start_subtest("Ensure GCS is able to set other MIS_ parameters")
        self.set_parameter("MIS_OPTIONS", 1)
        if self.get_parameter("MIS_OPTIONS") != 1:
            raise NotAchievedException("Failed to set MIS_OPTIONS")

        mavproxy = self.start_mavproxy()
        from_mavproxy = self.get_parameter_mavproxy(mavproxy, "MIS_OPTIONS")
        if from_mavproxy != 1:
            raise NotAchievedException("MAVProxy failed to get parameter")
        self.stop_mavproxy(mavproxy)

    def test_parameter_documentation(self):
        '''ensure parameter documentation is valid'''
        self.start_subsubtest("Check all parameters are documented")
        self.test_parameter_documentation_get_all_parameters()

    def Parameters(self):
        '''general small tests for parameter system'''
        if self.is_balancebot():
            # same binary and parameters as Rover
            return
        self.test_parameter_documentation()
        self.test_parameters_mis_total()
        self.test_parameters_download()

    def disabled_tests(self):
        return {}

    def test_parameter_checks_poscontrol(self, param_prefix):
        self.wait_ready_to_arm()
        self.context_push()
        self.set_parameter("%s_POSXY_P" % param_prefix, -1)
        self.run_cmd(
            mavutil.mavlink.MAV_CMD_COMPONENT_ARM_DISARM,
            p1=1,  # ARM
            timeout=4,
            want_result=mavutil.mavlink.MAV_RESULT_FAILED,
        )
        self.context_pop()
        self.run_cmd(
            mavutil.mavlink.MAV_CMD_COMPONENT_ARM_DISARM,
            p1=1,  # ARM
            timeout=4,
            want_result=mavutil.mavlink.MAV_RESULT_ACCEPTED,
        )
        self.disarm_vehicle()

    def assert_not_receiving_message(self, message, timeout=1, mav=None):
        self.progress("making sure we're not getting %s messages" % message)
        if mav is None:
            mav = self.mav
        m = mav.recv_match(type=message, blocking=True, timeout=timeout)
        if m is not None:
            raise PreconditionFailedException("Receiving %s messags" % message)

    def PIDTuning(self):
        '''Test PID Tuning'''
        self.assert_not_receiving_message('PID_TUNING', timeout=5)
        self.set_parameter("GCS_PID_MASK", 1)
        self.progress("making sure we are now getting PID_TUNING messages")
        self.assert_receive_message('PID_TUNING', timeout=5)

    def sample_mission_filename(self):
        return "flaps.txt"

    def AdvancedFailsafe(self):
        '''Test Advanced Failsafe'''
        ex = None
        try:
            self.drain_mav()
            if self.is_plane():  # other vehicles can always terminate
                self.assert_no_capability(mavutil.mavlink.MAV_PROTOCOL_CAPABILITY_FLIGHT_TERMINATION)
            self.set_parameters({
                "AFS_ENABLE": 1,
                "SYSID_MYGCS": self.mav.source_system,
            })
            self.drain_mav()
            self.assert_capability(mavutil.mavlink.MAV_PROTOCOL_CAPABILITY_FLIGHT_TERMINATION)
            self.set_parameter("AFS_TERM_ACTION", 42)
            self.load_sample_mission()
            self.context_collect("STATUSTEXT")
            self.change_mode("AUTO") # must go to auto for AFS to latch on
            self.wait_statustext("AFS State: AFS_AUTO", check_context=True)
            if self.is_plane():
                self.change_mode("MANUAL")
            elif self.is_copter():
                self.change_mode("STABILIZE")

            self.start_subtest("RC Failure")
            self.context_push()
            self.context_collect("STATUSTEXT")
            self.set_parameters({
                "AFS_RC_FAIL_TIME": 1,
                "SIM_RC_FAIL": 1,
            })
            self.wait_statustext("Terminating due to RC failure", check_context=True)
            self.context_pop()
            self.set_parameter("AFS_TERMINATE", 0)

            if not self.is_plane():
                # plane requires a polygon fence...
                self.start_subtest("Altitude Limit breach")
                self.set_parameters({
                    "AFS_AMSL_LIMIT": 100,
                    "AFS_QNH_PRESSURE": 1015.2,
                })
                self.do_fence_enable()
                self.wait_statustext("Terminating due to fence breach", check_context=True)
                self.set_parameter("AFS_AMSL_LIMIT", 0)
                self.set_parameter("AFS_TERMINATE", 0)
                self.do_fence_disable()

            self.start_subtest("GPS Failure")
            self.context_push()
            self.context_collect("STATUSTEXT")
            self.set_parameters({
                "AFS_MAX_GPS_LOSS": 1,
                "SIM_GPS_DISABLE": 1,
            })
            self.wait_statustext("AFS State: GPS_LOSS", check_context=True)
            self.context_pop()
            self.set_parameter("AFS_TERMINATE", 0)

            self.start_subtest("GCS Request")
            self.context_push()
            self.context_collect("STATUSTEXT")
            self.run_cmd(
                mavutil.mavlink.MAV_CMD_DO_FLIGHTTERMINATION,
                p1=1,  # terminate
            )
            self.wait_statustext("Terminating due to GCS request", check_context=True)
            self.context_pop()
            self.set_parameter("AFS_TERMINATE", 0)

        except Exception as e:
            ex = e
        try:
            self.do_fence_disable()
        except ValueError:
            # may not actually be enabled....
            pass
        if ex is not None:
            raise ex

    def drain_mav_seconds(self, seconds):
        tstart = self.get_sim_time_cached()
        while self.get_sim_time_cached() - tstart < seconds:
            self.drain_mav()
            self.delay_sim_time(0.5)

    def wait_gps_fix_type_gte(self, fix_type, timeout=30, message_type="GPS_RAW_INT", verbose=False):
        tstart = self.get_sim_time()
        while True:
            now = self.get_sim_time_cached()
            if now - tstart > timeout:
                raise AutoTestTimeoutException("Did not get good GPS lock")
            m = self.mav.recv_match(type=message_type, blocking=True, timeout=0.1)
            if verbose:
                self.progress("Received: %s" % str(m))
            if m is None:
                continue
            if m.fix_type >= fix_type:
                break

    def NMEAOutput(self):
        '''Test AHRS NMEA Output can be read by out NMEA GPS'''
        self.set_parameter("SERIAL5_PROTOCOL", 20) # serial5 is NMEA output
        self.set_parameter("GPS2_TYPE", 5) # GPS2 is NMEA
        port = self.spare_network_port()
        self.customise_SITL_commandline([
            "--serial4=tcp:%u" % port, # GPS2 is NMEA....
            "--serial5=tcpclient:127.0.0.1:%u" % port, # serial5 spews to localhost port
        ])
        self.do_timesync_roundtrip()
        self.wait_gps_fix_type_gte(3)
        gps1 = self.mav.recv_match(type="GPS_RAW_INT", blocking=True, timeout=10)
        self.progress("gps1=(%s)" % str(gps1))
        if gps1 is None:
            raise NotAchievedException("Did not receive GPS_RAW_INT")
        tstart = self.get_sim_time()
        while True:
            now = self.get_sim_time_cached()
            if now - tstart > 20:
                raise NotAchievedException("NMEA output not updating?!")
            gps2 = self.mav.recv_match(type="GPS2_RAW", blocking=True, timeout=1)
            self.progress("gps2=%s" % str(gps2))
            if gps2 is None:
                continue
            if gps2.time_usec != 0:
                break
        max_distance = 1
        distance = self.get_distance_int(gps1, gps2)
        if distance > max_distance:
            raise NotAchievedException("NMEA output inaccurate (dist=%f want<%f)" %
                                       (distance, max_distance))

    def mavproxy_load_module(self, mavproxy, module):
        mavproxy.send("module load %s\n" % module)
        mavproxy.expect("Loaded module %s" % module)

    def mavproxy_unload_module(self, mavproxy, module):
        mavproxy.send("module unload %s\n" % module)
        mavproxy.expect("Unloaded module %s" % module)

    def AccelCal(self):
        '''Accelerometer Calibration testing'''
        ex = None
        mavproxy = self.start_mavproxy()
        try:
            # setup with pre-existing accel offsets, to show that existing offsets don't
            # adversely affect a new cal
            pre_aofs = [Vector3(2.8, 1.2, 1.7),
                        Vector3(0.2, -0.9, 2.9)]
            pre_ascale = [Vector3(0.95, 1.2, 0.98),
                          Vector3(1.1, 1.0, 0.93)]
            aofs = [Vector3(0.7, -0.3, 1.8),
                    Vector3(-2.1, 1.9, 2.3)]
            ascale = [Vector3(0.98, 1.12, 1.05),
                      Vector3(1.11, 0.98, 0.96)]
            atrim = Vector3(0.05, -0.03, 0)
            pre_atrim = Vector3(-0.02, 0.04, 0)
            param_map = [("INS_ACCOFFS", "SIM_ACC1_BIAS", pre_aofs[0], aofs[0]),
                         ("INS_ACC2OFFS", "SIM_ACC2_BIAS", pre_aofs[1], aofs[1]),
                         ("INS_ACCSCAL", "SIM_ACC1_SCAL", pre_ascale[0], ascale[0]),
                         ("INS_ACC2SCAL", "SIM_ACC2_SCAL", pre_ascale[1], ascale[1]),
                         ("AHRS_TRIM", "SIM_ACC_TRIM", pre_atrim, atrim)]
            axes = ['X', 'Y', 'Z']

            # form the pre-calibration params
            initial_params = {}
            for (ins_prefix, sim_prefix, pre_value, post_value) in param_map:
                for axis in axes:
                    initial_params[ins_prefix + "_" + axis] = getattr(pre_value, axis.lower())
                    initial_params[sim_prefix + "_" + axis] = getattr(post_value, axis.lower())
            self.set_parameters(initial_params)
            self.customise_SITL_commandline(["-M", "calibration"])
            self.mavproxy_load_module(mavproxy, "sitl_calibration")
            self.mavproxy_load_module(mavproxy, "calibration")
            self.mavproxy_load_module(mavproxy, "relay")
            mavproxy.send("sitl_accelcal\n")
            mavproxy.send("accelcal\n")
            mavproxy.expect("Calibrated")
            for wanted in [
                    "level",
                    "on its LEFT side",
                    "on its RIGHT side",
                    "nose DOWN",
                    "nose UP",
                    "on its BACK",
            ]:
                timeout = 2
                mavproxy.expect("Place vehicle %s and press any key." % wanted, timeout=timeout)
                mavproxy.expect("sitl_accelcal: sending attitude, please wait..", timeout=timeout)
                mavproxy.expect("sitl_accelcal: attitude detected, please press any key..", timeout=timeout)
                mavproxy.send("\n")
            mavproxy.expect(".*Calibration successful", timeout=timeout)
            self.drain_mav()

            self.progress("Checking results")
            accuracy_pct = 0.5
            for (ins_prefix, sim_prefix, pre_value, post_value) in param_map:
                for axis in axes:
                    pname = ins_prefix+"_"+axis
                    v = self.get_parameter(pname)
                    expected_v = getattr(post_value, axis.lower())
                    if v == expected_v:
                        continue
                    error_pct = 100.0 * abs(v - expected_v) / abs(expected_v)
                    if error_pct > accuracy_pct:
                        raise NotAchievedException(
                            "Incorrect value %.6f for %s should be %.6f error %.2f%%" %
                            (v, pname, expected_v, error_pct))
                    else:
                        self.progress("Correct value %.4f for %s error %.2f%%" % (v, pname, error_pct))
        except Exception as e:
            self.print_exception_caught(e)
            ex = e
        self.mavproxy_unload_module(mavproxy, "relay")
        self.mavproxy_unload_module(mavproxy, "calibration")
        self.mavproxy_unload_module(mavproxy, "sitl_calibration")
        self.stop_mavproxy(mavproxy)
        if ex is not None:
            raise ex

    def ahrstrim_preflight_cal(self):
        # setup with non-zero accel offsets
        self.set_parameters({
            "INS_ACCOFFS_X": 0.7,
            "INS_ACCOFFS_Y": -0.3,
            "INS_ACCOFFS_Z": 1.8,
            "INS_ACC2OFFS_X": -2.1,
            "INS_ACC2OFFS_Y": 1.9,
            "INS_ACC2OFFS_Z": 2.3,
            "SIM_ACC1_BIAS_X": 0.7,
            "SIM_ACC1_BIAS_Y": -0.3,
            "SIM_ACC1_BIAS_Z": 1.8,
            "SIM_ACC2_BIAS_X": -2.1,
            "SIM_ACC2_BIAS_Y": 1.9,
            "SIM_ACC2_BIAS_Z": 2.3,
            "AHRS_TRIM_X": 0.05,
            "AHRS_TRIM_Y": -0.03,
            "SIM_ACC_TRIM_X": -0.04,
            "SIM_ACC_TRIM_Y": 0.05,
        })
        expected_parms = {
            "AHRS_TRIM_X": -0.04,
            "AHRS_TRIM_Y": 0.05,
        }

        self.progress("Starting ahrstrim")
        self.drain_mav()
        self.mav.mav.command_long_send(self.sysid_thismav(), 1,
                                       mavutil.mavlink.MAV_CMD_PREFLIGHT_CALIBRATION, 0,
                                       0, 0, 0, 0, 2, 0, 0)
        self.wait_statustext('Trim OK')
        self.drain_mav()

        self.progress("Checking results")
        accuracy_pct = 0.2
        for (pname, expected_v) in expected_parms.items():
            v = self.get_parameter(pname)
            if v == expected_v:
                continue
            error_pct = 100.0 * abs(v - expected_v) / abs(expected_v)
            if error_pct > accuracy_pct:
                raise NotAchievedException(
                    "Incorrect value %.6f for %s should be %.6f error %.2f%%" %
                    (v, pname, expected_v, error_pct))
            self.progress("Correct value %.4f for %s error %.2f%%" %
                          (v, pname, error_pct))

    def user_takeoff(self, alt_min=30, timeout=30, max_err=5):
        '''takeoff using mavlink takeoff command'''
        self.run_cmd(
            mavutil.mavlink.MAV_CMD_NAV_TAKEOFF,
            p7=alt_min, # param7
        )
        self.wait_altitude(alt_min - 1,
                           (alt_min + max_err),
                           relative=True,
                           timeout=timeout)

    def ahrstrim_attitude_correctness(self):
        self.wait_ready_to_arm()
        HOME = self.sitl_start_location()
        for heading in 0, 90:
            self.customise_SITL_commandline([
                "--home", "%s,%s,%s,%s" % (HOME.lat, HOME.lng, HOME.alt, heading)
            ])
            for ahrs_type in [0, 2, 3]:
                self.start_subsubtest("Testing AHRS_TYPE=%u" % ahrs_type)
                self.context_push()
                self.set_parameter("AHRS_EKF_TYPE", ahrs_type)
                self.reboot_sitl()
                self.wait_prearm_sys_status_healthy()
                for (r, p) in [(0, 0), (9, 0), (2, -6), (10, 10)]:
                    self.set_parameters({
                        'AHRS_TRIM_X': math.radians(r),
                        'AHRS_TRIM_Y': math.radians(p),
                        "SIM_ACC_TRIM_X": math.radians(r),
                        "SIM_ACC_TRIM_Y": math.radians(p),
                    })
                    self.wait_attitude(desroll=0, despitch=0, timeout=120, tolerance=1.5)
                    if ahrs_type != 0:  # we don't get secondary msgs while DCM is primary
                        self.wait_attitude(desroll=0, despitch=0, message_type='AHRS2', tolerance=1, timeout=120)
                    self.wait_attitude_quaternion(desroll=0, despitch=0, tolerance=1, timeout=120)

                self.context_pop()
                self.reboot_sitl()

    def AHRSTrim(self):
        '''AHRS trim testing'''
        self.start_subtest("Attitude Correctness")
        self.ahrstrim_attitude_correctness()
        self.delay_sim_time(5)
        self.start_subtest("Preflight Calibration")
        self.ahrstrim_preflight_cal()

    def Button(self):
        '''Test Buttons'''
        self.set_parameter("SIM_PIN_MASK", 0)
        self.set_parameter("BTN_ENABLE", 1)
        self.drain_mav()
        self.do_heartbeats(force=True)
        btn = 4
        pin = 3
        self.set_parameter("BTN_PIN%u" % btn, pin, verbose=True)
        m = self.mav.recv_match(type='BUTTON_CHANGE', blocking=True, timeout=1)
        self.progress("### m: %s" % str(m))
        if m is not None:
            # should not get a button-changed event here.  The pins
            # are simulated pull-down
            raise NotAchievedException("Received BUTTON_CHANGE event")
        mask = 1 << pin
        self.set_parameter("SIM_PIN_MASK", mask)
        m = self.assert_receive_message('BUTTON_CHANGE', timeout=1, verbose=True)
        if not (m.state & mask):
            raise NotAchievedException("Bit not set in mask (got=%u want=%u)" % (m.state, mask))
        m2 = self.mav.recv_match(type='BUTTON_CHANGE', blocking=True, timeout=10)
        if m2 is None:
            raise NotAchievedException("Did not get repeat message")
        self.progress("### m2: %s" % str(m2))
        # wait for messages to stop coming:
        self.drain_mav_seconds(15)

        new_mask = 0
        self.send_set_parameter("SIM_PIN_MASK", new_mask, verbose=True)
        m3 = self.mav.recv_match(type='BUTTON_CHANGE', blocking=True, timeout=1)
        if m3 is None:
            raise NotAchievedException("Did not get 'off' message")
        self.progress("### m3: %s" % str(m3))

        if m.last_change_ms == m3.last_change_ms:
            raise NotAchievedException("last_change_ms same as first message")
        if m3.state != new_mask:
            raise NotAchievedException("Unexpected mask (want=%u got=%u)" %
                                       (new_mask, m3.state))
        self.progress("correct BUTTON_CHANGE event received")

        if self.is_tracker():
            # tracker starts armed, which is annoying
            self.progress("Skipping arm/disarm tests for tracker")
            return

        self.context_push()
        self.wait_ready_to_arm()
        self.set_parameter("BTN_FUNC%u" % btn, 153)  # ARM/DISARM
        self.set_parameter("SIM_PIN_MASK", mask)
        self.wait_armed()
        self.set_parameter("SIM_PIN_MASK", 0)
        self.wait_disarmed()
        self.context_pop()

        if self.is_rover():
            self.context_push()
            # arming should be inhibited while e-STOP is in use:
            # set the function:
            self.set_parameter("BTN_FUNC%u" % btn, 31)
            # invert the sense of the pin, so eStop is asserted when pin is low:
            self.set_parameter("BTN_OPTIONS%u" % btn, 1 << 1)
            self.reboot_sitl()
            # assert the pin:
            self.set_parameter("SIM_PIN_MASK", mask)
            self.wait_ready_to_arm()
            self.arm_vehicle()
            self.disarm_vehicle()
            # de-assert the pin:
            self.set_parameter("SIM_PIN_MASK", 0)
            self.delay_sim_time(1)  # 5Hz update rate on Button library
            self.context_collect("STATUSTEXT")
            # try to arm the vehicle:
            self.run_cmd(
                mavutil.mavlink.MAV_CMD_COMPONENT_ARM_DISARM,
                p1=1,  # ARM
                want_result=mavutil.mavlink.MAV_RESULT_FAILED,
            )
            self.assert_prearm_failure("Motors Emergency Stopped",
                                       other_prearm_failures_fatal=False)
            self.reboot_sitl()
            self.assert_prearm_failure(
                "Motors Emergency Stopped",
                other_prearm_failures_fatal=False)
            self.context_pop()
            self.reboot_sitl()

        if self.is_rover():
            self.start_subtest("Testing using buttons for changing modes")
            self.context_push()
            if not self.mode_is('MANUAL'):
                raise NotAchievedException("Bad mode")
            self.set_parameter("BTN_FUNC%u" % btn, 53)  # steering mode
            # press button:
            self.set_parameter("SIM_PIN_MASK", mask)
            self.wait_mode('STEERING')
            # release button:
            self.set_parameter("SIM_PIN_MASK", 0)
            self.wait_mode('MANUAL')
            self.context_pop()

    def compare_number_percent(self, num1, num2, percent):
        if num1 == 0 and num2 == 0:
            return True
        if abs(num1 - num2) / max(abs(num1), abs(num2)) <= percent * 0.01:
            return True
        return False

    def bit_extract(self, number, offset, length):
        mask = 0
        for i in range(offset, offset+length):
            mask |= 1 << i
        return (number & mask) >> offset

    def tf_encode_gps_latitude(self, lat):
        value = 0
        if lat < 0:
            value = ((abs(lat)//100)*6) | 0x40000000
        else:
            value = ((abs(lat)//100)*6)
        return value

    def tf_validate_gps(self, value): # shared by proto 4 and proto 10
        self.progress("validating gps (0x%02x)" % value)
        lat = value
        gpi = self.mav.recv_match(
            type='GLOBAL_POSITION_INT',
            blocking=True,
            timeout=1
        )
        if gpi is None:
            raise NotAchievedException("Did not get GLOBAL_POSITION_INT message")
        gpi_lat = self.tf_encode_gps_latitude(gpi.lat)
        self.progress("GLOBAL_POSITION_INT lat==%f frsky==%f" % (gpi_lat, lat))
        if gpi_lat == lat:
            return True
        return False

    def tfp_prep_number(self, number, digits, power):
        res = 0
        abs_number = abs(number)
        if digits == 2 and power == 1: # number encoded on 8 bits: 7 bits for digits + 1 for 10^power
            if abs_number < 100:
                res = abs_number << 1
            elif abs_number < 1270:
                res = (round(abs_number * 0.1) << 1) | 0x1
            else: # transmit max possible value (0x7F x 10^1 = 1270)
                res = 0xFF
            if number < 0:  # if number is negative, add sign bit in front
                res |= 0x1 << 8
        elif digits == 2 and power == 2: # number encoded on 9 bits: 7 bits for digits + 2 for 10^power
            if abs_number < 100:
                res = abs_number << 2
            elif abs_number < 1000:
                res = (round(abs_number * 0.1) << 2) | 0x1
            elif abs_number < 10000:
                res = (round(abs_number * 0.01) << 2) | 0x2
            elif abs_number < 127000:
                res = (round(abs_number * 0.001) << 2) | 0x3
            else: # transmit max possible value (0x7F x 10^3 = 127000)
                res = 0x1FF
            if number < 0: # if numbe