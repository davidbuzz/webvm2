53L0X::detect(state[instance], params[instance],
                                                                hal.i2c_mgr->get_device(i, params[instance].address)),
                        instance)) {
                    break;
                }
#endif
#if AP_RANGEFINDER_VL53L1X_ENABLED
                if (_add_backend(AP_RangeFinder_VL53L1X::detect(state[instance], params[instance],
                                                                hal.i2c_mgr->get_device(i, params[instance].address),
                                                                _type == Type::VL53L1X_Short ?  AP_RangeFinder_VL53L1X::DistanceMode::Short :
                                                                AP_RangeFinder_VL53L1X::DistanceMode::Long),
                                 instance)) {
                    break;
                }
#endif
            }
        break;
#if AP_RANGEFINDER_BENEWAKE_TFMINIPLUS_ENABLED
    case Type::BenewakeTFminiPlus: {
        uint8_t addr = TFMINIPLUS_ADDR_DEFAULT;
        if (params[instance].address != 0) {
            addr = params[instance].address;
        }
        FOREACH_I2C(i) {
            if (_add_backend(AP_RangeFinder_Benewake_TFMiniPlus::detect(state[instance], params[instance],
                                                                        hal.i2c_mgr->get_device(i, addr)),
                    instance)) {
                break;
            }
        }
        break;
    }
#endif
#if AP_RANGEFINDER_PWM_ENABLED
    case Type::PX4_PWM:
        // to ease moving from PX4 to ChibiOS we'll lie a little about
        // the backend driver...
        if (AP_RangeFinder_PWM::detect()) {
            _add_backend(NEW_NOTHROW AP_RangeFinder_PWM(state[instance], params[instance], estimated_terrain_height), instance);
        }
        break;
#endif
#if AP_RANGEFINDER_BBB_PRU_ENABLED
    case Type::BBB_PRU:
        if (AP_RangeFinder_BBB_PRU::detect()) {
            _add_backend(NEW_NOTHROW AP_RangeFinder_BBB_PRU(state[instance], params[instance]), instance);
        }
        break;
#endif
#if AP_RANGEFINDER_LIGHTWARE_SERIAL_ENABLED
    case Type::LWSER:
        serial_create_fn = AP_RangeFinder_LightWareSerial::create;
        break;
#endif
#if AP_RANGEFINDER_LEDDARONE_ENABLED
    case Type::LEDDARONE:
        serial_create_fn = AP_RangeFinder_LeddarOne::create;
        break;
#endif
#if AP_RANGEFINDER_USD1_SERIAL_ENABLED
    case Type::USD1_Serial:
        serial_create_fn = AP_RangeFinder_USD1_Serial::create;
        break;
#endif
#if AP_RANGEFINDER_BEBOP_ENABLED
    case Type::BEBOP:
        if (AP_RangeFinder_Bebop::detect()) {
            _add_backend(NEW_NOTHROW AP_RangeFinder_Bebop(state[instance], params[instance]), instance);
        }
        break;
#endif
#if AP_RANGEFINDER_MAVLINK_ENABLED
    case Type::MAVLink:
        if (AP_RangeFinder_MAVLink::detect()) {
            _add_backend(NEW_NOTHROW AP_RangeFinder_MAVLink(state[instance], params[instance]), instance);
        }
        break;
#endif
#if AP_RANGEFINDER_MAXBOTIX_SERIAL_ENABLED
    case Type::MBSER:
        serial_create_fn = AP_RangeFinder_MaxsonarSerialLV::create;
        break;
#endif
#if AP_RANGEFINDER_ANALOG_ENABLED
    case Type::ANALOG:
        // note that analog will always come back as present if the pin is valid
        if (AP_RangeFinder_analog::detect(params[instance])) {
            _add_backend(NEW_NOTHROW AP_RangeFinder_analog(state[instance], params[instance]), instance);
        }
        break;
#endif
#if AP_RANGEFINDER_HC_SR04_ENABLED
    case Type::HC_SR04:
        // note that this will always come back as present if the pin is valid
        if (AP_RangeFinder_HC_SR04::detect(params[instance])) {
            _add_backend(NEW_NOTHROW AP_RangeFinder_HC_SR04(state[instance], params[instance]), instance);
        }
        break;
#endif
#if AP_RANGEFINDER_NMEA_ENABLED
    case Type::NMEA:
        serial_create_fn = AP_RangeFinder_NMEA::create;
        break;
#endif
#if AP_RANGEFINDER_WASP_ENABLED
    case Type::WASP:
        serial_create_fn = AP_RangeFinder_Wasp::create;
        break;
#endif
#if AP_RANGEFINDER_BENEWAKE_TF02_ENABLED
    case Type::BenewakeTF02:
        serial_create_fn = AP_RangeFinder_Benewake_TF02::create;
        break;
#endif
#if AP_RANGEFINDER_BENEWAKE_TFMINI_ENABLED
    case Type::BenewakeTFmini:
        serial_create_fn = AP_RangeFinder_Benewake_TFMini::create;
        break;
#endif
#if AP_RANGEFINDER_BENEWAKE_TF03_ENABLED
    case Type::BenewakeTF03:
        serial_create_fn = AP_RangeFinder_Benewake_TF03::create;
        break;
#endif
#if AP_RANGEFINDER_TERARANGER_SERIAL_ENABLED
    case Type::TeraRanger_Serial:
        serial_create_fn = AP_RangeFinder_TeraRanger_Serial::create;
        break;
#endif
#if AP_RANGEFINDER_PWM_ENABLED
    case Type::PWM:
        if (AP_RangeFinder_PWM::detect()) {
            _add_backend(NEW_NOTHROW AP_RangeFinder_PWM(state[instance], params[instance], estimated_terrain_height), instance);
        }
        break;
#endif
#if AP_RANGEFINDER_BLPING_ENABLED
    case Type::BLPing:
        serial_create_fn = AP_RangeFinder_BLPing::create;
        break;
#endif
#if AP_RANGEFINDER_LANBAO_ENABLED
    case Type::Lanbao:
        serial_create_fn = AP_RangeFinder_Lanbao::create;
        break;
#endif
#if AP_RANGEFINDER_LEDDARVU8_ENABLED
    case Type::LeddarVu8_Serial:
        serial_create_fn = AP_RangeFinder_LeddarVu8::create;
        break;
#endif

#if AP_RANGEFINDER_DRONECAN_ENABLED
    case Type::UAVCAN:
        /*
          the UAVCAN driver gets created when we first receive a
          measurement. We take the instance slot now, even if we don't
          yet have the driver
         */
        num_instances = MAX(num_instances, instance+1);
        break;
#endif

#if AP_RANGEFINDER_GYUS42V2_ENABLED
    case Type::GYUS42v2:
        serial_create_fn = AP_RangeFinder_GYUS42v2::create;
        break;
#endif

#if AP_RANGEFINDER_SIM_ENABLED
    case Type::SIM:
        _add_backend(NEW_NOTHROW AP_RangeFinder_SITL(state[instance], params[instance], instance), instance);
        break;
#endif

#if HAL_MSP_RANGEFINDER_ENABLED
    case Type::MSP:
        if (AP_RangeFinder_MSP::detect()) {
            _add_backend(NEW_NOTHROW AP_RangeFinder_MSP(state[instance], params[instance]), instance);
        }
        break;
#endif // HAL_MSP_RANGEFINDER_ENABLED

#if AP_RANGEFINDER_USD1_CAN_ENABLED
    case Type::USD1_CAN:
        _add_backend(NEW_NOTHROW AP_RangeFinder_USD1_CAN(state[instance], params[instance]), instance);
        break;
#endif
#if AP_RANGEFINDER_BENEWAKE_CAN_ENABLED
    case Type::Benewake_CAN:
        _add_backend(NEW_NOTHROW AP_RangeFinder_Benewake_CAN(state[instance], params[instance]), instance);
        break;
#endif

#if AP_RANGEFINDER_LUA_ENABLED
    case Type::Lua_Scripting:
        _add_backend(NEW_NOTHROW AP_RangeFinder_Lua(state[instance], params[instance]), instance);
        break;
#endif

#if AP_RANGEFINDER_NOOPLOOP_ENABLED
    case Type::NoopLoop_P:
        serial_create_fn = AP_RangeFinder_NoopLoop::create;
        break;
#endif

#if AP_RANGEFINDER_AINSTEIN_LR_D1_ENABLED
    case Type::Ainstein_LR_D1:
        serial_create_fn = AP_RangeFinder_Ainstein_LR_D1::create;
        break;
#endif

#if AP_RANGEFINDER_TOFSENSEP_CAN_ENABLED
    case Type::TOFSenseP_CAN:
        _add_backend(NEW_NOTHROW AP_RangeFinder_TOFSenseP_CAN(state[instance], params[instance]), instance);
        break;
#endif
#if AP_RANGEFINDER_NRA24_CAN_ENABLED
    case Type::NRA24_CAN:
        _add_backend(NEW_NOTHROW AP_RangeFinder_NRA24_CAN(state[instance], params[instance]), instance);
        break;
#endif
#if AP_RANGEFINDER_TOFSENSEF_I2C_ENABLED
    case Type::TOFSenseF_I2C: {
        uint8_t addr = TOFSENSEP_I2C_DEFAULT_ADDR;
        if (params[instance].address != 0) {
            addr = params[instance].address;
        }
        FOREACH_I2C(i) {
            if (_add_backend(AP_RangeFinder_TOFSenseF_I2C::detect(state[instance], params[instance],
                                                                  hal.i2c_mgr->get_device(i, addr)),
                             instance)) {
                break;
            }
        }
        break;
    }
#endif
#if AP_RANGEFINDER_JRE_SERIAL_ENABLED
    case Type::JRE_Serial:
        serial_create_fn = AP_RangeFinder_JRE_Serial::create;
        break;
#endif

#if AP_RANGEFINDER_RDS02UF_ENABLED
    case Type::RDS02UF:
        serial_create_fn = AP_RangeFinder_RDS02UF::create;
        break;
#endif
    case Type::NONE:
        break;
    }

    if (serial_create_fn != nullptr) {
        if (AP::serialmanager().have_serial(AP_SerialManager::SerialProtocol_Rangefinder, serial_instance)) {
            auto *b = serial_create_fn(state[instance], params[instance]);
            if (b != nullptr) {
                _add_backend(b, instance, serial_instance++);
            }
        }
    }

    // if the backend has some local parameters then make those available in the tree
    if (drivers[instance] && state[instance].var_info) {
        backend_var_info[instance] = state[instance].var_info;
        AP_Param::load_object_from_eeprom(drivers[instance], backend_var_info[instance]);

        // param count could have changed
        AP_Param::invalidate_count();
    }
}

AP_RangeFinder_Backend *RangeFinder::get_backend(uint8_t id) const {
    if (id >= num_instances) {
        return nullptr;
    }
    if (drivers[id] != nullptr) {
        if (drivers[id]->type() == Type::NONE) {
            // pretend it isn't here; disabled at runtime?
            return nullptr;
        }
    }
    return drivers[id];
};

RangeFinder::Status RangeFinder::status_orient(enum Rotation orientation) const
{
    AP_RangeFinder_Backend *backend = find_instance(orientation);
    if (backend == nullptr) {
        return Status::NotConnected;
    }
    return backend->status();
}

void RangeFinder::handle_msg(const mavlink_message_t &msg)
{
    uint8_t i;
    for (i=0; i<num_instances; i++) {
        if ((drivers[i] != nullptr) && ((Type)params[i].type.get() != Type::NONE)) {
          drivers[i]->handle_msg(msg);
        }
    }
}

#if HAL_MSP_RANGEFINDER_ENABLED
void RangeFinder::handle_msp(const MSP::msp_rangefinder_data_message_t &pkt)
{
    uint8_t i;
    for (i=0; i<num_instances; i++) {
        if ((drivers[i] != nullptr) && ((Type)params[i].type.get() == Type::MSP)) {
          drivers[i]->handle_msp(pkt);
        }
    }
}
#endif // HAL_MSP_RANGEFINDER_ENABLED

// return true if we have a range finder with the specified orientation
bool RangeFinder::has_orientation(enum Rotation orientation) const
{
    return (find_instance(orientation) != nullptr);
}

// find first range finder instance with the specified orientation
AP_RangeFinder_Backend *RangeFinder::find_instance(enum Rotation orientation) const
{
    // first try for a rangefinder that is in range
    for (uint8_t i=0; i<num_instances; i++) {
        AP_RangeFinder_Backend *backend = get_backend(i);
        if (backend != nullptr &&
            backend->orientation() == orientation &&
            backend->status() == Status::Good) {
            return backend;
        }
    }
    // if none in range then return first with correct orientation
    for (uint8_t i=0; i<num_instances; i++) {
        AP_RangeFinder_Backend *backend = get_backend(i);
        if (backend != nullptr &&
            backend->orientation() == orientation) {
            return backend;
        }
    }
    return nullptr;
}

float RangeFinder::distance_orient(enum Rotation orientation) const
{
    AP_RangeFinder_Backend *backend = find_instance(orientation);
    if (backend == nullptr) {
        return 0;
    }
    return backend->distance();
}

uint16_t RangeFinder::distance_cm_orient(enum Rotation orientation) const
{
    return distance_orient(orientation) * 100.0;
}

int8_t RangeFinder::signal_quality_pct_orient(enum Rotation orientation) const
{
    AP_RangeFinder_Backend *backend = find_instance(orientation);
    if (backend == nullptr) {
        return RangeFinder::SIGNAL_QUALITY_UNKNOWN;
    }
    return backend->signal_quality_pct();
}

int16_t RangeFinder::max_distance_cm_orient(enum Rotation orientation) const
{
    AP_RangeFinder_Backend *backend = find_instance(orientation);
    if (backend == nullptr) {
        return 0;
    }
    return backend->max_distance_cm();
}

int16_t RangeFinder::min_distance_cm_orient(enum Rotation orientation) const
{
    AP_RangeFinder_Backend *backend = find_instance(orientation);
    if (backend == nullptr) {
        return 0;
    }
    return backend->min_distance_cm();
}

int16_t RangeFinder::ground_clearance_cm_orient(enum Rotation orientation) const
{
    AP_RangeFinder_Backend *backend = find_instance(orientation);
    if (backend == nullptr) {
        return 0;
    }
    return backend->ground_clearance_cm();
}

bool RangeFinder::has_data_orient(enum Rotation orientation) const
{
    AP_RangeFinder_Backend *backend = find_instance(orientation);
    if (backend == nullptr) {
        return false;
    }
    return backend->has_data();
}

uint8_t RangeFinder::range_valid_count_orient(enum Rotation orientation) const
{
    AP_RangeFinder_Backend *backend = find_instance(orientation);
    if (backend == nullptr) {
        return 0;
    }
    return backend->range_valid_count();
}

const Vector3f &RangeFinder::get_pos_offset_orient(enum Rotation orientation) const
{
    AP_RangeFinder_Backend *backend = find_instance(orientation);
    if (backend == nullptr) {
        return pos_offset_zero;
    }
    return backend->get_pos_offset();
}

uint32_t RangeFinder::last_reading_ms(enum Rotation orientation) const
{
    AP_RangeFinder_Backend *backend = find_instance(orientation);
    if (backend == nullptr) {
        return 0;
    }
    return backend->last_reading_ms();
}

MAV_DISTANCE_SENSOR RangeFinder::get_mav_distance_sensor_type_orient(enum Rotation orientation) const
{
    AP_RangeFinder_Backend *backend = find_instance(orientation);
    if (backend == nullptr) {
        return MAV_DISTANCE_SENSOR_UNKNOWN;
    }
    return backend->get_mav_distance_sensor_type();
}

// get temperature reading in C.  returns true on success and populates temp argument
bool RangeFinder::get_temp(enum Rotation orientation, float &temp) const
{
    AP_RangeFinder_Backend *backend = find_instance(orientation);
    if (backend == nullptr) {
        return false;
    }
    return backend->get_temp(temp);
}

#if HAL_LOGGING_ENABLED
// Write an RFND (rangefinder) packet
void RangeFinder::Log_RFND() const
{
    if (_log_rfnd_bit == uint32_t(-1)) {
        return;
    }

    AP_Logger &logger = AP::logger();
    if (!logger.should_log(_log_rfnd_bit)) {
        return;
    }

    for (uint8_t i=0; i<RANGEFINDER_MAX_INSTANCES; i++) {
        const AP_RangeFinder_Backend *s = get_backend(i);
        if (s == nullptr) {
            continue;
        }

        const struct log_RFND pkt = {
                LOG_PACKET_HEADER_INIT(LOG_RFND_MSG),
                time_us      : AP_HAL::micros64(),
                instance     : i,
                dist         : s->distance_cm(),
                status       : (uint8_t)s->status(),
                orient       : s->orientation(),
                quality      : s->signal_quality_pct(),
        };
        AP::logger().WriteBlock(&pkt, sizeof(pkt));
    }
}
#endif  // HAL_LOGGING_ENABLED

bool RangeFinder::prearm_healthy(char *failure_msg, const uint8_t failure_msg_len) const
{
    for (uint8_t i = 0; i < RANGEFINDER_MAX_INSTANCES; i++) {
        if ((Type)params[i].type.get() == Type::NONE) {
            continue;
        }

        if (drivers[i] == nullptr) {
            hal.util->snprintf(failure_msg, failure_msg_len, "Rangefinder %X: Not Detected", i + 1);
            return false;
        }

        // backend-specific checks.  This might end up drivers[i]->arming_checks(...).
        switch (drivers[i]->allocated_type()) {
#if AP_RANGEFINDER_ANALOG_ENABLED || AP_RANGEFINDER_PWM_ENABLED
#if AP_RANGEFINDER_ANALOG_ENABLED
        case Type::ANALOG:
#endif
#if AP_RANGEFINDER_PWM_ENABLED
        case Type::PX4_PWM:
        case Type::PWM:
#endif
        {
            // ensure pin is configured
            if (params[i].pin == -1) {
                hal.util->snprintf(failure_msg, failure_msg_len, "RNGFND%u_PIN not set", unsigned(i + 1));
                return false;
            }
#if AP_RANGEFINDER_ANALOG_ENABLED
            if (drivers[i]->allocated_type() == Type::ANALOG) {
                // Analog backend does not use GPIO pin
                break;
            }
#endif

            // ensure that the pin we're configured to use is available
            if (!hal.gpio->valid_pin(params[i].pin)) {
                uint8_t servo_ch;
                if (hal.gpio->pin_to_servo_channel(params[i].pin, servo_ch)) {
                    hal.util->snprintf(failure_msg, failure_msg_len, "RNGFND%u_PIN=%d, set SERVO%u_FUNCTION=-1", unsigned(i + 1), int(params[i].pin.get()), unsigned(servo_ch+1));
                } else {
                    hal.util->snprintf(failure_msg, failure_msg_len, "RNGFND%u_PIN=%d invalid", unsigned(i + 1), int(params[i].pin.get()));
                }
                return false;
            }
            break;
        }
#endif  // AP_RANGEFINDER_ANALOG_ENABLED || AP_RANGEFINDER_PWM_ENABLED

#if AP_RANGEFINDER_NRA24_CAN_ENABLED
        case Type::NRA24_CAN: {
            if (drivers[i]->status() == Status::NoData) {
                // This sensor stops sending data if there is no relative motion. This will mostly happen during takeoff, before arming
                // To avoid pre-arm failure, return true even though there is no data.
                // This sensor also sends a "heartbeat" so we can differentiate between  "NoData" and "NotConnected"
                return true;
            }
            break;
        }
#endif

        default:
            break;
        }

        switch (drivers[i]->status()) {
        case Status::NoData:
            hal.util->snprintf(failure_msg, failure_msg_len, "Rangefinder %X: No Data", i + 1);
            return false;
        case Status::NotConnected:
            hal.util->snprintf(failure_msg, failure_msg_len, "Rangefinder %X: Not Connected", i + 1);
            return false;
        case Status::OutOfRangeLow:
        case Status::OutOfRangeHigh:
        case Status::Good:
            break;
        }
    }

    return true;
}

RangeFinder *RangeFinder::_singleton;

namespace AP {

RangeFinder *rangefinder()
{
    return RangeFinder::get_singleton();
}

}

#endif  // AP_RANGEFINDER_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          /*
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
#pragma once

#include "AP_RangeFinder_config.h"

#if AP_RANGEFINDER_ENABLED

#include <AP_Common/AP_Common.h>
#include <AP_HAL/AP_HAL_Boards.h>
#include <AP_HAL/Semaphores.h>
#include <AP_Param/AP_Param.h>
#include <GCS_MAVLink/GCS_MAVLink.h>
#include <AP_MSP/msp.h>
#include "AP_RangeFinder_Params.h"

// Maximum number of range finder instances available on this platform
#ifndef RANGEFINDER_MAX_INSTANCES 
  #if AP_RANGEFINDER_ENABLED
  #define RANGEFINDER_MAX_INSTANCES 10
  #else
  #define RANGEFINDER_MAX_INSTANCES 1
  #endif
#endif

#define RANGEFINDER_GROUND_CLEARANCE_CM_DEFAULT 10
#define RANGEFINDER_PREARM_ALT_MAX_CM           200
#if CONFIG_HAL_BOARD == HAL_BOARD_SITL
#define RANGEFINDER_PREARM_REQUIRED_CHANGE_CM   0
#else
#define RANGEFINDER_PREARM_REQUIRED_CHANGE_CM   50
#endif

class AP_RangeFinder_Backend;

class RangeFinder
{
    friend class AP_RangeFinder_Backend;
    //UAVCAN drivers are initialised in the Backend, hence list of drivers is needed there.
    friend class AP_RangeFinder_DroneCAN;
public:
    RangeFinder();

    /* Do not allow copies */
    CLASS_NO_COPY(RangeFinder);

    // RangeFinder driver types
    enum class Type {
        NONE   = 0,
#if AP_RANGEFINDER_ANALOG_ENABLED
        ANALOG = 1,
#endif
#if AP_RANGEFINDER_MAXSONARI2CXL_ENABLED
        MBI2C  = 2,
#endif
#if AP_RANGEFINDER_PULSEDLIGHTLRF_ENABLED
        PLI2C  = 3,
#endif
//        PX4    = 4, // no longer used, but may be in some user's parameters
#if AP_RANGEFINDER_PWM_ENABLED
        PX4_PWM= 5,
#endif
#if AP_RANGEFINDER_BBB_PRU_ENABLED
        BBB_PRU= 6,
#endif
#if AP_RANGEFINDER_LWI2C_ENABLED
        LWI2C  = 7,
#endif
#if AP_RANGEFINDER_LIGHTWARE_SERIAL_ENABLED
        LWSER  = 8,
#endif
#if AP_RANGEFINDER_BEBOP_ENABLED
        BEBOP  = 9,
#endif
#if AP_RANGEFINDER_MAVLINK_ENABLED
        MAVLink = 10,
#endif
#if AP_RANGEFINDER_USD1_SERIAL_ENABLED
        USD1_Serial = 11,
#endif
#if AP_RANGEFINDER_LEDDARONE_ENABLED
        LEDDARONE = 12,
#endif
#if AP_RANGEFINDER_MAXBOTIX_SERIAL_ENABLED
        MBSER  = 13,
#endif
#if AP_RANGEFINDER_TRI2C_ENABLED
        TRI2C  = 14,
#endif
#if AP_RANGEFINDER_PULSEDLIGHTLRF_ENABLED
        PLI2CV3= 15,
#endif
        VL53L0X = 16,
#if AP_RANGEFINDER_NMEA_ENABLED
        NMEA = 17,
#endif
#if AP_RANGEFINDER_WASP_ENABLED
        WASP = 18,
#endif
#if AP_RANGEFINDER_BENEWAKE_TF02_ENABLED
        BenewakeTF02 = 19,
#endif
#if AP_RANGEFINDER_BENEWAKE_TFMINI_ENABLED
        BenewakeTFmini = 20,
#endif
#if AP_RANGEFINDER_PULSEDLIGHTLRF_ENABLED
        PLI2CV3HP = 21,
#endif
#if AP_RANGEFINDER_PWM_ENABLED
        PWM = 22,
#endif
#if AP_RANGEFINDER_BLPING_ENABLED
        BLPing = 23,
#endif
#if AP_RANGEFINDER_DRONECAN_ENABLED
        UAVCAN = 24,
#endif
#if AP_RANGEFINDER_BENEWAKE_TFMINIPLUS_ENABLED
        BenewakeTFminiPlus = 25,
#endif
#if AP_RANGEFINDER_LANBAO_ENABLED
        Lanbao = 26,
#endif
#if AP_RANGEFINDER_BENEWAKE_TF03_ENABLED
        BenewakeTF03 = 27,
#endif
        VL53L1X_Short = 28,
#if AP_RANGEFINDER_LEDDARVU8_ENABLED
        LeddarVu8_Serial = 29,
#endif
#if AP_RANGEFINDER_HC_SR04_ENABLED
        HC_SR04 = 30,
#endif
#if AP_RANGEFINDER_GYUS42V2_ENABLED
        GYUS42v2 = 31,
#endif
#if HAL_MSP_RANGEFINDER_ENABLED
        MSP = 32,
#endif
#if AP_RANGEFINDER_USD1_CAN_ENABLED
        USD1_CAN = 33,
#endif
#if AP_RANGEFINDER_BENEWAKE_CAN_ENABLED
        Benewake_CAN = 34,
#endif
#if AP_RANGEFINDER_TERARANGER_SERIAL_ENABLED
        TeraRanger_Serial = 35,
#endif
#if AP_RANGEFINDER_LUA_ENABLED
        Lua_Scripting = 36,
#endif
#if AP_RANGEFINDER_NOOPLOOP_ENABLED
        NoopLoop_P = 37,
#endif
#if AP_RANGEFINDER_TOFSENSEP_CAN_ENABLED
        TOFSenseP_CAN = 38,
#endif
#if AP_RANGEFINDER_NRA24_CAN_ENABLED
        NRA24_CAN = 39,
#endif
#if AP_RANGEFINDER_TOFSENSEF_I2C_ENABLED
        TOFSenseF_I2C = 40,
#endif
#if AP_RANGEFINDER_JRE_SERIAL_ENABLED
        JRE_Serial = 41,
#endif
#if AP_RANGEFINDER_AINSTEIN_LR_D1_ENABLED
        Ainstein_LR_D1 = 42,
#endif
#if AP_RANGEFINDER_RDS02UF_ENABLED
        RDS02UF = 43,
#endif
#if AP_RANGEFINDER_SIM_ENABLED
        SIM = 100,
#endif
    };

    enum class Function {
        LINEAR    = 0,
        INVERTED  = 1,
        HYPERBOLA = 2
    };

    enum class Status {
        NotConnected = 0,
        NoData,
        OutOfRangeLow,
        OutOfRangeHigh,
        Good
    };

    static constexpr int8_t SIGNAL_QUALITY_MIN = 0;
    static constexpr int8_t SIGNAL_QUALITY_MAX = 100;
    static constexpr int8_t SIGNAL_QUALITY_UNKNOWN = -1;

    // The RangeFinder_State structure is filled in by the backend driver
    struct RangeFinder_State {
        float distance_m;               // distance in meters
        int8_t signal_quality_pct;      // measurement quality in percent 0-100, -1 -> quality is unknown
        uint16_t voltage_mv;            // voltage in millivolts, if applicable, otherwise 0
        enum RangeFinder::Status status; // sensor status
        uint8_t  range_valid_count;     // number of consecutive valid readings (maxes out at 10)
        uint32_t last_reading_ms;       // system time of last successful update from sensor

        const struct AP_Param::GroupInfo *var_info;
    };

    static const struct AP_Param::GroupInfo *backend_var_info[RANGEFINDER_MAX_INSTANCES];

    // parameters for each instance
    static const struct AP_Param::GroupInfo var_info[];

    void set_log_rfnd_bit(uint32_t log_rfnd_bit) { _log_rfnd_bit = log_rfnd_bit; }

    /*
      Return the number of range finder instances. Note that if users
      sets up rangefinders with a gap in the types then this is the
      index of the maximum sensor ID plus one, so this gives the value
      that should be used when iterating over all sensors
    */
    uint8_t num_sensors(void) const {
        return num_instances;
    }

    // prearm checks
    bool prearm_healthy(char *failure_msg, const uint8_t failure_msg_len) const;

    // detect and initialise any available rangefinders
    void init(enum Rotation orientation_default);

    // update state of all rangefinders. Should be called at around
    // 10Hz from main loop
    void update(void);

    // Handle an incoming DISTANCE_SENSOR message (from a MAVLink enabled range finder)
    void handle_msg(const mavlink_message_t &msg);

#if HAL_MSP_RANGEFINDER_ENABLED
    // Handle an incoming DISTANCE_SENSOR message (from a MSP enabled range finder)
    void handle_msp(const MSP::msp_rangefinder_data_message_t &pkt);
#endif
    // return true if we have a range finder with the specified orientation
    bool has_orientation(enum Rotation orientation) const;

    // find first range finder instance with the specified orientation
    AP_RangeFinder_Backend *find_instance(enum Rotation orientation) const;

    AP_RangeFinder_Backend *get_backend(uint8_t id) const;

    // get rangefinder type for an ID
    Type get_type(uint8_t id) const {
        return id >= RANGEFINDER_MAX_INSTANCES? Type::NONE : Type(params[id].type.get());
    }

    // get rangefinder address (for AP_Periph CAN)
    uint8_t get_address(uint8_t id) const {
        return id >= RANGEFINDER_MAX_INSTANCES? 0 : uint8_t(params[id].address.get());
    }
    
    // methods to return a distance on a particular orientation from
    // any sensor which can current supply it
    float distance_orient(enum Rotation orientation) const;
    uint16_t distance_cm_orient(enum Rotation orientation) const;
    int8_t signal_quality_pct_orient(enum Rotation orientation) const;
    int16_t max_distance_cm_orient(enum Rotation orientation) const;
    int16_t min_distance_cm_orient(enum Rotation orientation) const;
    int16_t ground_clearance_cm_orient(enum Rotation orientation) const;
    MAV_DISTANCE_SENSOR get_mav_distance_sensor_type_orient(enum Rotation orientation) const;
    RangeFinder::Status status_orient(enum Rotation orientation) const;
    bool has_data_orient(enum Rotation orientation) const;
    uint8_t range_valid_count_orient(enum Rotation orientation) const;
    const Vector3f &get_pos_offset_orient(enum Rotation orientation) const;
    uint32_t last_reading_ms(enum Rotation orientation) const;

    // get temperature reading in C.  returns true on success and populates temp argument
    bool get_temp(enum Rotation orientation, float &temp) const;

    /*
      set an externally estimated terrain height. Used to enable power
      saving (where available) at high altitudes.
     */
    void set_estimated_terrain_height(float height) {
        estimated_terrain_height = height;
    }

    static RangeFinder *get_singleton(void) { return _singleton; }

protected:
    AP_RangeFinder_Params params[RANGEFINDER_MAX_INSTANCES];

private:
    static RangeFinder *_singleton;

    RangeFinder_State state[RANGEFINDER_MAX_INSTANCES];
    AP_RangeFinder_Backend *drivers[RANGEFINDER_MAX_INSTANCES];
    uint8_t num_instances;
    HAL_Semaphore detect_sem;
    float estimated_terrain_height;
    Vector3f pos_offset_zero;   // allows returning position offsets of zero for invalid requests

    void detect_instance(uint8_t instance, uint8_t& serial_instance);

    bool _add_backend(AP_RangeFinder_Backend *driver, uint8_t instance, uint8_t serial_instance=0);

    uint32_t _log_rfnd_bit = -1;
    void Log_RFND() const;
};

namespace AP {
    RangeFinder *rangefinder();
};

#endif  // AP_RANGEFINDER_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       /*
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include "AP_RangeFinder_config.h"

#if AP_RANGEFINDER_AINSTEIN_LR_D1_ENABLED

#ifndef AP_RANGEFINDER_AINSTEIN_LR_D1_SHOW_MALFUNCTIONS
#define AP_RANGEFINDER_AINSTEIN_LR_D1_SHOW_MALFUNCTIONS 1
#endif

#include "AP_RangeFinder_Ainstein_LR_D1.h"
#include <GCS_MAVLink/GCS.h>

// get_reading - read a value from the sensor
bool AP_RangeFinder_Ainstein_LR_D1::get_reading(float &reading_m)
{
    if (uart == nullptr || uart->available() == 0) {
        return false;
    }

    bool has_data = false;

    uint32_t available = MAX(uart->available(), static_cast<unsigned int>(PACKET_SIZE*4));
    while (available >= PACKET_SIZE) {
        // ---------------
        // Sync up with the header
        const uint8_t header[] = {
            0xEB,   // Header MSB
            0x90,   // Header LSB
            0x00   // Device ID
        };
        for (uint8_t i = 0; i<ARRAY_SIZE(header); i++) {
            available--;
            if (uart->read() != header[i]) {
                continue;
            }
        }

        const uint8_t rest_of_packet_size = (PACKET_SIZE - ARRAY_SIZE(header));
        if (available < rest_of_packet_size) {  
            return false;
        }

        // ---------------
        // header is aligned!
        // ---------------

        uint8_t buffer[rest_of_packet_size];
        available -= uart->read(buffer, ARRAY_SIZE(buffer));

        const uint8_t checksum = buffer[ARRAY_SIZE(buffer)-1]; // last byte is a checksum
        if (crc_sum_of_bytes(buffer, ARRAY_SIZE(buffer)-1) != checksum) {
            // bad Checksum
            continue;
        }

        const uint8_t malfunction_alert = buffer[1];
        reading_m = UINT16_VALUE(buffer[3], buffer[4]) * 0.01;
        const uint8_t snr = buffer[5];

        has_data = true;

#if AP_RANGEFINDER_AINSTEIN_LR_D1_SHOW_MALFUNCTIONS
        const uint32_t now_ms = AP_HAL::millis();
        if (malfunction_alert_prev != malfunction_alert && now_ms - malfunction_alert_last_send_ms >= 1000) {
            malfunction_alert_prev = malfunction_alert;
            malfunction_alert_last_send_ms = now_ms;
            report_malfunction(malfunction_alert);
        }
#endif

        /* From datasheet:
            Altitude measurements associated with a SNR value 
            of 13dB or lower are considered erroneous. 

            SNR values of 0 are considered out of maximum range (655 metres)

            The altitude measurements should not in any circumstances be used as true
            measurements independently of the corresponding SNR values. 
        */
        signal_quality_pct = (snr <= 13 || malfunction_alert != 0) ? RangeFinder::SIGNAL_QUALITY_MIN : RangeFinder::SIGNAL_QUALITY_MAX;

        if (snr <= 13) {            
            has_data = false;           
            if (snr == 0) {
                state.status = RangeFinder::Status::OutOfRangeHigh;
                reading_m = MAX(656, max_distance_cm() * 0.01 + 1);
            } else {
                state.status = RangeFinder::Status::NoData;
            }
        } else {
            state.status = RangeFinder::Status::Good;
        }
    }

    return has_data;
}

#if AP_RANGEFINDER_AINSTEIN_LR_D1_SHOW_MALFUNCTIONS
void AP_RangeFinder_Ainstein_LR_D1::report_malfunction(const uint8_t _malfunction_alert_) {
    if (_malfunction_alert_ & static_cast<uint8_t>(MalfunctionAlert::Temperature)) {
        GCS_SEND_TEXT(MAV_SEVERITY_WARNING, "RangeFinder: Temperature alert");
    }
    if (_malfunction_alert_ & static_cast<uint8_t>(MalfunctionAlert::Voltage)) {
        GCS_SEND_TEXT(MAV_SEVERITY_WARNING, "RangeFinder: Voltage alert");
    }    
    if (_malfunction_alert_ & static_cast<uint8_t>(MalfunctionAlert::IFSignalSaturation)) {
        GCS_SEND_TEXT(MAV_SEVERITY_WARNING, "RangeFinder: IF signal saturation alert");
    }
    if (_malfunction_alert_ & static_cast<uint8_t>(MalfunctionAlert::AltitudeReading)) {
        GCS_SEND_TEXT(MAV_SEVERITY_WARNING, "RangeFinder: Altitude reading overflow alert");
    }
}
#endif // AP_RANGEFINDER_AINSTEIN_LR_D1_SHOW_MALFUNCTIONS

#endif // AP_RANGEFINDER_AINSTEIN_LR_D1_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     #pragma once

#include "AP_RangeFinder_config.h"

/*
 questions:
 - bug on page 22 on malfunction codes
 - fixed length seems strange at 28 bytes
 - definition of snr field is missing in documentation
 - roll/pitch limits are in conflict, 3.2 vs 
*/
#if AP_RANGEFINDER_AINSTEIN_LR_D1_ENABLED

#include "AP_RangeFinder.h"
#include "AP_RangeFinder_Backend_Serial.h"

class AP_RangeFinder_Ainstein_LR_D1 : public AP_RangeFinder_Backend_Serial
{

public:

    static AP_RangeFinder_Backend_Serial *create(
        RangeFinder::RangeFinder_State &_state,
        AP_RangeFinder_Params &_params) {
        return NEW_NOTHROW AP_RangeFinder_Ainstein_LR_D1(_state, _params);
    }

protected:

    MAV_DISTANCE_SENSOR _get_mav_distance_sensor_type() const override {
        return MAV_DISTANCE_SENSOR_RADAR;
    }

    uint32_t initial_baudrate(uint8_t serial_instance) const override {
        return 115200;
    }

private:

    using AP_RangeFinder_Backend_Serial::AP_RangeFinder_Backend_Serial;

    // get a reading
    bool get_reading(float &reading_m) override;

    // 0 is no return value, 100 is perfect.  false means signal
    // quality is not available
    int8_t get_signal_quality_pct() const override { return signal_quality_pct; };

    static void report_malfunction(const uint8_t _malfunction_alert_);

    enum class MalfunctionAlert : uint8_t {
        Temperature       = (1U << 0),  // 0x01
        Voltage           = (1U << 1),  // 0x02
        IFSignalSaturation= (1U << 6),  // 0x40
        AltitudeReading   = (1U << 7),  // 0x80
    };

    static constexpr uint8_t PACKET_SIZE = 32;
    uint8_t malfunction_alert_prev;
    uint32_t malfunction_alert_last_send_ms;
    int8_t signal_quality_pct = RangeFinder::SIGNAL_QUALITY_UNKNOWN;    
};
#endif                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     /*
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.

   HC-SR04 Ultrasonic Distance Sensor connected to BeagleBone Black
   by Mirko Denecke <mirkix@gmail.com>
 */

#include "AP_RangeFinder_BBB_PRU.h"

#if AP_RANGEFINDER_BBB_PRU_ENABLED

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/mman.h>
#include <sys/types.h>

extern const AP_HAL::HAL& hal;

volatile struct range *rangerpru;

/*
   Stop PRU, load firmware (check if firmware is present), start PRU.
   If we get a result the sensor seems to be there.
*/
bool AP_RangeFinder_BBB_PRU::detect()
{
    //The constructor is called when the detect() method returns true, more on this in the header file
    bool result = true;
    uint32_t mem_fd;
    uint32_t *ctrl;
    void *ram;

    mem_fd = open("/dev/mem", O_RDWR | O_SYNC | O_CLOEXEC);
    ctrl = (uint32_t*)mmap(0, 0x1000, PROT_READ | PROT_WRITE, MAP_SHARED, mem_fd, PRU0_CTRL_BASE);
    ram = mmap(0, PRU0_IRAM_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, mem_fd, PRU0_IRAM_BASE);

    // Reset PRU 0
    *ctrl = 0;
    hal.scheduler->delay(1);

    // Load firmware (.text)
    FILE *file = fopen("/lib/firmware/rangefinderprutext.bin", "rb");
    if (file == nullptr) {
        result = false;
    }

    if (fread(ram, PRU0_IRAM_SIZE, 1, file) != 1) {
        result = false;
    }

    fclose(file);

    munmap(ram, PRU0_IRAM_SIZE);

    ram = mmap(0, PRU0_DRAM_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, mem_fd, PRU0_DRAM_BASE);

    // Load firmware (.data)
    file = fopen("/lib/firmware/rangefinderprudata.bin", "rb");
    if (file == nullptr) {
        result = false;
    }

    if (fread(ram, PRU0_DRAM_SIZE, 1, file) != 1) {
        result = false;
    }

    fclose(file);

    munmap(ram, PRU0_DRAM_SIZE);

    // Map PRU RAM
    ram = mmap(0, 0x1000, PROT_READ | PROT_WRITE, MAP_SHARED, mem_fd, PRU0_DRAM_BASE);
    close(mem_fd);

    // Start PRU 0
    *ctrl = 2;

    rangerpru = (volatile struct range*)ram;

    return result;
}

/*
   update the state of the sensor
*/
void AP_RangeFinder_BBB_PRU::update(void)
{
    state.status = (RangeFinder::Status)rangerpru->status;
    state.distance_m = rangerpru->distance * 0.01f;
    state.last_reading_ms = AP_HAL::millis();
}
#endif // AP_RANGEFINDER_BBB_PRU_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      #pragma once

#include "AP_RangeFinder_config.h"

#if AP_RANGEFINDER_BBB_PRU_ENABLED

#include "AP_RangeFinder_Backend.h"

#define PRU0_CTRL_BASE 0x4a322000

#define PRU0_IRAM_BASE 0x4a334000
#define PRU0_IRAM_SIZE 0x2000

#define PRU0_DRAM_BASE 0x4a300000
#define PRU0_DRAM_SIZE 0x2000

struct range {
        uint32_t distance;
	uint32_t status;
};

class AP_RangeFinder_BBB_PRU : public AP_RangeFinder_Backend
{
public:
    /*
        Constructor:
        The constructor also initialises the rangefinder. Note that this
        constructor is not called until detect() returns true, so we
        already know that we should setup the rangefinder
    */
    using AP_RangeFinder_Backend::AP_RangeFinder_Backend;

    // static detection function
    static bool detect();

    // update state
    void update(void) override;

protected:

    MAV_DISTANCE_SENSOR _get_mav_distance_sensor_type() const override {
        return MAV_DISTANCE_SENSOR_ULTRASOUND;
    }

private:

};

#endif  // AP_RANGEFINDER_BBB_PRU_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               /*
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include "AP_RangeFinder_config.h"

#if AP_RANGEFINDER_ENABLED

#include <AP_Common/AP_Common.h>
#include <AP_HAL/AP_HAL.h>
#include "AP_RangeFinder.h"
#include "AP_RangeFinder_Backend.h"

extern const AP_HAL::HAL& hal;

/*
  base class constructor. 
  This incorporates initialisation as well.
*/
AP_RangeFinder_Backend::AP_RangeFinder_Backend(RangeFinder::RangeFinder_State &_state, AP_RangeFinder_Params &_params) :
        state(_state),
		params(_params)
{
    _backend_type = type();
}

MAV_DISTANCE_SENSOR AP_RangeFinder_Backend::get_mav_distance_sensor_type() const {
    if (type() == RangeFinder::Type::NONE) {
        return MAV_DISTANCE_SENSOR_UNKNOWN;
    }
    return _get_mav_distance_sensor_type();
}

RangeFinder::Status AP_RangeFinder_Backend::status() const {
    if (type() == RangeFinder::Type::NONE) {
        // turned off at runtime?
        return RangeFinder::Status::NotConnected;
    }
    return state.status;
}

// true if sensor is returning data
bool AP_RangeFinder_Backend::has_data() const {
    return ((state.status != RangeFinder::Status::NotConnected) &&
            (state.status != RangeFinder::Status::NoData));
}

// update status based on distance measurement
void AP_RangeFinder_Backend::update_status(RangeFinder::RangeFinder_State &state_arg) const
{
    // check distance
    if (state_arg.distance_m > max_distance_cm() * 0.01f) {
        set_status(state_arg, RangeFinder::Status::OutOfRangeHigh);
    } else if (state_arg.distance_m < min_distance_cm() * 0.01f) {
        set_status(state_arg, RangeFinder::Status::OutOfRangeLow);
    } else {
        set_status(state_arg, RangeFinder::Status::Good);
    }
}

// set status and update valid count
void AP_RangeFinder_Backend::set_status(RangeFinder::RangeFinder_State &state_arg, RangeFinder::Status _status)
{
    state_arg.status = _status;

    // update valid count
    if (_status == RangeFinder::Status::Good) {
        if (state_arg.range_valid_count < 10) {
            state_arg.range_valid_count++;
        }
    } else {
        state_arg.range_valid_count = 0;
    }
}

#if AP_SCRIPTING_ENABLED
// get a copy of state structure
void AP_RangeFinder_Backend::get_state(RangeFinder::RangeFinder_State &state_arg)
{
    WITH_SEMAPHORE(_sem);
    state_arg = state;
}
#endif

#endif  // AP_RANGEFINDER_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        /*
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
#pragma once

#include "AP_RangeFinder_config.h"

#if AP_RANGEFINDER_ENABLED

#include <AP_Common/AP_Common.h>
#include <AP_HAL/AP_HAL_Boards.h>
#include <AP_HAL/Semaphores.h>
#include "AP_RangeFinder.h"

class AP_RangeFinder_Backend
{
public:
    // constructor. This incorporates initialisation as well.
	AP_RangeFinder_Backend(RangeFinder::RangeFinder_State &_state, AP_RangeFinder_Params &_params);

    // we declare a virtual destructor so that RangeFinder drivers can
    // override with a custom destructor if need be
    virtual ~AP_RangeFinder_Backend(void) {}

    // update the state structure
    virtual void update() = 0;
    virtual void init_serial(uint8_t serial_instance) {};

    virtual void handle_msg(const mavlink_message_t &msg) { return; }

#if AP_SCRIPTING_ENABLED
    void get_state(RangeFinder::RangeFinder_State &state_arg);

    // Returns false if scripting backing hasn't been setup.
    virtual bool handle_script_msg(float dist_m) { return false; } // legacy interface
    virtual bool handle_script_msg(const RangeFinder::RangeFinder_State &state_arg) { return false; }
#endif

#if HAL_MSP_RANGEFINDER_ENABLED
    virtual void handle_msp(const MSP::msp_rangefinder_data_message_t &pkt) { return; }
#endif

    enum Rotation orientation() const { return (Rotation)params.orientation.get(); }
    float distance() const { return state.distance_m; }
    uint16_t distance_cm() const { return state.distance_m*100.0f; }
    int8_t signal_quality_pct() const  WARN_IF_UNUSED { return state.signal_quality_pct; }
    uint16_t voltage_mv() const { return state.voltage_mv; }
    virtual int16_t max_distance_cm() const { return params.max_distance_cm; }
    virtual int16_t min_distance_cm() const { return params.min_distance_cm; }
    int16_t ground_clearance_cm() const { return params.ground_clearance_cm; }
    MAV_DISTANCE_SENSOR get_mav_distance_sensor_type() const;
    RangeFinder::Status status() const;
    RangeFinder::Type type() const { return (RangeFinder::Type)params.type.get(); }

    // true if sensor is returning data
    bool has_data() const;

    // returns count of consecutive good readings
    uint8_t range_valid_count() const { return state.range_valid_count; }

    // return a 3D vector defining the position offset of the sensor
    // in metres relative to the body frame origin
    const Vector3f &get_pos_offset() const { return params.pos_offset; }

    // return system time of last successful read from the sensor
    uint32_t last_reading_ms() const { return state.last_reading_ms; }

    // get temperature reading in C.  returns true on success and populates temp argument
    virtual bool get_temp(float &temp) const { return false; }

    // return the actual type of the rangefinder, as opposed to the
    // parameter value which may be changed at runtime.
    RangeFinder::Type allocated_type() const { return _backend_type; }

protected:

    // update status based on distance measurement
    void update_status(RangeFinder::RangeFinder_State &state_arg) const;
    void update_status() { update_status(state); }

    // set status and update valid_count
    static void set_status(RangeFinder::RangeFinder_State &state_arg, RangeFinder::Status status);
    void set_status(RangeFinder::Status status) { set_status(state, status); }

    RangeFinder::RangeFinder_State &state;
    AP_RangeFinder_Params &params;

    // semaphore for access to shared frontend data
    HAL_Semaphore _sem;

    //Type Backend initialised with
    RangeFinder::Type _backend_type;

    virtual MAV_DISTANCE_SENSOR _get_mav_distance_sensor_type() const = 0;
};

#endif  // AP_RANGEFINDER_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                /*
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include "AP_RangeFinder_config.h"

#if AP_RANGEFINDER_BACKEND_CAN_ENABLED

#include <AP_HAL/AP_HAL.h>
#include "AP_RangeFinder_Backend_CAN.h"

const AP_Param::GroupInfo AP_RangeFinder_Backend_CAN::var_info[] = {

    // @Param: RECV_ID
    // @DisplayName: RangeFinder CAN receive ID
    // @Description: The receive ID of the CAN frames. A value of zero means all IDs are accepted.
    // @Range: 0 65535
    // @User: Advanced
    AP_GROUPINFO("RECV_ID", 10, AP_RangeFinder_Backend_CAN, receive_id, 0),

    // @Param: SNR_MIN
    // @DisplayName: RangeFinder Minimum signal strength
    // @Description: RangeFinder Minimum signal strength (SNR) to accept distance
    // @Range: 0 65535
    // @User: Advanced
    AP_GROUPINFO("SNR_MIN", 11, AP_RangeFinder_Backend_CAN, snr_min, 0),

    AP_GROUPEND
};

// constructor
AP_RangeFinder_Backend_CAN::AP_RangeFinder_Backend_CAN(
    RangeFinder::RangeFinder_State &_state, AP_RangeFinder_Params &_params, AP_CAN::Protocol can_type,
                                    const char *driver_name) :
    AP_RangeFinder_Backend(_state, _params)
{
    AP_Param::setup_object_defaults(this, var_info);
    state.var_info = var_info;
    multican_rangefinder = NEW_NOTHROW MultiCAN{FUNCTOR_BIND_MEMBER(&AP_RangeFinder_Backend_CAN::handle_frame, bool, AP_HAL::CANFrame &), can_type, driver_name};
    if (multican_rangefinder == nullptr) {
        AP_BoardConfig::allocation_error("Failed to create rangefinder multican");
    }
}

// update the state of the sensor
void AP_RangeFinder_Backend_CAN::update(void)
{
    if (get_reading(state.distance_m)) {
        // update range_valid state based on distance measured
        state.last_reading_ms = AP_HAL::millis();
        update_status();
    } else if (AP_HAL::millis() - state.last_reading_ms >= read_timeout_ms()) {
        set_status(RangeFinder::Status::NoData);
    }
}

// get distance measurement
bool AP_RangeFinder_Backend_CAN::get_reading(float &reading_m)
{
    WITH_SEMAPHORE(_sem);
    if (_distance_count != 0) {
        reading_m = _distance_sum / _distance_count;
        _distance_sum = 0;
        _distance_count = 0;
        return true;
    }

    return false;
}

// return true if the CAN ID is correct
bool AP_RangeFinder_Backend_CAN::is_correct_id(uint32_t id) const
{
    if (receive_id != 0 && id != uint32_t(receive_id.get())) {
        // incorrect receive ID
        return false;
    }
    return true;
}

#endif  // AP_RANGEFINDER_BACKEND_CAN_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        #pragma once

#include "AP_RangeFinder_config.h"

#if AP_RANGEFINDER_BACKEND_CAN_ENABLED

#include "AP_RangeFinder_Backend.h"
#include <AP_CANManager/AP_CANSensor.h>
#include <AP_BoardConfig/AP_BoardConfig.h>

class RangeFinder_MultiCAN;

class AP_RangeFinder_Backend_CAN : public AP_RangeFinder_Backend
{
public:
    // constructor
    AP_RangeFinder_Backend_CAN(RangeFinder::RangeFinder_State &_state,
                                AP_RangeFinder_Params &_params, AP_CAN::Protocol can_type,
                                const char *driver_name);

    friend class RangeFinder_MultiCAN;

    static const struct AP_Param::GroupInfo var_info[];

protected:

    // update state
    virtual void update(void) override;

    // get distance measurement
    bool get_reading(float &reading_m);

    // it is essential that anyone relying on the base-class update to implement this
    virtual bool handle_frame(AP_HAL::CANFrame &frame) = 0;

    // maximum time between readings before we change state to NoData:
    virtual uint32_t read_timeout_ms() const { return 200; }

    virtual MAV_DISTANCE_SENSOR _get_mav_distance_sensor_type() const override {
        return MAV_DISTANCE_SENSOR_RADAR;
    }

    // return true if the CAN ID is correct
    bool is_correct_id(uint32_t can_id) const;

    // set distance and count
    void accumulate_distance_m(float distance_m) {
        _distance_sum += distance_m;
        _distance_count++;
    };

    // linked list
    AP_RangeFinder_Backend_CAN *next;

    AP_Int32 receive_id; // CAN ID to receive for this backend
    AP_Int32 snr_min; // minimum signal strength to accept packet

    MultiCAN* multican_rangefinder; // Allows for multiple CAN rangefinders on a single bus
private:

    float _distance_sum; // meters
    uint32_t _distance_count;
};

#endif  // AP_RANGEFINDER_BACKEND_CAN_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               /*
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include "AP_RangeFinder_config.h"

#if AP_RANGEFINDER_ENABLED

#include <AP_HAL/AP_HAL.h>
#include "AP_RangeFinder_Backend_Serial.h"
#include <AP_SerialManager/AP_SerialManager.h>

#include <ctype.h>

extern const AP_HAL::HAL& hal;

/*
   The constructor also initialises the rangefinder. Note that this
   constructor is not called until detect() returns true, so we
   already know that we should setup the rangefinder
*/
AP_RangeFinder_Backend_Serial::AP_RangeFinder_Backend_Serial(
    RangeFinder::RangeFinder_State &_state,
    AP_RangeFinder_Params &_params) :
    AP_RangeFinder_Backend(_state, _params)
{

}

void AP_RangeFinder_Backend_Serial::init_serial(uint8_t serial_instance)
{
    uart = AP::serialmanager().find_serial(AP_SerialManager::SerialProtocol_Rangefinder, serial_instance);
    if (uart != nullptr) {
        uart->begin(initial_baudrate(serial_instance), rx_bufsize(), tx_bufsize());
    }
}

uint32_t AP_RangeFinder_Backend_Serial::initial_baudrate(const uint8_t serial_instance) const
{
    return AP::serialmanager().find_baudrate(AP_SerialManager::SerialProtocol_Rangefinder, serial_instance);
}

/*
   update the state of the sensor
*/
void AP_RangeFinder_Backend_Serial::update(void)
{
    if (get_reading(state.distance_m)) {
        state.signal_quality_pct = get_signal_quality_pct();
        // update range_valid state based on distance measured
        state.last_reading_ms = AP_HAL::millis();
        update_status();
    } else if (AP_HAL::millis() - state.last_reading_ms > read_timeout_ms()) {
        set_status(RangeFinder::Status::NoData);
    }
}

#endif  // AP_RANGEFINDER_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- x-quad-cg-allocation.lua: Adjust the control allocation matrix for offset CoG.
--
-- WARNING: This script is applicable only to X-type quadrotors and quadplanes.
--
-- How To Use
--   1. Place this script in the "scripts" directory.
--   2. Set FRAME_CLASS or Q_FRAME_CLASS to 17 to enable the dynamic scriptable mixer.
--   3. Enable Lua scripting via the SCR_ENABLE parameter.
--   4. Reboot.
--   5. Fly the vehicle.
--   6. Adjust the value of the CGA_RATIO parameter.
--
-- How It Works
--   1. The control allocation matrix is adjusted for thrust and pitch based on the ??? parameter value.

--[[
Global definitions.
--]]
local MAV_SEVERITY = {EMERGENCY=0, ALERT=1, CRITICAL=2, ERROR=3, WARNING=4, NOTICE=5, INFO=6, DEBUG=7}
local SCRIPT_NAME = "CoG adjust script"
local LOOP_RATE_HZ = 10
local last_warning_time_ms = uint32_t() -- Time we last sent a warning message to the user.
local WARNING_DEADTIME_MS = 1000 -- How often the user should be warned.
local is_mixer_matrix_static = false
local is_mixer_matrix_dynamic = false
local last_ratio = 1

-- State machine states.
local FSM_STATE = {
    INACTIVE = 0,
    INITIALIZE = 1,
    ACTIVE = 2,
    FINISHED = 3
}
local current_state = FSM_STATE.INACTIVE
local next_state = FSM_STATE.INACTIVE


--[[
New parameter declarations
--]]
local PARAM_TABLE_KEY = 139
local PARAM_TABLE_PREFIX = "CGA_"

-- Bind a parameter to a variable.
function bind_param(name)
    return Parameter(name)
end

-- Add a parameter and bind it to a variable.
function bind_add_param(name, idx, default_value)
    assert(param:add_param(PARAM_TABLE_KEY, idx, name, default_value), string.format('Could not add param %s', name))
    return bind_param(PARAM_TABLE_PREFIX .. name)
end

-- Add param table.
assert(param:add_table(PARAM_TABLE_KEY, PARAM_TABLE_PREFIX, 1), SCRIPT_NAME .. ': Could not add param table.')

--[[
  // @Param: CGA_RATIO
  // @DisplayName: CoG adjustment ratio
  // @Description: The ratio between the front and back motor outputs during steady-state hover. Positive when the CoG is in front of the motors midpoint (front motors work harder).
  // @Range: 0.5 2
  // @User: Advanced
--]]
CGA_RATIO = bind_add_param('RATIO', 1, 1)

-- Bindings to existing parameters

--[[
Potential additions:
--]]
-- Warn the user, throttling the message rate.
function warn_user(msg, severity)
    severity = severity or MAV_SEVERITY.WARNING -- Optional severity argument.
    if millis() - last_warning_time_ms > WARNING_DEADTIME_MS then
            gcs:send_text(severity, SCRIPT_NAME .. ": " .. msg)
        last_warning_time_ms = millis()
    end
end

-- Decide if the given ratio value makes sense.
function sanitize_ratio(ratio)
    if (ratio < 0.5) or (ratio > 2) then
        warn_user("CGA_RATIO value out of bounds.", MAV_SEVERITY.ERROR)
        CGA_RATIO:set(1.0)
        return 1.0 -- Return default.
    else
        return ratio
    end
end

-- Normalize the throttle factors to max 1
function normalize_throttle(factors)
    -- Find maximum value.
    local max_factor = 0
    for _, factor in ipairs(factors) do
        max_factor = math.max(max_factor, factor)
    end
    -- Adjust all values by it.
    normalized_factors = {}
    for _, factor in ipairs(factors) do
        table.insert(normalized_factors, factor / max_factor)
    end
    return normalized_factors
end

-- Calculate the thrust factors given a ratio.
function build_factors(ratio)
    local r1 = 2.0/(1+ratio)
    local r2 = 2.0*ratio/(1+ratio)
    local quad_x_factors = {r2, r1, r2, r1}
    return normalize_throttle(quad_x_factors)
end

-- Adjust the dynamic motor mixer.
function update_dynamic_mixer(ratio)

    Motors_dynamic:add_motor(0, 1)
    Motors_dynamic:add_motor(1, 3)
    Motors_dynamic:add_motor(2, 4)
    Motors_dynamic:add_motor(3, 2)

    factors = motor_factor_table()

    -- Roll stays as-is.
    factors:roll(0, -0.5)
    factors:roll(1,  0.5)
    factors:roll(2,  0.5)
    factors:roll(3, -0.5)

    -- Pitch stays as-is.
    factors:pitch(0, 0.5)
    factors:pitch(1, -0.5)
    factors:pitch(2, 0.5)
    factors:pitch(3, -0.5)

    -- Yaw stays as-is.
    factors:yaw(0,  0.5)
    factors:yaw(1,  0.5)
    factors:yaw(2, -0.5)
    factors:yaw(3, -0.5)

    -- Throttle is modulated.
    throttle_factors = build_factors(ratio)
    factors:throttle(0, throttle_factors[1])
    factors:throttle(1, throttle_factors[2])
    factors:throttle(2, throttle_factors[3])
    factors:throttle(3, throttle_factors[4])

    Motors_dynamic:load_factors(factors)

    if not Motors_dynamic:init(4) then
        warn_user("Failed to initialize motor matrix!", MAV_SEVERITY.EMERGENCY)
    else
        if ratio ~= last_ratio then
            warn_user("Set ratio to " .. tostring(ratio), MAV_SEVERITY.INFO)
            last_ratio = ratio
        end
    end
    motors:set_frame_string("Dynamic CoM adjust")

end

-- Adjust the static motor mixer.
function update_static_mixer(ratio)
    MotorsMatrix:add_motor_raw(0,-0.5, 0.5, 0.5, 2)
    MotorsMatrix:add_motor_raw(1, 0.5,-0.5, 0.5, 4)
    MotorsMatrix:add_motor_raw(2, 0.5, 0.5,-0.5, 1)
    MotorsMatrix:add_motor_raw(3,-0.5,-0.5,-0.5, 3)

    throttle_factors = build_factors(ratio)
    MotorsMatrix:set_throttle_factor(0, throttle_factors[1])
    MotorsMatrix:set_throttle_factor(1, throttle_factors[2])
    MotorsMatrix:set_throttle_factor(2, throttle_factors[3])
    MotorsMatrix:set_throttle_factor(3, throttle_factors[4])

    if not MotorsMatrix:init(4) then
        warn_user("Failed to initialize motor matrix!", MAV_SEVERITY.EMERGENCY)
    else
        if ratio ~= last_ratio then
            warn_user("Set ratio to " .. tostring(ratio), MAV_SEVERITY.INFO)
            last_ratio = ratio
        end
    end
    motors:set_frame_string("Static CoM adjust")
end

-- Decide if the UA is a Quad X quadplane.
function inspect_frame_class_fw()

    Q_ENABLE = bind_param("Q_ENABLE")
    Q_FRAME_CLASS = bind_param("Q_FRAME_CLASS")

    if FWVersion:type()==3 then
        -- Test for the validity of the parameters.
        if Q_ENABLE:get()==1 then
            if Q_FRAME_CLASS:get()==15 then
                is_mixer_matrix_static = true
            elseif Q_FRAME_CLASS:get()==17 then
                is_mixer_matrix_dynamic = true
            end
        end
    end
end

-- Decide if the UA is a Quad X multicopter.
function inspect_frame_class_mc()

    FRAME_CLASS = bind_param("FRAME_CLASS")

    if FWVersion:type()==2 then 
        if FRAME_CLASS:get()==15 then
            is_mixer_matrix_static = true
        elseif FRAME_CLASS:get()==17 then
            is_mixer_matrix_dynamic = true
        end
    end
end

--[[
Activation conditions
--]]
-- Check for script activating conditions here.
-- Check frame types.
function can_start()
    result = is_mixer_matrix_static or is_mixer_matrix_dynamic
    return result
end

--[[
State machine
--]]
function fsm_step()
    if current_state == FSM_STATE.INACTIVE then
        if can_start() then
            next_state = FSM_STATE.INITIALIZE
        else
            next_state = FSM_STATE.FINISHED
            warn_user("Could not find scriptable mixer", MAV_SEVERITY.ERROR)
        end

    elseif current_state == FSM_STATE.INITIALIZE then
        if is_mixer_matrix_static then
            local ratio = sanitize_ratio(CGA_RATIO:get())
            update_static_mixer(ratio)
            next_state = FSM_STATE.FINISHED
        else
            next_state = FSM_STATE.ACTIVE
        end

    elseif current_state == FSM_STATE.ACTIVE then
        -- Assert the parameter limits.
        local ratio = sanitize_ratio(CGA_RATIO:get())
        -- Create the control allocation matrix parameters.
        update_dynamic_mixer(ratio)
        
    else
        gcs:send_text(MAV_SEVERITY.CRITICAL, "Unexpected FSM state!")
    end

    current_state = next_state
end

-- Check once on boot if the frame type is suitable for this script.
pcall(inspect_frame_class_mc)
pcall(inspect_frame_class_fw)
gcs:send_text(MAV_SEVERITY.INFO, SCRIPT_NAME .. string.format(" loaded."))

-- Wrapper around update() to catch errors.
function protected_wrapper()
  local success, err = pcall(fsm_step)
  if not success then
    gcs:send_text(MAV_SEVERITY.EMERGENCY, "Internal Error: " .. err)
    return protected_wrapper, 1000
  end
  if not (current_state == FSM_STATE.FINISHED) then
    return protected_wrapper, 1000.0/LOOP_RATE_HZ
  end
end

-- Start running update loop
return protected_wrapper()
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         # Multicopter CoM compensation

This script allows for adjusting the control allocation matrix.

When the Center of Mass (CoM) of an airframe does not coincide with the center
of its thrusters, then there is a lever arm between the thrust vector and the
CoM. This often is the case in VTOL fixed-wing aircraft (quadplanes) where
typically the CoM is more forward than the center of thrust. As a result, the
thrust produces a pitch-down moment. This produces a disturbance in the pitch
control and requires significant wind-up in the pitch integrator.

To compensate for this issue, this script employs the scriptable control
allocation matrix to request asymmeterical front and back thrust.

WARNING: This script is applicable only to X-type quadrotors and quadplanes. Do
not use in any other frame configuration!

# Parameters

The script adds 1 parameter to control its behaviour.

## CGA_RATIO

This is the desired ratio between the front and back thrust. To have the front
motors produce more lift that the rear, increase higher than 1.

Reasonable extreme values are 2 (front works twice as hard as the rear) and 0.5
(the inverse case). Given an out-of-bounds parameter value, the script will
revert to the default 1.0. 

# Operation

## How To Use

First of all, place this script in the "scripts" directory.

To tune `CGA_RATIO` on the fly:

  1. Set `FRAME_CLASS` or `Q_FRAME_CLASS` (for quadplanes) to 17 to enable the
  dynamic scriptable mixer.
  2. Enable Lua scripting via the `SCR_ENABLE` parameter.
  3. Reboot.
  4. Fly the vehicle.
  5. Adjust the value of the `CGA_RATIO` parameter. A good indicator of a good
  tune is to monitor the telemetry value `PID_TUNE[2].I` (pitch rate controller
  integrator) until it reaches zero during a stable hover.

Once you are happy with the tuning, you can fall back to the static motor
matrix, which consumes no resources from the scripting engine:

  1. Set `FRAME_CLASS` or `Q_FRAME_CLASS` (for quadplanes) to 15 to enable the
  static scriptable mixer.
  2. Ensure Lua scripting is enabled via the `SCR_ENABLE` parameter.
  3. Reboot.
  
The aircraft is ready to fly.
Keep in mind that any further changes to `CGA_RATIO` will now require a reboot.

## How It Works

  1. The dynamic control allocation matrix is able to change the coefficients
  that convert the throttle command to individual PWM commands for every motor.
  These coefficients have a default value of 1.
  2. The parameter `CGA_RATIO` is used to alter these coefficients, so that the
  front and back thrust commands are not equal.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  --[[ 
 device driver for ANX CAN battery monitor
--]]

---@diagnostic disable: param-type-mismatch
---@diagnostic disable: missing-parameter

local MAV_SEVERITY = {EMERGENCY=0, ALERT=1, CRITICAL=2, ERROR=3, WARNING=4, NOTICE=5, INFO=6, DEBUG=7}

local PARAM_TABLE_KEY = 45
local PARAM_TABLE_PREFIX = "BATT_ANX_"

-- add a parameter and bind it to a variable
function bind_add_param(name, idx, default_value)
    assert(param:add_param(PARAM_TABLE_KEY, idx, name, default_value), string.format('could not add param %s', name))
    return Parameter(PARAM_TABLE_PREFIX .. name)
end

-- Type conversion functions, little endian
function get_uint16(frame, ofs)
    return frame:data(ofs) + (frame:data(ofs + 1) << 8)
end

-- Setup EFI Parameters
assert(param:add_table(PARAM_TABLE_KEY, PARAM_TABLE_PREFIX, 15), 'could not add param table')

--[[
  // @Param: BATT_ANX_ENABLE
  // @DisplayName: Enable ANX battery support
  // @Description: Enable ANX battery support
  // @Values: 0:Disabled,1:Enabled
  // @User: Standard
--]]
local BATT_ANX_ENABLE = bind_add_param('ENABLE', 1, 0)

--[[
  // @Param: BATT_ANX_CANDRV
  // @DisplayName: Set ANX CAN driver
  // @Description: Set ANX CAN driver
  // @Values: 0:None,1:1stCANDriver,2:2ndCanDriver
  // @User: Standard
--]]
local BATT_ANX_CANDRV     = bind_add_param('CANDRV',     2, 1)

--[[
  // @Param: BATT_ANX_INDEX
  // @DisplayName: ANX CAN battery index
  // @Description: ANX CAN battery index
  // @Range: 1 10
  // @User: Standard
--]]
local BATT_ANX_INDEX     = bind_add_param('INDEX',     3, 1)

--[[
  // @Param: BATT_ANX_OPTIONS
  // @DisplayName: ANX CAN battery options
  // @Description: ANX CAN battery options
  // @Bitmask: 0:LogAllFrames
  // @User: Advanced
--]]
local BATT_ANX_OPTIONS   = bind_add_param('OPTIONS',    4, 0)

local OPTION_LOGALLFRAMES = 0x01

if BATT_ANX_ENABLE:get() == 0 then
   gcs:send_text(0, string.format("BATT_ANX: disabled"))
   return
end

-- Register for the CAN drivers
local driver

local CAN_BUF_LEN = 25
if BATT_ANX_CANDRV:get() == 1 then
   driver = CAN.get_device(CAN_BUF_LEN)
elseif BATT_ANX_CANDRV:get() == 2 then
   driver = CAN.get_device2(CAN_BUF_LEN)
end

if not driver then
    gcs:send_text(0, string.format("BATT_ANX: Failed to load driver"))
    return
end

local assembly = {}
assembly.num_frames = 0
assembly.frames = {}

--[[
   xmodem CRC implementation thanks to https://github.com/cloudwu/skynet
   under MIT license
--]]
local XMODEMCRC16Lookup = {
   0x0000, 0x1021, 0x2042, 0x3063, 0x4084, 0x50A5, 0x60C6, 0x70E7,
   0x8108, 0x9129, 0xA14A, 0xB16B, 0xC18C, 0xD1AD, 0xE1CE, 0xF1EF,
   0x1231, 0x0210, 0x3273, 0x2252, 0x52B5, 0x4294, 0x72F7, 0x62D6,
   0x9339, 0x8318, 0xB37B, 0xA35A, 0xD3BD, 0xC39C, 0xF3FF, 0xE3DE,
   0x2462, 0x3443, 0x0420, 0x1401, 0x64E6, 0x74C7, 0x44A4, 0x5485,
   0xA56A, 0xB54B, 0x8528, 0x9509, 0xE5EE, 0xF5CF, 0xC5AC, 0xD58D,
   0x3653, 0x2672, 0x1611, 0x0630, 0x76D7, 0x66F6, 0x5695, 0x46B4,
   0xB75B, 0xA77A, 0x9719, 0x8738, 0xF7DF, 0xE7FE, 0xD79D, 0xC7BC,
   0x48C4, 0x58E5, 0x6886, 0x78A7, 0x0840, 0x1861, 0x2802, 0x3823,
   0xC9CC, 0xD9ED, 0xE98E, 0xF9AF, 0x8948, 0x9969, 0xA90A, 0xB92B,
   0x5AF5, 0x4AD4, 0x7AB7, 0x6A96, 0x1A71, 0x0A50, 0x3A33, 0x2A12,
   0xDBFD, 0xCBDC, 0xFBBF, 0xEB9E, 0x9B79, 0x8B58, 0xBB3B, 0xAB1A,
   0x6CA6, 0x7C87, 0x4CE4, 0x5CC5, 0x2C22, 0x3C03, 0x0C60, 0x1C41,
   0xEDAE, 0xFD8F, 0xCDEC, 0xDDCD, 0xAD2A, 0xBD0B, 0x8D68, 0x9D49,
   0x7E97, 0x6EB6, 0x5ED5, 0x4EF4, 0x3E13, 0x2E32, 0x1E51, 0x0E70,
   0xFF9F, 0xEFBE, 0xDFDD, 0xCFFC, 0xBF1B, 0xAF3A, 0x9F59, 0x8F78,
   0x9188, 0x81A9, 0xB1CA, 0xA1EB, 0xD10C, 0xC12D, 0xF14E, 0xE16F,
   0x1080, 0x00A1, 0x30C2, 0x20E3, 0x5004, 0x4025, 0x7046, 0x6067,
   0x83B9, 0x9398, 0xA3FB, 0xB3DA, 0xC33D, 0xD31C, 0xE37F, 0xF35E,
   0x02B1, 0x1290, 0x22F3, 0x32D2, 0x4235, 0x5214, 0x6277, 0x7256,
   0xB5EA, 0xA5CB, 0x95A8, 0x8589, 0xF56E, 0xE54F, 0xD52C, 0xC50D,
   0x34E2, 0x24C3, 0x14A0, 0x0481, 0x7466, 0x6447, 0x5424, 0x4405,
   0xA7DB, 0xB7FA, 0x8799, 0x97B8, 0xE75F, 0xF77E, 0xC71D, 0xD73C,
   0x26D3, 0x36F2, 0x0691, 0x16B0, 0x6657, 0x7676, 0x4615, 0x5634,
   0xD94C, 0xC96D, 0xF90E, 0xE92F, 0x99C8, 0x89E9, 0xB98A, 0xA9AB,
   0x5844, 0x4865, 0x7806, 0x6827, 0x18C0, 0x08E1, 0x3882, 0x28A3,
   0xCB7D, 0xDB5C, 0xEB3F, 0xFB1E, 0x8BF9, 0x9BD8, 0xABBB, 0xBB9A,
   0x4A75, 0x5A54, 0x6A37, 0x7A16, 0x0AF1, 0x1AD0, 0x2AB3, 0x3A92,
   0xFD2E, 0xED0F, 0xDD6C, 0xCD4D, 0xBDAA, 0xAD8B, 0x9DE8, 0x8DC9,
   0x7C26, 0x6C07, 0x5C64, 0x4C45, 0x3CA2, 0x2C83, 0x1CE0, 0x0CC1,
   0xEF1F, 0xFF3E, 0xCF5D, 0xDF7C, 0xAF9B, 0xBFBA, 0x8FD9, 0x9FF8,
   0x6E17, 0x7E36, 0x4E55, 0x5E74, 0x2E93, 0x3EB2, 0x0ED1, 0x1EF0
}

local function crc_ANX(bytes)
   -- ANX CRC uses xmodem with a seed of 0xa635
   local crc = 0xa635
	for i=1,#bytes do
		local b = string.byte(bytes,i,i)
		crc = ((crc<<8) & 0xffff) ~ XMODEMCRC16Lookup[(((crc>>8)~b) & 0xff) + 1]
	end
    return crc
end

local frame_count = 0

local function log_can_frame(frame)
   logger.write("CANF",'Id,DLC,FC,B0,B1,B2,B3,B4,B5,B6,B7','IBIBBBBBBBB',
                frame:id(),
                frame:dlc(),
                frame_count,
                frame:data(0), frame:data(1), frame:data(2), frame:data(3),
                frame:data(4), frame:data(5), frame:data(6), frame:data(7))
   frame_count = frame_count + 1
end
 

local function parse_volt_frame(payload)
   if #payload < 12 then
      -- invalid length
      return
   end
   local total_volt, current, rem_cap, temperature, _ = string.unpack("<HhHhH", string.sub(payload, 1, 10))
   total_volt = total_volt * 0.01
   -- it is a discharge, so use minus current
   current = -current * 0.01
   rem_cap = rem_cap * 0.1
   temperature = temperature * 0.1
   local num_cells = (#payload - 10) / 2
   local cells = {}
   for i = 1, num_cells do
      cells[i] = string.unpack("<H", string.sub(payload, 11+(i-1)*2, 11+i*2))
      cells[i] = cells[i]
   end
   -- API allows for up to 32 cells, but battery backend is more limited
   if num_cells > 32 then
      num_cells = 32
   end

   local state = BattMonitorScript_State()
   state:healthy(true)
   state:voltage(total_volt)
   state:cell_count(num_cells)
   state:capacity_remaining_pct(math.floor(rem_cap))
   for i = 1, num_cells do
      state:cell_voltages(i-1, cells[i])
   end
   state:current_amps(current)
   state:temperature(temperature)

   battery:handle_scripting(BATT_ANX_INDEX:get()-1, state)
end


--[[
   process a set of frames for a whole packet
--]]
local function process_frames(msg_type_id)
   local bytes = ""
   for i = 1, assembly.num_frames do
      local dlc = assembly.frames[i]:dlc()
      for ofs = 1, dlc do
         bytes = bytes .. string.char(assembly.frames[i]:data(ofs-1))
      end
   end
   local crc = string.unpack("<H", string.sub(bytes, 1, 2))
   local payload = string.sub(bytes, 3, #bytes)
   if crc ~= crc_ANX(payload) then
      return
   end
   -- message types with cell voltages are from 721 to 727
   if msg_type_id >= 721 and msg_type_id <= 727 then
      parse_volt_frame(payload)
   end
end

--[[
   read from CAN bus, updating battery backend
--]]
local function read_can()
   while true do
      local frame = driver:read_frame()
      if not frame then
         return
      end
      if BATT_ANX_OPTIONS:get() & OPTION_LOGALLFRAMES ~= 0 then
         log_can_frame(frame)
      end
      if not frame:isExtended() then
         -- only want extended frames
         break
      end
      local id = frame:id_signed()
      -- local sender_id = id&0x7
      local last_pkt_id = (id>>3) & 1
      local pkt_count = (id>>4) & 0x3F
      -- local pkt_id = (id>>10) & 0x7f
      -- local trans_type = (id>>17) & 0x03
      local msg_type_id = (id>>19) & 0x3FF

      if pkt_count ~= assembly.num_frames then
         -- reset, non-contiguous packets
         assembly.num_frames = 0
      end

      assembly.num_frames = assembly.num_frames + 1
      assembly.frames[assembly.num_frames] = frame
      if last_pkt_id == 1 then
         process_frames(msg_type_id)
         -- reset for next frame
         assembly.num_frames = 0
      end
   end
end

function update()
   read_can()
   return update,10
end

gcs:send_text(MAV_SEVERITY.INFO, "BATT_ANX: Started")

return update()
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            --[[
 DLA serial EFI protocol

 Note that this protocol is gap framed, no CRC

 https://www.austars-model.com/dla-232cc-uavuas-engine-optional-one-key-startauto-startergenerator_g17937.html
--]]

local PARAM_TABLE_KEY = 41
local PARAM_TABLE_PREFIX = "EFI_DLA_"

local MAV_SEVERITY = {EMERGENCY=0, ALERT=1, CRITICAL=2, ERROR=3, WARNING=4, NOTICE=5, INFO=6, DEBUG=7}

-- bind a parameter to a variable given
local function bind_param(name)
    local p = Parameter()
    assert(p:init(name), string.format('could not find %s parameter', name))
    return p
end

-- add a parameter and bind it to a variable
local function bind_add_param(name, idx, default_value)
    assert(param:add_param(PARAM_TABLE_KEY, idx, name, default_value), string.format('could not add param %s', name))
    return bind_param(PARAM_TABLE_PREFIX .. name)
end

-- setup script specific parameters
assert(param:add_table(PARAM_TABLE_KEY, PARAM_TABLE_PREFIX, 8), 'could not add param table')

--[[
  // @Param: EFI_DLA_ENABLE
  // @DisplayName: EFI DLA enable
  // @Description: Enable EFI DLA driver
  // @Values: 0:Disabled,1:Enabled
  // @User: Standard
--]]
EFI_DLA_ENABLE = bind_add_param("ENABLE", 1, 0)

--[[
  // @Param: EFI_DLA_LPS
  // @DisplayName: EFI DLA fuel scale
  // @Description: EFI DLA litres of fuel per second of injection time
  // @Range: 0.00001 1
  // @Units: litres
  // @User: Standard
--]]
EFI_DLA_LPS = bind_add_param("LPS", 2, 0.001)

if EFI_DLA_ENABLE:get() ~= 1 then
   return
end

local uart = serial:find_serial(0) -- first scripting serial
if not uart then
   gcs:send_text(MAV_SEVERITY.ERROR, "EFI_DLA: unable to find scripting serial")
   return
end
uart:begin(115200)

local efi_backend = efi:get_backend(0)
if not efi_backend then
   gcs:send_text(MAV_SEVERITY.ERROR, "EFI_DLA: unable to find EFI backend")
   return
end

--[[
   discard n bytes
--]]
local function discard_bytes(n)
   for _ = 1, n do
      uart:read()
   end
end

local function read_bytes(n)
   local ret = ""
   for _ = 1, n do
      ret = ret .. string.char(uart:read())
   end
   return ret
end

local state = {}
state.last_read_us = uint32_t(0)
state.total_fuel_cm3 = 0.0

--[[
   check for input and parse data
--]]
local function check_input()
   local n_bytes = uart:available():toint()
   --gcs:send_text(MAV_SEVERITY.INFO, string.format("n_bytes=%u %.2f", n_bytes, millis():tofloat()*0.001))
   if n_bytes < 82 then
      return
   end
   if n_bytes > 82 then
      discard_bytes(n_bytes)
      return
   end

   state.seconds, state.pw1, state.pw2 = string.unpack("<HHH", read_bytes(6))
   state.rpm, state.adv_deg, state.squirt = string.unpack("<HhB", read_bytes(5))
   state.engine, state.afrtgt1, state.afrtgt2 = string.unpack("<BBB", read_bytes(3))
   state.wbo2_en1, state.wbo2_en2, state.baro = string.unpack("<BBh", read_bytes(4))
   state.map, state.mat, state.clt = string.unpack("<hhh", read_bytes(6))
   state.tps, state.batt = string.unpack("<hh", read_bytes(4))

   state.last_read_us = micros()

   -- discard the rest
   discard_bytes(uart:available():toint())
end

--[[
   request more data
--]]
local function request_data()
   --uart:write(string.byte("a"))
   uart:write(0x61)
end

local function farenheight_to_C(v)
   return (v + 459.67) * 0.55556
end

--[[
   update EFI state
--]]
local function update_EFI()
   if state.last_read_us == uint32_t(0) then
      return
   end
   local cylinder_state = Cylinder_Status()
   local efi_state = EFI_State()

   -- 4.3.x incorrectly uses C instead of kelvin
   -- local C_TO_KELVIN = 273.2

   cylinder_state:cylinder_head_temperature(farenheight_to_C(state.clt*0.1))
   cylinder_state:exhaust_gas_temperature(farenheight_to_C(state.mat*0.1))
   cylinder_state:ignition_timing_deg(state.adv_deg*0.1)

   local inj_time_ms = (state.pw1+state.pw2)*0.001
   cylinder_state:injection_time_ms(inj_time_ms)

   efi_state:engine_speed_rpm(state.rpm)

   efi_state:atmospheric_pressure_kpa(state.baro*0.1)
   efi_state:intake_manifold_pressure_kpa(state.map*0.1)
   efi_state:intake_manifold_temperature(farenheight_to_C(state.mat*0.1))
   efi_state:throttle_position_percent(math.floor(state.tps*0.1))
   efi_state:ignition_voltage(state.batt*0.1)

   local now_us = micros()
   local dt = (now_us - state.last_read_us):tofloat()*1.0e-6
   state.last_read_us = now_us

   local revs = state.rpm * 60.0 * dt
   local inj_time = revs * inj_time_ms * 0.001
   local fuel_used_cm3 = EFI_DLA_LPS:get() * 0.001 * inj_time

   state.total_fuel_cm3 = state.total_fuel_cm3 + fuel_used_cm3

   efi_state:fuel_consumption_rate_cm3pm((fuel_used_cm3 / dt) * 60.0)
   efi_state:estimated_consumed_fuel_volume_cm3(state.total_fuel_cm3)
   
   efi_state:cylinder_status(cylinder_state)
   efi_state:last_updated_ms(millis())

   -- Set the EFI_State into the EFI scripting driver
   efi_backend:handle_scripting(efi_state)
end


--[[
   main update function
--]]
local function update()
   check_input()
   update_EFI()
   request_data()

   return update, 100
end

gcs:send_text(MAV_SEVERITY.INFO, "EFI_DLA: loaded")

return update()
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     --[[
   driver for HobbyWing DataLink ESC telemetry
--]]

---@diagnostic disable: param-type-mismatch

local PARAM_TABLE_KEY = 44
local PARAM_TABLE_PREFIX = "ESC_HW_"

local MAV_SEVERITY = {EMERGENCY=0, ALERT=1, CRITICAL=2, ERROR=3, WARNING=4, NOTICE=5, INFO=6, DEBUG=7}

-- bind a parameter to a variable given
local function bind_param(name)
    local p = Parameter()
    assert(p:init(name), string.format('could not find %s parameter', name))
    return p
end

-- add a parameter and bind it to a variable
local function bind_add_param(name, idx, default_value)
    assert(param:add_param(PARAM_TABLE_KEY, idx, name, default_value), string.format('could not add param %s', name))
    return bind_param(PARAM_TABLE_PREFIX .. name)
end

-- setup script specific parameters
assert(param:add_table(PARAM_TABLE_KEY, PARAM_TABLE_PREFIX, 8), 'could not add param table')

--[[
  // @Param: ESC_HW_ENABLE
  // @DisplayName: Hobbywing ESC Enable
  // @Description: Enable Hobbywing ESC telemetry
  // @Values: 0:Disabled,1:Enabled
  // @User: Standard
--]]
ESC_HW_ENABLE = bind_add_param("ENABLE", 1, 0)

--[[
  // @Param: ESC_HW_POLES
  // @DisplayName: Hobbywing ESC motor poles
  // @Description: Number of motor poles for eRPM scaling
  // @Range: 1 50
  // @User: Standard
--]]
ESC_HW_POLES = bind_add_param("POLES", 2, 14)

--[[
  // @Param: ESC_HW_OFS
  // @DisplayName: Hobbywing ESC motor offset
  // @Description: Motor number offset of first ESC
  // @Range: 0 31
  // @User: Standard
--]]
ESC_HW_OFS = bind_add_param("OFS", 3, 0)

if ESC_HW_ENABLE:get() ~= 1 then
   gcs:send_text(MAV_SEVERITY.INFO, "ESC_HW: disabled")
   return
end

local uart = serial:find_serial(0) -- first scripting serial
if not uart then
   gcs:send_text(MAV_SEVERITY.ERROR, "ESC_HW: unable to find serial port")
   return
end
uart:begin(115200)

local function read_bytes(n)
   local ret = ""
   for _ = 1, n do
      ret = ret .. string.char(uart:read())
   end
   return ret
end

--[[
   discard pending bytes
--]]
local function discard_pending()
   local n = uart:available():toint()
   for _ = 1, n do
      uart:read()
   end
end

--[[
   xmodem CRC implementation thanks to https://github.com/cloudwu/skynet
   under MIT license
--]]
local XMODEMCRC16Lookup = {
	0x0000,0x1021,0x2042,0x3063,0x4084,0x50a5,0x60c6,0x70e7,
	0x8108,0x9129,0xa14a,0xb16b,0xc18c,0xd1ad,0xe1ce,0xf1ef,
	0x1231,0x0210,0x3273,0x2252,0x52b5,0x4294,0x72f7,0x62d6,
	0x9339,0x8318,0xb37b,0xa35a,0xd3bd,0xc39c,0xf3ff,0xe3de,
	0x2462,0x3443,0x0420,0x1401,0x64e6,0x74c7,0x44a4,0x5485,
	0xa56a,0xb54b,0x8528,0x9509,0xe5ee,0xf5cf,0xc5ac,0xd58d,
	0x3653,0x2672,0x1611,0x0630,0x76d7,0x66f6,0x5695,0x46b4,
	0xb75b,0xa77a,0x9719,0x8738,0xf7df,0xe7fe,0xd79d,0xc7bc,
	0x48c4,0x58e5,0x6886,0x78a7,0x0840,0x1861,0x2802,0x3823,
	0xc9cc,0xd9ed,0xe98e,0xf9af,0x8948,0x9969,0xa90a,0xb92b,
	0x5af5,0x4ad4,0x7ab7,0x6a96,0x1a71,0x0a50,0x3a33,0x2a12,
	0xdbfd,0xcbdc,0xfbbf,0xeb9e,0x9b79,0x8b58,0xbb3b,0xab1a,
	0x6ca6,0x7c87,0x4ce4,0x5cc5,0x2c22,0x3c03,0x0c60,0x1c41,
	0xedae,0xfd8f,0xcdec,0xddcd,0xad2a,0xbd0b,0x8d68,0x9d49,
	0x7e97,0x6eb6,0x5ed5,0x4ef4,0x3e13,0x2e32,0x1e51,0x0e70,
	0xff9f,0xefbe,0xdfdd,0xcffc,0xbf1b,0xaf3a,0x9f59,0x8f78,
	0x9188,0x81a9,0xb1ca,0xa1eb,0xd10c,0xc12d,0xf14e,0xe16f,
	0x1080,0x00a1,0x30c2,0x20e3,0x5004,0x4025,0x7046,0x6067,
	0x83b9,0x9398,0xa3fb,0xb3da,0xc33d,0xd31c,0xe37f,0xf35e,
	0x02b1,0x1290,0x22f3,0x32d2,0x4235,0x5214,0x6277,0x7256,
	0xb5ea,0xa5cb,0x95a8,0x8589,0xf56e,0xe54f,0xd52c,0xc50d,
	0x34e2,0x24c3,0x14a0,0x0481,0x7466,0x6447,0x5424,0x4405,
	0xa7db,0xb7fa,0x8799,0x97b8,0xe75f,0xf77e,0xc71d,0xd73c,
	0x26d3,0x36f2,0x0691,0x16b0,0x6657,0x7676,0x4615,0x5634,
	0xd94c,0xc96d,0xf90e,0xe92f,0x99c8,0x89e9,0xb98a,0xa9ab,
	0x5844,0x4865,0x7806,0x6827,0x18c0,0x08e1,0x3882,0x28a3,
	0xcb7d,0xdb5c,0xeb3f,0xfb1e,0x8bf9,0x9bd8,0xabbb,0xbb9a,
	0x4a75,0x5a54,0x6a37,0x7a16,0x0af1,0x1ad0,0x2ab3,0x3a92,
	0xfd2e,0xed0f,0xdd6c,0xcd4d,0xbdaa,0xad8b,0x9de8,0x8dc9,
	0x7c26,0x6c07,0x5c64,0x4c45,0x3ca2,0x2c83,0x1ce0,0x0cc1,
	0xef1f,0xff3e,0xcf5d,0xdf7c,0xaf9b,0xbfba,0x8fd9,0x9ff8,
	0x6e17,0x7e36,0x4e55,0x5e74,0x2e93,0x3eb2,0x0ed1,0x1ef0
}

local function crc_xmodem(bytes)
	local crc = 0
	for i=1,#bytes do
		local b = string.byte(bytes,i,i)
		crc = ((crc<<8) & 0xffff) ~ XMODEMCRC16Lookup[(((crc>>8)~b) & 0xff) + 1]
	end
    return crc
end

local temp_table = {
    { 241, 	0}, 	{ 240, 	1}, 	{ 239, 	2}, 	{ 238, 	3}, 	{ 237, 	4}, 	{ 236, 	5}, 	{ 235, 	6}, 	{ 234, 	7}, 	{ 233, 	8}, 	{ 232, 	9},
    { 231, 	10}, 	{ 230, 	11}, 	{ 229, 	12}, 	{ 228, 	13}, 	{ 227, 	14}, 	{ 226, 	15}, 	{ 224, 	16}, 	{ 223, 	17}, 	{ 222, 	18}, 	{ 220, 	19},
    { 219, 	20}, 	{ 217, 	21}, 	{ 216, 	22}, 	{ 214, 	23}, 	{ 213, 	24}, 	{ 211, 	25}, 	{ 209, 	26}, 	{ 208, 	27}, 	{ 206, 	28}, 	{ 204, 	29},
    { 202, 	30}, 	{ 201, 	31}, 	{ 199, 	32}, 	{ 197, 	33}, 	{ 195, 	34}, 	{ 193, 	35}, 	{ 191, 	36}, 	{ 189, 	37}, 	{ 187, 	38}, 	{ 185, 	39},
    { 183, 	40}, 	{ 181, 	41}, 	{ 179, 	42}, 	{ 177, 	43}, 	{ 174, 	44}, 	{ 172, 	45}, 	{ 170, 	46}, 	{ 168, 	47}, 	{ 166, 	48}, 	{ 164, 	49},
    { 161, 	50}, 	{ 159, 	51}, 	{ 157, 	52}, 	{ 154, 	53}, 	{ 152, 	54}, 	{ 150, 	55}, 	{ 148, 	56}, 	{ 146, 	57}, 	{ 143, 	58}, 	{ 141, 	59},
    { 139, 	60}, 	{ 136, 	61}, 	{ 134, 	62}, 	{ 132, 	63}, 	{ 130, 	64}, 	{ 128, 	65}, 	{ 125, 	66}, 	{ 123, 	67}, 	{ 121, 	68}, 	{ 119, 	69},
    { 117, 	70}, 	{ 115, 	71}, 	{ 113, 	72}, 	{ 111, 	73}, 	{ 109, 	74}, 	{ 106, 	75}, 	{ 105, 	76}, 	{ 103, 	77}, 	{ 101, 	78}, 	{ 99, 	79},
    { 97, 	80}, 	{ 95, 	81}, 	{ 93, 	82}, 	{ 91, 	83}, 	{ 90, 	84}, 	{ 88, 	85}, 	{ 85, 	86}, 	{ 84, 	87}, 	{ 82, 	88}, 	{ 81, 	89},
    { 79, 	90}, 	{ 77, 	91}, 	{ 76, 	92}, 	{ 74, 	93}, 	{ 73, 	94}, 	{ 72, 	95}, 	{ 69, 	96}, 	{ 68, 	97}, 	{ 66, 	98}, 	{ 65, 	99},
    { 64, 	100}, 	{ 62, 	101}, 	{ 62, 	102}, 	{ 61, 	103}, 	{ 59, 	104}, 	{ 58, 	105}, 	{ 56, 	106}, 	{ 54, 	107}, 	{ 54, 	108}, 	{ 53, 	109},
    { 51, 	110}, 	{ 51, 	111}, 	{ 50, 	112}, 	{ 48, 	113}, 	{ 48, 	114}, 	{ 46, 	115}, 	{ 46, 	116}, 	{ 44, 	117}, 	{ 43, 	118}, 	{ 43, 	119},
    { 41, 	120}, 	{ 41, 	121}, 	{ 39, 	122}, 	{ 39, 	123}, 	{ 39, 	124}, 	{ 37, 	125}, 	{ 37, 	126}, 	{ 35, 	127}, 	{ 35, 	128}, 	{ 33, 	129},
}

local function temperature_decode(temp_raw)
   if temp_raw == 0 then
      return 0
   end
   for i = 1, #temp_table do
      if temp_table[i][1] <= temp_raw then
         return temp_table[i][2]
      end
   end
   return 130
end

local function decode_current(curr)
   return curr / 64.0
end

local telem_data = ESCTelemetryData()

--[[
   check for input and parse data
--]]
local function check_input()
   local n_bytes = uart:available():toint()
   if n_bytes < 160 then
      return
   end
   --gcs:send_text(0,string.format("n_bytes=%u", n_bytes))
   if n_bytes > 160 then
      discard_pending()
      return
   end

   local s = read_bytes(n_bytes)
   local head, frame_len, ver, cmd, _ = string.unpack(">BBBBH", string.sub(s,1,6))
   if head ~= 0x9B or frame_len ~= 158 or ver ~= 1 or cmd ~= 2 then
      gcs:send_text(MAV_SEVERITY.INFO, string.format("bad frame %x %x %x %x", head, frame_len, ver, cmd))
      return
   end
   local crc1 = string.unpack("<H", string.sub(s,159,160))
   local crc2 = crc_xmodem(string.sub(s,1,158))
   if crc1 ~= crc2 then
      -- gcs:send_text(MAV_SEVERITY.INFO, string.format("bad crc %x %x", crc1, crc2))
      return
   end
   for i = 0, 7 do
      local e = string.sub(s,7+i*19,25+i*19)
      local _, pnum, in_thr, out_thr, eRPM, volt, curr, pcurr, mos_temp, cap_temp, status = string.unpack(">BHHHHHhhBBH", e)
      local RPM = math.floor(eRPM*10.0/ESC_HW_POLES:get())
      if volt > 0 or curr > 0 or RPM > 0 or pnum > 1 then
         -- we have valid ESC data
         local ofs = ESC_HW_OFS:get()
         curr = decode_current(curr)
         pcurr = decode_current(pcurr)
         volt = volt * 0.1
         in_thr = in_thr / 32768.0
         out_thr = out_thr / 32768.0
         mos_temp = temperature_decode(mos_temp)
         cap_temp = temperature_decode(cap_temp)
         telem_data:voltage(volt)
         telem_data:current(curr)
         telem_data:temperature_cdeg(math.floor(mos_temp*100))
         esc_telem:update_rpm(ofs+i, math.floor(eRPM*10.0/ESC_HW_POLES:get()), 0)
         -- 0x0D is temperature + voltage + current
         esc_telem:update_telem_data(ofs+i, telem_data, 0x0D)
         logger.write('HWES','I,PNum,RPM,Curr,Volt,InT,OutT,PCurr,MosT,CapT,Status',
                      'BHHfffffBBH', '#-qAv--AOO-', '--00000000-',
                      ofs+i, pnum, RPM, curr, volt, in_thr, out_thr, pcurr, mos_temp, cap_temp, status)
      end
   end
end

--[[
   main update function
--]]
local function update()
   check_input()
   return update, 10
end

gcs:send_text(MAV_SEVERITY.ALERT, "ESC_HW: loaded")

return update, 100
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  # HobbyWing ESC DataLink Driver

https://www.hobbywing.com/en/products?id=59

This driver implements support the HobbyWing DataLink for HobbyWing
ESCs connected via a UART to an ArduPilot serial port. It supports up
to 8 ESCs.

# Parameters

The script used the following parameters:

## ESC_HW_ENABLE

this must be set to 1 to enable the driver

## ESC_HW_POLES

this should be set to the number of motor poles for eRPM to RPM
scaling. Please confirm the correct RPM using a tachometer

## ESC_HW_OFS

this parameter sets an offset for the first ESC number. It is useful
on vehicles where the first ESC is not the first SERVOn output, for
example on quadplanes. Set to zero for no offset.

# Hardware Setup

Connect the TX1 pin on the DataLink V2 to a RX pin on an ArduPilot
serial port and the GND pin on the DataLink V2 to the GND pin on the
ArduPilot UART.

Connect your ESCs into the 8 ESC connectors marked D1 to D8.

Power the DataLink V2 with a battery as indicated in the DataLink V2 manual.

# Operation

This driver should be loaded by placing the lua script in the
APM/SCRIPTS directory on the microSD card, which can be done either
directly or via MAVFTP. The following key parameters should be set:

 - SCR_ENABLE should be set to 1
 - ESC_HW_ENABLE should be set to 1
 - SERIALn_PROTOCOL should be set to 28 for the connected serial port

then the flight controller should rebooted and parameters should be
refreshed.

Once loaded the ESC_HW_ parameters will appear and should be
configured as per the above documentation.

Note that the DataLink does not provide any data unless the motor is
running, so you cannot see any valid data at all until you arm the
motors and they start spinning.

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    