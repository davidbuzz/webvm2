{endif}
	</Configurations>
	<References>
	</References>
	<Files>
${project.display_filter()}
	</Files>
</VisualStudioProject>
'''

SOLUTION_TEMPLATE = '''Microsoft Visual Studio Solution File, Format Version ${project.numver}
# Visual Studio ${project.vsver}
${for p in project.all_projects}
Project("{${p.ptype()}}") = "${p.name}", "${p.title}", "{${p.uuid}}"
EndProject${endfor}
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		${if project.all_projects}
		${for (configuration, platform) in project.all_projects[0].ctx.project_configurations()}
		${configuration}|${platform} = ${configuration}|${platform}
		${endfor}
		${endif}
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		${for p in project.all_projects}
			${if hasattr(p, 'source')}
			${for b in p.build_properties}
		{${p.uuid}}.${b.configuration}|${b.platform}.ActiveCfg = ${b.configuration}|${b.platform}
			${if getattr(p, 'is_active', None)}
		{${p.uuid}}.${b.configuration}|${b.platform}.Build.0 = ${b.configuration}|${b.platform}
			${endif}
			${if getattr(p, 'is_deploy', None)}
		{${p.uuid}}.${b.configuration}|${b.platform}.Deploy.0 = ${b.configuration}|${b.platform}
			${endif}
			${endfor}
			${endif}
		${endfor}
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(NestedProjects) = preSolution
	${for p in project.all_projects}
		${if p.parent}
		{${p.uuid}} = {${p.parent.uuid}}
		${endif}
	${endfor}
	EndGlobalSection
EndGlobal
'''

COMPILE_TEMPLATE = '''def f(project):
	lst = []
	def xml_escape(value):
		return value.replace("&", "&amp;").replace('"', "&quot;").replace("'", "&apos;").replace("<", "&lt;").replace(">", "&gt;")

	%s

	#f = open('cmd.txt', 'w')
	#f.write(str(lst))
	#f.close()
	return ''.join(lst)
'''
reg_act = re.compile(r"(?P<backslash>\\)|(?P<dollar>\$\$)|(?P<subst>\$\{(?P<code>[^}]*?)\})", re.M)
def compile_template(line):
	"""
	Compile a template expression into a python function (like jsps, but way shorter)
	"""
	extr = []
	def repl(match):
		g = match.group
		if g('dollar'):
			return "$"
		elif g('backslash'):
			return "\\"
		elif g('subst'):
			extr.append(g('code'))
			return "<<|@|>>"
		return None

	line2 = reg_act.sub(repl, line)
	params = line2.split('<<|@|>>')
	assert(extr)


	indent = 0
	buf = []
	app = buf.append

	def app(txt):
		buf.append(indent * '\t' + txt)

	for x in range(len(extr)):
		if params[x]:
			app("lst.append(%r)" % params[x])

		f = extr[x]
		if f.startswith(('if', 'for')):
			app(f + ':')
			indent += 1
		elif f.startswith('py:'):
			app(f[3:])
		elif f.startswith(('endif', 'endfor')):
			indent -= 1
		elif f.startswith(('else', 'elif')):
			indent -= 1
			app(f + ':')
			indent += 1
		elif f.startswith('xml:'):
			app('lst.append(xml_escape(%s))' % f[4:])
		else:
			#app('lst.append((%s) or "cannot find %s")' % (f, f))
			app('lst.append(%s)' % f)

	if extr:
		if params[-1]:
			app("lst.append(%r)" % params[-1])

	fun = COMPILE_TEMPLATE % "\n\t".join(buf)
	#print(fun)
	return Task.funex(fun)


re_blank = re.compile('(\n|\r|\\s)*\n', re.M)
def rm_blank_lines(txt):
	txt = re_blank.sub('\r\n', txt)
	return txt

BOM = '\xef\xbb\xbf'
try:
	BOM = bytes(BOM, 'latin-1') # python 3
except TypeError:
	pass

def stealth_write(self, data, flags='wb'):
	try:
		unicode
	except NameError:
		data = data.encode('utf-8') # python 3
	else:
		data = data.decode(sys.getfilesystemencoding(), 'replace')
		data = data.encode('utf-8')

	if self.name.endswith(('.vcproj', '.vcxproj')):
		data = BOM + data

	try:
		txt = self.read(flags='rb')
		if txt != data:
			raise ValueError('must write')
	except (IOError, ValueError):
		self.write(data, flags=flags)
	else:
		Logs.debug('msvs: skipping %s', self.win32path())
Node.Node.stealth_write = stealth_write

re_win32 = re.compile(r'^([/\\]cygdrive)?[/\\]([a-z])([^a-z0-9_-].*)', re.I)
def win32path(self):
	p = self.abspath()
	m = re_win32.match(p)
	if m:
		return "%s:%s" % (m.group(2).upper(), m.group(3))
	return p
Node.Node.win32path = win32path

re_quote = re.compile("[^a-zA-Z0-9-]")
def quote(s):
	return re_quote.sub("_", s)

def xml_escape(value):
	return value.replace("&", "&amp;").replace('"', "&quot;").replace("'", "&apos;").replace("<", "&lt;").replace(">", "&gt;")

def make_uuid(v, prefix = None):
	"""
	simple utility function
	"""
	if isinstance(v, dict):
		keys = list(v.keys())
		keys.sort()
		tmp = str([(k, v[k]) for k in keys])
	else:
		tmp = str(v)
	d = Utils.md5(tmp.encode()).hexdigest().upper()
	if prefix:
		d = '%s%s' % (prefix, d[8:])
	gid = uuid.UUID(d, version = 4)
	return str(gid).upper()

def diff(node, fromnode):
	# difference between two nodes, but with "(..)" instead of ".."
	c1 = node
	c2 = fromnode

	c1h = c1.height()
	c2h = c2.height()

	lst = []
	up = 0

	while c1h > c2h:
		lst.append(c1.name)
		c1 = c1.parent
		c1h -= 1

	while c2h > c1h:
		up += 1
		c2 = c2.parent
		c2h -= 1

	while id(c1) != id(c2):
		lst.append(c1.name)
		up += 1

		c1 = c1.parent
		c2 = c2.parent

	for i in range(up):
		lst.append('(..)')
	lst.reverse()
	return tuple(lst)

class build_property(object):
	pass

class vsnode(object):
	"""
	Abstract class representing visual studio elements
	We assume that all visual studio nodes have a uuid and a parent
	"""
	def __init__(self, ctx):
		self.ctx = ctx # msvs context
		self.name = '' # string, mandatory
		self.vspath = '' # path in visual studio (name for dirs, absolute path for projects)
		self.uuid = '' # string, mandatory
		self.parent = None # parent node for visual studio nesting

	def get_waf(self):
		"""
		Override in subclasses...
		"""
		return 'cd /d "%s" & %s' % (self.ctx.srcnode.win32path(), getattr(self.ctx, 'waf_command', 'waf.bat'))

	def ptype(self):
		"""
		Return a special uuid for projects written in the solution file
		"""
		pass

	def write(self):
		"""
		Write the project file, by default, do nothing
		"""
		pass

	def make_uuid(self, val):
		"""
		Alias for creating uuid values easily (the templates cannot access global variables)
		"""
		return make_uuid(val)

class vsnode_vsdir(vsnode):
	"""
	Nodes representing visual studio folders (which do not match the filesystem tree!)
	"""
	VS_GUID_SOLUTIONFOLDER = "2150E333-8FDC-42A3-9474-1A3956D46DE8"
	def __init__(self, ctx, uuid, name, vspath=''):
		vsnode.__init__(self, ctx)
		self.title = self.name = name
		self.uuid = uuid
		self.vspath = vspath or name

	def ptype(self):
		return self.VS_GUID_SOLUTIONFOLDER

class vsnode_project(vsnode):
	"""
	Abstract class representing visual studio project elements
	A project is assumed to be writable, and has a node representing the file to write to
	"""
	VS_GUID_VCPROJ = "8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942"
	def ptype(self):
		return self.VS_GUID_VCPROJ

	def __init__(self, ctx, node):
		vsnode.__init__(self, ctx)
		self.path = node
		self.uuid = make_uuid(node.win32path())
		self.name = node.name
		self.platform_toolset_ver = getattr(ctx, 'platform_toolset_ver', None)
		self.title = self.path.win32path()
		self.source = [] # list of node objects
		self.build_properties = [] # list of properties (nmake commands, output dir, etc)

	def dirs(self):
		"""
		Get the list of parent folders of the source files (header files included)
		for writing the filters
		"""
		lst = []
		def add(x):
			if x.height() > self.tg.path.height() and x not in lst:
				lst.append(x)
				add(x.parent)
		for x in self.source:
			add(x.parent)
		return lst

	def write(self):
		Logs.debug('msvs: creating %r', self.path)

		# first write the project file
		template1 = compile_template(PROJECT_TEMPLATE)
		proj_str = template1(self)
		proj_str = rm_blank_lines(proj_str)
		self.path.stealth_write(proj_str)

		# then write the filter
		template2 = compile_template(FILTER_TEMPLATE)
		filter_str = template2(self)
		filter_str = rm_blank_lines(filter_str)
		tmp = self.path.parent.make_node(self.path.name + '.filters')
		tmp.stealth_write(filter_str)

	def get_key(self, node):
		"""
		required for writing the source files
		"""
		name = node.name
		if name.endswith(('.cpp', '.c')):
			return 'ClCompile'
		return 'ClInclude'

	def collect_properties(self):
		"""
		Returns a list of triplet (configuration, platform, output_directory)
		"""
		ret = []
		for c in self.ctx.configurations:
			for p in self.ctx.platforms:
				x = build_property()
				x.outdir = ''

				x.configuration = c
				x.platform = p

				x.preprocessor_definitions = ''
				x.includes_search_path = ''

				# can specify "deploy_dir" too
				ret.append(x)
		self.build_properties = ret

	def get_build_params(self, props):
		opt = '--execsolution="%s"' % self.ctx.get_solution_node().win32path()
		return (self.get_waf(), opt)

	def get_build_command(self, props):
		return "%s build %s" % self.get_build_params(props)

	def get_clean_command(self, props):
		return "%s clean %s" % self.get_build_params(props)

	def get_rebuild_command(self, props):
		return "%s clean build %s" % self.get_build_params(props)

	def get_filter_name(self, node):
		lst = diff(node, self.tg.path)
		return '\\'.join(lst) or '.'

class vsnode_alias(vsnode_project):
	def __init__(self, ctx, node, name):
		vsnode_project.__init__(self, ctx, node)
		self.name = name
		self.output_file = ''

class vsnode_build_all(vsnode_alias):
	"""
	Fake target used to emulate the behaviour of "make all" (starting one process by target is slow)
	This is the only alias enabled by default
	"""
	def __init__(self, ctx, node, name='build_all_projects'):
		vsnode_alias.__init__(self, ctx, node, name)
		self.is_active = True

class vsnode_install_all(vsnode_alias):
	"""
	Fake target used to emulate the behaviour of "make install"
	"""
	def __init__(self, ctx, node, name='install_all_projects'):
		vsnode_alias.__init__(self, ctx, node, name)

	def get_build_command(self, props):
		return "%s build install %s" % self.get_build_params(props)

	def get_clean_command(self, props):
		return "%s clean %s" % self.get_build_params(props)

	def get_rebuild_command(self, props):
		return "%s clean build install %s" % self.get_build_params(props)

class vsnode_project_view(vsnode_alias):
	"""
	Fake target used to emulate a file system view
	"""
	def __init__(self, ctx, node, name='project_view'):
		vsnode_alias.__init__(self, ctx, node, name)
		self.tg = self.ctx() # fake one, cannot remove
		self.exclude_files = Node.exclude_regs + '''
waf-2*
waf3-2*/**
.waf-2*
.waf3-2*/**
**/*.sdf
**/*.suo
**/*.ncb
**/%s
		''' % Options.lockfile

	def collect_source(self):
		# this is likely to be slow
		self.source = self.ctx.srcnode.ant_glob('**', excl=self.exclude_files)

	def get_build_command(self, props):
		params = self.get_build_params(props) + (self.ctx.cmd,)
		return "%s %s %s" % params

	def get_clean_command(self, props):
		return ""

	def get_rebuild_command(self, props):
		return self.get_build_command(props)

class vsnode_target(vsnode_project):
	"""
	Visual studio project representing a targets (programs, libraries, etc) and bound
	to a task generator
	"""
	def __init__(self, ctx, tg):
		"""
		A project is more or less equivalent to a file/folder
		"""
		base = getattr(ctx, 'projects_dir', None) or tg.path
		node = base.make_node(quote(tg.name) + ctx.project_extension) # the project file as a Node
		vsnode_project.__init__(self, ctx, node)
		self.name = quote(tg.name)
		self.tg     = tg  # task generator

	def get_build_params(self, props):
		"""
		Override the default to add the target name
		"""
		opt = '--execsolution="%s"' % self.ctx.get_solution_node().win32path()
		if getattr(self, 'tg', None):
			opt += " --targets=%s" % self.tg.name
		return (self.get_waf(), opt)

	def collect_source(self):
		tg = self.tg
		source_files = tg.to_nodes(getattr(tg, 'source', []))
		include_dirs = Utils.to_list(getattr(tg, 'msvs_includes', []))
		include_files = []
		for x in include_dirs:
			if isinstance(x, str):
				x = tg.path.find_node(x)
			if x:
				lst = [y for y in x.ant_glob(HEADERS_GLOB, flat=False)]
				include_files.extend(lst)

		# remove duplicates
		self.source.extend(list(set(source_files + include_files)))
		self.source.sort(key=lambda x: x.win32path())

	def collect_properties(self):
		"""
		Visual studio projects are associated with platforms and configurations (for building especially)
		"""
		super(vsnode_target, self).collect_properties()
		for x in self.build_properties:
			x.outdir = self.path.parent.win32path()
			x.preprocessor_definitions = ''
			x.includes_search_path = ''

			try:
				tsk = self.tg.link_task
			except AttributeError:
				pass
			else:
				x.output_file = tsk.outputs[0].win32path()
				x.preprocessor_definitions = ';'.join(tsk.env.DEFINES)
				x.includes_search_path = ';'.join(self.tg.env.INCPATHS)

class msvs_generator(BuildContext):
	'''generates a visual studio 2010 solution'''
	cmd = 'msvs'
	fun = 'build'
	numver = '11.00' # Visual Studio Version Number
	vsver  = '2010'  # Visual Studio Version Year
	platform_toolset_ver = 'v110' # Platform Toolset Version Number

	def init(self):
		"""
		Some data that needs to be present
		"""
		if not getattr(self, 'configurations', None):
			self.configurations = ['Release'] # LocalRelease, RemoteDebug, etc
		if not getattr(self, 'platforms', None):
			self.platforms = ['Win32']
		if not getattr(self, 'all_projects', None):
			self.all_projects = []
		if not getattr(self, 'project_extension', None):
			self.project_extension = '.vcxproj'
		if not getattr(self, 'projects_dir', None):
			self.projects_dir = self.srcnode.make_node('.depproj')
			self.projects_dir.mkdir()

		# bind the classes to the object, so that subclass can provide custom generators
		if not getattr(self, 'vsnode_vsdir', None):
			self.vsnode_vsdir = vsnode_vsdir
		if not getattr(self, 'vsnode_target', None):
			self.vsnode_target = vsnode_target
		if not getattr(self, 'vsnode_build_all', None):
			self.vsnode_build_all = vsnode_build_all
		if not getattr(self, 'vsnode_install_all', None):
			self.vsnode_install_all = vsnode_install_all
		if not getattr(self, 'vsnode_project_view', None):
			self.vsnode_project_view = vsnode_project_view

		self.numver = self.__class__.numver
		self.vsver  = self.__class__.vsver
		self.platform_toolset_ver = self.__class__.platform_toolset_ver

	def execute(self):
		"""
		Entry point
		"""
		self.restore()
		if not self.all_envs:
			self.load_envs()
		self.recurse([self.run_dir])

		# user initialization
		self.init()

		# two phases for creating the solution
		self.collect_projects() # add project objects into "self.all_projects"
		self.write_files() # write the corresponding project and solution files

	def collect_projects(self):
		"""
		Fill the list self.all_projects with project objects
		Fill the list of build targets
		"""
		self.collect_targets()
		self.add_aliases()
		self.collect_dirs()
		default_project = getattr(self, 'default_project', None)
		def sortfun(x):
			# folders should sort to the top
			if getattr(x, 'VS_GUID_SOLUTIONFOLDER', None):
				return ''
			# followed by the default project
			elif x.name == default_project:
				return ' '
			return getattr(x, 'path', None) and x.path.win32path() or x.name
		self.all_projects.sort(key=sortfun)

	def write_files(self):
		"""
		Write the project and solution files from the data collected
		so far. It is unlikely that you will want to change this
		"""
		for p in self.all_projects:
			p.write()

		# and finally write the solution file
		node = self.get_solution_node()
		node.parent.mkdir()
		Logs.warn('Creating %r', node)
		template1 = compile_template(SOLUTION_TEMPLATE)
		sln_str = template1(self)
		sln_str = rm_blank_lines(sln_str)
		node.stealth_write(sln_str)

	def get_solution_node(self):
		"""
		The solution filename is required when writing the .vcproj files
		return self.solution_node and if it does not exist, make one
		"""
		try:
			return self.solution_node
		except AttributeError:
			pass

		solution_name = getattr(self, 'solution_name', None)
		if not solution_name:
			solution_name = getattr(Context.g_module, Context.APPNAME, 'project') + '.sln'
		if os.path.isabs(solution_name):
			self.solution_node = self.root.make_node(solution_name)
		else:
			self.solution_node = self.srcnode.make_node(solution_name)
		return self.solution_node

	def project_configurations(self):
		"""
		Helper that returns all the pairs (config,platform)
		"""
		ret = []
		for c in self.configurations:
			for p in self.platforms:
				ret.append((c, p))
		return ret

	def collect_targets(self):
		"""
		Process the list of task generators
		"""
		for g in self.groups:
			for tg in g:
				if not isinstance(tg, TaskGen.task_gen):
					continue

				if not hasattr(tg, 'msvs_includes'):
					tg.msvs_includes = tg.to_list(getattr(tg, 'includes', [])) + tg.to_list(getattr(tg, 'export_includes', []))
				tg.post()
				if not getattr(tg, 'link_task', None):
					continue

				p = self.vsnode_target(self, tg)
				p.collect_source() # delegate this processing
				p.collect_properties()
				self.all_projects.append(p)

	def add_aliases(self):
		"""
		Add a specific target that emulates the "make all" necessary for Visual studio when pressing F7
		We also add an alias for "make install" (disabled by default)
		"""
		base = getattr(self, 'projects_dir', None) or self.tg.path

		node_project = base.make_node('build_all_projects' + self.project_extension) # Node
		p_build = self.vsnode_build_all(self, node_project)
		p_build.collect_properties()
		self.all_projects.append(p_build)

		node_project = base.make_node('install_all_projects' + self.project_extension) # Node
		p_install = self.vsnode_install_all(self, node_project)
		p_install.collect_properties()
		self.all_projects.append(p_install)

		node_project = base.make_node('project_view' + self.project_extension) # Node
		p_view = self.vsnode_project_view(self, node_project)
		p_view.collect_source()
		p_view.collect_properties()
		self.all_projects.append(p_view)

		n = self.vsnode_vsdir(self, make_uuid(self.srcnode.win32path() + 'build_aliases'), "build_aliases")
		p_build.parent = p_install.parent = p_view.parent = n
		self.all_projects.append(n)

	def collect_dirs(self):
		"""
		Create the folder structure in the Visual studio project view
		"""
		seen = {}
		def make_parents(proj):
			# look at a project, try to make a parent
			if getattr(proj, 'parent', None):
				# aliases already have parents
				return
			x = proj.iter_path
			if x in seen:
				proj.parent = seen[x]
				return

			# There is not vsnode_vsdir for x.
			# So create a project representing the folder "x"
			n = proj.parent = seen[x] = self.vsnode_vsdir(self, make_uuid(x.win32path()), x.name)
			n.iter_path = x.parent
			self.all_projects.append(n)

			# recurse up to the project directory
			if x.height() > self.srcnode.height() + 1:
				make_parents(n)

		for p in self.all_projects[:]: # iterate over a copy of all projects
			if not getattr(p, 'tg', None):
				# but only projects that have a task generator
				continue

			# make a folder for each task generator
			p.iter_path = p.tg.path
			make_parents(p)

def wrap_2008(cls):
	class dec(cls):
		def __init__(self, *k, **kw):
			cls.__init__(self, *k, **kw)
			self.project_template = PROJECT_2008_TEMPLATE

		def display_filter(self):

			root = build_property()
			root.subfilters = []
			root.sourcefiles = []
			root.source = []
			root.name = ''

			@Utils.run_once
			def add_path(lst):
				if not lst:
					return root
				child = build_property()
				child.subfilters = []
				child.sourcefiles = []
				child.source = []
				child.name = lst[-1]

				par = add_path(lst[:-1])
				par.subfilters.append(child)
				return child

			for x in self.source:
				# this crap is for enabling subclasses to override get_filter_name
				tmp = self.get_filter_name(x.parent)
				tmp = tmp != '.' and tuple(tmp.split('\\')) or ()
				par = add_path(tmp)
				par.source.append(x)

			def display(n):
				buf = []
				for x in n.source:
					buf.append('<File RelativePath="%s" FileType="%s"/>\n' % (xml_escape(x.win32path()), self.get_key(x)))
				for x in n.subfilters:
					buf.append('<Filter Name="%s">' % xml_escape(x.name))
					buf.append(display(x))
					buf.append('</Filter>')
				return '\n'.join(buf)

			return display(root)

		def get_key(self, node):
			"""
			If you do not want to let visual studio use the default file extensions,
			override this method to return a value:
				0: C/C++ Code, 1: C++ Class, 2: C++ Header File, 3: C++ Form,
				4: C++ Control, 5: Text File, 6: DEF File, 7: IDL File,
				8: Makefile, 9: RGS File, 10: RC File, 11: RES File, 12: XSD File,
				13: XML File, 14: HTML File, 15: CSS File, 16: Bitmap, 17: Icon,
				18: Resx File, 19: BSC File, 20: XSX File, 21: C++ Web Service,
				22: ASAX File, 23: Asp Page, 24: Document, 25: Discovery File,
				26: C# File, 27: eFileTypeClassDiagram, 28: MHTML Document,
				29: Property Sheet, 30: Cursor, 31: Manifest, 32: eFileTypeRDLC
			"""
			return ''

		def write(self):
			Logs.debug('msvs: creating %r', self.path)
			template1 = compile_template(self.project_template)
			proj_str = template1(self)
			proj_str = rm_blank_lines(proj_str)
			self.path.stealth_write(proj_str)

	return dec

class msvs_2008_generator(msvs_generator):
	'''generates a visual studio 2008 solution'''
	cmd = 'msvs2008'
	fun = msvs_generator.fun
	numver = '10.00'
	vsver = '2008'

	def init(self):
		if not getattr(self, 'project_extension', None):
			self.project_extension = '_2008.vcproj'
		if not getattr(self, 'solution_name', None):
			self.solution_name = getattr(Context.g_module, Context.APPNAME, 'project') + '_2008.sln'

		if not getattr(self, 'vsnode_target', None):
			self.vsnode_target = wrap_2008(vsnode_target)
		if not getattr(self, 'vsnode_build_all', None):
			self.vsnode_build_all = wrap_2008(vsnode_build_all)
		if not getattr(self, 'vsnode_install_all', None):
			self.vsnode_install_all = wrap_2008(vsnode_install_all)
		if not getattr(self, 'vsnode_project_view', None):
			self.vsnode_project_view = wrap_2008(vsnode_project_view)

		msvs_generator.init(self)

def options(ctx):
	"""
	If the msvs option is used, try to detect if the build is made from visual studio
	"""
	ctx.add_option('--execsolution', action='store', help='when building with visual studio, use a build state file')

	old = BuildContext.execute
	def override_build_state(ctx):
		def lock(rm, add):
			uns = ctx.options.execsolution.replace('.sln', rm)
			uns = ctx.root.make_node(uns)
			try:
				uns.delete()
			except OSError:
				pass

			uns = ctx.options.execsolution.replace('.sln', add)
			uns = ctx.root.make_node(uns)
			try:
				uns.write('')
			except EnvironmentError:
				pass

		if ctx.options.execsolution:
			ctx.launch_dir = Context.top_dir # force a build for the whole project (invalid cwd when called by visual studio)
			lock('.lastbuildstate', '.unsuccessfulbuild')
			old(ctx)
			lock('.unsuccessfulbuild', '.lastbuildstate')
		else:
			old(ctx)
	BuildContext.execute = override_build_state

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              #! /usr/bin/env python
# encoding: utf-8
# Thomas Nagy, 2011-2015 (ita)

"""
A client for the network cache (playground/netcache/). Launch the server with:
./netcache_server, then use it for the builds by adding the following:

	def build(bld):
		bld.load('netcache_client')

The parameters should be present in the environment in the form:
	NETCACHE=host:port waf configure build

Or in a more detailed way:
	NETCACHE_PUSH=host:port NETCACHE_PULL=host:port waf configure build

where:
	host: host where the server resides, by default localhost
	port: by default push on 11001 and pull on 12001

Use the server provided in playground/netcache/Netcache.java
"""

import os, socket, time, atexit, sys
from waflib import Task, Logs, Utils, Build, Runner
from waflib.Configure import conf

BUF = 8192 * 16
HEADER_SIZE = 128
MODES = ['PUSH', 'PULL', 'PUSH_PULL']
STALE_TIME = 30 # seconds

GET = 'GET'
PUT = 'PUT'
LST = 'LST'
BYE = 'BYE'

all_sigs_in_cache = (0.0, [])

def put_data(conn, data):
	if sys.hexversion > 0x3000000:
		data = data.encode('latin-1')
	cnt = 0
	while cnt < len(data):
		sent = conn.send(data[cnt:])
		if sent == 0:
			raise RuntimeError('connection ended')
		cnt += sent

push_connections = Runner.Queue(0)
pull_connections = Runner.Queue(0)
def get_connection(push=False):
	# return a new connection... do not forget to release it!
	try:
		if push:
			ret = push_connections.get(block=False)
		else:
			ret = pull_connections.get(block=False)
	except Exception:
		ret = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
		if push:
			ret.connect(Task.push_addr)
		else:
			ret.connect(Task.pull_addr)
	return ret

def release_connection(conn, msg='', push=False):
	if conn:
		if push:
			push_connections.put(conn)
		else:
			pull_connections.put(conn)

def close_connection(conn, msg=''):
	if conn:
		data = '%s,%s' % (BYE, msg)
		try:
			put_data(conn, data.ljust(HEADER_SIZE))
		except:
			pass
		try:
			conn.close()
		except:
			pass

def close_all():
	for q in (push_connections, pull_connections):
		while q.qsize():
			conn = q.get()
			try:
				close_connection(conn)
			except:
				# ignore errors when cleaning up
				pass
atexit.register(close_all)

def read_header(conn):
	cnt = 0
	buf = []
	while cnt < HEADER_SIZE:
		data = conn.recv(HEADER_SIZE - cnt)
		if not data:
			#import traceback
			#traceback.print_stack()
			raise ValueError('connection ended when reading a header %r' % buf)
		buf.append(data)
		cnt += len(data)
	if sys.hexversion > 0x3000000:
		ret = ''.encode('latin-1').join(buf)
		ret = ret.decode('latin-1')
	else:
		ret = ''.join(buf)
	return ret

def check_cache(conn, ssig):
	"""
	List the files on the server, this is an optimization because it assumes that
	concurrent builds are rare
	"""
	global all_sigs_in_cache
	if not STALE_TIME:
		return
	if time.time() - all_sigs_in_cache[0] > STALE_TIME:

		params = (LST,'')
		put_data(conn, ','.join(params).ljust(HEADER_SIZE))

		# read what is coming back
		ret = read_header(conn)
		size = int(ret.split(',')[0])

		buf = []
		cnt = 0
		while cnt < size:
			data = conn.recv(min(BUF, size-cnt))
			if not data:
				raise ValueError('connection ended %r %r' % (cnt, size))
			buf.append(data)
			cnt += len(data)

		if sys.hexversion > 0x3000000:
			ret = ''.encode('latin-1').join(buf)
			ret = ret.decode('latin-1')
		else:
			ret = ''.join(buf)

		all_sigs_in_cache = (time.time(), ret.splitlines())
		Logs.debug('netcache: server cache has %r entries', len(all_sigs_in_cache[1]))

	if not ssig in all_sigs_in_cache[1]:
		raise ValueError('no file %s in cache' % ssig)

class MissingFile(Exception):
	pass

def recv_file(conn, ssig, count, p):
	check_cache(conn, ssig)

	params = (GET, ssig, str(count))
	put_data(conn, ','.join(params).ljust(HEADER_SIZE))
	data = read_header(conn)

	size = int(data.split(',')[0])

	if size == -1:
		raise MissingFile('no file %s - %s in cache' % (ssig, count))

	# get the file, writing immediately
	# TODO a tmp file would be better
	f = open(p, 'wb')
	cnt = 0
	while cnt < size:
		data = conn.recv(min(BUF, size-cnt))
		if not data:
			raise ValueError('connection ended %r %r' % (cnt, size))
		f.write(data)
		cnt += len(data)
	f.close()

def sock_send(conn, ssig, cnt, p):
	#print "pushing %r %r %r" % (ssig, cnt, p)
	size = os.stat(p).st_size
	params = (PUT, ssig, str(cnt), str(size))
	put_data(conn, ','.join(params).ljust(HEADER_SIZE))
	f = open(p, 'rb')
	cnt = 0
	while cnt < size:
		r = f.read(min(BUF, size-cnt))
		while r:
			k = conn.send(r)
			if not k:
				raise ValueError('connection ended')
			cnt += k
			r = r[k:]

def can_retrieve_cache(self):
	if not Task.pull_addr:
		return False
	if not self.outputs:
		return False
	self.cached = False

	cnt = 0
	sig = self.signature()
	ssig = Utils.to_hex(self.uid() + sig)

	conn = None
	err = False
	try:
		try:
			conn = get_connection()
			for node in self.outputs:
				p = node.abspath()
				recv_file(conn, ssig, cnt, p)
				cnt += 1
		except MissingFile as e:
			Logs.debug('netcache: file is not in the cache %r', e)
			err = True
		except Exception as e:
			Logs.debug('netcache: could not get the files %r', self.outputs)
			if Logs.verbose > 1:
				Logs.debug('netcache: exception %r', e)
			err = True

			# broken connection? remove this one
			close_connection(conn)
			conn = None
		else:
			Logs.debug('netcache: obtained %r from cache', self.outputs)

	finally:
		release_connection(conn)
	if err:
		return False

	self.cached = True
	return True

@Utils.run_once
def put_files_cache(self):
	if not Task.push_addr:
		return
	if not self.outputs:
		return
	if getattr(self, 'cached', None):
		return

	#print "called put_files_cache", id(self)
	bld = self.generator.bld
	sig = self.signature()
	ssig = Utils.to_hex(self.uid() + sig)

	conn = None
	cnt = 0
	try:
		for node in self.outputs:
			# We could re-create the signature of the task with the signature of the outputs
			# in practice, this means hashing the output files
			# this is unnecessary
			try:
				if not conn:
					conn = get_connection(push=True)
				sock_send(conn, ssig, cnt, node.abspath())
				Logs.debug('netcache: sent %r', node)
			except Exception as e:
				Logs.debug('netcache: could not push the files %r', e)

				# broken connection? remove this one
				close_connection(conn)
				conn = None
			cnt += 1
	finally:
		release_connection(conn, push=True)

	bld.task_sigs[self.uid()] = self.cache_sig

def hash_env_vars(self, env, vars_lst):
	# reimplement so that the resulting hash does not depend on local paths
	if not env.table:
		env = env.parent
		if not env:
			return Utils.SIG_NIL

	idx = str(id(env)) + str(vars_lst)
	try:
		cache = self.cache_env
	except AttributeError:
		cache = self.cache_env = {}
	else:
		try:
			return self.cache_env[idx]
		except KeyError:
			pass

	v = str([env[a] for a in vars_lst])
	v = v.replace(self.srcnode.abspath().__repr__()[:-1], '')
	m = Utils.md5()
	m.update(v.encode())
	ret = m.digest()

	Logs.debug('envhash: %r %r', ret, v)

	cache[idx] = ret

	return ret

def uid(self):
	# reimplement so that the signature does not depend on local paths
	try:
		return self.uid_
	except AttributeError:
		m = Utils.md5()
		src = self.generator.bld.srcnode
		up = m.update
		up(self.__class__.__name__.encode())
		for x in self.inputs + self.outputs:
			up(x.path_from(src).encode())
		self.uid_ = m.digest()
		return self.uid_


def make_cached(cls):
	if getattr(cls, 'nocache', None):
		return

	m1 = cls.run
	def run(self):
		if getattr(self, 'nocache', False):
			return m1(self)
		if self.can_retrieve_cache():
			return 0
		return m1(self)
	cls.run = run

	m2 = cls.post_run
	def post_run(self):
		if getattr(self, 'nocache', False):
			return m2(self)
		bld = self.generator.bld
		ret = m2(self)
		if bld.cache_global:
			self.put_files_cache()
		if hasattr(self, 'chmod'):
			for node in self.outputs:
				os.chmod(node.abspath(), self.chmod)
		return ret
	cls.post_run = post_run

@conf
def setup_netcache(ctx, push_addr, pull_addr):
	Task.Task.can_retrieve_cache = can_retrieve_cache
	Task.Task.put_files_cache = put_files_cache
	Task.Task.uid = uid
	Task.push_addr = push_addr
	Task.pull_addr = pull_addr
	Build.BuildContext.hash_env_vars = hash_env_vars
	ctx.cache_global = True

	for x in Task.classes.values():
		make_cached(x)

def build(bld):
	if not 'NETCACHE' in os.environ and not 'NETCACHE_PULL' in os.environ and not 'NETCACHE_PUSH' in os.environ:
		Logs.warn('Setting  NETCACHE_PULL=127.0.0.1:11001 and NETCACHE_PUSH=127.0.0.1:12001')
		os.environ['NETCACHE_PULL'] = '127.0.0.1:12001'
		os.environ['NETCACHE_PUSH'] = '127.0.0.1:11001'

	if 'NETCACHE' in os.environ:
		if not 'NETCACHE_PUSH' in os.environ:
			os.environ['NETCACHE_PUSH'] = os.environ['NETCACHE']
		if not 'NETCACHE_PULL' in os.environ:
			os.environ['NETCACHE_PULL'] = os.environ['NETCACHE']

	v = os.environ['NETCACHE_PULL']
	if v:
		h, p = v.split(':')
		pull_addr = (h, int(p))
	else:
		pull_addr = None

	v = os.environ['NETCACHE_PUSH']
	if v:
		h, p = v.split(':')
		push_addr = (h, int(p))
	else:
		push_addr = None

	setup_netcache(bld, push_addr, pull_addr)

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         #!/usr/bin/python
# Grygoriy Fuchedzhy 2010

"""
Support for converting linked targets to ihex, srec or binary files using
objcopy. Use the 'objcopy' feature in conjunction with the 'cc' or 'cxx'
feature. The 'objcopy' feature uses the following attributes:

objcopy_bfdname		Target object format name (eg. ihex, srec, binary).
					   Defaults to ihex.
objcopy_target		 File name used for objcopy output. This defaults to the
					   target name with objcopy_bfdname as extension.
objcopy_install_path   Install path for objcopy_target file. Defaults to ${PREFIX}/fw.
objcopy_flags		  Additional flags passed to objcopy.
"""

from waflib.Utils import def_attrs
from waflib import Task, Options
from waflib.TaskGen import feature, after_method

class objcopy(Task.Task):
	run_str = '${OBJCOPY} -O ${TARGET_BFDNAME} ${OBJCOPYFLAGS} ${SRC} ${TGT}'
	color   = 'CYAN'

@feature('objcopy')
@after_method('apply_link')
def map_objcopy(self):
	def_attrs(self,
	   objcopy_bfdname = 'ihex',
	   objcopy_target = None,
	   objcopy_install_path = "${PREFIX}/firmware",
	   objcopy_flags = '')

	link_output = self.link_task.outputs[0]
	if not self.objcopy_target:
		self.objcopy_target = link_output.change_ext('.' + self.objcopy_bfdname).name
	task = self.create_task('objcopy', src=link_output, tgt=self.path.find_or_declare(self.objcopy_target))

	task.env.append_unique('TARGET_BFDNAME', self.objcopy_bfdname)
	try:
		task.env.append_unique('OBJCOPYFLAGS', getattr(self, 'objcopy_flags'))
	except AttributeError:
		pass

	if self.objcopy_install_path:
		self.add_install_files(install_to=self.objcopy_install_path, install_from=task.outputs[0])

def configure(ctx):
	program_name = 'objcopy'
	prefix = getattr(Options.options, 'cross_prefix', None)
	if prefix:
		program_name = '{}-{}'.format(prefix, program_name)
	ctx.find_program(program_name, var='OBJCOPY', mandatory=True)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                #!/usr/bin/env python
# encoding: utf-8
# Thomas Nagy, 2006-2010 (ita)

"ocaml support"

import os, re
from waflib import Utils, Task
from waflib.Logs import error
from waflib.TaskGen import feature, before_method, after_method, extension

EXT_MLL = ['.mll']
EXT_MLY = ['.mly']
EXT_MLI = ['.mli']
EXT_MLC = ['.c']
EXT_ML  = ['.ml']

open_re = re.compile(r'^\s*open\s+([a-zA-Z]+)(;;){0,1}$', re.M)
foo = re.compile(r"""(\(\*)|(\*\))|("(\\.|[^"\\])*"|'(\\.|[^'\\])*'|.[^()*"'\\]*)""", re.M)
def filter_comments(txt):
	meh = [0]
	def repl(m):
		if m.group(1):
			meh[0] += 1
		elif m.group(2):
			meh[0] -= 1
		elif not meh[0]:
			return m.group()
		return ''
	return foo.sub(repl, txt)

def scan(self):
	node = self.inputs[0]
	code = filter_comments(node.read())

	global open_re
	names = []
	import_iterator = open_re.finditer(code)
	if import_iterator:
		for import_match in import_iterator:
			names.append(import_match.group(1))
	found_lst = []
	raw_lst = []
	for name in names:
		nd = None
		for x in self.incpaths:
			nd = x.find_resource(name.lower()+'.ml')
			if not nd:
				nd = x.find_resource(name+'.ml')
			if nd:
				found_lst.append(nd)
				break
		else:
			raw_lst.append(name)

	return (found_lst, raw_lst)

native_lst=['native', 'all', 'c_object']
bytecode_lst=['bytecode', 'all']

@feature('ocaml')
def init_ml(self):
	Utils.def_attrs(self,
		type = 'all',
		incpaths_lst = [],
		bld_incpaths_lst = [],
		mlltasks = [],
		mlytasks = [],
		mlitasks = [],
		native_tasks = [],
		bytecode_tasks = [],
		linktasks = [],
		bytecode_env = None,
		native_env = None,
		compiled_tasks = [],
		includes = '',
		uselib = '',
		are_deps_set = 0)

@feature('ocaml')
@after_method('init_ml')
def init_envs_ml(self):

	self.islibrary = getattr(self, 'islibrary', False)

	global native_lst, bytecode_lst
	self.native_env = None
	if self.type in native_lst:
		self.native_env = self.env.derive()
		if self.islibrary:
			self.native_env['OCALINKFLAGS']   = '-a'

	self.bytecode_env = None
	if self.type in bytecode_lst:
		self.bytecode_env = self.env.derive()
		if self.islibrary:
			self.bytecode_env['OCALINKFLAGS'] = '-a'

	if self.type == 'c_object':
		self.native_env.append_unique('OCALINKFLAGS_OPT', '-output-obj')

@feature('ocaml')
@before_method('apply_vars_ml')
@after_method('init_envs_ml')
def apply_incpaths_ml(self):
	inc_lst = self.includes.split()
	lst = self.incpaths_lst
	for dir in inc_lst:
		node = self.path.find_dir(dir)
		if not node:
			error("node not found: " + str(dir))
			continue
		if not node in lst:
			lst.append(node)
		self.bld_incpaths_lst.append(node)
	# now the nodes are added to self.incpaths_lst

@feature('ocaml')
@before_method('process_source')
def apply_vars_ml(self):
	for i in self.incpaths_lst:
		if self.bytecode_env:
			app = self.bytecode_env.append_value
			app('OCAMLPATH', ['-I', i.bldpath(), '-I', i.srcpath()])

		if self.native_env:
			app = self.native_env.append_value
			app('OCAMLPATH', ['-I', i.bldpath(), '-I', i.srcpath()])

	varnames = ['INCLUDES', 'OCAMLFLAGS', 'OCALINKFLAGS', 'OCALINKFLAGS_OPT']
	for name in self.uselib.split():
		for vname in varnames:
			cnt = self.env[vname+'_'+name]
			if cnt:
				if self.bytecode_env:
					self.bytecode_env.append_value(vname, cnt)
				if self.native_env:
					self.native_env.append_value(vname, cnt)

@feature('ocaml')
@after_method('process_source')
def apply_link_ml(self):

	if self.bytecode_env:
		ext = self.islibrary and '.cma' or '.run'

		linktask = self.create_task('ocalink')
		linktask.bytecode = 1
		linktask.set_outputs(self.path.find_or_declare(self.target + ext))
		linktask.env = self.bytecode_env
		self.linktasks.append(linktask)

	if self.native_env:
		if self.type == 'c_object':
			ext = '.o'
		elif self.islibrary:
			ext = '.cmxa'
		else:
			ext = ''

		linktask = self.create_task('ocalinkx')
		linktask.set_outputs(self.path.find_or_declare(self.target + ext))
		linktask.env = self.native_env
		self.linktasks.append(linktask)

		# we produce a .o file to be used by gcc
		self.compiled_tasks.append(linktask)

@extension(*EXT_MLL)
def mll_hook(self, node):
	mll_task = self.create_task('ocamllex', node, node.change_ext('.ml'))
	mll_task.env = self.native_env.derive()
	self.mlltasks.append(mll_task)

	self.source.append(mll_task.outputs[0])

@extension(*EXT_MLY)
def mly_hook(self, node):
	mly_task = self.create_task('ocamlyacc', node, [node.change_ext('.ml'), node.change_ext('.mli')])
	mly_task.env = self.native_env.derive()
	self.mlytasks.append(mly_task)
	self.source.append(mly_task.outputs[0])

	task = self.create_task('ocamlcmi', mly_task.outputs[1], mly_task.outputs[1].change_ext('.cmi'))
	task.env = self.native_env.derive()

@extension(*EXT_MLI)
def mli_hook(self, node):
	task = self.create_task('ocamlcmi', node, node.change_ext('.cmi'))
	task.env = self.native_env.derive()
	self.mlitasks.append(task)

@extension(*EXT_MLC)
def mlc_hook(self, node):
	task = self.create_task('ocamlcc', node, node.change_ext('.o'))
	task.env = self.native_env.derive()
	self.compiled_tasks.append(task)

@extension(*EXT_ML)
def ml_hook(self, node):
	if self.native_env:
		task = self.create_task('ocamlx', node, node.change_ext('.cmx'))
		task.env = self.native_env.derive()
		task.incpaths = self.bld_incpaths_lst
		self.native_tasks.append(task)

	if self.bytecode_env:
		task = self.create_task('ocaml', node, node.change_ext('.cmo'))
		task.env = self.bytecode_env.derive()
		task.bytecode = 1
		task.incpaths = self.bld_incpaths_lst
		self.bytecode_tasks.append(task)

def compile_may_start(self):

	if not getattr(self, 'flag_deps', ''):
		self.flag_deps = 1

		# the evil part is that we can only compute the dependencies after the
		# source files can be read (this means actually producing the source files)
		if getattr(self, 'bytecode', ''):
			alltasks = self.generator.bytecode_tasks
		else:
			alltasks = self.generator.native_tasks

		self.signature() # ensure that files are scanned - unfortunately
		tree = self.generator.bld
		for node in self.inputs:
			lst = tree.node_deps[self.uid()]
			for depnode in lst:
				for t in alltasks:
					if t == self:
						continue
					if depnode in t.inputs:
						self.set_run_after(t)

		# TODO necessary to get the signature right - for now
		delattr(self, 'cache_sig')
		self.signature()

	return Task.Task.runnable_status(self)

class ocamlx(Task.Task):
	"""native caml compilation"""
	color   = 'GREEN'
	run_str = '${OCAMLOPT} ${OCAMLPATH} ${OCAMLFLAGS} ${OCAMLINCLUDES} -c -o ${TGT} ${SRC}'
	scan    = scan
	runnable_status = compile_may_start

class ocaml(Task.Task):
	"""bytecode caml compilation"""
	color   = 'GREEN'
	run_str = '${OCAMLC} ${OCAMLPATH} ${OCAMLFLAGS} ${OCAMLINCLUDES} -c -o ${TGT} ${SRC}'
	scan    = scan
	runnable_status = compile_may_start

class ocamlcmi(Task.Task):
	"""interface generator (the .i files?)"""
	color   = 'BLUE'
	run_str = '${OCAMLC} ${OCAMLPATH} ${OCAMLINCLUDES} -o ${TGT} -c ${SRC}'
	before  = ['ocamlcc', 'ocaml', 'ocamlcc']

class ocamlcc(Task.Task):
	"""ocaml to c interfaces"""
	color   = 'GREEN'
	run_str = 'cd ${TGT[0].bld_dir()} && ${OCAMLOPT} ${OCAMLFLAGS} ${OCAMLPATH} ${OCAMLINCLUDES} -c ${SRC[0].abspath()}'

class ocamllex(Task.Task):
	"""lexical generator"""
	color   = 'BLUE'
	run_str = '${OCAMLLEX} ${SRC} -o ${TGT}'
	before  = ['ocamlcmi', 'ocaml', 'ocamlcc']

class ocamlyacc(Task.Task):
	"""parser generator"""
	color   = 'BLUE'
	run_str = '${OCAMLYACC} -b ${tsk.base()} ${SRC}'
	before  = ['ocamlcmi', 'ocaml', 'ocamlcc']

	def base(self):
		node = self.outputs[0]
		s = os.path.splitext(node.name)[0]
		return node.bld_dir() + os.sep + s

def link_may_start(self):

	if getattr(self, 'bytecode', 0):
		alltasks = self.generator.bytecode_tasks
	else:
		alltasks = self.generator.native_tasks

	for x in alltasks:
		if not x.hasrun:
			return Task.ASK_LATER

	if not getattr(self, 'order', ''):

		# now reorder the inputs given the task dependencies
		# this part is difficult, we do not have a total order on the tasks
		# if the dependencies are wrong, this may not stop
		seen = []
		pendant = []+alltasks
		while pendant:
			task = pendant.pop(0)
			if task in seen:
				continue
			for x in task.run_after:
				if not x in seen:
					pendant.append(task)
					break
			else:
				seen.append(task)
		self.inputs = [x.outputs[0] for x in seen]
		self.order = 1
	return Task.Task.runnable_status(self)

class ocalink(Task.Task):
	"""bytecode caml link"""
	color   = 'YELLOW'
	run_str = '${OCAMLC} -o ${TGT} ${OCAMLINCLUDES} ${OCALINKFLAGS} ${SRC}'
	runnable_status = link_may_start
	after = ['ocaml', 'ocamlcc']

class ocalinkx(Task.Task):
	"""native caml link"""
	color   = 'YELLOW'
	run_str = '${OCAMLOPT} -o ${TGT} ${OCAMLINCLUDES} ${OCALINKFLAGS_OPT} ${SRC}'
	runnable_status = link_may_start
	after = ['ocamlx', 'ocamlcc']

def configure(conf):
	opt = conf.find_program('ocamlopt', var='OCAMLOPT', mandatory=False)
	occ = conf.find_program('ocamlc', var='OCAMLC', mandatory=False)
	if (not opt) or (not occ):
		conf.fatal('The objective caml compiler was not found:\ninstall it or make it available in your PATH')

	v = conf.env
	v['OCAMLC']       = occ
	v['OCAMLOPT']     = opt
	v['OCAMLLEX']     = conf.find_program('ocamllex', var='OCAMLLEX', mandatory=False)
	v['OCAMLYACC']    = conf.find_program('ocamlyacc', var='OCAMLYACC', mandatory=False)
	v['OCAMLFLAGS']   = ''
	where = conf.cmd_and_log(conf.env.OCAMLC + ['-where']).strip()+os.sep
	v['OCAMLLIB']     = where
	v['LIBPATH_OCAML'] = where
	v['INCLUDES_OCAML'] = where
	v['LIB_OCAML'] = 'camlrun'

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        #! /usr/bin/env python
# encoding: utf-8
# Thomas Nagy, 2011

"""
Obtain packages, unpack them in a location, and add associated uselib variables
(CFLAGS_pkgname, LIBPATH_pkgname, etc).

The default is use a Dependencies.txt file in the source directory.

This is a work in progress.

Usage:

def options(opt):
	opt.load('package')

def configure(conf):
	conf.load_packages()
"""

from waflib import Logs
from waflib.Configure import conf

try:
	from urllib import request
except ImportError:
	from urllib import urlopen
else:
	urlopen = request.urlopen


CACHEVAR = 'WAFCACHE_PACKAGE'

@conf
def get_package_cache_dir(self):
	cache = None
	if CACHEVAR in conf.environ:
		cache = conf.environ[CACHEVAR]
		cache = self.root.make_node(cache)
	elif self.env[CACHEVAR]:
		cache = self.env[CACHEVAR]
		cache = self.root.make_node(cache)
	else:
		cache = self.srcnode.make_node('.wafcache_package')
	cache.mkdir()
	return cache

@conf
def download_archive(self, src, dst):
	for x in self.env.PACKAGE_REPO:
		url = '/'.join((x, src))
		try:
			web = urlopen(url)
			try:
				if web.getcode() != 200:
					continue
			except AttributeError:
				pass
		except Exception:
			# on python3 urlopen throws an exception
			# python 2.3 does not have getcode and throws an exception to fail
			continue
		else:
			tmp = self.root.make_node(dst)
			tmp.write(web.read())
			Logs.warn('Downloaded %s from %s', tmp.abspath(), url)
			break
	else:
		self.fatal('Could not get the package %s' % src)

@conf
def load_packages(self):
	self.get_package_cache_dir()
	# read the dependencies, get the archives, ..

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          #! /usr/bin/env python
# encoding: utf-8
# Thomas Nagy, 2007-2010 (ita)

"""
Debugging helper for parallel compilation.

Copy it to your project and load it with::

	def options(opt):
		opt.load('parallel_debug', tooldir='.')
	def build(bld):
		...

The build will then output a file named pdebug.svg in the source directory.
"""

import re, sys, threading, time, traceback
try:
	from Queue import Queue
except:
	from queue import Queue
from waflib import Runner, Options, Task, Logs, Errors

SVG_TEMPLATE = """<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.0//EN" "http://www.w3.org/TR/2001/REC-SVG-20010904/DTD/svg10.dtd">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.0"
   x="${project.x}" y="${project.y}" width="${project.width}" height="${project.height}" id="svg602" xml:space="preserve">

<style type='text/css' media='screen'>
	g.over rect { stroke:#FF0000; fill-opacity:0.4 }
</style>

<script type='text/javascript'><![CDATA[
var svg  = document.getElementsByTagName('svg')[0];

svg.addEventListener('mouseover', function(e) {
	var g = e.target.parentNode;
	var x = document.getElementById('r_' + g.id);
	if (x) {
		g.setAttribute('class', g.getAttribute('class') + ' over');
		x.setAttribute('class', x.getAttribute('class') + ' over');
		showInfo(e, g.id, e.target.attributes.tooltip.value);
	}
}, false);

svg.addEventListener('mouseout', function(e) {
		var g = e.target.parentNode;
		var x = document.getElementById('r_' + g.id);
		if (x) {
			g.setAttribute('class', g.getAttribute('class').replace(' over', ''));
			x.setAttribute('class', x.getAttribute('class').replace(' over', ''));
			hideInfo(e);
		}
}, false);

function showInfo(evt, txt, details) {
${if project.tooltip}
	tooltip = document.getElementById('tooltip');

	var t = document.getElementById('tooltiptext');
	t.firstChild.data = txt + " " + details;

	var x = evt.clientX + 9;
	if (x > 250) { x -= t.getComputedTextLength() + 16; }
	var y = evt.clientY + 20;
	tooltip.setAttribute("transform", "translate(" + x + "," + y + ")");
	tooltip.setAttributeNS(null, "visibility", "visible");

	var r = document.getElementById('tooltiprect');
	r.setAttribute('width', t.getComputedTextLength() + 6);
${endif}
}

function hideInfo(evt) {
	var tooltip = document.getElementById('tooltip');
	tooltip.setAttributeNS(null,"visibility","hidden");
}
]]></script>

<!-- inkscape requires a big rectangle or it will not export the pictures properly -->
<rect
   x='${project.x}' y='${project.y}' width='${project.width}' height='${project.height}'
   style="font-size:10;fill:#ffffff;fill-opacity:0.01;fill-rule:evenodd;stroke:#ffffff;"></rect>

${if project.title}
  <text x="${project.title_x}" y="${project.title_y}"
    style="font-size:15px; text-anchor:middle; font-style:normal;font-weight:normal;fill:#000000;fill-opacity:1;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1;font-family:Bitstream Vera Sans">${project.title}</text>
${endif}


${for cls in project.groups}
  <g id='${cls.classname}'>
    ${for rect in cls.rects}
    <rect x='${rect.x}' y='${rect.y}' width='${rect.width}' height='${rect.height}' tooltip='${rect.name}' style="font-size:10;fill:${rect.color};fill-rule:evenodd;stroke:#000000;stroke-width:0.4;" />
    ${endfor}
  </g>
${endfor}

${for info in project.infos}
  <g id='r_${info.classname}'>
   <rect x='${info.x}' y='${info.y}' width='${info.width}' height='${info.height}' style="font-size:10;fill:${info.color};fill-rule:evenodd;stroke:#000000;stroke-width:0.4;" />
   <text x="${info.text_x}" y="${info.text_y}"
       style="font-size:12px;font-style:normal;font-weight:normal;fill:#000000;fill-opacity:1;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1;font-family:Bitstream Vera Sans"
   >${info.text}</text>
  </g>
${endfor}

${if project.tooltip}
  <g transform="translate(0,0)" visibility="hidden" id="tooltip">
       <rect id="tooltiprect" y="-15" x="-3" width="1" height="20" style="stroke:black;fill:#edefc2;stroke-width:1"/>
       <text id="tooltiptext" style="font-family:Arial; font-size:12;fill:black;"> </text>
  </g>
${endif}

</svg>
"""

COMPILE_TEMPLATE = '''def f(project):
	lst = []
	def xml_escape(value):
		return value.replace("&", "&amp;").replace('"', "&quot;").replace("'", "&apos;").replace("<", "&lt;").replace(">", "&gt;")

	%s
	return ''.join(lst)
'''
reg_act = re.compile(r"(?P<backslash>\\)|(?P<dollar>\$\$)|(?P<subst>\$\{(?P<code>[^}]*?)\})", re.M)
def compile_template(line):

	extr = []
	def repl(match):
		g = match.group
		if g('dollar'):
			return "$"
		elif g('backslash'):
			return "\\"
		elif g('subst'):
			extr.append(g('code'))
			return "<<|@|>>"
		return None

	line2 = reg_act.sub(repl, line)
	params = line2.split('<<|@|>>')
	assert(extr)


	indent = 0
	buf = []
	app = buf.append

	def app(txt):
		buf.append(indent * '\t' + txt)

	for x in range(len(extr)):
		if params[x]:
			app("lst.append(%r)" % params[x])

		f = extr[x]
		if f.startswith(('if', 'for')):
			app(f + ':')
			indent += 1
		elif f.startswith('py:'):
			app(f[3:])
		elif f.startswith(('endif', 'endfor')):
			indent -= 1
		elif f.startswith(('else', 'elif')):
			indent -= 1
			app(f + ':')
			indent += 1
		elif f.startswith('xml:'):
			app('lst.append(xml_escape(%s))' % f[4:])
		else:
			#app('lst.append((%s) or "cannot find %s")' % (f, f))
			app('lst.append(str(%s))' % f)

	if extr:
		if params[-1]:
			app("lst.append(%r)" % params[-1])

	fun = COMPILE_TEMPLATE % "\n\t".join(buf)
	# uncomment the following to debug the template
	#for i, x in enumerate(fun.splitlines()):
	#	print i, x
	return Task.funex(fun)

# red   #ff4d4d
# green #4da74d
# lila  #a751ff

color2code = {
	'GREEN'  : '#4da74d',
	'YELLOW' : '#fefe44',
	'PINK'   : '#a751ff',
	'RED'    : '#cc1d1d',
	'BLUE'   : '#6687bb',
	'CYAN'   : '#34e2e2',
}

mp = {}
info = [] # list of (text,color)

def map_to_color(name):
	if name in mp:
		return mp[name]
	try:
		cls = Task.classes[name]
	except KeyError:
		return color2code['RED']
	if cls.color in mp:
		return mp[cls.color]
	if cls.color in color2code:
		return color2code[cls.color]
	return color2code['RED']

def process(self):
	m = self.generator.bld.producer
	try:
		# TODO another place for this?
		del self.generator.bld.task_sigs[self.uid()]
	except KeyError:
		pass

	self.generator.bld.producer.set_running(1, self)

	try:
		ret = self.run()
	except Exception:
		self.err_msg = traceback.format_exc()
		self.hasrun = Task.EXCEPTION

		# TODO cleanup
		m.error_handler(self)
		return

	if ret:
		self.err_code = ret
		self.hasrun = Task.CRASHED
	else:
		try:
			self.post_run()
		except Errors.WafError:
			pass
		except Exception:
			self.err_msg = traceback.format_exc()
			self.hasrun = Task.EXCEPTION
		else:
			self.hasrun = Task.SUCCESS
	if self.hasrun != Task.SUCCESS:
		m.error_handler(self)

	self.generator.bld.producer.set_running(-1, self)

Task.Task.process_back = Task.Task.process
Task.Task.process = process

old_start = Runner.Parallel.start
def do_start(self):
	try:
		Options.options.dband
	except AttributeError:
		self.bld.fatal('use def options(opt): opt.load("parallel_debug")!')

	self.taskinfo = Queue()
	old_start(self)
	if self.dirty:
		make_picture(self)
Runner.Parallel.start = do_start

lock_running = threading.Lock()
def set_running(self, by, tsk):
	with lock_running:
		try:
			cache = self.lock_cache
		except AttributeError:
			cache = self.lock_cache = {}

		i = 0
		if by > 0:
			vals = cache.values()
			for i in range(self.numjobs):
				if i not in vals:
					cache[tsk] = i
					break
		else:
			i = cache[tsk]
			del cache[tsk]

		self.taskinfo.put( (i, id(tsk), time.time(), tsk.__class__.__name__, self.processed, self.count, by, ",".join(map(str, tsk.outputs)))  )
Runner.Parallel.set_running = set_running

def name2class(name):
	return name.replace(' ', '_').replace('.', '_')

def make_picture(producer):
	# first, cast the parameters
	if not hasattr(producer.bld, 'path'):
		return

	tmp = []
	try:
		while True:
			tup = producer.taskinfo.get(False)
			tmp.append(list(tup))
	except:
		pass

	try:
		ini = float(tmp[0][2])
	except:
		return

	if not info:
		seen = []
		for x in tmp:
			name = x[3]
			if not name in seen:
				seen.append(name)
			else:
				continue

			info.append((name, map_to_color(name)))
		info.sort(key=lambda x: x[0])

	thread_count = 0
	acc = []
	for x in tmp:
		thread_count += x[6]
		acc.append("%d %d %f %r %d %d %d %s" % (x[0], x[1], x[2] - ini, x[3], x[4], x[5], thread_count, x[7]))

	data_node = producer.bld.path.make_node('pdebug.dat')
	data_node.write('\n'.join(acc))

	tmp = [lst[:2] + [float(lst[2]) - ini] + lst[3:] for lst in tmp]

	st = {}
	for l in tmp:
		if not l[0] in st:
			st[l[0]] = len(st.keys())
	tmp = [  [st[lst[0]]] + lst[1:] for lst in tmp ]
	THREAD_AMOUNT = len(st.keys())

	st = {}
	for l in tmp:
		if not l[1] in st:
			st[l[1]] = len(st.keys())
	tmp = [  [lst[0]] + [st[lst[1]]] + lst[2:] for lst in tmp ]


	BAND = Options.options.dband

	seen = {}
	acc = []
	for x in range(len(tmp)):
		line = tmp[x]
		id = line[1]

		if id in seen:
			continue
		seen[id] = True

		begin = line[2]
		thread_id = line[0]
		for y in range(x + 1, len(tmp)):
			line = tmp[y]
			if line[1] == id:
				end = line[2]
				#print id, thread_id, begin, end
				#acc.append(  ( 10*thread_id, 10*(thread_id+1), 10*begin, 10*end ) )
				acc.append( (BAND * begin, BAND*thread_id, BAND*end - BAND*begin, BAND, line[3], line[7]) )
				break

	if Options.options.dmaxtime < 0.1:
		gwidth = 1
		for x in tmp:
			m = BAND * x[2]
			if m > gwidth:
				gwidth = m
	else:
		gwidth = BAND * Options.options.dmaxtime

	ratio = float(Options.options.dwidth) / gwidth
	gwidth = Options.options.dwidth
	gheight = BAND * (THREAD_AMOUNT + len(info) + 1.5)


	# simple data model for our template
	class tobject(object):
		pass

	model = tobject()
	model.x = 0
	model.y = 0
	model.width = gwidth + 4
	model.height = gheight + 4

	model.tooltip = not Options.options.dnotooltip

	model.title = Options.options.dtitle
	model.title_x = gwidth / 2
	model.title_y = gheight + - 5

	groups = {}
	for (x, y, w, h, clsname, name) in acc:
		try:
			groups[clsname].append((x, y, w, h, name))
		except:
			groups[clsname] = [(x, y, w, h, name)]

	# groups of rectangles (else js highlighting is slow)
	model.groups = []
	for cls in groups:
		g = tobject()
		model.groups.append(g)
		g.classname = name2class(cls)
		g.rects = []
		for (x, y, w, h, name) in groups[cls]:
			r = tobject()
			g.rects.append(r)
			r.x = 2 + x * ratio
			r.y = 2 + y
			r.width = w * ratio
			r.height = h
			r.name = name
			r.color = map_to_color(cls)

	cnt = THREAD_AMOUNT

	# caption
	model.infos = []
	for (text, color) in info:
		inf = tobject()
		model.infos.append(inf)
		inf.classname = name2class(text)
		inf.x = 2 + BAND
		inf.y = 5 + (cnt + 0.5) * BAND
		inf.width = BAND/2
		inf.height = BAND/2
		inf.color = color

		inf.text = text
		inf.text_x = 2 + 2 * BAND
		inf.text_y = 5 + (cnt + 0.5) * BAND + 10

		cnt += 1

	# write the file...
	template1 = compile_template(SVG_TEMPLATE)
	txt = template1(model)

	node = producer.bld.path.make_node('pdebug.svg')
	node.write(txt)
	Logs.warn('Created the diagram %r', node)

def options(opt):
	opt.add_option('--dtitle', action='store', default='Parallel build representation for %r' % ' '.join(sys.argv),
		help='title for the svg diagram', dest='dtitle')
	opt.add_option('--dwidth', action='store', type='int', help='diagram width', default=800, dest='dwidth')
	opt.add_option('--dtime', action='store', type='float', help='recording interval in seconds', default=0.009, dest='dtime')
	opt.add_option('--dband', action='store', type='int', help='band width', default=22, dest='dband')
	opt.add_option('--dmaxtime', action='store', type='float', help='maximum time, for drawing fair comparisons', default=0, dest='dmaxtime')
	opt.add_option('--dnotooltip', action='store_true', help='disable tooltips', default=False, dest='dnotooltip')

                                                                                                                                                                                                                             #! /usr/bin/env python
# encoding: utf-8
# Alexander Afanasyev (UCLA), 2014

"""
Enable precompiled C++ header support (currently only clang++ and g++ are supported)

To use this tool, wscript should look like:

	def options(opt):
		opt.load('pch')
		# This will add `--with-pch` configure option.
		# Unless --with-pch during configure stage specified, the precompiled header support is disabled

	def configure(conf):
		conf.load('pch')
		# this will set conf.env.WITH_PCH if --with-pch is specified and the supported compiler is used
		# Unless conf.env.WITH_PCH is set, the precompiled header support is disabled

	def build(bld):
		bld(features='cxx pch',
			target='precompiled-headers',
			name='precompiled-headers',
			headers='a.h b.h c.h', # headers to pre-compile into `precompiled-headers`

			# Other parameters to compile precompiled headers
			# includes=...,
			# export_includes=...,
			# use=...,
			# ...

			# Exported parameters will be propagated even if precompiled headers are disabled
		)

		bld(
			target='test',
			features='cxx cxxprogram',
			source='a.cpp b.cpp d.cpp main.cpp',
			use='precompiled-headers',
		)

		# or

		bld(
			target='test',
			features='pch cxx cxxprogram',
			source='a.cpp b.cpp d.cpp main.cpp',
			headers='a.h b.h c.h',
		)

Note that precompiled header must have multiple inclusion guards.  If the guards are missing, any benefit of precompiled header will be voided and compilation may fail in some cases.
"""

import os
from waflib import Task, TaskGen, Utils
from waflib.Tools import c_preproc, cxx


PCH_COMPILER_OPTIONS = {
	'clang++': [['-include'], '.pch', ['-x', 'c++-header']],
	'g++':     [['-include'], '.gch', ['-x', 'c++-header']],
}


def options(opt):
	opt.add_option('--without-pch', action='store_false', default=True, dest='with_pch', help='''Try to use precompiled header to speed up compilation (only g++ and clang++)''')

def configure(conf):
	if (conf.options.with_pch and conf.env['COMPILER_CXX'] in PCH_COMPILER_OPTIONS.keys()):
		conf.env.WITH_PCH = True
		flags = PCH_COMPILER_OPTIONS[conf.env['COMPILER_CXX']]
		conf.env.CXXPCH_F = flags[0]
		conf.env.CXXPCH_EXT = flags[1]
		conf.env.CXXPCH_FLAGS = flags[2]


@TaskGen.feature('pch')
@TaskGen.before('process_source')
def apply_pch(self):
	if not self.env.WITH_PCH:
		return

	if getattr(self.bld, 'pch_tasks', None) is None:
		self.bld.pch_tasks = {}

	if getattr(self, 'headers', None) is None:
		return

	self.headers = self.to_nodes(self.headers)

	if getattr(self, 'name', None):
		try:
			task = self.bld.pch_tasks[self.name]
			self.bld.fatal("Duplicated 'pch' task with name %r" % "%s.%s" % (self.name, self.idx))
		except KeyError:
			pass

	out = '%s.%d%s' % (self.target, self.idx, self.env['CXXPCH_EXT'])
	out = self.path.find_or_declare(out)
	task = self.create_task('gchx', self.headers, out)

	# target should be an absolute path of `out`, but without precompiled header extension
	task.target = out.abspath()[:-len(out.suffix())]

	self.pch_task = task
	if getattr(self, 'name', None):
		self.bld.pch_tasks[self.name] = task

@TaskGen.feature('cxx')
@TaskGen.after_method('process_source', 'propagate_uselib_vars')
def add_pch(self):
	if not (self.env['WITH_PCH'] and getattr(self, 'use', None) and getattr(self, 'compiled_tasks', None) and getattr(self.bld, 'pch_tasks', None)):
		return

	pch = None
	# find pch task, if any

	if getattr(self, 'pch_task', None):
		pch = self.pch_task
	else:
		for use in Utils.to_list(self.use):
			try:
				pch = self.bld.pch_tasks[use]
			except KeyError:
				pass

	if pch:
		for x in self.compiled_tasks:
			x.env.append_value('CXXFLAGS', self.env['CXXPCH_F'] + [pch.target])

class gchx(Task.Task):
	run_str = '${CXX} ${ARCH_ST:ARCH} ${CXXFLAGS} ${CXXPCH_FLAGS} ${FRAMEWORKPATH_ST:FRAMEWORKPATH} ${CPPPATH_ST:INCPATHS} ${DEFINES_ST:DEFINES} ${CXXPCH_F:SRC} ${CXX_SRC_F}${SRC[0].abspath()} ${CXX_TGT_F}${TGT[0].abspath()} ${CPPFLAGS}'
	scan    = c_preproc.scan
	color   = 'BLUE'
	ext_out=['.h']

	def runnable_status(self):
		try:
			node_deps = self.generator.bld.node_deps[self.uid()]
		except KeyError:
			node_deps = []
		ret = Task.Task.runnable_status(self)
		if ret == Task.SKIP_ME and self.env.CXX_NAME == 'clang':
			t = os.stat(self.outputs[0].abspath()).st_mtime
			for n in self.inputs + node_deps:
				if os.stat(n.abspath()).st_mtime > t:
					return Task.RUN_ME
		return ret
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                #! /usr/bin/env python
# encoding: utf-8
#
# written by Sylvain Rouquette, 2011

'''
Install pep8 module:
$ easy_install pep8
	or
$ pip install pep8

To add the pep8 tool to the waf file:
$ ./waf-light --tools=compat15,pep8
	or, if you have waf >= 1.6.2
$ ./waf update --files=pep8


Then add this to your wscript:

[at]extension('.py', 'wscript')
def run_pep8(self, node):
	self.create_task('Pep8', node)

'''

import threading
from waflib import Task, Options

pep8 = __import__('pep8')


class Pep8(Task.Task):
	color = 'PINK'
	lock = threading.Lock()

	def check_options(self):
		if pep8.options:
			return
		pep8.options = Options.options
		pep8.options.prog = 'pep8'
		excl = pep8.options.exclude.split(',')
		pep8.options.exclude = [s.rstrip('/') for s in excl]
		if pep8.options.filename:
			pep8.options.filename = pep8.options.filename.split(',')
		if pep8.options.select:
			pep8.options.select = pep8.options.select.split(',')
		else:
			pep8.options.select = []
		if pep8.options.ignore:
			pep8.options.ignore = pep8.options.ignore.split(',')
		elif pep8.options.select:
			# Ignore all checks which are not explicitly selected
			pep8.options.ignore = ['']
		elif pep8.options.testsuite or pep8.options.doctest:
			# For doctest and testsuite, all checks are required
			pep8.options.ignore = []
		else:
			# The default choice: ignore controversial checks
			pep8.options.ignore = pep8.DEFAULT_IGNORE.split(',')
		pep8.options.physical_checks = pep8.find_checks('physical_line')
		pep8.options.logical_checks = pep8.find_checks('logical_line')
		pep8.options.counters = dict.fromkeys(pep8.BENCHMARK_KEYS, 0)
		pep8.options.messages = {}

	def run(self):
		with Pep8.lock:
			self.check_options()
		pep8.input_file(self.inputs[0].abspath())
		return 0 if not pep8.get_count() else -1


def options(opt):
	opt.add_option('-q', '--quiet', default=0, action='count',
				   help="report only file names, or nothing with -qq")
	opt.add_option('-r', '--repeat', action='store_true',
				   help="show all occurrences of the same error")
	opt.add_option('--exclude', metavar='patterns',
				   default=pep8.DEFAULT_EXCLUDE,
				   help="exclude files or directories which match these "
				   "comma separated patterns (default: %s)" %
				   pep8.DEFAULT_EXCLUDE,
				   dest='exclude')
	opt.add_option('--filename', metavar='patterns', default='*.py',
				   help="when parsing directories, only check filenames "
				   "matching these comma separated patterns (default: "
				   "*.py)")
	opt.add_option('--select', metavar='errors', default='',
				   help="select errors and warnings (e.g. E,W6)")
	opt.add_option('--ignore', metavar='errors', default='',
				   help="skip errors and warnings (e.g. E4,W)")
	opt.add_option('--show-source', action='store_true',
				   help="show source code for each error")
	opt.add_option('--show-pep8', action='store_true',
				   help="show text of PEP 8 for each error")
	opt.add_option('--statistics', action='store_true',
				   help="count errors and warnings")
	opt.add_option('--count', action='store_true',
				   help="print total number of errors and warnings "
				   "to standard error and set exit code to 1 if "
				   "total is not null")
	opt.add_option('--benchmark', action='store_true',
				   help="measure processing speed")
	opt.add_option('--testsuite', metavar='dir',
				   help="run regression tests from dir")
	opt.add_option('--doctest', action='store_true',
				   help="run doctest on myself")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            #!/usr/bin/env python
# encoding: utf-8
# Antoine Dechaume 2011

"""
Detect the PGI C compiler
"""

import sys, re
from waflib import Errors
from waflib.Configure import conf
from waflib.Tools.compiler_c import c_compiler
c_compiler['linux'].append('pgicc')

@conf
def find_pgi_compiler(conf, var, name):
	"""
	Find the program name, and execute it to ensure it really is itself.
	"""
	if sys.platform == 'cygwin':
		conf.fatal('The PGI compiler does not work on Cygwin')

	v = conf.env
	cc = None
	if v[var]:
		cc = v[var]
	elif var in conf.environ:
		cc = conf.environ[var]
	if not cc:
		cc = conf.find_program(name, var=var)
	if not cc:
		conf.fatal('PGI Compiler (%s) was not found' % name)

	v[var + '_VERSION'] = conf.get_pgi_version(cc)
	v[var] = cc
	v[var + '_NAME'] = 'pgi'

@conf
def get_pgi_version(conf, cc):
	"""Find the version of a pgi compiler."""
	version_re = re.compile(r"The Portland Group", re.I).search
	cmd = cc + ['-V', '-E'] # Issue 1078, prevent wrappers from linking

	try:
		out, err = conf.cmd_and_log(cmd, output=0)
	except Errors.WafError:
		conf.fatal('Could not find pgi compiler %r' % cmd)

	if out:
		match = version_re(out)
	else:
		match = version_re(err)

	if not match:
		conf.fatal('Could not verify PGI signature')

	cmd = cc + ['-help=variable']
	try:
		out, err = conf.cmd_and_log(cmd, output=0)
	except Errors.WafError:
		conf.fatal('Could not find pgi compiler %r' % cmd)

	version = re.findall(r'^COMPVER\s*=(.*)', out, re.M)
	if len(version) != 1:
		conf.fatal('Could not determine the compiler version')
	return version[0]

def configure(conf):
	conf.find_pgi_compiler('CC', 'pgcc')
	conf.find_ar()
	conf.gcc_common_flags()
	conf.cc_load_tools()
	conf.cc_add_flags()
	conf.link_add_flags()

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     #!/usr/bin/env python
# encoding: utf-8
# Antoine Dechaume 2011

"""
Detect the PGI C++ compiler
"""

from waflib.Tools.compiler_cxx import cxx_compiler
cxx_compiler['linux'].append('pgicxx')

from waflib.extras import pgicc

def configure(conf):
	conf.find_pgi_compiler('CXX', 'pgCC')
	conf.find_ar()
	conf.gxx_common_flags()
	conf.cxx_load_tools()
	conf.cxx_add_flags()
	conf.link_add_flags()
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     #! /usr/bin/env python
# per rosengren 2011

from os import environ, path
from waflib import TaskGen, Utils

def options(opt):
	grp = opt.add_option_group('Oracle ProC Options')
	grp.add_option('--oracle_home', action='store', default=environ.get('PROC_ORACLE'), help='Path to Oracle installation home (has bin/lib)')
	grp.add_option('--tns_admin', action='store', default=environ.get('TNS_ADMIN'), help='Directory containing server list (TNS_NAMES.ORA)')
	grp.add_option('--connection', action='store', default='dummy-user/dummy-password@dummy-server', help='Format: user/password@server')

def configure(cnf):
	env = cnf.env
	if not env.PROC_ORACLE:
		env.PROC_ORACLE = cnf.options.oracle_home
	if not env.PROC_TNS_ADMIN:
		env.PROC_TNS_ADMIN = cnf.options.tns_admin
	if not env.PROC_CONNECTION:
		env.PROC_CONNECTION = cnf.options.connection
	cnf.find_program('proc', var='PROC', path_list=env.PROC_ORACLE + path.sep + 'bin')

def proc(tsk):
	env = tsk.env
	gen = tsk.generator
	inc_nodes = gen.to_incnodes(Utils.to_list(getattr(gen,'includes',[])) + env['INCLUDES'])

	cmd = (
		[env.PROC] +
		['SQLCHECK=SEMANTICS'] +
		(['SYS_INCLUDE=(' + ','.join(env.PROC_INCLUDES) + ')']
			if env.PROC_INCLUDES else []) +
		['INCLUDE=(' + ','.join(
			[i.bldpath() for i in inc_nodes]
		) + ')'] +
		['userid=' + env.PROC_CONNECTION] +
		['INAME=' + tsk.inputs[0].bldpath()] +
		['ONAME=' + tsk.outputs[0].bldpath()]
	)
	exec_env = {
		'ORACLE_HOME': env.PROC_ORACLE,
		'LD_LIBRARY_PATH': env.PROC_ORACLE + path.sep + 'lib',
	}
	if env.PROC_TNS_ADMIN:
		exec_env['TNS_ADMIN'] = env.PROC_TNS_ADMIN
	return tsk.exec_command(cmd, env=exec_env)

TaskGen.declare_chain(
	name = 'proc',
	rule = proc,
	ext_in = '.pc',
	ext_out = '.c',
)

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   #!/usr/bin/env python
# encoding: utf-8
# Thomas Nagy, 2010-2018 (ita)

from __future__ import with_statement

import os

all_modifs = {}

def fixdir(dir):
	"""Call all substitution functions on Waf folders"""
	for k in all_modifs:
		for v in all_modifs[k]:
			modif(os.path.join(dir, 'waflib'), k, v)

def modif(dir, name, fun):
	"""Call a substitution function"""
	if name == '*':
		lst = []
		for y in '. Tools extras'.split():
			for x in os.listdir(os.path.join(dir, y)):
				if x.endswith('.py'):
					lst.append(y + os.sep + x)
		for x in lst:
			modif(dir, x, fun)
		return

	filename = os.path.join(dir, name)
	with open(filename, 'r') as f:
		txt = f.read()

	txt = fun(txt)

	with open(filename, 'w') as f:
		f.write(txt)

def subst(*k):
	"""register a substitution function"""
	def do_subst(fun):
		for x in k:
			try:
				all_modifs[x].append(fun)
			except KeyError:
				all_modifs[x] = [fun]
		return fun
	return do_subst

@subst('*')
def r1(code):
	"utf-8 fixes for python < 2.6"
	code = code.replace('as e:', ',e:')
	code = code.replace(".decode(sys.stdout.encoding or'latin-1',errors='replace')", '')
	return code.replace('.encode()', '')

@subst('Runner.py')
def r4(code):
	"generator syntax"
	return code.replace('next(self.biter)', 'self.biter.next()').replace('self.daemon = True', 'self.setDaemon(1)')

@subst('Context.py')
def r5(code):
	return code.replace("('Execution failure: %s'%str(e),ex=e)", "('Execution failure: %s'%str(e),ex=e),None,sys.exc_info()[2]")

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                #! /usr/bin/env python
# encoding: utf-8
# Thomas Nagy, 2016-2018 (ita)

import os, sys, traceback, base64, signal
try:
	import cPickle
except ImportError:
	import pickle as cPickle

try:
	import subprocess32 as subprocess
except ImportError:
	import subprocess

try:
	TimeoutExpired = subprocess.TimeoutExpired
except AttributeError:
	class TimeoutExpired(Exception):
		pass

def run():
	txt = sys.stdin.readline().strip()
	if not txt:
		# parent process probably ended
		sys.exit(1)
	[cmd, kwargs, cargs] = cPickle.loads(base64.b64decode(txt))
	cargs = cargs or {}

	if not 'close_fds' in kwargs:
		# workers have no fds
		kwargs['close_fds'] = False

	ret = 1
	out, err, ex, trace = (None, None, None, None)
	try:
		proc = subprocess.Popen(cmd, **kwargs)
		try:
			out, err = proc.communicate(**cargs)
		except TimeoutExpired:
			if kwargs.get('start_new_session') and hasattr(os, 'killpg'):
				os.killpg(proc.pid, signal.SIGKILL)
			else:
				proc.kill()
			out, err = proc.communicate()
			exc = TimeoutExpired(proc.args, timeout=cargs['timeout'], output=out)
			exc.stderr = err
			raise exc
		ret = proc.returncode
	except Exception as e:
		exc_type, exc_value, tb = sys.exc_info()
		exc_lines = traceback.format_exception(exc_type, exc_value, tb)
		trace = str(cmd) + '\n' + ''.join(exc_lines)
		ex = e.__class__.__name__

	# it is just text so maybe we do not need to pickle()
	tmp = [ret, out, err, ex, trace]
	obj = base64.b64encode(cPickle.dumps(tmp))
	sys.stdout.write(obj.decode())
	sys.stdout.write('\n')
	sys.stdout.flush()

while 1:
	try:
		run()
	except KeyboardInterrupt:
		break

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               #! /usr/bin/env python
# encoding: utf-8
# Thomas Nagy, 2005-2018

"""
to make a custom waf file use the option --tools

To add a tool that does not exist in the folder compat15, pass an absolute path:
./waf-light  --tools=compat15,/comp/waf/aba.py --prelude=$'\tfrom waflib.extras import aba\n\taba.foo()'
"""

from __future__ import with_statement

VERSION="2.0.27"
APPNAME='waf'
REVISION=''

top = '.'
out = 'build'

zip_types = ['bz2', 'gz', 'xz']

PRELUDE = ''

import os, sys, re, io, optparse, tokenize
from hashlib import md5

from waflib import Errors, Utils, Options, Logs, Scripting
from waflib import Configure
Configure.autoconfig = 1

def sub_file(fname, lst):
	with open(fname, 'r') as f:
		txt = f.read()

	for (key, val) in lst:
		re_pat = re.compile(key, re.M)
		txt = re_pat.sub(val, txt)

	with open(fname, 'w') as f:
		f.write(txt)

def to_bytes(x):
	if sys.hexversion>0x300000f:
		return x.encode()
	return x

Logs.warn('------> Executing code from the top-level wscript <-----')
def init(ctx):
	if Options.options.setver: # maintainer only (ita)
		ver = Options.options.setver
		hexver = Utils.num2ver(ver)
		hexver = '0x%x'%hexver
		sub_file('wscript', (('^VERSION=(.*)', 'VERSION="%s"' % ver), ))
		sub_file('waf-light', (('^VERSION=(.*)', 'VERSION="%s"' % ver), ))

		pats = []
		pats.append(('^WAFVERSION=(.*)', 'WAFVERSION="%s"' % ver))
		pats.append(('^HEXVERSION(.*)', 'HEXVERSION=%s' % hexver))

		try:
			rev = ctx.cmd_and_log("git rev-parse HEAD").strip()
		except Errors.WafError:
			rev = ''
		else:
			pats.append(('^WAFREVISION(.*)', 'WAFREVISION="%s"' % rev))

		sub_file('waflib/Context.py', pats)

		sys.exit(0)

def check(ctx):
	Logs.warn('Nothing to do')

# this function is called before any other for parsing the command-line
def options(opt):

	# generate waf
	opt.add_option('--make-waf', action='store_true', default=True,
		help='creates the waf script', dest='waf')

	opt.add_option('--interpreter', action='store', default=None,
		help='specify the #! line on top of the waf file', dest='interpreter')

	opt.add_option('--sign', action='store_true', default=False, help='make a signed file', dest='signed')

	default_zip = 'bz2'
	if os.name == 'java':
		default_zip = 'gz'
	opt.add_option('--zip-type', action='store', default=default_zip,
		help='specify the zip type [Allowed values: %s]' % ' '.join(zip_types), dest='zip')

	opt.add_option('--make-batch', action='store_true', default=False,
		help='creates a convenience waf.bat file (done automatically on win32 systems)',
		dest='make_batch')

	opt.add_option('--yes', action='store_true', default=False,
		help=optparse.SUPPRESS_HELP,
		dest='yes')

	# those ones are not too interesting
	opt.add_option('--set-version', default='',
		help='sets the version number for waf releases (for the maintainer)', dest='setver')
	opt.add_option('--set-name', default='waf', help=optparse.SUPPRESS_HELP, dest='wafname')

	opt.add_option('--strip', action='store_true', default=True,
		help='shrinks waf (strip docstrings, saves 33kb)',
		dest='strip_comments')
	opt.add_option('--nostrip', action='store_false', help='no shrinking',
		dest='strip_comments')
	opt.add_option('--tools', action='store', help='Comma-separated 3rd party tools to add, eg: "compat,ocaml" [Default: "compat15"]',
		dest='add3rdparty', default='compat15')
	opt.add_option('--coretools', action='store', help='Comma-separated core tools to add, eg: "vala,tex" [Default: all of them]',
		dest='coretools', default='default')
	opt.add_option('--prelude', action='store', help='Code to execute before calling waf', dest='prelude', default=PRELUDE)
	opt.add_option('--namesfrom', action='store', help='Obtain the file names from a model archive', dest='namesfrom', default=None)
	opt.load('python')

def process_tokens(tokens, filename):
	accu = []
	prev = tokenize.NEWLINE

	indent = 0
	line_buf = []

	for (type, token, start, end, line) in tokens:
		token = token.replace('\r\n', '\n')
		if type == tokenize.NEWLINE:
			if line_buf:
				accu.append(indent * '\t')
				ln = "".join(line_buf)
				if ln == 'if __name__=="__main__":': break
				#ln = ln.replace('\n', '')
				accu.append(ln)
				accu.append('\n')
				line_buf = []
				prev = tokenize.NEWLINE
		elif type == tokenize.INDENT:
			indent += 1
		elif type == tokenize.DEDENT:
			indent -= 1
		elif type == tokenize.NAME:
			if prev == tokenize.NAME or prev == tokenize.NUMBER: line_buf.append(' ')
			line_buf.append(token)
		elif type == tokenize.NUMBER:
			if prev == tokenize.NAME or prev == tokenize.NUMBER: line_buf.append(' ')
			line_buf.append(token)
		elif type == tokenize.STRING:
			if not line_buf and token.startswith('"'): pass
			else:
				if token.lower().startswith('f'):
					raise ValueError('Found f-strings in %s which require Python >= 3.6, use "waf-light --nostrip"' % filename)
				line_buf.append(token)
		elif type == tokenize.COMMENT:
			pass
		elif type == tokenize.OP:
			line_buf.append(token)
		else:
			if token != "\n": line_buf.append(token)

		if token != '\n':
			prev = type

	body = ''.join(accu)
	return body

deco_re = re.compile('(def|class)\\s+(\\w+)\\(.*')
def process_decorators(body):
	lst = body.splitlines()
	accu = []
	all_deco = []
	buf = [] # put the decorator lines
	for line in lst:
		if line.startswith('@'):
			buf.append(line[1:])
		elif buf:
			name = deco_re.sub('\\2', line)
			if not name:
				raise IOError("decorator not followed by a function!" + line)
			for x in buf:
				all_deco.append('%s(%s)' % (x, name))
			accu.append(line)
			buf = []
		else:
			accu.append(line)
	return '\n'.join(accu+all_deco)

def sfilter(path):
	if path.endswith('.py') :
		if Options.options.strip_comments:
			if sys.version_info[0] >= 3:
				with open(path, 'rb') as f:
					tk = tokenize.tokenize(f.readline)
					next(tk) # the first one is always tokenize.ENCODING for Python 3, ignore it
					cnt = process_tokens(tk, path)
			else:
				with open(path, 'r') as f:
					cnt = process_tokens(tokenize.generate_tokens(f.readline), path)
		else:
			with open(path, 'r') as f:
				cnt = f.read()
		# WARNING: since python >= 2.5 is required, decorators are not processed anymore
		# uncomment the following to enable decorator replacement:
		#cnt = process_decorators(cnt)
		#if cnt.find('set(') > -1:
		#	cnt = 'import sys\nif sys.hexversion < 0x020400f0: from sets import Set as set\n' + cnt
		cnt = '#! /usr/bin/env python\n# encoding: utf-8\n# WARNING! Do not edit! https://waf.io/book/index.html#_obtaining_the_waf_file\n\n' + cnt

	else:
		with open(path, 'r') as f:
			cnt = f.read()

	if sys.hexversion > 0x030000f0:
		return (io.BytesIO(cnt.encode('utf-8')), len(cnt.encode('utf-8')), cnt)
	return (io.BytesIO(cnt), len(cnt), cnt)

def create_waf(self, *k, **kw):
	mw = 'tmp-waf-'+VERSION
	print('-> preparing %r' % mw)

	import tarfile, zipfile

	zipType = Options.options.zip.strip().lower()
	if zipType not in zip_types:
		zipType = zip_types[0]

	directory_files = {}
	files = []
	add3rdparty = []
	for x in Options.options.add3rdparty.split(','):
		if os.path.isdir(x):
			# Create mapping from files absolute path to path in module
			# directory (for module mylib):
			#
			#     {"/home/path/mylib/__init__.py": "mylib/__init__.py",
			#      "/home/path/mylib/lib.py": "mylib/lib.py",
			#      "/home/path/mylib/sub/sub.py": "mylib/sub/lib.py"
			#     }
			#
			x_dir = self.generator.bld.root.find_dir(
				os.path.abspath(os.path.expanduser(x)))

			file_list = x_dir.ant_glob('**/*.py')

			for f in file_list:

				file_from = f.abspath()
				file_to = os.path.join(x_dir.name, f.path_from(x_dir))

				# If this is executed on Windows, then file_to will contain
				# '\' path separators. These should be changed to '/', otherwise
				# the added tools will not be accessible on Unix systems.
				directory_files[file_from] = file_to.replace('\\', '/')
				files.append(file_from)

		elif os.path.isabs(x):
			files.append(x)
		else:
			add3rdparty.append(x + '.py')

	coretools = []
	for x in Options.options.coretools.split(','):
		coretools.append(x + '.py')

	up_node = self.generator.bld.path
	for node in up_node.find_dir('waflib').ant_glob(incl=['*.py', 'Tools/*.py', 'extras/*.py']):
		relpath = node.path_from(up_node)
		if node.name == '__init__.py':
			files.append(relpath)
			continue
		if node.parent.name == 'Tools' and Options.options.coretools != 'default':
			if node.name not in coretools:
				continue
		if node.parent.name == 'extras':
			if node.name not in add3rdparty:
				continue
		files.append(relpath)

	if Options.options.namesfrom:
		with tarfile.open(Options.options.namesfrom) as tar:
			oldfiles = files
			files = [x.name for x in tar.getmembers()]
			if set(files) ^ set(oldfiles):
				Logs.warn('The archive model has differences:')
				Logs.warn('- Added %r', list(set(files) - set(oldfiles)))
				Logs.warn('- Removed %r', list(set(oldfiles) - set(files)))

	#open a file as tar.[extension] for writing
	tar = tarfile.open('%s.tar.%s' % (mw, zipType), "w:%s" % zipType)
	z = zipfile.ZipFile("zip/waflib.zip", "w", compression=zipfile.ZIP_DEFLATED)
	for x in files:
		try:
			tarinfo = tar.gettarinfo(x, x)
		except NotImplementedError:
			# jython 2.7.0 workaround
			tarinfo = tarfile.TarInfo(x)
		tarinfo.uid   = tarinfo.gid   = 0
		tarinfo.uname = tarinfo.gname = 'root'
		if os.environ.get('SOURCE_DATE_EPOCH'):
			tarinfo.mtime = int(os.environ.get('SOURCE_DATE_EPOCH'))
		(code, size, cnt) = sfilter(x)
		tarinfo.size = size

		if x in directory_files:
			tarinfo.name = 'waflib/extras/' + directory_files[x]
		elif os.path.isabs(x):
			tarinfo.name = 'waflib/extras/' + os.path.split(x)[1]

		print('   adding %s as %s' % (x, tarinfo.name))
		def dest(x):
			if x in directory_files:
				return os.path.join('waflib', 'extras', directory_files[x])
			elif os.path.isabs(x):
				return os.path.join('waflib', 'extras', os.path.basename(x))
			else:
				return os.path.normpath(os.path.relpath(x, "."))

		z.write(x, dest(x))
		tar.addfile(tarinfo, code)
	tar.close()
	z.close()

	with open('waf-light', 'r') as f:
		code1 = f.read()

	# tune the application name if necessary
	if Options.options.wafname != 'waf':
		Options.options.prelude = '\tfrom waflib import Context\n\tContext.WAFNAME=%r\n' % Options.options.wafname + Options.options.prelude

	# now store the revision unique number in waf
	code1 = code1.replace("if sys.hexversion<0x206000f:\n\traise ImportError('Python >= 2.6 is required to create the waf file')\n", '')
	code1 = code1.replace('\t#import waflib.extras.compat15#PRELUDE', Options.options.prelude)

	# when possible, set the git revision in the waf file
	bld = self.generator.bld
	try:
		rev = bld.cmd_and_log('git rev-parse HEAD', quiet=0).strip()
	except Errors.WafError:
		rev = ''
	else:
		reg = re.compile('^GIT(.*)', re.M)
		code1 = reg.sub('GIT="%s"' % rev, code1)

	# if the waf file is installed somewhere... but do not do that
	prefix = ''
	reg = re.compile('^INSTALL=(.*)', re.M)
	code1 = reg.sub(r'INSTALL=%r' % prefix, code1)
	#change the tarfile extension in the waf script
	reg = re.compile('bz2', re.M)
	code1 = reg.sub(zipType, code1)
	if zipType == 'gz':
		code1 = code1.replace('bunzip2', 'gzip -d')
	elif zipType == 'xz':
		code1 = code1.replace('bunzip2', 'xz -d')

	with open('%s.tar.%s' % (mw, zipType), 'rb') as f:
		cnt = f.read()

	# the REVISION value is the md5 sum of the compressed data (facilitate audits)
	m = md5()
	m.update(cnt)
	REVISION = m.hexdigest()
	reg = re.compile('^REVISION=(.*)', re.M)
	code1 = reg.sub(r'REVISION="%s"' % REVISION, code1)

	def find_unused(kd, ch):
		for i in range(35, 125):
			for j in range(35, 125):
				if i==j: continue
				if i == 39 or j == 39: continue
				if i == 92 or j == 92: continue
				s = chr(i) + chr(j)
				if -1 == kd.find(s.encode()):
					return (kd.replace(ch.encode(), s.encode()), s)
		raise ValueError('Could not find a proper encoding')

	# The reverse order prevents collisions
	(cnt, C3) = find_unused(cnt, '\x00')
	(cnt, C2) = find_unused(cnt, '\r')
	(cnt, C1) = find_unused(cnt, '\n')
	ccc = code1.replace("C1='x'", "C1='%s'" % C1).replace("C2='x'", "C2='%s'" % C2).replace("C3='x'", "C3='%s'" % C3)

	if getattr(Options.options, 'interpreter', None):
		ccc = ccc.replace('#!/usr/bin/env python', Options.options.interpreter)

	with open('waf', 'wb') as f:
		f.write(ccc.encode())
		f.write(to_bytes('#==>\n#'))
		f.write(cnt)
		f.write(to_bytes('\n#<==\n'))

		if Options.options.signed:
			f.flush()
			try:
				os.remove('waf.asc')
			except OSError:
				pass
			ret = Utils.subprocess.Popen('gpg -bass waf', shell=True).wait()
			if ret:
				raise ValueError('Could not sign the waf file!')

			sig = Utils.readf('waf.asc')
			sig = sig.replace('\r', '').replace('\n', '\\n')
			f.write(to_bytes('#'))
			f.write(to_bytes(sig))
			f.write(to_bytes('\n'))
			os.remove('waf.asc')


	if sys.platform == 'win32' or Options.options.make_batch:
		with open('waf.bat', 'w') as f:
			f.write('@setlocal\n@set PYEXE=python\n@where %PYEXE% 1>NUL 2>NUL\n@if %ERRORLEVEL% neq 0 set PYEXE=py\n@%PYEXE% -x "%~dp0waf" %*\n@exit /b %ERRORLEVEL%\n')

	if sys.platform != 'win32':
		os.chmod('waf', Utils.O755)
	os.remove('%s.tar.%s' % (mw, zipType))

def configure(conf):
	conf.load('python')

def build(bld):
	waf = bld.path.make_node('waf') # do not use a build directory for this file
	bld(name='create_waf', rule=create_waf, target=waf, always=True, color='PINK')

class Dist(Scripting.Dist):
	def get_excl(self):
		return super(self.__class__, self).get_excl() + ' **/waflib.zip'
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               waflib.zip
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     #!/usr/bin/env python
# encoding: latin-1
# Thomas Nagy, 2005-2011

"""
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:

1. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.

3. The name of the author may not be used to endorse or promote products
   derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE AUTHOR "AS IS" AND ANY EXPRESS OR
IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
"""

import os, sys

if sys.hexversion<0x206000f:
	raise ImportError('Python >= 2.6 is required to run waf-zip')

wafzip = os.path.join(os.path.dirname(sys.argv[0]), "waflib.zip")
sys.path.insert(0, wafzip)

from waflib import Context

if __name__ == '__main__':
	from waflib import Scripting
	Scripting.waf_entry_point(os.getcwd(), Context.WAFVERSION, wafzip)

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    DIRC     fu    fu                    J~nxo)`MT 
.gitignore        fu    fu                    /3C LX_r=W .pipelines/Jenkinsfile    fu    fu                    ,3=[7~X	?JPO 	ChangeLog fu    fu                    W^+
Z}xU DEVEL     fu    fu                    :}+gd LICENSE   fu    fu                    ]H`NjA/~K 	README.md fu    fu                    r[j.9[y@!z TODO      fu    fu                    !0q/hZ build_system_kit/README.txt       fu    fu                    sYfn,D\xo
 build_system_kit/extpy/extpy.py   fu    fu                    h1
[W+eQc build_system_kit/extpy/runme.py   fu    fu                     XEe4e`Z*@ !build_system_kit/extpy/wscript.py fu    fu                     !K $build_system_kit/makefile_dumper/a.c      fu    fu                     Xzue.C#u $build_system_kit/makefile_dumper/a.h      fu    fu                     3~@Q}}N3Gt 'build_system_kit/makefile_dumper/main.c   fu    fu                    >cZlVx$VX (build_system_kit/makefile_dumper/wscript  fu    fu                    7S.C)Vs8%B $build_system_kit/noscript/README.txt      fu    fu                     (~ntS>! build_system_kit/noscript/bar.c   fu    fu                     xyi'xK
{ build_system_kit/noscript/bar.h   fu    fu                     `$+(txPr{ &build_system_kit/noscript/create_it.sh    fu    fu                    j9(xa
eH8b #build_system_kit/noscript/dbdlib.py       fu    fu                     0W61d}2 build_system_kit/noscript/foo.c   fu    fu                     KSmp[HGzpcv build_system_kit/noscript/foo.h   fu    fu                     [@^d	J<2r  build_system_kit/noscript/main.c  fu    fu                    S| #build_system_kit/nostate/README.txt       fu    fu                     !K build_system_kit/nostate/a.c      fu    fu                     Xzue.C#u build_system_kit/nostate/a.h      fu    fu                     vp!G%W %build_system_kit/nostate/create_it.sh     fu    fu                    J7Rmtq&KF "build_system_kit/nostate/ebdlib.py        fu    fu                     3~@Q}}N3Gt build_system_kit/nostate/main.c   fu    fu                     "|>Of[T$  build_system_kit/nostate/wscript  fu    fu                    !0kL- $build_system_kit/overview/README.txt      fu    fu                    [,jXIJEsD #build_system_kit/overview/bbdlib.py       fu    fu                     ,tWL*f<.3R build_system_kit/overview/bbit    fu    fu                     ,HG)mgG &build_system_kit/overview/create_it.sh    fu    fu                     ?tF%diA'<v  build_system_kit/overview/main.c  fu    fu                    %IaALiqo "build_system_kit/parser/README.txt        fu    fu                    iFNoG^@YmSC !build_system_kit/parser/cbdlib.py fu    fu                     csA build_system_kit/parser/cbit      fu    fu                     2NJXj 
l $build_system_kit/parser/create_it.sh      fu    fu                     ?tF%diA'<v build_system_kit/parser/main.c    fu    fu                    Yi}?Jvk# 	configure fu    fu                     w^t*P demos/asm/header.h        fu    fu                     <@re*~m0f< demos/asm/main.c  fu    fu          