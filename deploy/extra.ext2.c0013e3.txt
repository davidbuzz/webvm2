on phases.
		Nodes objects that do have a corresponding file or folder are garbage-collected by default.
		This garbage collection is usually required to prevent returning files that do not
		exist anymore. Yet, this may also remove Node objects of files that are yet-to-be built.

		This typically happens when trying to match files in the build directory,
		but there are also cases when files are created in the source directory.
		Run ``waf -v`` to display any warnings, and try consider passing ``remove=False``
		when matching files in the build directory.

		Since ant_glob can traverse both source and build folders, it is a best practice
		to call this method only from the most specific build node::

			def build(bld):
				# traverses the build directory, may need ``remove=False``:
				bld.path.ant_glob('project/dir/**/*.h')
				# better, no accidental build directory traversal:
				bld.path.find_node('project/dir').ant_glob('**/*.h') # best

		In addition, files and folders are listed immediately. When matching files in the
		build folders, consider passing ``generator=True`` so that the generator object
		returned can defer computation to a later stage. For example::

			def build(bld):
				bld(rule='tar xvf ${SRC}', source='arch.tar')
				bld.add_group()
				gen = bld.bldnode.ant_glob("*.h", generator=True, remove=True)
				# files will be listed only after the arch.tar is unpacked
				bld(rule='ls ${SRC}', source=gen, name='XYZ')


		:param incl: ant patterns or list of patterns to include
		:type incl: string or list of strings
		:param excl: ant patterns or list of patterns to exclude
		:type excl: string or list of strings
		:param dir: return folders too (False by default)
		:type dir: bool
		:param src: return files (True by default)
		:type src: bool
		:param maxdepth: maximum depth of recursion
		:type maxdepth: int
		:param ignorecase: ignore case while matching (False by default)
		:type ignorecase: bool
		:param generator: Whether to evaluate the Nodes lazily
		:type generator: bool
		:param remove: remove files/folders that do not exist (True by default)
		:type remove: bool
		:param quiet: disable build directory traversal warnings (verbose mode)
		:type quiet: bool
		:returns: The corresponding Node objects as a list or as a generator object (generator=True)
		:rtype: by default, list of :py:class:`waflib.Node.Node` instances
		"""
		src = kw.get('src', True)
		dir = kw.get('dir')
		excl = kw.get('excl', exclude_regs)
		incl = k and k[0] or kw.get('incl', '**')
		remove = kw.get('remove', True)
		maxdepth = kw.get('maxdepth', 25)
		ignorecase = kw.get('ignorecase', False)
		quiet = kw.get('quiet', False)
		pats = (ant_matcher(incl, ignorecase), ant_matcher(excl, ignorecase))

		if kw.get('generator'):
			return Utils.lazy_generator(self.ant_iter, (ant_sub_matcher, maxdepth, pats, dir, src, remove, quiet))

		it = self.ant_iter(ant_sub_matcher, maxdepth, pats, dir, src, remove, quiet)
		if kw.get('flat'):
			# returns relative paths as a space-delimited string
			# prefer Node objects whenever possible
			return ' '.join(x.path_from(self) for x in it)
		return list(it)

	# ----------------------------------------------------------------------------
	# the methods below require the source/build folders (bld.srcnode/bld.bldnode)

	def is_src(self):
		"""
		Returns True if the node is below the source directory. Note that ``!is_src() ≠ is_bld()``

		:rtype: bool
		"""
		cur = self
		x = self.ctx.srcnode
		y = self.ctx.bldnode
		while cur.parent:
			if cur is y:
				return False
			if cur is x:
				return True
			cur = cur.parent
		return False

	def is_bld(self):
		"""
		Returns True if the node is below the build directory. Note that ``!is_bld() ≠ is_src()``

		:rtype: bool
		"""
		cur = self
		y = self.ctx.bldnode
		while cur.parent:
			if cur is y:
				return True
			cur = cur.parent
		return False

	def get_src(self):
		"""
		Returns the corresponding Node object in the source directory (or self if already
		under the source directory). Use this method only if the purpose is to create
		a Node object (this is common with folders but not with files, see ticket 1937)

		:rtype: :py:class:`waflib.Node.Node`
		"""
		cur = self
		x = self.ctx.srcnode
		y = self.ctx.bldnode
		lst = []
		while cur.parent:
			if cur is y:
				lst.reverse()
				return x.make_node(lst)
			if cur is x:
				return self
			lst.append(cur.name)
			cur = cur.parent
		return self

	def get_bld(self):
		"""
		Return the corresponding Node object in the build directory (or self if already
		under the build directory). Use this method only if the purpose is to create
		a Node object (this is common with folders but not with files, see ticket 1937)

		:rtype: :py:class:`waflib.Node.Node`
		"""
		cur = self
		x = self.ctx.srcnode
		y = self.ctx.bldnode
		lst = []
		while cur.parent:
			if cur is y:
				return self
			if cur is x:
				lst.reverse()
				return self.ctx.bldnode.make_node(lst)
			lst.append(cur.name)
			cur = cur.parent
		# the file is external to the current project, make a fake root in the current build directory
		lst.reverse()
		if lst and Utils.is_win32 and len(lst[0]) == 2 and lst[0].endswith(':'):
			lst[0] = lst[0][0]
		return self.ctx.bldnode.make_node(['__root__'] + lst)

	def find_resource(self, lst):
		"""
		Use this method in the build phase to find source files corresponding to the relative path given.

		First it looks up the Node data structure to find any declared Node object in the build directory.
		If None is found, it then considers the filesystem in the source directory.

		:param lst: relative path
		:type lst: string or list of string
		:returns: the corresponding Node object or None
		:rtype: :py:class:`waflib.Node.Node`
		"""
		if isinstance(lst, str):
			lst = [x for x in Utils.split_path(lst) if x and x != '.']

		node = self.get_bld().search_node(lst)
		if not node:
			node = self.get_src().find_node(lst)
		if node and node.isdir():
			return None
		return node

	def find_or_declare(self, lst):
		"""
		Use this method in the build phase to declare output files which
		are meant to be written in the build directory.

		This method creates the Node object and its parent folder
		as needed.

		:param lst: relative path
		:type lst: string or list of string
		"""
		if isinstance(lst, str) and os.path.isabs(lst):
			node = self.ctx.root.make_node(lst)
		else:
			node = self.get_bld().make_node(lst)
		node.parent.mkdir()
		return node

	def find_dir(self, lst):
		"""
		Searches for a folder on the filesystem (see :py:meth:`waflib.Node.Node.find_node`)

		:param lst: relative path
		:type lst: string or list of string
		:returns: The corresponding Node object or None if there is no such folder
		:rtype: :py:class:`waflib.Node.Node`
		"""
		if isinstance(lst, str):
			lst = [x for x in Utils.split_path(lst) if x and x != '.']

		node = self.find_node(lst)
		if node and not node.isdir():
			return None
		return node

	# helpers for building things
	def change_ext(self, ext, ext_in=None):
		"""
		Declares a build node with a distinct extension; this is uses :py:meth:`waflib.Node.Node.find_or_declare`

		:return: A build node of the same path, but with a different extension
		:rtype: :py:class:`waflib.Node.Node`
		"""
		name = self.name
		if ext_in is None:
			k = name.rfind('.')
			if k >= 0:
				name = name[:k] + ext
			else:
				name = name + ext
		else:
			name = name[:- len(ext_in)] + ext

		return self.parent.find_or_declare([name])

	def bldpath(self):
		"""
		Returns the relative path seen from the build directory ``src/foo.cpp``

		:rtype: string
		"""
		return self.path_from(self.ctx.bldnode)

	def srcpath(self):
		"""
		Returns the relative path seen from the source directory ``../src/foo.cpp``

		:rtype: string
		"""
		return self.path_from(self.ctx.srcnode)

	def relpath(self):
		"""
		If a file in the build directory, returns :py:meth:`waflib.Node.Node.bldpath`,
		else returns :py:meth:`waflib.Node.Node.srcpath`

		:rtype: string
		"""
		cur = self
		x = self.ctx.bldnode
		while cur.parent:
			if cur is x:
				return self.bldpath()
			cur = cur.parent
		return self.srcpath()

	def bld_dir(self):
		"""
		Equivalent to self.parent.bldpath()

		:rtype: string
		"""
		return self.parent.bldpath()

	def h_file(self):
		"""
		See :py:func:`waflib.Utils.h_file`

		:return: a hash representing the file contents
		:rtype: string or bytes
		"""
		return Utils.h_file(self.abspath())

	def get_bld_sig(self):
		"""
		Returns a signature (see :py:meth:`waflib.Node.Node.h_file`) for the purpose
		of build dependency calculation. This method uses a per-context cache.

		:return: a hash representing the object contents
		:rtype: string or bytes
		"""
		# previous behaviour can be set by returning self.ctx.node_sigs[self] when a build node
		try:
			cache = self.ctx.cache_sig
		except AttributeError:
			cache = self.ctx.cache_sig = {}
		try:
			ret = cache[self]
		except KeyError:
			p = self.abspath()
			try:
				ret = cache[self] = self.h_file()
			except EnvironmentError:
				if self.isdir():
					# allow folders as build nodes, do not use the creation time
					st = os.stat(p)
					ret = cache[self] = Utils.h_list([p, st.st_ino, st.st_mode])
					return ret
				raise
		return ret

pickle_lock = Utils.threading.Lock()
"""Lock mandatory for thread-safe node serialization"""

class Nod3(Node):
	"""Mandatory subclass for thread-safe node serialization"""
	pass # do not remove


                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  #!/usr/bin/env python
# encoding: utf-8
# Scott Newton, 2005 (scottn)
# Thomas Nagy, 2006-2018 (ita)

"""
Support for waf command-line options

Provides default and command-line options, as well the command
that reads the ``options`` wscript function.
"""

import os, tempfile, optparse, sys, re
from waflib import Logs, Utils, Context, Errors

options = optparse.Values()
"""
A global dictionary representing user-provided command-line options::

	$ waf --foo=bar
"""

commands = []
"""
List of commands to execute extracted from the command-line. This list
is consumed during the execution by :py:func:`waflib.Scripting.run_commands`.
"""

envvars = []
"""
List of environment variable declarations placed after the Waf executable name.
These are detected by searching for "=" in the remaining arguments.
You probably do not want to use this.
"""

lockfile = os.environ.get('WAFLOCK', '.lock-waf_%s_build' % sys.platform)
"""
Name of the lock file that marks a project as configured
"""

class opt_parser(optparse.OptionParser):
	"""
	Command-line options parser.
	"""
	def __init__(self, ctx, allow_unknown=False):
		optparse.OptionParser.__init__(self, conflict_handler='resolve', add_help_option=False,
			version='%s %s (%s)' % (Context.WAFNAME, Context.WAFVERSION, Context.WAFREVISION))
		self.formatter.width = Logs.get_term_cols()
		self.ctx = ctx
		self.allow_unknown = allow_unknown

	def _process_args(self, largs, rargs, values):
		"""
		Custom _process_args to allow unknown options according to the allow_unknown status
		"""
		while rargs:
			try:
				optparse.OptionParser._process_args(self,largs,rargs,values)
			except (optparse.BadOptionError, optparse.AmbiguousOptionError) as e:
				if self.allow_unknown:
					largs.append(e.opt_str)
				else:
					self.error(str(e))

	def _process_long_opt(self, rargs, values):
		# --custom-option=-ftxyz is interpreted as -f -t... see #2280
		if self.allow_unknown:
			back = [] + rargs
			try:
				optparse.OptionParser._process_long_opt(self, rargs, values)
			except optparse.BadOptionError:
				while rargs:
					rargs.pop()
				rargs.extend(back)
				rargs.pop(0)
				raise
		else:
			optparse.OptionParser._process_long_opt(self, rargs, values)

	def print_usage(self, file=None):
		return self.print_help(file)

	def get_usage(self):
		"""
		Builds the message to print on ``waf --help``

		:rtype: string
		"""
		cmds_str = {}
		for cls in Context.classes:
			if not cls.cmd or cls.cmd == 'options' or cls.cmd.startswith( '_' ):
				continue

			s = cls.__doc__ or ''
			cmds_str[cls.cmd] = s

		if Context.g_module:
			for (k, v) in Context.g_module.__dict__.items():
				if k in ('options', 'init', 'shutdown'):
					continue

				if type(v) is type(Context.create_context):
					if v.__doc__ and not k.startswith('_'):
						cmds_str[k] = v.__doc__

		just = 0
		for k in cmds_str:
			just = max(just, len(k))

		lst = ['  %s: %s' % (k.ljust(just), v) for (k, v) in cmds_str.items()]
		lst.sort()
		ret = '\n'.join(lst)

		return '''%s [commands] [options]

Main commands (example: ./%s build -j4)
%s
''' % (Context.WAFNAME, Context.WAFNAME, ret)


class OptionsContext(Context.Context):
	"""
	Collects custom options from wscript files and parses the command line.
	Sets the global :py:const:`waflib.Options.commands` and :py:const:`waflib.Options.options` values.
	"""
	cmd = 'options'
	fun = 'options'

	def __init__(self, **kw):
		super(OptionsContext, self).__init__(**kw)

		self.parser = opt_parser(self)
		"""Instance of :py:class:`waflib.Options.opt_parser`"""

		self.option_groups = {}

		jobs = self.jobs()
		p = self.add_option
		color = os.environ.get('NOCOLOR', '') and 'no' or 'auto'
		if os.environ.get('CLICOLOR', '') == '0':
			color = 'no'
		elif os.environ.get('CLICOLOR_FORCE', '') == '1':
			color = 'yes'
		p('-c', '--color',    dest='colors',  default=color, action='store', help='whether to use colors (yes/no/auto) [default: auto]', choices=('yes', 'no', 'auto'))
		p('-j', '--jobs',     dest='jobs',    default=jobs,  type='int', help='amount of parallel jobs (%r)' % jobs)
		p('-k', '--keep',     dest='keep',    default=0,     action='count', help='continue despite errors (-kk to try harder)')
		p('-v', '--verbose',  dest='verbose', default=0,     action='count', help='verbosity level -v -vv or -vvv [default: 0]')
		p('--zones',          dest='zones',   default='',    action='store', help='debugging zones (task_gen, deps, tasks, etc)')
		p('--profile',        dest='profile', default=0,     action='store_true', help=optparse.SUPPRESS_HELP)
		p('--pdb',            dest='pdb',     default=0,     action='store_true', help=optparse.SUPPRESS_HELP)
		p('-h', '--help',     dest='whelp',   default=0,     action='store_true', help="show this help message and exit")

		gr = self.add_option_group('Configuration options')
		self.option_groups['configure options'] = gr

		gr.add_option('-o', '--out', action='store', default='', help='build dir for the project', dest='out')
		gr.add_option('-t', '--top', action='store', default='', help='src dir for the project', dest='top')

		gr.add_option('--no-lock-in-run', action='store_true', default=os.environ.get('NO_LOCK_IN_RUN', ''), help=optparse.SUPPRESS_HELP, dest='no_lock_in_run')
		gr.add_option('--no-lock-in-out', action='store_true', default=os.environ.get('NO_LOCK_IN_OUT', ''), help=optparse.SUPPRESS_HELP, dest='no_lock_in_out')
		gr.add_option('--no-lock-in-top', action='store_true', default=os.environ.get('NO_LOCK_IN_TOP', ''), help=optparse.SUPPRESS_HELP, dest='no_lock_in_top')

		default_prefix = getattr(Context.g_module, 'default_prefix', os.environ.get('PREFIX'))
		if not default_prefix:
			if Utils.unversioned_sys_platform() == 'win32':
				d = tempfile.gettempdir()
				default_prefix = d[0].upper() + d[1:]
				# win32 preserves the case, but gettempdir does not
			else:
				default_prefix = '/usr/local/'
		gr.add_option('--prefix', dest='prefix', default=default_prefix, help='installation prefix [default: %r]' % default_prefix)
		gr.add_option('--bindir', dest='bindir', help='bindir')
		gr.add_option('--libdir', dest='libdir', help='libdir')

		gr = self.add_option_group('Build and installation options')
		self.option_groups['build and install options'] = gr
		gr.add_option('-p', '--progress', dest='progress_bar', default=0, action='count', help= '-p: progress bar; -pp: ide output')
		gr.add_option('--targets',        dest='targets', default='', action='store', help='task generators, e.g. "target1,target2"')

		gr = self.add_option_group('Step options')
		self.option_groups['step options'] = gr
		gr.add_option('--files',          dest='files', default='', action='store', help='files to process, by regexp, e.g. "*/main.c,*/test/main.o"')

		default_destdir = os.environ.get('DESTDIR', '')

		gr = self.add_option_group('Installation and uninstallation options')
		self.option_groups['install/uninstall options'] = gr
		gr.add_option('--destdir', help='installation root [default: %r]' % default_destdir, default=default_destdir, dest='destdir')
		gr.add_option('-f', '--force', dest='force', default=False, action='store_true', help='force file installation')
		gr.add_option('--distcheck-args', metavar='ARGS', help='arguments to pass to distcheck', default=None, action='store')

	def jobs(self):
		"""
		Finds the optimal amount of cpu cores to use for parallel jobs.
		At runtime the options can be obtained from :py:const:`waflib.Options.options` ::

			from waflib.Options import options
			njobs = options.jobs

		:return: the amount of cpu cores
		:rtype: int
		"""
		count = int(os.environ.get('JOBS', 0))
		if count < 1:
			if 'NUMBER_OF_PROCESSORS' in os.environ:
				# on Windows, use the NUMBER_OF_PROCESSORS environment variable
				count = int(os.environ.get('NUMBER_OF_PROCESSORS', 1))
			else:
				# on everything else, first try the POSIX sysconf values
				if hasattr(os, 'sysconf_names'):
					if 'SC_NPROCESSORS_ONLN' in os.sysconf_names:
						count = int(os.sysconf('SC_NPROCESSORS_ONLN'))
					elif 'SC_NPROCESSORS_CONF' in os.sysconf_names:
						count = int(os.sysconf('SC_NPROCESSORS_CONF'))
				if not count and os.name not in ('nt', 'java'):
					try:
						tmp = self.cmd_and_log(['sysctl', '-n', 'hw.ncpu'], quiet=0)
					except Errors.WafError:
						pass
					else:
						if re.match('^[0-9]+$', tmp):
							count = int(tmp)
		if count < 1:
			count = 1
		elif count > 1024:
			count = 1024
		return count

	def add_option(self, *k, **kw):
		"""
		Wraps ``optparse.add_option``::

			def options(ctx):
				ctx.add_option('-u', '--use', dest='use', default=False,
					action='store_true', help='a boolean option')

		:rtype: optparse option object
		"""
		return self.parser.add_option(*k, **kw)

	def add_option_group(self, *k, **kw):
		"""
		Wraps ``optparse.add_option_group``::

			def options(ctx):
				gr = ctx.add_option_group('some options')
				gr.add_option('-u', '--use', dest='use', default=False, action='store_true')

		:rtype: optparse option group object
		"""
		try:
			gr = self.option_groups[k[0]]
		except KeyError:
			gr = self.parser.add_option_group(*k, **kw)
		self.option_groups[k[0]] = gr
		return gr

	def get_option_group(self, opt_str):
		"""
		Wraps ``optparse.get_option_group``::

			def options(ctx):
				gr = ctx.get_option_group('configure options')
				gr.add_option('-o', '--out', action='store', default='',
					help='build dir for the project', dest='out')

		:rtype: optparse option group object
		"""
		try:
			return self.option_groups[opt_str]
		except KeyError:
			for group in self.parser.option_groups:
				if group.title == opt_str:
					return group
			return None

	def sanitize_path(self, path, cwd=None):
		if not cwd:
			cwd = Context.launch_dir
		p = os.path.expanduser(path)
		p = os.path.join(cwd, p)
		p = os.path.normpath(p)
		p = os.path.abspath(p)
		return p

	def parse_cmd_args(self, _args=None, cwd=None, allow_unknown=False):
		"""
		Just parse the arguments
		"""
		self.parser.allow_unknown = allow_unknown
		(options, leftover_args) = self.parser.parse_args(args=_args)
		envvars = []
		commands = []
		for arg in leftover_args:
			if '=' in arg:
				envvars.append(arg)
			elif arg != 'options':
				commands.append(arg)

		if options.jobs < 1:
			options.jobs = 1
		for name in 'top out destdir prefix bindir libdir'.split():
			# those paths are usually expanded from Context.launch_dir
			if getattr(options, name, None):
				path = self.sanitize_path(getattr(options, name), cwd)
				setattr(options, name, path)
		return options, commands, envvars

	def init_module_vars(self, arg_options, arg_commands, arg_envvars):
		options.__dict__.clear()
		del commands[:]
		del envvars[:]

		options.__dict__.update(arg_options.__dict__)
		commands.extend(arg_commands)
		envvars.extend(arg_envvars)

		for var in envvars:
			(name, value) = var.split('=', 1)
			os.environ[name.strip()] = value

	def init_logs(self, options, commands, envvars):
		Logs.verbose = options.verbose
		if options.verbose >= 1:
			self.load('errcheck')

		colors = {'yes' : 2, 'auto' : 1, 'no' : 0}[options.colors]
		Logs.enable_colors(colors)

		if options.zones:
			Logs.zones = options.zones.split(',')
			if not Logs.verbose:
				Logs.verbose = 1
		elif Logs.verbose > 0:
			Logs.zones = ['runner']
		if Logs.verbose > 2:
			Logs.zones = ['*']

	def parse_args(self, _args=None):
		"""
		Parses arguments from a list which is not necessarily the command-line.
		Initializes the module variables options, commands and envvars
		If help is requested, prints it and exit the application

		:param _args: arguments
		:type _args: list of strings
		"""
		options, commands, envvars = self.parse_cmd_args(_args)
		self.init_logs(options, commands, envvars)
		self.init_module_vars(options, commands, envvars)

	def execute(self):
		"""
		See :py:func:`waflib.Context.Context.execute`
		"""
		super(OptionsContext, self).execute()
		self.parse_args()
		Utils.alloc_process_pool(options.jobs)
                                                                                                                                                                                                                                                                                                                                      #!/usr/bin/env python
# encoding: utf-8
# Thomas Nagy, 2005-2018 (ita)

"""
Runner.py: Task scheduling and execution
"""

import heapq, traceback
try:
	from queue import Queue, PriorityQueue
except ImportError:
	from Queue import Queue
	try:
		from Queue import PriorityQueue
	except ImportError:
		class PriorityQueue(Queue):
			def _init(self, maxsize):
				self.maxsize = maxsize
				self.queue = []
			def _put(self, item):
				heapq.heappush(self.queue, item)
			def _get(self):
				return heapq.heappop(self.queue)

from waflib import Utils, Task, Errors, Logs

GAP = 5
"""
Wait for at least ``GAP * njobs`` before trying to enqueue more tasks to run
"""

class PriorityTasks(object):
	def __init__(self):
		self.lst = []
	def __len__(self):
		return len(self.lst)
	def __iter__(self):
		return iter(self.lst)
	def __str__(self):
		return 'PriorityTasks: [%s]' % '\n  '.join(str(x) for x in self.lst)
	def clear(self):
		self.lst = []
	def append(self, task):
		heapq.heappush(self.lst, task)
	def appendleft(self, task):
		"Deprecated, do not use"
		heapq.heappush(self.lst, task)
	def pop(self):
		return heapq.heappop(self.lst)
	def extend(self, lst):
		if self.lst:
			for x in lst:
				self.append(x)
		else:
			if isinstance(lst, list):
				self.lst = lst
				heapq.heapify(lst)
			else:
				self.lst = lst.lst

class Consumer(Utils.threading.Thread):
	"""
	Daemon thread object that executes a task. It shares a semaphore with
	the coordinator :py:class:`waflib.Runner.Spawner`. There is one
	instance per task to consume.
	"""
	def __init__(self, spawner, task):
		Utils.threading.Thread.__init__(self)
		self.task = task
		"""Task to execute"""
		self.spawner = spawner
		"""Coordinator object"""
		self.daemon = True
		self.start()
	def run(self):
		"""
		Processes a single task
		"""
		try:
			if not self.spawner.master.stop:
				self.spawner.master.process_task(self.task)
		finally:
			self.spawner.sem.release()
			self.spawner.master.out.put(self.task)
			self.task = None
			self.spawner = None

class Spawner(Utils.threading.Thread):
	"""
	Daemon thread that consumes tasks from :py:class:`waflib.Runner.Parallel` producer and
	spawns a consuming thread :py:class:`waflib.Runner.Consumer` for each
	:py:class:`waflib.Task.Task` instance.
	"""
	def __init__(self, master):
		Utils.threading.Thread.__init__(self)
		self.master = master
		""":py:class:`waflib.Runner.Parallel` producer instance"""
		self.sem = Utils.threading.Semaphore(master.numjobs)
		"""Bounded semaphore that prevents spawning more than *n* concurrent consumers"""
		self.daemon = True
		self.start()
	def run(self):
		"""
		Spawns new consumers to execute tasks by delegating to :py:meth:`waflib.Runner.Spawner.loop`
		"""
		try:
			self.loop()
		except Exception:
			# Python 2 prints unnecessary messages when shutting down
			# we also want to stop the thread properly
			pass
	def loop(self):
		"""
		Consumes task objects from the producer; ends when the producer has no more
		task to provide.
		"""
		master = self.master
		while 1:
			task = master.ready.get()
			self.sem.acquire()
			if not master.stop:
				task.log_display(task.generator.bld)
			Consumer(self, task)

class Parallel(object):
	"""
	Schedule the tasks obtained from the build context for execution.
	"""
	def __init__(self, bld, j=2):
		"""
		The initialization requires a build context reference
		for computing the total number of jobs.
		"""

		self.numjobs = j
		"""
		Amount of parallel consumers to use
		"""

		self.bld = bld
		"""
		Instance of :py:class:`waflib.Build.BuildContext`
		"""

		self.outstanding = PriorityTasks()
		"""Heap of :py:class:`waflib.Task.Task` that may be ready to be executed"""

		self.postponed = PriorityTasks()
		"""Heap of :py:class:`waflib.Task.Task` which are not ready to run for non-DAG reasons"""

		self.incomplete = set()
		"""List of :py:class:`waflib.Task.Task` waiting for dependent tasks to complete (DAG)"""

		self.ready = PriorityQueue(0)
		"""List of :py:class:`waflib.Task.Task` ready to be executed by consumers"""

		self.out = Queue(0)
		"""List of :py:class:`waflib.Task.Task` returned by the task consumers"""

		self.count = 0
		"""Amount of tasks that may be processed by :py:class:`waflib.Runner.TaskConsumer`"""

		self.processed = 0
		"""Amount of tasks processed"""

		self.stop = False
		"""Error flag to stop the build"""

		self.error = []
		"""Tasks that could not be executed"""

		self.biter = None
		"""Task iterator which must give groups of parallelizable tasks when calling ``next()``"""

		self.dirty = False
		"""
		Flag that indicates that the build cache must be saved when a task was executed
		(calls :py:meth:`waflib.Build.BuildContext.store`)"""

		self.revdeps = Utils.defaultdict(set)
		"""
		The reverse dependency graph of dependencies obtained from Task.run_after
		"""

		self.spawner = None
		"""
		Coordinating daemon thread that spawns thread consumers
		"""
		if self.numjobs > 1:
			self.spawner = Spawner(self)

	def get_next_task(self):
		"""
		Obtains the next Task instance to run

		:rtype: :py:class:`waflib.Task.Task`
		"""
		if not self.outstanding:
			return None
		return self.outstanding.pop()

	def postpone(self, tsk):
		"""
		Adds the task to the list :py:attr:`waflib.Runner.Parallel.postponed`.
		The order is scrambled so as to consume as many tasks in parallel as possible.

		:param tsk: task instance
		:type tsk: :py:class:`waflib.Task.Task`
		"""
		self.postponed.append(tsk)

	def refill_task_list(self):
		"""
		Pulls a next group of tasks to execute in :py:attr:`waflib.Runner.Parallel.outstanding`.
		Ensures that all tasks in the current build group are complete before processing the next one.
		"""
		while self.count > self.numjobs * GAP:
			self.get_out()

		while not self.outstanding:
			if self.count:
				self.get_out()
				if self.outstanding:
					break
			elif self.postponed:
				try:
					cond = self.deadlock == self.processed
				except AttributeError:
					pass
				else:
					if cond:
						# The most common reason is conflicting build order declaration
						# for example: "X run_after Y" and "Y run_after X"
						# Another can be changing "run_after" dependencies while the build is running
						# for example: updating "tsk.run_after" in the "runnable_status" method
						lst = []
						for tsk in self.postponed:
							deps = [id(x) for x in tsk.run_after if not x.hasrun]
							lst.append('%s\t-> %r' % (repr(tsk), deps))
							if not deps:
								lst.append('\n  task %r dependencies are done, check its *runnable_status*?' % id(tsk))
						raise Errors.WafError('Deadlock detected: check the task build order%s' % ''.join(lst))
				self.deadlock = self.processed

			if self.postponed:
				self.outstanding.extend(self.postponed)
				self.postponed.clear()
			elif not self.count:
				if self.incomplete:
					for x in self.incomplete:
						for k in x.run_after:
							if not k.hasrun:
								break
						else:
							# dependency added after the build started without updating revdeps
							self.incomplete.remove(x)
							self.outstanding.append(x)
							break
					else:
						if self.stop or self.error:
							break
						raise Errors.WafError('Broken revdeps detected on %r' % self.incomplete)
				else:
					tasks = next(self.biter)
					ready, waiting = self.prio_and_split(tasks)
					self.outstanding.extend(ready)
					self.incomplete.update(waiting)
					self.total = self.bld.total()
					break

	def add_more_tasks(self, tsk):
		"""
		If a task provides :py:attr:`waflib.Task.Task.more_tasks`, then the tasks contained
		in that list are added to the current build and will be processed before the next build group.

		The priorities for dependent tasks are not re-calculated globally

		:param tsk: task instance
		:type tsk: :py:attr:`waflib.Task.Task`
		"""
		if getattr(tsk, 'more_tasks', None):
			more = set(tsk.more_tasks)
			groups_done = set()
			def iteri(a, b):
				for x in a:
					yield x
				for x in b:
					yield x

			# Update the dependency tree
			# this assumes that task.run_after values were updated
			for x in iteri(self.outstanding, self.incomplete):
				for k in x.run_after:
					if isinstance(k, Task.TaskGroup):
						if k not in groups_done:
							groups_done.add(k)
							for j in k.prev & more:
								self.revdeps[j].add(k)
					elif k in more:
						self.revdeps[k].add(x)

			ready, waiting = self.prio_and_split(tsk.more_tasks)
			self.outstanding.extend(ready)
			self.incomplete.update(waiting)
			self.total += len(tsk.more_tasks)

	def mark_finished(self, tsk):
		def try_unfreeze(x):
			# DAG ancestors are likely to be in the incomplete set
			# This assumes that the run_after contents have not changed
			# after the build starts, else a deadlock may occur
			if x in self.incomplete:
				# TODO remove dependencies to free some memory?
				# x.run_after.remove(tsk)
				for k in x.run_after:
					if not k.hasrun:
						break
				else:
					self.incomplete.remove(x)
					self.outstanding.append(x)

		if tsk in self.revdeps:
			for x in self.revdeps[tsk]:
				if isinstance(x, Task.TaskGroup):
					x.prev.remove(tsk)
					if not x.prev:
						for k in x.next:
							# TODO necessary optimization?
							k.run_after.remove(x)
							try_unfreeze(k)
						# TODO necessary optimization?
						x.next = []
				else:
					try_unfreeze(x)
			del self.revdeps[tsk]

		if hasattr(tsk, 'semaphore'):
			sem = tsk.semaphore
			try:
				sem.release(tsk)
			except KeyError:
				# TODO
				pass
			else:
				while sem.waiting and not sem.is_locked():
					# take a frozen task, make it ready to run
					x = sem.waiting.pop()
					self._add_task(x)

	def get_out(self):
		"""
		Waits for a Task that task consumers add to :py:attr:`waflib.Runner.Parallel.out` after execution.
		Adds more Tasks if necessary through :py:attr:`waflib.Runner.Parallel.add_more_tasks`.

		:rtype: :py:attr:`waflib.Task.Task`
		"""
		tsk = self.out.get()
		if not self.stop:
			self.add_more_tasks(tsk)
		self.mark_finished(tsk)

		self.count -= 1
		self.dirty = True
		return tsk

	def add_task(self, tsk):
		"""
		Enqueue a Task to :py:attr:`waflib.Runner.Parallel.ready` so that consumers can run them.

		:param tsk: task instance
		:type tsk: :py:attr:`waflib.Task.Task`
		"""
		# TODO change in waf 2.1
		self.ready.put(tsk)

	def _add_task(self, tsk):
		if hasattr(tsk, 'semaphore'):
			sem = tsk.semaphore
			try:
				sem.acquire(tsk)
			except IndexError:
				sem.waiting.add(tsk)
				return

		self.count += 1
		self.processed += 1
		if self.numjobs == 1:
			tsk.log_display(tsk.generator.bld)
			try:
				self.process_task(tsk)
			finally:
				self.out.put(tsk)
		else:
			self.add_task(tsk)

	def process_task(self, tsk):
		"""
		Processes a task and attempts to stop the build in case of errors
		"""
		tsk.process()
		if tsk.hasrun != Task.SUCCESS:
			self.error_handler(tsk)

	def skip(self, tsk):
		"""
		Mark a task as skipped/up-to-date
		"""
		tsk.hasrun = Task.SKIPPED
		self.mark_finished(tsk)

	def cancel(self, tsk):
		"""
		Mark a task as failed because of unsatisfiable dependencies
		"""
		tsk.hasrun = Task.CANCELED
		self.mark_finished(tsk)

	def error_handler(self, tsk):
		"""
		Called when a task cannot be executed. The flag :py:attr:`waflib.Runner.Parallel.stop` is set,
		unless the build is executed with::

			$ waf build -k

		:param tsk: task instance
		:type tsk: :py:attr:`waflib.Task.Task`
		"""
		if not self.bld.keep:
			self.stop = True
		self.error.append(tsk)

	def task_status(self, tsk):
		"""
		Obtains the task status to decide whether to run it immediately or not.

		:return: the exit status, for example :py:attr:`waflib.Task.ASK_LATER`
		:rtype: integer
		"""
		try:
			return tsk.runnable_status()
		except Exception:
			self.processed += 1
			tsk.err_msg = traceback.format_exc()
			if not self.stop and self.bld.keep:
				self.skip(tsk)
				if self.bld.keep == 1:
					# if -k stop on the first exception, if -kk try to go as far as possible
					if Logs.verbose > 1 or not self.error:
						self.error.append(tsk)
					self.stop = True
				else:
					if Logs.verbose > 1:
						self.error.append(tsk)
				return Task.EXCEPTION

			tsk.hasrun = Task.EXCEPTION
			self.error_handler(tsk)

			return Task.EXCEPTION

	def start(self):
		"""
		Obtains Task instances from the BuildContext instance and adds the ones that need to be executed to
		:py:class:`waflib.Runner.Parallel.ready` so that the :py:class:`waflib.Runner.Spawner` consumer thread
		has them executed. Obtains the executed Tasks back from :py:class:`waflib.Runner.Parallel.out`
		and marks the build as failed by setting the ``stop`` flag.
		If only one job is used, then executes the tasks one by one, without consumers.
		"""
		self.total = self.bld.total()

		while not self.stop:

			self.refill_task_list()

			# consider the next task
			tsk = self.get_next_task()
			if not tsk:
				if self.count:
					# tasks may add new ones after they are run
					continue
				else:
					# no tasks to run, no tasks running, time to exit
					break

			if tsk.hasrun:
				# if the task is marked as "run", just skip it
				self.processed += 1
				continue

			if self.stop: # stop immediately after a failure is detected
				break

			st = self.task_status(tsk)
			if st == Task.RUN_ME:
				self._add_task(tsk)
			elif st == Task.ASK_LATER:
				self.postpone(tsk)
			elif st == Task.SKIP_ME:
				self.processed += 1
				self.skip(tsk)
				self.add_more_tasks(tsk)
			elif st == Task.CANCEL_ME:
				# A dependency problem has occurred, and the
				# build is most likely run with `waf -k`
				if Logs.verbose > 1:
					self.error.append(tsk)
				self.processed += 1
				self.cancel(tsk)

		# self.count represents the tasks that have been made available to the consumer threads
		# collect all the tasks after an error else the message may be incomplete
		while self.error and self.count:
			self.get_out()

		self.ready.put(None)
		if not self.stop:
			assert not self.count
			assert not self.postponed
			assert not self.incomplete

	def prio_and_split(self, tasks):
		"""
		Label input tasks with priority values, and return a pair containing
		the tasks that are ready to run and the tasks that are necessarily
		waiting for other tasks to complete.

		The priority system is really meant as an optional layer for optimization:
		dependency cycles are found quickly, and builds should be more efficient.
		A high priority number means that a task is processed first.

		This method can be overridden to disable the priority system::

			def prio_and_split(self, tasks):
				return tasks, []

		:return: A pair of task lists
		:rtype: tuple
		"""
		# to disable:
		#return tasks, []
		for x in tasks:
			x.visited = 0

		reverse = self.revdeps

		groups_done = set()
		for x in tasks:
			for k in x.run_after:
				if isinstance(k, Task.TaskGroup):
					if k not in groups_done:
						groups_done.add(k)
						for j in k.prev:
							reverse[j].add(k)
				else:
					reverse[k].add(x)

		# the priority number is not the tree depth
		def visit(n):
			if isinstance(n, Task.TaskGroup):
				return sum(visit(k) for k in n.next)

			if n.visited == 0:
				n.visited = 1

				if n in reverse:
					rev = reverse[n]
					n.prio_order = n.tree_weight + len(rev) + sum(visit(k) for k in rev)
				else:
					n.prio_order = n.tree_weight

				n.visited = 2
			elif n.visited == 1:
				raise Errors.WafError('Dependency cycle found!')
			return n.prio_order

		for x in tasks:
			if x.visited != 0:
				# must visit all to detect cycles
				continue
			try:
				visit(x)
			except Errors.WafError:
				self.debug_cycles(tasks, reverse)

		ready = []
		waiting = []
		for x in tasks:
			for k in x.run_after:
				if not k.hasrun:
					waiting.append(x)
					break
			else:
				ready.append(x)
		return (ready, waiting)

	def debug_cycles(self, tasks, reverse):
		tmp = {}
		for x in tasks:
			tmp[x] = 0

		def visit(n, acc):
			if isinstance(n, Task.TaskGroup):
				for k in n.next:
					visit(k, acc)
				return
			if tmp[n] == 0:
				tmp[n] = 1
				for k in reverse.get(n, []):
					visit(k, [n] + acc)
				tmp[n] = 2
			elif tmp[n] == 1:
				lst = []
				for tsk in acc:
					lst.append(repr(tsk))
					if tsk is n:
						# exclude prior nodes, we want the minimum cycle
						break
				raise Errors.WafError('Task dependency cycle in "run_after" constraints: %s' % ''.join(lst))
		for x in tasks:
			visit(x, [])

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      #!/usr/bin/env python
# encoding: utf-8
# Thomas Nagy, 2005-2018 (ita)

"Module called for configuring, compiling and installing targets"

from __future__ import with_statement

import os, shlex, shutil, traceback, errno, sys, stat
from waflib import Utils, Configure, Logs, Options, ConfigSet, Context, Errors, Build, Node

build_dir_override = None

no_climb_commands = ['configure']

default_cmd = "build"

def waf_entry_point(current_directory, version, wafdir):
	"""
	This is the main entry point, all Waf execution starts here.

	:param current_directory: absolute path representing the current directory
	:type current_directory: string
	:param version: version number
	:type version: string
	:param wafdir: absolute path representing the directory of the waf library
	:type wafdir: string
	"""
	Logs.init_log()

	if Context.WAFVERSION != version:
		Logs.error('Waf script %r and library %r do not match (directory %r)', version, Context.WAFVERSION, wafdir)
		sys.exit(1)

	# Store current directory before any chdir
	Context.waf_dir = wafdir
	Context.run_dir = Context.launch_dir = current_directory
	start_dir = current_directory
	no_climb = os.environ.get('NOCLIMB')

	if len(sys.argv) > 1:
		# os.path.join handles absolute paths
		# if sys.argv[1] is not an absolute path, then it is relative to the current working directory
		potential_wscript = os.path.join(current_directory, sys.argv[1])
		if os.path.basename(potential_wscript) == Context.WSCRIPT_FILE and os.path.isfile(potential_wscript):
			# need to explicitly normalize the path, as it may contain extra '/.'
			path = os.path.normpath(os.path.dirname(potential_wscript))
			start_dir = os.path.abspath(path)
			no_climb = True
			sys.argv.pop(1)

	ctx = Context.create_context('options')
	(options, commands, env) = ctx.parse_cmd_args(allow_unknown=True)
	if options.top:
		start_dir = Context.run_dir = Context.top_dir = options.top
		no_climb = True
	if options.out:
		Context.out_dir = options.out

	# if 'configure' is in the commands, do not search any further
	if not no_climb:
		for k in no_climb_commands:
			for y in commands:
				if y.startswith(k):
					no_climb = True
					break

	# try to find a lock file (if the project was configured)
	# at the same time, store the first wscript file seen
	cur = start_dir
	while cur:
		try:
			lst = os.listdir(cur)
		except OSError:
			lst = []
			Logs.error('Directory %r is unreadable!', cur)
		if Options.lockfile in lst:
			env = ConfigSet.ConfigSet()
			try:
				env.load(os.path.join(cur, Options.lockfile))
				ino = os.stat(cur)[stat.ST_INO]
			except EnvironmentError:
				pass
			else:
				# check if the folder was not moved
				for x in (env.run_dir, env.top_dir, env.out_dir):
					if not x:
						continue
					if Utils.is_win32:
						if cur == x:
							load = True
							break
					else:
						# if the filesystem features symlinks, compare the inode numbers
						try:
							ino2 = os.stat(x)[stat.ST_INO]
						except OSError:
							pass
						else:
							if ino == ino2:
								load = True
								break
				else:
					Logs.warn('invalid lock file in %s', cur)
					load = False

				if load:
					Context.run_dir = env.run_dir
					Context.top_dir = env.top_dir
					Context.out_dir = env.out_dir
					break

		if not Context.run_dir:
			if Context.WSCRIPT_FILE in lst:
				Context.run_dir = cur

		next = os.path.dirname(cur)
		if next == cur:
			break
		cur = next

		if no_climb:
			break

	wscript = os.path.normpath(os.path.join(Context.run_dir, Context.WSCRIPT_FILE))
	if not os.path.exists(wscript):
		if options.whelp:
			Logs.warn('These are the generic options (no wscript/project found)')
			ctx.parser.print_help()
			sys.exit(0)
		Logs.error('Waf: Run from a folder containing a %r file (or try -h for the generic options)', Context.WSCRIPT_FILE)
		sys.exit(1)

	try:
		os.chdir(Context.run_dir)
	except OSError:
		Logs.error('Waf: The folder %r is unreadable', Context.run_dir)
		sys.exit(1)

	try:
		set_main_module(wscript)
	except Errors.WafError as e:
		Logs.pprint('RED', e.verbose_msg)
		Logs.error(str(e))
		sys.exit(1)
	except Exception as e:
		Logs.error('Waf: The wscript in %r is unreadable', Context.run_dir)
		traceback.print_exc(file=sys.stdout)
		sys.exit(2)

	if options.profile:
		import cProfile, pstats
		cProfile.runctx('from waflib import Scripting; Scripting.run_commands()', {}, {}, 'profi.txt')
		p = pstats.Stats('profi.txt')
		p.sort_stats('time').print_stats(75) # or 'cumulative'
	else:
		try:
			try:
				run_commands()
			except:
				if options.pdb:
					import pdb
					type, value, tb = sys.exc_info()
					traceback.print_exc()
					pdb.post_mortem(tb)
				else:
					raise
		except Errors.WafError as e:
			if Logs.verbose > 1:
				Logs.pprint('RED', e.verbose_msg)
			Logs.error(e.msg)
			sys.exit(1)
		except SystemExit:
			raise
		except Exception as e:
			traceback.print_exc(file=sys.stdout)
			sys.exit(2)
		except KeyboardInterrupt:
			Logs.pprint('RED', 'Interrupted')
			sys.exit(68)

def set_main_module(file_path):
	"""
	Read the main wscript file into :py:const:`waflib.Context.Context.g_module` and
	bind default functions such as ``init``, ``dist``, ``distclean`` if not defined.
	Called by :py:func:`waflib.Scripting.waf_entry_point` during the initialization.

	:param file_path: absolute path representing the top-level wscript file
	:type file_path: string
	"""
	Context.g_module = Context.load_module(file_path)
	Context.g_module.root_path = file_path

	# note: to register the module globally, use the following:
	# sys.modules['wscript_main'] = g_module

	def set_def(obj):
		name = obj.__name__
		if not name in Context.g_module.__dict__:
			setattr(Context.g_module, name, obj)
	for k in (dist, distclean, distcheck):
		set_def(k)
	# add dummy init and shutdown functions if they're not defined
	if not 'init' in Context.g_module.__dict__:
		Context.g_module.init = Utils.nada
	if not 'shutdown' in Context.g_module.__dict__:
		Context.g_module.shutdown = Utils.nada
	if not 'options' in Context.g_module.__dict__:
		Context.g_module.options = Utils.nada

def parse_options():
	"""
	Parses the command-line options and initialize the logging system.
	Called by :py:func:`waflib.Scripting.waf_entry_point` during the initialization.
	"""
	ctx = Context.create_context('options')
	ctx.execute()
	if not Options.commands:
		if isinstance(default_cmd, list):
			Options.commands.extend(default_cmd)
		else:
			Options.commands.append(default_cmd)
	if Options.options.whelp:
		ctx.parser.print_help()
		sys.exit(0)

def run_command(cmd_name):
	"""
	Executes a single Waf command. Called by :py:func:`waflib.Scripting.run_commands`.

	:param cmd_name: command to execute, like ``build``
	:type cmd_name: string
	"""
	ctx = Context.create_context(cmd_name)
	ctx.log_timer = Utils.Timer()
	ctx.options = Options.options # provided for convenience
	ctx.cmd = cmd_name
	try:
		ctx.execute()
	finally:
		# Issue 1374
		ctx.finalize()
	return ctx

def run_commands():
	"""
	Execute the Waf commands that were given on the command-line, and the other options
	Called by :py:func:`waflib.Scripting.waf_entry_point` during the initialization, and executed
	after :py:func:`waflib.Scripting.parse_options`.
	"""
	parse_options()
	run_command('init')
	while Options.commands:
		cmd_name = Options.commands.pop(0)
		ctx = run_command(cmd_name)
		Logs.info('%r finished successfully (%s)', cmd_name, ctx.log_timer)
	run_command('shutdown')

###########################################################################################

def distclean_dir(dirname):
	"""
	Distclean function called in the particular case when::

		top == out

	:param dirname: absolute path of the folder to clean
	:type dirname: string
	"""
	for (root, dirs, files) in os.walk(dirname):
		for f in files:
			if f.endswith(('.o', '.moc', '.exe')):
				fname = os.path.join(root, f)
				try:
					os.remove(fname)
				except OSError:
					Logs.warn('Could not remove %r', fname)

	for x in (Context.DBFILE, 'config.log'):
		try:
			os.remove(x)
		except OSError:
			pass

	try:
		shutil.rmtree(Build.CACHE_DIR)
	except OSError:
		pass

def distclean(ctx):
	'''removes build folders and data'''

	def remove_and_log(k, fun):
		try:
			fun(k)
		except EnvironmentError as e:
			if e.errno != errno.ENOENT:
				Logs.warn('Could not remove %r', k)

	# remove waf cache folders on the top-level
	if not Options.commands:
		for k in os.listdir('.'):
			for x in '.waf-2 waf-2 .waf3-2 waf3-2'.split():
				if k.startswith(x):
					remove_and_log(k, shutil.rmtree)

	# remove a build folder, if any
	cur = '.'
	if os.environ.get('NO_LOCK_IN_TOP') or ctx.options.no_lock_in_top:
		cur = ctx.options.out

	try:
		lst = os.listdir(cur)
	except OSError:
		Logs.warn('Could not read %r', cur)
		return

	if Options.lockfile in lst:
		f = os.path.join(cur, Options.lockfile)
		try:
			env = ConfigSet.ConfigSet(f)
		except EnvironmentError:
			Logs.warn('Could not read %r', f)
			return

		if not env.out_dir or not env.top_dir:
			Logs.warn('Invalid lock file %r', f)
			return

		if env.out_dir == env.top_dir:
			distclean_dir(env.out_dir)
		else:
			remove_and_log(env.out_dir, shutil.rmtree)

		env_dirs = [env.out_dir]
		if not (os.environ.get('NO_LOCK_IN_TOP') or ctx.options.no_lock_in_top):
			env_dirs.append(env.top_dir)
		if not (os.environ.get('NO_LOCK_IN_RUN') or ctx.options.no_lock_in_run):
			env_dirs.append(env.run_dir)
		for k in env_dirs:
			p = os.path.join(k, Options.lockfile)
			remove_and_log(p, os.remove)

class Dist(Context.Context):
	'''creates an archive containing the project source code'''
	cmd = 'dist'
	fun = 'dist'
	algo = 'tar.bz2'
	ext_algo = {}

	def execute(self):
		"""
		See :py:func:`waflib.Context.Context.execute`
		"""
		self.recurse([os.path.dirname(Context.g_module.root_path)])
		self.archive()

	def archive(self):
		"""
		Creates the source archive.
		"""
		import tarfile

		arch_name = self.get_arch_name()

		try:
			self.base_path
		except AttributeError:
			self.base_path = self.path

		node = self.base_path.make_node(arch_name)
		try:
			node.delete()
		except OSError:
			pass

		files = self.get_files()

		if self.algo.startswith('tar.'):
			tar = tarfile.open(node.abspath(), 'w:' + self.algo.replace('tar.', ''))

			for x in files:
				self.add_tar_file(x, tar)
			tar.close()
		elif self.algo == 'zip':
			import zipfile
			zip = zipfile.ZipFile(node.abspath(), 'w', compression=zipfile.ZIP_DEFLATED)

			for x in files:
				archive_name = self.get_base_name() + '/' + x.path_from(self.base_path)
				if os.environ.get('SOURCE_DATE_EPOCH'):
					# TODO: parse that timestamp
					zip.writestr(zipfile.ZipInfo(archive_name), x.read(), zipfile.ZIP_DEFLATED)
				else:
					zip.write(x.abspath(), archive_name, zipfile.ZIP_DEFLATED)
			zip.close()
		else:
			self.fatal('Valid algo types are tar.bz2, tar.gz, tar.xz or zip')

		try:
			from hashlib import sha256
		except ImportError:
			digest = ''
		else:
			digest = ' (sha256=%r)' % sha256(node.read(flags='rb')).hexdigest()

		Logs.info('New archive created: %s%s', self.arch_name, digest)

	def get_tar_path(self, node):
		"""
		Return the path to use for a node in the tar archive, the purpose of this
		is to let subclases resolve symbolic links or to change file names

		:return: absolute path
		:rtype: string
		"""
		return node.abspath()

	def add_tar_file(self, x, tar):
		"""
		Adds a file to the tar archive. Symlinks are not verified.

		:param x: file path
		:param tar: tar file object
		"""
		p = self.get_tar_path(x)
		tinfo = tar.gettarinfo(name=p, arcname=self.get_tar_prefix() + '/' + x.path_from(self.base_path))
		tinfo.uid   = 0
		tinfo.gid   = 0
		tinfo.uname = 'root'
		tinfo.gname = 'root'
		if os.environ.get('SOURCE_DATE_EPOCH'):
			tinfo.mtime = int(os.environ.get('SOURCE_DATE_EPOCH'))

		if os.path.isfile(p):
			with open(p, 'rb') as f:
				tar.addfile(tinfo, fileobj=f)
		else:
			tar.addfile(tinfo)

	def get_tar_prefix(self):
		"""
		Returns the base path for files added into the archive tar file

		:rtype: string
		"""
		try:
			return self.tar_prefix
		except AttributeError:
			return self.get_base_name()

	def get_arch_name(self):
		"""
		Returns the archive file name.
		Set the attribute *arch_name* to change the default value::

			def dist(ctx):
				ctx.arch_name = 'ctx.tar.bz2'

		:rtype: string
		"""
		try:
			self.arch_name
		except AttributeError:
			self.arch_name = self.get_base_name() + '.' + self.ext_algo.get(self.algo, self.algo)
		return self.arch_name

	def get_base_name(self):
		"""
		Returns the default name of the main directory in the archive, which is set to *appname-version*.
		Set the attribute *base_name* to change the default value::

			def dist(ctx):
				ctx.base_name = 'files'

		:rtype: string
		"""
		try:
			self.base_name
		except AttributeError:
			appname = getattr(Context.g_module, Context.APPNAME, 'noname')
			version = getattr(Context.g_module, Context.VERSION, '1.0')
			self.base_name = appname + '-' + version
		return self.base_name

	def get_excl(self):
		"""
		Returns the patterns to exclude for finding the files in the top-level directory.
		Set the attribute *excl* to change the default value::

			def dist(ctx):
				ctx.excl = 'build **/*.o **/*.class'

		:rtype: string
		"""
		try:
			return self.excl
		except AttributeError:
			self.excl = Node.exclude_regs + ' **/waf-2.* **/.waf-2.* **/waf3-2.* **/.waf3-2.* **/*~ **/*.rej **/*.orig **/*.pyc **/*.pyo **/*.bak **/*.swp **/.lock-w*'
			if Context.out_dir:
				nd = self.root.find_node(Context.out_dir)
				if nd:
					self.excl += ' ' + nd.path_from(self.base_path)
			return self.excl

	def get_files(self):
		"""
		Files to package are searched automatically by :py:func:`waflib.Node.Node.ant_glob`.
		Set *files* to prevent this behaviour::

			def dist(ctx):
				ctx.files = ctx.path.find_node('wscript')

		Files are also searched from the directory 'base_path', to change it, set::

			def dist(ctx):
				ctx.base_path = path

		:rtype: list of :py:class:`waflib.Node.Node`
		"""
		try:
			files = self.files
		except AttributeError:
			files = self.base_path.ant_glob('**/*', excl=self.get_excl())
		return files

def dist(ctx):
	'''makes a tarball for redistributing the sources'''
	pass

class DistCheck(Dist):
	"""creates an archive with dist, then tries to build it"""
	fun = 'distcheck'
	cmd = 'distcheck'

	def execute(self):
		"""
		See :py:func:`waflib.Context.Context.execute`
		"""
		self.recurse([os.path.dirname(Context.g_module.root_path)])
		self.archive()
		self.check()

	def make_distcheck_cmd(self, tmpdir):
		cfg = []
		if Options.options.distcheck_args:
			cfg = shlex.split(Options.options.distcheck_args)
		else:
			cfg = [x for x in sys.argv if x.startswith('-')]
		cmd = [sys.executable, sys.argv[0], 'configure', 'build', 'install', 'uninstall', '--destdir=' + tmpdir] + cfg
		return cmd

	def check(self):
		"""
		Creates the archive, uncompresses it and tries to build the project
		"""
		import tempfile, tarfile

		with tarfile.open(self.get_arch_name()) as t:
			for x in t:
				t.extract(x)

		instdir = tempfile.mkdtemp('.inst', self.get_base_name())
		cmd = self.make_distcheck_cmd(instdir)
		ret = Utils.subprocess.Popen(cmd, cwd=self.get_base_name()).wait()
		if ret:
			raise Errors.WafError('distcheck failed with code %r' % ret)

		if os.path.exists(instdir):
			raise Errors.WafError('distcheck succeeded, but files were left in %s' % instdir)

		shutil.rmtree(self.get_base_name())


def distcheck(ctx):
	'''checks if the project compiles (tarball from 'dist')'''
	pass

def autoconfigure(execute_method):
	"""
	Decorator that enables context commands to run *configure* as needed.
	"""
	def execute(self):
		"""
		Wraps :py:func:`waflib.Context.Context.execute` on the context class
		"""
		if not Configure.autoconfig:
			return execute_method(self)

		env = ConfigSet.ConfigSet()
		do_config = False
		try:
			env.load(os.path.join(Context.top_dir, Options.lockfile))
		except EnvironmentError:
			Logs.warn('Configuring the project')
			do_config = True
		else:
			if env.run_dir != Context.run_dir:
				do_config = True
			else:
				h = 0
				for f in env.files:
					try:
						h = Utils.h_list((h, Utils.readf(f, 'rb')))
					except EnvironmentError:
						do_config = True
						break
				else:
					do_config = h != env.hash

		if do_config:
			cmd = env.config_cmd or 'configure'
			if Configure.autoconfig == 'clobber':
				tmp = Options.options.__dict__
				launch_dir_tmp = Context.launch_dir
				if env.options:
					Options.options.__dict__ = env.options
				Context.launch_dir = env.launch_dir
				try:
					run_command(cmd)
				finally:
					Options.options.__dict__ = tmp
					Context.launch_dir = launch_dir_tmp
			else:
				run_command(cmd)
			run_command(self.cmd)
		else:
			return execute_method(self)
	return execute
Build.BuildContext.execute = autoconfigure(Build.BuildContext.execute)

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      #!/usr/bin/env python
# encoding: utf-8
# Thomas Nagy, 2005-2018 (ita)

"""
Tasks represent atomic operations such as processes.
"""

import os, re, sys, tempfile, traceback
from waflib import Utils, Logs, Errors

# task states
NOT_RUN = 0
"""The task was not executed yet"""

MISSING = 1
"""The task has been executed but the files have not been created"""

CRASHED = 2
"""The task execution returned a non-zero exit status"""

EXCEPTION = 3
"""An exception occurred in the task execution"""

CANCELED = 4
"""A dependency for the task is missing so it was cancelled"""

SKIPPED = 8
"""The task did not have to be executed"""

SUCCESS = 9
"""The task was successfully executed"""

ASK_LATER = -1
"""The task is not ready to be executed"""

SKIP_ME = -2
"""The task does not need to be executed"""

RUN_ME = -3
"""The task must be executed"""

CANCEL_ME = -4
"""The task cannot be executed because of a dependency problem"""

COMPILE_TEMPLATE_SHELL = '''
def f(tsk):
	env = tsk.env
	gen = tsk.generator
	bld = gen.bld
	cwdx = tsk.get_cwd()
	p = env.get_flat
	def to_list(xx):
		if isinstance(xx, str): return [xx]
		return xx
	tsk.last_cmd = cmd = \'\'\' %s \'\'\' % s
	return tsk.exec_command(cmd, cwd=cwdx, env=env.env or None)
'''

COMPILE_TEMPLATE_NOSHELL = '''
def f(tsk):
	env = tsk.env
	gen = tsk.generator
	bld = gen.bld
	cwdx = tsk.get_cwd()
	def to_list(xx):
		if isinstance(xx, str): return [xx]
		return xx
	def merge(lst1, lst2):
		if lst1 and lst2:
			return lst1[:-1] + [lst1[-1] + lst2[0]] + lst2[1:]
		return lst1 + lst2
	lst = []
	%s
	if '' in lst:
		lst = [x for x in lst if x]
	tsk.last_cmd = lst
	return tsk.exec_command(lst, cwd=cwdx, env=env.env or None)
'''

COMPILE_TEMPLATE_SIG_VARS = '''
def f(tsk):
	sig = tsk.generator.bld.hash_env_vars(tsk.env, tsk.vars)
	tsk.m.update(sig)
	env = tsk.env
	gen = tsk.generator
	bld = gen.bld
	cwdx = tsk.get_cwd()
	p = env.get_flat
	buf = []
	%s
	tsk.m.update(repr(buf).encode())
'''

classes = {}
"""
The metaclass :py:class:`waflib.Task.store_task_type` stores all class tasks
created by user scripts or Waf tools to this dict. It maps class names to class objects.
"""

class store_task_type(type):
	"""
	Metaclass: store the task classes into the dict pointed by the
	class attribute 'register' which defaults to :py:const:`waflib.Task.classes`,

	The attribute 'run_str' is compiled into a method 'run' bound to the task class.
	"""
	def __init__(cls, name, bases, dict):
		super(store_task_type, cls).__init__(name, bases, dict)
		name = cls.__name__

		if name != 'evil' and name != 'Task':
			if getattr(cls, 'run_str', None):
				# if a string is provided, convert it to a method
				(f, dvars) = compile_fun(cls.run_str, cls.shell)
				cls.hcode = Utils.h_cmd(cls.run_str)
				cls.orig_run_str = cls.run_str
				# change the name of run_str or it is impossible to subclass with a function
				cls.run_str = None
				cls.run = f
				# process variables
				cls.vars = list(set(cls.vars + dvars))
				cls.vars.sort()
				if cls.vars:
					fun = compile_sig_vars(cls.vars)
					if fun:
						cls.sig_vars = fun
			elif getattr(cls, 'run', None) and not 'hcode' in cls.__dict__:
				# getattr(cls, 'hcode') would look in the upper classes
				cls.hcode = Utils.h_cmd(cls.run)

			# be creative
			getattr(cls, 'register', classes)[name] = cls

evil = store_task_type('evil', (object,), {})
"Base class provided to avoid writing a metaclass, so the code can run in python 2.6 and 3.x unmodified"

class Task(evil):
	"""
	Task objects represents actions to perform such as commands to execute by calling the `run` method.

	Detecting when to execute a task occurs in the method :py:meth:`waflib.Task.Task.runnable_status`.

	Detecting which tasks to execute is performed through a hash value returned by
	:py:meth:`waflib.Task.Task.signature`. The task signature is persistent from build to build.
	"""
	vars = []
	"""ConfigSet variables that should trigger a rebuild (class attribute used for :py:meth:`waflib.Task.Task.sig_vars`)"""

	always_run = False
	"""Specify whether task instances must always be executed or not (class attribute)"""

	shell = False
	"""Execute the command with the shell (class attribute)"""

	color = 'GREEN'
	"""Color for the console display, see :py:const:`waflib.Logs.colors_lst`"""

	ext_in = []
	"""File extensions that objects of this task class may use"""

	ext_out = []
	"""File extensions that objects of this task class may create"""

	before = []
	"""The instances of this class are executed before the instances of classes whose names are in this list"""

	after = []
	"""The instances of this class are executed after the instances of classes whose names are in this list"""

	hcode = Utils.SIG_NIL
	"""String representing an additional hash for the class representation"""

	keep_last_cmd = False
	"""Whether to keep the last command executed on the instance after execution.
	This may be useful for certain extensions but it can a lot of memory.
	"""

	weight = 0
	"""Optional weight to tune the priority for task instances.
	The higher, the earlier. The weight only applies to single task objects."""

	tree_weight = 0
	"""Optional weight to tune the priority of task instances and whole subtrees.
	The higher, the earlier."""

	prio_order = 0
	"""Priority order set by the scheduler on instances during the build phase.
	You most likely do not need to set it.
	"""

	__slots__ = ('hasrun', 'generator', 'env', 'inputs', 'outputs', 'dep_nodes', 'run_after')

	def __init__(self, *k, **kw):
		self.hasrun = NOT_RUN
		try:
			self.generator = kw['generator']
		except KeyError:
			self.generator = self

		self.env = kw['env']
		""":py:class:`waflib.ConfigSet.ConfigSet` object (make sure to provide one)"""

		self.inputs  = []
		"""List of input nodes, which represent the files used by the task instance"""

		self.outputs = []
		"""List of output nodes, which represent the files created by the task instance"""

		self.dep_nodes = []
		"""List of additional nodes to depend on"""

		self.run_after = set()
		"""Set of tasks that must be executed before this one"""

	def __lt__(self, other):
		return self.priority() > other.priority()
	def __le__(self, other):
		return self.priority() >= other.priority()
	def __gt__(self, other):
		return self.priority() < other.priority()
	def __ge__(self, other):
		return self.priority() <= other.priority()

	def get_cwd(self):
		"""
		:return: current working directory
		:rtype: :py:class:`waflib.Node.Node`
		"""
		bld = self.generator.bld
		ret = getattr(self, 'cwd', None) or getattr(bld, 'cwd', bld.bldnode)
		if isinstance(ret, str):
			if os.path.isabs(ret):
				ret = bld.root.make_node(ret)
			else:
				ret = self.generator.path.make_node(ret)
		return ret

	def quote_flag(self, x):
		"""
		Surround a process argument by quotes so that a list of arguments can be written to a file

		:param x: flag
		:type x: string
		:return: quoted flag
		:rtype: string
		"""
		old = x
		if '\\' in x:
			x = x.replace('\\', '\\\\')
		if '"' in x:
			x = x.replace('"', '\\"')
		if old != x or ' ' in x or '\t' in x or "'" in x:
			x = '"%s"' % x
		return x

	def priority(self):
		"""
		Priority of execution; the higher, the earlier

		:return: the priority value
		:rtype: a tuple of numeric values
		"""
		return (self.weight + self.prio_order, - getattr(self.generator, 'tg_idx_count', 0))

	def split_argfile(self, cmd):
		"""
		Splits a list of process commands into the executable part and its list of arguments

		:return: a tuple containing the executable first and then the rest of arguments
		:rtype: tuple
		"""
		return ([cmd[0]], [self.quote_flag(x) for x in cmd[1:]])

	def exec_command(self, cmd, **kw):
		"""
		Wrapper for :py:meth:`waflib.Context.Context.exec_command`.
		This version set the current working directory (``build.variant_dir``),
		applies PATH settings (if self.env.PATH is provided), and can run long
		commands through a temporary ``@argfile``.

		:param cmd: process command to execute
		:type cmd: list of string (best) or string (process will use a shell)
		:return: the return code
		:rtype: int

		Optional parameters:

		#. cwd: current working directory (Node or string)
		#. stdout: set to None to prevent waf from capturing the process standard output
		#. stderr: set to None to prevent waf from capturing the process standard error
		#. timeout: timeout value (Python 3)
		"""
		if not 'cwd' in kw:
			kw['cwd'] = self.get_cwd()

		if hasattr(self, 'timeout'):
			kw['timeout'] = self.timeout

		if self.env.PATH:
			env = kw['env'] = dict(kw.get('env') or self.env.env or os.environ)
			env['PATH'] = self.env.PATH if isinstance(self.env.PATH, str) else os.pathsep.join(self.env.PATH)

		if hasattr(self, 'stdout'):
			kw['stdout'] = self.stdout
		if hasattr(self, 'stderr'):
			kw['stderr'] = self.stderr

		if not isinstance(cmd, str):
			if Utils.is_win32:
				# win32 compares the resulting length http://support.microsoft.com/kb/830473
				too_long = sum([len(arg) for arg in cmd]) + len(cmd) > 8192
			else:
				# non-win32 counts the amount of arguments (200k)
				too_long = len(cmd) > 200000

			if too_long and getattr(self, 'allow_argsfile', True):
				# Shunt arguments to a temporary file if the command is too long.
				cmd, args = self.split_argfile(cmd)
				try:
					(fd, tmp) = tempfile.mkstemp()
					os.write(fd, '\r\n'.join(args).encode())
					os.close(fd)
					if Logs.verbose:
						Logs.debug('argfile: @%r -> %r', tmp, args)
					return self.generator.bld.exec_command(cmd + ['@' + tmp], **kw)
				finally:
					try:
						os.remove(tmp)
					except OSError:
						# anti-virus and indexers can keep files open -_-
						pass
		return self.generator.bld.exec_command(cmd, **kw)

	def process(self):
		"""
		Runs the task and handles errors

		:return: 0 or None if everything is fine
		:rtype: integer
		"""
		# remove the task signature immediately before it is executed
		# so that the task will be executed again in case of failure
		try:
			del self.generator.bld.task_sigs[self.uid()]
		except KeyError:
			pass

		try:
			ret = self.run()
		except Exception:
			self.err_msg = traceback.format_exc()
			self.hasrun = EXCEPTION
		else:
			if ret:
				self.err_code = ret
				self.hasrun = CRASHED
			else:
				try:
					self.post_run()
				except Errors.WafError:
					pass
				except Exception:
					self.err_msg = traceback.format_exc()
					self.hasrun = EXCEPTION
				else:
					self.hasrun = SUCCESS

		if self.hasrun != SUCCESS and self.scan:
			# rescan dependencies on next run
			try:
				del self.generator.bld.imp_sigs[self.uid()]
			except KeyError:
				pass

	def log_display(self, bld):
		"Writes the execution status on the context logger"
		if self.generator.bld.progress_bar == 3:
			return

		s = self.display()
		if s:
			if bld.logger:
				logger = bld.logger
			else:
				logger = Logs

			if self.generator.bld.progress_bar == 1:
				c1 = Logs.colors.cursor_off
				c2 = Logs.colors.cursor_on
				logger.info(s, extra={'stream': sys.stderr, 'terminator':'', 'c1': c1, 'c2' : c2})
			else:
				logger.info(s, extra={'terminator':'', 'c1': '', 'c2' : ''})

	def display(self):
		"""
		Returns an execution status for the console, the progress bar, or the IDE output.

		:rtype: string
		"""
		col1 = Logs.colors(self.color)
		col2 = Logs.colors.NORMAL
		master = self.generator.bld.producer

		def cur():
			# the current task position, computed as late as possible
			return master.processed - master.ready.qsize()

		if self.generator.bld.progress_bar == 1:
			return self.generator.bld.progress_line(cur(), master.total, col1, col2)

		if self.generator.bld.progress_bar == 2:
			ela = str(self.generator.bld.timer)
			try:
				ins  = ','.join([n.name for n in self.inputs])
			except AttributeError:
				ins = ''
			try:
				outs = ','.join([n.name for n in self.outputs])
			except AttributeError:
				outs = ''
			return '|Total %s|Current %s|Inputs %s|Outputs %s|Time %s|\n' % (master.total, cur(), ins, outs, ela)

		s = str(self)
		if not s:
			return None

		total = master.total
		n = len(str(total))
		fs = '[%%%dd/%%%dd] %%s%%s%%s%%s\n' % (n, n)
		kw = self.keyword()
		if kw:
			kw += ' '
		return fs % (cur(), total, kw, col1, s, col2)

	def hash_constraints(self):
		"""
		Identifies a task type for all the constraints relevant for the scheduler: precedence, file production

		:return: a hash value
		:rtype: string
		"""
		return (tuple(self.before), tuple(self.after), tuple(self.ext_in), tuple(self.ext_out), self.__class__.__name__, self.hcode)

	def format_error(self):
		"""
		Returns an error message to display the build failure reasons

		:rtype: string
		"""
		if Logs.verbose:
			msg = ': %r\n%r' % (self, getattr(self, 'last_cmd', ''))
		else:
			msg = ' (run with -v to display more information)'
		name = getattr(self.generator, 'name', '')
		if getattr(self, "err_msg", None):
			return self.err_msg
		elif not self.hasrun:
			return 'task in %r was not executed for some reason: %r' % (name, self)
		elif self.hasrun == CRASHED:
			if isinstance(msg, str):
				txt = msg
			else:
				txt = ' '.join(repr(x) if ' ' in x else x for x in msg)

			try:
				return ' -> task in %r failed (exit status %r): %r\n%s' % (name, self.err_code, self, txt)
			except AttributeError:
				return ' -> task in %r failed: %r\n%s' % (name, self, txt)
		elif self.hasrun == MISSING:
			return ' -> missing files in %r%s' % (name, msg)
		elif self.hasrun == CANCELED:
			return ' -> %r canceled because of missing dependencies' % name
		else:
			return 'invalid status for task in %r: %r' % (name, self.hasrun)

	def colon(self, var1, var2):
		"""
		Enable scriptlet expressions of the form ${FOO_ST:FOO}
		If the first variable (FOO_ST) is empty, then an empty list is returned

		The results will be slightly different if FOO_ST is a list, for example::

			env.FOO    = ['p1', 'p2']
			env.FOO_ST = '-I%s'
			# ${FOO_ST:FOO} returns
			['-Ip1', '-Ip2']

			env.FOO_ST = ['-a', '-b']
			# ${FOO_ST:FOO} returns
			['-a', '-b', 'p1', '-a', '-b', 'p2']
		"""
		tmp = self.env[var1]
		if not tmp:
			return []

		if isinstance(var2, str):
			it = self.env[var2]
		else:
			it = var2
		if isinstance(tmp, str):
			return [tmp % x for x in it]
		else:
			lst = []
			for y in it:
				lst.extend(tmp)
				lst.append(y)
			return lst

	def __str__(self):
		"string to display to the user"
		name = self.__class__.__name__
		if self.outputs:
			if name.endswith(('lib', 'program')) or not self.inputs:
				node = self.outputs[0]
				return node.path_from(node.ctx.launch_node())
		if not (self.inputs or self.outputs):
			return self.__class__.__name__
		if len(self.inputs) == 1:
			node = self.inputs[0]
			return node.path_from(node.ctx.launch_node())

		src_str = ' '.join([a.path_from(a.ctx.launch_node()) for a in self.inputs])
		tgt_str = ' '.join([a.path_from(a.ctx.launch_node()) for a in self.outputs])
		if self.outputs:
			sep = ' -> '
		else:
			sep = ''
		return '%s: %s%s%s' % (self.__class__.__name__, src_str, sep, tgt_str)

	def keyword(self):
		"Display keyword used to prettify the console outputs"
		name = self.__class__.__name__
		if name.endswith(('lib', 'program')):
			return 'Linking'
		if len(self.inputs) == 1 and len(self.outputs) == 1:
			return 'Compiling'
		if not self.inputs:
			if self.outputs:
				return 'Creating'
			else:
				return 'Running'
		return 'Processing'

	def __repr__(self):
		"for debugging purposes"
		try:
			ins = ",".join([x.name for x in self.inputs])
			outs = ",".join([x.name for x in self.outputs])
		except AttributeError:
			ins = ",".join([str(x) for x in self.inputs])
			outs = ",".join([str(x) for x in self.outputs])
		return "".join(['\n\t{task %r: ' % id(self), self.__class__.__name__, " ", ins, " -> ", outs, '}'])

	def uid(self):
		"""
		Returns an identifier used to determine if tasks are up-to-date. Since the
		identifier will be stored between executions, it must be:

			- unique for a task: no two tasks return the same value (for a given build context)
			- the same for a given task instance

		By default, the node paths, the class name, and the function are used
		as inputs to compute a hash.

		The pointer to the object (python built-in 'id') will change between build executions,
		and must be avoided in such hashes.

		:return: hash value
		:rtype: string
		"""
		try:
			return self.uid_
		except AttributeError:
			m = Utils.md5(self.__class__.__name__)
			up = m.update
			for x in self.inputs + self.outputs:
				up(x.abspath())
			self.uid_ = m.digest()
			return self.uid_

	def set_inputs(self, inp):
		"""
		Appends the nodes to the *inputs* list

		:param inp: input nodes
		:type inp: node or list of nodes
		"""
		if isinstance(inp, list):
			self.inputs += inp
		else:
			self.inputs.append(inp)

	def set_outputs(self, out):
		"""
		Appends the nodes to the *outputs* list

		:param out: output nodes
		:type out: node or list of nodes
		"""
		if isinstance(out, list):
			self.outputs += out
		else:
			self.outputs.append(out)

	def set_run_after(self, task):
		"""
		Run this task only after the given *task*.

		Calling this method from :py:meth:`waflib.Task.Task.runnable_status` may cause
		build deadlocks; see :py:meth:`waflib.Tools.fc.fc.runnable_status` for details.

		:param task: task
		:type task: :py:class:`waflib.Task.Task`
		"""
		assert isinstance(task, Task)
		self.run_after.add(task)

	def signature(self):
		"""
		Task signatures are stored between build executions, they are use to track the changes
		made to the input nodes (not to the outputs!). The signature hashes data from various sources:

		* explicit dependencies: files listed in the inputs (list of node objects) :py:meth:`waflib.Task.Task.sig_explicit_deps`
		* implicit dependencies: list of nodes returned by scanner methods (when present) :py:meth:`waflib.Task.Task.sig_implicit_deps`
		* hashed data: variables/values read from task.vars/task.env :py:meth:`waflib.Task.Task.sig_vars`

		If the signature is expected to give a different result, clear the cache kept in ``self.cache_sig``::

			from waflib import Task
			class cls(Task.Task):
				def signature(self):
					sig = super(Task.Task, self).signature()
					delattr(self, 'cache_sig')
					return super(Task.Task, self).signature()

		:return: the signature value
		:rtype: string or bytes
		"""
		try:
			return self.cache_sig
		except AttributeError:
			pass

		self.m = Utils.md5(self.hcode)

		# explicit deps
		self.sig_explicit_deps()

		# env vars
		self.sig_vars()

		# implicit deps / scanner results
		if self.scan:
			try:
				self.sig_implicit_deps()
			except Errors.TaskRescan:
				return self.signature()

		ret = self.cache_sig = self.m.digest()
		return ret

	def runnable_status(self):
		"""
		Returns the Task status

		:return: a task state in :py:const:`waflib.Task.RUN_ME`,
			:py:const:`waflib.Task.SKIP_ME`, :py:const:`waflib.Task.CANCEL_ME` or :py:const:`waflib.Task.ASK_LATER`.
		:rtype: int
		"""
		bld = self.generator.bld
		if bld.is_install < 0:
			return SKIP_ME

		for t in self.run_after:
			if not t.hasrun:
				return ASK_LATER
			elif t.hasrun < SKIPPED:
				# a dependency has an error
				return CANCEL_ME

		# first compute the signature
		try:
			new_sig = self.signature()
		except Errors.TaskNotReady:
			return ASK_LATER

		# compare the signature to a signature computed previously
		key = self.uid()
		try:
			prev_sig = bld.task_sigs[key]
		except KeyError:
			Logs.debug('task: task %r must run: it was never run before or the task code changed', self)
			return RUN_ME

		if new_sig != prev_sig:
			Logs.debug('task: task %r must run: the task signature changed', self)
			return RUN_ME

		# compare the signatures of the outputs
		for node in self.outputs:
			sig = bld.node_sigs.get(node)
			if not sig:
				Logs.debug('task: task %r must run: an output node has no signature', self)
				return RUN_ME
			if sig != key:
				Logs.debug('task: task %r must run: an output node was produced by another task', self)
				return RUN_ME
			if not node.exists():
				Logs.debug('task: task %r must run: an output node does not exist', self)
				return RUN_ME

		return (self.always_run and RUN_ME) or SKIP_ME

	def post_run(self):
		"""
		Called after successful execution to record that the task has run by
		updating the entry in :py:attr:`waflib.Build.BuildContext.task_sigs`.
		"""
		bld = self.generator.bld
		for node in self.outputs:
			if not node.exists():
				self.hasrun = MISSING
				self.err_msg = '-> missing file: %r' % node.abspath()
				raise Errors.WafError(self.err_msg)
			bld.node_sigs[node] = self.uid() # make sure this task produced the files in question
		bld.task_sigs[self.uid()] = self.signature()
		if not self.keep_last_cmd:
			try:
				del self.last_cmd
			except AttributeError:
				pass

	def sig_explicit_deps(self):
		"""
		Used by :py:meth:`waflib.Task.Task.signature`; it hashes :py:attr:`waflib.Task.Task.inputs`
		and :py:attr:`waflib.Task.Task.dep_nodes` signatures.
		"""
		bld = self.generator.bld
		upd = self.m.update

		# the inputs
		for x in self.inputs + self.dep_nodes:
			upd(x.get_bld_sig())

		# manual dependencies, they can slow down the builds
		if bld.deps_man:
			additional_deps = bld.deps_man
			for x in self.inputs + self.outputs:
				try:
					d = additional_deps[x]
				except KeyError:
					continue

				for v in d:
					try:
						v = v.get_bld_sig()
					except AttributeError:
						if hasattr(v, '__call__'):
							v = v() # dependency is a function, call it
					upd(v)

	def sig_deep_inputs(self):
		"""
		Enable rebuilds on input files task signatures. Not used by default.

		Example: hashes of output programs can be unchanged after being re-linked,
		despite the libraries being different. This method can thus prevent stale unit test
		results (waf_unit_test.py).

		Hashing input file timestamps is another possibility for the implementation.
		This may cause unnecessary rebuilds when input tasks are frequently executed.
		Here is an implementation example::

			lst = []
			for node in self.inputs + self.dep_nodes:
				st = os.stat(node.abspath())
				lst.append(st.st_mtime)
				lst.append(st.st_size)
			self.m.update(Utils.h_list(lst))

		The downside of the implementation is that it absolutely requires all build directory
		files to be declared within the current build.
		"""
		bld = self.generator.bld
		lst = [bld.task_sigs[bld.node_sigs[node]] for node in (self.inputs + self.dep_nodes) if node.is_bld()]
		self.m.update(Utils.h_list(lst))

	def sig_vars(self):
		"""
		Used by :py:meth:`waflib.Task.Task.signature`; it hashes :py:attr:`waflib.Task.Task.env` variables/values
		When overriding this method, and if scriptlet expressions are used, make sure to follow
		the code in :py:meth:`waflib.Task.Task.compile_sig_vars` to enable dependencies on scriptlet results.

		This method may be replaced on subclasses by the metaclass to force dependencies on scriptlet code.
		"""
		sig = self.generator.bld.hash_env_vars(self.env, self.vars)
		self.m.update(sig)

	scan = None
	"""
	This method, when provided, returns a tuple containing:

	* a list of nodes corresponding to real files
	* a list of names for files not found in path_lst

	For example::

		from waflib.Task import Task
		class mytask(Task):
			def scan(self, node):
				return ([], [])

	The first and second lists in the tuple are stored in :py:attr:`waflib.Build.BuildContext.node_deps` and
	:py:attr:`waflib.Build.BuildContext.raw_deps` respectively.
	"""

	def sig_implicit_deps(self):
		"""
		Used by :py:meth:`waflib.Task.Task.signature`; it hashes node signatures
		obtained by scanning for dependencies (:py:meth:`waflib.Task.Task.scan`).

		The exception :py:class:`waflib.Errors.TaskRescan` is thrown
		when a file has changed. In this case, the method :py:meth:`waflib.Task.Task.signature` is called
		once again, and return here to call :py:meth:`waflib.Task.Task.scan` and searching for dependencies.
		"""
		bld = self.generator.bld

		# get the task signatures from previous runs
		key = self.uid()
		prev = bld.imp_sigs.get(key, [])

		# for issue #379
		if prev:
			try:
				if prev == self.compute_sig_implicit_deps():
					return prev
			except Errors.TaskNotReady:
				raise
			except EnvironmentError:
				# when a file was renamed, remove the stale nodes (headers in folders without source files)
				# this will break the order calculation for headers created during the build in the source directory (should be uncommon)
				# the behaviour will differ when top != out
				for x in bld.node_deps.get(self.uid(), []):
					if not x.is_bld() and not x.exists():
						try:
							del x.parent.children[x.name]
						except KeyError:
							pass
			del bld.imp_sigs[key]
			raise Errors.TaskRescan('rescan')

		# no previous run or the signature of the dependencies has changed, rescan the dependencies
		(bld.node_deps[key], bld.raw_deps[key]) = self.scan()
		if Logs.verbose:
			Logs.debug('deps: scanner for %s: %r; unresolved: %r', self, bld.node_deps[key], bld.raw_deps[key])

		# recompute the signature and return it
		try:
			bld.imp_sigs[key] = self.compute_sig_implicit_deps()
		except EnvironmentError:
			for k in bld.node_deps.get(self.uid(), []):
				if not k.exists():
					Logs.warn('Dependency %r for %r is missing: check the task declaration and the build order!', k, self)
			raise

	def compute_sig_implicit_deps(self):
		"""
		Used by :py:meth:`waflib.Task.Task.sig_implicit_deps` for computing the actual hash of the
		:py:class:`waflib.Node.Node` returned by the scanner.

		:return: a hash value for the implicit dependencies
		:rtype: string or bytes
		"""
		upd = self.m.update
		self.are_implicit_nodes_ready()

		# scanner returns a node that does not have a signature
		# just *ignore* the error and let them figure out from the compiler output
		# waf -k behaviour
		for k in self.generator.bld.node_deps.get(self.uid(), []):
			upd(k.get_bld_sig())
		return self.m.digest()

	def are_implicit_nodes_ready(self):
		"""
		For each node returned by the scanner, see if there is a task that creates it,
		and infer the build order

		This has a low performance impact on null builds (1.86s->1.66s) thanks to caching (28s->1.86s)
		"""
		bld = self.generator.bld
		try:
			cache = bld.dct_implicit_nodes
		except AttributeError:
			bld.dct_implicit_nodes = cache = {}

		# one cache per build group
		try:
			dct = cache[bld.current_group]
		except KeyError:
			dct = cache[bld.current_group] = {}
			for tsk in bld.cur_tasks:
				for x in tsk.outputs:
					dct[x] = tsk

		modified = False
		for x in bld.node_deps.get(self.uid(), []):
			if x in dct:
				self.run_after.add(dct[x])
				modified = True

		if modified:
			for tsk in self.run_after:
				if not tsk.hasrun:
					#print "task is not ready..."
					raise Errors.TaskNotReady('not ready')
if sys.hexversion > 0x3000000:
	def uid(self):
		try:
			return self.uid_
		except AttributeError:
			m = Utils.md5(self.__class__.__name__.encode('latin-1', 'xmlcharrefreplace'))
			up = m.update
			for x in self.inputs + self.outputs:
				up(x.abspath().encode('latin-1', 'xmlcharrefreplace'))
			self.uid_ = m.digest()
			return self.uid_
	uid.__doc__ = Task.uid.__doc__
	Task.uid = uid

def is_before(t1, t2):
	"""
	Returns a non-zero value if task t1 is to be executed before task t2::

		t1.ext_out = '.h'
		t2.ext_in = '.h'
		t2.after = ['t1']
		t1.before = ['t2']
		waflib.Task.is_before(t1, t2) # True

	:param t1: Task object
	:type t1: :py:class:`waflib.Task.Task`
	:param t2: Task object
	:type t2: :py:class:`waflib.Task.Task`
	"""
	to_list = Utils.to_list
	for k in to_list(t2.ext_in):
		if k in to_list(t1.ext_out):
			return 1

	if t1.__class__.__name__ in to_list(t2.after):
		return 1

	if t2.__class__.__name__ in to_list(t1.before):
		return 1

	return 0

def set_file_constraints(tasks):
	"""
	Updates the ``run_after`` attribute of all tasks based on the task inputs and outputs

	:param tasks: tasks
	:type tasks: list of :py:class:`waflib.Task.Task`
	"""
	ins = Utils.defaultdict(set)
	outs = Utils.defaultdict(set)
	for x in tasks:
		for a in x.inputs:
			ins[a].add(x)
		for a in x.dep_nodes:
			ins[a].add(x)
		for a in x.outputs:
			outs[a].add(x)

	links = set(ins.keys()).intersection(outs.keys())
	for k in links:
		for a in ins[k]:
			a.run_after.update(outs[k])


class TaskGroup(object):
	"""
	Wrap nxm task order constraints into a single object
	to prevent the creation of large list/set objects

	This is an optimization
	"""
	def __init__(self, prev, next):
		self.prev = prev
		self.next = next
		self.done = False

	def get_hasrun(self):
		for k in self.prev:
			if not k.hasrun:
				return NOT_RUN
		return SUCCESS

	hasrun = property(get_hasrun, None)

def set_precedence_constraints(tasks):
	"""
	Updates the ``run_after`` attribute of all tasks based on the after/before/ext_out/ext_in attributes

	:param tasks: tasks
	:type tasks: list of :py:class:`waflib.Task.Task`
	"""
	cstr_groups = Utils.defaultdict(list)
	for x in tasks:
		h = x.hash_constraints()
		cstr_groups[h].append(x)

	keys = list(cstr_groups.keys())
	maxi = len(keys)

	# this list should be short
	for i in range(maxi):
		t1 = cstr_groups[keys[i]][0]
		for j in range(i + 1, maxi):
			t2 = cstr_groups[keys[j]][0]

			# add the constraints based on the comparisons
			if is_before(t1, t2):
				a = i
				b = j
			elif is_before(t2, t1):
				a = j
				b = i
			else:
				continue

			a = cstr_groups[keys[a]]
			b = cstr_groups[keys[b]]

			if len(a) < 2 or len(b) < 2:
				for x in b:
					x.run_after.update(a)
			else:
				group = TaskGroup(set(a), set(b))
				for x in b:
					x.run_after.add(group)

def funex(c):
	"""
	Compiles a scriptlet expression into a Python function

	:param c: function to compile
	:type c: string
	:return: the function 'f' declared in the input string
	:rtype: function
	"""
	dc = {}
	exec(c, dc)
	return dc['f']

re_cond = re.compile(r'(?P<var>\w+)|(?P<or>\|)|(?P<and>&)')
re_novar = re.compile(r'^(SRC|TGT)\W+.*?$')
reg_act = re.compile(r'(?P<backslash>\\)|(?P<dollar>\$\$)|(?P<subst>\$\{(?P<var>\w+)(?P<code>.*?)\})', re.M)
def compile_fun_shell(line):
	"""
	Creates a compiled function to execute a process through a sub-shell
	"""
	extr = []
	def repl(match):
		g = match.group
		if g('dollar'):
			return "$"
		elif g('backslash'):
			return '\\\\'
		elif g('subst'):
			extr.append((g('var'), g('code')))
			return "%s"
		return None
	line = reg_act.sub(repl, line) or line
	dvars = []
	def add_dvar(x):
		if x not in dvars:
			dvars.append(x)

	def replc(m):
		# performs substitutions and populates dvars
		if m.group('and'):
			return ' and '
		elif m.group('or'):
			return ' or '
		else:
			x = m.group('var')
			add_dvar(x)
			return 'env[%r]' % x

	parm = []
	app = parm.append
	for (var, meth) in extr:
		if var == 'SRC':
			if meth:
				app('tsk.inputs%s' % meth)
			else:
				app('" ".join([a.path_from(cwdx) for a in tsk.inputs])')
		elif var == 'TGT':
			if meth:
				app('tsk.outputs%s' % meth)
			else:
				app('" ".join([a.path_from(cwdx) for a in tsk.outputs])')
		elif meth:
			if meth.startswith(':'):
				add_dvar(var)
				m = meth[1:]
				if m == 'SRC':
					m = '[a.path_from(cwdx) for a in tsk.inputs]'
				elif m == 'TGT':
					m = '[a.path_from(cwdx) for a in tsk.outputs]'
				elif re_novar.match(m):
					m = '[tsk.inputs%s]' % m[3:]
				elif re_novar.match(m):
					m = '[tsk.outputs%s]' % m[3:]
				else:
					add_dvar(m)
					if m[:3] not in ('tsk', 'gen', 'bld'):
						m = '%r' % m
				app('" ".join(tsk.colon(%r, %s))' % (var, m))
			elif meth.startswith('?'):
				# In A?B|C output env.A if one of env.B or env.C is non-empty
				expr = re_cond.sub(replc, meth[1:])
				app('p(%r) if (%s) else ""' % (var, expr))
			else:
				call = '%s%s' % (var, meth)
				add_dvar(call)
				app(call)
		else:
			add_dvar(var)
			app("p('%s')" % var)
	if parm:
		parm = "%% (%s) " % (',\n\t\t'.join(parm))
	else:
		parm = ''

	c = COMPILE_TEMPLATE_SHELL % (line, parm)
	Logs.debug('action: %s', c.strip().splitlines())
	return (funex(c), dvars)

reg_act_noshell = re.compile(r"(?P<space>\s+)|(?P<subst>\$\{(?P<var>\w+)(?P<code>.*?)\})|(?P<text>([^$ \t\n\r\f\v]|\$\$)+)", re.M)
def compile_fun_noshell(line):
	"""
	Creates a compiled function to execute a process without a sub-shell
	"""
	buf = []
	dvars = []
	merge = False
	app = buf.append

	def add_dvar(x):
		if x not in dvars:
			dvars.append(x)

	def replc(m):
		# performs substitutions and populates dvars
		if m.group('and'):
			return ' and '
		elif m.group('or'):
			return ' or '
		else:
			x = m.group('var')
			add_dvar(x)
			return 'env[%r]' % x

	for m in reg_act_noshell.finditer(line):
		if m.group('space'):
			merge = False
			continue
		elif m.group('text'):
			app('[%r]' % m.group('text').replace('$$', '$'))
		elif m.group('subst'):
			var = m.group('var')
			code = m.group('code')
			if var == 'SRC':
				if code:
					app('[tsk.inputs%s]' % code)
				else:
					app('[a.path_from(cwdx) for a in tsk.inputs]')
			elif var == 'TGT':
				if code:
					app('[tsk.outputs%s]' % code)
				else:
					app('[a.path_from(cwdx) for a in tsk.outputs]')
			elif code:
				if code.startswith(':'):
					# a composed variable ${FOO:OUT}
					add_dvar(var)
					m = code[1:]
					if m == 'SRC':
						m = '[a.path_from(cwdx) for a in tsk.inputs]'
					elif m == 'TGT':
						m = '[a.path_from(cwdx) for a in tsk.outputs]'
					elif re_novar.match(m):
						m = '[tsk.inputs%s]' % m[3:]
					elif re_novar.match(m):
						m = '[tsk.outputs%s]' % m[3:]
					else:
						add_dvar(m)
						if m[:3] not in ('tsk', 'gen', 'bld'):
							m = '%r' % m
					app('tsk.colon(%r, %s)' % (var, m))
				elif code.startswith('?'):
					# In A?B|C output env.A if one of env.B or env.C is non-empty
					expr = re_cond.sub(replc, code[1:])
					app('to_list(env[%r] if (%s) else [])' % (var, expr))
				else:
					# plain code such as ${tsk.inputs[0].abspath()}
					call = '%s%s' % (var, code)
					add_dvar(call)
					app('to_list(%s)' % call)
			else:
				# a plain variable such as # a plain variable like ${AR}
				app('to_list(env[%r])' % var)
				add_dvar(var)
		if merge:
			tmp = 'merge(%s, %s)' % (buf[-2], buf[-1])
			del buf[-1]
			buf[-1] = tmp
		merge = True # next turn

	buf = ['lst.extend(%s)' % x for x in buf]
	fun = COMPILE_TEMPLATE_NOSHELL % "\n\t".join(buf)
	Logs.debug('action: %s', fun.strip().splitlines())
	return (funex(fun), dvars)

def compile_fun(line, shell=False):
	"""
	Parses a string expression such as '${CC} ${SRC} -o ${TGT}' and returns a pair containing:

	* The function created (compiled) for use as :py:meth:`waflib.Task.Task.run`
	* The list of variables that must cause rebuilds when *env* data is modified

	for example::

		from waflib.Task import compile_fun
		compile_fun('cxx', '${CXX} -o ${TGT[0]} ${SRC} -I ${SRC[0].parent.bldpath()}')

		def build(bld):
			bld(source='wscript', rule='echo "foo\\${SRC[0].name}\\bar"')

	The env variables (CXX, ..) on the task must not hold dicts so as to preserve a consistent order.
	The reserved keywords ``TGT`` and ``SRC`` represent the task input and output nodes

	"""
	if isinstance(line, str):
		if line.find('<') > 0 or line.find('>') > 0 or line.find('&&') > 0:
			shell = True
	else:
		dvars_lst = []
		funs_lst = []
		for x in line:
			if isinstance(x, str):
				fun, dvars = compile_fun(x, shell)
				dvars_lst += dvars
				funs_lst.append(fun)
			else:
				# assume a function to let through
				funs_lst.append(x)
		def composed_fun(task):
			for x in funs_lst:
				ret = x(task)
				if ret:
					return ret
			return None
		return composed_fun, dvars_lst
	if shell:
		return compile_fun_shell(line)
	else:
		return compile_fun_noshell(line)

def compile_sig_vars(vars):
	"""
	This method produces a sig_vars method suitable for subclasses that provide
	scriptlet code in their run_str code.
	If no such method can be created, this method returns None.

	The purpose of the sig_vars method returned is to ensures
	that rebuilds occur whenever the contents of the expression changes.
	This is the case B below::

		import time
		# case A: regular variables
		tg = bld(rule='echo ${FOO}')
		tg.env.FOO = '%s' % time.time()
		# case B
		bld(rule='echo ${gen.foo}', foo='%s' % time.time())

	:param vars: env variables such as CXXFLAGS or gen.foo
	:type vars: list of string
	:return: A sig_vars method relevant for dependencies if adequate, else None
	:rtype: A function, or None in most cases
	"""
	buf = []
	for x in sorted(vars):
		if x[:3] in ('tsk', 'gen', 'bld'):
			buf.append('buf.append(%s)' % x)
	if buf:
		return funex(COMPILE_TEMPLATE_SIG_VARS % '\n\t'.join(buf))
	return None

def task_factory(name, func=None, vars=None, color='GREEN', ext_in=[], ext_out=[], before=[], after=[], shell=False, scan=None):
	"""
	Returns a new task subclass with the function ``run`` compiled from the line given.

	:param func: method run
	:type func: string or function
	:param vars: list of variables to hash
	:type vars: list of string
	:param color: color to use
	:type color: string
	:param shell: when *func* is a string, enable/disable the use of the shell
	:type shell: bool
	:param scan: method scan
	:type scan: function
	:rtype: :py:class:`waflib.Task.Task`
	"""

	params = {
		'vars': vars or [], # function arguments are static, and this one may be modified by the class
		'color': color,
		'name': name,
		'shell': shell,
		'scan': scan,
	}

	if isinstance(func, str) or isinstance(func, tuple):
		params['run_str'] = func
	else:
		params['run'] = func

	cls = type(Task)(name, (Task,), params)
	classes[name] = cls

	if ext_in:
		cls.ext_in = Utils.to_list(ext_in)
	if ext_out:
		cls.ext_out = Utils.to_list(ext_out)
	if before:
		cls.before = Utils.to_list(before)
	if after:
		cls.after = Utils.to_list(after)

	return cls

def deep_inputs(cls):
	"""
	Task class decorator to enable rebuilds on input files task signatures
	"""
	def sig_explicit_deps(self):
		Task.sig_explicit_deps(self)
		Task.sig_deep_inputs(self)
	cls.sig_explicit_deps = sig_explicit_deps
	return cls

TaskBase = Task
"Provided for compatibility reasons, TaskBase should not be used"

class TaskSemaphore(object):
	"""
	Task semaphores provide a simple and efficient way of throttling the amount of
	a particular task to run concurrently. The throttling value is capped
	by the amount of maximum jobs, so for example, a `TaskSemaphore(10)`
	has no effect in a `-j2` build.

	Task semaphores are typically specified on the task class level::

		class compile(waflib.Task.Task):
			semaphore = waflib.Task.TaskSemaphore(2)
			run_str = 'touch ${TGT}'

	Task semaphores are meant to be used by the build scheduler in the main
	thread, so there are no guarantees of thread safety.
	"""
	def __init__(self, num):
		"""
		:param num: maximum value of concurrent tasks
		:type num: int
		"""
		self.num = num
		self.locking = set()
		self.waiting = set()

	def is_locked(self):
		"""Returns True if this semaphore cannot be acquired by more tasks"""
		return len(self.locking) >= self.num

	def acquire(self, tsk):
		"""
		Mark the semaphore as used by the given task (not re-entrant).

		:param tsk: task object
		:type tsk: :py:class:`waflib.Task.Task`
		:raises: :py:class:`IndexError` in case the resource is already acquired
		"""
		if self.is_locked():
			raise IndexError('Cannot lock more %r' % self.locking)
		self.locking.add(tsk)

	def release(self, tsk):
		"""
		Mark the semaphore as unused by the given task.

		:param tsk: task object
		:type tsk: :py:class:`waflib.Task.Task`
		:raises: :py:class:`KeyError` in case the resource is not acquired by the task
		"""
		self.locking.remove(tsk)

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             #!/usr/bin/env python
# encoding: utf-8
# Thomas Nagy, 2005-2018 (ita)

"""
Task generators

The class :py:class:`waflib.TaskGen.task_gen` encapsulates the creation of task objects (low-level code)
The instances can have various parameters, but the creation of task nodes (Task.py)
is deferred. To achieve this, various methods are called from the method "apply"
"""

import copy, re, os, functools
from waflib import Task, Utils, Logs, Errors, ConfigSet, Node

feats = Utils.defaultdict(set)
"""remember the methods declaring features"""

HEADER_EXTS = ['.h', '.hpp', '.hxx', '.hh']

class task_gen(object):
	"""
	Instances of this class create :py:class:`waflib.Task.Task` when
	calling the method :py:meth:`waflib.TaskGen.task_gen.post` from the main thread.
	A few notes:

	* The methods to call (*self.meths*) can be specified dynamically (removing, adding, ..)
	* The 'features' are used to add methods to self.meths and then execute them
	* The attribute 'path' is a node representing the location of the task generator
	* The tasks created are added to the attribute *tasks*
	* The attribute 'idx' is a counter of task generators in the same path
	"""

	mappings = Utils.ordered_iter_dict()
	"""Mappings are global file extension mappings that are retrieved in the order of definition"""

	prec = Utils.defaultdict(set)
	"""Dict that holds the precedence execution rules for task generator methods"""

	def __init__(self, *k, **kw):
		"""
		Task generator objects predefine various attributes (source, target) for possible
		processing by process_rule (make-like rules) or process_source (extensions, misc methods)

		Tasks are stored on the attribute 'tasks'. They are created by calling methods
		listed in ``self.meths`` or referenced in the attribute ``features``
		A topological sort is performed to execute the methods in correct order.

		The extra key/value elements passed in ``kw`` are set as attributes
		"""
		self.source = []
		self.target = ''

		self.meths = []
		"""
		List of method names to execute (internal)
		"""

		self.features = []
		"""
		List of feature names for bringing new methods in
		"""

		self.tasks = []
		"""
		Tasks created are added to this list
		"""

		if not 'bld' in kw:
			# task generators without a build context :-/
			self.env = ConfigSet.ConfigSet()
			self.idx = 0
			self.path = None
		else:
			self.bld = kw['bld']
			self.env = self.bld.env.derive()
			self.path = kw.get('path', self.bld.path) # by default, emulate chdir when reading scripts

			# Provide a unique index per folder
			# This is part of a measure to prevent output file name collisions
			path = self.path.abspath()
			try:
				self.idx = self.bld.idx[path] = self.bld.idx.get(path, 0) + 1
			except AttributeError:
				self.bld.idx = {}
				self.idx = self.bld.idx[path] = 1

			# Record the global task generator count
			try:
				self.tg_idx_count = self.bld.tg_idx_count = self.bld.tg_idx_count + 1
			except AttributeError:
				self.tg_idx_count = self.bld.tg_idx_count = 1

		for key, val in kw.items():
			setattr(self, key, val)

	def __str__(self):
		"""Debugging helper"""
		return "<task_gen %r declared in %s>" % (self.name, self.path.abspath())

	def __repr__(self):
		"""Debugging helper"""
		lst = []
		for x in self.__dict__:
			if x not in ('env', 'bld', 'compiled_tasks', 'tasks'):
				lst.append("%s=%s" % (x, repr(getattr(self, x))))
		return "bld(%s) in %s" % (", ".join(lst), self.path.abspath())

	def get_cwd(self):
		"""
		Current working directory for the task generator, defaults to the build directory.
		This is still used in a few places but it should disappear at some point as the classes
		define their own working directory.

		:rtype: :py:class:`waflib.Node.Node`
		"""
		return self.bld.bldnode

	def get_name(self):
		"""
		If the attribute ``name`` is not set on the instance,
		the name is computed from the target name::

			def build(bld):
				x = bld(name='foo')
				x.get_name() # foo
				y = bld(target='bar')
				y.get_name() # bar

		:rtype: string
		:return: name of this task generator
		"""
		try:
			return self._name
		except AttributeError:
			if isinstance(self.target, list):
				lst = [str(x) for x in self.target]
				name = self._name = ','.join(lst)
			else:
				name = self._name = str(self.target)
			return name
	def set_name(self, name):
		self._name = name

	name = property(get_name, set_name)

	def to_list(self, val):
		"""
		Ensures that a parameter is a list, see :py:func:`waflib.Utils.to_list`

		:type val: string or list of string
		:param val: input to return as a list
		:rtype: list
		"""
		if isinstance(val, str):
			return val.split()
		else:
			return val

	def post(self):
		"""
		Creates tasks for this task generators. The following operations are performed:

		#. The body of this method is called only once and sets the attribute ``posted``
		#. The attribute ``features`` is used to add more methods in ``self.meths``
		#. The methods are sorted by the precedence table ``self.prec`` or `:waflib:attr:waflib.TaskGen.task_gen.prec`
		#. The methods are then executed in order
		#. The tasks created are added to :py:attr:`waflib.TaskGen.task_gen.tasks`
		"""
		if getattr(self, 'posted', None):
			return False
		self.posted = True

		keys = set(self.meths)
		keys.update(feats['*'])

		# add the methods listed in the features
		self.features = Utils.to_list(self.features)
		for x in self.features:
			st = feats[x]
			if st:
				keys.update(st)
			elif not x in Task.classes:
				Logs.warn('feature %r does not exist - bind at least one method to it?', x)

		# copy the precedence table
		prec = {}
		prec_tbl = self.prec
		for x in prec_tbl:
			if x in keys:
				prec[x] = prec_tbl[x]

		# elements disconnected
		tmp = []
		for a in keys:
			for x in prec.values():
				if a in x:
					break
			else:
				tmp.append(a)

		tmp.sort(reverse=True)

		# topological sort
		out = []
		while tmp:
			e = tmp.pop()
			if e in keys:
				out.append(e)
			try:
				nlst = prec[e]
			except KeyError:
				pass
			else:
				del prec[e]
				for x in nlst:
					for y in prec:
						if x in prec[y]:
							break
					else:
						tmp.append(x)
						tmp.sort(reverse=True)

		if prec:
			buf = ['Cycle detected in the method execution:']
			for k, v in prec.items():
				buf.append('- %s after %s' % (k, [x for x in v if x in prec]))
			raise Errors.WafError('\n'.join(buf))
		self.meths = out

		# then we run the methods in order
		Logs.debug('task_gen: posting %s %d', self, id(self))
		for x in out:
			try:
				v = getattr(self, x)
			except AttributeError:
				raise Errors.WafError('%r is not a valid task generator method' % x)
			Logs.debug('task_gen: -> %s (%d)', x, id(self))
			v()

		Logs.debug('task_gen: posted %s', self.name)
		return True

	def get_hook(self, node):
		"""
		Returns the ``@extension`` method to call for a Node of a particular extension.

		:param node: Input file to process
		:type node: :py:class:`waflib.Tools.Node.Node`
		:return: A method able to process the input node by looking at the extension
		:rtype: function
		"""
		name = node.name
		for k in self.mappings:
			try:
				if name.endswith(k):
					return self.mappings[k]
			except TypeError:
				# regexps objects
				if k.match(name):
					return self.mappings[k]
		keys = list(self.mappings.keys())
		raise Errors.WafError("File %r has no mapping in %r (load a waf tool?)" % (node, keys))

	def create_task(self, name, src=None, tgt=None, **kw):
		"""
		Creates task instances.

		:param name: task class name
		:type name: string
		:param src: input nodes
		:type src: list of :py:class:`waflib.Tools.Node.Node`
		:param tgt: output nodes
		:type tgt: list of :py:class:`waflib.Tools.Node.Node`
		:return: A task object
		:rtype: :py:class:`waflib.Task.Task`
		"""
		task = Task.classes[name](env=self.env.derive(), generator=self)
		if src:
			task.set_inputs(src)
		if tgt:
			task.set_outputs(tgt)
		task.__dict__.update(kw)
		self.tasks.append(task)
		return task

	def clone(self, env):
		"""
		Makes a copy of a task generator. Once the copy is made, it is necessary to ensure that the
		it does not create the same output files as the original, or the same files may
		be compiled several times.

		:param env: A configuration set
		:type env: :py:class:`waflib.ConfigSet.ConfigSet`
		:return: A copy
		:rtype: :py:class:`waflib.TaskGen.task_gen`
		"""
		newobj = self.bld()
		for x in self.__dict__:
			if x in ('env', 'bld'):
				continue
			elif x in ('path', 'features'):
				setattr(newobj, x, getattr(self, x))
			else:
				setattr(newobj, x, copy.copy(getattr(self, x)))

		newobj.posted = False
		if isinstance(env, str):
			newobj.env = self.bld.all_envs[env].derive()
		else:
			newobj.env = env.derive()

		return newobj

def declare_chain(name='', rule=None, reentrant=None, color='BLUE',
	ext_in=[], ext_out=[], before=[], after=[], decider=None, scan=None, install_path=None, shell=False):
	"""
	Creates a new mapping and a task class for processing files by extension.
	See Tools/flex.py for an example.

	:param name: name for the task class
	:type name: string
	:param rule: function to execute or string to be compiled in a function
	:type rule: string or function
	:param reentrant: re-inject the output file in the process (done automatically, set to 0 to disable)
	:type reentrant: int
	:param color: color for the task output
	:type color: string
	:param ext_in: execute the task only after the files of such extensions are created
	:type ext_in: list of string
	:param ext_out: execute the task only before files of such extensions are processed
	:type ext_out: list of string
	:param before: execute instances of this task before classes of the given names
	:type before: list of string
	:param after: execute instances of this task after classes of the given names
	:type after: list of string
	:param decider: if present, function that returns a list of output file extensions (overrides ext_out for output files, but not for the build order)
	:type decider: function
	:param scan: scanner function for the task
	:type scan: function
	:param install_path: installation path for the output nodes
	:type install_path: string
	"""
	ext_in = Utils.to_list(ext_in)
	ext_out = Utils.to_list(ext_out)
	if not name:
		name = rule
	cls = Task.task_factory(name, rule, color=color, ext_in=ext_in, ext_out=ext_out, before=before, after=after, scan=scan, shell=shell)

	def x_file(self, node):
		if ext_in:
			_ext_in = ext_in[0]

		tsk = self.create_task(name, node)
		cnt = 0

		ext = decider(self, node) if decider else cls.ext_out
		for x in ext:
			k = node.change_ext(x, ext_in=_ext_in)
			tsk.outputs.append(k)

			if reentrant != None:
				if cnt < int(reentrant):
					self.source.append(k)
			else:
				# reinject downstream files into the build
				for y in self.mappings: # ~ nfile * nextensions :-/
					if k.name.endswith(y):
						self.source.append(k)
						break
			cnt += 1

		if install_path:
			self.install_task = self.add_install_files(install_to=install_path, install_from=tsk.outputs)
		return tsk

	for x in cls.ext_in:
		task_gen.mappings[x] = x_file
	return x_file

def taskgen_method(func):
	"""
	Decorator that registers method as a task generator method.
	The function must accept a task generator as first parameter::

		from waflib.TaskGen import taskgen_method
		@taskgen_method
		def mymethod(self):
			pass

	:param func: task generator method to add
	:type func: function
	:rtype: function
	"""
	setattr(task_gen, func.__name__, func)
	return func

def feature(*k):
	"""
	Decorator that registers a task generator method that will be executed when the
	object attribute ``feature`` contains the corresponding key(s)::

		from waflib.TaskGen import feature
		@feature('myfeature')
		def myfunction(self):
			print('that is my feature!')
		def build(bld):
			bld(features='myfeature')

	:param k: feature names
	:type k: list of string
	"""
	def deco(func):
		setattr(task_gen, func.__name__, func)
		for name in k:
			feats[name].update([func.__name__])
		return func
	return deco

def before_method(*k):
	"""
	Decorator that registera task generator method which will be executed
	before the functions of given name(s)::

		from waflib.TaskGen import feature, before
		@feature('myfeature')
		@before_method('fun2')
		def fun1(self):
			print('feature 1!')
		@feature('myfeature')
		def fun2(self):
			print('feature 2!')
		def build(bld):
			bld(features='myfeature')

	:param k: method names
	:type k: list of string
	"""
	def deco(func):
		setattr(task_gen, func.__name__, func)
		for fun_name in k:
			task_gen.prec[func.__name__].add(fun_name)
		return func
	return deco
before = before_method

def after_method(*k):
	"""
	Decorator that registers a task generator method which will be executed
	after the functions of given name(s)::

		from waflib.TaskGen import feature, after
		@feature('myfeature')
		@after_method('fun2')
		def fun1(self):
			print('feature 1!')
		@feature('myfeature')
		def fun2(self):
			print('feature 2!')
		def build(bld):
			bld(features='myfeature')

	:param k: method names
	:type k: list of string
	"""
	def deco(func):
		setattr(task_gen, func.__name__, func)
		for fun_name in k:
			task_gen.prec[fun_name].add(func.__name__)
		return func
	return deco
after = after_method

def extension(*k):
	"""
	Decorator that registers a task generator method which will be invoked during
	the processing of source files for the extension given::

		from waflib import Task
		class mytask(Task):
			run_str = 'cp ${SRC} ${TGT}'
		@extension('.moo')
		def create_maa_file(self, node):
			self.create_task('mytask', node, node.change_ext('.maa'))
		def build(bld):
			bld(source='foo.moo')
	"""
	def deco(func):
		setattr(task_gen, func.__name__, func)
		for x in k:
			task_gen.mappings[x] = func
		return func
	return deco

@taskgen_method
def to_nodes(self, lst, path=None):
	"""
	Flatten the input list of string/nodes/lists into a list of nodes.

	It is used by :py:func:`waflib.TaskGen.process_source` and :py:func:`waflib.TaskGen.process_rule`.
	It is designed for source files, for folders, see :py:func:`waflib.Tools.ccroot.to_incnodes`:

	:param lst: input list
	:type lst: list of string and nodes
	:param path: path from which to search the nodes (by default, :py:attr:`waflib.TaskGen.task_gen.path`)
	:type path: :py:class:`waflib.Tools.Node.Node`
	:rtype: list of :py:class:`waflib.Tools.Node.Node`
	"""
	tmp = []
	path = path or self.path
	find = path.find_resource

	if isinstance(lst, Node.Node):
		lst = [lst]

	for x in Utils.to_list(lst):
		if isinstance(x, str):
			node = find(x)
		elif hasattr(x, 'name'):
			node = x
		else:
			tmp.extend(self.to_nodes(x))
			continue
		if not node:
			raise Errors.WafError('source not found: %r in %r' % (x, self))
		tmp.append(node)
	return tmp

@feature('*')
def process_source(self):
	"""
	Processes each element in the attribute ``source`` by extension.

	#. The *source* list is converted through :py:meth:`waflib.TaskGen.to_nodes` to a list of :py:class:`waflib.Node.Node` first.
	#. File extensions are mapped to methods having the signature: ``def meth(self, node)`` by :py:meth:`waflib.TaskGen.extension`
	#. The method is retrieved through :py:meth:`waflib.TaskGen.task_gen.get_hook`
	#. When called, the methods may modify self.source to append more source to process
	#. The mappings can map an extension or a filename (see the code below)
	"""
	self.source = self.to_nodes(getattr(self, 'source', []))
	for node in self.source:
		self.get_hook(node)(self, node)

@feature('*')
@before_method('process_source')
def process_rule(self):
	"""
	Processes the attribute ``rule``. When present, :py:meth:`waflib.TaskGen.process_source` is disabled::

		def build(bld):
			bld(rule='cp ${SRC} ${TGT}', source='wscript', target='bar.txt')

	Main attributes processed:

	* rule: command to execute, it can be a tuple of strings for multiple commands
	* chmod: permissions for the resulting files (integer value such as Utils.O755)
	* shell: set to False to execute the command directly (default is True to use a shell)
	* scan: scanner function
	* vars: list of variables to trigger rebuilds, such as CFLAGS
	* cls_str: string to display when executing the task
	* cls_keyword: label to display when executing the task
	* cache_rule: by default, try to re-use similar classes, set to False to disable
	* source: list of Node or string objects representing the source files required by this task
	* target: list of Node or string objects representing the files that this task creates
	* cwd: current working directory (Node or string)
	* stdout: standard output, set to None to prevent waf from capturing the text
	* stderr: standard error, set to None to prevent waf from capturing the text
	* timeout: timeout for command execution (Python 3)
	* always: whether to always run the command (False by default)
	* deep_inputs: whether the task must depend on the input file tasks too (False by default)
	"""
	if not getattr(self, 'rule', None):
		return

	# create the task class
	name = str(getattr(self, 'name', None) or self.target or getattr(self.rule, '__name__', self.rule))

	# or we can put the class in a cache for performance reasons
	try:
		cache = self.bld.cache_rule_attr
	except AttributeError:
		cache = self.bld.cache_rule_attr = {}

	chmod = getattr(self, 'chmod', None)
	shell = getattr(self, 'shell', True)
	color = getattr(self, 'color', 'BLUE')
	scan = getattr(self, 'scan', None)
	_vars = getattr(self, 'vars', [])
	cls_str = getattr(self, 'cls_str', None)
	cls_keyword = getattr(self, 'cls_keyword', None)
	use_cache = getattr(self, 'cache_rule', 'True')
	deep_inputs = getattr(self, 'deep_inputs', False)

	scan_val = has_deps = hasattr(self, 'deps')
	if scan:
		scan_val = id(scan)

	key = Utils.h_list((name, self.rule, chmod, shell, color, cls_str, cls_keyword, scan_val, _vars, deep_inputs))

	cls = None
	if use_cache:
		try:
			cls = cache[key]
		except KeyError:
			pass
	if not cls:
		rule = self.rule
		if chmod is not None:
			def chmod_fun(tsk):
				for x in tsk.outputs:
					os.chmod(x.abspath(), tsk.generator.chmod)
			if isinstance(rule, tuple):
				rule = list(rule)
				rule.append(chmod_fun)
				rule = tuple(rule)
			else:
				rule = (rule, chmod_fun)

		cls = Task.task_factory(name, rule, _vars, shell=shell, color=color)

		if cls_str:
			setattr(cls, '__str__', self.cls_str)

		if cls_keyword:
			setattr(cls, 'keyword', self.cls_keyword)

		if deep_inputs:
			Task.deep_inputs(cls)

		if scan:
			cls.scan = self.scan
		elif has_deps:
			def scan(self):
				deps = getattr(self.generator, 'deps', None)
				nodes = self.generator.to_nodes(deps)
				return [nodes, []]
			cls.scan = scan

		if use_cache:
			cache[key] = cls

	# now create one instance
	tsk = self.create_task(name)

	for x in ('after', 'before', 'ext_in', 'ext_out'):
		setattr(tsk, x, getattr(self, x, []))

	if hasattr(self, 'stdout'):
		tsk.stdout = self.stdout

	if hasattr(self, 'stderr'):
		tsk.stderr = self.stderr

	if getattr(self, 'timeout', None):
		tsk.timeout = self.timeout

	if getattr(self, 'always', None):
		tsk.always_run = True

	if getattr(self, 'target', None):
		if isinstance(self.target, str):
			self.target = self.target.split()
		if not isinstance(self.target, list):
			self.target = [self.target]
		for x in self.target:
			if isinstance(x, str):
				tsk.outputs.append(self.path.find_or_declare(x))
			else:
				x.parent.mkdir() # if a node was given, create the required folders
				tsk.outputs.append(x)
		if getattr(self, 'install_path', None):
			self.install_task = self.add_install_files(install_to=self.install_path,
				install_from=tsk.outputs, chmod=getattr(self, 'chmod', Utils.O644))

	if getattr(self, 'source', None):
		tsk.inputs = self.to_nodes(self.source)
		# bypass the execution of process_source by setting the source to an empty list
		self.source = []

	if getattr(self, 'cwd', None):
		tsk.cwd = self.cwd

	if isinstance(tsk.run, functools.partial):
		# Python documentation says: "partial objects defined in classes
		# behave like static methods and do not transform into bound
		# methods during instance attribute look-up."
		tsk.run = functools.partial(tsk.run, tsk)

@feature('seq')
def sequence_order(self):
	"""
	Adds a strict sequential constraint between the tasks generated by task generators.
	It works because task generators are posted in order.
	It will not post objects which belong to other folders.

	Example::

		bld(features='javac seq')
		bld(features='jar seq')

	To start a new sequence, set the attribute seq_start, for example::

		obj = bld(features='seq')
		obj.seq_start = True

	Note that the method is executed in last position. This is more an
	example than a widely-used solution.
	"""
	if self.meths and self.meths[-1] != 'sequence_order':
		self.meths.append('sequence_order')
		return

	if getattr(self, 'seq_start', None):
		return

	# all the tasks previously declared must be run before these
	if getattr(self.bld, 'prev', None):
		self.bld.prev.post()
		for x in self.bld.prev.tasks:
			for y in self.tasks:
				y.set_run_after(x)

	self.bld.prev = self


re_m4 = re.compile(r'@(\w+)@', re.M)

class subst_pc(Task.Task):
	"""
	Creates *.pc* files from *.pc.in*. The task is executed whenever an input variable used
	in the substitution changes.
	"""

	def force_permissions(self):
		"Private for the time being, we will probably refactor this into run_str=[run1,chmod]"
		if getattr(self.generator, 'chmod', None):
			for x in self.outputs:
				os.chmod(x.abspath(), self.generator.chmod)

	def run(self):
		"Substitutes variables in a .in file"

		if getattr(self.generator, 'is_copy', None):
			for i, x in enumerate(self.outputs):
				x.write(self.inputs[i].read('rb'), 'wb')
				stat = os.stat(self.inputs[i].abspath()) # Preserve mtime of the copy
				os.utime(self.outputs[i].abspath(), (stat.st_atime, stat.st_mtime))
			self.force_permissions()
			return None

		if getattr(self.generator, 'fun', None):
			ret = self.generator.fun(self)
			if not ret:
				self.force_permissions()
			return ret

		code = self.inputs[0].read(encoding=getattr(self.generator, 'encoding', 'latin-1'))
		if getattr(self.generator, 'subst_fun', None):
			code = self.generator.subst_fun(self, code)
			if code is not None:
				self.outputs[0].write(code, encoding=getattr(self.generator, 'encoding', 'latin-1'))
			self.force_permissions()
			return None

		# replace all % by %% to prevent errors by % signs
		code = code.replace('%', '%%')

		# extract the vars foo into lst and replace @foo@ by %(foo)s
		lst = []
		def repl(match):
			g = match.group
			if g(1):
				lst.append(g(1))
				return "%%(%s)s" % g(1)
			return ''
		code = getattr(self.generator, 're_m4', re_m4).sub(repl, code)

		try:
			d = self.generator.dct
		except AttributeError:
			d = {}
			for x in lst:
				tmp = getattr(self.generator, x, '') or self.env[x] or self.env[x.upper()]
				try:
					tmp = ''.join(tmp)
				except TypeError:
					tmp = str(tmp)
				d[x] = tmp

		code = code % d
		self.outputs[0].write(code, encoding=getattr(self.generator, 'encoding', 'latin-1'))
		self.generator.bld.raw_deps[self.uid()] = lst

		# make sure the signature is updated
		try:
			delattr(self, 'cache_sig')
		except AttributeError:
			pass

		self.force_permissions()

	def sig_vars(self):
		"""
		Compute a hash (signature) of the variables used in the substitution
		"""
		bld = self.generator.bld
		env = self.env
		upd = self.m.update

		if getattr(self.generator, 'fun', None):
			upd(Utils.h_fun(self.generator.fun).encode())
		if getattr(self.generator, 'subst_fun', None):
			upd(Utils.h_fun(self.generator.subst_fun).encode())

		# raw_deps: persistent custom values returned by the scanner
		vars = self.generator.bld.raw_deps.get(self.uid(), [])

		# hash both env vars and task generator attributes
		act_sig = bld.hash_env_vars(env, vars)
		upd(act_sig)

		lst = [getattr(self.generator, x, '') for x in vars]
		upd(Utils.h_list(lst))

		return self.m.digest()

@extension('.pc.in')
def add_pcfile(self, node):
	"""
	Processes *.pc.in* files to *.pc*. Installs the results to ``${PREFIX}/lib/pkgconfig/`` by default

		def build(bld):
			bld(source='foo.pc.in', install_path='${LIBDIR}/pkgconfig/')
	"""
	tsk = self.create_task('subst_pc', node, node.change_ext('.pc', '.pc.in'))
	self.install_task = self.add_install_files(
		install_to=getattr(self, 'install_path', '${LIBDIR}/pkgconfig/'), install_from=tsk.outputs)

class subst(subst_pc):
	pass

@feature('subst')
@before_method('process_source', 'process_rule')
def process_subst(self):
