eed_estimate(const mavlink_message_t &msg)
{
    AP_VisualOdom *visual_odom = AP::visualodom();
    if (visual_odom == nullptr) {
        return;
    }
    mavlink_vision_speed_estimate_t m;
    mavlink_msg_vision_speed_estimate_decode(&msg, &m);
    const Vector3f vel = {m.x, m.y, m.z};
    uint32_t timestamp_ms = correct_offboard_timestamp_usec_to_ms(m.usec, PAYLOAD_SIZE(chan, VISION_SPEED_ESTIMATE));
    visual_odom->handle_vision_speed_estimate(m.usec, timestamp_ms, vel, m.reset_counter, 0);
}
#endif  // HAL_VISUALODOM_ENABLED

void GCS_MAVLINK::handle_command_ack(const mavlink_message_t &msg)
{
#if HAL_INS_ACCELCAL_ENABLED
    mavlink_command_ack_t packet;
    mavlink_msg_command_ack_decode(&msg, &packet);

    AP_AccelCal *accelcal = AP::ins().get_acal();
    if (accelcal != nullptr) {
        accelcal->handle_command_ack(packet);
    }
#endif
}

#if AP_RC_CHANNEL_ENABLED
// allow override of RC channel values for complete GCS
// control of switch position and RC PWM values.
void GCS_MAVLINK::handle_rc_channels_override(const mavlink_message_t &msg)
{
    if(msg.sysid != sysid_my_gcs()) {
        return; // Only accept control from our gcs
    }

    const uint32_t tnow = AP_HAL::millis();

    mavlink_rc_channels_override_t packet;
    mavlink_msg_rc_channels_override_decode(&msg, &packet);

    const uint16_t override_data[] = {
        packet.chan1_raw,
        packet.chan2_raw,
        packet.chan3_raw,
        packet.chan4_raw,
        packet.chan5_raw,
        packet.chan6_raw,
        packet.chan7_raw,
        packet.chan8_raw,
        packet.chan9_raw,
        packet.chan10_raw,
        packet.chan11_raw,
        packet.chan12_raw,
        packet.chan13_raw,
        packet.chan14_raw,
        packet.chan15_raw,
        packet.chan16_raw
    };

    for (uint8_t i=0; i<8; i++) {
        // Per MAVLink spec a value of UINT16_MAX means to ignore this field.
        if (override_data[i] != UINT16_MAX) {
            RC_Channels::set_override(i, override_data[i], tnow);
        }
    }
    for (uint8_t i=8; i<ARRAY_SIZE(override_data); i++) {
        // Per MAVLink spec a value of zero or UINT16_MAX means to
        // ignore this field.
        if (override_data[i] != 0 && override_data[i] != UINT16_MAX) {
            // per the mavlink spec, a value of UINT16_MAX-1 means
            // return the field to RC radio values:
            const uint16_t value = override_data[i] == (UINT16_MAX-1) ? 0 : override_data[i];
            RC_Channels::set_override(i, value, tnow);
        }
    }

    gcs().sysid_myggcs_seen(tnow);

}
#endif  // AP_RC_CHANNEL_ENABLED

#if AP_OPTICALFLOW_ENABLED
void GCS_MAVLINK::handle_optical_flow(const mavlink_message_t &msg)
{
    AP_OpticalFlow *optflow = AP::opticalflow();
    if (optflow == nullptr) {
        return;
    }
    optflow->handle_msg(msg);
}
#endif


#if AP_COMPASS_CALIBRATION_FIXED_YAW_ENABLED
/*
  handle MAV_CMD_FIXED_MAG_CAL_YAW
 */
MAV_RESULT GCS_MAVLINK::handle_command_fixed_mag_cal_yaw(const mavlink_command_int_t &packet)
{
    Compass &compass = AP::compass();
    if (!compass.mag_cal_fixed_yaw(packet.param1,
                                   uint8_t(packet.param2),
                                   packet.param3,
                                   packet.param4)) {
        return MAV_RESULT_FAILED;
    }
    return MAV_RESULT_ACCEPTED;
}
#endif  // AP_COMPASS_CALIBRATION_FIXED_YAW_ENABLED

#if COMPASS_CAL_ENABLED
MAV_RESULT GCS_MAVLINK::handle_command_mag_cal(const mavlink_command_int_t &packet)
{
    return AP::compass().handle_mag_cal_command(packet);
}
#endif  // COMPASS_CAL_ENABLED

#if HAL_CANMANAGER_ENABLED
/*
  handle MAV_CMD_CAN_FORWARD
 */
MAV_RESULT GCS_MAVLINK::handle_can_forward(const mavlink_command_int_t &packet, const mavlink_message_t &msg)
{
    return AP::can().handle_can_forward(chan, packet, msg) ? MAV_RESULT_ACCEPTED : MAV_RESULT_FAILED;
}

/*
  handle CAN_FRAME messages
 */
void GCS_MAVLINK::handle_can_frame(const mavlink_message_t &msg) const
{
    AP::can().handle_can_frame(msg);
}
#endif  // HAL_CANMANAGER_ENABLED

void GCS_MAVLINK::handle_distance_sensor(const mavlink_message_t &msg)
{
#if AP_RANGEFINDER_ENABLED
    RangeFinder *rangefinder = AP::rangefinder();
    if (rangefinder != nullptr) {
        rangefinder->handle_msg(msg);
    }
#endif

#if HAL_PROXIMITY_ENABLED
    AP_Proximity *proximity = AP::proximity();
    if (proximity != nullptr) {
        proximity->handle_msg(msg);
    }
#endif
}

#if HAL_PROXIMITY_ENABLED
void GCS_MAVLINK::handle_obstacle_distance(const mavlink_message_t &msg)
{
    AP_Proximity *proximity = AP::proximity();
    if (proximity != nullptr) {
        proximity->handle_msg(msg);
    }
}

void GCS_MAVLINK::handle_obstacle_distance_3d(const mavlink_message_t &msg)
{
    AP_Proximity *proximity = AP::proximity();
    if (proximity != nullptr) {
        proximity->handle_msg(msg);
    }
}
#endif

#if HAL_ADSB_ENABLED
void GCS_MAVLINK::handle_adsb_message(const mavlink_message_t &msg)
{
    AP_ADSB *adsb = AP::ADSB();
    if (adsb != nullptr) {
        adsb->handle_message(chan, msg);
    }
}
#endif

#if OSD_PARAM_ENABLED
void GCS_MAVLINK::handle_osd_param_config(const mavlink_message_t &msg) const
{
    AP_OSD *osd = AP::osd();
    if (osd != nullptr) {
        osd->handle_msg(msg, *this);
    }
}
#endif

void GCS_MAVLINK::handle_heartbeat(const mavlink_message_t &msg) const
{
    // if the heartbeat is from our GCS then we don't failsafe for
    // now...
    if (msg.sysid == sysid_my_gcs()) {
        gcs().sysid_myggcs_seen(AP_HAL::millis());
    }
}

/*
  handle messages which don't require vehicle specific data
 */
void GCS_MAVLINK::handle_message(const mavlink_message_t &msg)
{
    switch (msg.msgid) {

    case MAVLINK_MSG_ID_HEARTBEAT: {
        handle_heartbeat(msg);
        break;
    }

    case MAVLINK_MSG_ID_COMMAND_ACK: {
        handle_command_ack(msg);
        break;
    }

    case MAVLINK_MSG_ID_SETUP_SIGNING:
        handle_setup_signing(msg);
        break;

    case MAVLINK_MSG_ID_PARAM_REQUEST_LIST:
    case MAVLINK_MSG_ID_PARAM_SET:
    case MAVLINK_MSG_ID_PARAM_REQUEST_READ:
        handle_common_param_message(msg);
        break;

#if AP_AHRS_ENABLED
    case MAVLINK_MSG_ID_SET_GPS_GLOBAL_ORIGIN:
        handle_set_gps_global_origin(msg);
        break;
#endif

#if AP_MAVLINK_MSG_DEVICE_OP_ENABLED
    case MAVLINK_MSG_ID_DEVICE_OP_READ:
        handle_device_op_read(msg);
        break;
    case MAVLINK_MSG_ID_DEVICE_OP_WRITE:
        handle_device_op_write(msg);
        break;
#endif

    case MAVLINK_MSG_ID_TIMESYNC:
        handle_timesync(msg);
        break;
#if HAL_LOGGING_ENABLED
    case MAVLINK_MSG_ID_LOG_REQUEST_LIST:
    case MAVLINK_MSG_ID_LOG_REQUEST_DATA:
    case MAVLINK_MSG_ID_LOG_ERASE:
    case MAVLINK_MSG_ID_LOG_REQUEST_END:
    case MAVLINK_MSG_ID_REMOTE_LOG_BLOCK_STATUS:
        AP::logger().handle_mavlink_msg(*this, msg);
        break;
#endif

#if AP_MAVLINK_FTP_ENABLED
    case MAVLINK_MSG_ID_FILE_TRANSFER_PROTOCOL:
        handle_file_transfer_protocol(msg);
        break;
#endif

#if AP_CAMERA_ENABLED
    case MAVLINK_MSG_ID_DIGICAM_CONTROL:
    case MAVLINK_MSG_ID_GOPRO_HEARTBEAT: // heartbeat from a GoPro in Solo gimbal
    case MAVLINK_MSG_ID_CAMERA_INFORMATION:
        {
            AP_Camera *camera = AP::camera();
            if (camera == nullptr) {
                return;
            }
            camera->handle_message(chan, msg);
        }
        break;
#endif

    case MAVLINK_MSG_ID_SET_MODE:
        handle_set_mode(msg);
        break;

#if AP_MAVLINK_AUTOPILOT_VERSION_REQUEST_ENABLED
    case MAVLINK_MSG_ID_AUTOPILOT_VERSION_REQUEST:
        handle_send_autopilot_version(msg);
        break;
#endif

    case MAVLINK_MSG_ID_MISSION_WRITE_PARTIAL_LIST:
    case MAVLINK_MSG_ID_MISSION_REQUEST_LIST:
    case MAVLINK_MSG_ID_MISSION_COUNT:
    case MAVLINK_MSG_ID_MISSION_CLEAR_ALL:
    case MAVLINK_MSG_ID_MISSION_ITEM:
    case MAVLINK_MSG_ID_MISSION_ITEM_INT:
    case MAVLINK_MSG_ID_MISSION_REQUEST_INT:
    case MAVLINK_MSG_ID_MISSION_REQUEST:
    case MAVLINK_MSG_ID_MISSION_ACK:
    case MAVLINK_MSG_ID_MISSION_SET_CURRENT:
        handle_common_mission_message(msg);
        break;

    case MAVLINK_MSG_ID_COMMAND_LONG:
        handle_command_long(msg);
        break;

    case MAVLINK_MSG_ID_COMMAND_INT:
        handle_command_int(msg);
        break;

#if AC_POLYFENCE_FENCE_POINT_PROTOCOL_SUPPORT
    case MAVLINK_MSG_ID_FENCE_POINT:
    case MAVLINK_MSG_ID_FENCE_FETCH_POINT:
        send_received_message_deprecation_warning("FENCE_FETCH_POINT");
        handle_fence_message(msg);
        break;
#endif

#if HAL_MOUNT_ENABLED
#if AP_MAVLINK_MSG_MOUNT_CONFIGURE_ENABLED
    case MAVLINK_MSG_ID_MOUNT_CONFIGURE: // deprecated. Use MAV_CMD_DO_MOUNT_CONFIGURE
        send_received_message_deprecation_warning("MOUNT_CONFIGURE");
        handle_mount_message(msg);
        break;
#endif
#if AP_MAVLINK_MSG_MOUNT_CONTROL_ENABLED
    case MAVLINK_MSG_ID_MOUNT_CONTROL: // deprecated. Use MAV_CMD_DO_MOUNT_CONTROL
        send_received_message_deprecation_warning("MOUNT_CONTROL");
        handle_mount_message(msg);
        break;
#endif
    case MAVLINK_MSG_ID_GIMBAL_REPORT:
    case MAVLINK_MSG_ID_GIMBAL_DEVICE_INFORMATION:
    case MAVLINK_MSG_ID_GIMBAL_DEVICE_ATTITUDE_STATUS:
    case MAVLINK_MSG_ID_GIMBAL_MANAGER_SET_ATTITUDE:
    case MAVLINK_MSG_ID_GIMBAL_MANAGER_SET_PITCHYAW:
        handle_mount_message(msg);
        break;
#endif

    case MAVLINK_MSG_ID_PARAM_VALUE:
        handle_param_value(msg);
        break;

    case MAVLINK_MSG_ID_RADIO:
    case MAVLINK_MSG_ID_RADIO_STATUS:
        handle_radio_status(msg);
        break;

#if AP_MAVLINK_MSG_SERIAL_CONTROL_ENABLED
    case MAVLINK_MSG_ID_SERIAL_CONTROL:
        handle_serial_control(msg);
        break;
#endif

#if AP_GPS_ENABLED
#if AP_MAVLINK_MSG_HIL_GPS_ENABLED
    case MAVLINK_MSG_ID_HIL_GPS:
        send_received_message_deprecation_warning("HIL_GPS");
        FALLTHROUGH;
#endif
    case MAVLINK_MSG_ID_GPS_RTCM_DATA:
    case MAVLINK_MSG_ID_GPS_INPUT:
    case MAVLINK_MSG_ID_GPS_INJECT_DATA:
        AP::gps().handle_msg(chan, msg);
        break;
#endif

    case MAVLINK_MSG_ID_STATUSTEXT:
        handle_statustext(msg);
        break;

#if AP_NOTIFY_MAVLINK_LED_CONTROL_SUPPORT_ENABLED
    case MAVLINK_MSG_ID_LED_CONTROL:
        // send message to Notify
        AP_Notify::handle_led_control(msg);
        break;
#endif

#if AP_RC_CHANNEL_ENABLED
    case MAVLINK_MSG_ID_MANUAL_CONTROL:
        handle_manual_control(msg);
        break;
#endif

#if AP_NOTIFY_MAVLINK_PLAY_TUNE_SUPPORT_ENABLED
    case MAVLINK_MSG_ID_PLAY_TUNE:
        // send message to Notify
        AP_Notify::handle_play_tune(msg);
        break;
#endif

#if AP_MAVLINK_RALLY_POINT_PROTOCOL_ENABLED
    case MAVLINK_MSG_ID_RALLY_POINT:
    case MAVLINK_MSG_ID_RALLY_FETCH_POINT:
        send_received_message_deprecation_warning("RALLY_FETCH_POINT");
        handle_common_rally_message(msg);
        break;
#endif

    case MAVLINK_MSG_ID_REQUEST_DATA_STREAM:
        // only pass if override is not selected 
        if (!(_port->get_options() & _port->OPTION_NOSTREAMOVERRIDE)) {
            handle_request_data_stream(msg);
        }
        break;

    case MAVLINK_MSG_ID_DATA96:
        handle_data_packet(msg);
        break;        

#if HAL_VISUALODOM_ENABLED
    case MAVLINK_MSG_ID_VISION_POSITION_DELTA:
        handle_vision_position_delta(msg);
        break;

    case MAVLINK_MSG_ID_VISION_POSITION_ESTIMATE:
        handle_vision_position_estimate(msg);
        break;

    case MAVLINK_MSG_ID_GLOBAL_VISION_POSITION_ESTIMATE:
        handle_global_vision_position_estimate(msg);
        break;

    case MAVLINK_MSG_ID_VICON_POSITION_ESTIMATE:
        handle_vicon_position_estimate(msg);
        break;

    case MAVLINK_MSG_ID_ODOMETRY:
        handle_odometry(msg);
        break;

    case MAVLINK_MSG_ID_ATT_POS_MOCAP:
        handle_att_pos_mocap(msg);
        break;

    case MAVLINK_MSG_ID_VISION_SPEED_ESTIMATE:
        handle_vision_speed_estimate(msg);
        break;
#endif  // HAL_VISUALODOM_ENABLED

#if AP_RTC_ENABLED
    case MAVLINK_MSG_ID_SYSTEM_TIME:
        handle_system_time_message(msg);
        break;
#endif

#if AP_RC_CHANNEL_ENABLED
    case MAVLINK_MSG_ID_RC_CHANNELS_OVERRIDE:
        handle_rc_channels_override(msg);
        break;
#if AP_RCPROTOCOL_MAVLINK_RADIO_ENABLED
    case MAVLINK_MSG_ID_RADIO_RC_CHANNELS:
        handle_radio_rc_channels(msg);
        break;
#endif
#endif

#if AP_OPTICALFLOW_ENABLED
    case MAVLINK_MSG_ID_OPTICAL_FLOW:
        handle_optical_flow(msg);
        break;
#endif

    case MAVLINK_MSG_ID_DISTANCE_SENSOR:
        handle_distance_sensor(msg);
        break;

#if HAL_PROXIMITY_ENABLED
    case MAVLINK_MSG_ID_OBSTACLE_DISTANCE:
        handle_obstacle_distance(msg);
        break;

    case MAVLINK_MSG_ID_OBSTACLE_DISTANCE_3D:
        handle_obstacle_distance_3d(msg);
        break;
#endif

#if OSD_PARAM_ENABLED
    case MAVLINK_MSG_ID_OSD_PARAM_CONFIG:
    case MAVLINK_MSG_ID_OSD_PARAM_SHOW_CONFIG:
        handle_osd_param_config(msg);
        break;
#endif

#if HAL_ADSB_ENABLED
    case MAVLINK_MSG_ID_ADSB_VEHICLE:
    case MAVLINK_MSG_ID_UAVIONIX_ADSB_OUT_CFG:
    case MAVLINK_MSG_ID_UAVIONIX_ADSB_OUT_DYNAMIC:
    case MAVLINK_MSG_ID_UAVIONIX_ADSB_TRANSCEIVER_HEALTH_REPORT:
    case MAVLINK_MSG_ID_UAVIONIX_ADSB_OUT_CONTROL:
        handle_adsb_message(msg);
        break;
#endif

    case MAVLINK_MSG_ID_LANDING_TARGET:
        handle_landing_target(msg);
        break;

    case MAVLINK_MSG_ID_NAMED_VALUE_FLOAT:
        handle_named_value(msg);
        break;

#if HAL_CANMANAGER_ENABLED
    case MAVLINK_MSG_ID_CAN_FRAME:
    case MAVLINK_MSG_ID_CANFD_FRAME:
        handle_can_frame(msg);
        break;
#endif

#if HAL_CANMANAGER_ENABLED
    case MAVLINK_MSG_ID_CAN_FILTER_MODIFY:
        AP::can().handle_can_filter_modify(msg);
        break;
#endif

#if AP_OPENDRONEID_ENABLED
    case MAVLINK_MSG_ID_OPEN_DRONE_ID_ARM_STATUS:
    case MAVLINK_MSG_ID_OPEN_DRONE_ID_OPERATOR_ID:
    case MAVLINK_MSG_ID_OPEN_DRONE_ID_SELF_ID:
    case MAVLINK_MSG_ID_OPEN_DRONE_ID_BASIC_ID:
    case MAVLINK_MSG_ID_OPEN_DRONE_ID_SYSTEM:
    case MAVLINK_MSG_ID_OPEN_DRONE_ID_SYSTEM_UPDATE:
        AP::opendroneid().handle_msg(chan, msg);
        break;
#endif

#if AP_SIGNED_FIRMWARE
    case MAVLINK_MSG_ID_SECURE_COMMAND:
    case MAVLINK_MSG_ID_SECURE_COMMAND_REPLY:
        AP_CheckFirmware::handle_msg(chan, msg);
        break;
#endif

#if AP_EFI_MAV_ENABLED
    case MAVLINK_MSG_ID_EFI_STATUS:
    {
        AP_EFI *efi = AP::EFI();
        if (efi) {
            efi->handle_EFI_message(msg);
        }
        break;
    }
#endif
    }

}

void GCS_MAVLINK::handle_common_mission_message(const mavlink_message_t &msg)
{
    switch (msg.msgid) {
    case MAVLINK_MSG_ID_MISSION_WRITE_PARTIAL_LIST: // MAV ID: 38
    {
        handle_mission_write_partial_list(msg);
        break;
    }

    // GCS has sent us a mission item, store to EEPROM
    case MAVLINK_MSG_ID_MISSION_ITEM:           // MAV ID: 39
    case MAVLINK_MSG_ID_MISSION_ITEM_INT:
        handle_mission_item(msg);
        break;

    // read an individual command from EEPROM and send it to the GCS
    case MAVLINK_MSG_ID_MISSION_REQUEST_INT:
        handle_mission_request_int(msg);
        break;

#if AP_MAVLINK_MSG_MISSION_REQUEST_ENABLED
    case MAVLINK_MSG_ID_MISSION_REQUEST:
        handle_mission_request(msg);
        break;
#endif

#if AP_MAVLINK_MISSION_SET_CURRENT_ENABLED
    case MAVLINK_MSG_ID_MISSION_SET_CURRENT:    // MAV ID: 41
    {
        AP_Mission *_mission = AP::mission();
        if (_mission != nullptr) {
            handle_mission_set_current(*_mission, msg);
        }
        break;
    }
#endif

    // GCS request the full list of commands, we return just the number and leave the GCS to then request each command individually
    case MAVLINK_MSG_ID_MISSION_REQUEST_LIST:       // MAV ID: 43
    {
        handle_mission_request_list(msg);
        break;
    }

    // GCS provides the full number of commands it wishes to upload
    //  individual commands will then be sent from the GCS using the MAVLINK_MSG_ID_MISSION_ITEM message
    case MAVLINK_MSG_ID_MISSION_COUNT:          // MAV ID: 44
    {
        handle_mission_count(msg);
        break;
    }

    case MAVLINK_MSG_ID_MISSION_CLEAR_ALL:      // MAV ID: 45
    {
        handle_mission_clear_all(msg);
        break;
    }

    case MAVLINK_MSG_ID_MISSION_ACK:
        /* not used */
        break;
    }
}

#if AP_MAVLINK_AUTOPILOT_VERSION_REQUEST_ENABLED
void GCS_MAVLINK::handle_send_autopilot_version(const mavlink_message_t &msg)
{
    send_message(MSG_AUTOPILOT_VERSION);
}
#endif

void GCS_MAVLINK::send_banner()
{
    // mark the firmware version in the tlog
    const AP_FWVersion &fwver = AP::fwversion();

    send_text(MAV_SEVERITY_INFO, "%s", fwver.fw_string);

    if (fwver.middleware_name && fwver.os_name) {
        send_text(MAV_SEVERITY_INFO, "%s: %s %s: %s",
                  fwver.middleware_name, fwver.middleware_hash_str,
                  fwver.os_name, fwver.os_hash_str);
    } else if (fwver.os_name) {
        send_text(MAV_SEVERITY_INFO, "%s: %s",
                  fwver.os_name, fwver.os_hash_str);
    }

    // send system ID if we can
    char sysid[50];
    if (hal.util->get_system_id(sysid)) {
        send_text(MAV_SEVERITY_INFO, "%s", sysid);
    }

    // send MCUID if we can
#if HAL_WITH_IO_MCU
#define REVID_MASK	0xFFFF0000
#define DEVID_MASK	0xFFF
    if (AP_BoardConfig::io_enabled()) {
        uint32_t mcuid = iomcu.get_mcu_id();
        send_text(MAV_SEVERITY_INFO, "IOMCU: %x %x %lx", uint16_t(mcuid & DEVID_MASK), uint16_t((mcuid & REVID_MASK) >> 16U),
            iomcu.get_cpu_id());
    }
#endif

    // send RC output mode info if available
    char banner_msg[50];
    if (hal.rcout->get_output_mode_banner(banner_msg, sizeof(banner_msg))) {
        send_text(MAV_SEVERITY_INFO, "%s", banner_msg);
    }

#if AP_INERTIALSENSOR_ENABLED
    // output any fast sampling status messages
    for (uint8_t i = 0; i < INS_MAX_BACKENDS; i++) {
        if (AP::ins().get_output_banner(i, banner_msg, sizeof(banner_msg))) {
            send_text(MAV_SEVERITY_INFO, "%s", banner_msg);
        }
    }
#endif
}


#if AP_SIM_ENABLED
void GCS_MAVLINK::send_simstate() const
{
    SITL::SIM *sitl = AP::sitl();
    if (sitl == nullptr) {
        return;
    }
    sitl->simstate_send(get_chan());
}

void GCS_MAVLINK::send_sim_state() const
{
    SITL::SIM *sitl = AP::sitl();
    if (sitl == nullptr) {
        return;
    }
    sitl->sim_state_send(get_chan());
}
#endif

#if AP_BOOTLOADER_FLASHING_ENABLED
MAV_RESULT GCS_MAVLINK::handle_command_flash_bootloader(const mavlink_command_int_t &packet)
{
    if (packet.x != 290876) {
        GCS_SEND_TEXT(MAV_SEVERITY_INFO, "Magic not set");
        return MAV_RESULT_FAILED;
    }

    switch (hal.util->flash_bootloader()) {
    case AP_HAL::Util::FlashBootloader::OK:
    case AP_HAL::Util::FlashBootloader::NO_CHANGE:
        // consider NO_CHANGE as success (so as not to display error to user)
        return MAV_RESULT_ACCEPTED;
#if AP_SIGNED_FIRMWARE
    case AP_HAL::Util::FlashBootloader::NOT_SIGNED:
        GCS_SEND_TEXT(MAV_SEVERITY_ERROR, "Bootloader not signed");
        break;
#endif
    default:
        break;
    }

    return MAV_RESULT_FAILED;
}
#endif  // AP_BOOTLOADER_FLASHING_ENABLED

MAV_RESULT GCS_MAVLINK::_handle_command_preflight_calibration_baro(const mavlink_message_t &msg)
{
    // fast barometer calibration
    GCS_SEND_TEXT(MAV_SEVERITY_INFO, "Updating barometer calibration");
    AP::baro().update_calibration();
    GCS_SEND_TEXT(MAV_SEVERITY_INFO, "Barometer calibration complete");

#if AP_AIRSPEED_ENABLED

    AP_Airspeed *airspeed = AP_Airspeed::get_singleton();
    if (airspeed != nullptr) {
        GCS_MAVLINK_InProgress *task = GCS_MAVLINK_InProgress::get_task(MAV_CMD_PREFLIGHT_CALIBRATION, GCS_MAVLINK_InProgress::Type::AIRSPEED_CAL, msg.sysid, msg.compid, chan);
        if (task == nullptr) {
            return MAV_RESULT_TEMPORARILY_REJECTED;
        }
        airspeed->calibrate(false);
        return MAV_RESULT_IN_PROGRESS;
    }
#endif

    return MAV_RESULT_ACCEPTED;
}

MAV_RESULT GCS_MAVLINK::_handle_command_preflight_calibration(const mavlink_command_int_t &packet, const mavlink_message_t &msg)
{
    MAV_RESULT ret = MAV_RESULT_UNSUPPORTED;

    EXPECT_DELAY_MS(30000);
    if (is_equal(packet.param1,1.0f)) {
#if AP_INERTIALSENSOR_ENABLED
        if (!AP::ins().calibrate_gyros()) {
            return MAV_RESULT_FAILED;
        }
#else
        return MAV_RESULT_UNSUPPORTED;
#endif
        return MAV_RESULT_ACCEPTED;
    }

    if (is_equal(packet.param3,1.0f)) {
        return _handle_command_preflight_calibration_baro(msg);
    }

#if AP_RC_CHANNEL_ENABLED
    rc().calibrating(is_positive(packet.param4));
#endif

#if HAL_INS_ACCELCAL_ENABLED
    if (packet.x == 1) {
        // start with gyro calibration
        if (!AP::ins().calibrate_gyros()) {
            return MAV_RESULT_FAILED;
        }
        // start accel cal
        AP::ins().acal_init();
        AP::ins().get_acal()->start(this);
        return MAV_RESULT_ACCEPTED;
    }
#endif

#if AP_INERTIALSENSOR_ENABLED
#if AP_AHRS_ENABLED
    if (packet.x == 2) {
        return AP::ins().calibrate_trim();
    }
#endif

    if (packet.x == 4) {
        // simple accel calibration
        return AP::ins().simple_accel_cal();
    }

    /*
      allow GCS to force an existing calibration of accel and/or
      compass to be written as valid. This is useful when reloading
      parameters after a full parameter erase
     */
    if (packet.x == 76) {
        // force existing accel calibration to be accepted as valid
        AP::ins().force_save_calibration();
        ret = MAV_RESULT_ACCEPTED;
    }
#endif  // AP_INERTIALSENSOR_ENABLED

#if AP_COMPASS_ENABLED
    if (is_equal(packet.param2,76.0f)) {
        // force existing compass calibration to be accepted as valid
        AP::compass().force_save_calibration();
        ret = MAV_RESULT_ACCEPTED;
    }
#endif

    return ret;
}

MAV_RESULT GCS_MAVLINK::handle_command_preflight_calibration(const mavlink_command_int_t &packet, const mavlink_message_t &msg)
{
    if (hal.util->get_soft_armed()) {
        // *preflight*, remember?
        GCS_SEND_TEXT(MAV_SEVERITY_NOTICE, "Disarm to allow calibration");
        return MAV_RESULT_FAILED;
    }
    // now call subclass methods:
    return _handle_command_preflight_calibration(packet, msg);
}

#if AP_ARMING_ENABLED
MAV_RESULT GCS_MAVLINK::handle_command_run_prearm_checks(const mavlink_command_int_t &packet)
{
    if (hal.util->get_soft_armed()) {
        return MAV_RESULT_TEMPORARILY_REJECTED;
    }
    (void)AP::arming().pre_arm_checks(true);
    return MAV_RESULT_ACCEPTED;
}
#endif  // AP_ARMING_ENABLED

#if AP_MISSION_ENABLED
// changes the current waypoint; at time of writing GCS
// implementations use the mavlink message MISSION_SET_CURRENT to set
// the current waypoint, rather than this DO command.  It is hoped we
// can move to this command in the future to avoid acknowledgement
// issues with MISSION_SET_CURRENT
MAV_RESULT GCS_MAVLINK::handle_command_do_set_mission_current(const mavlink_command_int_t &packet)
{
    AP_Mission *mission = AP::mission();
    if (mission == nullptr) {
        return MAV_RESULT_UNSUPPORTED;
    }

    const uint32_t seq = (uint32_t)packet.param1;
    if (!mission->is_valid_index(seq)) {
        return MAV_RESULT_DENIED;
    }

    // From https://mavlink.io/en/messages/common.html#MAV_CMD_DO_SET_MISSION_CURRENT:
    //   Param 2: Reset Mission
    //     - Resets mission. 1: true, 0: false. Resets jump counters to initial values
    //       and changes mission state "completed" to be "active" or "paused".
    const bool reset_and_restart = is_equal(packet.param2, 1.0f);
    if (reset_and_restart) {
        mission->reset();
    }
    if (!mission->set_current_cmd(seq)) {
        return MAV_RESULT_FAILED;
    }
    if (reset_and_restart) {
        mission->resume();
    }

    // volunteer the new current waypoint for all listeners
    send_message(MSG_CURRENT_WAYPOINT);

    return MAV_RESULT_ACCEPTED;
}

MAV_RESULT GCS_MAVLINK::handle_command_do_jump_tag(const mavlink_command_int_t &packet)
{
    AP_Mission *mission = AP::mission();
    if (mission == nullptr) {
        return MAV_RESULT_UNSUPPORTED;
    }

    const uint32_t tag = (uint32_t)packet.param1;
    if (tag > UINT16_MAX) {
        return MAV_RESULT_DENIED;
    }
    if (!mission->jump_to_tag(tag)) {
        return MAV_RESULT_FAILED;
    }

    // volunteer the new current waypoint for all listeners
    send_message(MSG_CURRENT_WAYPOINT);

    return MAV_RESULT_ACCEPTED;
}
#endif

#if AP_BATTERY_ENABLED
MAV_RESULT GCS_MAVLINK::handle_command_battery_reset(const mavlink_command_int_t &packet)
{
    const uint16_t battery_mask = packet.param1;
    const float percentage = packet.param2;
    if (AP::battery().reset_remaining_mask(battery_mask, percentage)) {
        return MAV_RESULT_ACCEPTED;
    }
    return MAV_RESULT_FAILED;
}
#endif

#if AP_MAVLINK_MAV_CMD_REQUEST_AUTOPILOT_CAPABILITIES_ENABLED
MAV_RESULT GCS_MAVLINK::handle_command_request_autopilot_capabilities(const mavlink_command_int_t &packet)
{
    if (!is_equal(packet.param1,1.0f)) {
        return MAV_RESULT_FAILED;
    }

    send_message(MSG_AUTOPILOT_VERSION);

    return MAV_RESULT_ACCEPTED;
}
#endif

MAV_RESULT GCS_MAVLINK::handle_command_do_set_mode(const mavlink_command_int_t &packet)
{
    const MAV_MODE _base_mode = (MAV_MODE)packet.param1;
    const uint32_t _custom_mode = (uint32_t)packet.param2;

    return _set_mode_common(_base_mode, _custom_mode);
}

#if AP_AHRS_ENABLED
MAV_RESULT GCS_MAVLINK::handle_command_get_home_position(const mavlink_command_int_t &packet)
{
    if (!AP::ahrs().home_is_set()) {
        return MAV_RESULT_FAILED;
    }
    if (!try_send_message(MSG_HOME)) {
        // try again later
        send_message(MSG_HOME);
    }
    if (!try_send_message(MSG_ORIGIN)) {
        // try again later
        send_message(MSG_ORIGIN);
    }

    return MAV_RESULT_ACCEPTED;
}
#endif  // AP_AHRS_ENABLED

MAV_RESULT GCS_MAVLINK::handle_command_debug_trap(const mavlink_command_int_t &packet)
{
    // magic number must be supplied to trap; you must *really* mean it.
    if (uint32_t(packet.param1) != 32451) {
        return MAV_RESULT_DENIED;
    }
    if (hal.util->trap()) {
        return MAV_RESULT_ACCEPTED;
    }
    return MAV_RESULT_UNSUPPORTED;
}

#if AP_AHRS_ENABLED
MAV_RESULT GCS_MAVLINK::handle_command_set_ekf_source_set(const mavlink_command_int_t &packet)
{
    // source set must be between 1 and 3
    uint32_t source_set = uint32_t(packet.param1);
    if ((source_set >= 1) && (source_set <= 3)) {
        // mavlink command uses range 1 to 3 while ahrs interface accepts 0 to 2
        AP::ahrs().set_posvelyaw_source_set(source_set-1);
        return MAV_RESULT_ACCEPTED;
    }
    return MAV_RESULT_DENIED;
}
#endif

#if AP_GRIPPER_ENABLED
MAV_RESULT GCS_MAVLINK::handle_command_do_gripper(const mavlink_command_int_t &packet)
{
    AP_Gripper &gripper = AP::gripper();

    // param1 : gripper number (ignored)
    // param2 : action (0=release, 1=grab). See GRIPPER_ACTIONS enum.
    if(!gripper.enabled()) {
        return MAV_RESULT_FAILED;
    }

    MAV_RESULT result = MAV_RESULT_ACCEPTED;

    switch ((uint8_t)packet.param2) {
    case GRIPPER_ACTION_RELEASE:
        gripper.release();
        break;
    case GRIPPER_ACTION_GRAB:
        gripper.grab();
        break;
    default:
        result = MAV_RESULT_FAILED;
        break;
    }

    return result;
}
#endif  // AP_GRIPPER_ENABLED

#if HAL_SPRAYER_ENABLED
MAV_RESULT GCS_MAVLINK::handle_command_do_sprayer(const mavlink_command_int_t &packet)
{
    AC_Sprayer *sprayer = AP::sprayer();
    if (sprayer == nullptr) {
        return MAV_RESULT_FAILED;
    }

    if (is_equal(packet.param1, 1.0f)) {
        sprayer->run(true);
    } else if (is_zero(packet.param1)) {
        sprayer->run(false);
    }

    return MAV_RESULT_ACCEPTED;
}
#endif

#if AP_LANDINGGEAR_ENABLED
/*
  handle MAV_CMD_AIRFRAME_CONFIGURATION for landing gear control
 */
MAV_RESULT GCS_MAVLINK::handle_command_airframe_configuration(const mavlink_command_int_t &packet)
{
    // Param 1: Select which gear, not used in ArduPilot
    // Param 2: 0 = Deploy, 1 = Retract
    // For safety, anything other than 1 will deploy
    AP_LandingGear *lg = AP_LandingGear::get_singleton();
    if (lg == nullptr) {
        return MAV_RESULT_UNSUPPORTED;
    }
    switch ((uint8_t)packet.param2) {
    case 1:
        lg->set_position(AP_LandingGear::LandingGear_Retract);
        return MAV_RESULT_ACCEPTED;
    default:
        lg->set_position(AP_LandingGear::LandingGear_Deploy);
        return MAV_RESULT_ACCEPTED;
    }
    return MAV_RESULT_FAILED;
}
#endif

#if HAL_INS_ACCELCAL_ENABLED
MAV_RESULT GCS_MAVLINK::handle_command_accelcal_vehicle_pos(const mavlink_command_int_t &packet)
{
    if (AP::ins().get_acal() == nullptr ||
        !AP::ins().get_acal()->gcs_vehicle_position(packet.param1)) {
        return MAV_RESULT_FAILED;
    }
    return MAV_RESULT_ACCEPTED;
}
#endif  // HAL_INS_ACCELCAL_ENABLED

#if HAL_MOUNT_ENABLED
MAV_RESULT GCS_MAVLINK::handle_command_mount(const mavlink_command_int_t &packet, const mavlink_message_t &msg)
{
    AP_Mount *mount = AP::mount();
    if (mount == nullptr) {
        return MAV_RESULT_UNSUPPORTED;
    }
    return mount->handle_command(packet, msg);
}
#endif  // HAL_MOUNT_ENABLED

#if AP_ARMING_ENABLED
MAV_RESULT GCS_MAVLINK::handle_command_component_arm_disarm(const mavlink_command_int_t &packet)
{
    if (is_equal(packet.param1,1.0f)) {
        if (AP::arming().is_armed()) {
            return MAV_RESULT_ACCEPTED;
        }
        // run pre_arm_checks and arm_checks and display failures
        const bool do_arming_checks = !is_equal(packet.param2,magic_force_arm_value) && !is_equal(packet.param2,magic_force_arm_disarm_value);
        if (AP::arming().arm(AP_Arming::Method::MAVLINK, do_arming_checks)) {
            return MAV_RESULT_ACCEPTED;
        }
        return MAV_RESULT_FAILED;
    }
    if (is_zero(packet.param1))  {
        if (!AP::arming().is_armed()) {
            return MAV_RESULT_ACCEPTED;
        }
        const bool forced = is_equal(packet.param2, magic_force_arm_disarm_value);
        // note disarm()'s second parameter is "do_disarm_checks"
        if (AP::arming().disarm(AP_Arming::Method::MAVLINK, !forced)) {
            return MAV_RESULT_ACCEPTED;
        }
        return MAV_RESULT_FAILED;
    }

    return MAV_RESULT_UNSUPPORTED;
}
#endif // AP_ARMING_ENABLED

bool GCS_MAVLINK::location_from_command_t(const mavlink_command_int_t &in, Location &out)
{
    if (!command_long_stores_location((MAV_CMD)in.command)) {
        return false;
    }

    // integer storage imposes limits on the altitudes we can accept:
    if (isnan(in.z) || fabsf(in.z) > LOCATION_ALT_MAX_M) {
        return false;
    }

    Location::AltFrame frame;
    if (!mavlink_coordinate_frame_to_location_alt_frame((MAV_FRAME)in.frame, frame)) {
        // unknown coordinate frame
        return false;
    }

    out.lat = in.x;
    out.lng = in.y;

    out.set_alt_cm(int32_t(in.z * 100), frame);

    return true;
}

bool GCS_MAVLINK::command_long_stores_location(const MAV_CMD command)
{
    switch(command) {
    case MAV_CMD_DO_SET_HOME:
    case MAV_CMD_DO_SET_ROI:
    case MAV_CMD_DO_SET_ROI_LOCATION:
    // case MAV_CMD_NAV_TAKEOFF:  // technically yes, but we don't do lat/lng
    // case MAV_CMD_NAV_VTOL_TAKEOFF:
    case MAV_CMD_DO_REPOSITION:
    case MAV_CMD_EXTERNAL_POSITION_ESTIMATE:
        return true;
    default:
        return false;
    }
    return false;
}

#if AP_MAVLINK_COMMAND_LONG_ENABLED
// when conveyed via COMMAND_LONG, a command doesn't come with an
// explicit frame.  When conveying a location they do have an assumed
// frame in ArduPilot, and this function returns that frame.
bool GCS_MAVLINK::mav_frame_for_command_long(MAV_FRAME &frame, MAV_CMD packet_command) const
{
    static const struct {
        uint32_t command;
        MAV_FRAME frame;
    } frame_map[] {
        { MAV_CMD_FIXED_MAG_CAL_YAW, MAV_FRAME_GLOBAL_RELATIVE_ALT },
        { MAV_CMD_DO_SET_ROI, MAV_FRAME_GLOBAL_RELATIVE_ALT },
        { MAV_CMD_DO_SET_ROI_LOCATION, MAV_FRAME_GLOBAL_RELATIVE_ALT },
        { MAV_CMD_DO_SET_HOME, MAV_FRAME_GLOBAL },
    };

    // map from command to frame:
    for (const auto &map : frame_map) {
        if (map.command != packet_command) {
            continue;
        }
        frame = map.frame;
        return true;
    }

    return false;
}

MAV_RESULT GCS_MAVLINK::try_command_long_as_command_int(const mavlink_command_long_t &packet, const mavlink_message_t &msg)
{
    MAV_FRAME frame = MAV_FRAME_GLOBAL_RELATIVE_ALT;
    if (command_long_stores_location((MAV_CMD)packet.command)) {
        // we must be able to supply a frame for the location:
        if (!mav_frame_for_command_long(frame, (MAV_CMD)packet.command)) {
            return MAV_RESULT_UNSUPPORTED;
        }
    }

    // convert and run the command
    mavlink_command_int_t command_int;
    convert_COMMAND_LONG_to_COMMAND_INT(packet, command_int, frame);

    return handle_command_int_packet(command_int, msg);
}

// returns a value suitable for COMMAND_INT.x or y based on a value
// coming in from COMMAND_LONG.p5 or p6:
static int32_t convert_COMMAND_LONG_loc_param(float param, bool stores_location)
{
    if (isnan(param)) {
        return 0;
    }

    if (stores_location) {
        return param *1e7;
    }

    return param;
}

void GCS_MAVLINK::convert_COMMAND_LONG_to_COMMAND_INT(const mavlink_command_long_t &in, mavlink_command_int_t &out, MAV_FRAME frame)
{
    out = {};
    out.target_system = in.target_system;
    out.target_component = in.target_component;
    out.frame = frame;
    out.command = in.command;
    out.current = 0;
    out.autocontinue = 0;
    out.param1 = in.param1;
    out.param2 = in.param2;
    out.param3 = in.param3;
    out.param4 = in.param4;
    const bool stores_location = command_long_stores_location((MAV_CMD)in.command);
    out.x = convert_COMMAND_LONG_loc_param(in.param5, stores_location);
    out.y = convert_COMMAND_LONG_loc_param(in.param6, stores_location);
    out.z = in.param7;
}

void GCS_MAVLINK::handle_command_long(const mavlink_message_t &msg)
{
    // decode packet
    mavlink_command_long_t packet;
    mavlink_msg_command_long_decode(&msg, &packet);

#if AP_SCRIPTING_ENABLED
    AP_Scripting *scripting = AP_Scripting::get_singleton();
    if (scripting != nullptr && scripting->is_handling_command(packet.command)) {
        // Scripting has registered to receive this command, do not procces it internaly
        return;
    }
#endif

    hal.util->persistent_data.last_mavlink_cmd = packet.command;

    const MAV_RESULT result = try_command_long_as_command_int(packet, msg);

    // send ACK or NAK
    mavlink_msg_command_ack_send(chan, packet.command, result,
                                 0, 0,
                                 msg.sysid,
                                 msg.compid);

#if HAL_LOGGING_ENABLED
    // log the packet:
    mavlink_command_int_t packet_int;
    convert_COMMAND_LONG_to_COMMAND_INT(packet, packet_int);
    AP::logger().Write_Command(packet_int, msg.sysid, msg.compid, result, true);
#endif

    hal.util->persistent_data.last_mavlink_cmd = 0;
}

#else
void GCS_MAVLINK::handle_command_long(const mavlink_message_t &msg)
{
    // decode packet
    mavlink_command_long_t packet;
    mavlink_msg_command_long_decode(&msg, &packet);

    // send ACK or NAK
    mavlink_msg_command_ack_send(
        chan,
        packet.command,
        MAV_RESULT_COMMAND_INT_ONLY,
        0,
        0,
        msg.sysid,
        msg.compid
   );

}
#endif  // AP_MAVLINK_COMMAND_LONG_ENABLED

MAV_RESULT GCS_MAVLINK::handle_command_do_set_roi(const Location &roi_loc)
{
#if HAL_MOUNT_ENABLED
    AP_Mount *mount = AP::mount();
    if (mount == nullptr) {
        return MAV_RESULT_UNSUPPORTED;
    }

    // sanity check location
    if (!roi_loc.check_latlng()) {
        return MAV_RESULT_FAILED;
    }

    if (roi_loc.lat == 0 && roi_loc.lng == 0 && roi_loc.alt == 0) {
        mount->clear_roi_target();
    } else {
        mount->set_roi_target(roi_loc);
    }
    return MAV_RESULT_ACCEPTED;
#else
    return MAV_RESULT_UNSUPPORTED;
#endif
}


void GCS_MAVLINK::handle_landing_target(const mavlink_message_t &msg)
{
    mavlink_landing_target_t m;
    mavlink_msg_landing_target_decode(&msg, &m);
    // correct offboard timestamp
    const uint32_t corrected_ms = correct_offboard_timestamp_usec_to_ms(m.time_usec, PAYLOAD_SIZE(chan, LANDING_TARGET));
    handle_landing_target(m, corrected_ms);
}


#if AP_HOME_ENABLED
bool GCS_MAVLINK::set_home_to_current_location(bool _lock)
{
#if AP_VEHICLE_ENABLED
    return AP::vehicle()->set_home_to_current_location(_lock);
#else
    return false;
#endif
}

bool GCS_MAVLINK::set_home(const Location& loc, bool _lock) {
#if AP_VEHICLE_ENABLED
    return AP::vehicle()->set_home(loc, _lock);
#else
    return false;
#endif
}
#endif  // AP_HOME_ENABLED

#if AP_HOME_ENABLED
MAV_RESULT GCS_MAVLINK::handle_command_do_set_home(const mavlink_command_int_t &packet)
{
    if (is_equal(packet.param1, 1.0f) || (packet.x == 0 && packet.y == 0)) {
        // param1 is 1 (or both lat and lon are zero); use current location
        if (!set_home_to_current_location(true)) {
            return MAV_RESULT_FAILED;
        }
        return MAV_RESULT_ACCEPTED;
    }
    // ensure param1 is zero
    if (!is_zero(packet.param1)) {
        return MAV_RESULT_FAILED;
    }
    Location new_home_loc;
    if (!location_from_command_t(packet, new_home_loc)) {
        return MAV_RESULT_DENIED;
    }
    if (!set_home(new_home_loc, true)) {
        return MAV_RESULT_FAILED;
    }
    return MAV_RESULT_ACCEPTED;
}
#endif  // AP_HOME_ENABLED

#if AP_AHRS_POSITION_RESET_ENABLED
MAV_RESULT GCS_MAVLINK::handle_command_int_external_position_estimate(const mavlink_command_int_t &packet)
{
    if ((packet.frame != MAV_FRAME_GLOBAL && packet.frame != MAV_FRAME_GLOBAL_INT) ||
        !isnan(packet.z)) {
        // we only support global frame without altitude
        return MAV_RESULT_DENIED;
    }

    // cope with the NaN when convering to Location
    Location loc;
    mavlink_command_int_t p2 = packet;
    p2.z = 0;

    if (!location_from_command_t(p2, loc)) {
        return MAV_RESULT_DENIED;
    }
    uint32_t timestamp_ms = correct_offboard_timestamp_usec_to_ms(uint64_t(p2.param1*1e6), PAYLOAD_SIZE(chan, COMMAND_INT));
    const uint32_t processing_ms = p2.param2*1e3;
    const float pos_accuracy = p2.param3;
    if (timestamp_ms > processing_ms) {
        timestamp_ms -= processing_ms;
    }
    if (!AP::ahrs().handle_external_position_estimate(loc, pos_accuracy, timestamp_ms)) {
        return MAV_RESULT_FAILED;
    }
    return MAV_RESULT_ACCEPTED;
}
#endif // AP_AHRS_POSITION_RESET_ENABLED

MAV_RESULT GCS_MAVLINK::handle_command_do_set_roi(const mavlink_command_int_t &packet)
{
    // be aware that this method is called for both MAV_CMD_DO_SET_ROI
    // and MAV_CMD_DO_SET_ROI_LOCATION.  If you intend to support any
    // of the extra fields in the former then you will need to split
    // off support for MAV_CMD_DO_SET_ROI_LOCATION (which doesn't
    // support the extra fields).

    // param1 : /* Region of interest mode (not used)*/
    // param2 : /* MISSION index/ target ID (not used)*/
    // param3 : /* ROI index (not used)*/
    // param4 : /* empty */
    // x : lat
    // y : lon
    // z : alt
    Location roi_loc;
    if (!location_from_command_t(packet, roi_loc)) {
        return MAV_RESULT_DENIED;
    }
    return handle_command_do_set_roi(roi_loc);
}

#if AP_FILESYSTEM_FORMAT_ENABLED
MAV_RESULT GCS_MAVLINK::handle_command_storage_format(const mavlink_command_int_t &packet, const mavlink_message_t &msg)
{
    if (!is_equal(packet.param1, 1.0f) ||
        !is_equal(packet.param2, 1.0f)) {
        return MAV_RESULT_UNSUPPORTED;
    }
    GCS_MAVLINK_InProgress *task = GCS_MAVLINK_InProgress::get_task(MAV_CMD_STORAGE_FORMAT, GCS_MAVLINK_InProgress::Type::SD_FORMAT, msg.sysid, msg.compid, chan);
    if (task == nullptr) {
        return MAV_RESULT_TEMPORARILY_REJECTED;
    }
    if (!AP::FS().format()) {
        task->abort();
        return MAV_RESULT_FAILED;
    }
    return MAV_RESULT_IN_PROGRESS;
}
#endif

MAV_RESULT GCS_MAVLINK::handle_do_set_safety_switch_state(const mavlink_command_int_t &packet, const mavlink_message_t &msg)
{
    switch ((SAFETY_SWITCH_STATE)packet.param1) {
    case SAFETY_SWITCH_STATE_DANGEROUS:
        // turn safety off (pwm outputs flow to the motors)
        hal.rcout->force_safety_off();
        return MAV_RESULT_ACCEPTED;
    case SAFETY_SWITCH_STATE_SAFE:
        // turn safety on (no pwm outputs to the motors)
        if (hal.rcout->force_safety_on()) {
            return MAV_RESULT_ACCEPTED;
        }
        return MAV_RESULT_FAILED;
    default:
        return MAV_RESULT_DENIED;
    }
}


MAV_RESULT GCS_MAVLINK::handle_command_int_packet(const mavlink_command_int_t &packet, const mavlink_message_t &msg)
{
    switch (packet.command) {

#if HAL_INS_ACCELCAL_ENABLED
    case MAV_CMD_ACCELCAL_VEHICLE_POS:
        return handle_command_accelcal_vehicle_pos(packet);
#endif

#if AP_LANDINGGEAR_ENABLED
    case MAV_CMD_AIRFRAME_CONFIGURATION:
        return handle_command_airframe_configuration(packet);
#endif

#if AP_BATTERY_ENABLED
    case MAV_CMD_BATTERY_RESET:
        return handle_command_battery_reset(packet);
#endif

#if HAL_CANMANAGER_ENABLED
    case MAV_CMD_CAN_FORWARD:
        return handle_can_forward(packet, msg);
#endif

#if HAL_HIGH_LATENCY2_ENABLED
    case MAV_CMD_CONTROL_HIGH_LATENCY:
        return handle_control_high_latency(packet);
#endif // HAL_HIGH_LATENCY2_ENABLED

    case MAV_CMD_DEBUG_TRAP:
        return handle_command_debug_trap(packet);

#if HAL_ADSB_ENABLED
    case MAV_CMD_DO_ADSB_OUT_IDENT:
        if ((AP::ADSB() != nullptr) && AP::ADSB()->ident_start()) {
            return MAV_RESULT_ACCEPTED;
        }
        return  MAV_RESULT_FAILED;
#endif

#if AP_RC_CHANNEL_ENABLED
    case MAV_CMD_DO_AUX_FUNCTION:
        return handle_command_do_aux_function(packet);
#endif

#if AP_FENCE_ENABLED
    case MAV_CMD_DO_FENCE_ENABLE:
        return handle_command_do_fence_enable(packet);
#endif

    case MAV_CMD_DO_FLIGHTTERMINATION:
        return handle_flight_termination(packet);

#if AP_GRIPPER_ENABLED
    case MAV_CMD_DO_GRIPPER:
        return handle_command_do_gripper(packet);
#endif

#if AP_MISSION_ENABLED
    case MAV_CMD_DO_JUMP_TAG:
        return handle_command_do_jump_tag(packet);

    case MAV_CMD_DO_SET_MISSION_CURRENT:
        return handle_command_do_set_mission_current(packet);
#endif

    case MAV_CMD_DO_SET_MODE:
        return handle_command_do_set_mode(packet);

#if HAL_SPRAYER_ENABLED
    case MAV_CMD_DO_SPRAYER:
        return handle_command_do_sprayer(packet);
#endif

#if AP_CAMERA_ENABLED
    case MAV_CMD_DO_DIGICAM_CONFIGURE:
    case MAV_CMD_DO_DIGICAM_CONTROL:
    case MAV_CMD_DO_SET_CAM_TRIGG_DIST:
    case MAV_CMD_SET_CAMERA_ZOOM:
    case MAV_CMD_SET_CAMERA_FOCUS:
    case MAV_CMD_SET_CAMERA_SOURCE:
    case MAV_CMD_IMAGE_START_CAPTURE:
    case MAV_CMD_IMAGE_STOP_CAPTURE:
    case MAV_CMD_CAMERA_TRACK_POINT:
    case MAV_CMD_CAMERA_TRACK_RECTANGLE:
    case MAV_CMD_CAMERA_STOP_TRACKING:
    case MAV_CMD_VIDEO_START_CAPTURE:
    case MAV_CMD_VIDEO_STOP_CAPTURE:
        return handle_command_camera(packet);
#endif

    case MAV_CMD_DO_SET_ROI_NONE: {
        const Location zero_loc = Location();
        return handle_command_do_set_roi(zero_loc);
    }

    case MAV_CMD_DO_SET_ROI:
    case MAV_CMD_DO_SET_ROI_LOCATION:
        return handle_command_do_set_roi(packet);

#if HAL_MOUNT_ENABLED
    case MAV_CMD_DO_SET_ROI_SYSID:
    case MAV_CMD_DO_MOUNT_CONFIGURE:
    case MAV_CMD_DO_MOUNT_CONTROL:
    case MAV_CMD_DO_GIMBAL_MANAGER_PITCHYAW:
    case MAV_CMD_DO_GIMBAL_MANAGER_CONFIGURE:
        return handle_command_mount(packet, msg);
#endif  // HAL_MOUNT_ENABLED

    case MAV_CMD_DO_SEND_BANNER:
        send_banner();
        return MAV_RESULT_ACCEPTED;

#if AP_HOME_ENABLED
    case MAV_CMD_DO_SET_HOME:
        return handle_command_do_set_home(packet);
#endif

#if AP_AHRS_POSITION_RESET_ENABLED
    case MAV_CMD_EXTERNAL_POSITION_ESTIMATE:
        return handle_command_int_external_position_estimate(packet);
#endif
#if AP_ARMING_ENABLED
    case MAV_CMD_COMPONENT_ARM_DISARM:
        return handle_command_component_arm_disarm(packet);
#endif
#if AP_COMPASS_CALIBRATION_FIXED_YAW_ENABLED
    case MAV_CMD_FIXED_MAG_CAL_YAW:
        return handle_command_fixed_mag_cal_yaw(packet);
#endif
#if COMPASS_CAL_ENABLED
    case MAV_CMD_DO_START_MAG_CAL:
    case MAV_CMD_DO_ACCEPT_MAG_CAL:
    case MAV_CMD_DO_CANCEL_MAG_CAL:
        return handle_command_mag_cal(packet);
#endif

#if AP_BOOTLOADER_FLASHING_ENABLED
    case MAV_CMD_FLASH_BOOTLOADER:
        return handle_command_flash_bootloader(packet);
#endif

#if AP_AHRS_ENABLED
    case MAV_CMD_GET_HOME_POSITION:
        return handle_command_get_home_position(packet);
#endif

    case MAV_CMD_PREFLIGHT_CALIBRATION:
        return handle_command_preflight_calibration(packet, msg);

    case MAV_CMD_PREFLIGHT_STORAGE:
        if (is_equal(packet.param1, 2.0f)) {
            AP_Param::erase_all();
            send_text(MAV_SEVERITY_WARNING, "All parameters reset, reboot board");
            return MAV_RESULT_ACCEPTED;
        }
        return MAV_RESULT_DENIED;

    case MAV_CMD_PREFLIGHT_REBOOT_SHUTDOWN:
        return handle_preflight_reboot(packet, msg);

    case MAV_CMD_DO_SET_SAFETY_SWITCH_STATE:
        return handle_do_set_safety_switch_state(packet, msg);

#if AP_MAVLINK_SERVO_RELAY_ENABLED
    case MAV_CMD_DO_SET_SERVO:
    case MAV_CMD_DO_REPEAT_SERVO:
    case MAV_CMD_DO_SET_RELAY:
    case MAV_CMD_DO_REPEAT_RELAY:
        return handle_servorelay_message(packet);
#endif

#if AP_MAVLINK_MAV_CMD_REQUEST_AUTOPILOT_CAPABILITIES_ENABLED
    case MAV_CMD_REQUEST_AUTOPILOT_CAPABILITIES:
        return handle_command_request_autopilot_capabilities(packet);
#endif

#if AP_ARMING_ENABLED
    case MAV_CMD_RUN_PREARM_CHECKS:
        return handle_command_run_prearm_checks(packet);
#endif

#if AP_SCRIPTING_ENABLED
    case MAV_CMD_SCRIPTING:
        {
            AP_Scripting *scripting = AP_Scripting::get_singleton();
            if (scripting == nullptr) {
                return MAV_RESULT_UNSUPPORTED;
            }
            return scripting->handle_command_int_packet(packet);
        }
#endif // AP_SCRIPTING_ENABLED

#if AP_AHRS_ENABLED
    case MAV_CMD_SET_EKF_SOURCE_SET:
        return handle_command_set_ekf_source_set(packet);
#endif

#if AP_RC_CHANNEL_ENABLED
    case MAV_CMD_START_RX_PAIR:
        return handle_START_RX_PAIR(packet);
#endif

#if AP_FILESYSTEM_FORMAT_ENABLED
    case MAV_CMD_STORAGE_FORMAT:
        return handle_command_storage_format(packet, msg);
#endif

    // support for dealing with streamrate for a specific message and
    // requesting a message instance:
    case MAV_CMD_SET_MESSAGE_INTERVAL:
        return handle_command_set_message_interval(packet);

    case MAV_CMD_GET_MESSAGE_INTERVAL:
        return handle_command_get_message_interval(packet);

    case MAV_CMD_REQUEST_MESSAGE:
        return handle_command_request_message(packet);

    }

    return MAV_RESULT_UNSUPPORTED;
}

void GCS_MAVLINK::handle_command_int(const mavlink_message_t &msg)
{
    // decode packet
    mavlink_command_int_t packet;
    mavlink_msg_command_int_decode(&msg, &packet);

#if AP_SCRIPTING_ENABLED
    AP_Scripting *scripting = AP_Scripting::get_singleton();
    if (scripting != nullptr && scripting->is_handling_command(packet.command)) {
        // Scripting has registered to receive this command, do not procces it internaly
        return;
    }
#endif

    hal.util->persistent_data.last_mavlink_cmd = packet.command;

    const MAV_RESULT result = handle_command_int_packet(packet, msg);

    // send ACK or NAK
    mavlink_msg_command_ack_send(chan, packet.command, result,
                                 0, 0,
                                 msg.sysid,
                                 msg.compid);

#if HAL_LOGGING_ENABLED
    AP::logger().Write_Command(packet, msg.sysid, msg.compid, result);
#endif

    hal.util->persistent_data.last_mavlink_cmd = 0;
}

void GCS::try_send_queued_message_for_type(MAV_MISSION_TYPE type) const {
    MissionItemProtocol *prot = get_prot_for_mission_type(type);
    if (prot == nullptr) {
        return;
    }
    prot->queued_request_send();
}

bool GCS_MAVLINK::try_send_mission_message(const enum ap_message id)
{
    switch (id) {
#if AP_MISSION_ENABLED
    case MSG_CURRENT_WAYPOINT:
    {
        CHECK_PAYLOAD_SIZE(MISSION_CURRENT);
        AP_Mission *mission = AP::mission();
        if (mission != nullptr) {
            send_mission_current(*mission, mission->get_current_nav_index());
        }
        break;
    }
    case MSG_MISSION_ITEM_REACHED:
        CHECK_PAYLOAD_SIZE(MISSION_ITEM_REACHED);
        mavlink_msg_mission_item_reached_send(chan, mission_item_reached_index);
        break;
    case MSG_NEXT_MISSION_REQUEST_WAYPOINTS:
        CHECK_PAYLOAD_SIZE(MISSION_REQUEST);
        gcs().try_send_queued_message_for_type(MAV_MISSION_TYPE_MISSION);
        break;
#endif
#if HAL_RALLY_ENABLED
    case MSG_NEXT_MISSION_REQUEST_RALLY:
        CHECK_PAYLOAD_SIZE(MISSION_REQUEST);
        gcs().try_send_queued_message_for_type(MAV_MISSION_TYPE_RALLY);
        break;
#endif
#if AP_FENCE_ENABLED
    case MSG_NEXT_MISSION_REQUEST_FENCE:
        CHECK_PAYLOAD_SIZE(MISSION_REQUEST);
        gcs().try_send_queued_message_for_type(MAV_MISSION_TYPE_FENCE);
        break;
#endif
    default:
        break;
    }
    return true;
}

void GCS_MAVLINK::send_hwstatus()
{
    mavlink_msg_hwstatus_send(
        chan,
        hal.analogin->board_voltage()*1000,
        0);
}

#if AP_RPM_ENABLED
void GCS_MAVLINK::send_rpm() const
{
    AP_RPM *rpm = AP::rpm();
    if (rpm == nullptr) {
        return;
    }

    if (!rpm->enabled(0) && !rpm->enabled(1)) {
        return;
    }

    float rpm1 = -1, rpm2 = -1;

    rpm->get_rpm(0, rpm1);
    rpm->get_rpm(1, rpm2);

    mavlink_msg_rpm_send(
        chan,
        rpm1,
        rpm2);
}
#endif  // AP_RPM_ENABLED

void GCS_MAVLINK::send_sys_status()
{
    // send extended status only once vehicle has been initialised
    // to avoid unnecessary errors being reported to user
    if (!gcs().vehicle_initialised()) {
        return;
    }
#if AP_BATTERY_ENABLED
    const AP_BattMonitor &battery = AP::battery();
    float battery_current;
    const int8_t battery_remaining = battery_remaining_pct(AP_BATT_PRIMARY_INSTANCE);

    if (battery.healthy() && battery.current_amps(battery_current)) {
        battery_current = constrain_float(battery_current * 100,-INT16_MAX,INT16_MAX);
    } else {
        battery_current = -1;
    }
#endif

    uint32_t control_sensors_present;
    uint32_t control_sensors_enabled;
    uint32_t control_sensors_health;

    gcs().get_sensor_status_flags(control_sensors_present, control_sensors_enabled, control_sensors_health);

    const uint32_t errors = AP::internalerror().errors();
    const uint16_t errors1 = errors & 0xffff;
    const uint16_t errors2 = (errors>>16) & 0xffff;
    const uint16_t errors4 = AP::internalerror().count() & 0xffff;

    mavlink_msg_sys_status_send(
        chan,
        control_sensors_present,
        control_sensors_enabled,
        control_sensors_health,
#if AP_SCHEDULER_ENABLED
        static_cast<uint16_t>(AP::scheduler().load_average() * 1000),
#else
        0,
#endif
#if AP_BATTERY_ENABLED
        battery.gcs_voltage() * 1000,  // mV
        battery_current,        // in 10mA units
        battery_remaining,      // in %
#else
        0,
        -1,
        -1,
#endif
        0,  // comm drops %,
        0,  // comm drops in pkts,
        errors1,
        errors2,
        0,  // errors3
        errors4); // errors4
}

void GCS_MAVLINK::send_extended_sys_state() const
{
    mavlink_msg_extended_sys_state_send(chan, vtol_state(), landed_state());
}

void GCS_MAVLINK::send_attitude() const
{
#if AP_AHRS_ENABLED
    const AP_AHRS &ahrs = AP::ahrs();
    const Vector3f omega = ahrs.get_gyro();
    mavlink_msg_attitude_send(
        chan,
        AP_HAL::millis(),
        ahrs.get_roll(),
        ahrs.get_pitch(),
        ahrs.get_yaw(),
        omega.x,
        omega.y,
        omega.z);
#endif
}

void GCS_MAVLINK::send_attitude_quaternion() const
{
#if AP_AHRS_ENABLED
    const AP_AHRS &ahrs = AP::ahrs();
    Quaternion quat;
    if (!ahrs.get_quaternion(quat)) {
        return;
    }
    const Vector3f omega = ahrs.get_gyro();
    const float repr_offseq_q[] {0,0,0,0};  // unused, but probably should correspond to the AHRS view?
    mavlink_msg_attitude_quaternion_send(
        chan,
        AP_HAL::millis(),
        quat.q1,
        quat.q2,
        quat.q3,
        quat.q4,
        omega.x, // rollspeed
        omega.y, // pitchspeed
        omega.z, // yawspeed
        repr_offseq_q
        );
#endif
}

int32_t GCS_MAVLINK::global_position_int_alt() const {
    return global_position_current_loc.alt * 10UL;
}
int32_t GCS_MAVLINK::global_position_int_relative_alt() const {
#if AP_AHRS_ENABLED
    float posD;
    AP::ahrs().get_relative_position_D_home(posD);
    posD *= -1000.0f; // change from down to up and metres to millimeters
    return posD;
#else
    return 0;
#endif
}

void GCS_MAVLINK::send_global_position_int()
{
#if AP_AHRS_ENABLED
    AP_AHRS &ahrs = AP::ahrs();

    UNUSED_RESULT(ahrs.get_location(global_position_current_loc)); // return value ignored; we send stale data

    Vector3f vel;
    if (!ahrs.get_velocity_NED(vel)) {
        vel.zero();
    }

    mavlink_msg_global_position_int_send(
        chan,
        AP_HAL::millis(),
        global_position_current_loc.lat, // in 1E7 degrees
        global_position_current_loc.lng, // in 1E7 degrees
        global_position_int_alt(),       // millimeters above ground/sea level
        global_position_int_relative_alt(), // millimeters above home
        vel.x * 100,                     // X speed cm/s (+ve North)
        vel.y * 100,                     // Y speed cm/s (+ve East)
        vel.z * 100,                     // Z speed cm/s (+ve Down)
        ahrs.yaw_sensor);                // compass heading in 1/100 degree
#endif  // AP_AHRS_ENABLED
}

#if HAL_MOUNT_ENABLED
void GCS_MAVLINK::send_gimbal_device_attitude_status() const
{
    AP_Mount *mount = AP::mount();
    if (mount == nullptr) {
        return;
    }
    mount->send_gimbal_device_attitude_status(chan);
}

void GCS_MAVLINK::send_gimbal_manager_information() const
{
    AP_Mount *mount = AP::mount();
    if (mount == nullptr) {
        return;
    }
    mount->send_gimbal_manager_information(chan);
}

void GCS_MAVLINK::send_gimbal_manager_status() const
{
    AP_Mount *mount = AP::mount();
    if (mount == nullptr) {
        return;
    }
    mount->send_gimbal_manager_status(chan);
}
#endif

void GCS_MAVLINK::send_set_position_target_global_int(uint8_t target_system, uint8_t target_component, const Location& loc)
{

    const uint16_t type_mask = POSITION_TARGET_TYPEMASK_VX_IGNORE | POSITION_TARGET_TYPEMASK_VY_IGNORE | POSITION_TARGET_TYPEMASK_VZ_IGNORE | \
                               POSITION_TARGET_TYPEMASK_AX_IGNORE | POSITION_TARGET_TYPEMASK_AY_IGNORE | POSITION_TARGET_TYPEMASK_AZ_IGNORE | \
                               POSITION_TARGET_TYPEMASK_YAW_IGNORE | POSITION_TARGET_TYPEMASK_YAW_RATE_IGNORE;

    // convert altitude to relative to home
    int32_t rel_alt;
    if (!loc.get_alt_cm(Location::AltFrame::ABOVE_HOME, rel_alt)) {
        return;
    }

    mavlink_msg_set_position_target_global_int_send(
            chan,
            AP_HAL::millis(),
            target_system,
            target_component,
            MAV_FRAME_GLOBAL_RELATIVE_ALT,
            type_mask,
            loc.lat,
            loc.lng,
            rel_alt,
            0,0,0,  // vx, vy, vz
            0,0,0,  // ax, ay, az
            0,0);   // yaw, yaw_rate
}

#if HAL_GENERATOR_ENABLED
void GCS_MAVLINK::send_generator_status() const
{
    AP_Generator *generator = AP::generator();
    if (generator == nullptr) {
        return;
    }
    generator->send_generator_status(*this);
}
#endif

#if AP_RANGEFINDER_ENABLED && APM_BUILD_TYPE(APM_BUILD_Rover)
void GCS_MAVLINK::send_water_depth() const
{
    if (!HAVE_PAYLOAD_SPACE(chan, WATER_DEPTH)) {
        return;
    }

    RangeFinder *rangefinder = RangeFinder::get_singleton();

    if (rangefinder == nullptr || !rangefinder->has_orientation(ROTATION_PITCH_270)){
        return;
    } 

    // get position
    const AP_AHRS &ahrs = AP::ahrs();
    Location loc;
    IGNORE_RETURN(ahrs.get_location(loc));

    for (uint8_t i=0; i<rangefinder->num_sensors(); i++) {
        const AP_RangeFinder_Backend *s = rangefinder->get_backend(i);
        
        if (s == nullptr || s->orientation() != ROTATION_PITCH_270 || !s->has_data()) {
            continue;
        }

        // get temperature
        float temp_C;
        if (!s->get_temp(temp_C)) {
            temp_C = 0.0f;
        }

        const bool sensor_healthy = (s->status() == RangeFinder::Status::Good);

        mavlink_msg_water_depth_send(
            chan,
            AP_HAL::millis(),   // time since system boot TODO: take time of measurement
            i,                  // rangefinder instance
            sensor_healthy,     // sensor healthy
            loc.lat,            // latitude of vehicle
            loc.lng,            // longitude of vehicle
            loc.alt * 0.01f,    // altitude of vehicle (MSL)
            ahrs.get_roll(),    // roll in radians
            ahrs.get_pitch(),   // pitch in radians
            ahrs.get_yaw(),     // yaw in radians
            s->distance(),    // distance in meters
            temp_C);            // temperature in degC
    }

}
#endif  // AP_RANGEFINDER_ENABLED && APM_BUILD_TYPE(APM_BUILD_Rover)

#if HAL_ADSB_ENABLED
void GCS_MAVLINK::send_uavionix_adsb_out_status() const
{
    AP_ADSB *adsb = AP::ADSB();
    if (adsb != nullptr) {
        adsb->send_adsb_out_status(chan);
    }
}
#endif

#if AP_MAVLINK_MSG_RELAY_STATUS_ENABLED
bool GCS_MAVLINK::send_relay_status() const
{
    AP_Relay *relay = AP::relay();
    if (relay == nullptr) {
        // must only return false if out of space:
        return true;
    }

    return relay->send_relay_status(*this);
}
#endif  // AP_MAVLINK_MSG_RELAY_STATUS_ENABLED

void GCS_MAVLINK::send_autopilot_state_for_gimbal_device() const
{
#if AP_AHRS_ENABLED
    // get attitude
    const AP_AHRS &ahrs = AP::ahrs();
    Quaternion quat;
    if (!ahrs.get_quaternion(quat)) {
        return;
    }
    const float repr_offseq_q[] = {quat.q1, quat.q2, quat.q3, quat.q4};

    // get velocity
    Vector3f vel;
    if (!ahrs.get_velocity_NED(vel)) {
        vel.zero();
    }

    // get vehicle earth-frame rotation rate targets
    Vector3f rate_ef_targets;
#if AP_VEHICLE_ENABLED
    const AP_Vehicle *vehicle = AP::vehicle();
    if (vehicle != nullptr) {
        vehicle->get_rate_ef_targets(rate_ef_targets);
    }
#endif

    // get estimator flags
    uint16_t est_status_flags = 0;
    nav_filter_status nav_filt_status;
    if (ahrs.get_filter_status(nav_filt_status)) {
        est_status_flags = (uint16_t)(nav_filt_status.value & 0xFFFF);
    }

    mavlink_msg_autopilot_state_for_gimbal_device_send(
        chan,
        mavlink_system.sysid,   // target system (this autopilot's gimbal)
        0,                  // target component (anything)
        AP_HAL::micros(),   // time boot us
        repr_offseq_q,  // attitude as quaternion
        0,      // attitude estimated delay in micros
        vel.x,  // x speed in NED (m/s)
        vel.y,  // y speed in NED (m/s)
        vel.z,  // z speed in NED (m/s)
        0,      // velocity estimated delay in micros
        rate_ef_targets.z,  // feed forward angular velocity z
        est_status_flags,   // estimator status
        0,      // landed_state (see MAV_LANDED_STATE)
        AP::ahrs().get_yaw_rate_earth());   // [rad/s] Z component of angular velocity in NED (North, East, Down). NaN if unknown
#endif  // AP_AHRS_ENABLED
}

void GCS_MAVLINK::send_received_message_deprecation_warning(const char * message)
{
    // we're not expecting very many of these ever, so a tiny bit of
    // de-duping is probably OK:
    if (message == last_deprecation_message) {
        return;
    }

    const uint32_t now_ms = AP_HAL::millis();
    if (last_deprecation_warning_send_time_ms - now_ms < 30000) {
        return;
    }
    last_deprecation_warning_send_time_ms = now_ms;
    last_deprecation_message = message;

    send_text(MAV_SEVERITY_INFO, "Received message (%s) is deprecated", message);
}

bool GCS_MAVLINK::try_send_message(const enum ap_message id)
{
    bool ret = true;

    switch(id) {

#if AP_AHRS_ENABLED
    case MSG_ATTITUDE:
        CHECK_PAYLOAD_SIZE(ATTITUDE);
        send_attitude();
        break;

    case MSG_ATTITUDE_QUATERNION:
        CHECK_PAYLOAD_SIZE(ATTITUDE_QUATERNION);
        send_attitude_quaternion();
        break;
#endif

    case MSG_NEXT_PARAM:
        CHECK_PAYLOAD_SIZE(PARAM_VALUE);
        queued_param_send();
        break;

    case MSG_HEARTBEAT:
        CHECK_PAYLOAD_SIZE(HEARTBEAT);
        last_heartbeat_time = AP_HAL::millis();
        send_heartbeat();
        break;

    case MSG_HWSTATUS:
        CHECK_PAYLOAD_SIZE(HWSTATUS);
        send_hwstatus();
        break;

#if AP_AHRS_ENABLED
    case MSG_LOCATION:
        CHECK_PAYLOAD_SIZE(GLOBAL_POSITION_INT);
        send_global_position_int();
        break;

    case MSG_HOME:
        CHECK_PAYLOAD_SIZE(HOME_POSITION);
        send_home_position();
        break;

    case MSG_ORIGIN:
        CHECK_PAYLOAD_SIZE(GPS_GLOBAL_ORIGIN);
        send_gps_global_origin();
        break;
#endif  // AP_AHRS_ENABLED

#if AP_RPM_ENABLED
    case MSG_RPM:
        CHECK_PAYLOAD_SIZE(RPM);
        send_rpm();
        break;
#endif

    case MSG_CURRENT_WAYPOINT:
    case MSG_MISSION_ITEM_REACHED:
    case MSG_NEXT_MISSION_REQUEST_WAYPOINTS:
    case MSG_NEXT_MISSION_REQUEST_RALLY:
    case MSG_NEXT_MISSION_REQUEST_FENCE:
        ret = try_send_mission_message(id);
        break;

#if COMPASS_CAL_ENABLED
    case MSG_MAG_CAL_PROGRESS:
        ret = AP::compass().send_mag_cal_progress(*this);
        break;
    case MSG_MAG_CAL_REPORT:
        ret = AP::compass().send_mag_cal_report(*this);
        break;
#endif

#if AP_BATTERY_ENABLED
    case MSG_BATTERY_STATUS:
        send_battery_status();
        break;

#if AP_MAVLINK_BATTERY2_ENABLED
    case MSG_BATTERY2:
        CHECK_PAYLOAD_SIZE(BATTERY2);
        send_battery2();
        break;
#endif
#endif // AP_BATTERY_ENABLED

#if AP_AHRS_ENABLED
    case MSG_EKF_STATUS_REPORT:
        CHECK_PAYLOAD_SIZE(EKF_STATUS_REPORT);
        AP::ahrs().send_ekf_status_report(*this);
        break;
#endif

    case MSG_MEMINFO:
        CHECK_PAYLOAD_SIZE(MEMINFO);
        send_meminfo();
        break;

#if AP_FENCE_ENABLED
    case MSG_FENCE_STATUS:
        CHECK_PAYLOAD_SIZE(FENCE_STATUS);
        send_fence_status();
        break;
#endif

#if AP_RANGEFINDER_ENABLED
    case MSG_RANGEFINDER:
        CHECK_PAYLOAD_SIZE(RANGEFINDER);
        send_rangefinder();
        break;
#endif

    case MSG_DISTANCE_SENSOR:
        send_distance_sensor();
        break;

#if AP_CAMERA_ENABLED
    case MSG_CAMERA_FEEDBACK:
    case MSG_CAMERA_INFORMATION:
    case MSG_CAMERA_SETTINGS:
#if AP_CAMERA_SEND_FOV_STATUS_ENABLED
    case MSG_CAMERA_FOV_STATUS:
#endif
    case MSG_CAMERA_CAPTURE_STATUS:
        {
            AP_Camera *camera = AP::camera();
            if (camera == nullptr) {
                break;
            }
            return camera->send_mavlink_message(*this, id);
        }
#endif  // AP_CAMERA_ENABLED

    case MSG_SYSTEM_TIME:
        CHECK_PAYLOAD_SIZE(SYSTEM_TIME);
        send_system_time();
        break;
#if AP_GPS_ENABLED
    case MSG_GPS_RAW:
        CHECK_PAYLOAD_SIZE(GPS_RAW_INT);
        AP::gps().send_mavlink_gps_raw(chan);
        break;
    case MSG_GPS_RTK:
        CHECK_PAYLOAD_SIZE(GPS_RTK);
        AP::gps().send_mavlink_gps_rtk(chan, 0);
        break;
#if GPS_MAX_RECEIVERS > 1
    case MSG_GPS2_RAW:
        CHECK_PAYLOAD_SIZE(GPS2_RAW);
        AP::gps().send_mavlink_gps2_raw(chan);
        break;
#endif
#if GPS_MAX_RECEIVERS > 1
    case MSG_GPS2_RTK:
        CHECK_PAYLOAD_SIZE(GPS2_RTK);
        AP::gps().send_mavlink_gps_rtk(chan, 1);
        break;
#endif
#endif  // AP_GPS_ENABLED
#if AP_AHRS_ENABLED
    case MSG_LOCAL_POSITION:
        CHECK_PAYLOAD_SIZE(LOCAL_POSITION_NED);
        send_local_position();
        break;
#endif

#if HAL_MOUNT_ENABLED
    case MSG_GIMBAL_DEVICE_ATTITUDE_STATUS:
        CHECK_PAYLOAD_SIZE(GIMBAL_DEVICE_ATTITUDE_STATUS);
        send_gimbal_device_attitude_status();
        break;
    case MSG_AUTOPILOT_STATE_FOR_GIMBAL_DEVICE:
        CHECK_PAYLOAD_SIZE(AUTOPILOT_STATE_FOR_GIMBAL_DEVICE);
        send_autopilot_state_for_gimbal_device();
        break;
    case MSG_GIMBAL_MANAGER_INFORMATION:
        CHECK_PAYLOAD_SIZE(GIMBAL_MANAGER_INFORMATION);
        send_gimbal_manager_information();
        break;
    case MSG_GIMBAL_MANAGER_STATUS:
        CHECK_PAYLOAD_SIZE(GIMBAL_MANAGER_STATUS);
        send_gimbal_manager_status();
        break;
#endif  // HAL_MOUNT_ENABLED

#if AP_OPTICALFLOW_ENABLED
    case MSG_OPTICAL_FLOW:
        CHECK_PAYLOAD_SIZE(OPTICAL_FLOW);
        send_opticalflow();
        break;
#endif

    case MSG_ATTITUDE_TARGET:
        CHECK_PAYLOAD_SIZE(ATTITUDE_TARGET);
        send_attitude_target();
        break;

    case MSG_POSITION_TARGET_GLOBAL_INT:
        CHECK_PAYLOAD_SIZE(POSITION_TARGET_GLOBAL_INT);
        send_position_target_global_int();
        break;

    case MSG_POSITION_TARGET_LOCAL_NED:
        CHECK_PAYLOAD_SIZE(POSITION_TARGET_LOCAL_NED);
        send_position_target_local_ned();
        break;

    case MSG_POWER_STATUS:
        CHECK_PAYLOAD_SIZE(POWER_STATUS);
        send_power_status();
        break;

#if HAL_WITH_MCU_MONITORING
    case MSG_MCU_STATUS:
        CHECK_PAYLOAD_SIZE(MCU_STATUS);
        send_mcu_status();
        break;
#endif

#if AP_RC_CHANNEL_ENABLED
    case MSG_RC_CHANNELS:
        CHECK_PAYLOAD_SIZE(RC_CHANNELS);
        send_rc_channels();
        break;

#if AP_MAVLINK_MSG_RC_CHANNELS_RAW_ENABLED
    case MSG_RC_CHANNELS_RAW:
        CHECK_PAYLOAD_SIZE(RC_CHANNELS_RAW);
        send_rc_channels_raw();
        break;
#endif  // AP_MAVLINK_MSG_RC_CHANNELS_RAW_ENABLED

#endif

    case MSG_RAW_IMU:
        CHECK_PAYLOAD_SIZE(RAW_IMU);
        send_raw_imu();
        break;

    case MSG_SCALED_IMU:
        CHECK_PAYLOAD_SIZE(SCALED_IMU);
        send_scaled_imu(0, mavlink_msg_scaled_imu_send);
        break;

    case MSG_SCALED_IMU2:
        CHECK_PAYLOAD_SIZE(SCALED_IMU2);
        send_scaled_imu(1, mavlink_msg_scaled_imu2_send);
        break;

    case MSG_SCALED_IMU3:
        CHECK_PAYLOAD_SIZE(SCALED_IMU3);
        send_scaled_imu(2, mavlink_msg_scaled_imu3_send);
        break;
#if AP_MAVLINK_MSG_HIGHRES_IMU_ENABLED
    case MSG_HIGHRES_IMU:
        CHECK_PAYLOAD_SIZE(HIGHRES_IMU);
        send_highres_imu();
        break;
#endif

    case MSG_SCALED_PRESSURE:
        CHECK_PAYLOAD_SIZE(SCALED_PRESSURE);
        send_scaled_pressure();
        break;

    case MSG_SCALED_PRESSURE2:
        CHECK_PAYLOAD_SIZE(SCALED_PRESSURE2);
        send_scaled_pressure2();
        break;

    case MSG_SCALED_PRESSURE3:
        CHECK_PAYLOAD_SIZE(SCALED_PRESSURE3);
        send_scaled_pressure3();
        break;

    case MSG_SERVO_OUTPUT_RAW:
        CHECK_PAYLOAD_SIZE(SERVO_OUTPUT_RAW);
        send_servo_output_raw();
        break;

#if AP_SIM_ENABLED
    case MSG_SIMSTATE:
        CHECK_PAYLOAD_SIZE(SIMSTATE);
        send_simstate();
        break;

    case MSG_SIM_STATE:
        CHECK_PAYLOAD_SIZE(SIM_STATE);
        send_sim_state();
        break;
#endif

    case MSG_SYS_STATUS:
        CHECK_PAYLOAD_SIZE(SYS_STATUS);
        send_sys_status();
        break;

#if AP_AHRS_ENABLED
    case MSG_AHRS2:
        CHECK_PAYLOAD_SIZE(AHRS2);
        send_ahrs2();
        break;
#endif

    case MSG_PID_TUNING:
        CHECK_PAYLOAD_SIZE(PID_TUNING);
        send_pid_tuning();
        break;

    case MSG_NAV_CONTROLLER_OUTPUT:
        CHECK_PAYLOAD_SIZE(NAV_CONTROLLER_OUTPUT);
        send_nav_controller_output();
        break;

#if AP_AHRS_ENABLED
    case MSG_AHRS:
        CHECK_PAYLOAD_SIZE(AHRS);
        send_ahrs();
        break;
#endif

    case MSG_EXTENDED_SYS_STATE:
        CHECK_PAYLOAD_SIZE(EXTENDED_SYS_STATE);
        send_extended_sys_state();
        break;

#if AP_AHRS_ENABLED
    case MSG_VFR_HUD:
        CHECK_PAYLOAD_SIZE(VFR_HUD);
        send_vfr_hud();
        break;
#endif

    case MSG_VIBRATION:
        CHECK_PAYLOAD_SIZE(VIBRATION);
        send_vibration();
        break;

#if HAL_GENERATOR_ENABLED
    case MSG_GENERATOR_STATUS:
    	CHECK_PAYLOAD_SIZE(GENERATOR_STATUS);
    	send_generator_status();
    	break;
#endif

    case MSG_AUTOPILOT_VERSION:
        CHECK_PAYLOAD_SIZE(AUTOPILOT_VERSION);
        send_autopilot_version();
        break;

#if HAL_WITH_ESC_TELEM
    case MSG_ESC_TELEMETRY:
        AP::esc_telem().send_esc_telemetry_mavlink(uint8_t(chan));
        break;
#endif

#if HAL_EFI_ENABLED
    case MSG_EFI_STATUS: {
        CHECK_PAYLOAD_SIZE(EFI_STATUS);
        AP_EFI *efi = AP::EFI();
        if (efi) {
            efi->send_mavlink_status(chan);
        }
        break;
    }
#endif

#if AP_WINCH_ENABLED
    case MSG_WINCH_STATUS:
        CHECK_PAYLOAD_SIZE(WINCH_STATUS);
        send_winch_status();
        break;
#endif

#if AP_RANGEFINDER_ENABLED && APM_BUILD_TYPE(APM_BUILD_Rover)
    case MSG_WATER_DEPTH:
        CHECK_PAYLOAD_SIZE(WATER_DEPTH);
        send_water_depth();
        break;
#endif

#if HAL_HIGH_LATENCY2_ENABLED
    case MSG_HIGH_LATENCY2:
        CHECK_PAYLOAD_SIZE(HIGH_LATENCY2);
        send_high_latency2();
        break;
#endif // HAL_HIGH_LATENCY2_ENABLED

#if AP_AIS_ENABLED
    case MSG_AIS_VESSEL: {
        AP_AIS *ais = AP_AIS::get_singleton();
        if (ais) {
            ais->send(chan);
        }
        break;
    }
#endif

#if AP_MAVLINK_MSG_UAVIONIX_ADSB_OUT_STATUS_ENABLED
    case MSG_UAVIONIX_ADSB_OUT_STATUS:
        CHECK_PAYLOAD_SIZE(UAVIONIX_ADSB_OUT_STATUS);
        send_uavionix_adsb_out_status();
        break;
#endif

#if AP_MAVLINK_MSG_RELAY_STATUS_ENABLED
    case MSG_RELAY_STATUS:
        ret = send_relay_status();
        break;
#endif

    default:
        // try_send_message must always at some stage return true for
        // a message, or we will attempt to infinitely retry the
        // message as part of send_message.
        // This message will be sent out at the same rate as the
        // unknown message, so should be safe.
        GCS_SEND_TEXT(MAV_SEVERITY_DEBUG, "Sending unknown message (%u)", id);
#if CONFIG_HAL_BOARD == HAL_BOARD_SITL
        AP_HAL::panic("Sending unknown ap_message %u", id);
#endif
        break;
    }

    return ret;
}

uint16_t GCS_MAVLINK::get_interval_for_stream(GCS_MAVLINK::streams id) const
{
    const int16_t frate = streamRates[id].get();
    if (frate == 0) {
        return 0;
    }
    const uint32_t ret = 1000/frate;
    if (ret > 60000) {
        return 60000;
    }
    return ret;
}

void GCS_MAVLINK::initialise_message_intervals_for_stream(GCS_MAVLINK::streams id)
{
    for (uint8_t i=0; all_stream_entries[i].ap_message_ids != nullptr; i++) {
        const GCS_MAVLINK::stream_entries &entries = all_stream_entries[i];
        if (entries.stream_id != id) {
            continue;
        }
        // found it!
        const uint16_t interval_ms = get_interval_for_stream(id);
        for (uint8_t j=0; j<entries.num_ap_message_ids; j++) {
            set_ap_message_interval(entries.ap_message_ids[j], interval_ms);
        }
        break;
    }
}

#if HAL_MAVLINK_INTERVALS_FROM_FILES_ENABLED
// open and read contents of path, setting message intervals from each
// line
DefaultIntervalsFromFiles::DefaultIntervalsFromFiles(uint16_t max_num)
{
    if (max_num == 0) {
        return;
    }
    _intervals = NEW_NOTHROW from_file_default_interval[max_num];
    _max_intervals = max_num;
}

DefaultIntervalsFromFiles::~DefaultIntervalsFromFiles()
{
    delete[] (_intervals);
}

void DefaultIntervalsFromFiles::set(ap_message id, uint16_t interval)
{
    if (_intervals == nullptr) {
        return;
    }

    // update any existing interval (last-one-in wins)
    for (uint8_t i=0; i<_num_intervals; i++) {
        if (_intervals[i].id == id) {
            _intervals[i].interval = interval;
            return;
        }
    }

    // store an interval we've not seen before:
    if (_num_intervals == _max_intervals) {
        return;
    }

    _intervals[_num_intervals].id = id;
    _intervals[_num_intervals].interval = interval;
    _num_intervals++;
}

bool DefaultIntervalsFromFiles::get_interval_for_ap_message_id(ap_message id, uint16_t &interval) const
{
    for (uint16_t i=0; i<_num_intervals; i++) {
        if (_intervals[i].id == id) {
            interval = _intervals[i].interval;
            return true;
        }
    }
    return false;
}

ap_message DefaultIntervalsFromFiles::id_at(uint8_t ofs) const
{
    if (_intervals == nullptr || ofs >= _num_intervals) {
        return MSG_LAST;
    }
    return _intervals[ofs].id;
}

uint16_t DefaultIntervalsFromFiles::interval_at(uint8_t ofs) const
{
    if (_intervals == nullptr || ofs >= _num_intervals) {
        return -1;  // unsigned-integer wrap
    }
    return _intervals[ofs].interval;
}

void GCS_MAVLINK::get_intervals_from_filepath(const char *path, DefaultIntervalsFromFiles &intervals)
{
    const int f = AP::FS().open(path, O_RDONLY);
    if (f == -1) {
        return;
    }

    char line[20];
    while (AP::FS().fgets(line, sizeof(line)-1, f)) {
        char *saveptr = nullptr;
        const char *mavlink_id_str = strtok_r(line, " ", &saveptr);
        if (mavlink_id_str == nullptr || strlen(mavlink_id_str) == 0) {
            continue;
        }
        const uint32_t mavlink_id = atoi(mavlink_id_str);

        const ap_message msg_id = mavlink_id_to_ap_message_id(mavlink_id);
        if (msg_id == MSG_LAST) {
            continue;
        }

        const char *interval_str = strtok_r(nullptr, "\r\n", &saveptr);
        if (interval_str == nullptr || strlen(interval_str) == 0) {
            continue;
        }
        const uint16_t interval = atoi(interval_str);

        intervals.set(msg_id, interval);
    }

    AP::FS().close(f);
}

void GCS_MAVLINK::initialise_message_intervals_from_config_files()
{
    static const char *path_templates[] {
        "@ROMFS/message-intervals-chan%u.txt",
        "message-intervals-chan%u.txt"
    };

    // don't do anything at all if no files exist:
    bool exists = false;
    for (const char * path_template : path_templates) {
        struct stat stats;
        char *path;
        if (asprintf(&path, path_template, chan) == -1) {
            continue;
        }
        if (AP::FS().stat(path, &stats) < 0) {
            free(path);
            continue;
        }
        free(path);
        if (stats.st_size == 0) {
            continue;
        }
        exists = true;
        break;
    }
    if (!exists) {
        return;
    }

    // first over-allocate:
    DefaultIntervalsFromFiles *overallocated = NEW_NOTHROW DefaultIntervalsFromFiles(128);
    if (overallocated == nullptr) {
        return;
    }
    for (const char * path_template : path_templates) {
        char *path;
        if (asprintf(&path, path_template, chan) == -1) {
            continue;
        }
        get_intervals_from_filepath(path, *overallocated);
        free(path);
    }

    // then allocate just the right number and redo all of the work:
    const uint16_t num_required = overallocated->num_intervals();
    delete overallocated;
    overallocated = nullptr;

    default_intervals_from_files = NEW_NOTHROW DefaultIntervalsFromFiles(num_required);
    if (default_intervals_from_files == nullptr) {
        return;
    }
    for (const char * path_template : path_templates) {
        char *path;
        if (asprintf(&path, path_template, chan) == -1) {
            continue;
        }
        get_intervals_from_filepath(path, *default_intervals_from_files);
        free(path);
    }

    // now actually initialise the intervals:
    for (uint8_t i=0; i<default_intervals_from_files->num_intervals(); i++) {
        const ap_message id = default_intervals_from_files->id_at(i);
        if (id == MSG_LAST) {
            // internal error
            break;
        }
        const uint16_t interval = default_intervals_from_files->interval_at(i);
        set_ap_message_interval(id, interval);
    }
}
#endif

void GCS_MAVLINK::initialise_message_intervals_from_streamrates()
{
    // this is O(n^2), but it's once at boot and across a 10-entry list...
    for (uint8_t i=0; all_stream_entries[i].ap_message_ids != nullptr; i++) {
        initialise_message_intervals_for_stream(all_stream_entries[i].stream_id);
    }
#if HAL_HIGH_LATENCY2_ENABLED
    if (!is_high_latency_link) {
        set_mavlink_message_id_interval(MAVLINK_MSG_ID_HEARTBEAT, 1000);
    } else {
        set_mavlink_message_id_interval(MAVLINK_MSG_ID_HIGH_LATENCY2, 5000);
    }
#else
    set_mavlink_message_id_interval(MAVLINK_MSG_ID_HEARTBEAT, 1000);
#endif
}

bool GCS_MAVLINK::get_default_interval_for_ap_message(const ap_message id, uint16_t &interval) const
{
    if (id == MSG_HEARTBEAT) {
        // handle heartbeat requests as a special case because heartbeat is not "streamed"
        interval = 1000;
        return true;
    }

#if HAL_HIGH_LATENCY2_ENABLED
    if (id == MSG_HIGH_LATENCY2) {
        // handle HL2 requests as a special case because HL2 is not "streamed"
        interval = 5000;
        return true;
    }
#endif

#if HAL_MAVLINK_INTERVALS_FROM_FILES_ENABLED
    // a user can specify default rates in files, which are read close
    // to vehicle startup
    if (default_intervals_from_files != nullptr &&
        default_intervals_from_files->get_interval_for_ap_message_id(id, interval)) {
        return true;
    }
#endif

    // find which stream this ap_message is in
    for (uint8_t i=0; all_stream_entries[i].ap_message_ids != nullptr; i++) {
        const GCS_MAVLINK::stream_entries &entries = all_stream_entries[i];
        for (uint8_t j=0; j<entries.num_ap_message_ids; j++) {
            if (entries.ap_message_ids[j] == id) {
                interval = get_interval_for_stream(all_stream_entries[i].stream_id);
                return true;
            }
        }
    }
    return false;
}

/*
  correct an offboard timestamp in microseconds into a local timestamp
  since boot in milliseconds. See the JitterCorrection code for details

  Return a value in milliseconds since boot (for use by the EKF)
 */
uint32_t GCS_MAVLINK::correct_offboard_timestamp_usec_to_ms(uint64_t offboard_usec, uint16_t payload_size)
{
    uint64_t local_us;
    // if the HAL supports it then constrain the latest possible time
    // the packet could have been sent by the uart receive time and
    // the baudrate and packet size.
    uint64_t uart_receive_time = _port->receive_time_constraint_us(payload_size);
    if (uart_receive_time != 0) {
        local_us = uart_receive_time;
    } else {
        local_us = AP_HAL::micros64();
    }
    uint64_t corrected_us = lag_correction.correct_offboard_timestamp_usec(offboard_usec, local_us);

    return corrected_us / 1000U;
}

/*
  return true if we will accept this packet. Used to implement SYSID_ENFORCE
 */
bool GCS_MAVLINK::accept_packet(const mavlink_status_t &status,
                                const mavlink_message_t &msg) const
{
    if (msg.sysid == mavlink_system.sysid) {
        // accept packets from our own components
        // (e.g. mavlink-connected companion computers)
        return true;
    }

    if (msg.sysid == sysid_my_gcs()) {
        return true;
    }

    if (msg.msgid == MAVLINK_MSG_ID_RADIO ||
        msg.msgid == MAVLINK_MSG_ID_RADIO_STATUS) {
        return true;
    }

    if (!sysid_enforce()) {
        return true;
    }

    return false;
}

/*
  update UART pass-thru, if enabled
 */
void GCS::update_passthru(void)
{
#if APM_BUILD_TYPE(APM_BUILD_UNKNOWN)
    // examples don't have AP::serialmanager
    return;
#endif

    WITH_SEMAPHORE(_passthru.sem);
    uint32_t now = AP_HAL::millis();
    uint32_t baud1, baud2;
    uint8_t parity1 = 0, parity2 = 0;
    bool enabled = AP::serialmanager().get_passthru(_passthru.port1, _passthru.port2, _passthru.timeout_s,
                                                    baud1, baud2);
    if (enabled && !_passthru.enabled) {
        _passthru.start_ms = now;
        _passthru.last_ms = 0;
        _passthru.enabled = true;
        _passthru.last_port1_data_ms = now;
        _passthru.baud1 = baud1;
        _passthru.baud2 = baud2;
        _passthru.parity1 = parity1 = _passthru.port1->get_parity();
        _passthru.parity2 = parity2 = _passthru.port2->get_parity();
        GCS_SEND_TEXT(MAV_SEVERITY_INFO, "Passthru enabled");
        if (!_passthru.timer_installed) {
            _passthru.timer_installed = true;
            hal.scheduler->register_timer_process(FUNCTOR_BIND_MEMBER(&GCS::passthru_timer, void));
        }
    } else if (!enabled && _passthru.enabled) {
        _passthru.enabled = false;
        _passthru.port1->lock_port(0, 0);
        _passthru.port2->lock_port(0, 0);
        // Restore original baudrates
        if (_passthru.baud1 != baud1) {
            _passthru.port1->end();
            _passthru.port1->begin(baud1);
        }
        if (_passthru.baud2 != baud2) {
            _passthru.port2->end();
            _passthru.port2->begin(baud2);
        }
        // Restore original parity
        if (_passthru.parity1 != parity1) {
            _passthru.port1->configure_parity(parity1);
        }
        if (_passthru.parity2 != parity2) {
            _passthru.port2->configure_parity(parity2);
        }
        GCS_SEND_TEXT(MAV_SEVERITY_INFO, "Passthru disabled");
    } else if (enabled &&
               _passthru.timeout_s &&
               now - _passthru.last_port1_data_ms > uint32_t(_passthru.timeout_s)*1000U) {
        // timed out, disable
        _passthru.enabled = false;
        _passthru.port1->lock_port(0, 0);
        _passthru.port2->lock_port(0, 0);
        AP::serialmanager().disable_passthru();
        // Restore original baudrates
        if (_passthru.baud1 != baud1) {
            _passthru.port1->end();
            _passthru.port1->begin(baud1);
        }
        if (_passthru.baud2 != baud2) {
            _passthru.port2->end();
            _passthru.port2->begin(baud2);
        }
        // Restore original parity
        if (_passthru.parity1 != parity1) {
            _passthru.port1->configure_parity(parity1);
        }
        if (_passthru.parity2 != parity2) {
            _passthru.port2->configure_parity(parity2);
        }
        GCS_SEND_TEXT(MAV_SEVERITY_INFO, "Passthru timed out");
    }
}

/*
  called at 1kHz to handle pass-thru between SERIAL_PASS1 and SERIAL_PASS2 ports
 */
void GCS::passthru_timer(void)
{
    WITH_SEMAPHORE(_passthru.sem);

    if (!_passthru.enabled) {
        // it has been disabled after starting
        return;
    }
    if (_passthru.start_ms != 0) {
        uint32_t now = AP_HAL::millis();
        if (now - _passthru.start_ms < 1000) {
            // delay for 1s so the reply for the SERIAL_PASS2 param set can be seen by GCS
            return;
        }
        _passthru.start_ms = 0;
        _passthru.port1->begin(_passthru.baud1);
        _passthru.port2->begin(_passthru.baud2);
    }

    // while pass-thru is enabled lock both ports. They remain
    // locked until disabled again, or reboot
    const uint32_t lock_key = 0x3256AB9F;
    _passthru.port1->lock_port(lock_key, lock_key);
    _passthru.port2->lock_port(lock_key, lock_key);

    // Check for requested Baud rates and parity over USB
    uint32_t baud = _passthru.port1->get_usb_baud();
    uint8_t parity = _passthru.port1->get_usb_parity();
    if (baud != 0) { // port1 is USB
        if (_passthru.baud2 != baud) {
            _passthru.baud2 = baud;
            _passthru.port2->end();
            _passthru.port2->begin_locked(baud, 0, 0, lock_key);
        }

        if (_passthru.parity2 != parity) {
            _passthru.parity2 = parity;
            _passthru.port2->configure_parity(parity);
        }
    }

    baud = _passthru.port2->get_usb_baud();
    parity = _passthru.port2->get_usb_parity();
    if (baud != 0) { // port2 is USB
        if (_passthru.baud1 != baud) {
            _passthru.baud1 = baud;
            _passthru.port1->end();
            _passthru.port1->begin_locked(baud, 0, 0, lock_key);
        }

        if (_passthru.parity1 != parity) {
            _passthru.parity1 = parity;
            _passthru.port1->configure_parity(parity);
        }
    }

    uint8_t buf[64];

    // read from port1, and write to port2
    int16_t nbytes = _passthru.port1->read_locked(buf, MIN(sizeof(buf),_passthru.port2->txspace()), lock_key);
    if (nbytes > 0) {
        _passthru.last_port1_data_ms = AP_HAL::millis();
        _passthru.port2->write_locked(buf, nbytes, lock_key);
    }

    // read from port2, and write to port1
    nbytes = _passthru.port2->read_locked(buf, MIN(sizeof(buf),_passthru.port1->txspace()), lock_key);
    if (nbytes > 0) {
        _passthru.port1->write_locked(buf, nbytes, lock_key);
    }
}

bool GCS_MAVLINK::mavlink_coordinate_frame_to_location_alt_frame(const MAV_FRAME coordinate_frame, Location::AltFrame &frame)
{
    switch (coordinate_frame) {
    case MAV_FRAME_GLOBAL_RELATIVE_ALT: // solo shot manager incorrectly sends RELATIVE_ALT instead of RELATIVE_ALT_INT
    case MAV_FRAME_GLOBAL_RELATIVE_ALT_INT:
        frame = Location::AltFrame::ABOVE_HOME;
        return true;
    case MAV_FRAME_GLOBAL_TERRAIN_ALT:
    case MAV_FRAME_GLOBAL_TERRAIN_ALT_INT:
        frame = Location::AltFrame::ABOVE_TERRAIN;
        return true;
    case MAV_FRAME_GLOBAL:
    case MAV_FRAME_GLOBAL_INT:
        frame = Location::AltFrame::ABSOLUTE;
        return true;
    default:
#if CONFIG_HAL_BOARD == HAL_BOARD_SITL
        GCS_SEND_TEXT(MAV_SEVERITY_INFO, "Unknown mavlink coordinate frame %u", coordinate_frame);
#endif
        return false;
    }
}

uint64_t GCS_MAVLINK::capabilities() const
{
    uint64_t ret = MAV_PROTOCOL_CAPABILITY_PARAM_FLOAT |
        MAV_PROTOCOL_CAPABILITY_COMPASS_CALIBRATION;

    const auto mavlink_protocol = uartstate->get_protocol();
    if (mavlink_protocol == AP_SerialManager::SerialProtocol_MAVLink2 || mavlink_protocol == AP_SerialManager::SerialProtocol_MAVLinkHL) {
        ret |= MAV_PROTOCOL_CAPABILITY_MAVLINK2;
    }

#if AP_ADVANCEDFAILSAFE_ENABLED
    AP_AdvancedFailsafe *failsafe = AP::advancedfailsafe();
    if (failsafe != nullptr && failsafe->enabled()) {
        // Copter and Sub may also set this bit as they can always terminate
        ret |= MAV_PROTOCOL_CAPABILITY_FLIGHT_TERMINATION;
    }
#endif

#if HAL_RALLY_ENABLED
    if (AP::rally()) {
        ret |= MAV_PROTOCOL_CAPABILITY_MISSION_RALLY;
    }
#endif

#if AP_FENCE_ENABLED
    if (AP::fence()) {
        ret |= MAV_PROTOCOL_CAPABILITY_MISSION_FENCE;
    }
#endif

#if AP_MAVLINK_FTP_ENABLED
    if (!AP_BoardConfig::ftp_disabled()){  //if ftp disable board option is not set
        ret |= MAV_PROTOCOL_CAPABILITY_FTP;
    }
#endif

    return ret;
}


#if AP_RC_CHANNEL_ENABLED
void GCS_MAVLINK::manual_override(RC_Channel *c, int16_t value_in, const uint16_t offset, const float scaler, const uint32_t tnow, const bool reversed)
{
    if (c == nullptr) {
        return;
    }
    int16_t override_value = 0;
    if (value_in != INT16_MAX) {
        const int16_t radio_min = c->get_radio_min();
        const int16_t radio_max = c->get_radio_max();
        if (reversed) {
            value_in *= -1;
        }
        override_value = radio_min + (radio_max - radio_min) * (value_in + offset) / scaler;
    }
    c->set_override(override_value, tnow);
}

void GCS_MAVLINK::handle_manual_control(const mavlink_message_t &msg)
{
    if (msg.sysid != sysid_my_gcs()) {
        return; // only accept control from our gcs
    }

    mavlink_manual_control_t packet;
    mavlink_msg_manual_control_decode(&msg, &packet);

    if (packet.target != gcs().sysid_this_mav()) {
        return; // only accept control aimed at us
    }

    uint32_t tnow = AP_HAL::millis();

    handle_manual_control_axes(packet, tnow);

    // a manual control message is considered to be a 'heartbeat'
    // from the ground station for failsafe purposes
    gcs().sysid_myggcs_seen(tnow);
}
#endif  // AP_RC_CHANNEL_ENABLED

#if AP_RSSI_ENABLED
uint8_t GCS_MAVLINK::receiver_rssi() const
{
    AP_RSSI *aprssi = AP::rssi();
    if (aprssi == nullptr) {
        return 255;
    }

    if (!aprssi->enabled()) {
        return 255;
    }

    // scale across the full valid range
    return aprssi->read_receiver_rssi() * 254;
}
#endif

GCS &gcs()
{
    return *GCS::get_singleton();
}

/*
  send HIGH_LATENCY2 message
 */
#if HAL_HIGH_LATENCY2_ENABLED
void GCS_MAVLINK::send_high_latency2() const
{
#if AP_AHRS_ENABLED
    AP_AHRS &ahrs = AP::ahrs();
    Location global_position_current;
    UNUSED_RESULT(ahrs.get_location(global_position_current));
#if AP_BATTERY_ENABLED
    const int8_t battery_remaining = battery_remaining_pct(AP_BATT_PRIMARY_INSTANCE);
#endif

    uint16_t current_waypoint = 0;
#if AP_MISSION_ENABLED
    AP_Mission *mission = AP::mission();
    if (mission != nullptr) {
        current_waypoint = mission->get_current_nav_index();
    }
#endif

    uint32_t present;
    uint32_t enabled;
    uint32_t health;
    gcs().get_sensor_status_flags(present, enabled, health);
    // Remap HL_FAILURE_FLAG from system status flags
    static const struct PACKED status_map_t {
        MAV_SYS_STATUS_SENSOR sensor;
        HL_FAILURE_FLAG failure_flag;
    } status_map[] {
        { MAV_SYS_STATUS_SENSOR_GPS, HL_FAILURE_FLAG_GPS },
        { MAV_SYS_STATUS_SENSOR_DIFFERENTIAL_PRESSURE, HL_FAILURE_FLAG_DIFFERENTIAL_PRESSURE },
        { MAV_SYS_STATUS_SENSOR_ABSOLUTE_PRESSURE, HL_FAILURE_FLAG_ABSOLUTE_PRESSURE },
        { MAV_SYS_STATUS_SENSOR_3D_ACCEL, HL_FAILURE_FLAG_3D_ACCEL },
        { MAV_SYS_STATUS_SENSOR_3D_GYRO, HL_FAILURE_FLAG_3D_GYRO },
        { MAV_SYS_STATUS_SENSOR_3D_MAG, HL_FAILURE_FLAG_3D_MAG },
        { MAV_SYS_STATUS_TERRAIN, HL_FAILURE_FLAG_TERRAIN },
        { MAV_SYS_STATUS_SENSOR_BATTERY, HL_FAILURE_FLAG_BATTERY },
        { MAV_SYS_STATUS_SENSOR_RC_RECEIVER, HL_FAILURE_FLAG_RC_RECEIVER },
        { MAV_SYS_STATUS_GEOFENCE, HL_FAILURE_FLAG_GEOFENCE },
        { MAV_SYS_STATUS_AHRS, HL_FAILURE_FLAG_ESTIMATOR },
    };

    uint16_t failure_flags = 0;
    for (auto &map_entry : status_map) {
        if ((health & map_entry.sensor) == 0) {
            failure_flags |= map_entry.failure_flag;
        }
    }

    //send_text(MAV_SEVERITY_INFO, "Yaw: %u", (((uint16_t)ahrs.yaw_sensor / 100) % 360));

    mavlink_msg_high_latency2_send(chan, 
        AP_HAL::millis(), //[ms] Timestamp (milliseconds since boot or Unix epoch)
        gcs().frame_type(), // Type of the MAV (quadrotor, helicopter, etc.)
        MAV_AUTOPILOT_ARDUPILOTMEGA, // Autopilot type / class. Use MAV_AUTOPILOT_INVALID for components that are not flight controllers.
        gcs().custom_mode(), // A bitfield for use for autopilot-specific flags (2 byte version).
        global_position_current.lat, // [degE7] Latitude
        global_position_current.lng, // [degE7] Longitude
        global_position_current.alt * 0.01f, // [m] Altitude above mean sea level
        high_latency_target_altitude(), // [m] Altitude setpoint
        (((uint16_t)ahrs.yaw_sensor / 100) % 360) / 2, // [deg/2] Heading
        high_latency_tgt_heading(), // [deg/2] Heading setpoint
        high_latency_tgt_dist(), // [dam] Distance to target waypoint or position
        abs(vfr_hud_throttle()), // [%] Throttle
        MIN(vfr_hud_airspeed() * 5, UINT8_MAX), // [m/s*5] Airspeed
        high_latency_tgt_airspeed(), // [m/s*5] Airspeed setpoint
        MIN(ahrs.groundspeed() * 5, UINT8_MAX), // [m/s*5] Groundspeed
        high_latency_wind_speed(), // [m/s*5] Windspeed
        high_latency_wind_direction(), // [deg/2] Wind heading
        0, // [dm] Maximum error horizontal position since last message
        0, // [dm] Maximum error vertical position since last message
        high_latency_air_temperature(), // [degC] Air temperature from airspeed sensor
        0, // [dm/s] Maximum climb rate magnitude since last message
#if AP_BATTERY_ENABLED
        battery_remaining, // [%] Battery level (-1 if field not provided).
#else
        -1,
#endif
        current_waypoint, // Current waypoint number
        failure_flags, // Bitmap of failure flags.
        base_mode(), // Field for custom payload. base mode (arming status) in ArduPilot's case
        0, // Field for custom payload.
        0); // Field for custom payload.
#endif
}

int8_t GCS_MAVLINK::high_latency_air_temperature() const
{
#if AP_AIRSPEED_ENABLED
    // return units are degC
    AP_Airspeed *airspeed = AP_Airspeed::get_singleton();
    float air_temperature;
    if (airspeed != nullptr && airspeed->enabled() && airspeed->get_temperature(air_temperature)) {
        return air_temperature;
    }
#endif

    return INT8_MIN;
}

/*
  handle a MAV_CMD_CONTROL_HIGH_LATENCY command 

  Enable or disable any marked (via SERIALn_PROTOCOL) high latency connections
 */
MAV_RESULT GCS_MAVLINK::handle_control_high_latency(const mavlink_command_int_t &packet)
{
    // high latency mode is enabled if param1=1 or disabled if param1=0
    if (is_equal(packet.param1, 0.0f)) {
        gcs().enable_high_latency_connections(false);
    } else if (is_equal(packet.param1, 1.0f)) {
        gcs().enable_high_latency_connections(true);
    } else {
        return MAV_RESULT_FAILED;
    }

    // send to all other mavlink components with same sysid
    mavlink_command_long_t hl_msg{};
    hl_msg.command = MAV_CMD_CONTROL_HIGH_LATENCY;
    hl_msg.param1 = packet.param1;
    GCS_MAVLINK::send_to_components(MAVLINK_MSG_ID_COMMAND_LONG, (char*)&hl_msg, sizeof(hl_msg));

    return MAV_RESULT_ACCEPTED;
}
#endif // HAL_HIGH_LATENCY2_ENABLED

#if AP_RCPROTOCOL_MAVLINK_RADIO_ENABLED
void GCS_MAVLINK::handle_radio_rc_channels(const mavlink_message_t &msg)
{
    mavlink_radio_rc_channels_t packet;
    mavlink_msg_radio_rc_channels_decode(&msg, &packet);

    AP::RC().handle_radio_rc_channels(&packet);
}
#endif // AP_RCPROTOCOL_MAVLINK_RADIO_ENABLED

#endif  // HAL_GCS_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               