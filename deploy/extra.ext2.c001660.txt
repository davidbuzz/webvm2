FIFO filled or end of packet
    {CC2500_17_MCSM1,    0x03}, // RX->IDLE, CCA always, TX -> IDLE
    {CC2500_18_MCSM0,    0x08}, // XOSC expire 64, cal never
    {CC2500_3E_PATABLE,  0xFF}, // initially max power
};

const uint16_t CRCTable[] = {
    0x0000,0x1189,0x2312,0x329b,0x4624,0x57ad,0x6536,0x74bf,
    0x8c48,0x9dc1,0xaf5a,0xbed3,0xca6c,0xdbe5,0xe97e,0xf8f7,
    0x1081,0x0108,0x3393,0x221a,0x56a5,0x472c,0x75b7,0x643e,
    0x9cc9,0x8d40,0xbfdb,0xae52,0xdaed,0xcb64,0xf9ff,0xe876,
    0x2102,0x308b,0x0210,0x1399,0x6726,0x76af,0x4434,0x55bd,
    0xad4a,0xbcc3,0x8e58,0x9fd1,0xeb6e,0xfae7,0xc87c,0xd9f5,
    0x3183,0x200a,0x1291,0x0318,0x77a7,0x662e,0x54b5,0x453c,
    0xbdcb,0xac42,0x9ed9,0x8f50,0xfbef,0xea66,0xd8fd,0xc974,
    0x4204,0x538d,0x6116,0x709f,0x0420,0x15a9,0x2732,0x36bb,
    0xce4c,0xdfc5,0xed5e,0xfcd7,0x8868,0x99e1,0xab7a,0xbaf3,
    0x5285,0x430c,0x7197,0x601e,0x14a1,0x0528,0x37b3,0x263a,
    0xdecd,0xcf44,0xfddf,0xec56,0x98e9,0x8960,0xbbfb,0xaa72,
    0x6306,0x728f,0x4014,0x519d,0x2522,0x34ab,0x0630,0x17b9,
    0xef4e,0xfec7,0xcc5c,0xddd5,0xa96a,0xb8e3,0x8a78,0x9bf1,
    0x7387,0x620e,0x5095,0x411c,0x35a3,0x242a,0x16b1,0x0738,
    0xffcf,0xee46,0xdcdd,0xcd54,0xb9eb,0xa862,0x9af9,0x8b70,
    0x8408,0x9581,0xa71a,0xb693,0xc22c,0xd3a5,0xe13e,0xf0b7,
    0x0840,0x19c9,0x2b52,0x3adb,0x4e64,0x5fed,0x6d76,0x7cff,
    0x9489,0x8500,0xb79b,0xa612,0xd2ad,0xc324,0xf1bf,0xe036,
    0x18c1,0x0948,0x3bd3,0x2a5a,0x5ee5,0x4f6c,0x7df7,0x6c7e,
    0xa50a,0xb483,0x8618,0x9791,0xe32e,0xf2a7,0xc03c,0xd1b5,
    0x2942,0x38cb,0x0a50,0x1bd9,0x6f66,0x7eef,0x4c74,0x5dfd,
    0xb58b,0xa402,0x9699,0x8710,0xf3af,0xe226,0xd0bd,0xc134,
    0x39c3,0x284a,0x1ad1,0x0b58,0x7fe7,0x6e6e,0x5cf5,0x4d7c,
    0xc60c,0xd785,0xe51e,0xf497,0x8028,0x91a1,0xa33a,0xb2b3,
    0x4a44,0x5bcd,0x6956,0x78df,0x0c60,0x1de9,0x2f72,0x3efb,
    0xd68d,0xc704,0xf59f,0xe416,0x90a9,0x8120,0xb3bb,0xa232,
    0x5ac5,0x4b4c,0x79d7,0x685e,0x1ce1,0x0d68,0x3ff3,0x2e7a,
    0xe70e,0xf687,0xc41c,0xd595,0xa12a,0xb0a3,0x8238,0x93b1,
    0x6b46,0x7acf,0x4854,0x59dd,0x2d62,0x3ceb,0x0e70,0x1ff9,
    0xf78f,0xe606,0xd49d,0xc514,0xb1ab,0xa022,0x92b9,0x8330,
    0x7bc7,0x6a4e,0x58d5,0x495c,0x3de3,0x2c6a,0x1ef1,0x0f78
};

/*
  static probe function for radio auto-detect
 */
bool AP_Radio_cc2500::probe(void)
{
    auto dev = hal.spi->get_device("cc2500");
    dev->get_semaphore()->take_blocking();
    uint8_t r1=0, r2=0;
    if (!dev->read_registers(CC2500_30_PARTNUM | CC2500_READ_BURST | CC2500_READ_SINGLE, &r1, 1) || r1 != 0x80 ||
        !dev->read_registers(CC2500_31_VERSION | CC2500_READ_BURST | CC2500_READ_SINGLE, &r2, 1) || r2 != 0x03) {
        dev->get_semaphore()->give();
        return false;
    }
    dev->get_semaphore()->give();
    return true;
}

/*
  initialise the radio
 */
void AP_Radio_cc2500::radio_init(void)
{
    if (cc2500.ReadReg(CC2500_30_PARTNUM | CC2500_READ_BURST) != 0x80 ||
        cc2500.ReadReg(CC2500_31_VERSION | CC2500_READ_BURST) != 0x03) {
        Debug(1, "cc2500: radio not found\n");
        return;
    }

    Debug(1, "cc2500: radio_init starting\n");

    cc2500.Reset();
    hal.scheduler->delay_microseconds(100);
    if (get_protocol() == AP_Radio::PROTOCOL_CC2500_GFSK) {
        Debug(1,"Using GFSK configuration\n");
        for (uint8_t i=0; i<ARRAY_SIZE(radio_config_GFSK); i++) {
            cc2500.WriteRegCheck(radio_config_GFSK[i].reg, radio_config_GFSK[i].value);
        }
    } else {
        for (uint8_t i=0; i<ARRAY_SIZE(radio_config); i++) {
            cc2500.WriteRegCheck(radio_config[i].reg, radio_config[i].value);
        }
    }

    cc2500.Strobe(CC2500_SIDLE);	// Go to idle...

    hal.scheduler->delay_microseconds(10*1000);

    // setup handler for rising edge of IRQ pin
    hal.gpio->attach_interrupt(HAL_GPIO_RADIO_IRQ, trigger_irq_radio_event, AP_HAL::GPIO::INTERRUPT_RISING);

    // fill in rxid for use in double bind prevention
    char sysid[50] {};
    hal.util->get_system_id(sysid);
    uint16_t sysid_crc = calc_crc((const uint8_t *)sysid, strnlen(sysid, sizeof(sysid)));
    if (sysid_crc == 0) {
        sysid_crc = 1;
    }
    t_status.rxid[0] = sysid_crc & 0xFF;
    t_status.rxid[1] = sysid_crc >> 8;

    initTuneRx();

    if (load_bind_info()) {
        Debug(3,"Loaded bind info\n");
    } else {
        listLength = NUM_CHANNELS;
        bindOffset = 0;
        setup_hopping_table_SRT();
    }

    uint8_t factory_test = get_factory_test();
    if (factory_test != 0) {
        bindTxId[0] = uint8_t(factory_test * 17);
        bindTxId[1] = uint8_t(~bindTxId[0]);
        setup_hopping_table_SRT();
    }

    // we go straight into search, and rely on autobind
    initialiseData(0);
    protocolState = STATE_SEARCH;
    packet_timer = AP_HAL::micros();
    chanskip = 1;
    nextChannel(1);

    // set default autobind power to suit the cc2500
    AP_Param::set_default_by_name("BRD_RADIO_ABLVL", 90);

    chVTSet(&timeout_vt, chTimeMS2I(INTER_PACKET_INITIAL_MS), trigger_timeout_event, nullptr);

}

void AP_Radio_cc2500::trigger_irq_radio_event()
{
    //we are called from ISR context
    chSysLockFromISR();
    irq_time_us = AP_HAL::micros();
    chEvtSignalI(_irq_handler_ctx, EVT_IRQ);
    chSysUnlockFromISR();
}

void AP_Radio_cc2500::trigger_timeout_event(virtual_timer_t* vt, void *arg)
{
    (void)arg;
    //we are called from ISR context
    chSysLockFromISR();
    chVTSetI(&timeout_vt, chTimeMS2I(INTER_PACKET_INITIAL_MS), trigger_timeout_event, nullptr);
    chEvtSignalI(_irq_handler_ctx, EVT_TIMEOUT);
    chSysUnlockFromISR();
}

void AP_Radio_cc2500::start_recv_bind(void)
{
    chan_count = 0;
    packet_timer = AP_HAL::micros();
    chEvtSignal(_irq_handler_ctx, EVT_BIND);
    Debug(1,"Starting bind\n");
}

// handle a data96 mavlink packet for fw upload
void AP_Radio_cc2500::handle_data_packet(mavlink_channel_t chan, const mavlink_data96_t &m)
{
    uint32_t ofs=0;
    memcpy(&ofs, &m.data[0], 4);
    Debug(4, "got data96 of len %u from chan %u at offset %u\n", m.len, chan, unsigned(ofs));
    if (sem.take_nonblocking()) {
        fwupload.chan = chan;
        fwupload.need_ack = false;
        fwupload.offset = ofs;
        fwupload.length = MIN(m.len-4, 92);
        fwupload.acked = 0;
        fwupload.sequence++;
        if (m.type == 43) {
            // sending a tune to play - for development testing
            fwupload.fw_type = TELEM_PLAY;
            fwupload.length = MIN(m.len, 90);
            fwupload.offset = 0;
            memcpy(&fwupload.pending_data[0], &m.data[0], fwupload.length);
        } else {
            // sending a chunk of firmware OTA upload
            fwupload.fw_type = TELEM_FW;
            memcpy(&fwupload.pending_data[0], &m.data[4], fwupload.length);
        }
        sem.give();
    }
}

/*
  handle a FrSky D16 packet
 */
bool AP_Radio_cc2500::handle_D16_packet(const uint8_t *packet)
{
    if (packet[0] != 0x1D) {
        return false;
    }
    if (packet[1] != bindTxId[0] ||
        packet[2] != bindTxId[1]) {
        Debug(3, "p1=%02x p2=%02x p6=%02x\n", packet[1], packet[2], packet[6]);
        // not for us
        return false;
    }
    if (packet[7] == 0x00 ||
        packet[7] == 0x20 ||
        packet[7] == 0x10 ||
        packet[7] == 0x12 ||
        packet[7] == 0x14 ||
        packet[7] == 0x16 ||
        packet[7] == 0x18 ||
        packet[7] == 0x1A ||
        packet[7] == 0x1C ||
        packet[7] == 0x1E) {
        // channel packet or range check packet
        parse_frSkyX(packet);

        packet3 = packet[3];

        uint8_t hop_chan = packet[4] & 0x3F;
        uint8_t skip = (packet[4]>>6) | (packet[5]<<2);
        if (channr != hop_chan) {
            Debug(2, "channr=%u hop_chan=%u\n", channr, hop_chan);
        }
        channr = hop_chan;
        if (chanskip != skip) {
            Debug(2, "chanskip=%u skip=%u\n", chanskip, skip);
        }
        chanskip = skip;
        return true;
    }
    return false;
}

/*
  handle a SRT packet
 */
bool AP_Radio_cc2500::handle_SRT_packet(const uint8_t *packet)
{
    const struct srt_packet *pkt = (const struct srt_packet *)packet;
    if (pkt->length != sizeof(struct srt_packet)-1 ||
        pkt->txid[0] != bindTxId[0] ||
        pkt->txid[1] != bindTxId[1]) {
        Debug(3, "len=%u p1=%02x p2=%02x\n", pkt->length, pkt->txid[0], pkt->txid[1]);
        // not for us
        return false;
    }
    if (pkt->version != 1) {
        // only support version 1 so far
        return false;
    }
    uint16_t chan_new[CC2500_MAX_PWM_CHANNELS];
    memcpy(chan_new, pwm_channels, sizeof(pwm_channels));

    chan_new[0] = pkt->chan1 + 1000 + ((pkt->chan_high&0xC0)<<2);
    chan_new[1] = pkt->chan2 + 1000 + ((pkt->chan_high&0x30)<<4);
    chan_new[2] = pkt->chan3 + 1000 + ((pkt->chan_high&0x0C)<<6);
    chan_new[3] = pkt->chan4 + 1000 + ((pkt->chan_high&0x03)<<8);
    // we map the buttons onto two PWM channels for ease of integration with ArduPilot
    chan_new[4] = 1000 + (pkt->buttons & 0x7) * 100;
    chan_new[5] = 1000 + (pkt->buttons >> 3) * 100;

    // cope with mode1/mode2
    map_stick_mode(chan_new);

    memcpy(pwm_channels, chan_new, sizeof(pwm_channels));

    uint8_t data = pkt->data;
    /*
      decode special data field
     */
    switch (pkt->pkt_type) {
    case PKTYPE_VOLTAGE:
        // voltage from TX is in 0.025 volt units. Convert to 0.01 volt units for easier display
        pwm_channels[6] = data * 4;
        break;
    case PKTYPE_YEAR:
        tx_date.firmware_year = data;
        break;
    case PKTYPE_MONTH:
        tx_date.firmware_month = data;
        break;
    case PKTYPE_DAY:
        tx_date.firmware_day = data;
        break;
    case PKTYPE_TELEM_RSSI:
        tx_rssi = data;
        break;
    case PKTYPE_TELEM_PPS:
        tx_pps = data;
        if (!have_tx_pps) {
            check_double_bind();
        }
        have_tx_pps = true;
        break;
    case PKTYPE_BL_VERSION:
        // unused so far for cc2500
        break;
    case PKTYPE_RXID1:
        if (data != t_status.rxid[0]) {
            Debug(4, "Double bind1 - disconnecting\n");
            start_recv_bind();
        }
        break;
    case PKTYPE_RXID2:
        if (data != t_status.rxid[1]) {
            Debug(4, "Double bind2 - disconnecting\n");
            start_recv_bind();
        }
        break;
    case PKTYPE_FW_ACK: {
        // got an fw upload ack
        Debug(4, "ack %u seq=%u acked=%u length=%u len=%u\n",
              data, fwupload.sequence, unsigned(fwupload.acked), unsigned(fwupload.length), fwupload.len);
        if (fwupload.sequence == data && sem.take_nonblocking()) {
            fwupload.sequence++;
            fwupload.acked += fwupload.len;
            if (fwupload.acked == fwupload.length) {
                // trigger send of DATA16 ack to client
                fwupload.need_ack = true;
            }
            sem.give();
        }
        break;
    }
    }

    if (chan_count < 7) {
        chan_count = 7;
    }

    if (pkt->channr != channr) {
        Debug(2, "channr=%u hop_chan=%u\n", channr, pkt->channr);
        channr = pkt->channr;
    }
    if (pkt->chanskip != chanskip) {
        Debug(2, "chanskip=%u skip=%u\n", chanskip, pkt->chanskip);
        chanskip = pkt->chanskip;
    }
    return true;
}

/*
  see if we have already assigned a channel
 */
bool AP_Radio_cc2500::have_channel(uint8_t channel, uint8_t count, uint8_t loop)
{
    uint8_t i;
    for (i=0; i<count; i++) {
        if (bindHopData[i] == channel) {
            return true;
        }
        if (loop < 5) {
            int separation = ((int)bindHopData[i]) - (int)channel;
            if (separation < 0) {
                separation = -separation;
            }
            if (separation < 4) {
                // try if possible to stay at least 4 channels from existing channels
                return true;
            }
        }
    }
    return false;
}

/*
  mapping from WiFi channel number minus 1 to cc2500 channel
  number. WiFi channels are separated by 5MHz starting at 2412 MHz,
  except for channel 14, which has a 12MHz separation. We represent
  channel 14 as 255 as we want to keep this table 8 bit.
 */
static const uint8_t wifi_chan_map[14] = {
    28, 44, 61, 78, 94, 111, 128, 144, 161, 178, 194, 211, 228, 255
};

/*
  create hopping table for SRT protocol
 */
void AP_Radio_cc2500::setup_hopping_table_SRT(void)
{
    uint8_t val;
    uint8_t channel = bindTxId[0] % 127;
    uint8_t channel_spacing = bindTxId[1] % 127;
    uint8_t i;
    uint8_t wifi_chan = t_status.wifi_chan;
    uint8_t cc_wifi_mid, cc_wifi_low, cc_wifi_high;
    const uint8_t wifi_separation = 65;

    if (wifi_chan == 0 || wifi_chan > 14) {
        wifi_chan = 9;
    }
    cc_wifi_mid = wifi_chan_map[wifi_chan-1];
    if (cc_wifi_mid < wifi_separation) {
        cc_wifi_low = 0;
    } else {
        cc_wifi_low = cc_wifi_mid - wifi_separation;
    }
    if (cc_wifi_mid > 225) {
        cc_wifi_high = 255;
    } else {
        cc_wifi_high = cc_wifi_mid + wifi_separation;
    }

    if (channel_spacing < 7) {
        channel_spacing += 7;
    }

    for (i=0; i<NUM_CHANNELS; i++) {
        // loop is to prevent any possibility of non-completion
        uint8_t loop = 0;
        do {
            channel = (channel+channel_spacing) % MAX_CHANNEL_NUMBER;

            if ((channel <= cc_wifi_low || channel >= cc_wifi_high) && !have_channel(channel, i, loop)) {
                // accept if not in wifi range and not already allocated
                break;
            }
        } while (loop++ < 100);
        val=channel;
        // channels to avoid from D16 code, not properly understood
        if ((val==0x00) || (val==0x5A) || (val==0xDC)) {
            val++;
        }
        bindHopData[i] = val;
    }

    if (get_protocol() != AP_Radio::PROTOCOL_CC2500_GFSK) {
        // additional loop to fix any close channels
        for (i=0; i<NUM_CHANNELS; i++) {
            // first loop only accepts channels that are outside wifi band
            if (have_channel(bindHopData[i], i, 0)) {
                uint8_t c;
                for (c = 0; c<MAX_CHANNEL_NUMBER; c++) {
                    if ((channel <= cc_wifi_low || channel >= cc_wifi_high) && !have_channel(c, i, 0)) {
                        bindHopData[i] = c;
                        break;
                    }
                }
            }
            // if that fails then accept channels within the wifi band
            if (have_channel(bindHopData[i], i, 0)) {
                uint8_t c;
                for (c = 0; c<MAX_CHANNEL_NUMBER; c++) {
                    if (!have_channel(c, i, 0)) {
                        bindHopData[i] = c;
                        break;
                    }
                }
            }
        }
    }

    for (i=0; i<NUM_CHANNELS; i++) {
        Debug(3, "%u ", bindHopData[i]);
    }
    Debug(3, "\n");
    last_wifi_channel = t_status.wifi_chan;
    Debug(2, "Setup hopping for 0x%x:0x%0x WiFi %u %u-%u spc:%u\n",
          bindTxId[0], bindTxId[1],
          wifi_chan, cc_wifi_low, cc_wifi_high, channel_spacing);
}


/*
  handle a autobind packet
 */
bool AP_Radio_cc2500::handle_autobind_packet(const uint8_t *packet, uint8_t lqi)
{
    if (get_factory_test() != 0) {
        // no autobind in factory test mode
        return false;
    }
    const struct autobind_packet_cc2500 *pkt = (const struct autobind_packet_cc2500 *)packet;
    if (stats.recv_packets != 0) {
        // don't process autobind packets once we're connected
        Debug(4,"autobind discard\n");
        return false;
    }
    if (pkt->length != sizeof(struct autobind_packet_cc2500)-1 ||
        pkt->magic1 != 0xC5 ||
        pkt->magic2 != 0xA2 ||
        pkt->txid[0] != uint8_t(~pkt->txid_inverse[0]) ||
        pkt->txid[1] != uint8_t(~pkt->txid_inverse[1])) {
        Debug(3, "AB l=%u el=%u m1=%02x m2=%02x %02x:%02x %02x:%02x %02x:%02x\n",
              pkt->length, sizeof(struct autobind_packet_cc2500)-1, pkt->magic1, pkt->magic2,
              pkt->txid[0], pkt->txid[1], uint8_t(~pkt->txid_inverse[0]), uint8_t(~pkt->txid_inverse[1]),
              pkt->crc[0], pkt->crc[1]);
        // not a valid autobind packet
        return false;
    }
    for (uint8_t i=0; i<sizeof(pkt->pad); i++) {
        if (pkt->pad[i] != i+1) {
            Debug(3, "AB pad[%u]=%u\n", i, pkt->pad[i]);
            return false;
        }
    }
    uint16_t lcrc = calc_crc(packet,sizeof(*pkt)-2);
    if ((lcrc>>8)!=pkt->crc[0] || (lcrc&0x00FF)!=pkt->crc[1]) {
        Debug(3, "AB bad CRC\n");
        return false;
    }

    uint8_t rssi_raw = packet[sizeof(struct autobind_packet_cc2500)];
    uint8_t rssi_dbm = map_RSSI_to_dBm(rssi_raw);

    if (lqi >= 50) {
        Debug(3,"autobind bad LQI %u\n", lqi);
        return false;
    }

    if (rssi_dbm < get_autobind_rssi()) {
        Debug(1,"autobind RSSI %u needs %u\n", (unsigned)rssi_dbm, (unsigned)get_autobind_rssi());
        return false;
    }
    Debug(1,"autobind RSSI %u above %u lqi=%u bofs=%d\n", (unsigned)rssi_dbm, (unsigned)get_autobind_rssi(), lqi, auto_bindOffset);

    bindOffset = auto_bindOffset;

    bindTxId[0] = pkt->txid[0];
    bindTxId[1] = pkt->txid[1];

    listLength = NUM_CHANNELS;
    t_status.wifi_chan = pkt->wifi_chan;

    setup_hopping_table_SRT();

    Debug(1,"Saved bind data\n");
    save_bind_info();

    return true;
}

/*
  map a raw RSSI value to a dBm value
 */
uint8_t AP_Radio_cc2500::map_RSSI_to_dBm(uint8_t rssi_raw)
{
    float rssi_dbm;
    if (rssi_raw >= 128) {
        rssi_dbm = ((((uint16_t)rssi_raw) * 18) >> 5) - 82;
    } else {
        rssi_dbm = ((((uint16_t)rssi_raw) * 18) >> 5) + 65;
    }
    return rssi_dbm;
}

// main IRQ handler
void AP_Radio_cc2500::irq_handler(void)
{
    uint8_t ccLen;
    bool matched = false;
    do {
        ccLen = cc2500.ReadReg(CC2500_3B_RXBYTES | CC2500_READ_BURST);
        hal.scheduler->delay_microseconds(20);
        uint8_t ccLen2 = cc2500.ReadReg(CC2500_3B_RXBYTES | CC2500_READ_BURST);
        matched = (ccLen == ccLen2);
    } while (!matched);

    if (ccLen & 0x80) {
        Debug(6,"Fifo overflow %02x\n", ccLen);
        // RX FIFO overflow
        cc2500.Strobe(CC2500_SFRX);
        cc2500.Strobe(CC2500_SRX);
        return;
    }

    uint8_t packet[ccLen];
    cc2500.ReadFifo(packet, ccLen);

    if (get_fcc_test() != 0) {
        // don't process interrupts in FCCTEST mode
        return;
    }

    if (ccLen != 32 &&
        ccLen != sizeof(srt_packet)+2 &&
        ccLen != sizeof(autobind_packet_cc2500)+2) {
        cc2500.Strobe(CC2500_SFRX);
        cc2500.Strobe(CC2500_SRX);
        Debug(4, "bad len %u SRT=%u AB=%u\n", ccLen,
              sizeof(srt_packet)+2,
              sizeof(autobind_packet_cc2500)+2);
        return;
    }

    if (get_debug_level() > 6) {
        Debug(6, "CC2500 IRQ state=%u\n", unsigned(protocolState));
        Debug(6,"len=%u\n", ccLen);
        for (uint8_t i=0; i<ccLen; i++) {
            Debug(6, "%02x:%02x ", i, packet[i]);
            if ((i+1) % 16 == 0) {
                Debug(6, "\n");
            }
        }
        if (ccLen % 16 != 0) {
            Debug(6, "\n");
        }
    }

    if (!check_crc(ccLen, packet)) {
        Debug(4, "bad CRC ccLen=%u\n", ccLen);
        return;
    }

    switch (protocolState) {
    case STATE_BIND_TUNING:
        tuneRx(ccLen, packet);
        break;

    case STATE_BIND_BINDING:
        if (getBindData(ccLen, packet)) {
            Debug(2,"Bind complete\n");
            protocolState = STATE_BIND_COMPLETE;
        }
        break;

    case STATE_BIND_COMPLETE:
        protocolState = STATE_STARTING;
        save_bind_info();
        Debug(3,"listLength=%u\n", listLength);
        Debug(3,"Saved bind info\n");
        break;

    case STATE_STARTING:
        listLength = NUM_CHANNELS;
        initialiseData(0);
        protocolState = STATE_SEARCH;
        chanskip = 1;
        nextChannel(1);
        break;

    case STATE_SEARCH:
        protocolState = STATE_DATA;
    // fallthrough

    case STATE_DATA: {
        bool ok = false;
        if (ccLen == 32) {
            ok = handle_D16_packet(packet);
        } else if (ccLen == sizeof(srt_packet)+2) {
            ok = handle_SRT_packet(packet);
            if (!ok) {
                uint8_t Lqi = packet[ccLen - 1] & 0x7F;
                ok = handle_autobind_packet(packet, Lqi);
            }
        }
        if (ok) {
            // get RSSI value from status byte
            uint8_t rssi_raw = packet[ccLen-2];
            float rssi_dbm = map_RSSI_to_dBm(rssi_raw);
            rssi_filtered = 0.95 * rssi_filtered + 0.05 * rssi_dbm;
            t_status.rssi = uint8_t(MAX(rssi_filtered, 1));

            if (stats.recv_packets == 0) {
                Debug(3,"cc2500: got 1st packet\n");
            }
            stats.recv_packets++;

            packet_timer = irq_time_us;
            chVTSet(&timeout_vt, chTimeMS2I(INTER_PACKET_INITIAL_MS), trigger_timeout_event, nullptr);

            cc2500.Strobe(CC2500_SIDLE);
            if (get_telem_enable()) {
                cc2500.SetPower(get_transmit_power());
                if (ccLen == 32 || get_protocol() == AP_Radio::PROTOCOL_D16) {
                    send_D16_telemetry();
                } else {
                    if (have_tx_pps) {
                        /* we don't start sending telemetry until we have the tx_pps rate. This allows us
                           to reliably detect double-bind, where one TX is bound to multiple RX
                        */
                        send_SRT_telemetry();
                    }
                }

                // now we sleep for enough time for the packet to be
                // transmitted. We can safely sleep here as we have a
                // dedicated thread for radio processing.
                cc2500.unlock_bus();
                hal.scheduler->delay_microseconds(PACKET_SENT_DELAY_US);
                cc2500.lock_bus();
            }

            nextChannel(chanskip);
        }
        break;
    }

    case STATE_FCCTEST:
        // nothing to do, all done in timeout code
        Debug(3,"IRQ in FCCTEST state\n");
        break;

    default:
        Debug(2,"state %u\n", (unsigned)protocolState);
        break;
    }
}

/*
  setup for the 6 possible FCC channel values (3 normal, 3 CW)
 */
void AP_Radio_cc2500::set_fcc_channel(void)
{
    uint8_t chan = MAX_CHANNEL_NUMBER/2;
    switch (get_fcc_test()) {
    case 1:
    case 4:
        chan = 0;
        break;
    case 2:
    case 5:
        chan = MAX_CHANNEL_NUMBER/2;
        break;
    case 3:
    case 6:
        chan = MAX_CHANNEL_NUMBER-1;
        break;
    }
    setChannel(chan);
}

// handle timeout IRQ
void AP_Radio_cc2500::irq_timeout(void)
{
    if (get_fcc_test() != 0 && protocolState != STATE_FCCTEST) {
        protocolState = STATE_FCCTEST;
        last_fcc_chan = 0;
        set_fcc_channel();
        send_SRT_telemetry();
    }

    switch (protocolState) {
    case STATE_BIND_TUNING: {
        if (bindOffset >= 126) {
            if (check_best_LQI()) {
                return;
            }
            bindOffset = -126;
        }
        uint32_t now = AP_HAL::millis();
        if (now - timeTunedMs > 20) {
            timeTunedMs = now;
            bindOffset += 5;
            Debug(6,"bindOffset=%d\n", int(bindOffset));
            cc2500.Strobe(CC2500_SIDLE);
            cc2500.WriteRegCheck(CC2500_0C_FSCTRL0, (uint8_t)bindOffset);
            cc2500.Strobe(CC2500_SFRX);
            cc2500.Strobe(CC2500_SRX);
        }
        break;
    }

    case STATE_DATA: {
        uint32_t now = AP_HAL::micros();

        if (now - packet_timer > SEARCH_START_PKTS*INTER_PACKET_MS*1000UL) {
            Debug(3,"searching %u\n", unsigned(now - packet_timer));
            cc2500.Strobe(CC2500_SIDLE);
            cc2500.Strobe(CC2500_SFRX);
            nextChannel(1);
            cc2500.Strobe(CC2500_SRX);
            timeouts++;
            protocolState = STATE_SEARCH;
            search_count = 0;
        } else {
            // to keep the timeouts a constant time behind the
            // expected time we need to set the timeout to the
            // inter-packet delay again now
            chVTSet(&timeout_vt, chTimeMS2I(INTER_PACKET_MS), trigger_timeout_event, nullptr);
            nextChannel(chanskip);
            lost++;
        }
        break;
    }

    case STATE_SEARCH: {
        uint32_t now = AP_HAL::millis();
        search_count++;
        if (stats.recv_packets == 0 &&
           H_RX},                                    // Set in Synth RX mode (again, really needed?)
    {CYRF_IO_CFG, CYRF_IRQ_POL},                                            // IRQ active high
};

const AP_Radio_cypress::config AP_Radio_cypress::cyrf_bind_config[] = {
    {CYRF_TX_CFG, CYRF_DATA_CODE_LENGTH | CYRF_DATA_MODE_SDR | CYRF_PA_4},   // Enable 64 chip codes, SDR mode and amplifier +4dBm
    {CYRF_FRAMING_CFG, CYRF_SOP_LEN | 0xE},                                  // Set SOP CODE to 64 chips and SOP Correlator Threshold to 0xE
    {CYRF_RX_OVERRIDE, CYRF_FRC_RXDR | CYRF_DIS_RXCRC},                      // Force receive data rate and disable receive CRC checker
    {CYRF_EOP_CTRL, 0x02},                                                   // Only enable EOP symbol count of 2
    {CYRF_TX_OVERRIDE, CYRF_DIS_TXCRC},                                      // Disable transmit CRC generate
};
const AP_Radio_cypress::config AP_Radio_cypress::cyrf_transfer_config[] = {
    {CYRF_TX_CFG, CYRF_DATA_CODE_LENGTH | CYRF_DATA_MODE_8DR | CYRF_PA_4},   // Enable 64 chip codes, 8DR mode and amplifier +4dBm
    {CYRF_FRAMING_CFG, CYRF_SOP_EN | CYRF_SOP_LEN | CYRF_LEN_EN | 0xE},      // Set SOP CODE enable, SOP CODE to 64 chips, Packet length enable, and SOP Correlator Threshold to 0xE
    {CYRF_TX_OVERRIDE, 0x00},                                                // Reset TX overrides
    {CYRF_RX_OVERRIDE, 0x00},                                                // Reset RX overrides
};

/*
  read radio status, handling the race condition between completion and error
 */
uint8_t AP_Radio_cypress::read_status_debounced(uint8_t adr)
{
    uint8_t ret;

    dev->set_chip_select(true);
    ret = read_register(adr);

    // If COMPLETE and ERROR bits mismatch, then re-read register
    if ((ret & (CYRF_RXC_IRQ | CYRF_RXE_IRQ)) != 0
        && (ret & (CYRF_RXC_IRQ | CYRF_RXE_IRQ)) != (CYRF_RXC_IRQ | CYRF_RXE_IRQ)) {
        uint8_t v2;
        dev->read(&v2, 1);
        ret |= v2;   // re-read and make bits sticky
    }
    dev->set_chip_select(false);
    return ret;
}

/*
  force the initial state of the radio
 */
void AP_Radio_cypress::force_initial_state(void)
{
    while (true) {
        write_register(CYRF_XACT_CFG, CYRF_FRC_END);
        uint32_t start_ms = AP_HAL::millis();
        do {
            if ((read_register(CYRF_XACT_CFG) & CYRF_FRC_END) == 0) {
                return;                     // FORCE_END done (osc running)
            }
        } while (AP_HAL::millis() - start_ms < 5);

        // FORCE_END failed to complete, implying going SLEEP to IDLE and
        // oscillator failed to start.  Recover by returning to SLEEP and
        //  trying to start oscillator again.
        write_register(CYRF_XACT_CFG, CYRF_MODE_SLEEP);
    }
}

/*
  set desired channel
 */
void AP_Radio_cypress::set_channel(uint8_t channel)
{
    if (dsm.forced_channel != -1) {
        channel = dsm.forced_channel;
    }
    write_register(CYRF_CHANNEL, channel);
}

void AP_Radio_cypress::radio_set_config(const struct config *conf, uint8_t size)
{
    // setup required radio config
    for (uint8_t i=0; i<size; i++) {
        write_register(conf[i].reg, conf[i].value);
    }
}

/*
  initialise the radio
 */
void AP_Radio_cypress::radio_init(void)
{
    Debug(1, "Cypress: radio_init starting\n");

    // wait for radio to settle
    uint16_t i;
    for (i=0; i<1000; i++) {
        uint8_t chan = read_register(CYRF_CHANNEL);
        if (chan == 1) {
            break;
        }
        write_register(CYRF_CHANNEL, 1);
        hal.scheduler->delay(10);
    }
    if (i == 1000) {
        Debug(1, "Cypress: radio_init failed\n");
        return;
    }

    // base config
    radio_set_config(cyrf_config, ARRAY_SIZE(cyrf_config));

    // start with receive config
    radio_set_config(cyrf_transfer_config, ARRAY_SIZE(cyrf_transfer_config));

    if (get_disable_crc()) {
        write_register(CYRF_RX_OVERRIDE, CYRF_DIS_RXCRC);
    }

    dsm_setup_transfer_dsmx();

    write_register(CYRF_XTAL_CTRL,0x80);  // XOUT=BitSerial
    force_initial_state();
    write_register(CYRF_PWR_CTRL,0x20);   // Disable PMU

    // start in RECV state
    state = STATE_RECV;

    Debug(1, "Cypress: radio_init done\n");

    start_receive();

    // setup handler for rising edge of IRQ pin
    hal.gpio->attach_interrupt(HAL_GPIO_RADIO_IRQ, trigger_irq_radio_event, AP_HAL::GPIO::INTERRUPT_RISING);
}

void AP_Radio_cypress::dump_registers(uint8_t n)
{
    for (uint8_t i=0; i<n; i++) {
        uint8_t v = read_register(i);
        printf("%02x:%02x ", i, v);
        if ((i+1) % 16 == 0) {
            printf("\n");
        }
    }
    if (n % 16 != 0) {
        printf("\n");
    }
}

/*
  read one register value
 */
uint8_t AP_Radio_cypress::read_register(uint8_t reg)
{
    uint8_t v = 0;
    (void)dev->read_registers(reg, &v, 1);
    return v;
}


/*
  write multiple bytes
 */
void AP_Radio_cypress::write_multiple(uint8_t reg, uint8_t n, const uint8_t *data)
{
    uint8_t pkt[n+1];
    pkt[0] = reg | FLAG_WRITE;
    memcpy(&pkt[1], data, n);
    dev->transfer(pkt, n+1, nullptr, 0);
}

/*
  write one register value
 */
void AP_Radio_cypress::write_register(uint8_t reg, uint8_t value)
{
    dev->write_register(reg | FLAG_WRITE, value);
}


/*
  support all 4 rc input modes by swapping channels.
 */
void AP_Radio_cypress::map_stick_mode(uint16_t *channels)
{
    switch (get_stick_mode()) {
    case 1: {
        // mode1
        uint16_t tmp = channels[1];
        channels[1] = 3000 - channels[2];
        channels[2] = 3000 - tmp;
        break;
    }

    case 3: {
        // mode3
        uint16_t tmp = channels[1];
        channels[1] = 3000 - channels[2];
        channels[2] = 3000 - tmp;
        tmp = channels[0];
        channels[0] = channels[3];
        channels[3] = tmp;
        break;
    }

    case 4: {
        // mode4
        uint16_t tmp = channels[0];
        channels[0] = channels[3];
        channels[3] = tmp;
        break;
    }

    case 2:
    default:
        // nothing to do, transmitter is natively mode2
        break;
    }
}

/*
  check if we are the 2nd RX bound to this TX
 */
void AP_Radio_cypress::check_double_bind(void)
{
    if (dsm.tx_pps <= dsm.telem_send_count ||
        get_autobind_time() == 0) {
        return;
    }
    // the TX has received more telemetry packets in the last second
    // than we have ever sent. There must be another RX sending
    // telemetry packets. We will reset our mfg_id and go back waiting
    // for a new bind packet, hopefully with the right TX
    Debug(1,"Double-bind detected\n");
    memset(dsm.mfg_id, 1, sizeof(dsm.mfg_id));
    dsm.last_recv_us = 0;
    dsm_setup_transfer_dsmx();
}

/*
  parse channels from a packet
 */
bool AP_Radio_cypress::parse_dsm_channels(const uint8_t *data)
{
    uint16_t num_values = 0;
    uint16_t pwm_channels[max_channels] {};

    // default value for channels above 4 is previous value
    memcpy(&pwm_channels[4], &dsm.pwm_channels[4], (max_channels-4)*sizeof(uint16_t));

    if (!dsm_decode(AP_HAL::micros64(),
                    data,
                    pwm_channels,
                    &num_values,
                    ARRAY_SIZE(pwm_channels))) {
        // invalid packet
        Debug(2, "DSM: bad decode\n");
        return false;
    }
    if (num_values < 5) {
        Debug(2, "DSM: num_values=%u\n", num_values);
        return false;
    }

    // cope with mode1/mode2
    map_stick_mode(pwm_channels);

    memcpy(dsm.pwm_channels, pwm_channels, num_values*sizeof(uint16_t));

    dsm.last_parse_us = AP_HAL::micros();

    // suppress channel 8 ack values
    dsm.num_channels = num_values==8?7:num_values;

    if (num_values == 8) {
        // decode telemetry ack value and version
        uint16_t d=0;
        if (is_DSM2()) {
            d = data[14] << 8 | data[15];
        } else {
            // see chan_order[] for DSMX
            d = data[10] << 8 | data[11];
        }
        // extra data is sent on channel 8, with 3 bit key and 8 bit data
        uint8_t chan = d>>11;
        uint8_t key = (d >> 8) & 0x7;
        uint8_t v = d & 0xFF;
        if (chan == 7 && key == 0) {
            // got an ack from key 0
            Debug(4, "ack %u seq=%u acked=%u length=%u len=%u\n",
                  v, fwupload.sequence, unsigned(fwupload.acked), unsigned(fwupload.length), fwupload.len);
            if (fwupload.sequence == v && sem.take_nonblocking()) {
                fwupload.sequence++;
                fwupload.acked += fwupload.len;
                if (fwupload.acked == fwupload.length) {
                    // trigger send of DATA16 ack to client
                    fwupload.need_ack = true;
                }
                sem.give();
            }
        }
        if (chan == 7) {
            // extract telemetry extra data
            switch (key) {
            case 1:
                dsm.tx_firmware_year = v;
                break;
            case 2:
                dsm.tx_firmware_month = v;
                break;
            case 3:
                dsm.tx_firmware_day = v;
                break;
            case 4:
                dsm.tx_rssi = v;
                break;
            case 5:
                dsm.tx_pps = v;
                dsm.have_tx_pps = true;
                check_double_bind();
                break;
            case 6:
                if (v != dsm.tx_bl_version) {
                    if (v == 2) {
                        // TX with new filter gets a default power of 6
                        set_tx_max_power_default(6);
                    }
                }
                dsm.tx_bl_version = v;
                break;
            }
        }
    }
    return true;
}

/*
  process an incoming bind packet
 */
void AP_Radio_cypress::process_bind(const uint8_t *pkt, uint8_t len)
{
    if (len != 16) {
        return;
    }
    bool ok = (len==16 && pkt[0] == pkt[4] && pkt[1] == pkt[5] && pkt[2] == pkt[6] && pkt[3] == pkt[7]);

    // Calculate the first sum
    uint16_t bind_sum = 384 - 0x10;
    for (uint8_t i = 0; i < 8; i++) {
        bind_sum += pkt[i];
    }

    // Check the first sum
    if (pkt[8] != bind_sum >> 8 || pkt[9] != (bind_sum & 0xFF)) {
        ok = false;
    }

    // Calculate second sum
    for (uint8_t i = 8; i < 14; i++) {
        bind_sum += pkt[i];
    }

    // Check the second sum
    if (pkt[14] != bind_sum >> 8 || pkt[15] != (bind_sum & 0xFF)) {
        ok = false;
    }

    if (state == STATE_AUTOBIND) {
        uint8_t rssi = read_register(CYRF_RSSI) & 0x1F;
        Debug(3,"bind RSSI %u\n", rssi);
        if (rssi < get_autobind_rssi()) {
            ok = false;
        }
    }

    if (ok) {
        uint8_t mfg_id[4] = {uint8_t(~pkt[0]), uint8_t(~pkt[1]), uint8_t(~pkt[2]), uint8_t(~pkt[3])};
        uint8_t num_chan = pkt[11];
        uint8_t protocol = pkt[12];
        (void)num_chan;
        // change to normal receive
        memcpy(dsm.mfg_id, mfg_id, 4);
        state = STATE_RECV;

        radio_set_config(cyrf_transfer_config, ARRAY_SIZE(cyrf_transfer_config));

        if (get_disable_crc()) {
            write_register(CYRF_RX_OVERRIDE, CYRF_DIS_RXCRC);
        }

        dsm.protocol = (enum dsm_protocol)protocol;
        dsm_setup_transfer_dsmx();

        Debug(1, "BIND OK: mfg_id={0x%02x, 0x%02x, 0x%02x, 0x%02x} N=%u P=0x%02x DSM2=%u\n",
              mfg_id[0], mfg_id[1], mfg_id[2], mfg_id[3],
              num_chan,
              protocol,
              is_DSM2());

        dsm.last_recv_us = AP_HAL::micros();

        if (is_DSM2()) {
            dsm2_start_sync();
        }

        dsm.need_bind_save = true;
    }
}

/*
  start DSM2 sync
 */
void AP_Radio_cypress::dsm2_start_sync(void)
{
    uint8_t factory_test = get_factory_test();
    if (factory_test != 0) {
        dsm.channels[0] = (factory_test*7) % DSM_MAX_CHANNEL;
        dsm.channels[1] = (dsm.channels[0] + 5) % DSM_MAX_CHANNEL;
        dsm.sync = DSM2_OK;
    } else {
        Debug(2, "DSM2 start sync\n");
        dsm.sync = DSM2_SYNC_A;
    }
}

/*
  setup a timeout in timeout_ms milliseconds
 */
void AP_Radio_cypress::setup_timeout(uint32_t timeout_ms)
{
    chVTSet(&timeout_vt, chTimeMS2I(timeout_ms), trigger_timeout_event, nullptr);
}

/*
  process an incoming packet
 */
void AP_Radio_cypress::process_packet(const uint8_t *pkt, uint8_t len)
{
    if (len == 16) {
        bool ok;
        const uint8_t *id = dsm.mfg_id;
        uint32_t now = AP_HAL::micros();

        if (is_DSM2()) {
            ok = (pkt[0] == ((~id[2])&0xFF) && pkt[1] == (~id[3]&0xFF));
        } else {
            ok = (pkt[0] == id[2] && pkt[1] == id[3]);
        }
        if (ok && is_DSM2() && dsm.sync < DSM2_OK) {
            if (dsm.sync == DSM2_SYNC_A) {
                dsm.channels[0] = dsm.current_rf_channel;
                dsm.sync = DSM2_SYNC_B;
                Debug(2, "DSM2 SYNCA chan=%u\n", dsm.channels[0]);
                dsm.last_recv_us = now;
            } else {
                if (dsm.current_rf_channel != dsm.channels[0]) {
                    dsm.channels[1] = dsm.current_rf_channel;
                    dsm.sync = DSM2_OK;
                    Debug(2, "DSM2 SYNCB chan=%u\n", dsm.channels[1]);
                    dsm.last_recv_us = now;
                }
            }
            return;
        }
        if (ok && (!is_DSM2() || dsm.sync >= DSM2_SYNC_B)) {
            ok = parse_dsm_channels(pkt);
        }
        if (ok) {
            uint32_t packet_dt_us = now - dsm.last_recv_us;

            dsm.last_recv_chan = dsm.current_channel;
            dsm.last_recv_us = now;
            if (dsm.crc_errors > 2) {
                dsm.crc_errors -= 2;
            }

            stats.recv_packets++;

            // sample the RSSI
            uint8_t rssi = read_register(CYRF_RSSI) & 0x1F;
            dsm.rssi = 0.95 * dsm.rssi + 0.05 * rssi;

            if (packet_dt_us < 5000) {
                dsm.pkt_time1 = packet_dt_us;
            } else if (packet_dt_us < 8000) {
                dsm.pkt_time2 = packet_dt_us;
            }

            if (get_telem_enable()) {
                if (packet_dt_us < 5000 &&
                    (get_autobind_time() == 0 || dsm.have_tx_pps)) {
                    /*
                      we have just received two packets rapidly, which
                      means we have about 7ms before the next
                      one. That gives time for a telemetry packet. We
                      send it 1ms after we receive the incoming packet

                      If auto-bind is enabled we don't send telemetry
                      till we've received a tx_pps value from the
                      TX. This allows us to detect double binding (two
                      RX bound to the same TX)
                    */
                    state = STATE_SEND_TELEM;
                    setup_timeout(1);
                }
            }
        } else {
            stats.bad_packets++;
        }
    } else {
        stats.bad_packets++;
    }
}


/*
  start packet receive
 */
void AP_Radio_cypress::start_receive(void)
{
    dsm_choose_channel();

    write_register(CYRF_RX_IRQ_STATUS, CYRF_RXOW_IRQ);
    write_register(CYRF_RX_CTRL, CYRF_RX_GO | CYRF_RXC_IRQEN | CYRF_RXE_IRQEN);

    dsm.receive_start_us = AP_HAL::micros();
    if (state == STATE_AUTOBIND) {
        dsm.receive_timeout_msec = 90;
    } else if (state == STATE_BIND) {
        dsm.receive_timeout_msec = 15;
    } else {
        dsm.receive_timeout_msec = 12;
    }
    setup_timeout(dsm.receive_timeout_msec);
}

/*
  handle a receive IRQ
 */
void AP_Radio_cypress::irq_handler_recv(uint8_t rx_status)
{
    if ((rx_status & (CYRF_RXC_IRQ | CYRF_RXE_IRQ)) == 0) {
        // nothing interesting yet
        return;
    }

    uint8_t pkt[16];
    uint8_t rlen = read_register(CYRF_RX_COUNT);
    if (rlen > 16) {
        rlen = 16;
    }
    if (rlen > 0) {
        dev->read_registers(CYRF_RX_BUFFER, pkt, rlen);
    }

    if (rx_status & CYRF_RXE_IRQ) {
        uint8_t reason = read_register(CYRF_RX_STATUS);
        if (reason & CYRF_BAD_CRC) {
            dsm.crc_errors++;
            if (dsm.crc_errors > 20) {
                Debug(2, "Flip CRC\n");
                // flip crc seed, this allows us to resync with transmitter
                dsm.crc_seed = ~dsm.crc_seed;
                dsm.crc_errors = 0;
            }
        }
        write_register(CYRF_XACT_CFG, CYRF_MODE_SYNTH_RX | CYRF_FRC_END);
        write_register(CYRF_RX_ABORT, 0);
        stats.recv_errors++;
    } else if (rx_status & CYRF_RXC_IRQ) {
        if (state == STATE_RECV) {
            process_packet(pkt, rlen);
        } else {
            process_bind(pkt, rlen);
        }
    }

    if (state == STATE_AUTOBIND) {
        state = STATE_RECV;
    }

    if (state != STATE_SEND_TELEM) {
        start_receive();
    }
}


/*
  handle a send IRQ
 */
void AP_Radio_cypress::irq_handler_send(uint8_t tx_status)
{
    if ((tx_status & (CYRF_TXC_IRQ | CYRF_TXE_IRQ)) == 0) {
        // nothing interesting yet
        return;
    }
    state = STATE_RECV;
    start_receive();
}


/*
  IRQ handler
 */
void AP_Radio_cypress::irq_handler(void)
{
    //hal.console->printf("IRQ\n");
    if (!dev->get_semaphore()->take_nonblocking()) {
        // we have to wait for timeout instead
        return;
    }
    // always read both rx and tx status. This ensure IRQ is cleared
    uint8_t rx_status = read_status_debounced(CYRF_RX_IRQ_STATUS);
    uint8_t tx_status = read_status_debounced(CYRF_TX_IRQ_STATUS);

    switch (state) {
    case STATE_AUTOBIND:
    // fallthrough
    case STATE_RECV:
    case STATE_BIND:
        irq_handler_recv(rx_status);
        break;

    case STATE_SEND_TELEM:
    case STATE_SEND_TELEM_WAIT:
        irq_handler_send(tx_status);
        break;

    case STATE_SEND_FCC:
        // stop transmit oscillator
        write_register(CYRF_RX_IRQ_STATUS, CYRF_RXOW_IRQ);
        write_register(CYRF_RX_CTRL, CYRF_RX_GO | CYRF_RXC_IRQEN | CYRF_RXE_IRQEN);
        break;

    default:
        break;
    }
    dev->get_semaphore()->give();
}

/*
  called on radio timeout
 */
void AP_Radio_cypress::irq_timeout(void)
{
    stats.timeouts++;
    if (!dev->get_semaphore()->take_nonblocking()) {
        // schedule a new timeout
        setup_timeout(dsm.receive_timeout_msec);
        return;
    }

    if (get_fcc_test() != 0 && state != STATE_SEND_FCC) {
        Debug(3,"Starting FCC test\n");
        state = STATE_SEND_FCC;
    } else if (get_fcc_test() == 0 && state == STATE_SEND_FCC) {
        Debug(3,"Ending FCC test\n");
        state = STATE_RECV;
    }

    switch (state) {
    case STATE_SEND_TELEM:
        send_telem_packet();
        break;
    case STATE_SEND_FCC:
        send_FCC_test_packet();
        break;
    case STATE_AUTOBIND:
    case STATE_SEND_TELEM_WAIT:
        state = STATE_RECV;
    // fall through
    default:
        write_register(CYRF_XACT_CFG, CYRF_MODE_SYNTH_RX | CYRF_FRC_END);
        write_register(CYRF_RX_ABORT, 0);
        start_receive();
        break;
    }

    dev->get_semaphore()->give();
}


/*
  called on HRT timeout
 */
void AP_Radio_cypress::irq_handler_thd(void *arg)
{
    _irq_handler_ctx = chThdGetSelfX();
    (void)arg;
    while (true) {
        eventmask_t evt = chEvtWaitAny(ALL_EVENTS);
        if (evt & EVT_IRQ) {
            radio_singleton->irq_handler();
        }
        if (evt & EVT_TIMEOUT) {
            radio_singleton->irq_timeout();
        }
    }
}

void AP_Radio_cypress::trigger_timeout_event(virtual_timer_t* vt, void *arg)
{
    (void)arg;
    //we are called from ISR context
    chSysLockFromISR();
    if (_irq_handler_ctx) {
        chEvtSignalI(_irq_handler_ctx, EVT_TIMEOUT);
    }
    chSysUnlockFromISR();
}

void AP_Radio_cypress::trigger_irq_radio_event()
{
    //we are called from ISR context
    chSysLockFromISR();
    if (_irq_handler_ctx) {
        chEvtSignalI(_irq_handler_ctx, EVT_IRQ);
    }
    chSysUnlockFromISR();
}

/*
 Set the current DSM channel with SOP, CRC and data code
 */
void AP_Radio_cypress::dsm_set_channel(uint8_t channel, bool is_dsm2, uint8_t sop_col, uint8_t data_col, uint16_t crc_seed)
{
    //printf("dsm_set_channel: %u\n", channel);

    uint8_t pn_row;
    pn_row = is_dsm2? channel % 5 : (channel-2) % 5;

    // set CRC seed
    write_register(CYRF_CRC_SEED_LSB, crc_seed & 0xff);
    write_register(CYRF_CRC_SEED_MSB, crc_seed >> 8);

    // set start of packet code
    if (memcmp(dsm.last_sop_code, pn_codes[pn_row][sop_col], 8) != 0) {
        write_multiple(CYRF_SOP_CODE, 8, pn_codes[pn_row][sop_col]);
        memcpy(dsm.last_sop_code, pn_codes[pn_row][sop_col], 8);
    }

    // set data code
    if (memcmp(dsm.last_data_code, pn_codes[pn_row][data_col], 16) != 0) {
        write_multiple(CYRF_DATA_CODE, 16, pn_codes[pn_row][data_col]);
        memcpy(dsm.last_data_code, pn_codes[pn_row][data_col], 16);
    }

    if (get_disable_crc() != dsm.last_discrc) {
        dsm.last_discrc = get_disable_crc();
        Debug(3,"Cypress: DISCRC=%u\n", dsm.last_discrc);
        write_register(CYRF_RX_OVERRIDE, dsm.last_discrc?CYRF_DIS_RXCRC:0);
    }

    if (get_transmit_power() != dsm.last_transmit_power+1) {
        dsm.last_transmit_power = get_transmit_power()-1;
        Debug(3,"Cypress: TXPOWER=%u\n", dsm.last_transmit_power);
        write_register(CYRF_TX_CFG, CYRF_DATA_CODE_LENGTH | CYRF_DATA_MODE_8DR | dsm.last_transmit_power);
    }

    // Change channel
    set_channel(channel);
}

/*
  Generate the DSMX channels from the manufacturer ID
 */
void AP_Radio_cypress::dsm_generate_channels_dsmx(uint8_t mfg_id[4], uint8_t channels[23])
{
    // Calculate the DSMX channels
    int idx = 0;
    uint32_t id = ~((mfg_id[0] << 24) | (mfg_id[1] << 16) |
                    (mfg_id[2] << 8) | (mfg_id[3] << 0));
    uint32_t id_tmp = id;

    // While not all channels are set
    while (idx < 23) {
        int i;
        int count_3_27 = 0, count_28_51 = 0, count_52_76 = 0;

        id_tmp = id_tmp * 0x0019660D + 0x3C6EF35F; // Randomization
        uint8_t next_ch = ((id_tmp >> 8) % 0x49) + 3;       // Use least-significant byte and must be larger than 3
        if (((next_ch ^ id) & 0x01 ) == 0) {
            continue;
        }

        // Go trough all already set channels
        for (i = 0; i < idx; i++) {
            // Channel is already used
            if (channels[i] == next_ch) {
                break;
            }

            // Count the channel groups
            if (channels[i] <= 27) {
                count_3_27++;
            } else if (channels[i] <= 51) {
                count_28_51++;
            } else {
                count_52_76++;
            }
        }

        // When channel is already used continue
        if (i != idx) {
            continue;
        }

        // Set the channel when channel groups aren't full
        if ((next_ch < 28 && count_3_27 < 8)                        // Channels 3-27: max 8
            || (next_ch >= 28 && next_ch < 52 && count_28_51 < 7)    // Channels 28-52: max 7
            || (next_ch >= 52 && count_52_76 < 8)) {                // Channels 52-76: max 8
            channels[idx++] = next_ch;
        }
    }

    Debug(2, "Generated DSMX channels\n");
}

/*
  setup for DSMX transfers
 */
void AP_Radio_cypress::dsm_setup_transfer_dsmx(void)
{
    dsm.current_channel = 0;

    dsm.crc_seed = ~((dsm.mfg_id[0] << 8) + dsm.mfg_id[1]);
    dsm.sop_col = (dsm.mfg_id[0] + dsm.mfg_id[1] + dsm.mfg_id[2] + 2) & 0x07;
    dsm.data_col = 7 - dsm.sop_col;

    dsm_generate_channels_dsmx(dsm.mfg_id, dsm.channels);
}

/*
  choose channel to receive on
 */
void AP_Radio_cypress::dsm_choose_channel(void)
{
    uint32_t now = AP_HAL::micros();
    uint32_t dt = now - dsm.last_recv_us;
    const uint32_t cycle_time = dsm.pkt_time1 + dsm.pkt_time2;
    uint8_t next_channel;


    if (state == STATE_BIND) {
        if (now - dsm.last_chan_change_us > 15000) {
            // always use odd channel numbers for bind
            dsm.current_rf_channel |= 1;
            dsm.current_rf_channel = (dsm.current_rf_channel+2) % DSM_MAX_CHANNEL;
            dsm.last_chan_change_us = now;
        }
        set_channel(dsm.current_rf_channel);
        return;
    }

    if (get_autobind_time() != 0 &&
        dsm.last_recv_us == 0 &&
        now - dsm.last_autobind_send > 300*1000UL &&
        now > get_autobind_time() * 1000*1000UL &&
        get_factory_test() == 0 &&
        state == STATE_RECV) {
        // try to receive an auto-bind packet
        dsm_set_channel(AUTOBIND_CHANNEL, true, 0, 0, 0);

        state = STATE_AUTOBIND;

        Debug(3,"recv autobind %u\n", unsigned(now - dsm.last_autobind_send));
        dsm.last_autobind_send = now;
        return;
    }

    if (is_DSM2() && dsm.sync == DSM2_SYNC_A) {
        if (now - dsm.last_chan_change_us > 15000) {
            // only even channels for DSM2 scan
            dsm.current_rf_channel &= ~1;
            dsm.current_rf_channel = (dsm.current_rf_channel+2) % DSM_MAX_CHANNEL;
            dsm.last_chan_change_us = now;
        }
        //hal.console->printf("%u chan=%u\n", AP_HAL::micros(), dsm.current_rf_channel);
        dsm_set_channel(dsm.current_rf_channel, is_DSM2(),
                        dsm.sop_col, dsm.data_col,
                        dsm.sync==DSM2_SYNC_B?~dsm.crc_seed:dsm.crc_seed);
        return;
    }

    if (dt < 1000) {
        // normal channel advance
        next_channel = dsm.last_recv_chan + 1;
    } else if (dt > 20*cycle_time) {
        // change channel slowly
        next_channel = dsm.last_recv_chan + (dt / (cycle_time*2));
    } else {
        // predict next channel
        next_channel = dsm.last_recv_chan + 1;
        next_channel += (dt / cycle_time) * 2;
        if (dt % cycle_time > (unsigned)(dsm.pkt_time1 + 1000U)) {
            next_channel++;
        }
    }

    uint8_t chan_count = is_DSM2()?2:23;
    dsm.current_channel = next_channel;
    if (dsm.current_channel >= chan_count) {
        dsm.current_channel %= chan_count;
        if (!is_DSM2()) {
            dsm.crc_seed = ~dsm.crc_seed;
        }
    }

    if (is_DSM2() && dsm.sync == DSM2_SYNC_B && dsm.current_channel == 1) {
        // scan to next channelb
        do {
            dsm.channels[1] &= ~1;
            dsm.channels[1] = (dsm.channels[1]+2) % DSM_MAX_CHANNEL;
        } while (dsm.channels[1] == dsm.channels[0]);
    }

    dsm.current_rf_channel = dsm.channels[dsm.current_channel];

    uint16_t seed = dsm.crc_seed;
    if (dsm.current_channel & 1) {
        seed = ~seed;
    }

    if (is_DSM2()) {
        if (now - dsm.last_recv_us > 5000000) {
            dsm2_start_sync();
        }
    }

    dsm_set_channel(dsm.current_rf_channel, is_DSM2(),
                    dsm.sop_col, dsm.data_col, seed);
}

/*
  setup radio for bind
 */
void AP_Radio_cypress::start_recv_bind(void)
{
    dev->get_semaphore()->take_blocking();

    Debug(1, "Cypress: start_recv_bind\n");

    write_register(CYRF_XACT_CFG, CYRF_MODE_SYNTH_RX | CYRF_FRC_END);
    write_register(CYRF_RX_ABORT, 0);

    state = STATE_BIND;

    radio_set_config(cyrf_bind_config, ARRAY_SIZE(cyrf_bind_config));

    write_register(CYRF_CRC_SEED_LSB, 0);
    write_register(CYRF_CRC_SEED_MSB, 0);

    write_multiple(CYRF_SOP_CODE, 8, pn_codes[0][0]);

    uint8_t data_code[16];
    memcpy(data_code, pn_codes[0][8], 8);
    memcpy(&data_code[8], pn_bind, 8);
    write_multiple(CYRF_DATA_CODE, 16, data_code);

    dsm.current_rf_channel = 1;

    start_receive();

    dev->get_semaphore()->give();
}

/*
  save bind info
 */
void AP_Radio_cypress::save_bind_info(void)
{
    // access to storage for bind information
    StorageAccess bind_storage(StorageManager::StorageBindInfo);
    struct bind_info info;

    info.magic = bind_magic;
    memcpy(info.mfg_id, dsm.mfg_id, sizeof(info.mfg_id));
    info.protocol = dsm.protocol;

    if (bind_storage.write_block(0, &info, sizeof(info))) {
        dsm.need_bind_save = false;
    }
}

/*
  load bind info
 */
void AP_Radio_cypress::load_bind_info(void)
{
    // access to storage for bind information
    StorageAccess bind_storage(StorageManager::StorageBindInfo);
    struct bind_info info;

    uint8_t factory_test = get_factory_test();

    if (factory_test != 0) {
        Debug(1, "In factory test %u\n", factory_test);
        memset(dsm.mfg_id, 0, sizeof(dsm.mfg_id));
        dsm.mfg_id[0] = factory_test;
        dsm.protocol = DSM_DSM2_2;
        dsm2_start_sync();
    } else if (bind_storage.read_block(&info, 0, sizeof(info)) && info.magic == bind_magic) {
        Debug(1, "Loaded mfg_id %02x:%02x:%02x:%02x\n",
              info.mfg_id[0], info.mfg_id[1], info.mfg_id[2], info.mfg_id[3]);
        memcpy(dsm.mfg_id, info.mfg_id, sizeof(info.mfg_id));
        dsm.protocol = info.protocol;
    }
}

bool AP_Radio_cypress::is_DSM2(void)
{
    if (get_protocol() != AP_Radio::PROTOCOL_AUTO) {
        return get_protocol() == AP_Radio::PROTOCOL_DSM2;
    }
    return dsm.protocol == DSM_DSM2_1 || dsm.protocol == DSM_DSM2_2;
}

/*
  transmit a 16 byte packet
  this is a blind send, not waiting for ack or completion
*/
void AP_Radio_cypress::transmit16(const uint8_t data[16])
{
    write_register(CYRF_TX_LENGTH, 16);
    write_register(CYRF_TX_CTRL, CYRF_TX_CLR);

    write_multiple(CYRF_TX_BUFFER, 16, data);
    write_register(CYRF_TX_CTRL, CYRF_TX_GO | CYRF_TXC_IRQEN);
    dsm.send_count++;
}


/*
  send a telemetry structure packet
 */
void AP_Radio_cypress::send_telem_packet(void)
{
    struct telem_packet_cypress pkt;

    t_status.flags = 0;
    t_status.flags |= AP_Notify::flags.gps_status >= 3?TELEM_FLAG_GPS_OK:0;
    t_status.flags |= AP_Notify::flags.pre_arm_check?TELEM_FLAG_ARM_OK:0;
    t_status.flags |= AP_Notify::flags.failsafe_battery?0:TELEM_FLAG_BATT_OK;
    t_status.flags |= hal.util->get_soft_armed()?TELEM_FLAG_ARMED:0;
    t_status.flags |= AP_Notify::flags.have_pos_abs?TELEM_FLAG_POS_OK:0;
    t_status.flags |= AP_Notify::flags.video_recording?TELEM_FLAG_VIDEO:0;
    t_status.flight_mode = AP_Notify::flags.flight_mode;
    t_status.tx_max = get_tx_max_power();
    t_status.note_adjust = get_tx_buzzer_adjust();

    // send fw update packet for 7/8 of packets if any data pending
    if (fwupload.length != 0 &&
        fwupload.length > fwupload.acked &&
        ((fwupload.counter++ & 0x07) != 0) &&
        sem.take_nonblocking()) {
        pkt.type = fwupload.fw_type;
        pkt.payload.fw.seq = fwupload.sequence;
        uint32_t len = fwupload.length>fwupload.acked?fwupload.length - fwupload.acked:0;
        pkt.payload.fw.len = len<=8?len:8;
        pkt.payload.fw.offset = fwupload.offset+fwupload.acked;
        memcpy(&pkt.payload.fw.data[0], &fwupload.pending_data[fwupload.acked], pkt.payload.fw.len);
        fwupload.len = pkt.payload.fw.len;
        Debug(4, "sent fw seq=%u offset=%u len=%u type=%u\n",
              pkt.payload.fw.seq,
              pkt.payload.fw.offset,
              pkt.payload.fw.len,
              pkt.type);
        sem.give();
        pkt.crc = crc_crc8((const uint8_t *)&pkt.type, 15);
    } else {
        pkt.type = TELEM_STATUS;
        pkt.payload.status = t_status;
        pkt.crc = crc_crc8((const uint8_t *)&pkt.type, 15);
        dsm.telem_send_count++;
    }

    write_register(CYRF_XACT_CFG, CYRF_MODE_SYNTH_TX | CYRF_FRC_END);
    write_register(CYRF_RX_ABORT, 0);
    transmit16((uint8_t*)&pkt);

    state = STATE_SEND_TELEM_WAIT;
    setup_timeout(2);
}

/*
  send a FCC test packet
 */
void AP_Radio_cypress::send_FCC_test_packet(void)
{
    uint8_t pkt[16] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 };

    state = STATE_SEND_FCC;

    uint8_t channel=0;

    switch (get_fcc_test()) {
    case 0:
        // switch back to normal operation
        dsm.forced_channel = -1;
        send_telem_packet();
        return;
    case 1:
    case 4:
        channel = DSM_SCAN_MIN_CH;
        break;
    case 2:
    case 5:
        channel = DSM_SCAN_MID_CH;
        break;
    case 3:
    case 6:
    default:
        channel = DSM_SCAN_MAX_CH;
        break;
    }

    Debug(5,"FCC send %u\n", channel);

    if (channel != dsm.forced_channel) {
        Debug(1,"FCC channel %u\n", channel);
        dsm.forced_channel = channel;

        radio_set_config(cyrf_config, ARRAY_SIZE(cyrf_config));
        radio_set_config(cyrf_transfer_config, ARRAY_SIZE(cyrf_transfer_config));

        set_channel(channel);
    }

#if FCC_SUPPORT_CW_MODE
    if (get_fcc_test() > 3) {
        // continuous preamble transmit is closest approximation to CW
        // that is possible with this chip
        write_register(CYRF_PREAMBLE,0x01);
        write_register(CYRF_PREAMBLE,0x00);
        write_register(CYRF_PREAMBLE,0x00);

        write_register(CYRF_TX_OVERRIDE, CYRF_FRC_PRE);
        write_register(CYRF_TX_CTRL, CYRF_TX_GO);

        setup_timeout(500);
    } else {
        write_register(CYRF_XACT_CFG, CYRF_MODE_SYNTH_TX | CYRF_FRC_END);
        write_register(CYRF_RX_ABORT, 0);
        transmit16(pkt);
        setup_timeout(10);
    }
#else
    write_register(CYRF_XACT_CFG, CYRF_MODE_SYNTH_TX | CYRF_FRC_END);
    write_register(CYRF_RX_ABORT, 0);
    transmit16(pkt);
    setup_timeout(10);
#endif
}

// handle a data96 mavlink packet for fw upload
void AP_Radio_cypress::handle_data_packet(mavlink_channel_t chan, const mavlink_data96_t &m)
{
    uint32_t ofs=0;
    memcpy(&ofs, &m.data[0], 4);
    Debug(4, "got data96 of len %u from chan %u at offset %u\n", m.len, chan, unsigned(ofs));
    if (sem.take_nonblocking()) {
        fwupload.chan = chan;
        fwupload.need_ack = false;
        fwupload.offset = ofs;
        fwupload.length = MIN(m.len-4, 92);
        fwupload.acked = 0;
        fwupload.sequence++;
        if (m.type == 43) {
            // sending a tune to play - for development testing
            fwupload.fw_type = TELEM_PLAY;
            fwupload.length = MIN(m.len, 90);
            fwupload.offset = 0;
            memcpy(&fwupload.pending_data[0], &m.data[0], fwupload.length);
        } else {
            // sending a chunk of firmware OTA upload
            fwupload.fw_type = TELEM_FW;
            memcpy(&fwupload.pending_data[0], &m.data[4], fwupload.length);
        }
        sem.give();
    }
}

#endif  // AP_RADIO_CYRF6936_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       /*
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
#pragma once

#include "AP_Radio_config.h"

#if AP_RADIO_CYRF6936_ENABLED

/*
  AP_Radio implementation for Cypress 2.4GHz radio.

  With thanks to the SuperBitRF project
  See http://wiki.paparazziuav.org/wiki/SuperbitRF

  This implementation uses the DSMX protocol on a CYRF6936
 */

#include "AP_Radio_backend.h"
#include "hal.h"
#include "telem_structure.h"

class AP_Radio_cypress : public AP_Radio_backend
{
public:
    AP_Radio_cypress(AP_Radio &radio);

    // init - initialise radio
    bool init(void) override;

    // rest radio
    bool reset(void) override;

    // send a packet
    bool send(const uint8_t *pkt, uint16_t len) override;

    // start bind process as a receiver
    void start_recv_bind(void) override;

    // return time in microseconds of last received R/C packet
    uint32_t last_recv_us(void) override;

    // return number of input channels
    uint8_t num_channels(void) override;

    // return current PWM of a channel
    uint16_t read(uint8_t chan) override;

    // handle a data96 mavlink packet for fw upload
    void handle_data_packet(mavlink_channel_t chan, const mavlink_data96_t &m) override;

    // update status
    void update(void) override;

    // get TX fw version
    uint32_t get_tx_version(void) override
    {
        // pack date into 16 bits for vendor_id in AUTOPILOT_VERSION
        return (uint16_t(dsm.tx_firmware_year)<<12) + (uint16_t(dsm.tx_firmware_month)<<8) + dsm.tx_firmware_day;
    }

    // get radio statistics structure
    const AP_Radio::stats &get_stats(void) override;

    // set the 2.4GHz wifi channel used by companion computer, so it can be avoided
    void set_wifi_channel(uint8_t channel) override
    {
        t_status.wifi_chan = channel;
    }

private:
    AP_HAL::OwnPtr<AP_HAL::SPIDevice> dev;
    static AP_Radio_cypress *radio_singleton;

    void radio_init(void);

    void dump_registers(uint8_t n);

    void force_initial_state(void);
    void set_channel(uint8_t channel);
    uint8_t read_status_debounced(uint8_t adr);

    uint8_t read_register(uint8_t reg);
    void write_register(uint8_t reg, uint8_t value);
    void write_multiple(uint8_t reg, uint8_t n, const uint8_t *data);

    enum {
        STATE_RECV,
        STATE_BIND,
        STATE_AUTOBIND,
        STATE_SEND_TELEM,
        STATE_SEND_TELEM_WAIT,
        STATE_SEND_FCC
    } state;

    struct config {
        uint8_t reg;
        uint8_t value;
    };
    static const uint8_t pn_codes[5][9][8];
    static const uint8_t pn_bind[];
    static const config cyrf_config[];
    static const config cyrf_bind_config[];
    static const config cyrf_transfer_config[];

    virtual_timer_t timeout_vt;
    static thread_t *_irq_handler_ctx;
    void radio_set_config(const struct config *config, uint8_t size);

    void start_receive(void);

    // main IRQ handler
    void irq_handler(void);

    // IRQ handler for packet receive
    void irq_handler_recv(uint8_t rx_status);

    // handle timeout IRQ
    void irq_timeout(void);

    // trampoline functions to take us from static IRQ function to class functions

    static void irq_handler_thd(void* arg);
    static void trigger_irq_radio_event(void);
    static void trigger_timeout_event(virtual_timer_t* vt, void *arg);

    static const uint8_t max_channels = 16;

    uint32_t last_debug_print_ms;

    void print_debug_info(void);

    AP_Radio::stats stats;
    AP_Radio::stats last_stats;

    enum dsm_protocol {
        DSM_NONE   = 0,      // not bound yet
        DSM_DSM2_1 = 0x01,   // The original DSM2 protocol with 1 packet of data
        DSM_DSM2_2 = 0x02,   // The original DSM2 protocol with 2 packets of data
        DSM_DSMX_1 = 0xA2,   // The original DSMX protocol with 1 packet of data
        DSM_DSMX_2 = 0xB2,   // The original DSMX protocol with 2 packets of data
    };

    enum dsm2_sync {
        DSM2_SYNC_A,
        DSM2_SYNC_B,
        DSM2_OK
    };

    // semaphore between ISR and main thread
    HAL_Semaphore sem;

    // dsm config data and status
    struct {
        uint8_t channels[23];
        enum dsm_protocol protocol;
        uint8_t mfg_id[4];
        uint8_t current_channel;
        uint8_t current_rf_channel;
        uint16_t crc_seed;
        uint8_t sop_col;
        uint8_t data_col;
        uint8_t last_sop_code[8];
        uint8_t last_data_code[16];

        uint32_t receive_start_us;
        uint32_t receive_timeout_msec;

        uint32_t last_recv_us;
        uint32_t last_parse_us;
        uint32_t last_recv_chan;
        uint32_t last_chan_change_us;
        uint16_t num_channels;
        uint16_t pwm_channels[max_channels];
        bool need_bind_save;
        enum dsm2_sync sync;
        uint32_t crc_errors;
        float rssi;
        bool last_discrc;
        uint8_t last_transmit_power;
        uint32_t send_irq_count;
        uint32_t send_count;
        uint16_t pkt_time1 = 3000;
        uint16_t pkt_time2 = 7000;
        uint8_t tx_firmware_year;
        uint8_t tx_firmware_month;
        uint8_t tx_firmware_day;
        int8_t forced_channel = -1;
        uint8_t tx_rssi;
        uint8_t tx_pps;
        uint32_t last_autobind_send;
        bool have_tx_pps;
        uint32_t telem_send_count;
        uint8_t tx_bl_version;
    } dsm;

    struct {
        mavlink_channel_t chan;
        bool need_ack;
        uint8_t counter;
        uint8_t sequence;
        uint32_t offset;
        uint32_t length;
        uint32_t acked;
        uint8_t len;
        enum telem_type fw_type;
        uint8_t pending_data[92];
    } fwupload;

    // bind structure saved to storage
    static const uint16_t bind_magic = 0x43F6;
    struct PACKED bind_info {
        uint16_t magic;
        uint8_t  mfg_id[4];
        enum dsm_protocol protocol;
    };

    struct telem_status t_status;

    // DSM specific functions
    void dsm_set_channel(uint8_t channel, bool is_dsm2, uint8_t sop_col, uint8_t data_col, uint16_t crc_seed);

    // generate DSMX channels
    void dsm_generate_channels_dsmx(uint8_t mfg_id[4], uint8_t channels[23]);

    // setup for DSMX transfers
    void dsm_setup_transfer_dsmx(void);

    // choose channel to receive on
    void dsm_choose_channel(void);

    // map for mode1/mode2
    void map_stick_mode(uint16_t *channels);

    // parse DSM channels from a packet
    bool parse_dsm_channels(const uint8_t *data);

    // process an incoming packet
    void process_packet(const uint8_t *pkt, uint8_t len);

    // process an incoming bind packet
    void process_bind(const uint8_t *pkt, uint8_t len);

    // load bind info from storage
    void load_bind_info(void);

    // save bind info to storage
    void save_bind_info(void);

    bool is_DSM2(void);

    // send a 16 byte packet
    void transmit16(const uint8_t data[16]);

    void send_telem_packet(void);
    void irq_handler_send(uint8_t tx_status);

    void send_FCC_test_packet(void);

    // check sending of fw upload ack
    void check_fw_ack(void);

    // re-sync DSM2
    void dsm2_start_sync(void);

    // check for double binding
    void check_double_bind(void);

    // setup a timeout handler
    void setup_timeout(uint32_t timeout_ms);
};

#endif  // AP_RADIO_CYRPRESS_ENABLED
                                                                                                                                                                                                                                                                                                                                    #include "AP_Radio_config.h"

#if AP_RADIO_BK2425_ENABLED

// --------------------------------------------------------------------
//  low level driver for the beken radio on SPI
// --------------------------------------------------------------------

#include "driver_bk2425.h"

#include <utility>
#include <AP_HAL_ChibiOS/AP_HAL_ChibiOS.h>
using namespace ChibiOS;

//#pragma GCC optimize("O0")

extern const AP_HAL::HAL& hal;

#if CONFIG_HAL_BOARD == HAL_BOARD_CHIBIOS
#include <hal.h>
#endif

// This assumes we are using ChiBios instead of the pixhawk o/s for accessing GPIO
#if CONFIG_HAL_BOARD_SUBTYPE == HAL_BOARD_SUBTYPE_CHIBIOS_SKYVIPER_F412
#define BEKEN_SELECT()      (dev->set_chip_select(true))
#define BEKEN_DESELECT()    (dev->set_chip_select(false))
#define BEKEN_CE_HIGH()     (palSetLine(HAL_GPIO_PIN_RADIO_CE)) // (hal.gpio->write(HAL_CHIBIOS_GPIO_RADIO_CE, 1))
#define BEKEN_CE_LOW()      (palClearLine(HAL_GPIO_PIN_RADIO_CE)) // (hal.gpio->write(HAL_CHIBIOS_GPIO_RADIO_CE, 0))
#define BEKEN_PA_HIGH()     (palSetLine(HAL_GPIO_PIN_RADIO_PA_CTL)) // (hal.gpio->write(HAL_CHIBIOS_GPIO_RADIO_PA_CTL, 1))
#define BEKEN_PA_LOW()      (palClearLine(HAL_GPIO_PIN_RADIO_PA_CTL)) // (hal.gpio->write(HAL_CHIBIOS_GPIO_RADIO_PA_CTL, 0))
#if SUPPORT_BK_DEBUG_PINS
#define DEBUG1_HIGH()       (palSetLine(HAL_GPIO_PIN_DEBUG1))
#define DEBUG1_LOW()        (palClearLine(HAL_GPIO_PIN_DEBUG1))
#define DEBUG2_HIGH()       (palSetLine(HAL_GPIO_PIN_DEBUG2))
#define DEBUG2_LOW()        (palClearLine(HAL_GPIO_PIN_DEBUG2))
#else
#define DEBUG1_HIGH()       do {} while (0)
#define DEBUG1_LOW()        do {} while (0)
#define DEBUG2_HIGH()       do {} while (0)
#define DEBUG2_LOW()        do {} while (0)
#endif
#else
#error This configuration is not supported.
#endif

// --------------------------------------------------------------------
// Radio initialisation tables
// --------------------------------------------------------------------

#if (TX_SPEED==250)
ITX_SPEED Radio_Beken::gTxSpeed = ITX_250;
#elif (TX_SPEED==100)
ITX_SPEED Radio_Beken::gTxSpeed = ITX_1000;
#elif (TX_SPEED==2000)
ITX_SPEED Radio_Beken::gTxSpeed = ITX_2000;
#endif


// --------------------------------------------------------------------
static const uint8_t Bank1_RegTable[ITX_MAX][IREG_MAX][5]= {
    // (TX_SPEED == 250u) // [ITX_250]
    {
        { BK2425_R1_4,  0xf9,0x96,0x8a,0xdb }, // 0xDB8A96f9ul, // [IREG1_4]  REG4 250kbps
        { BK2425_R1_5,  0x24,0x06,0x0f,0xb6 }, // 0xB60F0624ul, // [IREG1_5]  REG5 250kbps
        PLL_SPEED,                                              // [IREG1_12] REG12
        { BK2425_R1_13, 0x36,0xb4,0x80,0x00 }, // 0x36B48000ul, // [IREG1_13] REG13
        { BK2425_R1_4,  0xff,0x96,0x8a,0xdb }, // 0xDB8A96f9ul, // [IREG1_4A] REG4 250kbps
    },
    // (TX_SPEED == 1000u) [ITX_1000]
    {
        { BK2425_R1_4,  0xf9,0x96,0x82,0x1b }, // 0x1B8296f9ul, // [IREG1_4]  REG4 1Mbps
        { BK2425_R1_5,  0x24,0x06,0x0f,0xa6 }, // 0xA60F0624ul, // [IREG1_5]  REG5 1Mbps
        PLL_SPEED,                                              // [IREG1_12] REG12
        { BK2425_R1_13, 0x36,0xb4,0x80,0x00 }, // 0x36B48000ul, // [IREG1_13] REG13
        { BK2425_R1_4,  0xff,0x96,0x82,0x1b }, // 0x1B8296f9ul, // [IREG1_4A] REG4 1Mbps
    },
    // (TX_SPEED == 2000u) [ITX_2000]
    {
        { BK2425_R1_4,  0xf9,0x96,0x82,0xdb }, // 0xdb8296f9ul, // [IREG1_4]  REG4 2Mbps
        { BK2425_R1_5,  0x24,0x06,0x0f,0xb6 }, // 0xb60f0624ul, // [IREG1_5]  REG5 2Mbps
        PLL_SPEED,                                              // [IREG1_12] REG12
        { BK2425_R1_13, 0x36,0xb4,0x80,0x00 }, // 0x36B48000ul, // [IREG1_13] REG13
        { BK2425_R1_4,  0xff,0x96,0x82,0xdb }, // 0xdb8296f9ul, // [IREG1_4A] REG4 2Mbps
    },
    // (TX_SPEED == 0u) // [ITX_CARRIER]
    {
        { BK2425_R1_4,  0xf9,0x96,0x82,0x21 }, // 0xF9968221ul, // [IREG1_4] REG4 carrier
        { BK2425_R1_5,  0x24,0x06,0x0f,0xb6 }, // 0xB60F0624ul, // [IREG1_5] REG5 250kbps
        PLL_SPEED,                                              // [IREG1_12] REG12
        { BK2425_R1_13, 0x36,0xb4,0x80,0x00 }, // 0x36B48000ul, // [IREG1_13] REG13
        { BK2425_R1_4,  0xff,0x96,0x82,0x21 }, // 0xDB8A96f9ul, // [IREG1_4A] REG4 250kbps
    }
};


// --------------------------------------------------------------------
static const uint8_t Bank0_Reg6[ITX_MAX][2] = {
    {BK_RF_SETUP,   0x27}, //  250kbps (6) 0x27=250kbps
    {BK_RF_SETUP,   0x07}, // 1000kbps (6) 0x07=1Mbps, high gain, high txpower
    {BK_RF_SETUP,   0x2F}, // 2000kbps (6) 0x2F=2Mbps, high gain, high txpower
    {BK_RF_SETUP,   0x37}, //  250kbps (6) 0x10=carrier
};

// --------------------------------------------------------------------
static const uint8_t Bank1_Reg14[]= {
    0x41,0x20,0x08,0x04,0x81,0x20,0xcf,0xF7,0xfe,0xff,0xff
};

// --------------------------------------------------------------------
// Bank0 register initialization value
static const uint8_t Bank0_Reg[][2]= {

#if 0
    {BK_CONFIG,     BK_CONFIG_PWR_UP | BK_CONFIG_PRIM_RX }, // (0) 0x0F=Rx, PowerUp, no crc, all interrupts enabled
    {BK_EN_AA,      0x00}, // (1) 0x00=No auto acknowledge packets on all 6 data pipes (0..5)
    {BK_EN_RXADDR,  0x02}, // (2) 0x01=1 or 2 out of 6 data pipes enabled (pairing heartbeat and my tx)
    {BK_SETUP_AW,   0x03}, // (3) 0x01=3 byte address width
#else
    {BK_CONFIG,     BK_CONFIG_EN_CRC | BK_CONFIG_CRCO | BK_CONFIG_PWR_UP | BK_CONFIG_PRIM_RX }, // (0) 0x0F=Rx, PowerUp, crc16, all interrupts enabled
    {BK_EN_AA,      0x00}, // (1) 0x00=No auto acknowledge packets on all 6 data pipes (0..5)
    {BK_EN_RXADDR,  0x03}, // (2) 0x01=1 or 2 out of 6 data pipes enabled (pairing heartbeat and my tx)
    {BK_SETUP_AW,   0x03}, // (3) 0x03=5 byte address width
#endif
    {BK_SETUP_RETR, 0x00}, // (4) 0x00=No retransmissions
    {BK_RF_CH,      0x17}, // (5) 0x17=2423Mhz default frequency

    // Comment in Beken code says that 0x0F or 0x2F=2Mbps; 0x07=1Mbps; 0x27=250Kbps
#if (TX_SPEED == 2000)
    {BK_RF_SETUP,   0x2F},      // (6) 0x2F=2Mbps, high gain, high txpower
#elif (TX_SPEED == 1000)
    {BK_RF_SETUP,   0x07},      // (6) 0x07=1Mbps, high gain, high txpower
#elif (TX_SPEED == 250)
    {BK_RF_SETUP,   0x27},       // (6) 0x27=250kbps
    //{BK_RF_SETUP,   0x21},    // (6) 0x27=250kbps, lowest txpower
#endif

    {BK_STATUS,     0x07},          // (7) 7=no effect
    {BK_OBSERVE_TX, 0x00},          // (8) (no effect)
    {BK_CD,         0x00},          // (9) Carrier detect (no effect)
    // (10) = 5 byte register
    // (11) = 5 byte register
    {BK_RX_ADDR_P2, 0xc3},          // (12) rx address for data pipe 2
    {BK_RX_ADDR_P3, 0xc4},          // (13) rx address for data pipe 3
    {BK_RX_ADDR_P4, 0xc5},          // (14) rx address for data pipe 4
    {BK_RX_ADDR_P5, 0xc6},          // (15) rx address for data pipe 5
    // (16) = 5 byte register
    {BK_RX_PW_P0,   PACKET_LENGTH_RX_CTRL},          // (17) size of rx data pipe 0
    {BK_RX_PW_P1,   PACKET_LENGTH_RX_BIND},          // (18) size of rx data pipe 1
    {BK_RX_PW_P2,   0x20},          // (19) size of rx data pipe 2
    {BK_RX_PW_P3,   0x20},          // (20) size of rx data pipe 3
    {BK_RX_PW_P4,   0x20},          // (21) size of rx data pipe 4
    {BK_RX_PW_P5,   0x20},          // (22) size of rx data pipe 5
    {BK_FIFO_STATUS,0x00},          // (23) fifo status
    // (24,25,26,27)
    {BK_DYNPD,      0x3F},          // (28) 0x3f=enable dynamic payload length for all 6 data pipes
    {BK_FEATURE,    BK_FEATURE_EN_DPL | BK_FEATURE_EN_ACK_PAY | BK_FEATURE_EN_DYN_ACK }  // (29) 7=enable ack, no ack, dynamic payload length
};

// ----------------------------------------------------------------------------
const uint8_t RegPower[8][2] = {
    { OUTPUT_POWER_REG4_0, OUTPUT_POWER_REG6_0 },
    { OUTPUT_POWER_REG4_1, OUTPUT_POWER_REG6_1 },
    { OUTPUT_POWER_REG4_2, OUTPUT_POWER_REG6_2 },
    { OUTPUT_POWER_REG4_3, OUTPUT_POWER_REG6_3 },
    { OUTPUT_POWER_REG4_4, OUTPUT_POWER_REG6_4 },
    { OUTPUT_POWER_REG4_5, OUTPUT_POWER_REG6_5 },
    { OUTPUT_POWER_REG4_6, OUTPUT_POWER_REG6_6 },
    { OUTPUT_POWER_REG4_7, OUTPUT_POWER_REG6_7 },
};

// --------------------------------------------------------------------
// Generic functions
// --------------------------------------------------------------------

// --------------------------------------------------------------------
// constructor
Radio_Beken::Radio_Beken(AP_HAL::OwnPtr<AP_HAL::SPIDevice> _dev) :
    dev(std::move(_dev))
{
    ResetAddress();
}

// --------------------------------------------------------------------
// Use the default addresses
void Radio_Beken::ResetAddress(void)
{
    // Set the default address
    TX_Address[0] = 0x33;
    TX_Address[1] = RX0_Address[1] = 0x00;
    TX_Address[2] = RX0_Address[2] = 0x59;
    TX_Address[3] = RX0_Address[3] = 0x00;
    TX_Address[4] = RX0_Address[4] = 0x00;
    RX0_Address[0] = 0x31;
    RX1_Address[0] = 0x32;
    RX1_Address[1] = 0x99;
    RX1_Address[2] = 0x59;
    RX1_Address[3] = 0xC6;
    RX1_Address[4] = 0x2D;
}

// --------------------------------------------------------------------
// Raw SPI access functions
// --------------------------------------------------------------------

// --------------------------------------------------------------------
void Radio_Beken::ReadRegisterMulti(uint8_t address, uint8_t *data, uint8_t len)
{
    uint8_t tx[len+1];
    uint8_t rx[len+1];
    memset(tx, 0, len+1);
    memset(rx, 0, len+1);
    tx[0] = address;
    DEBUG2_HIGH();
    (void)dev->transfer_fullduplex(tx, rx, len+1);
    DEBUG2_LOW();
    memcpy(data, &rx[1], len);
}

// --------------------------------------------------------------------
void Radio_Beken::WriteRegisterMulti(uint8_t address, const uint8_t *data, uint8_t len)
{
    uint8_t tx[len+1];
    uint8_t rx[len+1];
    memset(rx, 0, len+1);
    tx[0] = address;
    memcpy(&tx[1], data, len);
    DEBUG2_HIGH();
    (void)dev->transfer_fullduplex(tx, rx, len+1);
    DEBUG2_LOW();
}

// --------------------------------------------------------------------
// Low-level Beken functions
// --------------------------------------------------------------------

// --------------------------------------------------------------------
uint8_t Radio_Beken::ReadStatus(void)
{
    uint8_t tx = BK_NOP;
    uint8_t rx = 0;
    DEBUG2_HIGH();
    (void)dev->transfer_fullduplex(&tx, &rx, 1);
    DEBUG2_LOW();
    return rx; // Status
}

// --------------------------------------------------------------------
uint8_t Radio_Beken::ReadReg(uint8_t reg)
{
    uint8_t tx[2];
    uint8_t rx[2];
    memset(tx, 0, 2);
    memset(rx, 0, 2);
    tx[0] = reg | BK_READ_REG;
    DEBUG2_HIGH();
    (void)dev->transfer_fullduplex(tx, rx, 2);
    DEBUG2_LOW();
    return rx[1];
}

// --------------------------------------------------------------------
uint8_t Radio_Beken::Strobe(uint8_t address)
{
    uint8_t tx = address;
    uint8_t rx = 0;
    DEBUG2_HIGH();
    (void)dev->transfer_fullduplex(&tx, &rx, 1);
    DEBUG2_LOW();
    return rx; // Status
}

// --------------------------------------------------------------------
// Set which register bank we are accessing
void Radio_Beken::SetRBank(uint8_t bank) // 1:Bank1 0:Bank0
{
    uint8_t lastbank = ReadStatus() & BK_STATUS_RBANK;
    if (!lastbank != !bank) {
        uint8_t tx[2];
        uint8_t rx[2];
        tx[0] = BK_ACTIVATE_CMD;
        tx[1] = 0x53;
        DEBUG2_HIGH();
        (void)dev->transfer_fullduplex(&tx[0], &rx[0], 2);
        DEBUG2_LOW();
    }
}

// --------------------------------------------------------------------
void Radio_Beken::WriteReg(uint8_t address, uint8_t data)
{
    uint8_t tx[2];
    uint8_t rx[2];
    memset(rx, 0, 2);
    tx[0] = address; // done by caller | BK_WRITE_REG;
    tx[1] = data;
    DEBUG2_HIGH();
    (void)dev->transfer_fullduplex(tx, rx, 2);
    DEBUG2_LOW();
}

// --------------------------------------------------------------------
void Radio_Beken::WriteRegisterMultiBank1(uint8_t address, const uint8_t *data, uint8_t length)
{
    SetRBank(1);
    WriteRegisterMulti(address, data, length);
    SetRBank(0);
}

// --------------------------------------------------------------------
// High-level Beken functions
// --------------------------------------------------------------------

// --------------------------------------------------------------------
// Set the radio transmission power of the beken
// Prerequisite: We should be in idle mode before calling this function
void Radio_Beken::SetPower(uint8_t power)
{
    if (power > 7) {
        power = 7;
    }
    uint8_t oldready = bkReady;
    bkReady = 0;
    hal.scheduler->delay(100); // delay more than 50ms.
    SetRBank(1);
    {
        const uint8_t* p = &Bank1_RegTable[fcc.CW_mode ? ITX_CARRIER : gTxSpeed][IREG1_4][0];
        uint8_t idx = *p++;
        uint8_t buf[4];
        buf[0] = *p++;
        buf[1] = *p++;
        buf[2] = *p++;
        buf[3] = *p++;
        buf[0] &= ~0x38;
        buf[0] |= (RegPower[power][0] << 3); // Bits 27..29
        WriteRegisterMulti((BK_WRITE_REG|idx), buf, 4);
    }
    hal.scheduler->delay(100); // delay more than 50ms.
    SetRBank(0);
    hal.scheduler->delay(100);

    uint8_t setup = ReadReg(BK_RF_SETUP);
    setup &= ~(3 << 1);
    setup |= (RegPower[power][1] << 1); // Bits 1..2
    if (fcc.CW_mode) {
        setup |= 0x10;
    }
    WriteReg(BK_WRITE_REG|BK_RF_SETUP, setup);
    bkReady = oldready;
    fcc.power = power;
}

// --------------------------------------------------------------------
// Set the physical radio transmission frequency of the beken
void Radio_Beken::SetChannel(uint8_t freq)
{
    lastTxChannel = freq;
    WriteReg(BK_WRITE_REG|BK_RF_CH, freq);
}

// --------------------------------------------------------------------
// Set the radio transmission mode of the beken
// Enable/disable the carrier sending mode
// Prerequisite: We should be in idle mode before calling this function
void Radio_Beken::SetCwMode(uint8_t cw)
{
    uint8_t oldready = bkReady;
    bkReady = 0;
    hal.scheduler->delay(100); // delay more than 50ms.
    SetRBank(1);
    {
        const uint8_t* p = &Bank1_RegTable[cw ? ITX_CARRIER : gTxSpeed][IREG1_4][0];
        uint8_t idx = *p++;
        uint8_t buf[4];
        buf[0] = *p++;
        buf[1] = *p++;
        buf[2] = *p++;
        buf[3] = *p++;
        buf[0] &= ~0x38;
        buf[0] |= (RegPower[fcc.power & 7][0] << 3); // Bits 27..29
        WriteRegisterMulti((BK_WRITE_REG|idx), buf, 4);
    }
    hal.scheduler->delay(100); // delay more than 50ms.
    SetRBank(0);
    hal.scheduler->delay(100); // delay more than 50ms.

    uint8_t setup = ReadReg(BK_RF_SETUP);
    setup &= ~(3 << 1);
    setup |= (RegPower[fcc.power & 7][1] << 1); // Bits 1..2
    if (cw) {
        setup |= 0x10;
    }
    WriteReg((BK_WRITE_REG|BK_RF_SETUP), setup);
    fcc.CW_mode = cw != 0;
    bkReady = oldready;
}

// --------------------------------------------------------------------
// Enable/disable the CRC receive  mode
// Prerequisite: We should be in idle mode before calling this function
void Radio_Beken::SetCrcMode(uint8_t disable_crc)
{
    uint8_t oldready = bkReady;
    bkReady = 0;

    uint8_t config = ReadReg(BK_CONFIG);
    if (disable_crc) {
        config &= ~(BK_CONFIG_EN_CRC | BK_CONFIG_CRCO);    // Disable CRC
    } else {
        config |= (BK_CONFIG_EN_CRC | BK_CONFIG_CRCO);    // Enable CRC
    }
    WriteReg((BK_WRITE_REG|BK_CONFIG), config);
    fcc.disable_crc = (disable_crc != 0);
    bkReady = oldready;
}

// ----------------------------------------------------------------------------
// Enable the carrier detect feature: Bank1 Reg5 Bit 18
void Radio_Beken::EnableCarrierDetect(bool bEnable)
{
    if (bEnable == fcc.enable_cd) {
        return;
    }
    uint8_t oldready = bkReady;
    bkReady = 0;
    SetRBank(1);
    {
        const uint8_t* p = &Bank1_RegTable[gTxSpeed][IREG1_5][0];
        uint8_t idx = *p++;
        uint8_t buf[4];
        buf[0] = *p++;
        buf[1] = *p++;
        buf[2] = *p++;
        buf[3] = *p++;
        if (bEnable) {
            buf[1] &= ~0x04;
        }
        WriteRegisterMulti((BK_WRITE_REG|idx), buf, 4);
    }
    SetRBank(0);
    bkReady = oldready;
    fcc.enable_cd = bEnable;
}

// ----------------------------------------------------------------------------
// Returns true if a carrier is detected
bool Radio_Beken::CarrierDetect(void)
{
    if (fcc.enable_cd) {
        if (ReadReg(BK_CD) & 0x01) {
            return true;
        }
    }
    return false;
}

// ----------------------------------------------------------------------------
void Radio_Beken::SetFactoryMode(uint8_t factory)
{
    uint8_t oldready = bkReady;
    bkReady = 0;

    // Set receive/transmit addresses
    if (factory) {
        // For factory modes, use fixed addresses
        TX_Address[0] = 0x35;
        TX_Address[1] = RX1_Address[1] = RX0_Address[1] = 0x99;
        TX_Address[2] = RX1_Address[2] = RX0_Address[2] = 0x59;
        TX_Address[3] = RX1_Address[3] = RX0_Address[3] = 0xC6;
        TX_Address[4] = RX1_Address[4] = RX0_Address[4] = factory;
        RX0_Address[0] = 0x34;
        RX1_Address[0] = 0x43;
    } else {
        // For normal modes, use the default addresses
        ResetAddress();
    }

    // Write the addresses to the registers
    WriteRegisterMulti((BK_WRITE_REG|BK_RX_ADDR_P0), RX0_Address, 5);
    WriteRegisterMulti((BK_WRITE_REG|BK_RX_ADDR_P1), RX1_Address, 5);
    WriteRegisterMulti((BK_WRITE_REG|BK_TX_ADDR), TX_Address, 5);
    WriteReg(BK_WRITE_REG|BK_EN_RXADDR, 0x03);

    // Frequency is set by the caller
    fcc.factory_mode = factory;
    bkReady = oldready;
}

// ----------------------------------------------------------------------------
bool Radio_Beken::Reset(void)
{
    //...
    hal.scheduler->delay_microseconds(1000);
    return 0;
}

// ----------------------------------------------------------------------------
// Delay after changing chip-enable
// This can be called from within the interrupt response thread
void Radio_Beken::DelayCE(void)
{
    DEBUG1_LOW();
    hal.scheduler->delay_microseconds(50);
    DEBUG1_HIGH();
}

// ----------------------------------------------------------------------------
bool Radio_Beken::WasTxMode(void)
{
    // Were we transmitting something?
    return bkMode == BKRADIO_TX;
}

// ----------------------------------------------------------------------------
bool Radio_Beken::WasRxMode(void)
{
    // Were we receiving something?
    return bkMode == BKRADIO_RX;
}

// ----------------------------------------------------------------------------
// Switch to Rx mode
void Radio_Beken::SwitchToRxMode(void)
{
    uint8_t value;

    Strobe(BK_FLUSH_RX); // flush Rx
    value = ReadStatus(); // read register STATUS's value
    WriteReg(BK_WRITE_REG|BK_STATUS, value); // clear RX_DR or TX_DS or MAX_RT interrupt flag

    BEKEN_CE_LOW();
    DelayCE();
    value = ReadReg(BK_CONFIG);	// read register CONFIG's value
    value |= BK_CONFIG_PRIM_RX; // set bit 0
    value |= BK_CONFIG_PWR_UP;
    WriteReg(BK_WRITE_REG | BK_CONFIG, value); // Set PWR_UP bit, enable CRC(2 length) & Prim:RX. RX_DR enabled..

    BEKEN_CE_HIGH();
    //BEKEN_PA_LOW(); // we dont have a PA on the RX side
    bkMode = BKRADIO_RX;
}

// ----------------------------------------------------------------------------
// switch to Tx mode
void Radio_Beken::SwitchToTxMode(void)
{
    uint8_t value;
    Strobe(BK_FLUSH_TX); // flush half-sent Tx
    Strobe(BK_FLUSH_RX); // flush half-received rx

    //  BEKEN_PA_HIGH();
    BEKEN_CE_LOW();
    DelayCE();
    value = ReadReg(BK_CONFIG); // read register CONFIG's value
    value &= ~BK_CONFIG_PRIM_RX; // Clear bit 0 (PTX)
    value |= BK_CONFIG_PWR_UP;
    WriteReg(BK_WRITE_REG | BK_CONFIG, value); // Set PWR_UP bit, enable CRC(2 length) & Prim:RX. RX_DR enabled.
    //  BEKEN_CE_HIGH();
    bkMode = BKRADIO_TX;
}

// ----------------------------------------------------------------------------
// switch to Idle mode
void Radio_Beken::SwitchToIdleMode(void)
{
    Strobe(BK_FLUSH_TX); // flush Tx
    Strobe(BK_FLUSH_RX); // flush Rx

    BEKEN_PA_LOW();
    BEKEN_CE_LOW();
    DelayCE();
    bkMode = BKRADIO_IDLE;
}

// ----------------------------------------------------------------------------
// Switch to Sleep mode
void Radio_Beken::SwitchToSleepMode(void)
{
    uint8_t value;
    Strobe(BK_FLUSH_RX); // flush Rx
    Strobe(BK_FLUSH_TX); // flush Tx
    value = ReadStatus(); // read register STATUS's value
    WriteReg(BK_WRITE_REG|BK_STATUS, value); // clear RX_DR or TX_DS or MAX_RT interrupt flag

    BEKEN_PA_LOW();
    BEKEN_CE_LOW();
    DelayCE();
    value = ReadReg(BK_CONFIG);	// read register CONFIG's value
    value |= BK_CONFIG_PRIM_RX; // Receive mode
    value &= ~BK_CONFIG_PWR_UP; // Power down
    WriteReg(BK_WRITE_REG | BK_CONFIG, value); // Clear PWR_UP bit, enable CRC(2 length) & Prim:RX. RX_DR enabled..
    // Stay low
    BEKEN_CE_LOW();
    bkMode = BKRADIO_SLEEP;
}

// ----------------------------------------------------------------------------
void Radio_Beken::InitBank0Registers(ITX_SPEED spd)
{
    int8_t i;

    //********************Write Bank0 register******************
    for (i=20; i >= 0; i--) { // From BK_FIFO_STATUS back to beginning of table
        uint8_t idx = Bank0_Reg[i][0];
        uint8_t value = Bank0_Reg[i][1];
        if (idx == BK_RF_SETUP) { // Adjust for speed
            value = Bank0_Reg6[spd][1];
        }
        WriteReg((BK_WRITE_REG|idx), value);
    }

    // Enable features
    i = ReadReg(BK_FEATURE);
    if (i == 0) { // i!=0 showed that chip has been actived. So do not active again (as that would toggle these features off again).
        WriteReg(BK_ACTIVATE_CMD,0x73);    // Activate the BK_FEATURE register. (This command must NOT have BK_WRITE_REG set)
    }
    for (i = 22; i >= 21; i--) {
        WriteReg((BK_WRITE_REG|Bank0_Reg[i][0]),Bank0_Reg[i][1]);
    }

    // Set the various 5 byte addresses
    WriteRegisterMulti((BK_WRITE_REG|BK_RX_ADDR_P0),RX0_Address,5); // reg 10 - Rx0 addr
    WriteRegisterMulti((BK_WRITE_REG|BK_RX_ADDR_P1),RX1_Address,5); // REG 11 - Rx1 addr
    WriteRegisterMulti((BK_WRITE_REG|BK_TX_ADDR),TX_Address,5); // REG 16 - TX addr
    WriteReg(BK_WRITE_REG|BK_EN_RXADDR, 0x03);

}

// ----------------------------------------------------------------------------
void Radio_Beken::InitBank1Registers(ITX_SPEED spd)
{
    int16_t i;

    for (i = IREG1_4; i <= IREG1_13; i++) {
        const uint8_t* p = &Bank1_RegTable[spd][i][0];
        uint8_t idx = *p++;
        WriteRegisterMulti((BK_WRITE_REG|idx), p, 4);
    }
    WriteRegisterMulti((BK_WRITE_REG|BK2425_R1_14),&(Bank1_Reg14[0]),11);

    //toggle REG4<25,26>
    {
        const uint8_t* p = &Bank1_RegTable[spd][IREG1_4A][0];
        uint8_t idx = *p++;
        WriteRegisterMulti((BK_WRITE_REG|idx), p, 4);
    }
    {
        const uint8_t* p = &Bank1_RegTable[spd][IREG1_4][0];
        uint8_t idx = *p++;
        WriteRegisterMulti((BK_WRITE_REG|idx), p, 4);
    }
}

// ----------------------------------------------------------------------------
// Set the rx and tx addresses
void Radio_Beken::SetAddresses(const uint8_t* txaddr)
{
    TX_Address[1] = RX0_Address[1] = txaddr[1];
    TX_Address[3] = RX0_Address[3] = txaddr[3];
    TX_Address[4] = RX0_Address[4] = txaddr[4];
    WriteRegisterMulti((BK_WRITE_REG|BK_RX_ADDR_P0), RX0_Address, 5);
    WriteRegisterMulti((BK_WRITE_REG|BK_TX_ADDR), TX_Address, 5);
    WriteReg(BK_WRITE_REG|BK_EN_RXADDR, 0x03);
}

// ----------------------------------------------------------------------------
bool Radio_Beken::ClearAckOverflow(void)
{
    uint8_t status = ReadStatus();
    if ((BK_STATUS_MAX_RT & status) == 0) {
        return false;
    } else {
        WriteReg((BK_WRITE_REG|BK_STATUS), BK_STATUS_MAX_RT);
        return true;
    }
}


// ----------------------------------------------------------------------------
// Write a data packet
bool Radio_Beken::SendPacket(uint8_t type, ///< WR_TX_PLOAD or W_TX_PAYLOAD_NOACK_CMD
                             const uint8_t* pbuf, ///< a buffer pointer
                             uint8_t len) ///< packet length in bytes
{
    uint8_t fifo_sta = ReadReg(BK_FIFO_STATUS);	// read register FIFO_STATUS's value
    bool returnValue = ClearAckOverflow();

    if (!(fifo_sta & BK_FIFO_STATUS_TX_FULL)) { // if not full, send data
        numTxPackets++;
        WriteRegisterMulti(type, pbuf, len); // Writes data to buffer A0,B0,A8
        BEKEN_CE_HIGH(); // Wait until FIFO has the data before sending it.
    }
    return returnValue;
}

// ----------------------------------------------------------------------------
// For debugging - tell us the current beken register values (from bank 0)
// This just prints it to the UART rather than to the console over WiFi
void Radio_Beken::DumpRegisters(void)
{
    uint8_t i;
    for (i = 0; i <= BK_FEATURE; ++i) {
        uint8_t len = 1;
        switch (i) {
        case 10: case 11: case 16: len = 5; break;
        case 24: case 25: case 26: case 27: len = 0; break;
        default: len = 1; break;
        };
        if (len == 1) {
            //printf("Bank0reg%d : %x\r\n", i, ReadReg(i));
        } else if (len == 5) {
            uint8_t data[5];
            ReadRegisterMulti(i, &data[0], len);
            //printf("Bank0reg%d : %x %x %x %x %x\r\n", i, data[0], data[1], data[2], data[3], data[4]);
        }
    }
    SetRBank(1);
    for (i = IREG1_4; i <= IREG1_13; ++i) {
        uint8_t len = 4;
        uint8_t data[4];
        ReadRegisterMulti(i, &data[0], len);
        //uint8_t idx = Bank1_RegTable[0][i][0];
        //printf("Bank1reg%d : %x %x %x %x\r\n", idx, data[0], data[1], data[2], data[3]);
    }
    SetRBank(0);
}

#endif // AP_RADIO_BK2425_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          /*
  structures for telemetry packets
  This header is common to ArduPilot AP_Radio and STM8 TX code
 */

#pragma once

enum telem_type {
    TELEM_STATUS= 0, // a telem_status packet
    TELEM_PLAY  = 1, // play a tune
    TELEM_FW    = 2, // update new firmware
};

// flags in telem_status structure
#define TELEM_FLAG_GPS_OK  (1U<<0)
#define TELEM_FLAG_ARM_OK  (1U<<1)
#define TELEM_FLAG_BATT_OK (1U<<2)
#define TELEM_FLAG_ARMED   (1U<<4)
#define TELEM_FLAG_POS_OK  (1U<<5)
#define TELEM_FLAG_VIDEO   (1U<<6)
#define TELEM_FLAG_HYBRID  (1U<<7)

struct PACKED telem_status {
    uint8_t pps; // packets per second received
    uint8_t rssi; // lowpass rssi
    uint8_t flags; // TELEM_FLAG_*
    uint8_t flight_mode; // flight mode (with profile number in high bit)
    uint8_t wifi_chan; // wifi channel number on Sonix
    uint8_t tx_max;  // max TX power
    uint8_t note_adjust; // buzzer tone adjustment
};

// write to new firmware. This is also used to play a tune
struct PACKED telem_firmware {
    uint8_t seq;
    uint8_t len;
    uint16_t offset;
    uint8_t data[4];
};

/*
  telemetry packet from RX to TX for cypress
 */
struct PACKED telem_packet_cypress {
    uint8_t crc; // simple CRC
    enum telem_type type;
    union {
        uint8_t pkt[14];
        struct telem_status status;
        struct telem_firmware fw;
    } payload;
};

/*
  cc2500 specific protocol structures
 */
struct PACKED telem_status_cc2500 {
    uint8_t pps; // packets per second received
    uint8_t rssi; // lowpass rssi
    uint8_t flags; // TELEM_FLAG_*
    uint8_t flight_mode; // flight mode (with profile number in high bit)
    uint8_t wifi_chan; // wifi channel number on Sonix
    uint8_t tx_max;  // max TX power
    uint8_t note_adjust; // buzzer tone adjustment
    uint8_t rxid[2]; // 16 bit ID for cc2500 to prevent double binds
};

/*
  telemetry packet from RX to TX for cc2500
 */
struct PACKED telem_packet_cc2500 {
    uint8_t length;
    uint8_t type;
    uint8_t txid[2];
    union {
        uint8_t pkt[9];
        struct telem_status_cc2500 status;
        struct telem_firmware fw;
    } payload;
};

/*
  autobind packet from TX to RX for cc2500
 */
struct PACKED autobind_packet_cc2500 {
    uint8_t length;
    uint8_t magic1; // 0xC5
    uint8_t magic2; // 0xA2
    uint8_t txid[2];
    uint8_t txid_inverse[2];
    uint8_t wifi_chan;
    uint8_t pad[3]; // pad to 13 bytes for fixed packet length
    uint8_t crc[2];
};

/*
  packet type - controls data field. We have 4 bits, giving 16 possible
  data field types
 */
enum packet_type {
    PKTYPE_VOLTAGE    = 0,
    PKTYPE_YEAR       = 1,
    PKTYPE_MONTH      = 2,
    PKTYPE_DAY        = 3,
    PKTYPE_TELEM_RSSI = 4,
    PKTYPE_TELEM_PPS  = 5,
    PKTYPE_BL_VERSION = 6,
    PKTYPE_FW_ACK     = 7,
    PKTYPE_RXID1      = 8,
    PKTYPE_RXID2      = 9,
    PKTYPE_NUM_TYPES  = 10 // used for modulus
};

/*
  skyrocket specific packet from TX to RX for cc2500
 */
struct PACKED srt_packet {
    uint8_t length;     // required for cc2500 FIFO
    uint8_t txid[2];
    uint8_t version:4;  // protocol version
    uint8_t pkt_type:4; // packet type
    uint8_t chan1;
    uint8_t chan2;
    uint8_t chan3;
    uint8_t chan4;
    uint8_t chan_high;
    uint8_t data;       // data according to pkt_type
    uint8_t buttons;    // see channels.h
    uint8_t channr;
    uint8_t chanskip;
};
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      #include "AP_Rally_config.h"

#if HAL_RALLY_ENABLED

#include "AP_Rally.h"

#include <AP_AHRS/AP_AHRS.h>
#include <AP_Logger/AP_Logger.h>
#include <StorageManager/StorageManager.h>
#include <AP_Vehicle/AP_Vehicle_Type.h>

// storage object
StorageAccess AP_Rally::_storage(StorageManager::StorageRally);

#if APM_BUILD_COPTER_OR_HELI
  #define RALLY_LIMIT_KM_DEFAULT 0.3f
  #define RALLY_INCLUDE_HOME_DEFAULT 1
#elif APM_BUILD_TYPE(APM_BUILD_ArduPlane)
  #define RALLY_LIMIT_KM_DEFAULT 5.0f
  #define RALLY_INCLUDE_HOME_DEFAULT 0
#elif APM_BUILD_TYPE(APM_BUILD_Rover)
  #define RALLY_LIMIT_KM_DEFAULT 0.5f
  #define RALLY_INCLUDE_HOME_DEFAULT 1
#else
  #define RALLY_LIMIT_KM_DEFAULT 1.0f
  #define RALLY_INCLUDE_HOME_DEFAULT 0
#endif

const AP_Param::GroupInfo AP_Rally::var_info[] = {
    // @Param: TOTAL
    // @DisplayName: Rally Total
    // @Description: Number of rally points currently loaded
    // @User: Advanced
    AP_GROUPINFO("TOTAL", 0, AP_Rally, _rally_point_total_count, 0),

    // @Param: LIMIT_KM
    // @DisplayName: Rally Limit
    // @Description: Maximum distance to rally point. If the closest rally point is more than this number of kilometers from the current position and the home location is closer than any of the rally points from the current position then do RTL to home rather than to the closest rally point. This prevents a leftover rally point from a different airfield being used accidentally. If this is set to 0 then the closest rally point is always used.
    // @User: Advanced
    // @Units: km
    // @Increment: 0.1
    AP_GROUPINFO("LIMIT_KM", 1, AP_Rally, _rally_limit_km, RALLY_LIMIT_KM_DEFAULT),

    // @Param: INCL_HOME
    // @DisplayName: Rally Include Home
    // @Description: Controls if Home is included as a Rally point (i.e. as a safe landing place) for RTL
    // @User: Standard
    // @Values: 0:DoNotIncludeHome,1:IncludeHome
    AP_GROUPINFO("INCL_HOME", 2, AP_Rally, _rally_incl_home, RALLY_INCLUDE_HOME_DEFAULT),

    AP_GROUPEND
};

// constructor
AP_Rally::AP_Rally()
{
    ASSERT_STORAGE_SIZE(RallyLocation, 15);

#if CONFIG_HAL_BOARD == HAL_BOARD_SITL
    if (_singleton != nullptr) {
        AP_HAL::panic("Rally must be singleton");
    }
#endif
    _singleton = this;
    AP_Param::setup_object_defaults(this, var_info);
}

// get a rally point from EEPROM
bool AP_Rally::get_rally_point_with_index(uint8_t i, RallyLocation &ret) const
{
    if (i >= (uint8_t) _rally_point_total_count) {
        return false;
    }

    _storage.read_block(&ret, i * sizeof(RallyLocation), sizeof(RallyLocation));

    if (ret.lat == 0 && ret.lng == 0) {
        return false; // sanity check
    }

    return true; 
}

void AP_Rally::truncate(uint8_t num)
{
    if (num > _rally_point_total_count) {
        // we never make the space larger this way
        return;
    }
    _rally_point_total_count.set_and_save_ifchanged(num);
}

bool AP_Rally::append(const RallyLocation &loc)
{
    const uint8_t current_total = get_rally_total();
    _rally_point_total_count.set_and_save_ifchanged(current_total + 1);
    if (!set_rally_point_with_index(current_total, loc)) {
        _rally_point_total_count.set_and_save_ifchanged(current_total);
        return false;
    }
    return true;
}

// save a rally point to EEPROM - this assumes that the RALLY_TOTAL param has been incremented beforehand, which is the case in Mission Planner
bool AP_Rally::set_rally_point_with_index(uint8_t i, const RallyLocation &rallyLoc)
{
    if (i >= (uint8_t) _rally_point_total_count) {
        return false;
    }

    if (i >= get_rally_max()) {
        return false;
    }

    _storage.write_block(i * sizeof(RallyLocation), &rallyLoc, sizeof(RallyLocation));

    _last_change_time_ms = AP_HAL::millis();

#if HAL_LOGGING_ENABLED
    AP::logger().Write_RallyPoint(_rally_point_total_count, i, rallyLoc);
#endif

    return true;
}

// helper function to translate a RallyLocation to a Location
Location AP_Rally::rally_location_to_location(const RallyLocation &rally_loc) const
{
    //Relative altitudes are relative to HOME point's altitude:
    Location ret {
        rally_loc.lat,
        rally_loc.lng,
        rally_loc.alt * 100,
        (rally_loc.alt_frame_valid == 1) ? Location::AltFrame(rally_loc.alt_frame) : Location::AltFrame::ABOVE_HOME
    };

    return ret;
}

// returns true if a valid rally point is found, otherwise returns false to indicate home position should be used
bool AP_Rally::find_nearest_rally_point(const Location &current_loc, RallyLocation &return_loc) const
{
    float min_dis = -1;

    for (uint8_t i = 0; i < (uint8_t) _rally_point_total_count; i++) {
        RallyLocation next_rally;
        if (!get_rally_point_with_index(i, next_rally)) {
            continue;
        }
        Location rally_loc = rally_location_to_location(next_rally);
        float dis = current_loc.get_distance(rally_loc);

        if (is_valid(rally_loc) && (dis < min_dis || min_dis < 0)) {
            min_dis = dis;
            return_loc = next_rally;
        }
    }

    // if a limit is defined and all rally points are beyond that limit, use home if it is closer
    if ((_rally_limit_km > 0) && (min_dis > _rally_limit_km*1000.0f)) {
        return false; // use home position
    }

    // use home if no rally points found
    return min_dis >= 0;
}

// return best RTL location from current position
Location AP_Rally::calc_best_rally_or_home_location(const Location &current_loc, float rtl_home_alt_amsl_cm) const
{
    // if no valid rally point, return home position:
    Location return_loc { AP::ahrs().get_home() };
    return_loc.set_alt_cm(rtl_home_alt_amsl_cm, Location::AltFrame::ABSOLUTE);

    RallyLocation ral_loc;
    if (find_nearest_rally_point(current_loc, ral_loc)) {
        Location loc = rally_location_to_location(ral_loc);
        // use the rally point if it's closer then home, or we aren't generally considering home as acceptable
        if (!_rally_incl_home  || (current_loc.get_distance(loc) < current_loc.get_distance(return_loc))) {
            return_loc = rally_location_to_location(ral_loc);
        }
    }

    return return_loc;
}

// singleton instance
AP_Rally *AP_Rally::_singleton;

namespace AP {

AP_Rally *rally()
{
    return AP_Rally::get_singleton();
}

}
#endif //HAL_RALLY_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     /// @file    AP_Rally.h
/// @brief   Handles rally point storage, retrieval and lookup

/*
 * The AP_Rally library:
 * 
 * Initial implementation: Michael Day, September 2013
 * Moved to AP_Rally lib:  Andrew Chapman April 2014
 * 
 * - responsible for managing a list of rally points
 * - reads and writes the rally points to storage
 * - provides access to the rally points, including logic to find the nearest one
 *
 */
#pragma once

#include "AP_Rally_config.h"

#if HAL_RALLY_ENABLED

#include <AP_HAL/AP_HAL_Boards.h>

#include <AP_Common/AP_Common.h>
#include <AP_Common/Location.h>
#include <AP_Param/AP_Param.h>

struct PACKED RallyLocation {
    int32_t lat;        //Latitude * 10^7
    int32_t lng;        //Longitude * 10^7
    int16_t alt;        //transit altitude (and loiter altitude) in meters (absolute);
    int16_t break_alt;  //when autolanding, break out of loiter at this alt (meters)
    uint16_t land_dir;   //when the time comes to auto-land, try to land in this direction (centidegrees)
    union {
        uint8_t flags; 
        struct {
            uint8_t favorable_winds : 1; // bit 0 = seek favorable winds when choosing a landing poi
            uint8_t do_auto_land    : 1; // bit 1 = do auto land after arriving
            uint8_t alt_frame_valid : 1; // bit 2 = true if following alt frame value should be used, else Location::AltFrame::ABOVE_HOME
            uint8_t alt_frame       : 2; // Altitude frame following Location::AltFrame enum
            uint8_t unused          : 3;
        };
    };
};

/// @class    AP_Rally
/// @brief    Object managing Rally Points
class AP_Rally {
public:
    AP_Rally();

    /* Do not allow copies */
    CLASS_NO_COPY(AP_Rally);

    // data handling
    bool get_rally_point_with_index(uint8_t i, RallyLocation &ret) const;
    bool set_rally_point_with_index(uint8_t i, const RallyLocation &rallyLoc);
    uint8_t get_rally_total() const {
        return (uint8_t)_rally_point_total_count;
    }
    uint8_t get_rally_max(void) const {
        const uint16_t ret = _storage.size() / uint16_t(sizeof(RallyLocation));
        if (ret > 255) {
            return 255;
        }
        return (uint8_t)ret;
    }
    // reduce point count:
    void truncate(uint8_t num);
    // append a rally point to the list
    bool append(const RallyLocation &loc) WARN_IF_UNUSED;

    float get_rally_limit_km() const { return _rally_limit_km; }

    Location rally_location_to_location(const RallyLocation &ret) const;

    // logic handling
    Location calc_best_rally_or_home_location(const Location &current_loc, float rtl_home_alt_amsl_cm) const;
    bool find_nearest_rally_point(const Location &myloc, RallyLocation &ret) const;

    // last time rally points changed
    uint32_t last_change_time_ms(void) const { return _last_change_time_ms; }

    // parameter block
    static const struct AP_Param::GroupInfo var_info[];

    // get singleton instance
    static AP_Rally *get_singleton() { return _singleton; }


private:
    static AP_Rally *_singleton;

    virtual bool is_valid(const Location &rally_point) const { return true; }

    static StorageAccess _storage;

    // parameters
    AP_Int8  _rally_point_total_count;
    AP_Float _rally_limit_km;
    AP_Int8  _rally_incl_home;

    uint32_t _last_change_time_ms = 0xFFFFFFFF;
};

namespace AP {
    AP_Rally *rally();
};

#endif  // HAL_RALLY_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          #pragma once

#include <AP_HAL/AP_HAL_Boards.h>

#ifndef HAL_RALLY_ENABLED
#define HAL_RALLY_ENABLED 1
#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  /*
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include "AP_RangeFinder.h"

#if AP_RANGEFINDER_ENABLED

#include "AP_RangeFinder_analog.h"
#include "AP_RangeFinder_PulsedLightLRF.h"
#include "AP_RangeFinder_MaxsonarI2CXL.h"
#include "AP_RangeFinder_MaxsonarSerialLV.h"
#include "AP_RangeFinder_BBB_PRU.h"
#include "AP_RangeFinder_LightWareI2C.h"
#include "AP_RangeFinder_LightWareSerial.h"
#if (CONFIG_HAL_BOARD_SUBTYPE == HAL_BOARD_SUBTYPE_LINUX_BEBOP || \
     CONFIG_HAL_BOARD_SUBTYPE == HAL_BOARD_SUBTYPE_LINUX_DISCO) &&      \
    defined(HAVE_LIBIIO)
#include "AP_RangeFinder_Bebop.h"
#endif
#include "AP_RangeFinder_Backend.h"
#include "AP_RangeFinder_Backend_Serial.h"
#include "AP_RangeFinder_MAVLink.h"
#include "AP_RangeFinder_LeddarOne.h"
#include "AP_RangeFinder_USD1_Serial.h"
#include "AP_RangeFinder_TeraRangerI2C.h"
#include "AP_RangeFinder_TeraRanger_Serial.h"
#include "AP_RangeFinder_VL53L0X.h"
#include "AP_RangeFinder_VL53L1X.h"
#include "AP_RangeFinder_NMEA.h"
#include "AP_RangeFinder_Wasp.h"
#include "AP_RangeFinder_Benewake_TF02.h"
#include "AP_RangeFinder_Benewake_TF03.h"
#include "AP_RangeFinder_Benewake_TFMini.h"
#include "AP_RangeFinder_Benewake_TFMiniPlus.h"
#include "AP_RangeFinder_PWM.h"
#include "AP_RangeFinder_GYUS42v2.h"
#include "AP_RangeFinder_HC_SR04.h"
#include "AP_RangeFinder_Bebop.h"
#include "AP_RangeFinder_BLPing.h"
#include "AP_RangeFinder_DroneCAN.h"
#include "AP_RangeFinder_Lanbao.h"
#include "AP_RangeFinder_LeddarVu8.h"
#include "AP_RangeFinder_SITL.h"
#include "AP_RangeFinder_MSP.h"
#include "AP_RangeFinder_USD1_CAN.h"
#include "AP_RangeFinder_Benewake_CAN.h"
#include "AP_RangeFinder_Lua.h"
#include "AP_RangeFinder_NoopLoop.h"
#include "AP_RangeFinder_TOFSenseP_CAN.h"
#include "AP_RangeFinder_NRA24_CAN.h"
#include "AP_RangeFinder_TOFSenseF_I2C.h"
#include "AP_RangeFinder_JRE_Serial.h"
#include "AP_RangeFinder_Ainstein_LR_D1.h"
#include "AP_RangeFinder_RDS02UF.h"

#include <AP_BoardConfig/AP_BoardConfig.h>
#include <AP_Logger/AP_Logger.h>
#include <AP_SerialManager/AP_SerialManager.h>
#include <AP_Vehicle/AP_Vehicle_Type.h>
#include <AP_HAL/I2CDevice.h>
#include <AP_InternalError/AP_InternalError.h>

extern const AP_HAL::HAL &hal;

// table of user settable parameters
const AP_Param::GroupInfo RangeFinder::var_info[] = {

	// @Group: 1_
	// @Path: AP_RangeFinder_Params.cpp
	AP_SUBGROUPINFO(params[0], "1_", 25, RangeFinder, AP_RangeFinder_Params),

    // @Group: 1_
    // @Path: AP_RangeFinder_Wasp.cpp,AP_RangeFinder_Backend_CAN.cpp
    AP_SUBGROUPVARPTR(drivers[0], "1_",  57, RangeFinder, backend_var_info[0]),

#if RANGEFINDER_MAX_INSTANCES > 1
    // @Group: 2_
    // @Path: AP_RangeFinder_Params.cpp
    AP_SUBGROUPINFO(params[1], "2_", 27, RangeFinder, AP_RangeFinder_Params),

    // @Group: 2_
    // @Path: AP_RangeFinder_Wasp.cpp,AP_RangeFinder_Backend_CAN.cpp
    AP_SUBGROUPVARPTR(drivers[1], "2_",  58, RangeFinder, backend_var_info[1]),
#endif

#if RANGEFINDER_MAX_INSTANCES > 2
    // @Group: 3_
    // @Path: AP_RangeFinder_Params.cpp
    AP_SUBGROUPINFO(params[2], "3_", 29, RangeFinder, AP_RangeFinder_Params),

    // @Group: 3_
    // @Path: AP_RangeFinder_Wasp.cpp,AP_RangeFinder_Backend_CAN.cpp
    AP_SUBGROUPVARPTR(drivers[2], "3_",  59, RangeFinder, backend_var_info[2]),
#endif

#if RANGEFINDER_MAX_INSTANCES > 3
    // @Group: 4_
    // @Path: AP_RangeFinder_Params.cpp
    AP_SUBGROUPINFO(params[3], "4_", 31, RangeFinder, AP_RangeFinder_Params),

    // @Group: 4_
    // @Path: AP_RangeFinder_Wasp.cpp,AP_RangeFinder_Backend_CAN.cpp
    AP_SUBGROUPVARPTR(drivers[3], "4_",  60, RangeFinder, backend_var_info[3]),
#endif

#if RANGEFINDER_MAX_INSTANCES > 4
    // @Group: 5_
    // @Path: AP_RangeFinder_Params.cpp
    AP_SUBGROUPINFO(params[4], "5_", 33, RangeFinder, AP_RangeFinder_Params),

    // @Group: 5_
    // @Path: AP_RangeFinder_Wasp.cpp,AP_RangeFinder_Backend_CAN.cpp
    AP_SUBGROUPVARPTR(drivers[4], "5_",  34, RangeFinder, backend_var_info[4]),
#endif

#if RANGEFINDER_MAX_INSTANCES > 5
    // @Group: 6_
    // @Path: AP_RangeFinder_Params.cpp
    AP_SUBGROUPINFO(params[5], "6_", 35, RangeFinder, AP_RangeFinder_Params),

    // @Group: 6_
    // @Path: AP_RangeFinder_Wasp.cpp,AP_RangeFinder_Backend_CAN.cpp
    AP_SUBGROUPVARPTR(drivers[5], "6_",  36, RangeFinder, backend_var_info[5]),
#endif

#if RANGEFINDER_MAX_INSTANCES > 6
    // @Group: 7_
    // @Path: AP_RangeFinder_Params.cpp
    AP_SUBGROUPINFO(params[6], "7_", 37, RangeFinder, AP_RangeFinder_Params),

    // @Group: 7_
    // @Path: AP_RangeFinder_Wasp.cpp,AP_RangeFinder_Backend_CAN.cpp
    AP_SUBGROUPVARPTR(drivers[6], "7_",  38, RangeFinder, backend_var_info[6]),
#endif

#if RANGEFINDER_MAX_INSTANCES > 7
    // @Group: 8_
    // @Path: AP_RangeFinder_Params.cpp
    AP_SUBGROUPINFO(params[7], "8_", 39, RangeFinder, AP_RangeFinder_Params),

    // @Group: 8_
    // @Path: AP_RangeFinder_Wasp.cpp,AP_RangeFinder_Backend_CAN.cpp
    AP_SUBGROUPVARPTR(drivers[7], "8_",  40, RangeFinder, backend_var_info[7]),
#endif

#if RANGEFINDER_MAX_INSTANCES > 8
    // @Group: 9_
    // @Path: AP_RangeFinder_Params.cpp
    AP_SUBGROUPINFO(params[8], "9_", 41, RangeFinder, AP_RangeFinder_Params),

    // @Group: 9_
    // @Path: AP_RangeFinder_Wasp.cpp,AP_RangeFinder_Backend_CAN.cpp
    AP_SUBGROUPVARPTR(drivers[8], "9_",  42, RangeFinder, backend_var_info[8]),
#endif

#if RANGEFINDER_MAX_INSTANCES > 9
    // @Group: A_
    // @Path: AP_RangeFinder_Params.cpp
    AP_SUBGROUPINFO(params[9], "A_", 43, RangeFinder, AP_RangeFinder_Params),

    // @Group: A_
    // @Path: AP_RangeFinder_Wasp.cpp,AP_RangeFinder_Backend_CAN.cpp
    AP_SUBGROUPVARPTR(drivers[9], "A_",  44, RangeFinder, backend_var_info[9]),
#endif

    AP_GROUPEND
};

const AP_Param::GroupInfo *RangeFinder::backend_var_info[RANGEFINDER_MAX_INSTANCES];

RangeFinder::RangeFinder()
{
    AP_Param::setup_object_defaults(this, var_info);

#if CONFIG_HAL_BOARD == HAL_BOARD_SITL
    if (_singleton != nullptr) {
        AP_HAL::panic("Rangefinder must be singleton");
    }
#endif // CONFIG_HAL_BOARD == HAL_BOARD_SITL
    _singleton = this;
}

/*
  initialise the RangeFinder class. We do detection of attached range
  finders here. For now we won't allow for hot-plugging of
  rangefinders.
 */
void RangeFinder::init(enum Rotation orientation_default)
{
    if (num_instances != 0) {
        // don't re-init if we've found some sensors already
        return;
    }

    // set orientation defaults
    for (uint8_t i=0; i<RANGEFINDER_MAX_INSTANCES; i++) {
        params[i].orientation.set_default(orientation_default);
    }

    for (uint8_t i=0, serial_instance = 0; i<RANGEFINDER_MAX_INSTANCES; i++) {
        // serial_instance will be increased inside detect_instance
        // if a serial driver is loaded for this instance
        WITH_SEMAPHORE(detect_sem);
        detect_instance(i, serial_instance);
        if (drivers[i] != nullptr) {
            // we loaded a driver for this instance, so it must be
            // present (although it may not be healthy). We use MAX()
            // here as a UAVCAN rangefinder may already have been
            // found
            num_instances = MAX(num_instances, i+1);
        }

        // initialise status
        state[i].status = Status::NotConnected;
        state[i].range_valid_count = 0;
        // initialize signal_quality_pct for drivers that don't handle it.
        state[i].signal_quality_pct = SIGNAL_QUALITY_UNKNOWN;
    }
}

/*
  update RangeFinder state for all instances. This should be called at
  around 10Hz by main loop
 */
void RangeFinder::update(void)
{
    for (uint8_t i=0; i<num_instances; i++) {
        if (drivers[i] != nullptr) {
            if ((Type)params[i].type.get() == Type::NONE) {
                // allow user to disable a rangefinder at runtime
                state[i].status = Status::NotConnected;
                state[i].range_valid_count = 0;
                continue;
            }
            drivers[i]->update();
        }
    }
#if HAL_LOGGING_ENABLED
    Log_RFND();
#endif
}

bool RangeFinder::_add_backend(AP_RangeFinder_Backend *backend, uint8_t instance, uint8_t serial_instance)
{
    if (!backend) {
        return false;
    }
    if (instance >= RANGEFINDER_MAX_INSTANCES) {
        AP_HAL::panic("Too many RANGERS backends");
    }
    if (drivers[instance] != nullptr) {
        // we've allocated the same instance twice
        INTERNAL_ERROR(AP_InternalError::error_t::flow_of_control);
    }
    backend->init_serial(serial_instance);
    drivers[instance] = backend;
    num_instances = MAX(num_instances, instance+1);

    return true;
}

/*
  detect if an instance of a rangefinder is connected. 
 */
void RangeFinder::detect_instance(uint8_t instance, uint8_t& serial_instance)
{
    AP_RangeFinder_Backend_Serial *(*serial_create_fn)(RangeFinder::RangeFinder_State&, AP_RangeFinder_Params&) = nullptr;

    const Type _type = (Type)params[instance].type.get();
    switch (_type) {
#if AP_RANGEFINDER_PULSEDLIGHTLRF_ENABLED
    case Type::PLI2C:
    case Type::PLI2CV3:
    case Type::PLI2CV3HP:
        FOREACH_I2C(i) {
            if (_add_backend(AP_RangeFinder_PulsedLightLRF::detect(i, state[instance], params[instance], _type),
                             instance)) {
                break;
            }
        }
        break;
#endif
#if AP_RANGEFINDER_MAXSONARI2CXL_ENABLED
    case Type::MBI2C: {
        uint8_t addr = AP_RANGE_FINDER_MAXSONARI2CXL_DEFAULT_ADDR;
        if (params[instance].address != 0) {
            addr = params[instance].address;
        }
        FOREACH_I2C(i) {
            if (_add_backend(AP_RangeFinder_MaxsonarI2CXL::detect(state[instance], params[instance],
                                                                  hal.i2c_mgr->get_device(i, addr)),
                             instance)) {
                break;
            }
        }
        break;
    }
#endif
#if AP_RANGEFINDER_LWI2C_ENABLED
    case Type::LWI2C:
        if (params[instance].address) {
            // the LW20 needs a long time to boot up, so we delay 1.5s here
#ifndef HAL_BUILD_AP_PERIPH
            if (!hal.util->was_watchdog_armed()) {
                hal.scheduler->delay(1500);
            }
#endif
#ifdef HAL_RANGEFINDER_LIGHTWARE_I2C_BUS
            _add_backend(AP_RangeFinder_LightWareI2C::detect(state[instance], params[instance],
                                                             hal.i2c_mgr->get_device(HAL_RANGEFINDER_LIGHTWARE_I2C_BUS, params[instance].address)),
                                                             instance);
#else
            FOREACH_I2C(i) {
                if (_add_backend(AP_RangeFinder_LightWareI2C::detect(state[instance], params[instance],
                                                                     hal.i2c_mgr->get_device(i, params[instance].address)),
                                 instance)) {
                    break;
                }
            }
#endif
        }
        break;
#endif  // AP_RANGEFINDER_LWI2C_ENABLED
#if AP_RANGEFINDER_TRI2C_ENABLED
    case Type::TRI2C:
        if (params[instance].address) {
            FOREACH_I2C(i) {
                if (_add_backend(AP_RangeFinder_TeraRangerI2C::detect(state[instance], params[instance],
                                                                      hal.i2c_mgr->get_device(i, params[instance].address)),
                                 instance)) {
                    break;
                }
            }
        }
        break;
#endif
    case Type::VL53L0X:
    case Type::VL53L1X_Short:
            FOREACH_I2C(i) {
#if AP_RANGEFINDER_VL53L0X_ENABLED
                if (_add_backend(AP_RangeFinder_VL