old = 12;
            if (_last_options & OPTION_NOFIFO) {
                threshold = 8;
            }
#endif
            if (_total_written > used && _total_written - used > threshold) {
                _flow_control = FLOW_CONTROL_ENABLE;
                return;
            }
        }
        if (AP_HAL::micros() - _first_write_started_us > 500*1000UL) {
            // it doesn't look like hw flow control is working
            DEV_PRINTF("disabling flow control on serial %u\n", sdef.get_index());
            set_flow_control(FLOW_CONTROL_DISABLE);
        }
    }
}
#pragma GCC diagnostic pop

/*
  setup for half duplex tramsmit. To cope with uarts that have level
  shifters and pullups we need to play a trick where we temporarily
  disable half-duplex while transmitting. That disables the receive
  part of the uart on the pin which allows the transmit side to
  correctly setup the idle voltage before the transmit starts.
 */
void UARTDriver::half_duplex_setup_tx(void)
{
    if (!hd_tx_active) {
        chEvtGetAndClearFlags(&hd_listener);
        // half-duplex transmission is done when both the output is empty and the transmission is ended
        // if we only wait for empty output the line can be setup for receive too soon losing data bits
        hd_tx_active = CHN_TRANSMISSION_END | CHN_OUTPUT_EMPTY;
        SerialDriver *sd = (SerialDriver*)(sdef.serial);
        sdStop(sd);
        sercfg.cr3 &= ~USART_CR3_HDSEL;
        sdStart(sd, &sercfg);
    }
}

/*
  push any pending bytes to/from the serial port. This is called at
  1kHz in the timer thread. Doing it this way reduces the system call
  overhead in the main task enormously.
 */
void UARTDriver::_rx_timer_tick(void)
{
    if (!_rx_initialised || half_duplex) {
        return;
    }

    _in_rx_timer = true;

#if HAL_UART_STATS_ENABLED && CH_CFG_USE_EVENTS == TRUE
    if (!sdef.is_usb) {
        const auto err_flags = chEvtGetAndClearFlags(&err_listener);
        // count the number of errors
        if (err_flags & SD_FRAMING_ERROR) {
            _rx_stats_framing_errors++;
        }
        if (err_flags & SD_OVERRUN_ERROR) {
            _rx_stats_overrun_errors++;
        }
        if (err_flags & SD_NOISE_ERROR) {
            _rx_stats_noise_errors++;
        }
    }
#endif

#ifndef HAL_UART_NODMA
    if (rx_dma_enabled && rxdma) {
        chSysLock();
        //Check if DMA is enabled
        //if not, it might be because the DMA interrupt was silenced
        //let's handle that here so that we can continue receiving
#if defined(STM32F3) || defined(STM32G4) || defined(STM32L4) || defined(STM32L4PLUS)
        bool enabled = (rxdma->channel->CCR & STM32_DMA_CR_EN);
#else
        bool enabled = (rxdma->stream->CR & STM32_DMA_CR_EN);
#endif
        if (!enabled) {
            uint8_t len = RX_BOUNCE_BUFSIZE - dmaStreamGetTransactionSize(rxdma);
            if (len != 0) {
                _readbuf.write(rx_bounce_buf[rx_bounce_idx], len);
                _rx_stats_bytes += len;

                receive_timestamp_update();
                if (_rts_is_active) {
                    update_rts_line();
                }
            }
            // DMA disabled by idle interrupt never got a chance to be handled
            // we will enable it here
            dmaStreamDisable(rxdma);
            dma_rx_enable();
        }
        chSysUnlock();
    }
#endif

    // don't try IO on a disconnected USB port
    if (sdef.is_usb) {
#ifdef HAVE_USB_SERIAL
        if (((SerialUSBDriver*)sdef.serial)->config->usbp->state != USB_ACTIVE) {
            _in_rx_timer = false;
            return;
        }
#endif
    }
    if (sdef.is_usb) {
#ifdef HAVE_USB_SERIAL
        ((GPIO *)hal.gpio)->set_usb_connected();
#endif
    }
#ifndef HAL_UART_NODMA
    if (!rx_dma_enabled)
#endif
    {
        read_bytes_NODMA();
    }
    if (_wait.thread_ctx && _readbuf.available() >= _wait.n) {
        chEvtSignal(_wait.thread_ctx, EVT_DATA);
    }
#if HAL_FORWARD_OTG2_SERIAL
    if (sdef.get_index() == HAL_FORWARD_OTG2_SERIAL) {
        fwd_otg2_serial();
    }
#endif
    _in_rx_timer = false;
}

// forward data from a serial port to the USB
// Used for connecting to Secondary Autopilot to communicate over
// USB, for firmware updates, configuration etc
#if HAL_FORWARD_OTG2_SERIAL
void UARTDriver::fwd_otg2_serial()
{
    if (lock_read_key == HAL_FORWARD_OTG2_SERIAL_LOCK_KEY &&
        lock_write_key == HAL_FORWARD_OTG2_SERIAL_LOCK_KEY &&
        SDU2.config->usbp->state == USB_ACTIVE &&
        hal.analogin->power_status_flags() & MAV_POWER_STATUS_USB_CONNECTED) {
        // forward read data to USB
        if (_readbuf.available() > 0) {
            ByteBuffer::IoVec vec[2];
            const auto n_vec = _readbuf.peekiovec(vec, _readbuf.available());
            for (int i = 0; i < n_vec; i++) {
                int ret = 0;
                ret = chnWriteTimeout(&SDU2, vec[i].data, vec[i].len, TIME_IMMEDIATE);
                if (ret < 0) {
                    break;
                }
                _readbuf.advance(ret);
                /* We wrote less than we asked for, stop */
                if ((unsigned)ret != vec[i].len) {
                    break;
                }
            }
        }
        {
            // Do the same for write data
            WITH_SEMAPHORE(_write_mutex);
            ByteBuffer::IoVec vec[2];
            const auto n_vec = _writebuf.reserve(vec, _writebuf.space());
            for (int i = 0; i < n_vec; i++) {
                int ret = 0;
                ret = chnReadTimeout(&SDU2, vec[i].data, vec[i].len, TIME_IMMEDIATE);
                if (ret < 0) {
                    break;
                }
                _writebuf.commit(ret);
                /* We read less than we asked for, stop */
                if ((unsigned)ret != vec[i].len) {
                    break;
                }
            }
            if (_writebuf.available() > 0) {
                // we have data to write, so trigger the write thread
                chEvtSignal(uart_thread_ctx, EVT_TRANSMIT_DATA_READY);
            }
        }
    } else if (hal.analogin->power_status_flags() & MAV_POWER_STATUS_USB_CONNECTED) {
        // lock the read and write keys
        lock_port(HAL_FORWARD_OTG2_SERIAL_LOCK_KEY, HAL_FORWARD_OTG2_SERIAL_LOCK_KEY);
        // flush the write and read buffer
        _readbuf.clear();
        _writebuf.clear();
    } else if (lock_read_key == HAL_FORWARD_OTG2_SERIAL_LOCK_KEY &&
            lock_write_key == HAL_FORWARD_OTG2_SERIAL_LOCK_KEY) {
        _readbuf.clear();
        _writebuf.clear();
        lock_port(0,0); // unlock the port
    }
}
#endif

// regular serial read
void UARTDriver::read_bytes_NODMA()
{
    // try to fill the read buffer
    ByteBuffer::IoVec vec[2];

    const auto n_vec = _readbuf.reserve(vec, _readbuf.space());
    for (int i = 0; i < n_vec; i++) {
        int ret = 0;
        //Do a non-blocking read
        if (sdef.is_usb) {
#ifdef HAVE_USB_SERIAL
            ret = chnReadTimeout((SerialUSBDriver*)sdef.serial, vec[i].data, vec[i].len, TIME_IMMEDIATE);
#endif
        } else {
#if HAL_USE_SERIAL == TRUE
            ret = chnReadTimeout((SerialDriver*)sdef.serial, vec[i].data, vec[i].len, TIME_IMMEDIATE);
#endif
        }
        if (ret < 0) {
            break;
        }
#if CH_CFG_USE_EVENTS == TRUE
        if (parity_enabled && ((chEvtGetAndClearFlags(&ev_listener) & SD_PARITY_ERROR))) {
            // discard bytes with parity error
            ret = -1;
        }
#endif
        if (!hd_tx_active) {
            _readbuf.commit((unsigned)ret);
            _rx_stats_bytes += ret;
            receive_timestamp_update();
        }

        /* stop reading as we read less than we asked for */
        if ((unsigned)ret < vec[i].len) {
            break;
        }
    }
}

/*
  push any pending bytes to/from the serial port. This is called at
  1kHz in the timer thread. Doing it this way reduces the system call
  overhead in the main task enormously.
 */
void UARTDriver::_tx_timer_tick(void)
{
    if (!_tx_initialised) {
        return;
    }

    _in_tx_timer = true;

    if (hd_tx_active) {
        hd_tx_active &= ~chEvtGetAndClearFlags(&hd_listener);
        if (!hd_tx_active) {
            /*
                half-duplex transmit has finished. We now re-enable the
                HDSEL bit for receive
            */
            SerialDriver *sd = (SerialDriver*)(sdef.serial);
            sdStop(sd);
            sercfg.cr3 |= USART_CR3_HDSEL;
            sdStart(sd, &sercfg);
        }
    }

    // don't try IO on a disconnected USB port
    if (sdef.is_usb) {
#ifdef HAVE_USB_SERIAL
        if (((SerialUSBDriver*)sdef.serial)->config->usbp->state != USB_ACTIVE) {
            _in_tx_timer = false;
            return;
        }
#endif
    }
    if (sdef.is_usb) {
#ifdef HAVE_USB_SERIAL
        ((GPIO *)hal.gpio)->set_usb_connected();
#endif
    }

    // half duplex we do reads in the write thread
    if (half_duplex) {
        _in_rx_timer = true;
        read_bytes_NODMA();
        if (_wait.thread_ctx && _readbuf.available() >= _wait.n) {
            chEvtSignal(_wait.thread_ctx, EVT_DATA);
        }
        _in_rx_timer = false;
    }

    // now do the write
    write_pending_bytes();

    _in_tx_timer = false;
}

/*
  change flow control mode for port
 */
void UARTDriver::set_flow_control(enum flow_control flowcontrol)
{
    if (sdef.is_usb) {
        // no hw flow control available
        return;
    }
#if HAL_USE_SERIAL == TRUE
    SerialDriver *sd = (SerialDriver*)(sdef.serial);
    _flow_control = (arts_line == 0) ? FLOW_CONTROL_DISABLE : flowcontrol;
    if (!is_initialized()) {
        // not ready yet, we just set variable for when we call begin
        return;
    }
    switch (_flow_control) {

    case FLOW_CONTROL_DISABLE:
        // force RTS active when flow disabled
        if (arts_line != 0) {
            palSetLineMode(arts_line, 1);
            palClearLine(arts_line);
        }
        _rts_is_active = true;
        // disable hardware CTS support
        chSysLock();
        if ((sd->usart->CR3 & (USART_CR3_CTSE | USART_CR3_RTSE)) != 0) {
            sd->usart->CR1 &= ~USART_CR1_UE;
            sd->usart->CR3 &= ~(USART_CR3_CTSE | USART_CR3_RTSE);
            sd->usart->CR1 |= USART_CR1_UE;
        }
        chSysUnlock();
        break;

    case FLOW_CONTROL_AUTO:
        // reset flow control auto state machine
        _first_write_started_us = 0;
        _last_write_completed_us = 0;
        FALLTHROUGH;

    case FLOW_CONTROL_ENABLE:
        // we do RTS in software as STM32 hardware RTS support toggles
        // the pin for every byte which loses a lot of bandwidth
        palSetLineMode(arts_line, 1);
        palClearLine(arts_line);
        _rts_is_active = true;
        // enable hardware CTS support, disable RTS support as we do that in software
        chSysLock();
        if ((sd->usart->CR3 & (USART_CR3_CTSE | USART_CR3_RTSE)) != USART_CR3_CTSE) {
            // CTSE and RTSE can only be written when uart is disabled
            sd->usart->CR1 &= ~USART_CR1_UE;
            sd->usart->CR3 |= USART_CR3_CTSE;
            sd->usart->CR3 &= ~USART_CR3_RTSE;
            sd->usart->CR1 |= USART_CR1_UE;
        }
        chSysUnlock();
        break;

    case FLOW_CONTROL_RTS_DE:
        // Driver Enable, RTS pin high during transmit
        // If posible enable in hardware
#if defined(USART_CR3_DEM)
        if (sdef.rts_alternative_function != UINT8_MAX) {
            // Hand over control of RTS pin to the UART driver
            palSetLineMode(arts_line, PAL_MODE_ALTERNATE(sdef.rts_alternative_function));

            // Enable in driver, if not already set
            chSysLock();
            if ((sd->usart->CR3 & USART_CR3_DEM) != USART_CR3_DEM) {
                // Disable UART, set bit and then re-enable
                sd->usart->CR1 &= ~USART_CR1_UE;
                sd->usart->CR3 |= USART_CR3_DEM;
                sd->usart->CR1 |= USART_CR1_UE;
            }
            chSysUnlock();
        } else
#endif
        {
            // No hardware support for DEM mode or
            // No alternative function, RTS GPIO pin is not a conected to the UART peripheral
            // This is typicaly fine becaues we do software flow control.
            set_flow_control(FLOW_CONTROL_DISABLE);
        }
        break;
    }
#endif // HAL_USE_SERIAL
}

/*
  software update of rts line. We don't use the HW support for RTS as
  it has no hysteresis, so it ends up toggling RTS on every byte
 */
__RAMFUNC__ void UARTDriver::update_rts_line(void)
{
    if (arts_line == 0 || !flow_control_enabled(_flow_control)) {
        return;
    }
    uint16_t space = _readbuf.space();
    if (_rts_is_active && space < _rts_threshold) {
        _rts_is_active = false;
        palSetLine(arts_line);
    } else if (!_rts_is_active && space > _rts_threshold+16) {
        _rts_is_active = true;
        palClearLine(arts_line);
    }
}

/*
   setup unbuffered writes for lower latency
 */
bool UARTDriver::set_unbuffered_writes(bool on)
{
    unbuffered_writes = on;
    chEvtSignal(uart_thread_ctx, EVT_TRANSMIT_UNBUFFERED);
    return true;
}

/*
  setup parity
 */
void UARTDriver::configure_parity(uint8_t v)
{
    if (sdef.is_usb) {
        // not possible
        return;
    }
    UARTDriver::parity = v;
#if HAL_USE_SERIAL == TRUE
    // stop and start to take effect
    sdStop((SerialDriver*)sdef.serial);

#ifdef USART_CR1_M0
    // cope with F3 and F7 where there are 2 bits in CR1_M
    const uint32_t cr1_m0 = USART_CR1_M0;
#else
    const uint32_t cr1_m0 = USART_CR1_M;
#endif

    switch (v) {
    case 0:
        // no parity
        sercfg.cr1 &= ~(USART_CR1_PCE | USART_CR1_PS | USART_CR1_M);
        break;
    case 1:
        // odd parity
        // setting USART_CR1_M ensures extra bit is used as parity
        // not last bit of data
        sercfg.cr1 |= cr1_m0 | USART_CR1_PCE;
        sercfg.cr1 |= USART_CR1_PS;
        break;
    case 2:
        // even parity
        sercfg.cr1 |= cr1_m0 | USART_CR1_PCE;
        sercfg.cr1 &= ~USART_CR1_PS;
        break;
    }

    sdStart((SerialDriver*)sdef.serial, &sercfg);

#if CH_CFG_USE_EVENTS == TRUE
    if (parity_enabled) {
        chEvtUnregister(chnGetEventSource((SerialDriver*)sdef.serial), &ev_listener);
    }
    parity_enabled = (v != 0);
    if (parity_enabled) {
        chEvtRegisterMaskWithFlags(chnGetEventSource((SerialDriver*)sdef.serial),
                                   &ev_listener,
                                   EVT_PARITY,
                                   SD_PARITY_ERROR);
    }
#endif

#ifndef HAL_UART_NODMA
    if (rx_dma_enabled) {
        // Configure serial driver to skip handling RX packets
        // because we will handle them via DMA
        ((SerialDriver*)sdef.serial)->usart->CR1 &= ~USART_CR1_RXNEIE;
    }
#endif
#endif // HAL_USE_SERIAL
}

/*
  set stop bits
 */
void UARTDriver::set_stop_bits(int n)
{
    if (sdef.is_usb) {
        // not possible
        return;
    }
#if HAL_USE_SERIAL
    // stop and start to take effect
    sdStop((SerialDriver*)sdef.serial);

    switch (n) {
    case 1:
        _cr2_options &= ~USART_CR2_STOP2_BITS;
        _cr2_options |= USART_CR2_STOP1_BITS;
        break;
    case 2:
        _cr2_options &= ~USART_CR2_STOP1_BITS;
        _cr2_options |= USART_CR2_STOP2_BITS;
        break;
    }
    sercfg.cr2 = _cr2_options;

    sdStart((SerialDriver*)sdef.serial, &sercfg);
#ifndef HAL_UART_NODMA
    if (rx_dma_enabled) {
        //Configure serial driver to skip handling RX packets
        //because we will handle them via DMA
        ((SerialDriver*)sdef.serial)->usart->CR1 &= ~USART_CR1_RXNEIE;
    }
#endif
#endif // HAL_USE_SERIAL
}


// record timestamp of new incoming data
__RAMFUNC__ void UARTDriver::receive_timestamp_update(void)
{
    _receive_timestamp[_receive_timestamp_idx^1] = AP_HAL::micros64();
    _receive_timestamp_idx ^= 1;
}

/*
  return timestamp estimate in microseconds for when the start of
  a nbytes packet arrived on the uart. This should be treated as a
  time constraint, not an exact time. It is guaranteed that the
  packet did not start being received after this time, but it
  could have been in a system buffer before the returned time.

  This takes account of the baudrate of the link. For transports
  that have no baudrate (such as USB) the time estimate may be
  less accurate.

  A return value of zero means the HAL does not support this API
*/
uint64_t UARTDriver::receive_time_constraint_us(uint16_t nbytes)
{
    uint64_t last_receive_us = _receive_timestamp[_receive_timestamp_idx];
    if (_baudrate > 0 && !sdef.is_usb) {
        // assume 10 bits per byte. For USB we assume zero transport delay
        uint32_t transport_time_us = (1000000UL * 10UL / _baudrate) * (nbytes + available());
        last_receive_us -= transport_time_us;
    }
    return last_receive_us;
}

/*
 set user specified PULLUP/PULLDOWN options from SERIALn_OPTIONS
*/
void UARTDriver::set_pushpull(uint16_t options)
{
#if HAL_USE_SERIAL == TRUE && !defined(STM32F1)
    if ((options & OPTION_PULLDOWN_RX) && arx_line) {
        palLineSetPushPull(arx_line, PAL_PUSHPULL_PULLDOWN);
    }
    if ((options & OPTION_PULLDOWN_TX) && atx_line) {
        palLineSetPushPull(atx_line, PAL_PUSHPULL_PULLDOWN);
    }
    if ((options & OPTION_PULLUP_RX) && arx_line) {
        palLineSetPushPull(arx_line, PAL_PUSHPULL_PULLUP);
    }
    if ((options & OPTION_PULLUP_TX) && atx_line) {
        palLineSetPushPull(atx_line, PAL_PUSHPULL_PULLUP);
    }
#endif
}

// set optional features, return true on success
bool UARTDriver::set_options(uint16_t options)
{
    if (sdef.is_usb) {
        // no options allowed on USB
        return (options == 0);
    }
    bool ret = true;

    _last_options = options;

#if HAL_USE_SERIAL == TRUE
    SerialDriver *sd = (SerialDriver*)(sdef.serial);
    uint32_t cr2 = sd->usart->CR2;
    uint32_t cr3 = sd->usart->CR3;
    bool was_enabled = (sd->usart->CR1 & USART_CR1_UE);

    /*
      allow for RX, TX, RTS and CTS pins to be remapped via BRD_ALT_CONFIG
     */
    arx_line = GPIO::resolve_alt_config(sdef.rx_line, PERIPH_TYPE::UART_RX, sdef.instance);
    atx_line = GPIO::resolve_alt_config(sdef.tx_line, PERIPH_TYPE::UART_TX, sdef.instance);
    arts_line = GPIO::resolve_alt_config(sdef.rts_line, PERIPH_TYPE::OTHER, sdef.instance);
    acts_line = GPIO::resolve_alt_config(sdef.cts_line, PERIPH_TYPE::OTHER, sdef.instance);

    // Check flow control, might have to disable if RTS line is gone
    set_flow_control(_flow_control);

#if defined(STM32F7) || defined(STM32H7) || defined(STM32F3) || defined(STM32G4) || defined(STM32L4) || defined(STM32L4PLUS)
    // F7 has built-in support for inversion in all uarts
    ioline_t rx_line = (options & OPTION_SWAP)?atx_line:arx_line;
    ioline_t tx_line = (options & OPTION_SWAP)?arx_line:atx_line;

    // if we are half-duplex then treat either inversion option as
    // both being enabled. This is easier to understand for users, who
    // can be confused as to which pin is the one that needs inversion
    if ((options & OPTION_HDPLEX) && (options & (OPTION_TXINV|OPTION_RXINV)) != 0) {
        options |= OPTION_TXINV|OPTION_RXINV;
    }

    if (options & OPTION_RXINV) {
        cr2 |= USART_CR2_RXINV;
        _cr2_options |= USART_CR2_RXINV;
        if (rx_line != 0) {
            palLineSetPushPull(rx_line, PAL_PUSHPULL_PULLDOWN);
        }
    } else {
        cr2 &= ~USART_CR2_RXINV;
        _cr2_options &= ~USART_CR2_RXINV;
        if (rx_line != 0) {
            palLineSetPushPull(rx_line, PAL_PUSHPULL_PULLUP);
        }
    }
    if (options & OPTION_TXINV) {
        cr2 |= USART_CR2_TXINV;
        _cr2_options |= USART_CR2_TXINV;
        if (tx_line != 0) {
            palLineSetPushPull(tx_line, PAL_PUSHPULL_PULLDOWN);
        }
    } else {
        cr2 &= ~USART_CR2_TXINV;
        _cr2_options &= ~USART_CR2_TXINV;
        if (tx_line != 0) {
            palLineSetPushPull(tx_line, PAL_PUSHPULL_PULLUP);
        }
    }
    // F7 can also support swapping RX and TX pins
    if (options & OPTION_SWAP) {
        cr2 |= USART_CR2_SWAP;
        _cr2_options |= USART_CR2_SWAP;
    } else {
        cr2 &= ~USART_CR2_SWAP;
        _cr2_options &= ~USART_CR2_SWAP;
    }
#elif defined(STM32F4) // STM32F4
    // F4 can do inversion by GPIO if enabled in hwdef.dat, using
    // TXINV and RXINV options
    if (options & OPTION_RXINV) {
        if (sdef.rxinv_gpio >= 0) {
            hal.gpio->write(sdef.rxinv_gpio, sdef.rxinv_polarity);
            if (arx_line != 0) {
                palLineSetPushPull(arx_line, PAL_PUSHPULL_PULLDOWN);
            }
        } else {
            ret = false;
        }
    } else if (sdef.rxinv_gpio >= 0) {
        hal.gpio->write(sdef.rxinv_gpio, !sdef.rxinv_polarity);
        if (arx_line != 0) {
            palLineSetPushPull(arx_line, PAL_PUSHPULL_PULLUP);
        }
    }
    if (options & OPTION_TXINV) {
        if (sdef.txinv_gpio >= 0) {
            hal.gpio->write(sdef.txinv_gpio, sdef.txinv_polarity);
            if (atx_line != 0) {
                palLineSetPushPull(atx_line, PAL_PUSHPULL_PULLDOWN);
            }
        } else {
            ret = false;
        }
    } else if (sdef.txinv_gpio >= 0) {
        hal.gpio->write(sdef.txinv_gpio, !sdef.txinv_polarity);
        if (atx_line != 0) {
            palLineSetPushPull(atx_line, PAL_PUSHPULL_PULLUP);
        }
    }
    if (options & OPTION_SWAP) {
        ret = false;
    }
#endif // STM32xx

    // both F4 and F7 can do half-duplex
    if (options & OPTION_HDPLEX) {
        cr3 |= USART_CR3_HDSEL;
        _cr3_options |= USART_CR3_HDSEL;
        if (!half_duplex) {
            chEvtRegisterMaskWithFlags(chnGetEventSource((SerialDriver*)sdef.serial),
                                       &hd_listener,
                                       EVT_TRANSMIT_END,
                                       CHN_OUTPUT_EMPTY | CHN_TRANSMISSION_END);
            half_duplex = true;
        }
#ifndef HAL_UART_NODMA
        if (rx_dma_enabled && rxdma) {
            dmaStreamDisable(rxdma);
        }
#endif
        // force DMA off when using half-duplex as the timing may affect other devices
        // sharing the DMA channel
        rx_dma_enabled = tx_dma_enabled = false;
    } else {
        cr3 &= ~USART_CR3_HDSEL;
        _cr3_options &= ~USART_CR3_HDSEL;
    }

    set_pushpull(options);

    if (sd->usart->CR2 == cr2 &&
        sd->usart->CR3 == cr3) {
        // no change
        return ret;
    }

    if (was_enabled) {
        sd->usart->CR1 &= ~USART_CR1_UE;
    }

    sd->usart->CR2 = cr2;
    sd->usart->CR3 = cr3;

    if (was_enabled) {
        sd->usart->CR1 |= USART_CR1_UE;
    }
#endif // HAL_USE_SERIAL == TRUE
    return ret;
}

// get optional features
uint16_t UARTDriver::get_options(void) const
{
    return _last_options;
}

#if HAL_UART_STATS_ENABLED
// request information on uart I/O for @SYS/uarts.txt for this uart
void UARTDriver::uart_info(ExpandingString &str, StatsTracker &stats, const uint32_t dt_ms)
{
    const uint32_t tx_bytes = stats.tx.update(_tx_stats_bytes);
    const uint32_t rx_bytes = stats.rx.update(_rx_stats_bytes);

    if (sdef.is_usb) {
        str.printf("OTG%u  ", unsigned(sdef.instance));
    } else {
        str.printf("UART%u ", unsigned(sdef.instance));
    }
    str.printf("TX%c=%8u RX%c=%8u TXBD=%6u RXBD=%6u"
#if CH_CFG_USE_EVENTS == TRUE
                " FE=%lu OE=%lu NE=%lu"
#endif
                " FlowCtrl=%u\n",
               tx_dma_enabled ? '*' : ' ',
               unsigned(tx_bytes),
               rx_dma_enabled ? '*' : ' ',
               unsigned(rx_bytes),
               unsigned((tx_bytes * 10000) / dt_ms),
               unsigned((rx_bytes * 10000) / dt_ms),
#if CH_CFG_USE_EVENTS == TRUE
               _rx_stats_framing_errors,
               _rx_stats_overrun_errors,
               _rx_stats_noise_errors,
#endif
               _flow_control);
}
#endif

/*
  software control of the CTS pin if available. Return false if
  not available
*/
bool UARTDriver::set_CTS_pin(bool high)
{
    if (_flow_control != FLOW_CONTROL_DISABLE) {
        // CTS pin is being used
        return false;
    }
    if (acts_line == 0) {
        // we don't have a CTS pin on this UART
        return false;
    }
    palSetLineMode(acts_line, 1);
    palWriteLine(acts_line, high?1:0);
    return true;
}

/*
  software control of the RTS pin if available. Return false if
  not available
*/
bool UARTDriver::set_RTS_pin(bool high)
{
    if (_flow_control != FLOW_CONTROL_DISABLE) {
        // RTS pin is being used
        return false;
    }
    if (arts_line == 0) {
        // we don't have a RTS pin on this UART
        return false;
    }
    palSetLineMode(arts_line, 1);
    palWriteLine(arts_line, high?1:0);
    return true;
}

#if HAL_USE_SERIAL_USB == TRUE
/*
  initialise the USB bus, called from both UARTDriver and stdio for startup debug
  This can be called before the hal is initialised so must not call any hal functions
 */
void usb_initialise(void)
{
    static bool initialised;
    if (initialised) {
        return;
    }
    initialised = true;
    sduObjectInit(&SDU1);
    sduStart(&SDU1, &serusbcfg1);
#if HAL_HAVE_DUAL_USB_CDC
    sduObjectInit(&SDU2);
    sduStart(&SDU2, &serusbcfg2);
#endif
    /*
     * Activates the USB driver and then the USB bus pull-up on D+.
     * Note, a delay is inserted in order to not have to disconnect the cable
     * after a reset.
     */
    usbDisconnectBus(serusbcfg1.usbp);
    chThdSleep(chTimeUS2I(1500));
    usbStart(serusbcfg1.usbp, &usbcfg);
    usbConnectBus(serusbcfg1.usbp);
}
#endif

// disable TX/RX pins for unusued uart
void UARTDriver::disable_rxtx(void) const
{
    if (arx_line) {
        palSetLineMode(arx_line, PAL_MODE_INPUT);
    }
    if (atx_line) {
        palSetLineMode(atx_line, PAL_MODE_INPUT);
    }
}

#endif //CONFIG_HAL_BOARD == HAL_BOARD_CHIBIOS
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     /*
 * This file is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This file is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Code by Andrew Tridgell and Siddharth Bharat Purohit
 */
#pragma once

#include <AP_HAL/utility/RingBuffer.h>

#include "AP_HAL_ChibiOS.h"
#include "shared_dma.h"
#include "Semaphores.h"

#define RX_BOUNCE_BUFSIZE 64U
#define TX_BOUNCE_BUFSIZE 64U

// enough for serial0 to serial9, plus IOMCU
#define UART_MAX_DRIVERS 11

#ifndef HAL_HAVE_LOW_NOISE_UART
#define HAL_HAVE_LOW_NOISE_UART 0
#endif

class ChibiOS::UARTDriver : public AP_HAL::UARTDriver {
public:
    UARTDriver(uint8_t serial_num);

    /* Do not allow copies */
    CLASS_NO_COPY(UARTDriver);

    bool is_initialized() override;
    bool tx_pending() override;
    uint32_t get_usb_baud() const override;
    uint8_t get_usb_parity() const override;

    // disable TX/RX pins for unusued uart
    void disable_rxtx(void) const override;
    
    uint32_t txspace() override;
    void _rx_timer_tick(void);
    void _tx_timer_tick(void);
#if HAL_FORWARD_OTG2_SERIAL
    void fwd_otg2_serial(void);
#endif

    // control optional features
    bool set_options(uint16_t options) override;
    uint16_t get_options(void) const override;

    struct SerialDef {
        BaseSequentialStream* serial;
        uint8_t instance;
        bool is_usb;
#ifndef HAL_UART_NODMA
        bool dma_rx;
        uint8_t dma_rx_stream_id;
        uint32_t dma_rx_channel_id;
        bool dma_tx;
        uint8_t dma_tx_stream_id;
        uint32_t dma_tx_channel_id;
#endif
        ioline_t tx_line;
        ioline_t rx_line;
        ioline_t rts_line;
        ioline_t cts_line;
        int8_t rxinv_gpio;
        uint8_t rxinv_polarity;
        int8_t txinv_gpio;
        uint8_t txinv_polarity;
        uint8_t endpoint_id;
        uint8_t rts_alternative_function;
        uint8_t get_index(void) const {
            return uint8_t(this - &_serial_tab[0]);
        }

#if HAL_HAVE_LOW_NOISE_UART
        bool low_noise_line;
#endif
    };

    bool wait_timeout(uint16_t n, uint32_t timeout_ms) override;

    void set_flow_control(enum flow_control flow_control) override;
    enum flow_control get_flow_control(void) override { return _flow_control; }

    // allow for low latency writes
    bool set_unbuffered_writes(bool on) override;

    void configure_parity(uint8_t v) override;
    void set_stop_bits(int n) override;

    /*
      software control of the CTS/RTS pins if available. Return false if
      not available
     */
    bool set_RTS_pin(bool high) override;
    bool set_CTS_pin(bool high) override;

    /*
      return timestamp estimate in microseconds for when the start of
      a nbytes packet arrived on the uart. This should be treated as a
      time constraint, not an exact time. It is guaranteed that the
      packet did not start being received after this time, but it
      could have been in a system buffer before the returned time.

      This takes account of the baudrate of the link. For transports
      that have no baudrate (such as USB) the time estimate may be
      less accurate.

      A return value of zero means the HAL does not support this API
     */
    uint64_t receive_time_constraint_us(uint16_t nbytes) override;

    uint32_t bw_in_bytes_per_second() const override {
        if (sdef.is_usb) {
            return 200*1024;
        }
        return _baudrate/10;
    }

    uint32_t get_baud_rate() const override { return _baudrate; }

#if HAL_UART_STATS_ENABLED
    // request information on uart I/O for one uart
    void uart_info(ExpandingString &str, StatsTracker &stats, const uint32_t dt_ms) override;
#endif

    /*
      return true if this UART has DMA enabled on both RX and TX
     */
    bool is_dma_enabled() const override { return rx_dma_enabled && tx_dma_enabled; }

private:
    const SerialDef &sdef;
    bool rx_dma_enabled;
    bool tx_dma_enabled;

    /*
      copy of rx_line, tx_line, rts_line and cts_line with alternative configs resolved
     */
    ioline_t atx_line;
    ioline_t arx_line;
    ioline_t arts_line;
    ioline_t acts_line;

    // thread used for all UARTs
    static thread_t* volatile uart_rx_thread_ctx;

    // table to find UARTDrivers from serial number, used for event handling
    static UARTDriver *serial_drivers[UART_MAX_DRIVERS];
    
    // thread used for writing and reading
    thread_t* volatile uart_thread_ctx;
    char uart_thread_name[6];

    // index into serial_drivers table
    uint8_t serial_num;

    uint32_t _baudrate;
#if HAL_USE_SERIAL == TRUE
    SerialConfig sercfg;
#endif
    const thread_t* _uart_owner_thd;

    struct {
        // thread waiting for data
        thread_t *thread_ctx;
        // number of bytes needed
        uint16_t n;
    } _wait;

    // we use in-task ring buffers to reduce the system call cost
    // of ::read() and ::write() in the main loop
#ifndef HAL_UART_NODMA
    volatile uint8_t rx_bounce_idx;
    uint8_t *rx_bounce_buf[2];
    uint8_t *tx_bounce_buf;
    uint16_t contention_counter;
#endif
    ByteBuffer _readbuf{0};
    ByteBuffer _writebuf{0};
    uint32_t _rts_threshold;
    HAL_Semaphore _write_mutex;
#ifndef HAL_UART_NODMA
    const stm32_dma_stream_t* rxdma;
    const stm32_dma_stream_t* txdma;
#endif
    volatile bool _in_rx_timer;
    volatile bool _in_tx_timer;
    volatile bool _rx_initialised;
    volatile bool _tx_initialised;
    volatile bool _device_initialised;
#ifndef HAL_UART_NODMA
    Shared_DMA *dma_handle;
#endif
    static const SerialDef _serial_tab[];

    // timestamp for receiving data on the UART, avoiding a lock
    uint64_t _receive_timestamp[2];
    uint8_t _receive_timestamp_idx;

    // handling of flow control
    enum flow_control _flow_control = FLOW_CONTROL_DISABLE;
    bool _rts_is_active;
    uint32_t _last_write_completed_us;
    uint32_t _first_write_started_us;
    uint32_t _total_written;

    // statistics
    uint32_t _tx_stats_bytes;
    uint32_t _rx_stats_bytes;

    // we remember config options from set_options to apply on sdStart()
    uint32_t _cr1_options;
    uint32_t _cr2_options;
    uint32_t _cr3_options;
    uint16_t _last_options;

    // half duplex control. After writing we throw away bytes for 4 byte widths to
    // prevent reading our own bytes back
#if CH_CFG_USE_EVENTS == TRUE
    bool half_duplex;
    event_listener_t hd_listener;
    eventflags_t hd_tx_active;
    void half_duplex_setup_tx(void);
#endif

    // set to true for unbuffered writes (low latency writes)
    bool unbuffered_writes;

#if CH_CFG_USE_EVENTS == TRUE
    // listener for parity error events
    event_listener_t ev_listener;
    bool parity_enabled;
#endif

#ifndef HAL_UART_NODMA
    static void rx_irq_cb(void* sd);
#endif
    static void rxbuff_full_irq(void* self, uint32_t flags);
    static void tx_complete(void* self, uint32_t flags);

#ifndef HAL_UART_NODMA
    void dma_tx_allocate(Shared_DMA *ctx);
    void dma_tx_deallocate(Shared_DMA *ctx);
    void dma_rx_enable(void);
#endif
    void update_rts_line(void);

    void check_dma_tx_completion(void);
#ifndef HAL_UART_NODMA
    void write_pending_bytes_DMA(uint32_t n);
#endif
    void write_pending_bytes_NODMA(uint32_t n);
    void write_pending_bytes(void);
    void read_bytes_NODMA();

    void receive_timestamp_update(void);

    // set SERIALn_OPTIONS for pullup/pulldown
    void set_pushpull(uint16_t options);

    static void thread_rx_init();
    void thread_init();
    void uart_thread();
    static void uart_rx_thread(void* arg);
    static void uart_thread_trampoline(void* p);

protected:
    void _begin(uint32_t b, uint16_t rxS, uint16_t txS) override;
    void _end() override;
    void _flush() override;
    size_t _write(const uint8_t *buffer, size_t size) override;
    ssize_t _read(uint8_t *buffer, uint16_t count) override;
    uint32_t _available() override;
    bool _discard_input() override;

#if HAL_UART_STATS_ENABLED
    // Getters for cumulative tx and rx counts
    uint32_t get_total_tx_bytes() const override { return _tx_stats_bytes; }
    uint32_t get_total_rx_bytes() const override { return _rx_stats_bytes; }
#if CH_CFG_USE_EVENTS == TRUE
    uint32_t _rx_stats_framing_errors;
    uint32_t _rx_stats_overrun_errors;
    uint32_t _rx_stats_noise_errors;
    event_listener_t err_listener;
    bool err_listener_initialised;
#endif
#endif
};

// access to usb init for stdio.cpp
void usb_initialise(void);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         /*
 * This file is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This file is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Code by Andrew Tridgell and Siddharth Bharat Purohit
 */
#include <AP_HAL/AP_HAL.h>
#include <AP_Math/AP_Math.h>

#include <hal.h>
#include "Util.h"
#include <ch.h>
#include "RCOutput.h"
#include "UARTDriver.h"
#include "hwdef/common/stm32_util.h"
#include "hwdef/common/watchdog.h"
#include "hwdef/common/flash.h"
#include <AP_ROMFS/AP_ROMFS.h>
#include <AP_Common/ExpandingString.h>
#include <AP_InternalError/AP_InternalError.h>
#include "sdcard.h"
#include "shared_dma.h"
#if defined(HAL_PWM_ALARM) || HAL_DSHOT_ALARM_ENABLED || HAL_CANMANAGER_ENABLED || HAL_USE_PWM == TRUE
#include <AP_Notify/AP_Notify.h>
#endif
#if HAL_ENABLE_SAVE_PERSISTENT_PARAMS
#include <AP_InertialSensor/AP_InertialSensor.h>
#include <AP_OpenDroneID/AP_OpenDroneID.h>
#endif
#include <AP_Logger/AP_Logger_config.h>
#if HAL_LOGGING_ENABLED
#include <AP_Logger/AP_Logger.h>
#endif

#if HAL_WITH_IO_MCU
#include <AP_BoardConfig/AP_BoardConfig.h>
#include <AP_IOMCU/AP_IOMCU.h>
extern AP_IOMCU iomcu;
#endif

#if AP_SIGNED_FIRMWARE && !defined(HAL_BOOTLOADER_BUILD)
#include <AP_CheckFirmware/AP_CheckFirmware.h>
#endif


extern const AP_HAL::HAL& hal;

using namespace ChibiOS;
#if CH_CFG_USE_HEAP == TRUE

/**
   how much free memory do we have in bytes.
*/
uint32_t Util::available_memory(void)
{
    // from malloc.c in hwdef
    return mem_available();
}

/*
    Special Allocation Routines
*/

void* Util::malloc_type(size_t size, AP_HAL::Util::Memory_Type mem_type)
{
    if (mem_type == AP_HAL::Util::MEM_DMA_SAFE) {
        return malloc_dma(size);
    } else if (mem_type == AP_HAL::Util::MEM_FAST) {
        return malloc_fastmem(size);
    } else if (mem_type == AP_HAL::Util::MEM_FILESYSTEM) {
#if defined(STM32H7)
        return malloc_axi_sram(size);
#else
        return malloc_dma(size);
#endif
    } else {
        return calloc(1, size);
    }
}

void Util::free_type(void *ptr, size_t size, AP_HAL::Util::Memory_Type mem_type)
{
    if (ptr != NULL) {
        free(ptr);
    }
}


#if ENABLE_HEAP

void *Util::allocate_heap_memory(size_t size)
{
    memory_heap_t *heap = (memory_heap_t *)malloc(size + sizeof(memory_heap_t));
    if (heap == nullptr) {
        return nullptr;
    }
    chHeapObjectInit(heap, heap + 1U, size);
    return heap;
}

/*
  realloc implementation thanks to wolfssl, used by AP_Scripting
 */
void *Util::std_realloc(void *addr, size_t size)
{
    if (size == 0) {
       free(addr);
       return nullptr;
    }
    if (addr == nullptr) {
        return malloc(size);
    }
    void *new_mem = malloc(size);
    if (new_mem != nullptr) {
        memcpy(new_mem, addr, chHeapGetSize(addr) > size ? size : chHeapGetSize(addr));
        free(addr);
    }
    return new_mem;
}

void *Util::heap_realloc(void *heap, void *ptr, size_t old_size, size_t new_size)
{
    if (heap == nullptr) {
        return nullptr;
    }
    if (new_size == 0) {
        if (ptr != nullptr) {
            chHeapFree(ptr);
        }
        return nullptr;
    }
    if (ptr == nullptr) {
        return chHeapAlloc((memory_heap_t *)heap, new_size);
    }
    void *new_mem = chHeapAlloc((memory_heap_t *)heap, new_size);
    if (new_mem != nullptr) {
        const size_t old_size2 = chHeapGetSize(ptr);
#if defined(HAL_DEBUG_BUILD) && !defined(IOMCU_FW)
        if (new_size != 0 && old_size2 != old_size) {
            INTERNAL_ERROR(AP_InternalError::error_t::invalid_arg_or_result);
        }
#endif
        memcpy(new_mem, ptr, old_size2 > new_size ? new_size : old_size2);
        chHeapFree(ptr);
    }
    return new_mem;
}
#endif // ENABLE_HEAP

#endif // CH_CFG_USE_HEAP

/*
  get safety switch state
 */
Util::safety_state Util::safety_switch_state(void)
{
#if HAL_USE_PWM == TRUE
    return ((RCOutput *)hal.rcout)->_safety_switch_state();
#else
    return SAFETY_NONE;
#endif
}

#ifdef HAL_PWM_ALARM
struct Util::ToneAlarmPwmGroup Util::_toneAlarm_pwm_group = HAL_PWM_ALARM;
#elif HAL_USE_PWM == TRUE
struct Util::ToneAlarmPwmGroup Util::_toneAlarm_pwm_group = {};
#endif

uint8_t  Util::_toneAlarm_types = 0;

bool Util::toneAlarm_init(uint8_t types)
{
#ifdef HAL_PWM_ALARM
    _toneAlarm_pwm_group.pwm_cfg.period = 1000;
    pwmStart(_toneAlarm_pwm_group.pwm_drv, &_toneAlarm_pwm_group.pwm_cfg);
#endif
    _toneAlarm_types = types;

#if HAL_USE_PWM != TRUE && !HAL_DSHOT_ALARM_ENABLED && !HAL_CANMANAGER_ENABLED
    // Nothing to do
    return false;
#else
    return true;
#endif
}

#if HAL_USE_PWM == TRUE
bool Util::toneAlarm_init(const PWMConfig& pwm_cfg, PWMDriver* pwm_drv, pwmchannel_t chan, bool active_high)
{
#ifdef HAL_PWM_ALARM
    pwmStop(_toneAlarm_pwm_group.pwm_drv);
#endif
    _toneAlarm_pwm_group.pwm_cfg = pwm_cfg;
    _toneAlarm_pwm_group.pwm_drv = pwm_drv;
    _toneAlarm_pwm_group.pwm_cfg.period = 1000;
    _toneAlarm_pwm_group.pwm_cfg.channels[chan].mode = active_high ? PWM_OUTPUT_ACTIVE_HIGH : PWM_OUTPUT_ACTIVE_LOW;
    _toneAlarm_pwm_group.chan = chan;
    pwmStart(_toneAlarm_pwm_group.pwm_drv, &_toneAlarm_pwm_group.pwm_cfg);
    return true;
}
#endif

void Util::toneAlarm_set_buzzer_tone(float frequency, float volume, uint32_t duration_ms)
{
#if HAL_USE_PWM == TRUE
    if (_toneAlarm_pwm_group.pwm_drv != nullptr) {
        if (is_zero(frequency) || is_zero(volume)) {
            pwmDisableChannel(_toneAlarm_pwm_group.pwm_drv, _toneAlarm_pwm_group.chan);
        } else {
            pwmChangePeriod(_toneAlarm_pwm_group.pwm_drv,
                            roundf(_toneAlarm_pwm_group.pwm_cfg.frequency/frequency));

            pwmEnableChannel(_toneAlarm_pwm_group.pwm_drv, _toneAlarm_pwm_group.chan, roundf(volume*_toneAlarm_pwm_group.pwm_cfg.frequency/frequency)/2);
        }
    }
#endif // HAL_USE_PWM
#if HAL_DSHOT_ALARM_ENABLED
    // don't play the motors while flying
    if (!(_toneAlarm_types & uint8_t(AP_Notify::BuzzerType::DSHOT)) || get_soft_armed() || hal.rcout->get_dshot_esc_type() == RCOutput::DSHOT_ESC_NONE) {
        return;
    }

    if (is_zero(frequency)) {   // silence
        hal.rcout->send_dshot_command(RCOutput::DSHOT_RESET, RCOutput::ALL_CHANNELS, duration_ms);
    } else if (frequency < 1047) { // C
        hal.rcout->send_dshot_command(RCOutput::DSHOT_BEEP1, RCOutput::ALL_CHANNELS, duration_ms);
    } else if (frequency < 1175) {  // D
        hal.rcout->send_dshot_command(RCOutput::DSHOT_BEEP2, RCOutput::ALL_CHANNELS, duration_ms);
    } else if (frequency < 1319) {  // E
        hal.rcout->send_dshot_command(RCOutput::DSHOT_BEEP3, RCOutput::ALL_CHANNELS, duration_ms);
    } else if (frequency < 1397) {  // F
        hal.rcout->send_dshot_command(RCOutput::DSHOT_BEEP4, RCOutput::ALL_CHANNELS, duration_ms);
    } else {  // G+
        hal.rcout->send_dshot_command(RCOutput::DSHOT_BEEP5, RCOutput::ALL_CHANNELS, duration_ms);
    }
#endif // HAL_DSHOT_ALARM_ENABLED
}

/*
  set HW RTC in UTC microseconds
*/
void Util::set_hw_rtc(uint64_t time_utc_usec)
{
    stm32_set_utc_usec(time_utc_usec);
}

/*
  get system clock in UTC microseconds
*/
uint64_t Util::get_hw_rtc() const
{
    return stm32_get_utc_usec();
}

#include <GCS_MAVLink/GCS.h>

#if AP_BOOTLOADER_FLASHING_ENABLED

#if HAL_GCS_ENABLED
#include <GCS_MAVLink/GCS.h>
#define Debug(fmt, args ...)  do { GCS_SEND_TEXT(MAV_SEVERITY_INFO, fmt, ## args); } while (0)
#endif // HAL_GCS_ENABLED

#ifndef Debug
#define Debug(fmt, args ...)  do { hal.console->printf(fmt, ## args); } while (0)
#endif

#ifdef HAL_NO_FLASH_SUPPORT
#error "Bootloader-flashing enabled but no flashing support"
#endif

Util::FlashBootloader Util::flash_bootloader()
{
    uint32_t fw_size;
    const char *fw_name = "bootloader.bin";

    EXPECT_DELAY_MS(11000);

    const uint8_t *fw = AP_ROMFS::find_decompress(fw_name, fw_size);
    if (!fw) {
        Debug("failed to find %s\n", fw_name);
        return FlashBootloader::NOT_AVAILABLE;
    }

#if AP_SIGNED_FIRMWARE
    if (!AP_CheckFirmware::check_signed_bootloader(fw, fw_size)) {
        // don't allow flashing of an unsigned bootloader in a secure
        // setup. This prevents the easy mistake of leaving an
        // unsigned bootloader in ROMFS, which would give a trivail
        // way to bypass signing
        AP_ROMFS::free(fw);
        return FlashBootloader::NOT_SIGNED;
    }
#endif

    // make sure size is multiple of 32
    fw_size = (fw_size + 31U) & ~31U;

    bool uptodate = true;
    const uint32_t addr = hal.flash->getpageaddr(0);

    if (memcmp(fw, (const void*)addr, fw_size) != 0) {
        uptodate = false;
    }

#if HAL_ENABLE_SAVE_PERSISTENT_PARAMS
    // see if we should store persistent parameters along with the
    // bootloader. We only do this on boards using a single sector for
    // the bootloader. The persistent parameters are stored as text at
    // the end of the sector
    const int32_t space_available = hal.flash->getpagesize(0) - int32_t(fw_size);
    ExpandingString persistent_params {}, old_persistent_params {};
    if (get_persistent_params(persistent_params) &&
        space_available >= persistent_params.get_length() &&
        (!load_persistent_params(old_persistent_params) ||
         strcmp(persistent_params.get_string(),
                old_persistent_params.get_string()) != 0)) {
        // persistent parameters have changed, we will update
        // bootloader to allow storage of the params
        uptodate = false;
    }
#endif

    if (uptodate) {
        Debug("Bootloader up-to-date\n");
        AP_ROMFS::free(fw);
        return FlashBootloader::NO_CHANGE;
    }

    Debug("Erasing\n");
    uint32_t erased_size = 0;
    uint8_t erase_page = 0;
    while (erased_size < fw_size) {
        uint32_t page_size = hal.flash->getpagesize(erase_page);
        if (page_size == 0) {
            AP_ROMFS::free(fw);
            return FlashBootloader::FAIL;
        }
        hal.scheduler->expect_delay_ms(1000);
        if (!hal.flash->erasepage(erase_page)) {
            Debug("Erase %u failed\n", erase_page);
            AP_ROMFS::free(fw);
            return FlashBootloader::FAIL;
        }
        erased_size += page_size;
        erase_page++;
    }

    Debug("Flashing %s @%08x\n", fw_name, (unsigned int)addr);
    const uint8_t max_attempts = 10;
    hal.flash->keep_unlocked(true);
    for (uint8_t i=0; i<max_attempts; i++) {
        hal.scheduler->expect_delay_ms(1000);
        bool ok = hal.flash->write(addr, fw, fw_size);
        if (!ok) {
            Debug("Flash failed! (attempt=%u/%u)\n",
                                i+1,
                                max_attempts);
            hal.scheduler->delay(100);
            continue;
        }
        Debug("Flash OK\n");
#if HAL_ENABLE_SAVE_PERSISTENT_PARAMS
        if (persistent_params.get_length()) {
            const uint32_t ofs = hal.flash->getpagesize(0) - persistent_params.get_length();
            hal.flash->write(addr+ofs, persistent_params.get_string(), persistent_params.get_length());
        }
#endif
        hal.flash->keep_unlocked(false);
        AP_ROMFS::free(fw);
        return FlashBootloader::OK;
    }

    hal.flash->keep_unlocked(false);
    Debug("Flash failed after %u attempts\n", max_attempts);
    AP_ROMFS::free(fw);
    return FlashBootloader::FAIL;
}
#endif // AP_BOOTLOADER_FLASHING_ENABLED

/*
  display system identifer - board type and serial number
 */
bool Util::get_system_id(char buf[50])
{
    uint8_t serialid[12];
    char board_name[24];

    memcpy(serialid, (const void *)UDID_START, 12);
    // avoid board names greater than 23 chars (sizeof includes null char, so allow 24 bytes total)
    static_assert(sizeof(CHIBIOS_SHORT_BOARD_NAME) <= 24, "CHIBIOS_SHORT_BOARD_NAME must be 23 characters or less");
    strncpy(board_name, CHIBIOS_SHORT_BOARD_NAME, 23);
    board_name[23] = 0;

    // this format is chosen to match the format used by HAL_PX4
    snprintf(buf, 50, "%s %02X%02X%02X%02X %02X%02X%02X%02X %02X%02X%02X%02X",
             board_name,
             (unsigned)serialid[3], (unsigned)serialid[2], (unsigned)serialid[1], (unsigned)serialid[0],
             (unsigned)serialid[7], (unsigned)serialid[6], (unsigned)serialid[5], (unsigned)serialid[4],
             (unsigned)serialid[11], (unsigned)serialid[10], (unsigned)serialid[9],(unsigned)serialid[8]);
    buf[49] = 0;
    return true;
}

bool Util::get_system_id_unformatted(uint8_t buf[], uint8_t &len)
{
    len = MIN(12, len);
    memcpy(buf, (const void *)UDID_START, len);
    return true;
}

// return true if the reason for the reboot was a watchdog reset
bool Util::was_watchdog_reset() const
{
    return stm32_was_watchdog_reset();
}

#if CH_DBG_ENABLE_STACK_CHECK == TRUE && !defined(HAL_BOOTLOADER_BUILD)
/*
  display stack usage as text buffer for @SYS/threads.txt
 */
__RAMFUNC__ void Util::thread_info(ExpandingString &str)
{
#if HAL_ENABLE_THREAD_STATISTICS
    uint64_t cumulative_cycles = currcore->kernel_stats.m_crit_isr.cumulative;
    for (thread_t *tp = chRegFirstThread(); tp; tp = chRegNextThread(tp)) {
        if (tp->stats.best > 0) { // not run
            cumulative_cycles += (uint64_t)tp->stats.cumulative;
        }
    }
#endif
    // a header to allow for machine parsers to determine format
    const uint32_t isr_stack_size = uint32_t((const uint8_t *)&__main_stack_end__ - (const uint8_t *)&__main_stack_base__);
#if HAL_ENABLE_THREAD_STATISTICS
    str.printf("ThreadsV2\nISR           PRI=255 sp=%p STACK=%u/%u LOAD=%4.1f%%\n",
                &__main_stack_base__,
                unsigned(stack_free(&__main_stack_base__)),
                unsigned(isr_stack_size), 100.0f * float(currcore->kernel_stats.m_crit_isr.cumulative) / float(cumulative_cycles));
    currcore->kernel_stats.m_crit_isr.cumulative = 0U;
#else
    str.printf("ThreadsV2\nISR           PRI=255 sp=%p STACK=%u/%u\n",
                &__main_stack_base__,
                unsigned(stack_free(&__main_stack_base__)),
                unsigned(isr_stack_size));
#endif
    for (thread_t *tp = chRegFirstThread(); tp; tp = chRegNextThread(tp)) {
        uint32_t total_stack;
        if (tp->wabase == (void*)&__main_thread_stack_base__) {
            // main thread has its stack separated from the thread context
            total_stack = uint32_t((const uint8_t *)&__main_thread_stack_end__ - (const uint8_t *)&__main_thread_stack_base__);
        } else {
            // all other threads have their thread context pointer
            // above the stack top
            total_stack = uint32_t(tp) - uint32_t(tp->wabase);
        }
#if HAL_ENABLE_THREAD_STATISTICS
        time_measurement_t stats = tp->stats;
        if (tp->stats.best > 0) { // not run
            str.printf("%-13.13s PRI=%3u sp=%p STACK=%4u/%4u LOAD=%4.1f%%%s\n",
                        tp->name, unsigned(tp->realprio), tp->wabase,
                        unsigned(stack_free(tp->wabase)), unsigned(total_stack),
                        100.0f * float(stats.cumulative) / float(cumulative_cycles),
                        // more than a loop slice is bad for everyone else, warn on
                        // more than a 200Hz slice so that only the worst offenders are identified
                        // also don't do this for the main or idle threads
                        tp != chThdGetSelfX() && unsigned(RTC2US(STM32_HSECLK, stats.worst)) > 5000
                            && tp != get_main_thread() && tp->realprio != 1 ? "*" : "");
        } else {
            str.printf("%-13.13s PRI=%3u sp=%p STACK=%4u/%4u\n",
                        tp->name, unsigned(tp->realprio), tp->wabase, unsigned(stack_free(tp->wabase)), unsigned(total_stack));
        }
        // Giovanni thinks this is dangerous, but we can't get useable data without it
        if (tp != chThdGetSelfX()) {
            chTMObjectInit(&tp->stats); // reset counters to zero
        } else {
            tp->stats.cumulative = 0U;
        }
#else
        str.printf("%-13.13s PRI=%3u sp=%p STACK=%u/%u\n",
                    tp->name, unsigned(tp->realprio), tp->wabase,
                    unsigned(stack_free(tp->wabase)), unsigned(total_stack));
#endif
    }
}
#endif // CH_DBG_ENABLE_STACK_CHECK == TRUE

#if CH_CFG_USE_SEMAPHORES
// request information on dma contention
void Util::dma_info(ExpandingString &str)
{
#if AP_HAL_SHARED_DMA_ENABLED
    ChibiOS::Shared_DMA::dma_info(str);
#endif
}
#endif

#if CH_CFG_USE_HEAP == TRUE
/*
  return information on heap usage
 */
void Util::mem_info(ExpandingString &str)
{
    memory_heap_t *heaps;
    const struct memory_region *regions;
    uint8_t num_heaps = malloc_get_heaps(&heaps, &regions);

    str.printf("MemInfoV1\n");
    for (uint8_t i=0; i<num_heaps; i++) {
        size_t totalp=0, largest=0;
        // get memory available on main heap
        chHeapStatus(i == 0 ? nullptr : &heaps[i], &totalp, &largest);
        str.printf("START=0x%08x LEN=%3uk FREE=%6u LRG=%6u TYPE=%1u\n",
                   unsigned(regions[i].address), unsigned(regions[i].size/1024),
                   unsigned(totalp), unsigned(largest), unsigned(regions[i].flags));
    }
}
#endif

#if HAL_ENABLE_SAVE_PERSISTENT_PARAMS

static const char *persistent_header = "{{PERSISTENT_START_V1}}\n";

/*
  create a set of persistent parameters in string form
 */
bool Util::get_persistent_params(ExpandingString &str) const
{
    str.printf("%s", persistent_header);
#if HAL_INS_TEMPERATURE_CAL_ENABLE
    const auto *ins = AP_InertialSensor::get_singleton();
    if (ins) {
        ins->get_persistent_params(str);
    }
#endif
#if AP_OPENDRONEID_ENABLED
    const auto *odid = AP_OpenDroneID::get_singleton();
    if (odid) {
        odid->get_persistent_params(str);
    }
#endif
    if (str.has_failed_allocation() || str.get_length() <= strlen(persistent_header)) {
        // no data
        return false;
    }
    // ensure that the length is a multiple of 32 to meet flash alignment requirements
    while (!str.has_failed_allocation() && str.get_length() % 32 != 0) {
        str.append(" ", 1);
    }
    return !str.has_failed_allocation();
}

/*
  load a set of persistent parameters in string form from the bootloader sector
 */
bool Util::load_persistent_params(ExpandingString &str) const
{
    const uint32_t addr = hal.flash->getpageaddr(0);
    const uint32_t size = hal.flash->getpagesize(0);
    const char *s = (const char *)memmem((void*)addr, size,
                                         persistent_header,
                                         strlen(persistent_header));
    if (s) {
        str.append(s, (addr+size) - uint32_t(s));
        return !str.has_failed_allocation();
    }
    return false;
}

/*
  get a persistent variable by name,
  len is the length of the value buffer, and is updated with the length of the value
 */
bool Util::get_persistent_param_by_name(const char *name, char* value, size_t& len) const
{
    ExpandingString persistent_params {};
    if (!load_persistent_params(persistent_params)) {
        return false;
    }
    char *s = persistent_params.get_writeable_string();
    if (s == nullptr) {
        return false;
    }
    char *saveptr;
    s += strlen(persistent_header);
    for (char *p = strtok_r(s, "\n", &saveptr);
         p; p = strtok_r(nullptr, "\n", &saveptr)) {
        char *eq = strchr(p, int('='));
        if (eq) {
            *eq = 0;
            if (strcmp(p, name) == 0) {
                // also get the length of the value
                strncpy(value, eq+1, len);
                len = strlen(value);
                return true;
            }
        }
    }
    return false;
}

/*
  apply persistent parameters from the bootloader sector to AP_Param
 */
void Util::apply_persistent_params(void) const
{
    ExpandingString str {};
    if (!load_persistent_params(str)) {
        return;
    }
    char *s = str.get_writeable_string();
    char *saveptr;
    s += strlen(persistent_header);
    uint32_t count = 0;
    uint32_t errors = 0;
    for (char *p = strtok_r(s, "\n", &saveptr);
         p; p = strtok_r(nullptr, "\n", &saveptr)) {
        char *eq = strchr(p, int('='));
        if (eq) {
            *eq = 0;
            const char *pname = p;
            const float value = strtof(eq+1, NULL);
            if (AP_Param::set_default_by_name(pname, value)) {
                count++;
                /*
                  we now have a special case for INS_ACC*_ID. To
                  support factory accelerometer calibration we need to
                  do a save() on the ID parameters if they are not
                  already in storage. This is needed as
                  AP_InertialSensor determines if a calibration has
                  been done by whether the IDs are configured in
                  storage
                 */
                bool legacy_acc_id = strncmp(pname, "INS_ACC", 7) == 0 &&
                    strcmp(pname+strlen(pname)-3, "_ID") == 0;
                bool new_acc_id = strncmp(pname, "INS", 3) == 0 &&
                    strcmp(pname+strlen(pname)-6, "ACC_ID") == 0;
                if (legacy_acc_id || new_acc_id) {
                    enum ap_var_type ptype;
                    AP_Int32 *ap = (AP_Int32 *)AP_Param::find(pname, &ptype);
                    if (ap && ptype == AP_PARAM_INT32) {
                        if (ap->get() != int32_t(value)) {
                            // the accelerometer ID has changed since
                            // this persistent data was saved. Stop
                            // loading persistent parameters as it is
                            // no longer valid for this board. This
                            // can happen if the user has set
                            // parameters to prevent loading of
                            // specific IMU drivers, or if they have
                            // setup an external IMU
                            errors++;
                            break;
                        }
                        if (!ap->configured()) {
                            ap->save();
                        }
                    }
                }
            }
        }
    }
    if (count) {
        AP_Param::invalidate_count();
        GCS_SEND_TEXT(MAV_SEVERITY_INFO, "Loaded %u persistent parameters (%u errors)",
                      unsigned(count), unsigned(errors));
    }
}
#endif // HAL_ENABLE_SAVE_PERSISTENT_PARAMS

#if HAL_WITH_IO_MCU
extern ChibiOS::UARTDriver uart_io;
#endif

#if HAL_UART_STATS_ENABLED
// request information on uart I/O
void Util::uart_info(ExpandingString &str)
{
    // Calculate time since last call
    const uint32_t now_ms = AP_HAL::millis();
    const uint32_t dt_ms = now_ms - sys_uart_stats.last_ms;
    sys_uart_stats.last_ms = now_ms;

    // a header to allow for machine parsers to determine format
    str.printf("UARTV1\n");
    for (uint8_t i = 0; i < HAL_UART_NUM_SERIAL_PORTS; i++) {
        auto *uart = hal.serial(i);
        if (uart) {
            str.printf("SERIAL%u ", i);
            uart->uart_info(str, sys_uart_stats.serial[i], dt_ms);
        }
    }
#if HAL_WITH_IO_MCU
    str.printf("IOMCU   ");
    uart_io.uart_info(str, sys_uart_stats.io, dt_ms);
#endif
}

// Log UART message for each serial port
#if HAL_LOGGING_ENABLED
void Util::uart_log()
{
    // Calculate time since last call
    const uint32_t now_ms = AP_HAL::millis();
    const uint32_t dt_ms = now_ms - log_uart_stats.last_ms;
    log_uart_stats.last_ms = now_ms;

    // Loop over all numbered ports
    for (uint8_t i = 0; i < HAL_UART_NUM_SERIAL_PORTS; i++) {
        auto *uart = hal.serial(i);
        if (uart) {
            uart->log_stats(i, log_uart_stats.serial[i], dt_ms);
        }
    }
#if HAL_WITH_IO_MCU
    // Use magic instance 100 for IOMCU
    uart_io.log_stats(100, log_uart_stats.io, dt_ms);
#endif
}
#endif // HAL_LOGGING_ENABLED
#endif // HAL_UART_STATS_ENABLED

// request information on uart I/O
#if HAL_USE_PWM == TRUE
void Util::timer_info(ExpandingString &str)
{
    hal.rcout->timer_info(str);
}
#endif

/**
 * This method will generate random values with set size. It will fall back to AP_Math's get_random16()
 * if True RNG fails or enough entropy is not present.
 */
bool Util::get_random_vals(uint8_t* data, size_t size)
{
#if HAL_USE_HW_RNG && defined(RNG)
    size_t true_random_vals = stm32_rand_generate_nonblocking(data, size);
    if (true_random_vals != size) {
        if (!(true_random_vals % 2)) {
            data[true_random_vals] = (uint8_t)(get_random16() & 0xFF);
            true_random_vals++;
        }
        while(true_random_vals < size) {
            uint16_t val = get_random16();
            memcpy(&data[true_random_vals], &val, sizeof(uint16_t));
            true_random_vals+=sizeof(uint16_t);
        }
    }
#else
    size_t true_random_vals = 0;
    while(true_random_vals < size) {
        uint16_t val = get_random16();
        memcpy(&data[true_random_vals], &val, sizeof(uint16_t));
        true_random_vals+=sizeof(uint16_t);
    }
    if (size % 2) {
        data[size-1] = get_random16() & 0xFF;
    }
#endif
    return true;
}

/**
 * This method will generate true random values with set size. This method will block for set amount
 * of true random numbers to be generated, the timeout specifies the maximum amount of time to wait
 * for the call to finish.
 */
bool Util::get_true_random_vals(uint8_t* data, size_t size, uint32_t timeout_us)
{
#if HAL_USE_HW_RNG && defined(RNG)
    if (stm32_rand_generate_blocking(data, size, timeout_us)) {
        return true;
    } else {
        return false;
    }
#else
    return false;
#endif
}

/*
  log info on stack usage. Called at 1Hz by logging thread, logs next
  thread on each call
*/
void Util::log_stack_info(void)
{
#if HAL_LOGGING_ENABLED
    static thread_t *last_tp;
    static uint8_t thread_id;
    thread_t *tp = last_tp;
    if (tp == nullptr) {
        tp = chRegFirstThread();
        thread_id = 0;
    } else {
        tp = chRegNextThread(last_tp);
        thread_id++;
    }
    struct log_STAK pkt = {
        LOG_PACKET_HEADER_INIT(LOG_STAK_MSG),
        time_us         : AP_HAL::micros64(),
    };
    if (tp == nullptr) {
        pkt.thread_id = 255;
        pkt.priority = 255;
        const uint32_t isr_stack_size = uint32_t((const uint8_t *)&__main_stack_end__ - (const uint8_t *)&__main_stack_base__);
        pkt.stack_total = isr_stack_size;
        pkt.stack_free = stack_free(&__main_stack_base__);
        strncpy_noterm(pkt.name, "ISR", sizeof(pkt.name));
    } else {
        if (tp->wabase == (void*)&__main_thread_stack_base__) {
            // main thread has its stack separated from the thread context
            pkt.stack_total = uint32_t((const uint8_t *)&__main_thread_stack_end__ - (const uint8_t *)&__main_thread_stack_base__);
        } else {
            // all other threads have their thread context pointer
            // above the stack top
            pkt.stack_total = uint32_t(tp) - uint32_t(tp->wabase);
        }
        pkt.thread_id = thread_id;
        pkt.priority = tp->realprio,
        pkt.stack_free = stack_free(tp->wabase);
        strncpy_noterm(pkt.name, tp->name, sizeof(pkt.name));
    }
    AP::logger().WriteBlock(&pkt, sizeof(pkt));
    last_tp = tp;
#endif
}

#if AP_CRASHDUMP_ENABLED
size_t Util::last_crash_dump_size() const
{
    // get dump size
    uint32_t size = stm32_crash_dump_size();
    char* dump_start = (char*)stm32_crash_dump_addr();
    if (!(dump_start[0] == 0x63 && dump_start[1] == 0x43)) {
        // there's no valid Crash Dump
        return 0;
    }
    if (size == 0xFFFFFFFF) {
        GCS_SEND_TEXT(MAV_SEVERITY_ERROR, "Crash Dump incomplete, dumping what we got!");
        size = stm32_crash_dump_max_size();
    }
    return size;
}

void* Util::last_crash_dump_ptr() const
{
    if (last_crash_dump_size() == 0) {
        return nullptr;
    }
    return (void*)stm32_crash_dump_addr();
}
#endif // AP_CRASHDUMP_ENABLED

#if HAL_ENABLE_DFU_BOOT && !defined(HAL_BOOTLOADER_BUILD)
void Util::boot_to_dfu()
{
    hal.util->persistent_data.boot_to_dfu = true;
    stm32_watchdog_save((uint32_t *)&hal.util->persistent_data, (sizeof(hal.util->persistent_data)+3)/4);
    hal.scheduler->reboot();
}
#endif

// set armed state
void Util::set_soft_armed(const bool b)
{
    AP_HAL::Util::set_soft_armed(b);
#ifdef HAL_GPIO_PIN_nARMED
    palWriteLine(HAL_GPIO_PIN_nARMED, !b);
#endif
}

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           /*
 * This file is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This file is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Code by Andrew Tridgell and Siddharth Bharat Purohit
 */
#pragma once

#include <AP_HAL/AP_HAL.h>
#include "AP_HAL_ChibiOS_Namespace.h"
#include "AP_HAL_ChibiOS.h"
#include <ch.h>
#include <AP_Logger/AP_Logger_config.h>

class ExpandingString;

#ifndef HAL_ENABLE_SAVE_PERSISTENT_PARAMS
// on F7 and H7 we will try to save key persistent parameters at the
// end of the bootloader sector. This enables temperature calibration
// data to be saved persistently in the factory
#define HAL_ENABLE_SAVE_PERSISTENT_PARAMS (defined(STM32F7) || defined(STM32H7))
#endif

class ChibiOS::Util : public AP_HAL::Util {
public:
    static Util *from(AP_HAL::Util *util) {
        return static_cast<Util*>(util);
    }

    uint32_t available_memory() override;

    // get path to custom defaults file for AP_Param
    const char* get_custom_defaults_file() const override {
        return "@ROMFS/defaults.parm";
    }

    // Special Allocation Routines
    void *malloc_type(size_t size, AP_HAL::Util::Memory_Type mem_type) override;
    void free_type(void *ptr, size_t size, AP_HAL::Util::Memory_Type mem_type) override;

#if ENABLE_HEAP
    // heap functions, note that a heap once alloc'd cannot be dealloc'd
    virtual void *allocate_heap_memory(size_t size) override;
    virtual void *heap_realloc(void *heap, void *ptr, size_t old_size, size_t new_size) override;
    virtual void *std_realloc(void *ptr, size_t new_size) override;
#endif // ENABLE_HEAP

    /*
      return state of safety switch, if applicable
     */
    enum safety_state safety_switch_state(void) override;

    // get system ID as a string
    bool get_system_id(char buf[50]) override;
    bool get_system_id_unformatted(uint8_t buf[], uint8_t &len) override;

    bool toneAlarm_init(uint8_t types) override;
#if HAL_USE_PWM == TRUE
    bool toneAlarm_init(const PWMConfig& pwm_cfg, PWMDriver* pwm_drv, pwmchannel_t chan, bool active_high);
#endif
    void toneAlarm_set_buzzer_tone(float frequency, float volume, uint32_t duration_ms) override;
    static uint8_t _toneAlarm_types;

    // return true if the reason for the reboot was a watchdog reset
    bool was_watchdog_reset() const override;

#if CH_DBG_ENABLE_STACK_CHECK == TRUE
    // request information on running threads
    void thread_info(ExpandingString &str) override;
#endif
#if CH_CFG_USE_SEMAPHORES
    // request information on dma contention
    void dma_info(ExpandingString &str) override;
#endif
#if CH_CFG_USE_HEAP == TRUE
    void mem_info(ExpandingString &str) override;
#endif

#if HAL_ENABLE_SAVE_PERSISTENT_PARAMS
    // apply persistent parameters to current parameters
    void apply_persistent_params(void) const;
#endif

#if HAL_ENABLE_SAVE_PERSISTENT_PARAMS
    // save/load key persistent parameters in bootloader sector
    bool load_persistent_params(ExpandingString &str) const override;
    bool get_persistent_param_by_name(const char *name, char* value, size_t& len) const override;
#endif
#if HAL_UART_STATS_ENABLED
    // request information on uart I/O
    void uart_info(ExpandingString &str) override;

#if HAL_LOGGING_ENABLED
    // Log UART message for each serial port
    void uart_log() override;
#endif
#endif // HAL_UART_STATS_ENABLED

#if HAL_USE_PWM == TRUE
    void timer_info(ExpandingString &str) override;
#endif
    // returns random values
    bool get_random_vals(uint8_t* data, size_t size) override;

    // returns true random values
    bool get_true_random_vals(uint8_t* data, size_t size, uint32_t timeout_us) override;

    // set armed state
    void set_soft_armed(const bool b) override;

private:
#if HAL_USE_PWM == TRUE
    struct ToneAlarmPwmGroup {
        pwmchannel_t chan;
        PWMConfig pwm_cfg;
        PWMDriver* pwm_drv;
    };

    static ToneAlarmPwmGroup _toneAlarm_pwm_group;
#endif

    /*
      set HW RTC in UTC microseconds
     */
    void set_hw_rtc(uint64_t time_utc_usec) override;

    /*
      get system clock in UTC microseconds
     */
    uint64_t get_hw_rtc() const override;
#if AP_BOOTLOADER_FLASHING_ENABLED
    FlashBootloader flash_bootloader() override;
#endif

#if ENABLE_HEAP
    static memory_heap_t scripting_heap;
#endif // ENABLE_HEAP

    // stm32F4 and F7 have 20 total RTC backup registers. We use the first one for boot type
    // flags, so 19 available for persistent data
    static_assert(sizeof(persistent_data) <= 19*4, "watchdog persistent data too large");

#if HAL_ENABLE_SAVE_PERSISTENT_PARAMS
    // save/load key persistent parameters in bootloader sector
    bool get_persistent_params(ExpandingString &str) const;
#endif

    // log info on stack usage
    void log_stack_info(void) override;

#if AP_CRASHDUMP_ENABLED
    // get last crash dump
    size_t last_crash_dump_size() const override;
    void* last_crash_dump_ptr() const override;
#endif

#if HAL_ENABLE_DFU_BOOT
    void boot_to_dfu() override;
#endif

#if HAL_UART_STATS_ENABLED
    struct uart_stats {
        AP_HAL::UARTDriver::StatsTracker serial[HAL_UART_NUM_SERIAL_PORTS];
#if HAL_WITH_IO_MCU
        AP_HAL::UARTDriver::StatsTracker io;
#endif
        uint32_t last_ms;
    };
    uart_stats sys_uart_stats;
#if HAL_LOGGING_ENABLED
    uart_stats log_uart_stats;
#endif
#endif
};
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         /*
 * This file is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This file is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Code by 
 *         Andy Piper
 *         Siddharth Bharat Purohit, Cubepilot Pty. Ltd.
 */

#include <hal.h>
#include "WSPIDevice.h"

#include <AP_HAL/AP_HAL.h>
#include <AP_Math/AP_Math.h>
#include <AP_HAL/utility/OwnPtr.h>
#include <AP_InternalError/AP_InternalError.h>
#include "Util.h"
#include "Scheduler.h"
#include <stdio.h>

#if HAL_USE_WSPI == TRUE && defined(HAL_WSPI_DEVICE_LIST)

using namespace ChibiOS;
extern const AP_HAL::HAL& hal;

static const struct WSPIDriverInfo {
    WSPIDriver *driver;
    uint8_t busid; // used for device IDs in parameters
} wspi_devices[] = { HAL_WSPI_BUS_LIST };

#define WSPIDEV_MODE1 0
#if HAL_USE_QUADSPI
#define WSPIDEV_MODE3 STM32_DCR_CK_MODE
#else
#define WSPIDEV_MODE3 STM32_DCR1_CK_MODE
#endif

// device list comes from hwdef.dat
WSPIDesc WSPIDeviceManager::device_table[] = { HAL_WSPI_DEVICE_LIST };

// Check clock sanity during runtime
#if defined(STM32_WSPI_USE_QUADSPI1) && STM32_WSPI_USE_QUADSPI1
#if (STM32_QSPICLK < HAL_QSPI1_CLK)
#error "Flash speed must not be greater than QSPI Clock"
#endif
#if (STM32_QSPICLK % HAL_QSPI1_CLK)
#warning "QSPI clock not an integer multiple of flash speed"
#endif
#endif

#if defined(STM32_WSPI_USE_QUADSPI2) && STM32_WSPI_USE_QUADSPI2
#if (STM32_QSPICLK < HAL_QSPI2_CLK)
#error "Flash speed must not be greater than QSPI Clock"
#endif
#if (STM32_QSPICLK % HAL_QSPI2_CLK)
#warning "WSPI clock not an integer multiple of flash speed"
#endif
#endif

#if defined(STM32_WSPI_USE_OCTOSPI1) && STM32_WSPI_USE_OCTOSPI1
#if (STM32_OCTOSPICLK < HAL_OSPI1_CLK)
#error "Flash speed must not be greater than OSPI Clock"
#endif
#if (STM32_OCTOSPICLK % HAL_OSPI1_CLK)
#warning "OSPI clock not an integer multiple of flash speed"
#endif
#endif

#if defined(STM32_WSPI_USE_OCTOSPI2) && STM32_WSPI_USE_OCTOSPI2
#if (STM32_OCTOSPICLK < HAL_OSPI2_CLK)
#error "Flash speed must not be greater than OSPI Clock"
#endif
#if (STM32_OCTOSPICLK % HAL_OSPI2_CLK)
#warning "OSPI clock not an integer multiple of flash speed"
#endif
#endif

bool WSPIDevice::is_busy()
{
#if HAL_USE_OCTOSPI
    return (wspi_devices[device_desc.bus].driver->ospi->SR & OCTOSPI_SR_BUSY) != 0U;
#else
    return (wspi_devices[device_desc.bus].driver->qspi->SR & QUADSPI_SR_BUSY) != 0U;
#endif
}

bool WSPIDevice::transfer(const uint8_t *send, uint32_t send_len,
                          uint8_t *recv, uint32_t recv_len)
{
    if (!acquire_bus(true)) {
        return false;
    }
    if (!bus.bouncebuffer_setup(send, send_len, recv, recv_len)) {
        acquire_bus(false);
        return false;
    }
    bool ret = true;
    if (send_len == 0 && recv_len == 0) {
        // This is just a command
        ret = !wspiCommand(wspi_devices[device_desc.bus].driver, &mode);
    } else if (send_len > 0 && recv == 0) {
        // This is a send cmd
        ret = !wspiSend(wspi_devices[device_desc.bus].driver, &mode, send_len, send);
    } else if (send_len == 0 && recv_len >= 1) {
        // This is a receive cmd,
        // we only consume first byte of send
        ret = !wspiReceive(wspi_devices[device_desc.bus].driver, &mode, recv_len, recv);
    } else {
        // Can't handle this transaction type
        ret = false;
    }
    bus.bouncebuffer_finish(send, recv, recv_len);
    acquire_bus(false);
    return ret;
}

void WSPIDevice::set_cmd_header(const CommandHeader& cmd_hdr)
{
    mode.cmd   = cmd_hdr.cmd;
    mode.cfg   = cmd_hdr.cfg;
    mode.addr  = cmd_hdr.addr;
    mode.alt   = cmd_hdr.alt;
    mode.dummy = cmd_hdr.dummy;
}


bool WSPIDevice::acquire_bus(bool acquire)
{
    if (!bus.semaphore.check_owner()) {
        return false;
    }
    if (acquire) {
        wspiAcquireBus(wspi_devices[device_desc.bus].driver);
        if (wspi_devices[device_desc.bus].driver->config != &bus.wspicfg) {
            // Initialise and Start WSPI driver
            bus.wspicfg.end_cb = nullptr;
            bus.wspicfg.error_cb = nullptr;
#if HAL_USE_QUADSPI
            bus.wspicfg.dcr = STM32_DCR_FSIZE(device_desc.size_pow2) |
                              STM32_DCR_CSHT(device_desc.ncs_clk_delay - 1)   |
                              device_desc.mode;
#else
            bus.wspicfg.dcr1 = STM32_DCR1_DEVSIZE(device_desc.size_pow2) |
                              STM32_DCR1_CSHT(device_desc.ncs_clk_delay - 1)   |
                              device_desc.mode;
#endif
            wspiStart(wspi_devices[device_desc.bus].driver, &bus.wspicfg);
        }
    } else {
        wspiReleaseBus(wspi_devices[device_desc.bus].driver);
    }
    return true;
}


// Enters Memory mapped or eXecution In Place or 0-4-4 mode
bool WSPIDevice::enter_xip_mode(void** map_ptr)
{
    if (!acquire_bus(true)) {
        return false;
    }
    wspiMapFlash(wspi_devices[device_desc.bus].driver, &mode, (uint8_t**)map_ptr);
    acquire_bus(false);
    return true;
}

bool WSPIDevice::exit_xip_mode()
{
    if (!acquire_bus(true)) {
        return false;
    }
    wspiUnmapFlash(wspi_devices[device_desc.bus].driver);
    acquire_bus(false);
    return true;
}

/*
  return a SPIDevice given a string device name
 */
AP_HAL::OwnPtr<AP_HAL::WSPIDevice>
WSPIDeviceManager::get_device(const char *name)
{
    /* Find the bus description in the table */
    uint8_t i;
    for (i = 0; i<ARRAY_SIZE(device_table); i++) {
        if (strcmp(device_table[i].name, name) == 0) {
            break;
        }
    }
    if (i == ARRAY_SIZE(device_table)) {
        return AP_HAL::OwnPtr<AP_HAL::WSPIDevice>(nullptr);
    }

    WSPIDesc &desc = device_table[i];

    // find the bus
    WSPIBus *busp;
    for (busp = buses; busp; busp = (WSPIBus *)busp->next) {
        if (busp->bus == desc.bus) {
            break;
        }
    }
    if (busp == nullptr) {
        // create a new one
        busp = NEW_NOTHROW WSPIBus(desc.bus);
        if (busp == nullptr) {
            return nullptr;
        }
        busp->next = buses;
        busp->bus = desc.bus;

        buses = busp;
    }

    return AP_HAL::OwnPtr<AP_HAL::WSPIDevice>(NEW_NOTHROW WSPIDevice(*busp, desc));
}

#endif // #if HAL_USE_WSPI == TRUE && defined(HAL_QPI_DEVICE_LIST)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         /*
 * This file is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This file is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Code by 
 *         Andy Piper
 *         Siddharth Bharat Purohit, Cubepilot Pty. Ltd.
 */

#pragma once

#include <inttypes.h>
#include <AP_HAL/HAL.h>
#include <AP_HAL/WSPIDevice.h>
#include "AP_HAL_ChibiOS.h"

#if HAL_USE_WSPI == TRUE && defined(HAL_WSPI_DEVICE_LIST)

#if !defined(HAL_BOOTLOADER_BUILD)
#include "Semaphores.h"
#endif
#include "hwdef/common/stm32_util.h"

#include "Scheduler.h"
#include "Device.h"

namespace ChibiOS
{

struct WSPIDesc {
    WSPIDesc(const char *_name, uint8_t _bus,
             uint32_t _mode, uint32_t _speed,
             uint8_t _size_pow2, uint8_t _ncs_clk_shift)
        : name(_name), bus(_bus), mode(_mode), speed(_speed),
          size_pow2(_size_pow2), ncs_clk_delay(_ncs_clk_shift)
    {
    }

    const char *name; // name of the device
    uint8_t bus; // WSPI bus being used
    uint8_t device; // device id
    uint32_t mode; // clock mode
    uint32_t speed; // clock speed
    uint8_t size_pow2; // size as power of 2
    uint8_t ncs_clk_delay; // number of clk cycles to wait while transitioning NCS

};

class WSPIBus : public DeviceBus
{
public:
    WSPIBus(uint8_t _bus) :
        DeviceBus(APM_SPI_PRIORITY, true),
        bus(_bus) {}

    uint8_t bus;
    WSPIConfig wspicfg;
    bool wspi_started;
};

class WSPIDevice : public AP_HAL::WSPIDevice
{
public:
    static WSPIDevice *from(AP_HAL::WSPIDevice *dev)
    {
        return static_cast<WSPIDevice*>(dev);
    }

    WSPIDevice(WSPIBus &_bus, WSPIDesc &_device_desc) :
        bus(_bus),
        device_desc(_device_desc)
    {}

    bool set_speed(Speed speed) override
    {
        return true;
    }

    PeriodicHandle register_periodic_callback(uint32_t period_usec, PeriodicCb) override
    {
        return nullptr;
    }
    bool adjust_periodic_callback(PeriodicHandle h, uint32_t period_usec) override
    {
        return false;
    }

    /* See AP_HAL::Device::transfer() */
    bool transfer(const uint8_t *send, uint32_t send_len,
                  uint8_t *recv, uint32_t recv_len) override;

    void set_cmd_header(const CommandHeader& cmd_hdr) override;

    AP_HAL::Semaphore* get_semaphore() override
    {
#if !defined(HAL_BOOTLOADER_BUILD)
        // if asking for invalid bus number use bus 0 semaphore
        return &bus.semaphore;
#else
        return nullptr;
#endif
    }

    bool is_busy() override;
    bool acquire_bus(bool acquire);

    // Enters Memory mapped or eXecution In Place or 0-4-4 mode
    bool enter_xip_mode(void** map_ptr) override;
    bool exit_xip_mode() override;

private:
    WSPIBus &bus;
    WSPIDesc &device_desc;
    wspi_command_t mode;
};

class WSPIDeviceManager : public AP_HAL::WSPIDeviceManager
{
public:
    friend class WSPIDevice;

    static WSPIDeviceManager *from(AP_HAL::WSPIDeviceManager *wspi_mgr)
    {
        return static_cast<WSPIDeviceManager*>(wspi_mgr);
    }

    AP_HAL::OwnPtr<AP_HAL::WSPIDevice> get_device(const char *name) override;
private:
    static WSPIDesc device_table[];
    WSPIBus *buses;
};

}

#endif // #if HAL_USE_WSPI == TRUE && defined(HAL_WSPI_DEVICE_LIST)
                                                                                                                                                                                                                                                                                                                                                                            /*
 * The MIT License (MIT)
 *
 * Copyright (c) 2014 Pavel Kirienko
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

/*
 * This file is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This file is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Modified for Ardupilot by Siddharth Bharat Purohit
 */

#pragma once

#include "AP_HAL_ChibiOS.h"

#if HAL_NUM_CAN_IFACES

# if !defined(STM32H7XX)

#include <stdint.h>

namespace ChibiOS
{
namespace bxcan
{

struct TxMailboxType {
    volatile uint32_t TIR;
    volatile uint32_t TDTR;
    volatile uint32_t TDLR;
    volatile uint32_t TDHR;
};

struct RxMailboxType {
    volatile uint32_t RIR;
    volatile uint32_t RDTR;
    volatile uint32_t RDLR;
    volatile uint32_t RDHR;
};

struct FilterRegisterType {
    volatile uint32_t FR1;
    volatile uint32_t FR2;
};

struct CanType {
    volatile uint32_t  MCR;                 /*!< CAN master control register,         Address offset: 0x00          */
    volatile uint32_t  MSR;                 /*!< CAN master status register,          Address offset: 0x04          */
    volatile uint32_t  TSR;                 /*!< CAN transmit status register,        Address offset: 0x08          */
    volatile uint32_t  RF0R;                /*!< CAN receive FIFO 0 register,         Address offset: 0x0C          */
    volatile uint32_t  RF1R;                /*!< CAN receive FIFO 1 register,         Address offset: 0x10          */
    volatile uint32_t  IER;                 /*!< CAN interrupt enable register,       Address offset: 0x14          */
    volatile uint32_t  ESR;                 /*!< CAN error status register,           Address offset: 0x18          */
    volatile uint32_t  BTR;                 /*!< CAN bit timing register,             Address offset: 0x1C          */
    uint32_t           RESERVED0[88];       /*!< Reserved, 0x020 - 0x17F                                            */
    TxMailboxType      TxMailbox[3];        /*!< CAN Tx MailBox,                      Address offset: 0x180 - 0x1AC */
    RxMailboxType      RxMailbox[2];        /*!< CAN FIFO MailBox,                    Address offset: 0x1B0 - 0x1CC */
    uint32_t           RESERVED1[12];       /*!< Reserved, 0x1D0 - 0x1FF                                            */
    volatile uint32_t  FMR;                 /*!< CAN filter master register,          Address offset: 0x200         */
    volatile uint32_t  FM1R;                /*!< CAN filter mode register,            Address offset: 0x204         */
    uint32_t           RESERVED2;           /*!< Reserved, 0x208                                                    */
    volatile uint32_t  FS1R;                /*!< CAN filter scale register,           Address offset: 0x20C         */
    uint32_t           RESERVED3;           /*!< Reserved, 0x210                                                    */
    volatile uint32_t  FFA1R;               /*!< CAN filter FIFO assignment register, Address offset: 0x214         */
    uint32_t           RESERVED4;           /*!< Reserved, 0x218                                                    */
    volatile uint32_t  FA1R;                /*!< CAN filter activation register,      Address offset: 0x21C         */
    uint32_t           RESERVED5[8];        /*!< Reserved, 0x220-0x23F                                              */
    FilterRegisterType FilterRegister[28];  /*!< CAN Filter Register,                 Address offset: 0x240-0x31C   */
};

/* CAN master control register */

constexpr unsigned long MCR_INRQ =            (1U << 0); /* Bit 0: Initialization Request */
constexpr unsigned long MCR_SLEEP =           (1U << 1); /* Bit 1: Sleep Mode Request */
constexpr unsigned long MCR_TXFP =            (1U << 2); /* Bit 2: Transmit FIFO Priority */
constexpr unsigned long MCR_RFLM =            (1U << 3); /* Bit 3: Receive FIFO Locked Mode */
constexpr unsigned long MCR_NART =            (1U << 4); /* Bit 4: No Automatic Retransmission */
constexpr unsigned long MCR_AWUM =            (1U << 5); /* Bit 5: Automatic Wakeup Mode */
constexpr unsigned long MCR_ABOM =            (1U << 6); /* Bit 6: Automatic Bus-Off Management */
constexpr unsigned long MCR_TTCM =            (1U << 7); /* Bit 7: Time Triggered Communication Mode Enable */
constexpr unsigned long MCR_RESET =           (1U << 15);/* Bit 15: bxCAN software master reset */
constexpr unsigned long MCR_DBF =             (1U << 16);/* Bit 16: Debug freeze */

/* CAN master status register */

constexpr unsigned long MSR_INAK =            (1U << 0); /* Bit 0: Initialization Acknowledge */
constexpr unsigned long MSR_SLAK =            (1U << 1); /* Bit 1: Sleep Acknowledge */
constexpr unsigned long MSR_ERRI =            (1U << 2); /* Bit 2: Error Interrupt */
constexpr unsigned long MSR_WKUI =            (1U << 3); /* Bit 3: Wakeup Interrupt */
constexpr unsigned long MSR_SLAKI =           (1U << 4); /* Bit 4: Sleep acknowledge interrupt */
constexpr unsigned long MSR_TXM =             (1U << 8); /* Bit 8: Transmit Mode */
constexpr unsigned long MSR_RXM =             (1U << 9); /* Bit 9: Receive Mode */
constexpr unsigned long MSR_SAMP =            (1U << 10);/* Bit 10: Last Sample Point */
constexpr unsigned long MSR_RX =              (1U << 11);/* Bit 11: CAN Rx Signal */

/* CAN transmit status register */

constexpr unsigned long TSR_RQCP0 =           (1U << 0); /* Bit 0: Request Completed Mailbox 0 */
constexpr unsigned long TSR_TXOK0 =           (1U << 1); /* Bit 1 : Transmission OK of Mailbox 0 */
constexpr unsigned long TSR_ALST0 =           (1U << 2); /* Bit 2 : Arbitration Lost for Mailbox 0 */
constexpr unsigned long TSR_TERR0 =           (1U << 3); /* Bit 3 : Transmission Error of Mailbox 0 */
constexpr unsigned long TSR_ABRQ0 =           (1U << 7); /* Bit 7 : Abort Request for Mailbox 0 */
constexpr unsigned long TSR_RQCP1 =           (1U << 8); /* Bit 8 : Request Completed Mailbox 1 */
constexpr unsigned long TSR_TXOK1 =           (1U << 9); /* Bit 9 : Transmission OK of Mailbox 1 */
constexpr unsigned long TSR_ALST1 =           (1U << 10);/* Bit 10 : Arbitration Lost for Mailbox 1 */
constexpr unsigned long TSR_TERR1 =           (1U << 11);/* Bit 11 : Transmission Error of Mailbox 1 */
constexpr unsigned long TSR_ABRQ1 =           (1U << 15);/* Bit 15 : Abort Request for Mailbox 1 */
constexpr unsigned long TSR_RQCP2 =           (1U << 16);/* Bit 16 : Request Completed Mailbox 2 */
constexpr unsigned long TSR_TXOK2 =           (1U << 17);/* Bit 17 : Transmission OK of Mailbox 2 */
constexpr unsigned long TSR_ALST2 =           (1U << 18);/* Bit 18: Arbitration Lost for Mailbox 2 */
constexpr unsigned long TSR_TERR2 =           (1U << 19);/* Bit 19: Transmission Error of Mailbox 2 */
constexpr unsigned long TSR_ABRQ2 =           (1U << 23);/* Bit 23: Abort Request for Mailbox 2 */
constexpr unsigned long TSR_CODE_SHIFT =      (24U);     /* Bits 25-24: Mailbox Code */
constexpr unsigned long TSR_CODE_MASK =       (3U << TSR_CODE_SHIFT);
constexpr unsigned long TSR_TME0 =            (1U << 26);/* Bit 26: Transmit Mailbox 0 Empty */
constexpr unsigned long TSR_TME1 =            (1U << 27);/* Bit 27: Transmit Mailbox 1 Empty */
constexpr unsigned long TSR_TME2 =            (1U << 28);/* Bit 28: Transmit Mailbox 2 Empty */
constexpr unsigned long TSR_LOW0 =            (1U << 29);/* Bit 29: Lowest Priority Flag for Mailbox 0 */
constexpr unsigned long TSR_LOW1 =            (1U << 30);/* Bit 30: Lowest Priority Flag for Mailbox 1 */
constexpr unsigned long TSR_LOW2 =            (1U << 31);/* Bit 31: Lowest Priority Flag for Mailbox 2 */

/* CAN receive FIFO 0/1 registers */

constexpr unsigned long RFR_FMP_SHIFT =       (0U);      /* Bits 1-0: FIFO Message Pending */
constexpr unsigned long RFR_FMP_MASK =        (3U << RFR_FMP_SHIFT);
constexpr unsigned long RFR_FULL =            (1U << 3); /* Bit 3: FIFO 0 Full */
constexpr unsigned long RFR_FOVR =            (1U << 4); /* Bit 4: FIFO 0 Overrun */
constexpr unsigned long RFR_RFOM =            (1U << 5); /* Bit 5: Release FIFO 0 Output Mailbox */

/* CAN interrupt enable register */

constexpr unsigned long IER_TMEIE =           (1U << 0); /* Bit 0: Transmit Mailbox Empty Interrupt Enable */
constexpr unsigned long IER_FMPIE0 =          (1U << 1); /* Bit 1: FIFO Message Pending Interrupt Enable */
constexpr unsigned long IER_FFIE0 =           (1U << 2); /* Bit 2: FIFO Full Interrupt Enable */
constexpr unsigned long IER_FOVIE0 =          (1U << 3); /* Bit 3: FIFO Overrun Interrupt Enable */
constexpr unsigned long IER_FMPIE1 =          (1U << 4); /* Bit 4: FIFO Message Pending Interrupt Enable */
constexpr unsigned long IER_FFIE1 =           (1U << 5); /* Bit 5: FIFO Full Interrupt Enable */
constexpr unsigned long IER_FOVIE1 =          (1U << 6); /* Bit 6: FIFO Overrun Interrupt Enable */
constexpr unsigned long IER_EWGIE =           (1U << 8); /* Bit 8: Error Warning Interrupt Enable */
constexpr unsigned long IER_EPVIE =           (1U << 9); /* Bit 9: Error Passive Interrupt Enable */
constexpr unsigned long IER_BOFIE =           (1U << 10);/* Bit 10: Bus-Off Interrupt Enable */
constexpr unsigned long IER_LECIE =           (1U << 11);/* Bit 11: Last Error Code Interrupt Enable */
constexpr unsigned long IER_ERRIE =           (1U << 15);/* Bit 15: Error Interrupt Enable */
constexpr unsigned long IER_WKUIE =           (1U << 16);/* Bit 16: Wakeup Interrupt Enable */
constexpr unsigned long IER_SLKIE =           (1U << 17);/* Bit 17: Sleep Interrupt Enable */

/* CAN error status register */

constexpr unsigned long ESR_EWGF =            (1U << 0); /* Bit 0: Error Warning Flag */
constexpr unsigned long ESR_EPVF =            (1U << 1); /* Bit 1: Error Passive Flag */
constexpr unsigned long ESR_BOFF =            (1U << 2); /* Bit 2: Bus-Off Flag */
constexpr unsigned long ESR_LEC_SHIFT =       (4U);      /* Bits 6-4: Last Error Code */
constexpr unsigned long ESR_LEC_MASK =        (7U << ESR_LEC_SHIFT);
constexpr unsigned long ESR_NOERROR =         (0U << ESR_LEC_SHIFT);/* 000: No Error */
constexpr unsigned long ESR_STUFFERROR =      (1U << ESR_LEC_SHIFT);/* 001: Stuff Error */
constexpr unsigned long ESR_FORMERROR =       (2U << ESR_LEC_SHIFT);/* 010: Form Error */
constexpr unsigned long ESR_ACKERROR =        (3U << ESR_LEC_SHIFT);/* 011: Acknowledgment Error */
constexpr unsigned long ESR_BRECERROR =       (4U << ESR_LEC_SHIFT);/* 100: Bit recessive Error */
constexpr unsigned long ESR_BDOMERROR =       (5U << ESR_LEC_SHIFT);/* 101: Bit dominant Error */
constexpr unsigned long ESR_CRCERRPR =        (6U << ESR_LEC_SHIFT);/* 110: CRC Error */
constexpr unsigned long ESR_SWERROR =         (7U << ESR_LEC_SHIFT);/* 111: Set by software */
constexpr unsigned long ESR_TEC_SHIFT =       (16U);     /* Bits 23-16: LS byte of the 9-bit Transmit Error Counter */
constexpr unsigned long ESR_TEC_MASK =        (0xFFU << ESR_TEC_SHIFT);
constexpr unsigned long ESR_REC_SHIFT =       (24U);     /* Bits 31-24: Receive Error Counter */
constexpr unsigned long ESR_REC_MASK =        (0xFFU << ESR_REC_SHIFT);

/* CAN bit timing register */

constexpr unsigned long BTR_BRP_SHIFT =       (0U);      /* Bits 9-0: Baud Rate Prescaler */
constexpr unsigned long BTR_BRP_MASK =        (0x03FFU << BTR_BRP_SHIFT);
constexpr unsigned long BTR_TS1_SHIFT =       (16U);     /* Bits 19-16: Time Segment 1 */
constexpr unsigned long BTR_TS1_MASK =        (0x0FU <<  BTR_TS1_SHIFT);
constexpr unsigned long BTR_TS2_SHIFT =       (20U);     /* Bits 22-20: Time Segment 2 */
constexpr unsigned long BTR_TS2_MASK =        (7U << BTR_TS2_SHIFT);
constexpr unsigned long BTR_SJW_SHIFT =       (24U);     /* Bits 25-24: Resynchronization Jump Width */
constexpr unsigned long BTR_SJW_MASK =        (3U << BTR_SJW_SHIFT);
constexpr unsigned long BTR_LBKM =            (1U << 30);/* Bit 30: Loop Back Mode (Debug);*/
constexpr unsigned long BTR_SILM =            (1U << 31);/* Bit 31: Silent Mode (Debug);*/

constexpr unsigned long BTR_BRP_MAX =         (1024U);   /* Maximum BTR value (without decrement);*/
constexpr unsigned long BTR_TSEG1_MAX =       (16U);     /* Maximum TSEG1 value (without decrement);*/
constexpr unsigned long BTR_TSEG2_MAX =       (8U);      /* Maximum TSEG2 value (without decrement);*/

/* TX mailbox identifier register */

constexpr unsigned long TIR_TXRQ =            (1U << 0); /* Bit 0: Transmit Mailbox Request */
constexpr unsigned long TIR_RTR =             (1U << 1); /* Bit 1: Remote Transmission Request */
constexpr unsigned long TIR_IDE =             (1U << 2); /* Bit 2: Identifier Extension */
constexpr unsigned long TIR_EXID_SHIFT =      (3U);      /* Bit 3-31: Extended Identifier */
constexpr unsigned long TIR_EXID_MASK =       (0x1FFFFFFFU << TIR_EXID_SHIFT);
constexpr unsigned long TIR_STID_SHIFT =      (21U);     /* Bits 21-31: Standard Identifier */
constexpr unsigned long TIR_STID_MASK =       (0x07FFU << TIR_STID_SHIFT);

/* Mailbox data length control and time stamp register */

constexpr unsigned long TDTR_DLC_SHIFT =      (0U);      /* Bits 3:0: Data Length Code */
constexpr unsigned long TDTR_DLC_MASK =       (0x0FU << TDTR_DLC_SHIFT);
constexpr unsigned long TDTR_TGT =            (1U << 8); /* Bit 8: Transmit Global Time */
constexpr unsigned long TDTR_TIME_SHIFT =     (16U);     /* Bits 31:16: Message Time Stamp */
constexpr unsigned long TDTR_TIME_MASK =      (0xFFFFU << TDTR_TIME_SHIFT);

/* Mailbox data low register */

constexpr unsigned long TDLR_DATA0_SHIFT =    (0U);      /* Bits 7-0: Data Byte 0 */
constexpr unsigned long TDLR_DATA0_MASK =     (0xFFU << TDLR_DATA0_SHIFT);
constexpr unsigned long TDLR_DATA1_SHIFT =    (8U);      /* Bits 15-8: Data Byte 1 */
constexpr unsigned long TDLR_DATA1_MASK =     (0xFFU << TDLR_DATA1_SHIFT);
constexpr unsigned long TDLR_DATA2_SHIFT =    (16U);     /* Bits 23-16: Data Byte 2 */
constexpr unsigned long TDLR_DATA2_MASK =     (0xFFU << TDLR_DATA2_SHIFT);
constexpr unsigned long TDLR_DATA3_SHIFT =    (24U);     /* Bits 31-24: Data Byte 3 */
constexpr unsigned long TDLR_DATA3_MASK =     (0xFFU << TDLR_DATA3_SHIFT);

/* Mailbox data high register */

constexpr unsigned long TDHR_DATA4_SHIFT =    (0U);      /* Bits 7-0: Data Byte 4 */
constexpr unsigned long TDHR_DATA4_MASK =     (0xFFU << TDHR_DATA4_SHIFT);
constexpr unsigned long TDHR_DATA5_SHIFT =    (8U);      /* Bits 15-8: Data Byte 5 */
constexpr unsigned long TDHR_DATA5_MASK =     (0xFFU << TDHR_DATA5_SHIFT);
constexpr unsigned long TDHR_DATA6_SHIFT =    (16U);     /* Bits 23-16: Data Byte 6 */
constexpr unsigned long TDHR_DATA6_MASK =     (0xFFU << TDHR_DATA6_SHIFT);
constexpr unsigned long TDHR_DATA7_SHIFT =    (24U);     /* Bits 31-24: Data Byte 7 */
constexpr unsigned long TDHR_DATA7_MASK =     (0xFFU << TDHR_DATA7_SHIFT);

/* Rx FIFO mailbox identifier register */

constexpr unsigned long RIR_RTR =             (1U << 1); /* Bit 1: Remote Transmission Request */
constexpr unsigned long RIR_IDE =             (1U << 2); /* Bit 2: Identifier Extension */
constexpr unsigned long RIR_EXID_SHIFT =      (3U);      /* Bit 3-31: Extended Identifier */
constexpr unsigned long RIR_EXID_MASK =       (0x1FFFFFFFU << RIR_EXID_SHIFT);
constexpr unsigned long RIR_STID_SHIFT =      (21U);     /* Bits 21-31: Standard Identifier */
constexpr unsigned long RIR_STID_MASK =       (0x07FFU << RIR_STID_SHIFT);

/* Receive FIFO mailbox data length control and time stamp register */

constexpr unsigned long RDTR_DLC_SHIFT =      (0U);      /* Bits 3:0: Data Length Code */
constexpr unsigned long RDTR_DLC_MASK =       (0x0FU << RDTR_DLC_SHIFT);
constexpr unsigned long RDTR_FM_SHIFT =       (8U);      /* Bits 15-8: Filter Match Index */
constexpr unsigned long RDTR_FM_MASK =        (0xFFU << RDTR_FM_SHIFT);
constexpr unsigned long RDTR_TIME_SHIFT =     (16U);     /* Bits 31:16: Message Time Stamp */
constexpr unsigned long RDTR_TIME_MASK =      (0xFFFFU << RDTR_TIME_SHIFT);

/* Receive FIFO mailbox data low register */

constexpr unsigned long RDLR_DATA0_SHIFT =    (0U);      /* Bits 7-0: Data Byte 0 */
constexpr unsigned long RDLR_DATA0_MASK =     (0xFFU << RDLR_DATA0_SHIFT);
constexpr unsigned long RDLR_DATA1_SHIFT =    (8U);      /* Bits 15-8: Data Byte 1 */
constexpr unsigned long RDLR_DATA1_MASK =     (0xFFU << RDLR_DATA1_SHIFT);
constexpr unsigned long RDLR_DATA2_SHIFT =    (16U);     /* Bits 23-16: Data Byte 2 */
constexpr unsigned long RDLR_DATA2_MASK =     (0xFFU << RDLR_DATA2_SHIFT);
constexpr unsigned long RDLR_DATA3_SHIFT =    (24U);     /* Bits 31-24: Data Byte 3 */
constexpr unsigned long RDLR_DATA3_MASK =     (0xFFU << RDLR_DATA3_SHIFT);

/* Receive FIFO mailbox data high register */

constexpr unsigned long RDHR_DATA4_SHIFT =    (0U);      /* Bits 7-0: Data Byte 4 */
constexpr unsigned long RDHR_DATA4_MASK =     (0xFFU << RDHR_DATA4_SHIFT);
constexpr unsigned long RDHR_DATA5_SHIFT =    (8U);      /* Bits 15-8: Data Byte 5 */
constexpr unsigned long RDHR_DATA5_MASK =     (0xFFU << RDHR_DATA5_SHIFT);
constexpr unsigned long RDHR_DATA6_SHIFT =    (16U);     /* Bits 23-16: Data Byte 6 */
constexpr unsigned long RDHR_DATA6_MASK =     (0xFFU << RDHR_DATA6_SHIFT);
constexpr unsigned long RDHR_DATA7_SHIFT =    (24U);     /* Bits 31-24: Data Byte 7 */
constexpr unsigned long RDHR_DATA7_MASK =     (0xFFU << RDHR_DATA7_SHIFT);

/* CAN filter master register */

constexpr unsigned long FMR_FINIT =           (1U << 0); /* Bit 0:  Filter Init Mode */

}
}

#endif //!defined(STM32H7XX)
#endif //HAL_NUM_CAN_IFACES
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                # 3DR (mRo) Control Zero H7 OEM Flight Controller revision G

The Control Zero H7 OEM revision G is a flight controller produced by [3DR (mRo)](https://store.3dr.com/control-zero-h7-oem-g/).

![3DR Control Zero H7 OEM rev G - Top](https://vddwxegfxugwzpfnrrlp.supabase.co/storage/v1/object/public/Website-CDN/autopilot-img/CZOEM_revG_front.JPG)
![3DR Control Zero H7 OEM rev G - Bottom](https://vddwxegfxugwzpfnrrlp.supabase.co/storage/v1/object/public/Website-CDN/autopilot-img/CZOEM_revG_back.JPG?t=2024-03-08T20%3A18%3A49.140Z)
![3DR Control Zero H7 OEM rev G - Top w/ case](https://vddwxegfxugwzpfnrrlp.supabase.co/storage/v1/object/public/Website-CDN/autopilot-img/CZOEM_revG_case_front.JPG?t=2024-03-08T20%3A18%3A57.128Z)
![3DR Control Zero H7 OEM rev G - Bottomi w/ case](https://vddwxegfxugwzpfnrrlp.supabase.co/storage/v1/object/public/Website-CDN/autopilot-img/CZOEM_revG_case.jpg?t=2024-03-08T20%3A18%3A52.750Z)

## Features

	Processor
		STM32H743IIK6 32-bit Processor
	Sensors
		BMI088 6DOF
		ICM20602 6DOF
		ICM20948 9DOF
		DPS368 Baro
	Power
		External Power Supply
		Logic level at 3.3V
	Interfaces
		Bottom Connectors: 36pin front and 40pin back Samtec FTM-118-02-x and FTM-120-02-x
		8x PWM / IO - DMA capable
		1x RC Input 
		5x UARTs (2x with hardware flow control)
		2x CAN
		1x SPI
		3x I2C
		SWD via TC2030 header
		SDCARD Socket
	Memory
		FRAM (256KB)
	Miscellaneous
		Onboard 3 color LED
		Buzzer
		Safety Button


###  Uncased Weight and Dimensions

 Weight: 3.66g (13.oz)
 Width:  20mm (.79in)
 Length: 34mm (1.34in)

 *Case sold separately*

## Changelog

- M10059C - Initial Release
- M10059G adds external power supply and TCXO.

## Pinout

![Control Zero H7 OEM revision G pinout](https://vddwxegfxugwzpfnrrlp.supabase.co/storage/v1/object/public/Website-CDN/pinouts/czoem_pinout_revG_topview.png)

## UART Mapping

- SERIAL0 -> USB1, for GCS connection

- SERIAL1 -> USART2 (TELEM 1) DMA Enabled

- SERIAL2 -> USART3 (TELEM 2) DMA Enabled

- SERIAL3 -> UART4 (GPS) DMA Enabled

- SERIAL4 -> UART8 (GPS 2) DMA Enabled

- SERIAL5 -> UART7 (DEBUG) DMA Enabled

- SERIAL6 -> USART6 (Additional USART) DMA Enabled

- SERIAL7 -> USB2, MAVLink interface

## RC Input

RC input is configured on the RC_IN pin. These are the supported RC input protocols: 

Spektrum DSM / DSM2 / DSM-X Satellite compatible input and binding. 
Futaba S.BUS & S.BUS2 compatible input. 
Graupner SUMD. Yuneec ST24.

## Analog Inputs

The Control Zero H7 OEM revision G has 4 ADC inputs:

- ADC1 Pin11 -> RSSI IN
- ADC1 Pin14 -> Battery Voltage
- ADC1 Pin15 -> Battery Current
- ADC1 Pin18 -> 5V Sensor

## PWM Output

The Control Zero H7 OEM revision G supports up to 8 PWM outputs. All DShot and BiDirDShot capable.

The PWM outputs are distributed in 3 groups:

- PWM 1-4 in group 1
- PWM 5-6 in group 4
- PWM 7-8 in group 8

Channels within the same group must use only one output rate. If any channel is using DShot or BiDirDShot the rest of the group will use the said output type.

## Power Supply

This board requires a 5V, 1 Amps power supply.

## Battery Monitoring

This board has a built-in voltage and current sensors. The following settings need to be present already on the board to work with a Power Zero Module (M10077):

- BATT_MONITOR 4
- BATT_VOLT_PIN 14
- BATT_CURR_PIN 15
- BATT_VOLT_SCALE 15.3
- BATT_CURR_SCALE 50.0

*Other Power Module needs to be adjusted accordingly*

## Build

`./waf configure --board=3DRControlZeroG`

`./waf copter` (check ArduPilot's docs for more info about the available targets)

The compiled binary will be located in `build/3DRControlZeroG/bin/arducopter.apj`.

## Uploading Firmware

Any Control Zero H7 OEM revision G has a preloaded Ardupilot bootloader, which allows the user to use a compatible Ground Station software to upload the `.apj` file.  
                                                                                                                                                                                                                                                                                         #Default Parameters for the mRo Control Zero OEM H7

CAN_P1_DRIVER 1
CAN_P2_DRIVER 2
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           # MCU class and specific type
MCU STM32H7xx STM32H743xx

# USB setup
USB_VENDOR 0x26ac
USB_PRODUCT 0x1124
USB_STRING_MANUFACTURER "3DR"
USB_STRING_PRODUCT "CZOEMrevG"

# crystal frequency
OSCILLATOR_HZ 24000000
define STM32_HSE_BYPASS
define SMPS_EXT

# board ID for firmware load
APJ_BOARD_ID 1124

FLASH_SIZE_KB 2048

# bootloader is installed at zero offset
FLASH_RESERVE_START_KB 0

# the location where the bootloader will put the firmware
FLASH_BOOTLOADER_LOAD_KB 128

PB11 LED_BOOTLOADER OUTPUT

PH5 VDD_1V2_CORE_EN OUTPUT HIGH

# define all 3 to make LED output White.
PB1 LED_ACTIVITY OUTPUT
PB3 LED_ACTIVITY2 OUTPUT
# PB11 LED_ACTIVITY3 OUTPUT

define HAL_LED_ON 0

# order of UARTs (and USB)
SERIAL_ORDER OTG1 USART2

PD5 USART2_TX USART2
PD6 USART2_RX USART2
PD3 USART2_CTS USART2
PD4 USART2_RTS USART2

PA11 OTG_FS_DM OTG1
PA12 OTG_FS_DP OTG1

PA13 JTMS-SWDIO SWD
PA14 JTCK-SWCLK SWD

# Add CS pins to ensure they are high in bootloader
PC2  ICM_20602_CS CS
PD7  BARO_CS CS
PD10 FRAM_CS CS SPEED_VERYLOW NODMA
PE15 ICM_20948_CS CS
PF6  BMI088_ACCEL_CS CS
PF10 BMI088_GYRO_CS CS
#PG9 EXTERNAL CS
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            # MCU class and specific type
MCU STM32H7xx STM32H743xx

# board ID for firmware load
APJ_BOARD_ID 1124

# crystal frequency
OSCILLATOR_HZ 24000000
define STM32_HSE_BYPASS
define SMPS_EXT

FLASH_SIZE_KB 2048

# with 2M flash we can afford to optimize for speed
env OPTIMIZE -O2

# start on 2th sector (1st sector for bootloader)
FLASH_RESERVE_START_KB 128

define HAL_STORAGE_SIZE 32768

# USB setup
USB_VENDOR 0x26ac
USB_PRODUCT 0x1124
USB_STRING_MANUFACTURER "3DR"
USB_STRING_PRODUCT "CZOEMrevG"

PA8 RCC_MCO_1 OUTPUT LOW

PH5 VDD_1V2_CORE_EN OUTPUT HIGH

# RC Input set for Interrupt not DMA
PC7 TIM3_CH2 TIM3 RCININT PULLDOWN LOW

# GPIO(70) # also USART6_RX for serial RC

# Control of Spektrum power pin
PE4 SPEKTRUM_PWR OUTPUT LOW GPIO(70)
define HAL_GPIO_SPEKTRUM_PWR 70

# Spektrum Power is Active High
define HAL_SPEKTRUM_PWR_ENABLED 0

# Spektrum RC Input pin, used as GPIO for bind for Satellite Receivers
PB0 SPEKTRUM_RC INPUT PULLUP GPIO(71)
define HAL_GPIO_SPEKTRUM_RC 71

# Order of I2C buses
I2C_ORDER I2C1 I2C3 I2C4

# this board has no internal I2C buses so mark them all external
define HAL_I2C_INTERNAL_MASK 0

# order of UARTs and suggested uses
# USART2 TELEM1
# USART3 TELEM2
# UART4 GPS
# UART8 GPS2 
# UART7 DEBUG

# USART6 RC input (Only RX pin is connected)

# OTG1 and OTG2 are USB devices (1x physical USB connection enumerated as 2x logical ports)

SERIAL_ORDER OTG1 USART2 USART3 UART4 UART8 UART7 USART6 OTG2

# Another USART, this one for telem1. This one has RTS and CTS lines.
# USART2 telem1
PD5 USART2_TX USART2
PD6 USART2_RX USART2
PD3 USART2_CTS USART2
PD4 USART2_RTS USART2

# The telem2 USART, with RTS and CTS lines.
# USART3 telem2
PD8 USART3_TX USART3
PD9 USART3_RX USART3
PD11 USART3_CTS USART3
PD12 USART3_RTS USART3

# UART4 GPS
PA0 UART4_TX UART4
PA1 UART4_RX UART4

# UART7
PE8 UART7_TX UART7 NODMA
PE7 UART7_RX UART7 NODMA

# USART6
PG14 USART6_TX USART6
PG9  USART6_RX USART6
PG13 USART6_CTS USART6
PG12 USART6_RTS USART6

# UART8 GPS2
PE1 UART8_TX UART8
PE0 UART8_RX UART8

# RSSI Analog Input
PC1 RSSI_IN ADC1

# Safety Switch Input
PC4 SAFETY_IN INPUT PULLDOWN
define HAL_HAVE_SAFETY_SWITCH 1

# Battery Analog Sense Pins
PA2 BATT_VOLTAGE_SENS ADC1 SCALE(1)
PA3 BATT_CURRENT_SENS ADC1 SCALE(1)

# Now the VDD sense pin. This is used to sense primary board voltage.
PA4 VDD_5V_SENS ADC1 SCALE(2)

# Now setup the default battery pins driver analog pins and default
# scaling for the power brick (Adjusted for Power Zero - M10077).
define HAL_BATT_VOLT_PIN 14
define HAL_BATT_CURR_PIN 15
define HAL_BATT_VOLT_SCALE 15.3
define HAL_BATT_CURR_SCALE 50.0

#SPI1 ICM_20602 / ICM_20948
PA5 SPI1_SCK SPI1
PA6 SPI1_MISO SPI1
PA7 SPI1_MOSI SPI1

#SPI2 FRAM / DPS310
PB10 SPI2_SCK SPI2
PB14 SPI2_MISO SPI2
PB15 SPI2_MOSI SPI2

#SPI5 BMI088
PF7 SPI5_SCK SPI5
PF8 SPI5_MISO SPI5
PF9 SPI5_MOSI SPI5

#SPI6 External
#PG13 SPI6_SCK SPI6
#PG12 SPI6_MISO SPI6
#PG14 SPI6_MOSI SPI6

# This is the pin that senses USB being connected. It is an input pin
# setup as OPENDRAIN.
PA9 VBUS INPUT OPENDRAIN

# This input pin is used to detect that power is valid on USB.
PC0 VBUS_VALID INPUT PULLDOWN

# Now we define the pins that USB is connected on.
PA11 OTG_FS_DM OTG1
PA12 OTG_FS_DP OTG1

# These are the pins for SWD debugging with a STlinkv2 or black-magic probe.
PA13 JTMS-SWDIO SWD
PA14 JTCK-SWCLK SWD

# PWM output for buzzer
PA15 TIM2_CH1 TIM2 GPIO(77) ALARM

# First I2C bus.
PB8 I2C1_SCL I2C1
PB9 I2C1_SDA I2C1

# Second I2C bus.
PH7 I2C3_SCL I2C3
PH8 I2C3_SDA I2C3

# Third I2C bus.
PB6 I2C4_SCL I2C4
PB7 I2C4_SDA I2C4

# microSD card
PC8 SDMMC1_D0 SDMMC1
PC9 SDMMC1_D1 SDMMC1
PC10 SDMMC1_D2 SDMMC1
PC11 SDMMC1_D3 SDMMC1
PC12 SDMMC1_CK SDMMC1
PD2 SDMMC1_CMD SDMMC1

# CS pins for SPI sensors. The labels for all CS pins need to
# match the SPI device table later in this file.
PC2 ICM_20602_CS CS
PD7 BARO_CS CS
PD10 FRAM_CS CS SPEED_VERYLOW NODMA
PE15 ICM_20948_CS CS
PF6 BMI088_ACCEL_CS CS
PF10 BMI088_GYRO_CS CS
#PG9 EXTERNAL CS

# CAN Busses
PD0 CAN1_RX CAN1
PD1 CAN1_TX CAN1

PB13 CAN2_TX CAN2
PB12 CAN2_RX CAN2

# CAN Silent Pins LOW Enable
PF5 GP