(1u << i) & srxlRx.pBindRcvr->busBits)
            {
                srxlBus[i].txFlags.enterBind = 1;
                return true;
            }
        }
    }

    return false;
}

/**
    @brief  Public function to set bind info for the system, either locally or via SRXL commands

    @param  bindType: Type of bind requested for this receiver or all receivers
    @param  guid: Transmitter GUID to bind the receiver to
    @param  uid: Unique ID provided by transmitter upon initial bind (can be 0 if unknown)
    @return bool: True if bind info was successfully set for the destination device; else false
*/
bool srxlSetBindInfo(uint8_t bindType, uint64_t guid, uint32_t uid)
{
    if(guid == 0)
        return false;

    // Set bind info, with options defaulted to 0
    srxlBindInfo.type = bindType;
    srxlBindInfo.options = SRXL_BIND_OPT_US_POWER; // Request US power, with no guarantee it's supported
    srxlBindInfo.guid = guid;
    srxlBindInfo.uid = uid ? uid : srxlThisDev.uid;

#ifdef SRXL_INCLUDE_MASTER_CODE
    // If we are a receiver
    if(srxlThisDev.pRcvr)
    {
        // Bind locally, which will result in no further packets since options == 0
        srxlTryToBind(srxlBindInfo);
    }
#endif

    // Broadcast this bind info on all SRXL buses
    uint8_t b;
    for(b = 0; b < SRXL_NUM_OF_BUSES; ++b)
    {
        srxlBus[b].txFlags.broadcastBindInfo = 1;
    }

    return true;
}

/**
    @brief  Public function to call from the user UART code when a UART frame error occurs

    @param  busIndex: Index of SRXL bus state information entry in the srxlBus array
*/
void srxlOnFrameError(uint8_t busIndex)
{
    SrxlBus* pBus = &srxlBus[busIndex];
    if(busIndex >= SRXL_NUM_OF_BUSES || !pBus->initialized)
        return;

    ++(pBus->frameErrCount);
    if(pBus->master)
    {
        // TODO: If master (i.e. remote receiver 0x10), cause break condition to force reset?
        return;
    }

    if(pBus->state == SrxlState_ListenOnStartup || pBus->state == SrxlState_ListenForHandshake)
    {
        // Wait for multiple frame breaks before trying to change baud rate
        if(pBus->frameErrCount < 3)
            return;

        // Try the next higher baud rate
        switch(pBus->baudRate)
        {
        case SRXL_BAUD_115200:
        {
            if(pBus->baudSupported & SRXL_BAUD_400000)
            {
                srxlChangeBaudRate(pBus->uart, 400000);
                pBus->baudRate = SRXL_BAUD_400000;
                break;
            }
            FALLTHROUGH;
            // else fall thru...
        }
        case SRXL_BAUD_400000:
        default:
        {
            // TODO: Cause break condition to force reset of everyone? Or just keep cycling?

            srxlChangeBaudRate(pBus->uart, 115200);
            pBus->baudRate = SRXL_BAUD_115200;
            break;
        }
        }
        pBus->frameErrCount = 0;
    }
    else
    {
        // TODO: Handle frame error during normal comm -- probably caused by collision on bus?
    }
}

SrxlFullID srxlGetTelemetryEndpoint(void)
{
    SrxlFullID retVal = {0};
    if(srxlRx.pTelemRcvr)
    {
        retVal.deviceID = srxlRx.pTelemRcvr->deviceID;
        retVal.busIndex = srxlRx.pTelemRcvr->busBits;
    }
    return retVal;
}

bool srxlSetVtxData(SrxlVtxData* pVtxData)
{
    if(!pVtxData)
        return false;

    // Update VTX data, ignoring values marked as unchanged
    if(pVtxData->band != 0xFF)
        srxlVtxData.band = pVtxData->band;
    if(pVtxData->channel != 0xFF)
        srxlVtxData.channel = pVtxData->channel;
    if(pVtxData->pit != 0xFF)
        srxlVtxData.pit = pVtxData->pit;
    if(pVtxData->power != 0xFF || pVtxData->powerDec != 0xFFFF)
        srxlVtxData.power = pVtxData->power;
    if(pVtxData->powerDec != 0xFFFF)
        srxlVtxData.powerDec = pVtxData->powerDec;
    if(pVtxData->region != 0xFF)
        srxlVtxData.region = pVtxData->region;

    uint8_t b;
    for(b = 0; b < SRXL_NUM_OF_BUSES; ++b)
    {
        srxlBus[b].txFlags.sendVtxData = 1;
    }

    return true;
}

void srxlSetHoldThreshold(uint8_t countdownReset/*
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/
#pragma once

#include "AP_RCTelemetry_config.h"

#if HAL_CRSF_TELEM_ENABLED

#include <AP_OSD/AP_OSD.h>
#include <AP_RCProtocol/AP_RCProtocol_CRSF.h>
#include "AP_RCTelemetry.h"
#include <AP_HAL/utility/sparse-endian.h>

class AP_OSD_ParamSetting;

class AP_CRSF_Telem : public AP_RCTelemetry {
public:
    AP_CRSF_Telem();
    ~AP_CRSF_Telem() override;

    /* Do not allow copies */
    CLASS_NO_COPY(AP_CRSF_Telem);

    // init - perform required initialisation
    virtual bool init() override;

    static AP_CRSF_Telem *get_singleton(void);
    void queue_message(MAV_SEVERITY severity, const char *text) override;

    static const uint8_t PASSTHROUGH_STATUS_TEXT_FRAME_MAX_SIZE = 50U;
    static const uint8_t PASSTHROUGH_MULTI_PACKET_FRAME_MAX_SIZE = 9U;
    static const uint8_t CRSF_RX_DEVICE_PING_MAX_RETRY = 50U;

    // Broadcast frame definitions courtesy of TBS
    struct PACKED GPSFrame {   // curious fact, calling this GPS makes sizeof(GPS) return 1!
        int32_t latitude; // ( degree / 10`000`000 )
        int32_t longitude; // (degree / 10`000`000 )
        uint16_t groundspeed; // ( km/h / 100 )
        uint16_t gps_heading; // ( degree / 100 )
        uint16_t altitude; // ( meter - 1000m offset )
        uint8_t satellites; // in use ( counter )
    };

    struct HeartbeatFrame {
        uint8_t origin; // Device address
    };

    struct PACKED BatteryFrame {
        uint16_t voltage; // ( mV * 100 )
        uint16_t current; // ( mA * 100 )
        uint8_t capacity[3]; // ( mAh )
        uint8_t remaining; // ( percent )
    };

    struct PACKED BaroVarioFrame {
        uint16_t altitude_packed; // Altitude above start (calibration) point.
        int8_t vertical_speed_packed; // vertical speed.
    };

    struct PACKED VarioFrame {
        int16_t v_speed; // vertical speed cm/s
    };

    struct PACKED VTXFrame {
#if __BYTE_ORDER != __LITTLE_ENDIAN
#error "Only supported on little-endian architectures"
#endif
        uint8_t origin; // address
        // status
        uint8_t is_in_pitmode : 1;
        uint8_t is_in_user_frequency_mode : 1;
        uint8_t unused : 2;
        uint8_t is_vtx_available : 1;
        uint8_t smart_audio_ver : 3;    // SmartAudio_V1 = 0, SmartAudio_V2 = 1
        // band / channel
        uint8_t channel : 3;            // 1x-8x
        uint8_t band : 5;               // A, B, E, AirWave, Race
        uint16_t user_frequency;
        uint8_t power : 4;              // 25mW = 0, 200mW = 1, 500mW = 2, 800mW = 3
        uint8_t pitmode : 4;            // off = 0, In_Band = 1, Out_Band = 2;
    };

    struct PACKED VTXTelemetryFrame {
        uint8_t origin; // address
        uint8_t power;              // power in dBm
        uint16_t frequency;         // frequency in Mhz
        uint8_t pitmode;            // disable 0, enable 1
    };

    struct PACKED AttitudeFrame {
        int16_t pitch_angle; // ( rad * 10000 )
        int16_t roll_angle; // ( rad * 10000 )
        int16_t yaw_angle; // ( rad * 10000 )
    };

    struct PACKED FlightModeFrame {
        char flight_mode[16]; // ( Null-terminated string )
    };

    // CRSF_FRAMETYPE_COMMAND
    struct PACKED CommandFrame {
        uint8_t destination;
        uint8_t origin;
        uint8_t command_id;
        uint8_t payload[9]; // 8 maximum for LED command + crc8
    };

    // CRSF_FRAMETYPE_PARAM_DEVICE_PING
    struct PACKED ParameterPingFrame {
        uint8_t destination;
        uint8_t origin;
    };

    // CRSF_FRAMETYPE_PARAM_DEVICE_INFO
    struct PACKED ParameterDeviceInfoFrame {
        uint8_t destination;
        uint8_t origin;
        uint8_t payload[58];   // largest possible frame is 60
    };

    enum ParameterType : uint8_t
    {
        UINT8 = 0,
        INT8 = 1,
        UINT16 = 2,
        INT16 = 3,
        FLOAT = 8,
        TEXT_SELECTION = 9,
        STRING = 10,
        FOLDER = 11,
        INFO = 12,
        COMMAND = 13,
        OUT_OF_RANGE = 127
    };

    // CRSF_FRAMETYPE_PARAMETER_SETTINGS_ENTRY
    struct PACKED ParameterSettingsEntryHeader {
        uint8_t destination;
        uint8_t origin;
        uint8_t param_num;
        uint8_t chunks_left;
    };

    // CRSF_FRAMETYPE_PARAMETER_SETTINGS_ENTRY
    struct PACKED ParameterSettingsEntry {
        ParameterSettingsEntryHeader header;
        uint8_t payload[56];   // largest possible frame is 60
    };

    // CRSF_FRAMETYPE_PARAMETER_READ
    struct PACKED ParameterSettingsReadFrame {
        uint8_t destination;
        uint8_t origin;
        uint8_t param_num;
        uint8_t param_chunk;
    } _param_request;

    // CRSF_FRAMETYPE_PARAMETER_WRITE
    struct PACKED ParameterSettingsWriteFrame {
        uint8_t destination;
        uint8_t origin;
        uint8_t param_num;
        uint8_t payload[57];   // largest possible frame is 60
    };

    // Frame to hold passthrough telemetry
    struct PACKED PassthroughSinglePacketFrame {
        uint8_t sub_type;
        uint16_t appid;
        uint32_t data;
    };

    // Frame to hold passthrough telemetry
    struct PACKED PassthroughMultiPacketFrame {
        uint8_t sub_type;
        uint8_t size;
        struct PACKED PassthroughTelemetryPacket {
            uint16_t appid;
            uint32_t data;
        } packets[PASSTHROUGH_MULTI_PACKET_FRAME_MAX_SIZE];
    };

    // Frame to hold status text message
    struct PACKED StatusTextFrame {
        uint8_t sub_type;
        uint8_t severity;
        char text[PASSTHROUGH_STATUS_TEXT_FRAME_MAX_SIZE];  // ( Null-terminated string )
    };

    // ardupilot frametype container
    union PACKED APCustomTelemFrame {
        PassthroughSinglePacketFrame single_packet_passthrough;
        PassthroughMultiPacketFrame multi_packet_passthrough;
        StatusTextFrame status_text;
    };


    union PACKED BroadcastFrame {
        GPSFrame gps;
        HeartbeatFrame heartbeat;
        BaroVarioFrame baro_vario;
        VarioFrame vario;
        BatteryFrame battery;
        VTXFrame vtx;
        AttitudeFrame attitude;
        FlightModeFrame flightmode;
        APCustomTelemFrame custom_telem;
    };

    union PACKED ExtendedFrame {
        CommandFrame command;
        ParameterPingFrame ping;
        ParameterDeviceInfoFrame info;
        ParameterSettingsEntry param_entry;
        ParameterSettingsReadFrame param_read;
        ParameterSettingsWriteFrame param_write;
    };

    union PACKED TelemetryPayload {
        BroadcastFrame bcast;
        ExtendedFrame ext;
    };

    // get the protocol string
    const char* get_protocol_string() const { return AP::crsf()->get_protocol_string(_crsf_version.protocol); }

    // is the current protocol ELRS?
    bool is_elrs() const { return _crsf_version.protocol == AP_RCProtocol_CRSF::ProtocolType::PROTOCOL_ELRS; }
    // is the current protocol Tracer?
    bool is_tracer() const { return _crsf_version.protocol == AP_RCProtocol_CRSF::ProtocolType::PROTOCOL_TRACER; }

    // Process a frame from the CRSF protocol decoder
    static bool process_frame(AP_RCProtocol_CRSF::FrameType frame_type, void* data);
    // get next telemetry data for external consumers of SPort data
    static bool get_telem_data(AP_RCProtocol_CRSF::Frame* frame, bool is_tx_active);
    // start bind request
    void start_bind() { _bind_request_pending = true; }

private:

    enum SensorType {
        HEARTBEAT,
        PARAMETERS,
        BARO_VARIO,
        VARIO,
        ATTITUDE,
        VTX_PARAMETERS,
        BATTERY,
        GPS,
        FLIGHT_MODE,
        PASSTHROUGH,
        STATUS_TEXT,
        GENERAL_COMMAND,
        VERSION_PING,
        DEVICE_PING,
        NUM_SENSORS
    };

    // passthrough WFQ scheduler
    bool is_packet_ready(uint8_t idx, bool queue_empty) override;
    void process_packet(uint8_t idx) override;
    void adjust_packet_weight(bool queue_empty) override;
    void setup_custom_telemetry();
    void update_custom_telemetry_rates(const AP_RCProtocol_CRSF::RFMode rf_mode);

    void calc_parameter_ping();
    void calc_heartbeat();
    void calc_battery();
    uint16_t get_altitude_packed();
    int8_t get_vertical_speed_packed();
    void calc_baro_vario();
    void calc_vario();
    void calc_gps();
    void calc_attitude();
    void calc_flight_mode();
    void calc_device_info();
    void calc_device_ping(uint8_t destination);
    void calc_command_response();
    void calc_bind();
    void calc_parameter();
#if HAL_CRSF_TELEM_TEXT_SELECTION_ENABLED
    void calc_text_selection( AP_OSD_ParamSetting* param, uint8_t chunk);
#endif
    void process_pending_requests();
    void update_vtx_params();
    void get_single_packet_passthrough_telem_data();
    void get_multi_packet_passthrough_telem_data(uint8_t size = PASSTHROUGH_MULTI_PACKET_FRAME_MAX_SIZE);
    void calc_status_text();
    bool process_rf_mode_changes();
    uint8_t get_custom_telem_frame_id() const;
    AP_RCProtocol_CRSF::RFMode get_rf_mode() const;
    uint16_t get_telemetry_rate() const;
    bool is_high_speed_telemetry(const AP_RCProtocol_CRSF::RFMode rf_mode) const;

    void process_vtx_frame(VTXFrame* vtx);
    void process_vtx_telem_frame(VTXTelemetryFrame* vtx);
    void process_ping_frame(ParameterPingFrame* ping);
    void process_param_read_frame(ParameterSettingsReadFrame* read);
    void process_param_write_frame(ParameterSettingsWriteFrame* write);
    void process_device_info_frame(ParameterDeviceInfoFrame* info);
    void process_command_frame(CommandFrame* command);

    // setup ready for passthrough operation
    void setup_wfq_scheduler(void) override;

    // setup the scheduler for parameters download
    void enter_scheduler_params_mode();
    void exit_scheduler_params_mode();
    void disable_tx_entries();
    void enable_tx_entries();

    // get next telemetry data for external consumers
    bool _get_telem_data(AP_RCProtocol_CRSF::Frame* data, bool is_tx_active);
    bool _process_frame(AP_RCProtocol_CRSF::FrameType frame_type, void* data);

    TelemetryPayload _telem;
    uint8_t _telem_size;
    uint8_t _telem_type;
    AP_RCProtocol_CRSF::RFMode _telem_rf_mode;
    // reporting telemetry rate
    uint32_t _telem_last_report_ms;
    uint16_t _telem_last_avg_rate;
    // do we need to report the initial state
    bool _telem_bootstrap_msg_pending;

    bool _telem_is_high_speed;
    bool _telem_pending;
    bool _enable_telemetry;
    // used to limit telemetry when in a failsafe condition
    bool _is_tx_active;

    struct {
        uint8_t destination = AP_RCProtocol_CRSF::CRSF_ADDRESS_BROADCAST;
        uint8_t frame_type;
    } _pending_request;

    struct {
        uint8_t minor;
        uint8_t major;
        uint8_t retry_count;
        bool use_rf_mode;
        AP_RCProtocol_CRSF::ProtocolType protocol;
        bool pending = true;
        uint32_t last_request_info_ms;
    } _crsf_version;

    struct {
        bool init_done;
        uint32_t params_mode_start_ms;
        bool params_mode_active;
    } _custom_telem;

    struct {
        bool pending;
        bool valid;
        uint8_t port_id;
    } _baud_rate_request;

    bool _bind_request_pending;

    // vtx state
    bool _vtx_freq_update;  // update using the frequency method or not
    bool _vtx_dbm_update; // update using the dbm method or not
    bool _vtx_freq_change_pending; // a vtx command has been issued but not confirmed by a vtx broadcast frame
    bool _vtx_power_change_pending;
    bool _vtx_options_change_pending;

    bool _noted_lq_as_rssi_active;

    static AP_CRSF_Telem *singleton;
};

namespace AP {
    AP_CRSF_Telem *crsf_telem();
};

#endif
                      /*
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "AP_RCTelemetry_config.h"

#if AP_GHST_TELEM_ENABLED

#include "AP_GHST_Telem.h"
#include <AP_VideoTX/AP_VideoTX.h>
#include <AP_HAL/utility/sparse-endian.h>
#include <AP_BattMonitor/AP_BattMonitor.h>
#include <AP_GPS/AP_GPS.h>
#include <GCS_MAVLink/GCS.h>
#include <AP_RCProtocol/AP_RCProtocol_GHST.h>
#include <AP_SerialManager/AP_SerialManager.h>
#include <AP_Compass/AP_Compass.h>
#include <AP_Baro/AP_Baro.h>
#include <AP_AHRS/AP_AHRS.h>
#include <AP_Notify/AP_Notify.h>
#include <math.h>
#include <stdio.h>
#include <AP_HAL/AP_HAL.h>
#include <AP_Vehicle/AP_Vehicle_Type.h>

//#define GHST_DEBUG
#ifdef GHST_DEBUG
# define debug(fmt, args...)	hal.console->printf("GHST: " fmt "\n", ##args)
#else
# define debug(fmt, args...)	do {} while(0)
#endif

extern const AP_HAL::HAL& hal;

AP_GHST_Telem *AP_GHST_Telem::singleton;

AP_GHST_Telem::AP_GHST_Telem() : AP_RCTelemetry(0)
{
    singleton = this;
}

AP_GHST_Telem::~AP_GHST_Telem(void)
{
    singleton = nullptr;
}

bool AP_GHST_Telem::init(void)
{
    // sanity check that we are using a UART for RC input
    if (!AP::serialmanager().have_serial(AP_SerialManager::SerialProtocol_RCIN, 0)) {
        return false;
    }

    return AP_RCTelemetry::init();
}

/*
  setup ready for passthrough telem
 */
void AP_GHST_Telem::setup_wfq_scheduler(void)
{
    // initialize packet weights for the WFQ scheduler
    // priority[i] = 1/_scheduler.packet_weight[i]
    // rate[i] = LinkRate * ( priority[i] / (sum(priority[1-n])) )

    // CRSF telemetry rate is 150Hz (4ms) max, so these rates must fit
    add_scheduler_entry(50, 120);   // Attitude and compass 8Hz
    add_scheduler_entry(200, 1000); // VTX parameters    1Hz
    add_scheduler_entry(1300, 500); // battery           2Hz
    add_scheduler_entry(550, 280);  // GPS               3Hz
    add_scheduler_entry(550, 280);  // GPS2              3Hz
}

void AP_GHST_Telem::update_custom_telemetry_rates(AP_RCProtocol_GHST::RFMode rf_mode)
{
    if (is_high_speed_telemetry(rf_mode)) {
        // standard telemetry for high data rates
        set_scheduler_entry(BATTERY, 1000, 1000);       // 1Hz
        set_scheduler_entry(ATTITUDE, 1000, 1000);      // 1Hz
        // custom telemetry for high data rates
        set_scheduler_entry(GPS, 550, 500);            // 2.0Hz
        set_scheduler_entry(GPS2, 550, 500);            // 2.0Hz
    } else {
        // standard telemetry for low data rates
        set_scheduler_entry(BATTERY, 1000, 2000);       // 0.5Hz
        set_scheduler_entry(ATTITUDE, 1000, 3000);      // 0.33Hz
        // GHST custom telemetry for low data rates
        set_scheduler_entry(GPS, 550, 1000);              // 1.0Hz
        set_scheduler_entry(GPS2, 550, 1000);              // 1.0Hz
    }
}

bool AP_GHST_Telem::process_rf_mode_changes()
{
    const AP_RCProtocol_GHST::RFMode current_rf_mode = get_rf_mode();
    uint32_t now = AP_HAL::millis();

    AP_RCProtocol_GHST* ghost = AP::ghost();
    AP_HAL::UARTDriver* uart = nullptr;
    if (ghost != nullptr) {
        uart = ghost->get_UART();
    }

    if (uart == nullptr) {
        return true;
    }

    if (!ghost->is_detected()) {
        return false;
    }
    // not ready yet
    if (!uart->is_initialized()) {
        return false;
    }
#if !defined (STM32H7)
    // warn the user if their setup is sub-optimal, H7 does not need DMA on serial port
    if (_telem_bootstrap_msg_pending && !uart->is_dma_enabled()) {
        GCS_SEND_TEXT(MAV_SEVERITY_WARNING, "%s: running on non-DMA serial port", get_protocol_string());
    }
#endif
    // note if option was set to show LQ in place of RSSI
    bool current_lq_as_rssi_active = rc().option_is_enabled(RC_Channels::Option::USE_CRSF_LQ_AS_RSSI);
    if(_telem_bootstrap_msg_pending || _noted_lq_as_rssi_active != current_lq_as_rssi_active){
        _noted_lq_as_rssi_active = current_lq_as_rssi_active;
        GCS_SEND_TEXT(MAV_SEVERITY_INFO, "%s: RSSI now displays %s", get_protocol_string(), current_lq_as_rssi_active ? " as LQ" : "normally");
    }
    _telem_bootstrap_msg_pending = false;

    const bool is_high_speed = is_high_speed_telemetry(current_rf_mode);
    if ((now - _telem_last_report_ms > 5000)) {
        // report an RF mode change or a change in telemetry rate if we haven't done so in the last 5s
        if (!rc().option_is_enabled(RC_Channels::Option::SUPPRESS_CRSF_MESSAGE) && (_rf_mode != current_rf_mode)) {
            GCS_SEND_TEXT(MAV_SEVERITY_INFO, "%s: Link rate %dHz, Telemetry %s",
                get_protocol_string(), ghost->get_link_rate(), _enable_telemetry ? "ON" : "OFF");
        }
        // tune the scheduler based on telemetry speed high/low transitions
        if (_telem_is_high_speed != is_high_speed) {
            update_custom_telemetry_rates(current_rf_mode);
        }
        _telem_is_high_speed = is_high_speed;
        _rf_mode = current_rf_mode;
        _telem_last_avg_rate = _scheduler.avg_packet_rate;
        if (_telem_last_report_ms == 0) {   // only want to show bootstrap messages once
            _telem_bootstrap_msg_pending = true;
        }
        _telem_last_report_ms = now;
    }
    return true;
}

AP_RCProtocol_GHST::RFMode AP_GHST_Telem::get_rf_mode() const
{
    AP_RCProtocol_GHST* ghost = AP::ghost();
    if (ghost == nullptr) {
        return AP_RCProtocol_GHST::RFMode::RF_MODE_UNKNOWN;
    }

    return static_cast<AP_RCProtocol_GHST::RFMode>(ghost->get_link_status().rf_mode);
}

bool AP_GHST_Telem::is_high_speed_telemetry(const AP_RCProtocol_GHST::RFMode rf_mode) const
{
    return rf_mode == AP_RCProtocol_GHST::RFMode::GHST_RF_MODE_RACE || rf_mode == AP_RCProtocol_GHST::RFMode::GHST_RF_MODE_RACE250;
}

uint16_t AP_GHST_Telem::get_telemetry_rate() const
{
    return get_avg_packet_rate();
}

// WFQ scheduler
bool AP_GHST_Telem::is_packet_ready(uint8_t idx, bool queue_empty)
{
    return _enable_telemetry;
}

// WFQ scheduler
void AP_GHST_Telem::process_packet(uint8_t idx)
{
    // send packet
    switch (idx) {
        case ATTITUDE:
            calc_attitude();
            break;
        case BATTERY: // BATTERY
            calc_battery();
            break;
        case GPS: // GPS
            calc_gps();
            break;
        case GPS2: // GPS secondary info
            calc_gps2();
            break;
        default:
            break;
    }
}

// Process a frame from the GHST protocol decoder
bool AP_GHST_Telem::_process_frame(AP_RCProtocol_GHST::FrameType frame_type, void* data) {
    switch (frame_type) {
    // this means we are connected to an RC receiver and can send telemetry
    case AP_RCProtocol_GHST::GHST_UL_RC_CHANS_RSSI: {
        process_rf_mode_changes();
        _enable_telemetry = AP::ghost()->is_telemetry_supported();
        break;
    }
    default:
        break;
    }
    return true;
}

// process any changed settings and schedule for transmission
void AP_GHST_Telem::update()
{
}

void AP_GHST_Telem::process_pending_requests()
{
    _pending_request.frame_type = 0;
}

// prepare battery data
void AP_GHST_Telem::calc_battery()
{
    debug("BATTERY");
    const AP_BattMonitor &_battery = AP::battery();

    _telem.battery.voltage = htole16(uint16_t(roundf(_battery.voltage(0) * 100.0f)));

    float current;
    if (!_battery.current_amps(current, 0)) {
        current = 0;
    }
    _telem.battery.current = htole16(uint16_t(roundf(current * 100.0f)));

    float used_mah;
    if (!_battery.consumed_mah(used_mah, 0)) {
        used_mah = 0;
    }

    _telem.battery.consumed = htole16(uint16_t(roundf(used_mah * 100.0f)));;
    _telem.battery.rx_voltage = htole16(uint16_t(roundf(hal.analogin->board_voltage() * 10)));

    _telem_size = sizeof(BatteryFrame);
    _telem_type = AP_RCProtocol_GHST::GHST_DL_PACK_STAT;

    _telem_pending = true;
}

// prepare gps data
void AP_GHST_Telem::calc_gps()
{
    debug("GPS");
    const Location &loc = AP::gps().location(0); // use the first gps instance (same as in send_mavlink_gps_raw)

    _telem.gps.latitude = htole32(loc.lat);
    _telem.gps.longitude = htole32(loc.lng);
    _telem.gps.altitude = htole16(constrain_int16(loc.alt / 100, 0, 5000) + 1000);

    _telem_size = sizeof(AP_GHST_Telem::GPSFrame);
    _telem_type = AP_RCProtocol_GHST::GHST_DL_GPS_PRIMARY;

    _telem_pending = true;
}

void AP_GHST_Telem::calc_gps2()
{
    debug("GPS2");
    _telem.gps2.groundspeed = htole16(roundf(AP::gps().ground_speed() * 100000 / 3600));
    _telem.gps2.gps_heading = htole16(roundf(AP::gps().ground_course() * 100.0f));
    _telem.gps2.satellites = AP::gps().num_sats();

    AP_AHRS &_ahrs = AP::ahrs();
    WITH_SEMAPHORE(_ahrs.get_semaphore());
    Location loc;

    if (_ahrs.get_location(loc) && _ahrs.home_is_set()) {
        const Location &home_loc = _ahrs.get_home();
        _telem.gps2.home_dist = home_loc.get_distance(loc) / 10; // 10m
        _telem.gps2.home_heading = loc.get_bearing_to(home_loc) / 10; // deci-degrees
    } else {
        _telem.gps2.home_dist = 0;
        _telem.gps2.home_heading = 0;
    }

    AP_GPS::GPS_Status status = AP::gps().status();
    _telem.gps2.flags = status >= AP_GPS::GPS_OK_FIX_2D ? 0x1 : 0;

    _telem_size = sizeof(AP_GHST_Telem::GPSSecondaryFrame);
    _telem_type = AP_RCProtocol_GHST::GHST_DL_GPS_SECONDARY;

    _telem_pending = true;
}

// prepare attitude data
void AP_GHST_Telem::calc_attitude()
{
    debug("MAGBARO");
    AP_AHRS &_ahrs = AP::ahrs();
    WITH_SEMAPHORE(_ahrs.get_semaphore());

    float heading = AP::compass().calculate_heading(_ahrs.get_rotation_body_to_ned());
    _telem.sensor.compass_heading = htole16(degrees(wrap_PI(heading)));

    float alt = AP::baro().get_altitude();
    _telem.sensor.baro_alt = htole16(roundf(alt));
    _telem.sensor.vario = 0;
    _telem.sensor.flags = 3;
    _telem_size = sizeof(AP_GHST_Telem::SensorFrame);
    _telem_type = AP_RCProtocol_GHST::GHST_DL_MAGBARO;

    _telem_pending = true;
}

/*
  fetch GHST frame data
  if is_tx_active is true then this will be a request for telemetry after receiving an RC frame
 */
bool AP_GHST_Telem::_get_telem_data(AP_RCProtocol_GHST::Frame* data, bool is_tx_active)
{
    memset(&_telem, 0, sizeof(TelemetryPayload));
    _is_tx_active = is_tx_active;

    run_wfq_scheduler();
    if (!_telem_pending) {
        return false;
    }
    memcpy(data->payload, &_telem, _telem_size);
    data->device_address = AP_RCProtocol_GHST::GHST_ADDRESS_GHST_RECEIVER;
    data->length = _telem_size + 2;
    data->type = _telem_type;

    _telem_pending = false;
    return true;
}

/*
  fetch data for an external transport, such as GHST
 */
bool AP_GHST_Telem::process_frame(AP_RCProtocol_GHST::FrameType frame_type, void* data)
{
    if (!get_singleton()) {
        return false;
    }
    return singleton->_process_frame(frame_type, data);
}

/*
  fetch data for an external transport, such as GHST
 */
bool AP_GHST_Telem::get_telem_data(AP_RCProtocol_GHST::Frame* data, bool is_tx_active)
{
    if (!get_singleton()) {
        return false;
    }
    return singleton->_get_telem_data(data, is_tx_active);
}

AP_GHST_Telem *AP_GHST_Telem::get_singleton(void) {
    if (!singleton && !hal.util->get_soft_armed()) {
        // if telem data is requested when we are disarmed and don't
        // yet have a AP_GHST_Telem object then try to allocate one
        NEW_NOTHROW AP_GHST_Telem();
        // initialize the passthrough scheduler
        if (singleton) {
            singleton->init();
        }
    }
    return singleton;
}

namespace AP {
    AP_GHST_Telem *ghost_telem() {
        return AP_GHST_Telem::get_singleton();
    }
};

#endif // AP_GHST_TELEM_ENABLED
                             /*
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/
#pragma once

#include "AP_RCTelemetry_config.h"

#if AP_GHST_TELEM_ENABLED

#include <AP_RCProtocol/AP_RCProtocol_GHST.h>
#include "AP_RCTelemetry.h"
#include <AP_HAL/utility/sparse-endian.h>

class AP_GHST_Telem : public AP_RCTelemetry {
public:
    AP_GHST_Telem();
    ~AP_GHST_Telem() override;

    /* Do not allow copies */
    CLASS_NO_COPY(AP_GHST_Telem);

    // init - perform required initialisation
    virtual bool init() override;

    static AP_GHST_Telem *get_singleton(void);

    // Broadcast frame definitions courtesy of TBS
    struct PACKED GPSFrame {
        uint32_t latitude; // ( degree * 1e7 )
        uint32_t longitude; // (degree * 1e7 )
        int16_t altitude; // ( meter )
    };

    struct PACKED GPSSecondaryFrame {
        uint16_t groundspeed; // ( cm/s )
        uint16_t gps_heading; // ( degree * 10 )
        uint8_t satellites; // in use ( counter )
        uint16_t home_dist; // ( m / 10 )
        uint16_t home_heading; // ( degree * 10 )
        uint8_t flags; // GPS_FLAGS_FIX 0x01, GPS_FLAGS_FIX_HOME 0x2
    };

    struct PACKED BatteryFrame {
        uint16_t voltage; // ( mV / 10 )
        uint16_t current; // ( mA / 10 )
        uint16_t consumed; // ( mAh / 10 )
        uint8_t rx_voltage; // ( mV / 100 )
        uint8_t spare[3];
    };

    struct PACKED VTXFrame {
#if __BYTE_ORDER != __LITTLE_ENDIAN
#error "Only supported on little-endian architectures"
#endif
        uint8_t flags;
        uint16_t frequency;         // frequency in Mhz
        uint16_t power;              // power in mw, 0 == off
        uint8_t band : 4;               // A, B, E, AirWave, Race
        uint8_t channel : 4;            // 1x-8x
        uint8_t spare[3];
    };

    struct PACKED SensorFrame {
        uint16_t compass_heading; // ( deg * 10 )
        int16_t baro_alt; // ( m )
        int16_t vario; // ( m/s * 100 )
        uint8_t spare[3];
        uint8_t flags; // MISC_FLAGS_MAGHEAD 0x01, MISC_FLAGS_BAROALT 0x02, MISC_FLAGS_VARIO 0x04
    };

    union PACKED TelemetryPayload {
        GPSFrame gps;
        GPSSecondaryFrame gps2;
        BatteryFrame battery;
        VTXFrame vtx;
        SensorFrame sensor;
    };

    // get the protocol string
    const char* get_protocol_string() const { return AP::ghost()->get_protocol_string(); }

    // Process a frame from the CRSF protocol decoder
    static bool process_frame(AP_RCProtocol_GHST::FrameType frame_type, void* data);
    // process any changed settings and schedule for transmission
    void update();
    // get next telemetry data for external consumers of SPort data
    static bool get_telem_data(AP_RCProtocol_GHST::Frame* frame, bool is_tx_active);

private:

    enum SensorType {
        ATTITUDE,
        VTX_PARAMETERS,
        BATTERY,
        GPS,
        GPS2,
        NUM_SENSORS
    };

    // passthrough WFQ scheduler
    bool is_packet_ready(uint8_t idx, bool queue_empty) override;
    void process_packet(uint8_t idx) override;
    void setup_custom_telemetry();
    void update_custom_telemetry_rates(const AP_RCProtocol_GHST::RFMode rf_mode);

    void calc_battery();
    void calc_gps();
    void calc_gps2();
    void calc_attitude();
    void process_pending_requests();
    bool process_rf_mode_changes();
    AP_RCProtocol_GHST::RFMode get_rf_mode() const;
    uint16_t get_telemetry_rate() const;
    bool is_high_speed_telemetry(const AP_RCProtocol_GHST::RFMode rf_mode) const;

    // setup ready for passthrough operation
    void setup_wfq_scheduler(void) override;

    // get next telemetry data for external consumers
    bool _get_telem_data(AP_RCProtocol_GHST::Frame* data, bool is_tx_active);
    bool _process_frame(AP_RCProtocol_GHST::FrameType frame_type, void* data);

    TelemetryPayload _telem;
    uint8_t _telem_size;
    uint8_t _telem_type;

    AP_RCProtocol_GHST::RFMode _rf_mode;
    bool _enable_telemetry;

    // reporting telemetry rate
    uint32_t _telem_last_report_ms;
    uint16_t _telem_last_avg_rate;
    // do we need to report the initial state
    bool _telem_bootstrap_msg_pending;

    bool _telem_is_high_speed;
    bool _telem_pending;
    // used to limit telemetry when in a failsafe condition
    bool _is_tx_active;

    struct {
        uint8_t destination = 0;
        uint8_t frame_type;
    } _pending_request;

    bool _noted_lq_as_rssi_active;

    static AP_GHST_Telem *singleton;
};

namespace AP {
    AP_GHST_Telem *ghost_telem();
};

#endif // AP_GHST_TELEM_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      /*
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

/*
   Abstract Telemetry library
*/

#include "AP_RCTelemetry.h"

#include <AP_AHRS/AP_AHRS.h>
#include <AP_Common/AP_FWVersion.h>
#include <GCS_MAVLink/GCS.h>
#include <stdio.h>
#include <math.h>
#include <AP_Vehicle/AP_Vehicle_Type.h>
#include <AP_Baro/AP_Baro.h>

#ifdef TELEM_DEBUG
# define debug(fmt, args...)	hal.console->printf("Telem: " fmt "\n", ##args)
#else
# define debug(fmt, args...)	do {} while(0)
#endif

extern const AP_HAL::HAL& hal;

/*
  setup ready for passthrough telem
 */
bool AP_RCTelemetry::init(void)
{
#if HAL_GCS_ENABLED && !APM_BUILD_TYPE(APM_BUILD_UNKNOWN)
    // make telemetry available to GCS_MAVLINK (used to queue statustext messages from GCS_MAVLINK)
    // add firmware and frame info to message queue
    const char* _frame_string = gcs().frame_string();
    if (_frame_string == nullptr) {
        queue_message(MAV_SEVERITY_INFO, AP::fwversion().fw_string);
    } else {
        char firmware_buf[MAVLINK_MSG_STATUSTEXT_FIELD_TEXT_LEN+1];
        snprintf(firmware_buf, sizeof(firmware_buf), "%s %s", AP::fwversion().fw_string, _frame_string);
        queue_message(MAV_SEVERITY_INFO, firmware_buf);
    }
#endif
    setup_wfq_scheduler();

    return true;
}

void AP_RCTelemetry::update_avg_packet_rate()
{
    uint32_t poll_now = AP_HAL::millis();

    _scheduler.avg_packet_counter++;

    if (poll_now - _scheduler.last_poll_timer > 1000) { //average in last 1000ms
        // initialize
        if (_scheduler.avg_packet_rate == 0) _scheduler.avg_packet_rate = _scheduler.avg_packet_counter;
        // moving average
        _scheduler.avg_packet_rate = (uint16_t)_scheduler.avg_packet_rate * 0.75f + _scheduler.avg_packet_counter * 0.25f;
        // reset
        _scheduler.last_poll_timer = poll_now;
        _scheduler.avg_packet_counter = 0;
        debug("avg packet rate %dHz, rates(Hz) %d %d %d %d %d %d %d %d", _scheduler.avg_packet_rate,
             _scheduler.packet_rate[0],
             _scheduler.packet_rate[1],
             _scheduler.packet_rate[2],
             _scheduler.packet_rate[3],
             _scheduler.packet_rate[4],
             _scheduler.packet_rate[5],
             _scheduler.packet_rate[6],
             _scheduler.packet_rate[7]);
    }
}

/*
 * WFQ scheduler
 * returns the actual packet type index (if any) sent by the scheduler
 */
uint8_t AP_RCTelemetry::run_wfq_scheduler(const bool use_shaper)
{
    update_avg_packet_rate();
    update_max_packet_rate();

    uint32_t now = AP_HAL::millis();
    int8_t max_delay_idx = -1;

    float max_delay = 0;
    float delay = 0;
    bool packet_ready = false;

    // build message queue for sensor_status_flags
    check_sensor_status_flags();
    // build message queue for ekf_status
    check_ekf_status();

    // dynamic priorities
    bool queue_empty;
    {
        WITH_SEMAPHORE(_statustext.sem);
        queue_empty = !_statustext.available && _statustext.queue.is_empty();
    }

    adjust_packet_weight(queue_empty);

    // search the packet with the longest delay after the scheduled time
    for (int i=0; i<_time_slots; i++) {
        // normalize packet delay relative to packet weight
        delay = (now - _scheduler.packet_timer[i])/static_cast<float>(_scheduler.packet_weight[i]);
        // use >= so with equal delays we choose the packet with lowest priority
        // this is ensured by the packets being sorted by desc frequency
        // apply the rate limiter
        if (delay >= max_delay && check_scheduler_entry_time_constraints(now, i, use_shaper)) {
            packet_ready = is_scheduler_entry_enabled(i) && is_packet_ready(i, queue_empty);

            if (packet_ready) {
                max_delay = delay;
                max_delay_idx = i;
            }
        }
    }
    if (max_delay_idx < 0) {  // nothing was ready
        return max_delay_idx;
    }

    now = AP_HAL::millis();
#ifdef TELEM_DEBUG
    _scheduler.packet_rate[max_delay_idx] = (_scheduler.packet_rate[max_delay_idx] + 1000 / (now - _scheduler.packet_timer[max_delay_idx])) / 2;
#endif
    _scheduler.packet_timer[max_delay_idx] = now;
    //debug("process_packet(%d): %f", max_delay_idx, max_delay);
    // send packet
    process_packet(max_delay_idx);
    // let the caller know which packet type was sent
    return max_delay_idx;
}

/*
 * do not run the scheduler and process a specific entry
 */
bool AP_RCTelemetry::process_scheduler_entry(const uint8_t slot )
{
    if (slot >= TELEM_TIME_SLOT_MAX) {
        return false;
    }
    if (!is_scheduler_entry_enabled(slot)) {
        return false;
    }
    bool queue_empty;
    {
        WITH_SEMAPHORE(_statustext.sem);
        queue_empty = !_statustext.available && _statustext.queue.is_empty();
    }
    if (!is_packet_ready(slot, queue_empty)) {
        return false;
    }
    process_packet(slot);

    return true;
}

/*
 * add message to message cue for transmission through link
 */
void AP_RCTelemetry::queue_message(MAV_SEVERITY severity, const char *text)
{
    mavlink_statustext_t statustext{};

    statustext.severity = severity;
    strncpy_noterm(statustext.text, text, sizeof(statustext.text));

    // The force push will ensure comm links do not block other comm links forever if they fail.
    // If we push to a full buffer then we overwrite the oldest entry, effectively removing the
    // block but not until the buffer fills up.
    WITH_SEMAPHORE(_statustext.sem);
    _statustext.queue.push_force(statustext);
}

/*
 * add sensor_status_flags information to message cue, normally passed as sys_status mavlink messages to the GCS, for transmission through FrSky link
 */
void AP_RCTelemetry::check_sensor_status_flags(void)
{
    uint32_t now = AP_HAL::millis();

    const uint32_t _sensor_status_flags = sensor_status_flags();

    if ((now - check_sensor_status_timer) >= 5000) { // prevent repeating any system_status messages unless 5 seconds have passed
        // only one error is reported at a time (in order of preference). Same setup and displayed messages as Mission Planner.
        if ((_sensor_status_flags & MAV_SYS_STATUS_SENSOR_GPS) > 0) {
            queue_message(MAV_SEVERITY_CRITICAL, "Bad GPS Health");
            check_sensor_status_timer = now;
        } else if ((_sensor_status_flags & MAV_SYS_STATUS_SENSOR_3D_GYRO) > 0) {
            queue_message(MAV_SEVERITY_CRITICAL, "Bad Gyro Health");
            check_sensor_status_timer = now;
        } else if ((_sensor_status_flags & MAV_SYS_STATUS_SENSOR_3D_ACCEL) > 0) {
            queue_message(MAV_SEVERITY_CRITICAL, "Bad Accel Health");
            check_sensor_status_timer = now;
        } else if ((_sensor_status_flags & MAV_SYS_STATUS_SENSOR_3D_MAG) > 0) {
            queue_message(MAV_SEVERITY_CRITICAL, "Bad Compass Health");
            check_sensor_status_timer = now;
        } else if ((_sensor_status_flags & MAV_SYS_STATUS_SENSOR_ABSOLUTE_PRESSURE) > 0) {
            queue_message(MAV_SEVERITY_CRITICAL, "Bad Baro Health");
            check_sensor_status_timer = now;
        } else if ((_sensor_status_flags & MAV_SYS_STATUS_SENSOR_LASER_POSITION) > 0) {
            queue_message(MAV_SEVERITY_CRITICAL, "Bad LiDAR Health");
            check_sensor_status_timer = now;
        } else if ((_sensor_status_flags & MAV_SYS_STATUS_SENSOR_OPTICAL_FLOW) > 0) {
            queue_message(MAV_SEVERITY_CRITICAL, "Bad OptFlow Health");
            check_sensor_status_timer = now;
        } else if ((_sensor_status_flags & MAV_SYS_STATUS_TERRAIN) > 0) {
            queue_message(MAV_SEVERITY_CRITICAL, "Bad or No Terrain Data");
            check_sensor_status_timer = now;
        } else if ((_sensor_status_flags & MAV_SYS_STATUS_GEOFENCE) > 0) {
            queue_message(MAV_SEVERITY_CRITICAL, "Geofence Breach");
            check_sensor_status_timer = now;
        } else if ((_sensor_status_flags & MAV_SYS_STATUS_AHRS) > 0) {
            queue_message(MAV_SEVERITY_CRITICAL, "Bad AHRS");
            check_sensor_status_timer = now;
        } else if ((_sensor_status_flags & MAV_SYS_STATUS_SENSOR_RC_RECEIVER) > 0) {
            queue_message(MAV_SEVERITY_CRITICAL, "No RC Receiver");
            check_sensor_status_timer = now;
        } else if ((_sensor_status_flags & MAV_SYS_STATUS_LOGGING) > 0) {
            queue_message(MAV_SEVERITY_CRITICAL, "Bad Logging");
            check_sensor_status_timer = now;
        }
    }
}

/*
 * add innovation variance information to message cue, normally passed as ekf_status_report mavlink messages to the GCS, for transmission through FrSky link
 */
void AP_RCTelemetry::check_ekf_status(void)
{
    // get variances
    bool get_variance;
    float velVar, posVar, hgtVar, tasVar;
    Vector3f magVar;
    {
        AP_AHRS &_ahrs = AP::ahrs();
        WITH_SEMAPHORE(_ahrs.get_semaphore());
        get_variance = _ahrs.get_variances(velVar, posVar, hgtVar, magVar, tasVar);
    }
    if (get_variance) {
        uint32_t now = AP_HAL::millis();
        if ((now - check_ekf_status_timer) >= 10000) { // prevent repeating any ekf_status message unless 10 seconds have passed
            // multiple errors can be reported at a time. Same setup as Mission Planner.
            if (velVar >= 0.8f) {
                queue_message(MAV_SEVERITY_CRITICAL, "Error velocity variance");
                check_ekf_status_timer = now;
            }
            if (posVar >= 0.8f) {
                queue_message(MAV_SEVERITY_CRITICAL, "Error pos horiz variance");
                check_ekf_status_timer = now;
            }
            if (hgtVar >= 0.8f) {
                queue_message(MAV_SEVERITY_CRITICAL, "Error pos vert variance");
                check_ekf_status_timer = now;
            }
            if (magVar.length() >= 0.8f) {
                queue_message(MAV_SEVERITY_CRITICAL, "Error compass variance");
                check_ekf_status_timer = now;
            }
            if (tasVar >= 0.8f) {
                queue_message(MAV_SEVERITY_CRITICAL, "Error terrain alt variance");
                check_ekf_status_timer = now;
            }
        }
    }
}

uint32_t AP_RCTelemetry::sensor_status_flags() const
{
    uint32_t present;
    uint32_t enabled;
    uint32_t health;
#if HAL_GCS_ENABLED
    gcs().get_sensor_status_flags(present, enabled, health);
#else
    present = 0;
    enabled = 0;
    health = 0;
#endif

    return ~health & enabled & present;
}

/*
 * get vertical speed from ahrs, if not available fall back to baro climbrate, units is m/s
 */
float AP_RCTelemetry::get_vspeed_ms(void)
{
    {
        // release semaphore as soon as possible
        AP_AHRS &_ahrs = AP::ahrs();
        Vector3f v;
        WITH_SEMAPHORE(_ahrs.get_semaphore());
        if (_ahrs.get_velocity_NED(v)) {
            return -v.z;
        }
    }
    auto &_baro = AP::baro();
    WITH_SEMAPHORE(_baro.get_semaphore());
    return _baro.get_climb_rate();
}

/*
 * prepare altitude between vehicle and home location data
 */
float AP_RCTelemetry::get_nav_alt_m(Location::AltFrame frame)
{
    Location loc;
    float current_height = 0;

    AP_AHRS &_ahrs = AP::ahrs();
    WITH_SEMAPHORE(_ahrs.get_semaphore());

    if (frame == Location::AltFrame::ABOVE_HOME) {
        _ahrs.get_relative_position_D_home(current_height);
        return -current_height;
    }

    if (_ahrs.get_location(loc)) {
        if (!loc.get_alt_m(frame, current_height)) {
            // ignore this error
        }
    }
    return current_height;
}
                                                                                                                                                                                                             /*
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/
#pragma once

#include <AP_HAL/Semaphores.h>
#include <AP_HAL/utility/RingBuffer.h>
#include <AP_Math/AP_Math.h>
#include <GCS_MAVLink/GCS_MAVLink.h>
#include <AP_Common/Location.h>

#define TELEM_PAYLOAD_STATUS_CAPACITY          5 // size of the message buffer queue (max number of messages waiting to be sent)

// for fair scheduler
#define TELEM_TIME_SLOT_MAX               20
//#define TELEM_DEBUG

class AP_RCTelemetry {
public:
    AP_RCTelemetry(uint8_t time_slots) : _time_slots(time_slots) {}
    virtual ~AP_RCTelemetry() {};

    /* Do not allow copies */
    CLASS_NO_COPY(AP_RCTelemetry);

    // add statustext message to message queue
    virtual void queue_message(MAV_SEVERITY severity, const char *text);

    // scheduler entry helpers
    void enable_scheduler_entry(const uint8_t slot) {
        if (slot >= TELEM_TIME_SLOT_MAX) {
            return;
        }
        BIT_CLEAR(_disabled_scheduler_entries_bitmask, slot);
    }
    void disable_scheduler_entry(const uint8_t slot) {
        if (slot >= TELEM_TIME_SLOT_MAX) {
            return;
        }
        BIT_SET(_disabled_scheduler_entries_bitmask, slot);
    }
    void set_scheduler_entry_min_period(const uint8_t slot, const uint32_t min_period_ms)
    {
        if (slot >= TELEM_TIME_SLOT_MAX) {
            return;
        }
        _scheduler.packet_min_period[slot] = min_period_ms;
    }
    bool is_scheduler_entry_enabled(const uint8_t slot) const {
        if (slot >= TELEM_TIME_SLOT_MAX) {
            return false;
        }
        return !BIT_IS_SET(_disabled_scheduler_entries_bitmask, slot);
    }
    // each derived class might provide a way to reset telemetry rates to default
    virtual void reset_scheduler_entry_min_periods() {}

    // update error mask of sensors and subsystems. The mask uses the
    // MAV_SYS_STATUS_* values from mavlink. If a bit is set then it
    // indicates that the sensor or subsystem is present but not
    // functioning correctly
    uint32_t sensor_status_flags() const;
    uint16_t get_avg_packet_rate() const {
        return _scheduler.avg_packet_rate;
    }
    uint16_t get_max_packet_rate() const {
        return _scheduler.max_packet_rate;
    }

    static float get_vspeed_ms(void);
    static float get_nav_alt_m(Location::AltFrame frame = Location::AltFrame::ABSOLUTE);

protected:
    uint8_t run_wfq_scheduler(const bool use_shaper = true);
    // process a specific entry
    bool process_scheduler_entry(const uint8_t slot );
    // set an entry in the scheduler table
    void set_scheduler_entry(uint8_t slot, uint32_t weight, uint32_t min_period_ms) {
        if (slot >= TELEM_TIME_SLOT_MAX) {
            return;
        }
        _scheduler.packet_weight[slot] = weight;
        _scheduler.packet_min_period[slot] = min_period_ms;
    }
    // add an entry to the scheduler table
    void add_scheduler_entry(uint32_t weight, uint32_t min_period_ms) {
        if (_time_slots >= TELEM_TIME_SLOT_MAX) {
            return;
        }
        set_scheduler_entry(_time_slots++, weight, min_period_ms);
    }
    // setup ready for passthrough operation
    virtual bool init(void);

    uint8_t _time_slots;

    struct
    {
        uint32_t last_poll_timer;
        uint32_t avg_packet_counter;
        uint32_t packet_timer[TELEM_TIME_SLOT_MAX];
        uint32_t packet_weight[TELEM_TIME_SLOT_MAX];
        uint32_t packet_min_period[TELEM_TIME_SLOT_MAX];
        uint16_t avg_packet_rate;
        uint16_t max_packet_rate;
#ifdef TELEM_DEBUG
        uint8_t packet_rate[TELEM_TIME_SLOT_MAX];
#endif
    } _scheduler;

    struct {
        HAL_Semaphore sem;
        ObjectBuffer<mavlink_statustext_t> queue{TELEM_PAYLOAD_STATUS_CAPACITY};
        mavlink_statustext_t next;
        bool available;
    } _statustext;

private:
    uint32_t check_sensor_status_timer;
    uint32_t check_ekf_status_timer;
    uint32_t _disabled_scheduler_entries_bitmask;

    // passthrough WFQ scheduler
    virtual void setup_wfq_scheduler() = 0;
    virtual bool get_next_msg_chunk(void) { return false; }
    virtual bool is_packet_ready(uint8_t idx, bool queue_empty) { return true; }
    virtual void process_packet(uint8_t idx) = 0;
    virtual void adjust_packet_weight(bool queue_empty) {};
    bool check_scheduler_entry_time_constraints(const uint32_t now, uint8_t slot, const bool use_shaper) const {
        if (!use_shaper) {
            return true;
        }
        return ((now - _scheduler.packet_timer[slot]) >= _scheduler.packet_min_period[slot]);
    }

    void update_avg_packet_rate();
    void update_max_packet_rate() {
        _scheduler.max_packet_rate = MAX(_scheduler.avg_packet_rate, _scheduler.max_packet_rate);
    }

    // methods to convert flight controller data to FrSky SPort Passthrough (OpenTX) format
    void check_sensor_status_flags(void);
    void check_ekf_status(void);
};
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 #pragma once

#include <AP_HAL/AP_HAL_Boards.h>
#include <AP_Frsky_Telem/AP_Frsky_config.h>
#include <AP_OSD/AP_OSD_config.h>
#include <AP_RCProtocol/AP_RCProtocol_config.h>

#ifndef HAL_CRSF_TELEM_ENABLED
#define HAL_CRSF_TELEM_ENABLED AP_RCPROTOCOL_CRSF_ENABLED && AP_FRSKY_SPORT_PASSTHROUGH_ENABLED
#endif

#ifndef HAL_CRSF_TELEM_TEXT_SELECTION_ENABLED
#define HAL_CRSF_TELEM_TEXT_SELECTION_ENABLED OSD_ENABLED && OSD_PARAM_ENABLED && HAL_CRSF_TELEM_ENABLED && BOARD_FLASH_SIZE > 1024
#endif

#ifndef HAL_SPEKTRUM_TELEM_ENABLED
#define HAL_SPEKTRUM_TELEM_ENABLED 1
#endif

#ifndef AP_GHST_TELEM_ENABLED
#define AP_GHST_TELEM_ENABLED AP_RCPROTOCOL_GHST_ENABLED
#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  /*
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

/*
   Spektrum Telemetry library, based on AP_Frsky_Telem.cpp
   See https://www.spektrumrc.com/ProdInfo/Files/SPM_Telemetry_Developers_Specs.pdf
*/

#include "AP_Spektrum_Telem.h"
#include <AP_HAL/utility/sparse-endian.h>
#include <AP_AHRS/AP_AHRS.h>
#include <AP_RPM/AP_RPM.h>
#include <AP_Airspeed/AP_Airspeed.h>
#include <AP_Compass/AP_Compass.h>
#include <AP_BattMonitor/AP_BattMonitor.h>
#include <AP_RangeFinder/AP_RangeFinder.h>
#include <AP_Common/AP_FWVersion.h>
#include <GCS_MAVLink/GCS.h>
#include <AP_Common/Location.h>
#include <AP_GPS/AP_GPS.h>
#include <AP_Baro/AP_Baro.h>
#include <AP_RTC/AP_RTC.h>
#include <AP_SerialManager/AP_SerialManager.h>
#include <AP_ESC_Telem/AP_ESC_Telem.h>
#include <math.h>

#if HAL_SPEKTRUM_TELEM_ENABLED

#define MICROSEC_PER_MINUTE 60000000
#define MAX_TEXTGEN_LEN     13

//#define SPKT_DEBUG
#ifdef SPKT_DEBUG
# define debug(fmt, args...)	hal.console->printf("SPKT:" fmt "\n", ##args)
#else
# define debug(fmt, args...)	do {} while(0)
#endif

extern const AP_HAL::HAL& hal;

AP_Spektrum_Telem *AP_Spektrum_Telem::singleton;

AP_Spektrum_Telem::AP_Spektrum_Telem() : AP_RCTelemetry(0)
{
    singleton = this;
}

AP_Spektrum_Telem::~AP_Spektrum_Telem(void)
{
    singleton = nullptr;
}

bool AP_Spektrum_Telem::init(void)
{
    // sanity check that we are using a UART for RC input
    if (!AP::serialmanager().have_serial(AP_SerialManager::SerialProtocol_RCIN, 0)) {
        return false;
    }
    return AP_RCTelemetry::init();
}

/*
  setup ready for passthrough telem
 */
void AP_Spektrum_Telem::setup_wfq_scheduler(void)
{
    // initialize packet weights for the WFQ scheduler
    // priority[i] = 1/_scheduler.packet_weight[i]
    // rate[i] = LinkRate * ( priority[i] / (sum(priority[1-n])) )

    // Spektrum telemetry rate is 46Hz, so these rates must fit
    add_scheduler_entry(50, 100);   // qos        10Hz
    add_scheduler_entry(50, 100);   // rpm        10Hz
    add_scheduler_entry(50, 100);   // text,      10Hz
    add_scheduler_entry(50, 120);   // Attitude and compass 8Hz
    add_scheduler_entry(550, 280);  // GPS        3Hz
    add_scheduler_entry(550, 280);  // ESC        3Hz
    add_scheduler_entry(400, 250);  // altitude   4Hz
    add_scheduler_entry(400, 250);  // airspeed   4Hz
    add_scheduler_entry(700, 500);  // GPS status 2Hz
    add_scheduler_entry(1300, 500); // batt volt  2Hz
    add_scheduler_entry(1300, 500); // batt curr  2Hz
    add_scheduler_entry(1300, 500); // batt mah   2Hz
    add_scheduler_entry(1300, 500); // temp       2Hz
}

void AP_Spektrum_Telem::adjust_packet_weight(bool queue_empty)
{
    if (!queue_empty) {
        _scheduler.packet_weight[TEXT] = 50;         // messages
    } else {
        _scheduler.packet_weight[TEXT] = 5000;        // messages
    }
}

// WFQ scheduler
bool AP_Spektrum_Telem::is_packet_ready(uint8_t idx, bool queue_empty)
{
    bool packet_ready = false;
    switch (idx) {
    case TEXT:
        packet_ready = !queue_empty;
        break;
    default:
        packet_ready = true;
        break;
    }

    return packet_ready;
}

// WFQ scheduler
void AP_Spektrum_Telem::process_packet(uint8_t idx)
{
    // send packet
    switch (idx) {
        case QOS: // QOS
            calc_qos();
            break;
        case RPM: // RPM
            calc_rpm();
            break;
        case TEXT: // status text
            if (repeat_msg_chunk() || get_next_msg_chunk()) {
                send_msg_chunk(_msg_chunk);
            }
            break;
        case ATTITUDE: // Attitude and compass
            calc_attandmag();
            break;
        case GPS_LOC: // GPS location
            calc_gps_location();
            break;
        case ESC: // ESC
            calc_esc();
            break;
        case ALTITUDE: // altitude
            calc_altitude();
            break;
        case AIRSPEED: // airspeed
            calc_airspeed();
            break;
        case GPS_STATUS: // GPS status
            calc_gps_status();
            break;
        case VOLTAGE: // Battery volts
            calc_batt_volts(0);
            break;
        case AMPS: // Battery current
            calc_batt_amps(0);
            break;
        case MAH: // Battery current & mah
            calc_batt_mah();
            break;
        case TEMP: // temperature
            calc_temperature(0);
            break;
        default:
            break;
    }
}

// whether to repeat the last texgen output
bool AP_Spektrum_Telem::repeat_msg_chunk(void)
{
    if (_msg_chunk.repeats == 0) {
        return false;
    }

    // repeat each message chunk 3 times to ensure transmission
    // on slow links reduce the number of duplicate chunks
    uint8_t extra_chunks = 2;

    if (_scheduler.avg_packet_rate < 20) {
        extra_chunks = 0;
    } else if (_scheduler.avg_packet_rate < 30) {
        extra_chunks = 1;
    }

    if (_msg_chunk.repeats++ > extra_chunks) {
        _msg_chunk.repeats = 0;
        return false;
    }
    return true;
}


// grabs one "chunk" (13 bytes) of the queued message to be transmitted
bool AP_Spektrum_Telem::get_next_msg_chunk(void)
{
    _msg_chunk.repeats++;

    if (!_statustext.available) {
        WITH_SEMAPHORE(_statustext.sem);
        if (!_statustext.queue.pop(_statustext.next)) {
            return false;
        }

        _statustext.available = true;

        // We're going to display a new message so first clear the screen
        _msg_chunk.linenumber = 0xFF;
        _msg_chunk.char_index = 0;
        return true;
    }

    uint8_t character = 0;
    memset(_msg_chunk.chunk, 0, MAX_TEXTGEN_LEN);

    const uint8_t message_len = sizeof(_statustext.next.text);
    // the message fits in an entire line of text
    if (message_len < MAX_TEXTGEN_LEN) {
        memcpy(_msg_chunk.chunk, _statustext.next.text, message_len);
        _msg_chunk.linenumber = 0;
        _statustext.available = false;
        return true;
    }

    // a following part of multi-line text
    if (_msg_chunk.linenumber == 0xFF) {
        _msg_chunk.linenumber = 0;
    } else if (_msg_chunk.char_index > 0) {
        _msg_chunk.linenumber++;
    }

    // skip leading whitespace
    while (_statustext.next.text[_msg_chunk.char_index] == ' ' && _msg_chunk.char_index < message_len) {
        _msg_chunk.char_index++;
    }

    uint8_t space_idx = 0;
    const uint8_t begin_idx = _msg_chunk.char_index;
    // can't fit it all on one line so wrap at an appropriate place
    for (int i = 0; i < MAX_TEXTGEN_LEN && _msg_chunk.char_index < message_len; i++) {
        character = _statustext.next.text[_msg_chunk.char_index++];
        // split at the first ':'
        if (character == ':') {
            _msg_chunk.chunk[i] = 0;
            break;
        }
        // record the last space if we need to go back there
        if (character == ' ') {
            space_idx = _msg_chunk.char_index;
        }

        _msg_chunk.chunk[i] = character;

        if (!character) {
            break;
        }
    }
    // still not done, can we break at a word boundary?
    if (character != 0 && _msg_chunk.char_index < message_len && space_idx > 0) {
        _msg_chunk.char_index = space_idx;
        _msg_chunk.chunk[space_idx - begin_idx - 1] = 0;
    }

    // we've reached the end of the message (string terminated by '\0' or last character of the string has been processed)
    if (character == 0 || _msg_chunk.char_index == message_len) {
        _msg_chunk.char_index = 0; // reset index to get ready to process the next message
        _statustext.available = false;
    }

    return true;
}

// prepare qos data - mandatory frame that must be sent periodically
void AP_Spektrum_Telem::calc_qos()
{
    _telem.qos.identifier = TELE_DEVICE_QOS;
    _telem.qos.sID = 0;
    _telem.qos.A = 0xFFFF;
    _telem.qos.B = 0xFFFF;
    _telem.qos.L = 0xFFFF;
    _telem.qos.R = 0xFFFF;
    _telem.qos.F = 0xFFFF;
    _telem.qos.H = 0xFFFF;
    _telem.qos.rxVoltage = 0xFFFF;
    _telem_pending = true;
}

// prepare rpm data - B/E mandatory frame that must be sent periodically
void AP_Spektrum_Telem::calc_rpm()
{
#if AP_BATTERY_ENABLED
    const AP_BattMonitor &_battery = AP::battery();
#endif

    _telem.rpm.identifier = TELE_DEVICE_RPM;
    _telem.rpm.sID = 0;
    // battery voltage in centivolts, can have up to a 12S battery (4.25Vx12S = 51.0V)
#if AP_BATTERY_ENABLED
    _telem.rpm.volts = htobe16(((uint16_t)roundf(_battery.voltage(0) * 100.0f)));
#endif
    _telem.rpm.temperature = htobe16(int16_t(roundf(32.0f + AP::baro().get_temperature(0) * 9.0f / 5.0f)));
#if AP_RPM_ENABLED
    const AP_RPM *rpm = AP::rpm();
    float rpm_value;
    if (!rpm || !rpm->get_rpm(0, rpm_value) || rpm_value < 999.0f) {
        rpm_value = 999.0f;
    }
    _telem.rpm.microseconds = htobe16(uint16_t(roundf(MICROSEC_PER_MINUTE / rpm_value)));
    _telem.rpm.dBm_A = 0x7F;
    _telem.rpm.dBm_B = 0x7F;
#endif
    _telem_pending = true;
}

void AP_Spektrum_Telem::send_msg_chunk(const MessageChunk& chunk)
{
    memcpy(_telem.textgen.text, chunk.chunk, 13);
    _telem.textgen.identifier = TELE_DEVICE_TEXTGEN;
    _telem.textgen.lineNumber = chunk.linenumber;
    _telem.textgen.sID = 0;
    _telem_pending = true;
}

// prepare battery data - B/E but not supported by Spektrum
void AP_Spektrum_Telem::calc_batt_volts(uint8_t instance)
{
#if AP_BATTERY_ENABLED
    const AP_BattMonitor &_battery = AP::battery();

    // battery voltage in centivolts, can have up to a 12S battery (4.25Vx12S = 51.0V)
    _telem.hv.volts = htobe16(uint16_t(roundf(_battery.voltage(instance) * 100.0f)));
#endif
    _telem.hv.identifier = TELE_DEVICE_VOLTAGE;
    _telem.hv.sID = 0;
    _telem_pending = true;
}

// prepare battery data - B/E but not supported by Spektrum
void AP_Spektrum_Telem::calc_batt_amps(uint8_t instance)
{
#if AP_BATTERY_ENABLED
    const AP_BattMonitor &_battery = AP::battery();

    float current;
    if (!_battery.current_amps(current, instance)) {
        current = 0;
    }

    // Range: +/- 150A     Resolution: 300A / 2048 = 0.196791 A/count
    _telem.amps.current = htobe16(int16_t(roundf(current * 2048.0f / 300.0f)));
#endif
    _telem.amps.identifier = TELE_DEVICE_AMPS;
    _telem.amps.sID = 0;
    _telem_pending = true;
}

// prepare battery data - L/E
void AP_Spektrum_Telem::calc_batt_mah()
{
#if AP_BATTERY_ENABLED
    const AP_BattMonitor &_battery = AP::battery();
#endif

    _telem.fpMAH.identifier = TELE_DEVICE_FP_MAH;
    _telem.fpMAH.sID = 0;

#if AP_BATTERY_ENABLED
    float current;
    if (!_battery.current_amps(current, 0)) {
        current = 0;
    }
    _telem.fpMAH.current_A = int16_t(roundf(current * 10.0f));     // Instantaneous current, 0.1A (0-3276.6A)

    float used_mah;
    if (!_battery.consumed_mah(used_mah, 0)) {
        used_mah = 0;
    }
    _telem.fpMAH.chargeUsed_A = int16_t(roundf(used_mah));         // Integrated mAh used, 1mAh (0-32.766Ah)

    float temp;
    if (_battery.get_temperature(temp, 0)) {
         _telem.fpMAH.temp_A = uint16_t(roundf(temp * 10.0f));     // Temperature, 0.1C (0-150C, 0x7FFF indicates not populated)
    } else {
        _telem.fpMAH.temp_A = 0x7FFF;
    }

    if (!_battery.current_amps(current, 1)) {
        current = 0;
    }
    _telem.fpMAH.current_B = int16_t(roundf(current * 10.0f));     // Instantaneous current, 0.1A (0-3276.6A)

    if (!_battery.consumed_mah(used_mah, 1)) {
        used_mah = 0;
    }
    _telem.fpMAH.chargeUsed_B = int16_t(roundf(used_mah));         // Integrated mAh used, 1mAh (0-32.766Ah)

    if (_battery.get_temperature(temp, 1)) {
         _telem.fpMAH.temp_B = uint16_t(roundf(temp * 10.0f));     // Temperature, 0.1C (0-150C, 0x7FFF indicates not populated)
    } else {
        _telem.fpMAH.temp_B = 0x7FFF;
    }
#else
        _telem.fpMAH.temp_A = 0x7FFF;
        _telem.fpMAH.temp_B = 0x7FFF;
#endif

    _telem_pending = true;
}

// prepare temperature data - B/E but not supported by Spektrum
void AP_Spektrum_Telem::calc_temperature(uint8_t instance)
{
    _telem.temp.temperature = htobe16(int16_t(roundf(32.0f + AP::baro().get_temperature(instance) * 9.0f / 5.0f)));
    _telem.temp.identifier = TELE_DEVICE_TEMPERATURE;
    _telem.temp.sID = 0;
    _telem_pending = true;
}

// prepare altitude data - B/E
void AP_Spektrum_Telem::calc_altitude()
{
    _telem.alt.identifier = TELE_DEVICE_ALTITUDE;
    _telem.alt.sID = 0;

    AP_AHRS &ahrs = AP::ahrs();
    WITH_SEMAPHORE(ahrs.get_semaphore());

    float alt = 0;
    ahrs.get_relative_position_D_home(alt);
    alt = roundf(-alt * 10.0f);
    _telem.alt.altitude = htobe16(uint16_t(alt));            // .1m increments
    _max_alt = MAX(alt, _max_alt);
    _telem.alt.maxAltitude = htobe16(uint16_t(_max_alt));    // .1m increments
    _telem_pending = true;
}

// prepare airspeed data - B/E
void AP_Spektrum_Telem::calc_airspeed()
{
    _telem.speed.identifier = TELE_DEVICE_AIRSPEED;
    _telem.speed.sID = 0;

    AP_AHRS &ahrs = AP::ahrs();
    WITH_SEMAPHORE(ahrs.get_semaphore());

    float speed = 0.0f;
#if AP_AIRSPEED_ENABLED
    const AP_Airspeed *airspeed = AP::airspeed();
    if (airspeed && airspeed->healthy()) {
        speed = roundf(airspeed->get_airspeed() * 3.6);
    } else {
        speed = roundf(AP::ahrs().groundspeed() * 3.6);
    }
#else
    speed = roundf(AP::ahrs().groundspeed() * 3.6);
#endif

    _telem.speed.airspeed = htobe16(uint16_t(speed));           // 1 km/h increments
    _max_speed = MAX(speed, _max_speed);
    _telem.speed.maxAirspeed = htobe16(uint16_t(_max_speed));   // 1 km/h increments
    _telem_pending = true;
}

// prepare attitude and compass data - L/E
void AP_Spektrum_Telem::calc_attandmag(void)
{
    _telem.attMag.identifier = TELE_DEVICE_ATTMAG;
    _telem.attMag.sID = 0;

    AP_AHRS &_ahrs = AP::ahrs();
    WITH_SEMAPHORE(_ahrs.get_semaphore());

    // Attitude, 3 axes.  Roll is a rotation about the X Axis of the vehicle using the RHR.
    // Units are 0.1 deg - Pitch is a rotation about the Y Axis of the vehicle using the RHR.
    // Yaw is a rotation about the Z Axis of the vehicle using the RHR.
    _telem.attMag.attRoll = _ahrs.roll_sensor / 10;
    _telem.attMag.attPitch = _ahrs.pitch_sensor / 10;
    _telem.attMag.attYaw = _ahrs.yaw_sensor / 10;
    _telem.attMag.heading = (_ahrs.yaw_sensor / 10) % 3600;  // Heading, 0.1deg

    const Vector3f& field = AP::compass().get_field();

    _telem.attMag.magX = int16_t(roundf(field.x * 10.0f));             // Units are 0.1mG
    _telem.attMag.magY = int16_t(roundf(field.y * 10.0f));
    _telem.attMag.magZ = int16_t(roundf(field.z * 10.0f));
    _telem_pending = true;
}

// prepare gps location - L/E
void AP_Spektrum_Telem::calc_gps_location()
{
    const Location &loc = AP::gps().location(0); // use the first gps instance (same as in send_mavlink_gps_raw)
    const uint32_t u1e8 = 100000000, u1e7 = 10000000, u1e6 = 1000000, u1e5 = 100000, u1e4 = 10000;

    _telem.gpsloc.identifier = TELE_DEVICE_GPS_LOC;                 // Source device = 0x16
    _telem.gpsloc.sID = 0;                                          // Secondary ID
    uint32_t alt = (abs(loc.alt) / 10) % u1e6;
    _telem.gpsloc.altitudeLow = ((alt % u1e4 / 1000) << 12) | ((alt % 1000 / 100) << 8)
        | ((alt % 100 / 10) << 4) | (alt % 100); // BCD, meters, format 3.1 (Low order of altitude)

    const float lat = fabsf(loc.lat / 1.0e7f);                       // BCD, format 4.4, Degrees * 100 + minutes, less than 100 degrees
    const float lng = fabsf(loc.lng / 1.0e7f);                       // BCD, format 4.4 , Degrees * 100 + minutes, flag indicates > 99 degrees

    const uint32_t ulat = roundf((int32_t(lat) * 100.0f + (lat - int32_t(lat)) * 60.0f) * 10000.0f);
    const uint32_t ulng = roundf((int32_t(lng) * 100.0f + (lng - int32_t(lng)) * 60.0f) * 10000.0f);

    _telem.gpsloc.latitude = ((ulat % u1e8 / u1e7) << 28) | ((ulat % u1e7 / u1e6) << 24) | ((ulat % u1e6 / u1e5) << 20) | ((ulat % u1e5 / u1e4) << 16)
        | ((ulat % u1e4 / 1000) << 12) | ((ulat % 1000 / 100) << 8) | ((ulat % 100 / 10) << 4) | (ulat % 10);
    _telem.gpsloc.longitude = ((ulng % u1e8 / u1e7) << 28) | ((ulng % u1e7 / u1e6) << 24) | ((ulng % u1e6 / u1e5) << 20) | ((ulng % u1e5 / u1e4) << 16)
        | ((ulng % u1e4 / 1000) << 12) | ((ulng % 1000 / 100) << 8) | ((ulng % 100 / 10) << 4) | (ulng % 10);

    uint16_t course = uint16_t(roundf(AP::gps().ground_course() * 10.0f));
    _telem.gpsloc.course = ((course % u1e5 / u1e4) << 12) | ((course % u1e4 / 1000) << 8)  | ((course % 1000 / 100) << 4) | (course % 100 / 10);  // BCD, 3.1
    uint16_t hdop = AP::gps().get_hdop(0);
    _telem.gpsloc.HDOP = ((hdop % 1000 / 100) << 4) | (hdop % 100 / 10); // BCD, format 1.1
    _telem.gpsloc.GPSflags = 0;

    if (AP::gps().status(0) >= AP_GPS::GPS_OK_FIX_3D) {
        _telem.gpsloc.GPSflags |= GPS_INFO_FLAGS_3D_FIX;
    }
    if (loc.alt < 0) {
        _telem.gpsloc.GPSflags |= GPS_INFO_FLAGS_NEGATIVE_ALT;
    }
    if ((loc.lng / 1e7) > 99) {
        _telem.gpsloc.GPSflags |= GPS_INFO_FLAGS_LONGITUDE_GREATER_99;
    }
    if (loc.lat >= 0) {
        _telem.gpsloc.GPSflags |= GPS_INFO_FLAGS_IS_NORTH;
    }
    if (loc.lng >= 0) {
        _telem.gpsloc.GPSflags |= GPS_INFO_FLAGS_IS_EAST;
    }
    if (AP::gps().status(0) > AP_GPS::NO_FIX) {
        _telem.gpsloc.GPSflags |= GPS_INFO_FLAGS_GPS_FIX_VALID;
    }
    if (AP::gps().status(0) >= AP_GPS::NO_FIX) {
        _telem.gpsloc.GPSflags |= GPS_INFO_FLAGS_GPS_DATA_RECEIVED;
    }
    _telem_pending = true;
}

// prepare gps status - L/E
void AP_Spektrum_Telem::calc_gps_status()
{
    const Location &loc = AP::gps().location(0);

    _telem.gpsstat.identifier = TELE_DEVICE_GPS_STATS;              // Source device = 0x17
    _telem.gpsstat.sID = 0;                                         // Secondary ID

    uint16_t knots = roundf(AP::gps().ground_speed() * 1.94384f * 10.0f);
    _telem.gpsstat.speed = ((knots % 10000 / 1000) << 12) | ((knots % 1000 / 100) << 8) | ((knots % 100 / 10) << 4) | (knots % 10); // BCD, knots, format 3.1
    uint16_t ms;
    uint8_t h, m, s;
#if AP_RTC_ENABLED
    AP::rtc().get_system_clock_utc(h, m, s, ms);                    // BCD, format HH:MM:SS.S, format 6.1
    // FIXME: the above call can fail!
#else
    h = 0;
    m = 0;
    s = 0;
    ms = 0;
#endif
    _telem.gpsstat.UTC = ((((h / 10) << 4) | (h % 10)) << 20) | ((((m / 10) << 4) | (m % 10)) << 12) | ((((s / 10) << 4) | (s % 10)) << 4) | (ms / 100) ;
    uint8_t nsats =  AP::gps().num_sats();
    _telem.gpsstat.numSats = ((nsats / 10) << 4) | (nsats % 10);    // BCD, 0-99
    uint32_t alt = (abs(loc.alt) / 100000);
    _telem.gpsstat.altitudeHigh = ((alt / 10) << 4) | (alt % 10); // BCD, meters, format 2.0 (High order of altitude)
    _telem_pending = true;
}

// prepare ESC information - B/E
void AP_Spektrum_Telem::calc_esc()
{
#if HAL_WITH_ESC_TELEM
    uint8_t esc = AP::esc_telem().get_max_rpm_esc();
    const volatile AP_ESC_Telem_Backend::TelemetryData& td = AP::esc_telem().get_telem_data(esc); // ideally should rotate between ESCs
    float rpm = 0.0f;
    uint16_t rpmdata = 0xFFFFU;
    if (AP::esc_telem().get_rpm(esc, rpm)) {
        rpmdata = uint16_t(roundf(rpm));
    }

	_telem.esc.identifier = TELE_DEVICE_ESC;	    // Source device = 0x20
	_telem.esc.sID = 0;									// Secondary ID
	_telem.esc.RPM = htobe16(rpmdata);	// Electrical RPM, 10RPM (0-655340 RPM)  0xFFFF --> "No data"
	_telem.esc.voltsInput = htobe16(td.voltage * 100);	    // Volts, 0.01v (0-655.34V)       0xFFFF --> "No data"
	_telem.esc.tempFET = htobe16(td.temperature_cdeg * 10);	// Temperature, 0.1C (0-6553.4C)  0xFFFF --> "No data"
	_telem.esc.currentMotor = htobe16(td.current * 100);		// Current, 10mA (0-655.34A)      0xFFFF --> "No data"
	_telem.esc.tempBEC = 0xFFFF;						// Temperature, 0.1C (0-6553.4C)  0xFFFF --> "No data"
	_telem.esc.currentBEC = 0xFF;						// BEC Current, 100mA (0-25.4A)   0xFF ----> "No data"
	_telem.esc.voltsBEC = 0xFF;							// BEC Volts, 0.05V (0-12.70V)    0xFF ----> "No data"
	_telem.esc.throttle = 0xFF;							// 0.5% (0-100%)                  0xFF ----> "No data"
	_telem.esc.powerOut = 0xFF;							// Power Output, 0.5% (0-127%)    0xFF ----> "No data"
    _telem_pending = true;
#endif
}

/*
  fetch Spektrum data for an external transport, such as SRXL2
 */
bool AP_Spektrum_Telem::_get_telem_data(uint8_t* data)
{
    memset(&_telem, 0, 16);
    run_wfq_scheduler();
    if (!_telem_pending) {
        return false;
    }
    memcpy(data, &_telem, 16);
    _telem_pending = false;
    return true;
}

/*
  fetch data for an external transport, such as SRXL2
 */
bool AP_Spektrum_Telem::get_telem_data(uint8_t* data)
{
    if (!singleton && !hal.util->get_soft_armed()) {
        // if telem data is requested when we are disarmed and don't
        // yet have a AP_Spektrum_Telem object then try to allocate one
        NEW_NOTHROW AP_Spektrum_Telem();
        // initialize the passthrough scheduler
        if (singleton) {
            singleton->init();
        }
    }
    if (!singleton) {
        return false;
    }
    return singleton->_get_telem_data(data);
}

namespace AP {
    AP_Spektrum_Telem *spektrum_telem() {
        return AP_Spektrum_Telem::get_singleton();
    }
};

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 /*
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/
#pragma once

#include "AP_RCTelemetry_config.h"

#if HAL_SPEKTRUM_TELEM_ENABLED

#include <AP_HAL/utility/RingBuffer.h>
#include "AP_RCTelemetry.h"

#define UINT8 uint8_t
#define UINT16 uint16_t
#define UINT32 uint32_t
#define UINT64 uint64_t
#define INT8 int8_t
#define INT16 int16_t
#define INT32 int32_t
extern "C" {
#include "spektrumTelemetrySensors.h"
}
#undef UINT8
#undef UINT16
#undef UINT32
#undef UINT64
#undef INT8
#undef INT16
#undef INT32

class AP_Spektrum_Telem : public AP_RCTelemetry {
public:
    AP_Spektrum_Telem();
    ~AP_Spektrum_Telem() override;

    /* Do not allow copies */
    CLASS_NO_COPY(AP_Spektrum_Telem);

    // init - perform required initialisation
    virtual bool init() override;

    static AP_Spektrum_Telem *get_singleton(void) {
        return singleton;
    }

    // get next telemetry data for external consumers of SPort data
    static bool get_telem_data(uint8_t* data);

private:

    enum SensorType {
        QOS,
        RPM,
        TEXT,
        ATTITUDE,
        GPS_LOC,
        ESC,
        ALTITUDE,
        AIRSPEED,
        GPS_STATUS,
        VOLTAGE,
        AMPS,
        MAH,
        TEMP,
        NUM_SENSORS
    };

    struct MessageChunk
    {
        uint8_t chunk[13]; // a "chunk" (13 characters/bytes) at a time of the queued message to be sent
        uint8_t linenumber;
        uint8_t char_index; // index of which character to get in the message
        uint8_t repeats;
    } _msg_chunk;

    float _max_speed = 0.0f;
    float _max_alt = 0.0f;

    // passthrough WFQ scheduler
    // Text Generator
    bool get_next_msg_chunk(void) override;
    bool repeat_msg_chunk(void);
    void send_msg_chunk(const MessageChunk& message);
    bool is_packet_ready(uint8_t idx, bool queue_empty) override;
    void process_packet(uint8_t idx) override;
    void adjust_packet_weight(bool queue_empty) override;
    // RxV + flight log data
    void calc_qos();
    // High-Voltage sensor
    void calc_batt_volts(uint8_t instance);
    // Temperature Sensor
    void calc_temperature(uint8_t instance);
    // Amps
    void calc_batt_amps(uint8_t instance);
    // Flight Battery Capacity (Dual)
    void calc_batt_mah();
    // Altitude (Eagle Tree Sensor)
    void calc_altitude();
    // Air Speed (Eagle Tree Sensor)
    void calc_airspeed();
    // Attitude and Magnetic Compass
    void calc_attandmag();
    // GPS Location Data (Eagle Tree)
    void calc_gps_location();
    // GPS Status (Eagle Tree)
    void calc_gps_status();
    // Electronic Speed Control
    void calc_esc();
    // RPM sensor
    void calc_rpm();

     // setup ready for passthrough operation
    void setup_wfq_scheduler(void) override;

     // get next telemetry data for external consumers of SPort data (internal function)
    bool _get_telem_data(uint8_t* data);

    // all Spektrum telemtry packets are big-endian!
    PACKED UN_TELEMETRY _telem;
    bool _telem_pending;

    static AP_Spektrum_Telem *singleton;
};

namespace AP {
    AP_Spektrum_Telem *spektrum_telem();
};

#endif
                                                                                                                                                                                                                                                                                                                                                                                                            //////////////////////////////////////////////////////////////////////////////
//
//	Copyright 2013 by Horizon Hobby, Inc.
//	All Rights Reserved Worldwide.
//
//	Released to Public Domain
//
//	This header file may be incorporated into non-Horizon
//	products.
//
//////////////////////////////////////////////////////////////////////////////
//
//	Author:		AK
//	Date:		2017-02-24
//	Mods:		Sync to Spektrum internal version by matching sequence of
//				structs, formatting, etc.  Also changed some structs from
//				having "id" to "identifier."  Also redefined "spare" in Rx MAH
//				to provide more bits for "chargeUsed" fields.
//
#ifndef TELEMETRY_H
#define	TELEMETRY_H

//////////////////////////////////////////////////////////////////////////////
//
//				TELEMETRY SENSOR I2C ADDRESSES & DEVICE TYPES
//
//////////////////////////////////////////////////////////////////////////////

#define	TELE_DEVICE_NODATA			(0x00)										// No data in packet, but telemetry is alive
#define	TELE_DEVICE_VOLTAGE			(0x01)										// High-Voltage sensor (INTERNAL)
#define	TELE_DEVICE_TEMPERATURE		(0x02)										// Temperature Sensor (INTERNAL)
#define	TELE_DEVICE_AMPS			(0x03)										// Amps (INTERNAL)
#define	TELE_DEVICE_RSV_04			(0x04)										// Reserved
#define	TELE_DEVICE_FLITECTRL		(0x05)										// Flight Controller Status Report
#define	TELE_DEVICE_RSV_06			(0x06)										// Reserved
#define	TELE_DEVICE_RSV_07			(0x07)										// Reserved
#define	TELE_DEVICE_RSV_08			(0x08)										// Reserved
//#define	DO_NOT_USE				(0x09)										// DO NOT USE!
#define	TELE_DEVICE_PBOX			(0x0A)										// PowerBox
#define	TELE_DEVICE_LAPTIMER		(0x0B)										// Lap Timer
#define	TELE_DEVICE_TEXTGEN			(0x0C)										// Text Generator
#define	TELE_DEVICE_VTX				(0x0D)										// Video Transmitter Feedback
#define	TELE_DEVICE_RSV_0E			(0x0E)										// Reserved
#define	TELE_DEVICE_RSV_0F			(0x0F)										// Reserved
#define	TELE_DEVICE_RSV_10			(0x10)										// Reserved
#define	TELE_DEVICE_AIRSPEED		(0x11)										// Air Speed (Eagle Tree Sensor)
#define	TELE_DEVICE_ALTITUDE		(0x12)										// Altitude (Eagle Tree Sensor)
#define	TELE_DEVICE_RSV_13			(0x13)										// Reserved
#define	TELE_DEVICE_GMETER			(0x14)										// G-Force (Eagle Tree Sensor)
#define	TELE_DEVICE_JETCAT			(0x15)										// Turbine interface (Eagle Tree)
#define	TELE_DEVICE_GPS_LOC			(0x16)										// GPS Location Data (Eagle Tree)
#define	TELE_DEVICE_GPS_STATS		(0x17)										// GPS Status (Eagle Tree)
#define	TELE_DEVICE_RX_MAH			(0x18)										// Receiver Pack Capacity (Dual)
#define	TELE_DEVICE_JETCAT_2		(0x19)										// Turbine interface, message 2 format (Eagle Tree)
#define	TELE_DEVICE_GYRO			(0x1A)										// 3-axis gyro
#define	TELE_DEVICE_ATTMAG			(0x1B)										// Attitude and Magnetic Compass
#define	TELE_DEVICE_TILT			(0x1C)										// Surface Tilt Sensor
#define	TELE_DEVICE_RSV_1D			(0x1D)										// Reserved
#define	TELE_DEVICE_AS6X_GAIN		(0x1E)										// Active AS6X Gains (new mode)
#define	TELE_DEVICE_AS3X_LEGACYGAIN	(0x1F)										// Active AS3X Gains for legacy mode
#define	TELE_DEVICE_ESC				(0x20)										// Electronic Speed Control
#define	TELE_DEVICE_RSV_21			(0x21)										// Reserved
#define	TELE_DEVICE_FUEL			(0x22)										// Fuel Flow Meter
#define	TELE_DEVICE_RSV_23			(0x23)										// Reserved
#define	TELE_DEVICE_ALPHA6			(0x24)										// Alpha6 Stabilizer
#define	TELE_DEVICE_RSV_25			(0x25)										// Reserved
#define	TELE_DEVICE_GPS_BINARY		(0x26)										// GPS, binary format
#define	TELE_DEVICE_RSV_27			(0x27)										// Reserved
#define	TELE_DEVICE_RSV_28			(0x28)										// Reserved
#define	TELE_DEVICE_RSV_29			(0x29)										// Reserved
#define	TELE_DEVICE_RSV_2A			(0x2A)										// Reserved
#define	TELE_DEVICE_RSV_2B			(0x2B)										// Reserved
#define	TELE_DEVICE_RSV_2C			(0x2C)										// Reserved
#define	TELE_DEVICE_RSV_2D			(0x2D)										// Reserved
#define	TELE_DEVICE_RSV_2E			(0x2E)										// Reserved
#define	TELE_DEVICE_RSV_2F			(0x2F)										// Reserved
//#define	DO_NOT_USE				(0x30)										// Internal ST sensor
//#define	DO_NOT_USE				(0x32)										// Internal ST sensor
#define	TELE_DEVICE_RSV_33			(0x33)										// Reserved
#define	TELE_DEVICE_FP_MAH			(0x34)										// Flight Battery Capacity (Dual)
#define	TELE_DEVICE_RSV_35			(0x35)										// Reserved
#define	TELE_DEVICE_DIGITAL_AIR		(0x36)										// Digital Inputs & Tank Pressure
#define	TELE_DEVICE_RSV_37			(0x37)										// Reserved
#define	TELE_DEVICE_STRAIN			(0x38)										// Thrust/Strain Gauge
#define	TELE_DEVICE_RSV_39			(0x39)										// Reserved
#define	TELE_DEVICE_LIPOMON			(0x3A)										// 6S Cell Monitor (LiPo taps)
#define	TELE_DEVICE_RSV_3B			(0x3B)										// Reserved
#define	TELE_DEVICE_RSV_3C			(0x3C)										// Reserved
#define	TELE_DEVICE_RSV_3D			(0x3D)										// Reserved
#define	TELE_DEVICE_RSV_3E			(0x3E)										// Reserved
#define	TELE_DEVICE_LIPOMON_14		(0x3F)										// 14S Cell Monitor (LiPo taps)
#define	TELE_DEVICE_VARIO_S			(0x40)										// Vario
#define	TELE_DEVICE_RSV_41			(0x41)										// Reserved
#define	TELE_DEVICE_SMARTBATT		(0x42)										// Spektrum SMART Battery (multiple structs)
#define	TELE_DEVICE_RSV_43			(0x43)										// Reserved
#define	TELE_DEVICE_RSV_44			(0x44)										// Reserved
#define	TELE_DEVICE_RSV_45			(0x45)										// Reserved
#define	TELE_DEVICE_RSV_46			(0x46)										// Reserved
#define	TELE_DEVICE_RSV_47			(0x47)										// Reserved
#define	TELE_DEVICE_RSV_48			(0x48)										// Reserved
#define	TELE_DEVICE_RSV_49			(0x49)										// Reserved
#define	TELE_DEVICE_RSV_4A			(0x4A)										// Reserved
#define	TELE_DEVICE_RSV_4B			(0x4B)										// Reserved
#define	TELE_DEVICE_RSV_4C			(0x4C)										// Reserved
#define	TELE_DEVICE_RSV_4D			(0x4D)										// Reserved
#define	TELE_DEVICE_RSV_4E			(0x4E)										// Reserved
#define	TELE_DEVICE_RSV_4F			(0x4F)										// Reserved
#define	TELE_DEVICE_USER_16SU		(0x50)										// User-Defined, STRU_TELE_USER_16SU
#define	TELE_DEVICE_RSV_51			(0x51)										// Reserved
#define	TELE_DEVICE_USER_16SU32U	(0x52)										// User-Defined, STRU_TELE_USER_16SU32U
#define	TELE_DEVICE_RSV_53			(0x53)										// Reserved
#define	TELE_DEVICE_USER_16SU32S	(0x54)										// User-Defined, STRU_TELE_USER_16SU32S
#define	TELE_DEVICE_RSV_55			(0x55)										// Reserved
#define	TELE_DEVICE_USER_16U32SU	(0x56)										// User-Defined, STRU_TELE_USER_16U32SU
#define	TELE_DEVICE_RSV_57			(0x57)										// Reserved
#define	TELE_DEVICE_RSV_58			(0x58)										// Reserved
#define	TELE_DEVICE_MULTICYLINDER	(0x59)										// Multi-cylinder temp sensor
#define	TELE_DEVICE_RSV_5A			(0x5A)										// Reserved
#define	TELE_DEVICE_RSV_5B			(0x5B)										// Reserved
#define	TELE_DEVICE_RSV_5C			(0x5C)										// Reserved
#define	TELE_DEVICE_RSV_5D			(0x5D)										// Reserved
#define	TELE_DEVICE_RSV_5E			(0x5E)										// Reserved
#define	TELE_DEVICE_RSV_5F			(0x5F)										// Reserved
#define	TELE_DEVICE_VSPEAK			(0x60)										// Reserved for V-Speak
#define	TELE_DEVICE_SMOKE_EL		(0x61)										// Reserved for Smoke-EL.de
#define	TELE_DEVICE_CROSSFIRE		(0x62)										// Reserved for Crossfire devices
#define	TELE_DEVICE_RSV_63			(0x63)										// Reserved
#define	TELE_DEVICE_RSV_64			(0x64)										// Reserved
#define	TELE_DEVICE_RSV_65			(0x65)										// Reserved
#define	TELE_DEVICE_EXTRF			(0x66)										// Reserved for Generic External RF sources
#define	TELE_DEVICE_RSV_67			(0x67)										// Reserved
#define	TELE_DEVICE_RSV_68			(0x68)										// Reserved
#define	TELE_DEVICE_RSV_69			(0x69)										// Reserved
#define	TELE_DEVICE_RSV_6A			(0x6A)										// Reserved
//#define	DO_NOT_USE				(0x6B)										// DO NOT USE!
#define	TELE_DEVICE_RSV_6C			(0x6C)										// Reserved
#define	TELE_DEVICE_RSV_6D			(0x6D)										// Reserved
#define	TELE_DEVICE_RSV_6E			(0x6E)										// Reserved
#define	TELE_DEVICE_RSV_6F			(0x6F)										// Reserved
#define	TELE_DEVICE_RSV_70			(0x70)										// Reserved
#define	TELE_XRF_LINKSTATUS			(0x71)										// External RF Link Status
#define	TELE_DEVICE_RSV_72			(0x72)										// Reserved
#define	TELE_DEVICE_RSV_73			(0x73)										// Reserved
#define	TELE_DEVICE_RSV_74			(0x74)										// Reserved
#define	TELE_DEVICE_RSV_75			(0x75)										// Reserved
#define	TELE_DEVICE_RSV_76			(0x76)										// Reserved
#define	TELE_DEVICE_RSV_77			(0x77)										// Reserved
#define	TELE_DEVICE_RSV_78			(0x78)										// Reserved
#define	TELE_DEVICE_RSV_79			(0x79)										// Reserved
#define	TELE_DEVICE_RSV_7A			(0x7A)										// Reserved
#define	TELE_DEVICE_ALT_ZERO		(0x7B)										// Pseudo-device setting Altitude "zero"
#define	TELE_DEVICE_RTC				(0x7C)										// Pseudo-device giving timestamp
#define	TELE_DEVICE_RPM				(0x7E)										// RPM sensor
#define	TELE_DEVICE_QOS				(0x7F)										// RxV + flight log data
#define	TELE_DEVICE_MAX				(0x7F)										// Last address available

#define	TELE_DEVICE_SHORTRANGE		(0x80)										// OR this bit to indicate data is from a short-range telemetry device (e.g. TM1100)

#define	TELE_DEVICE_MAX_PROGRAM		(0x70)										// Last programmable address when using sID

//////////////////////////////////////////////////////////////////////////////
//
//							TELEMETRY
//					DEVICE-SPECIFIC STRUCTURES
//
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
//		THIRD-PARTY 16-BIT DATA SIGNED/UNSIGNED
//
//////////////////////////////////////////////////////////////////////////////
//
typedef struct
{
	UINT8	identifier;															// Source device = 0x50
	UINT8	sID;																// Secondary ID
	INT16	sField1,															// Signed 16-bit data fields
			sField2,
			sField3;
	UINT16	uField1, 															// Unsigned 16-bit data fields
			uField2,
			uField3,
			uField4;
} STRU_TELE_USER_16SU;

//////////////////////////////////////////////////////////////////////////////
//
//		THIRD-PARTY 16-BIT SIGNED/UNSIGNED AND 32-BIT UNSIGNED
//
//////////////////////////////////////////////////////////////////////////////
//
typedef struct
{
	UINT8	identifier;															// Source device = 0x52
	UINT8	sID;																// Secondary ID
	INT16	sField1,															// Signed 16-bit data fields
			sField2;
	UINT16	uField1, 															// Unsigned 16-bit data fields
			uField2,
			uField3;
	UINT32	u32Field; 															// Unsigned 32-bit data field
} STRU_TELE_USER_16SU32U;

//////////////////////////////////////////////////////////////////////////////
//
//		THIRD-PARTY 16-BIT SIGNED/UNSIGNED AND 32-BIT SIGNED
//
//////////////////////////////////////////////////////////////////////////////
//
typedef struct
{
	UINT8	identifier;															// Source device = 0x54
	UINT8	sID;																// Secondary ID
	INT16	sField1,															// Signed 16-bit data fields
			sField2;
	UINT16	uField1, 															// Unsigned 16-bit data fields
			uField2,
			uField3;
	INT32	s32Field; 															// Signed 32-bit data field
} STRU_TELE_USER_16SU32S;

//////////////////////////////////////////////////////////////////////////////
//
//		THIRD-PARTY 16-BIT UNSIGNED AND 32-BIT SIGNED/UNSIGNED
//
//////////////////////////////////////////////////////////////////////////////
//
typedef struct
{
	UINT8	identifier;															// Source device = 0x56
	UINT8	sID;																// Secondary ID
	UINT16	uField1; 															// Unsigned 16-bit data field
	INT32	s32Field; 															// Signed 32-bit data field
	UINT32	u32Field1, 															// Unsigned 32-bit data fields
			u32Field2;
} STRU_TELE_USER_16U32SU;

//////////////////////////////////////////////////////////////////////////////
//
//							POWERBOX
//
//////////////////////////////////////////////////////////////////////////////
//
typedef struct
{
	UINT8	identifier;															// Source device = 0x0A
	UINT8	sID;																// Secondary ID
	UINT16	volt1;																// Volts, 0.01v
	UINT16	volt2;																// Volts, 0.01v
	UINT16	capacity1;															// mAh, 1mAh
	UINT16	capacity2;															// mAh, 1mAh
	UINT16	spare16_1;
	UINT16	spare16_2;
	UINT8	spare;
	UINT8	alarms;																// Alarm bitmask (see below)
} STRU_TELE_POWERBOX;

#define	TELE_PBOX_ALARM_VOLTAGE_1			(0x01)
#define	TELE_PBOX_ALARM_VOLTAGE_2			(0x02)
#define	TELE_PBOX_ALARM_CAPACITY_1			(0x04)
#define	TELE_PBOX_ALARM_CAPACITY_2			(0x08)
//#define	TELE_PBOX_ALARM_RPM					(0x10)
//#define	TELE_PBOX_ALARM_TEMPERATURE			(0x20)
#define	TELE_PBOX_ALARM_RESERVED_1			(0x40)
#define	TELE_PBOX_ALARM_RESERVED_2			(0x80)

//////////////////////////////////////////////////////////////////////////////
//
//							VOLTAGE
//
//////////////////////////////////////////////////////////////////////////////
//
typedef struct
{
	UINT8		identifier;														// Source device = 0x01
	UINT8		sID;															// Secondary ID
	UINT16		volts;															// 0.01V increments
} STRU_TELE_HV;

//////////////////////////////////////////////////////////////////////////////
//
//							TEMPERATURE
//
//////////////////////////////////////////////////////////////////////////////
//
typedef struct
{
	UINT8		identifier;														// Source device = 0x02
	UINT8		sID;															// Secondary ID
	INT16		temperature;													// Temperature in degrees Fahrenheit
} STRU_TELE_TEMP;

//////////////////////////////////////////////////////////////////////////////
//
//						RX CAPACITY METER
//
//////////////////////////////////////////////////////////////////////////////
//
typedef struct
{
	UINT8		identifier;														// Source device = 0x18
	UINT8		sID;															// Secondary ID
	INT16		current_A;														// Instantaneous current, 0.01A (0-328.7A)		7FFF-> no data
	UINT16		chargeUsed_A;													// Integrated mAh used, 0.1mAh (0-3276.6mAh)
	UINT16		volts_A;														// Volts, 0.01V increments (0-16.00V)
	INT16		current_B;														// Instantaneous current, 0.01A (0-328.7A)		7FFF-> no data/sensor B
	UINT16		chargeUsed_B;													// Integrated mAh used, 0.1mAh (0-3276.6mAh)
	UINT16		volts_B;														// Volts, 0.01V increments (0-16.00V)
	UINT8		alerts,															// Bit mapped alert conditions (see below)
				highCharge;														// High nybble is extra bits for chargeUsed_B, Low is for chargeUsed_A
} STRU_TELE_RX_MAH;

#define	RXMAH_PS_ALERT_NONE			(0)											// No alarms
#define	RXMAH_PS_ALERT_RF_INT		(1 << 0)									// A or internal Remote failure
#define	RXMAH_PS_ALERT_RF_ANT1		(1 << 1)									// B remote power fault
#define	RXMAH_PS_ALERT_RF_ANT2		(1 << 2)									// L remote power fault
#define	RXMAH_PS_ALERT_RF_ANT3		(1 << 3)									// R remote power fault
#define	RXMAH_PS_ALERT_OVERVOLT_A	(1 << 4) 									// Battery A is over voltage
#define	RXMAH_PS_ALERT_OVERVOLT_B	(1 << 5) 									// Battery A is over voltage
#define	RXMAH_PS_ALERT_RFU1			(1 << 6)
#define	RXMAH_PS_ALERT_RFU2			(1 << 7)

//////////////////////////////////////////////////////////////////////////////
//
//							HIGH-CURRENT
//
//////////////////////////////////////////////////////////////////////////////
//
typedef struct
{
	UINT8		identifier;														// Source device = 0x03
	UINT8		sID;															// Secondary ID
	INT16		current,														// Range: +/- 150A     Resolution: 300A / 2048 = 0.196791 A/count
				dummy;															// TBD
} STRU_TELE_IHIGH;

#define	IHIGH_RESOLUTION_FACTOR						((FP32)(0.196791))

//////////////////////////////////////////////////////////////////////////////
//
//							SIMPLE VARIO
//
//////////////////////////////////////////////////////////////////////////////
//
typedef struct
{
	UINT8		identifier;														// Source device = 0x40
	UINT8		sID;															// Secondary ID
	INT16		altitude;														// .1m increments
	INT16		delta_0250ms,													// change in altitude last 250ms, 0.1m/s increments
				delta_0500ms,													// change in altitude last 500ms, 0.1m/s increments
				delta_1000ms,													// change in altitude last 1.0 seconds, 0.1m/s increments
				delta_1500ms,													// change in altitude last 1.5 seconds, 0.1m/s increments
				delta_2000ms,													// change in altitude last 2.0 seconds, 0.1m/s increments
				delta_3000ms;													// change in altitude last 3.0 seconds, 0.1m/s increments
} STRU_TELE_VARIO_S;

//////////////////////////////////////////////////////////////////////////////
//
//							ALTIMETER
//
//////////////////////////////////////////////////////////////////////////////
//
typedef struct
{
	UINT8		identifier;
	UINT8		sID;															// Secondary ID
	INT16		altitude;														// .1m increments
	INT16		maxAltitude;													// .1m increments
} STRU_TELE_ALT;																// Eagle Tree Sensor

//////////////////////////////////////////////////////////////////////////////
//
//							AIRSPEED
//
//////////////////////////////////////////////////////////////////////////////
//
typedef struct
{
	UINT8		identifier;
	UINT8		sID;															// Secondary ID
	UINT16		airspeed;														// 1 km/h increments
	UINT16		maxAirspeed;													// 1 km/h increments
} STRU_TELE_SPEED;																// Eagle Tree Sensor

//////////////////////////////////////////////////////////////////////////////
//
//							LAP TIMER
//
//////////////////////////////////////////////////////////////////////////////
//
typedef struct
{
	UINT8		identifier;
	UINT8		sID;															// Secondary ID
	UINT8		lapNumber;														// Lap last finished
	UINT8		gateNumber;														// Last gate passed
	UINT32		lastLapTime;													// Time of lap in 1ms increments (NOT duration)
	UINT32		gateTime;														// Duration between last 2 gates
	UINT8		unused[4];
} STRU_TELE_LAPTIMER;

//////////////////////////////////////////////////////////////////////////////
//
//							TEXT GENERATOR
//
//////////////////////////////////////////////////////////////////////////////
//
typedef struct
{
	UINT8		identifier;
	UINT8		sID;															// Secondary ID
	UINT8		lineNumber;														// Line number to display (0 = title, 1-8 for general, 254 = Refresh backlight, 255 = Erase all text on screen)
	char		text[13];														// 0-terminated text when < 13 chars
} STRU_TELE_TEXTGEN;

//////////////////////////////////////////////////////////////////////////////
//
//							VIDEO TRANSMITTER (VTX)
//
//////////////////////////////////////////////////////////////////////////////
//
//	VTX spec subject to change. Refer to Spektrum VTX Interfacing document for latest info
//
typedef struct
{
	UINT8		identifier;
	UINT8		sID;															// Secondary ID
	UINT8		band;															// VTX Band (0 = Fatshark, 1 = Raceband, 2 = E, 3 = B, 4 = A, 5-7 = Reserved)
	UINT8		channel;														// VTX Channel (0-7)
	UINT8		pit;															// Pit/Race mode (0 = Race, 1 = Pit). Race = (normal operating) mode. Pit = (reduced power) mode. When PIT is set, it overrides all other power settings.
	UINT8		power;															// VTX Power (0 = Off, 1 = 1mw to 14mW, 2 = 15mW to 25mW, 3 = 26mW to 99mW, 4 = 100mW to 299mW, 5 = 300mW to 600mW, 6 = 601mW+, 7 = manual control)
	UINT16		powerDec;														// VTX Power as a decimal 1mw/unit
	UINT8		region;															// Region (0 = USA, 1 = EU, 0xFF = Not Provided)
	UINT8		unused[7];														// reserved
} STRU_TELE_VTX;

//////////////////////////////////////////////////////////////////////////////
//
//							ESC
//
//////////////////////////////////////////////////////////////////////////////
//
//	Uses big-endian byte order
//
typedef struct
{
	UINT8		identifier;														// Source device = 0x20
	UINT8		sID;															// Secondary ID
	UINT16		RPM;															// Electrical RPM, 10RPM (0-655340 RPM)  0xFFFF --> "No data"
	UINT16		voltsInput;														// Volts, 0.01v (0-655.34V)       0xFFFF --> "No data"
	UINT16		tempFET;														// Temperature, 0.1C (0-6553.4C)  0xFFFF --> "No data"
	UINT16		currentMotor;													// Current, 10mA (0-655.34A)      0xFFFF --> "No data"
	UINT16		tempBEC;														// Temperature, 0.1C (0-6553.4C)  0xFFFF --> "No data"
	UINT8		currentBEC;														// BEC Current, 100mA (0-25.4A)   0xFF ----> "No data"
	UINT8		voltsBEC;														// BEC Volts, 0.05V (0-12.70V)    0xFF ----> "No data"
	UINT8		throttle;														// 0.5% (0-100%)                  0xFF ----> "No data"
	UINT8		powerOut;														// Power Output, 0.5% (0-127%)    0xFF ----> "No data"
} STRU_TELE_ESC;

//////////////////////////////////////////////////////////////////////////////
//
//		(Liquid) Fuel Flow/Capacity (Two Tanks/Engines)
//
//////////////////////////////////////////////////////////////////////////////
//
typedef struct
{
	UINT8		identifier;														// Source device = 0x22
	UINT8		sID;															// Secondary ID
	UINT16		fuelConsumed_A;													// Integrated fuel consumption, 0.1mL
	UINT16		flowRate_A;														// Instantaneous consumption, 0.01mL/min
	UINT16		temp_A;															// Temperature, 0.1C (0-655.34C)
	UINT16		fuelConsumed_B;													// Integrated fuel consumption, 0.1mL
	UINT16		flowRate_B;														// Instantaneous consumption, 0.01mL/min
	UINT16		temp_B;															// Temperature, 0.1C (0-655.34C)
	UINT16		spare;															// Not used
} STRU_TELE_FUEL;

//////////////////////////////////////////////////////////////////////////////
//
//		Battery Current/Capacity (Flight Pack Capacity)
//
//////////////////////////////////////////////////////////////////////////////
//
// AK 2013-11-19 make struct align with 0x03 device
//
typedef struct
{
	UINT8		identifier;														// Source device = 0x34
	UINT8		sID;															// Secondary ID
	INT16		current_A;														// Instantaneous current, 0.1A (0-3276.6A)
	INT16		chargeUsed_A;													// Integrated mAh used, 1mAh (0-32.766Ah)
	UINT16		temp_A;															// Temperature, 0.1C (0-150C, 0x7FFF indicates not populated)
	INT16		current_B;														// Instantaneous current, 0.1A (0-3276.6A)
	INT16		chargeUsed_B;													// Integrated mAh used, 1mAh (0-32.766Ah)
	UINT16		temp_B;															// Temperature, 0.1C (0-150C, 0x7FFF indicates not populated)
	UINT16		spare;															// Not used
} STRU_TELE_FP_MAH;

//////////////////////////////////////////////////////////////////////////////
//
//		Digital Input Status (Retract Status) and Tank Pressure
//
//////////////////////////////////////////////////////////////////////////////
//
typedef struct
{
	UINT8		identifier;														// Source device = TELE_DEVICE_DIGITAL_AIR
	UINT8		sID;															// Secondary ID
	UINT16		digital;														// Digital inputs (bit per input)
	UINT16		spare1;
	UINT16		pressure[4];													// Tank pressure, 0.1PSI (0-6553.4PSI), 0xFFFF = Not Installed
	UINT16		spare2;
} STRU_TELE_DIGITAL_AIR;

//////////////////////////////////////////////////////////////////////////////
//
//		Thrust/Strain Gauge
//
//////////////////////////////////////////////////////////////////////////////
//
typedef struct
{
	UINT8		identifier;														// Source device = 0x38
	UINT8		sID;															// Secondary ID
	UINT16		strain_A,														// Strain sensor A
				strain_B,														// Strain sensor B
				strain_C,														// Strain sensor D
				strain_D;														// Strain sensor C
} STRU_TELE_STRAIN;

//////////////////////////////////////////////////////////////////////////////
//
//						6S LiPo Cell Monitor
//
//////////////////////////////////////////////////////////////////////////////
//
typedef struct
{
	UINT8		identifier;														// Source device = 0x3A
	UINT8		sID;															// Secondary ID
	UINT16		cell[6];														// Voltage across cell 1, .01V steps
																				// 0x7FFF --> cell not present
	UINT16		temp;															// Temperature, 0.1C (0-655.34C)
} STRU_TELE_LIPOMON;

//////////////////////////////////////////////////////////////////////////////
//
//						14S LiPo Cell Monitor
//
//////////////////////////////////////////////////////////////////////////////
//
typedef struct
{
	UINT8		identifier;														// Source device = 0x3F
	UINT8		sID;															// Secondary ID
	UINT8		cell[14];														// Voltage across cell 1, .01V steps, excess of 2.56V
																				// (ie, 3.00V would report 300-256 = 44)
																				// 0xFF --> cell not present
} STRU_TELE_LIPOMON_14;

//////////////////////////////////////////////////////////////////////////////
//
//								Smart Battery
//
//////////////////////////////////////////////////////////////////////////////
//
//			Uses little-endian byte order for all multi-byte fields
//
typedef struct
{
	UINT8	identifier;															// Source device = 0x42
	UINT8	sID;																// Secondary ID
	UINT8	typeChannel;														// Upper nybble = Message type; Lower nybble = Battery number (0 or 1)
	UINT8	msgData[13];														// Message-specific data, determined by upper nybble of typeChannel (see defs below)
} STRU_SMARTBATT_HEADER;

#define	SMARTBATT_MSG_TYPE_MASK_BATTNUMBER		(0x0F)
#define	SMARTBATT_MSG_TYPE_MASK_MSGTYPE			(0xF0)

#define SMARTBATT_MSG_TYPE_REALTIME				(0x00)
#define SMARTBATT_MSG_TYPE_CELLS_1_6			(0x10)
#define SMARTBATT_MSG_TYPE_CELLS_7_12			(0x20)
#define SMARTBATT_MSG_TYPE_CELLS_13_18			(0x30)
#define SMARTBATT_MSG_TYPE_ID					(0x80)
#define SMARTBATT_MSG_TYPE_LIMITS				(0x90)

//...........................................................................
// Real-time battery data when current sense is available
typedef struct
{
	UINT8		identifier;														// Source device = 0x42
	UINT8		sID;															// Secondary ID
	UINT8		typeChannel;													// Msg type = SMARTBATT_MSG_TYPE_REALTIME | Battery number (0 or 1)
	INT8		temperature_C;													// Temperature in degrees C, 1 degree increments (-128 = unavailable)
	UINT32		dischargeCurrent_mA;											// Amount of current being drawn from battery, in mA steps (0xFFFFFFFF = unavailable)
	UINT16		batteryCapacityUsage_mAh;										// Approximate battery capacity usage, in mAh (0xFFFF = unavailable)
	UINT16		minCellVoltage_mV;												// Minimum cell voltage of pack, in mV
	UINT16		maxCellVoltage_mV;												// Maximum cell voltage of pack, in mV
	UINT8		rfu[2];
} STRU_SMARTBATT_REALTIME;

//...........................................................................
// Real-time cell voltage
typedef struct
{
	UINT8		identifier;														// Source device = 0x42
	UINT8		sID;															// Secondary ID
	UINT8		typeChannel;													// Msg type = SMARTBATT_MSG_TYPE_CELLS_X_Y | Battery number (0 or 1)
	INT8		temperature_C;													// Temperature in degrees C, 1 degree increments (-128 = unavailable)
	UINT16		cellVoltage_mV[6];												// Cell voltage of first 6 cells, in mV (0xFFFF = unavailable)
} STRU_SMARTBATT_CELLS;

//...........................................................................
// Smart Battery ID and general info
typedef struct
{
	UINT8		identifier;														// Source device = 0x42
	UINT8		sID;															// Secondary ID
	UINT8		typeChannel;													// Msg type = SMARTBATT_MSG_TYPE_ID | Battery number (0 or 1)
	UINT8		chemistry;														// 0:LiHv, 1:LiPo, 2:LiIon, 3:LiFe, 4:Pb, 5:Ni-MH/Cd
	UINT8		numOfCells;														// Number of cells in the battery
	UINT8		manufacturer;													// 0:BattGo
	UINT16		cycles;															// Number of charge/discharge cycles recorded (0 = unavailable)
	UINT8		uniqueID[8];													// Unique battery ID, manufacturer-specific
																				// 0: [0]   = lower (first) byte of "Customer ID"
																				//    [1-3] = lower 3 bytes of "Special Mark of Battery"
																				//    [4-7] = 4-byte "Manufacturing Date"
} STRU_SMARTBATT_ID;

//...........................................................................
// Smart Battery Limits
typedef struct
{
	UINT8		identifier;														// Source device = 0x42
	UINT8		sID;															// Secondary ID
	UINT8		typeChannel;													// Msg type = SMARTBATT_MSG_TYPE_LIMITS | Battery number (0 or 1)
	UINT8		rfu;
	UINT16		fullCapacity_mAh;												// Fully charged battery capacity, in mAh
	UINT16		dischargeCurrentRating;											// Rated discharge current, in 0.1C
	UINT16		overDischarge_mV;												// Limit below which battery is likely damaged, in mV
	UINT16		zeroCapacity_mV;												// Voltage at which LVC protection should activate, in mV
	UINT16		fullyCharged_mV;												// Voltage reading expected when fully charged, in mV
	INT8		minWorkingTemp;													// Minimum working temperature in degrees C, 1 degree steps
	INT8		maxWorkingTemp;													// Maximum working temperature in degrees C, 1 degree steps
} STRU_SMARTBATT_LIMITS;

//////////////////////////////////////////////////////////////////////////////
//
//							ACCELEROMETER
//
//////////////////////////////////////////////////////////////////////////////
//
typedef struct
{
	UINT8		identifier;														// Source device = 0x14
	UINT8		sID;															// Secondary ID
	INT16		GForceX;														// force is reported as .01G increments
	INT16		GForceY;														// 		Range = +/-4000 (+/- 40G) in Pro model
	INT16		GForceZ;														// 		Range = +/-800 (+/- 8G) in Standard model
	INT16		maxGForceX;														// abs(max G X-axis)   FORE/AFT
	INT16		maxGForceY;														// abs (max G Y-axis)  LEFT/RIGHT
	INT16		maxGForceZ;														// max G Z-axis        WING SPAR LOAD
	INT16		minGForceZ;														// min G Z-axis        WING SPAR LOAD
} STRU_TELE_G_METER;

//////////////////////////////////////////////////////////////////////////////
//
//						SURFACE TILT (ATTITUDE) SENSOR
//
//////////////////////////////////////////////////////////////////////////////
//
typedef struct
{
	UINT8		identifier;														// Source device = 0x1C TELE_DEVICE_TILT
	UINT8		sID;															// Secondary ID
	INT16		attQuatX;														// Quaternion representing attitude using RHR. X component in Q14.
	INT16		attQuatY;														// Y component in Q14.
	INT16		attQuatZ;														// Z component in Q14.
	INT16		attQuatW;														// W component in Q14.
	UINT16		spare[3];
} STRU_TELE_TILT;

//////////////////////////////////////////////////////////////////////////////
//
//								TURBINE
//
//////////////////////////////////////////////////////////////////////////////
//
typedef struct
{
	UINT8		identifier;														// Source device = 0x15
	UINT8		sID;															// Secondary ID
	UINT8		status;															// Table below
	UINT8		throttle;														// (BCD) xx Percent
	UINT16		packVoltage;													// (BCD) xx.yy
	UINT16		pumpVoltage;													// (BCD) xx.yy
	UINT32		RPM;															// (BCD)
	UINT16		EGT;															// (BCD) Temperature, Celsius
	UINT8		offCondition;													// Table below
	UINT8		spare;
} STRU_TELE_JETCAT;

enum JETCAT_ECU_TURBINE_STATE {							// ECU Status definitions
		JETCAT_ECU_STATE_OFF = 0x00,
		JETCAT_ECU_STATE_WAIT_for_RPM = 0x01, // (Stby/Start)
		JETCAT_ECU_STATE_Ignite = 0x02,
		JETCAT_ECU_STATE_Accelerate = 0x03,
		JETCAT_ECU_STATE_Stabilise = 0x04,
		JETCAT_ECU_STATE_Learn_HI = 0x05,
		JETCAT_ECU_STATE_Learn_LO = 0x06,
		JETCAT_ECU_STATE_UNDEFINED = 0x07,
		JETCAT_ECU_STATE_Slow_Down = 0x08,
		JETCAT_ECU_STATE_Manual = 0x09,
		JETCAT_ECU_STATE_AutoOff = 0x10,
		JETCAT_ECU_STATE_Run = 0x11, // (reg.)
		JETCAT_ECU_STATE_Accleleration_delay = 0x12,
		JETCAT_ECU_STATE_SpeedReg = 0x13, // (Speed Ctrl)
		JETCAT_ECU_STATE_Two_Shaft_Regulate = 0x14, // (only for secondary shaft)
		JETCAT_ECU_STATE_PreHeat1 = 0x15,
		JETCAT_ECU_STATE_PreHeat2 = 0x16,
		JETCAT_ECU_STATE_MainFStart = 0x17,
		JETCAT_ECU_STATE_NotUsed = 0x18,
		JETCAT_ECU_STATE_KeroFullOn = 0x19,
		// undefined states 0x1A-0x1F
		EVOJET_ECU_STATE_off = 0x20,
		EVOJET_ECU_STATE_ignt = 0x21,
		EVOJET_ECU_STATE_acce = 0x22,
		EVOJET_ECU_STATE_run = 0x23,
		EVOJET_ECU_STATE_cal = 0x24,
		EVOJET_ECU_STATE_cool = 0x25,
		EVOJET_ECU_STATE_fire = 0x26,
		EVOJET_ECU_STATE_glow = 0x27,
		EVOJET_ECU_STATE_heat = 0x28,
		EVOJET_ECU_STATE_idle = 0x29,
		EVOJET_ECU_STATE_lock = 0x2A,
		EVOJET_ECU_STATE_rel = 0x2B,
		EVOJET_ECU_STATE_spin = 0x2C,
		EVOJET_ECU_STATE_stop = 0x2D,
		// undefined states 0x2E-0x2F
		HORNET_ECU_STATE_OFF = 0x30,
		HORNET_ECU_STATE_SLOWDOWN = 0x31,
		HORNET_ECU_STATE_COOL_DOWN = 0x32,
		HORNET_ECU_STATE_AUTO = 0x33,
		HORNET_ECU_STATE_AUTO_HC = 0x34,
		HORNET_ECU_STATE_BURNER_ON = 0x35,
		HORNET_ECU_STATE_CAL_IDLE = 0x36,
		HORNET_ECU_STATE_CALIBRATE = 0x37,
		HORNET_ECU_STATE_DEV_DELAY = 0x38,
		HORN/*
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include <AP_RPM/AP_RPM_Params.h>

// table of user settable parameters
const AP_Param::GroupInfo AP_RPM_Params::var_info[] = {
    // @Param: TYPE
    // @DisplayName: RPM type
    // @Description: What type of RPM sensor is connected
    // @Values: 0:None,1:Not Used,2:GPIO,3:EFI,4:Harmonic Notch,5:ESC Telemetry Motors Bitmask,6:Generator,7:DroneCAN
    // @User: Standard
    AP_GROUPINFO_FLAGS("TYPE", 1, AP_RPM_Params, type, 0, AP_PARAM_FLAG_ENABLE),
    // Note, 1 was previously for type = PWM. This has been removed from docs to make setup less confusing for users.
    // However, 1 is reserved as it does still fallthrough to type = GPIO.

    // @Param: SCALING
    // @DisplayName: RPM scaling
    // @Description: Scaling factor between sensor reading and RPM.
    // @Increment: 0.001
    // @User: Standard
    AP_GROUPINFO("SCALING", 2, AP_RPM_Params, scaling, 1.0f),

    // @Param: MAX
    // @DisplayName: Maximum RPM
    // @Description: Maximum RPM to report. Only used on type = GPIO.
    // @Increment: 1
    // @User: Standard
    AP_GROUPINFO("MAX", 3, AP_RPM_Params, maximum, 100000),

    // @Param: MIN
    // @DisplayName: Minimum RPM
    // @Description: Minimum RPM to report. Only used on type = GPIO.
    // @Increment: 1
    // @User: Standard
    AP_GROUPINFO("MIN", 4, AP_RPM_Params, minimum, 10),

    // @Param: MIN_QUAL
    // @DisplayName: Minimum Quality
    // @Description: Minimum data quality to be used
    // @Increment: 0.1
    // @User: Advanced
    AP_GROUPINFO("MIN_QUAL", 5, AP_RPM_Params, quality_min, 0.5),

    // @Param: PIN
    // @DisplayName: Input pin number
    // @Description: Which digital GPIO pin to use. Only used on type = GPIO. Some common values are given, but see the Wiki's "GPIOs" page for how to determine the pin number for a given autopilot.
    // @Values: -1:Disabled,50:AUX1,51:AUX2,52:AUX3,53:AUX4,54:AUX5,55:AUX6
    // @User: Standard
    AP_GROUPINFO("PIN", 6, AP_RPM_Params, pin, -1),

    // @Param: ESC_MASK
    // @DisplayName: Bitmask of ESC telemetry channels to average
    // @Description: Mask of channels which support ESC rpm telemetry. RPM telemetry of the selected channels will be averaged
    // @Bitmask: 0:Channel1,1:Channel2,2:Channel3,3:Channel4,4:Channel5,5:Channel6,6:Channel7,7:Channel8,8:Channel9,9:Channel10,10:Channel11,11:Channel12,12:Channel13,13:Channel14,14:Channel15,15:Channel16
    // @User: Advanced
    AP_GROUPINFO("ESC_MASK", 7, AP_RPM_Params, esc_mask, 0),

#if AP_RPM_ESC_TELEM_OUTBOUND_ENABLED
    // @Param: ESC_INDEX
    // @DisplayName: ESC Telemetry Index to write RPM to
    // @Description: ESC Telemetry Index to write RPM to. Use 0 to disable.
    // @Range: 0 10
    // @Increment: 1
    // @User: Advanced
    AP_GROUPINFO("ESC_INDEX", 8, AP_RPM_Params, esc_telem_outbound_index, 0),
#endif

#if AP_RPM_DRONECAN_ENABLED || defined(HAL_PERIPH_ENABLE_RPM_STREAM)
    // @Param: DC_ID
    // @DisplayName: DroneCAN Sensor ID
    // @Description: DroneCAN sensor ID to assign to this backend
    // @Description{AP_Periph}: DroneCAN sensor ID to send as on AP-Periph -1 disables
    // @Range: -1 10
    // @Increment: 1
    // @User: Advanced
    AP_GROUPINFO("DC_ID", 9, AP_RPM_Params, dronecan_sensor_id, -1),
#endif

    AP_GROUPEND
};

AP_RPM_Params::AP_RPM_Params(void)
{
    AP_Param::setup_object_defaults(this, var_info);
}
                                                                                   /*
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
#pragma once
#include <AP_Param/AP_Param.h>
#include "AP_RPM_config.h"

class AP_RPM_Params {

public:
    // Constructor
    AP_RPM_Params(void);

    // parameters for each instance
    AP_Int8  type;
    AP_Int8  pin;
    AP_Float scaling;
    AP_Float maximum;
    AP_Float minimum;
    AP_Float quality_min;
    AP_Int32 esc_mask;
#if AP_RPM_ESC_TELEM_OUTBOUND_ENABLED
    AP_Int8  esc_telem_outbound_index;
#endif
#if AP_RPM_DRONECAN_ENABLED || defined(HAL_PERIPH_ENABLE_RPM_STREAM)
    AP_Int8 dronecan_sensor_id;
#endif
    static const struct AP_Param::GroupInfo var_info[];

};
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           