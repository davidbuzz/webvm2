M > 0
    struct PACKED param_defaults_struct {
        char magic_str[8];
        uint8_t param_magic[8];
        uint16_t max_length;
        volatile uint16_t length;
        volatile char data[AP_PARAM_MAX_EMBEDDED_PARAM];
    };
    static const param_defaults_struct param_defaults_data;
#endif


    static void                 check_group_info(const struct GroupInfo *group_info, uint16_t *total_size, 
                                                 uint8_t max_bits, uint8_t prefix_length);
    static bool                 duplicate_key(uint16_t vindex, uint16_t key);

    static bool adjust_group_offset(uint16_t vindex, const struct GroupInfo &group_info, ptrdiff_t &new_offset);
    static bool get_base(const struct Info &info, ptrdiff_t &base);

    /// get group_info pointer based on flags
    static const struct GroupInfo *get_group_info(const struct GroupInfo &ginfo);

    /// get group_info pointer based on flags
    static const struct GroupInfo *get_group_info(const struct Info &ginfo);

    const struct Info *         find_var_info_group(
                                    const struct GroupInfo *    group_info,
                                    uint16_t                    vindex,
                                    uint32_t                    group_base,
                                    uint8_t                     group_shift,
                                    ptrdiff_t                   group_offset,
                                    uint32_t *                  group_element,
                                    const struct GroupInfo *   &group_ret,
                                    struct GroupNesting        &group_nesting,
                                    uint8_t *                   idx) const;
    const struct Info *         find_var_info(
                                    uint32_t *                group_element,
                                    const struct GroupInfo *  &group_ret,
                                    struct GroupNesting       &group_nesting,
                                    uint8_t *                 idx) const;
    const struct Info *			find_var_info_token(const ParamToken &token,
                                                    uint32_t *                 group_element,
                                                    const struct GroupInfo *  &group_ret,
                                                    struct GroupNesting       &group_nesting,
                                                    uint8_t *                  idx) const;
    static const struct Info *  find_by_header_group(
                                    struct Param_header phdr, void **ptr,
                                    uint16_t vindex,
                                    const struct GroupInfo *group_info,
                                    uint32_t group_base,
                                    uint8_t group_shift,
                                    ptrdiff_t group_offset);
    static const struct Info *  find_by_header(
                                    struct Param_header phdr,
                                    void **ptr);
    void                        add_vector3f_suffix(
                                    char *buffer,
                                    size_t buffer_size,
                                    uint8_t idx) const;
    static AP_Param *           find_group(
                                    const char *name,
                                    uint16_t vindex,
                                    ptrdiff_t group_offset,
                                    const struct GroupInfo *group_info,
                                    enum ap_var_type *ptype);
    static void                 write_sentinal(uint16_t ofs);
    static uint16_t             get_key(const Param_header &phdr);
    static void                 set_key(Param_header &phdr, uint16_t key);
    static bool                 is_sentinal(const Param_header &phrd);
    static bool                 scan(
                                    const struct Param_header *phdr,
                                    uint16_t *pofs);
    static void                 eeprom_write_check(
                                    const void *ptr,
                                    uint16_t ofs,
                                    uint8_t size);
    static AP_Param *           next_group(
                                    const uint16_t vindex,
                                    const struct GroupInfo *group_info,
                                    bool *found_current,
                                    const uint32_t group_base,
                                    const uint8_t group_shift,
                                    const ptrdiff_t group_offset,
                                    ParamToken *token,
                                    enum ap_var_type *ptype,
                                    bool skip_disabled,
                                    float *default_val);

    // find a default value given a pointer to a default value in flash
    static float get_default_value(const AP_Param *object_ptr, const struct GroupInfo &info);
    static float get_default_value(const AP_Param *object_ptr, const struct Info &info);

    static bool parse_param_line(char *line, char **vname, float &value, bool &read_only);

    /*
      load a parameter defaults file. This happens as part of load_all()
     */
    static bool count_defaults_in_file(const char *filename, uint16_t &num_defaults);
    static bool count_param_defaults(const volatile char *ptr, int32_t length, uint16_t &count);
    static bool read_param_defaults_file(const char *filename, bool last_pass, uint16_t &idx);

    // load a defaults.parm using AP_FileSystem:
    static void load_defaults_file_from_filesystem(const char *filename, bool lastpass);
    // load an @ROMFS defaults.parm using ROMFS API:
    static void load_defaults_file_from_romfs(const char *filename, bool lastpass);

    // load defaults from supplied string:
    static void load_param_defaults(const volatile char *ptr, int32_t length, bool last_pass);

    /*
      load defaults from embedded parameters
     */
    static bool count_embedded_param_defaults(uint16_t &count);
    static void load_embedded_param_defaults(bool last_pass);

    // return true if the parameter is configured in the defaults file
    bool configured_in_defaults_file(bool &read_only) const;

    // return true if the parameter is configured in EEPROM/FRAM
    bool configured_in_storage(void) const;

    /*
      convert width of a parameter, allowing update to wider scalar
      values without changing the parameter indexes. This will return
      true if the parameter was converted from an old parameter value
    */
    bool _convert_parameter_width(ap_var_type old_ptype, float scale_factor, bool bitmask);

    // send a parameter to all GCS instances
    void send_parameter(const char *name, enum ap_var_type param_header_type, uint8_t idx) const;

    static StorageAccess        _storage;
    static StorageAccess        _storage_bak;
    static uint16_t             _num_vars;
    static uint16_t             _parameter_count;
    static uint16_t             _count_marker;
    static uint16_t             _count_marker_done;
    static HAL_Semaphore        _count_sem;
    static const struct Info *  _var_info;

#if AP_PARAM_DYNAMIC_ENABLED
    // allow for a dynamically allocated var table
    static uint16_t             _num_vars_base;
    static struct Info *        _var_info_dynamic;
    static const struct AP_Param::Info &var_info(uint16_t i) {
        return i<_num_vars_base? _var_info[i] : _var_info_dynamic[i-_num_vars_base];
    }
    static uint8_t _dynamic_table_sizes[AP_PARAM_MAX_DYNAMIC];
#else
    // simple static var table in flash
    static const struct Info &var_info(uint16_t i) {
        return _var_info[i];
    }
#endif

    /*
      list of overridden values from load_defaults_file()
    */
    struct param_override {
        const AP_Param *object_ptr;
        float value;
        bool read_only; // param is marked @READONLY
    };
    static struct param_override *param_overrides;
    static uint16_t num_param_overrides;
    static uint16_t param_overrides_len;
    static uint16_t num_read_only;

    // values filled into the EEPROM header
    static const uint8_t        k_EEPROM_magic0      = 0x50;
    static const uint8_t        k_EEPROM_magic1      = 0x41; ///< "AP"
    static const uint8_t        k_EEPROM_revision    = 6; ///< current format revision

    static bool _hide_disabled_groups;

    // support for background saving of parameters. We pack it to reduce memory for the
    // queue
    struct PACKED param_save {
        AP_Param *param;
        bool force_save;
    };
    static ObjectBuffer_TS<struct param_save> save_queue;
    static bool registered_save_handler;

    // background function for saving parameters
    void save_io_handler(void);

    // Store default values from add_default() calls in linked list
    struct defaults_list {
        AP_Param *ap;
        float val;
        defaults_list *next;
    };
    static defaults_list *default_list;
    static void check_default(AP_Param *ap, float *default_value);

    static bool eeprom_full;
};

namespace AP {
    AP_Param *param();
};

/// Template class for scalar variables.
///
/// Objects of this type have a value, and can be treated in many ways as though they
/// were the value.
///
/// @tparam T			The scalar type of the variable
/// @tparam PT			The AP_PARAM_* type
///
template<typename T, ap_var_type PT>
class AP_ParamT : public AP_Param
{
public:
    static const ap_var_type        vtype = PT;

    /// Value getter
    ///
    const T &get(void) const {
        return _value;
    }

    /// Value setter
    ///
    void set(const T &v) {
        _value = v;
    }

    // set a parameter that is an ENABLE param
    void set_enable(const T &v);
    
    /// Sets if the parameter is unconfigured
    ///
    void set_default(const T &v);

    /// Sets parameter and default
    ///
    void set_and_default(const T &v);

    /// Value setter - set value, tell GCS
    ///
    void set_and_notify(const T &v);

    /// Combined set and save
    ///
    void set_and_save(const T &v);

    /// Combined set and save, but only does the save if the value if
    /// different from the current ram value, thus saving us a
    /// scan(). This should only be used where we have not set() the
    /// value separately, as otherwise the value in EEPROM won't be
    /// updated correctly.
    void set_and_save_ifchanged(const T &v);

    /// Conversion to T returns a reference to the value.
    ///
    /// This allows the class to be used in many situations where the value would be legal.
    ///
    operator const T &() const {
        return _value;
    }

    /// AP_ParamT types can implement AP_Param::cast_to_float
    ///
    float cast_to_float(void) const;

protected:
    T _value;
};


/// Template class for non-scalar variables.
///
/// Objects of this type have a value, and can be treated in many ways as though they
/// were the value.
///
/// @tparam T			The scalar type of the variable
/// @tparam PT			AP_PARAM_* type
///
template<typename T, ap_var_type PT>
class AP_ParamV : public AP_Param
{
public:

    static const ap_var_type        vtype = PT;

    /// Value getter
    ///
    const T &get(void) const {
        return _value;
    }

    /// Value setter
    ///
    void set(const T &v) {
        _value = v;
    }

    /// Value setter - set value, tell GCS
    ///
    void set_and_notify(const T &v);

    /// Combined set and save
    ///
    void set_and_save(const T &v);

    /// Combined set and save, but only does the save if the value is
    /// different from the current ram value, thus saving us a
    /// scan(). This should only be used where we have not set() the
    /// value separately, as otherwise the value in EEPROM won't be
    /// updated correctly.
    void set_and_save_ifchanged(const T &v);


    /// Conversion to T returns a reference to the value.
    ///
    /// This allows the class to be used in many situations where the value would be legal.
    ///
    operator const T &() const {
        return _value;
    }

protected:
    T        _value;
};


/// Template class for array variables.
///
/// Objects created using this template behave like arrays of the type T,
/// but are stored like single variables.
///
/// @tparam T           The scalar type of the variable
/// @tparam N           number of elements
/// @tparam PT          the AP_PARAM_* type
///
template<typename T, uint8_t N, ap_var_type PT>
class AP_ParamA : public AP_Param
{
public:

    static const ap_var_type vtype = PT;

    /// Array operator accesses members.
    ///
    /// @note It would be nice to range-check i here, but then what would we return?
    ///
    const T & operator[](uint8_t i) {
        return _value[i];
    }

    const T & operator[](int8_t i) {
        return _value[(uint8_t)i];
    }

    /// Value getter
    ///
    /// @note   Returns zero for index values out of range.
    ///
    T get(uint8_t i) const {
        if (i < N) {
            return _value[i];
        } else {
            return (T)0;
        }
    }

    /// Value setter
    ///
    /// @note   Attempts to set an index out of range are discarded.
    ///
    void  set(uint8_t i, const T &v) {
        if (i < N) {
            _value[i] = v;
        }
    }

protected:
    T _value[N];
};


/// Convenience macro for defining instances of the AP_ParamT template.
///
// declare a scalar type
// _t is the base type
// _suffix is the suffix on the AP_* type name
// _pt is the enum ap_var_type type
#define AP_PARAMDEF(_t, _suffix, _pt)   typedef AP_ParamT<_t, _pt> AP_ ## _suffix;
AP_PARAMDEF(float, Float, AP_PARAM_FLOAT);    // defines AP_Float
AP_PARAMDEF(int8_t, Int8, AP_PARAM_INT8);     // defines AP_Int8
AP_PARAMDEF(int16_t, Int16, AP_PARAM_INT16);  // defines AP_Int16
AP_PARAMDEF(int32_t, Int32, AP_PARAM_INT32);  // defines AP_Int32

// declare a non-scalar type
// this is used in AP_Math.h
// _t is the base type
// _suffix is the suffix on the AP_* type name
// _pt is the enum ap_var_type type
#define AP_PARAMDEFV(_t, _suffix, _pt)   typedef AP_ParamV<_t, _pt> AP_ ## _suffix;

/*
  template class for enum types based on AP_Int8
 */
template<typename eclass>
class AP_Enum : public AP_Int8
{
public:
    operator const eclass () const {
        return (eclass)_value;
    }
    void set(eclass v) {
        AP_Int8::set(int8_t(v));
    }
};

template<typename eclass>
class AP_Enum16 : public AP_Int16
{
public:
    operator const eclass () const {
        return (eclass)_value;
    }
    void set(eclass v) {
        AP_Int16::set(int16_t(v));
    }
};
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       /*
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include "AP_Param.h"
#include <AP_Math/AP_Math.h>

// Param type template functions

// set a parameter that is an ENABLE param
template<typename T, ap_var_type PT>
void AP_ParamT<T, PT>::set_enable(const T &v) {
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wfloat-equal"
    if (v != _value) {
#pragma GCC diagnostic pop
        invalidate_count();
    }
    _value = v;
}

// Sets if the parameter is unconfigured
template<typename T, ap_var_type PT>
void AP_ParamT<T, PT>::set_default(const T &v) {
#if AP_PARAM_DEFAULTS_ENABLED
    add_default(this, (float)v);
#endif
    if (!configured()) {
        set(v);
    }
}

// Sets parameter and default
template<typename T, ap_var_type PT>
void AP_ParamT<T, PT>::set_and_default(const T &v) {
#if AP_PARAM_DEFAULTS_ENABLED
    add_default(this, (float)v);
#endif
    set(v);
}

// Value setter - set value, tell GCS
template<typename T, ap_var_type PT>
void AP_ParamT<T, PT>::set_and_notify(const T &v) {
// We do want to compare each value, even floats, since it being the same here
// is the result of previously setting it.
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wfloat-equal"
    if (v != _value) {
#pragma GCC diagnostic pop
        set(v);
        notify();
    }
}

// Combined set and save
template<typename T, ap_var_type PT>
void AP_ParamT<T, PT>::set_and_save(const T &v) {
    bool force = fabsf((float)(_value - v)) < FLT_EPSILON;
    set(v);
    save(force);
}

// Combined set and save, but only does the save if the value if
// different from the current ram value, thus saving us a
// scan(). This should only be used where we have not set() the
// value separately, as otherwise the value in EEPROM won't be
// updated correctly.
template<typename T, ap_var_type PT>
void AP_ParamT<T, PT>::set_and_save_ifchanged(const T &v) {
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wfloat-equal"
    if (v == _value) {
#pragma GCC diagnostic pop
        return;
    }
    set(v);
    save(true);
}

// AP_ParamT types can implement AP_Param::cast_to_float
template<typename T, ap_var_type PT>
float AP_ParamT<T, PT>::cast_to_float(void) const {
    return (float)_value;
}

template class AP_ParamT<float, AP_PARAM_FLOAT>;
template class AP_ParamT<int8_t, AP_PARAM_INT8>;
template class AP_ParamT<int16_t, AP_PARAM_INT16>;
template class AP_ParamT<int32_t, AP_PARAM_INT32>;

// Value setter - set value, tell GCS
template<typename T, ap_var_type PT>
void AP_ParamV<T, PT>::set_and_notify(const T &v) {
    if (v != _value) {
        set(v);
        notify();
    }
}

    /// Combined set and save
template<typename T, ap_var_type PT>
void AP_ParamV<T, PT>::set_and_save(const T &v) {
    bool force = (_value != v);
    set(v);
    save(force);
}

// Combined set and save, but only does the save if the value is
// different from the current ram value, thus saving us a
// scan(). This should only be used where we have not set() the
// value separately, as otherwise the value in EEPROM won't be
// updated correctly.
template<typename T, ap_var_type PT>
void AP_ParamV<T, PT>::set_and_save_ifchanged(const T &v) {
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wfloat-equal"
    if (_value == v) {
#pragma GCC diagnostic pop
        return;
    }
    set(v);
    save(true);
}

template class AP_ParamV<Vector3f, AP_PARAM_VECTOR3F>;
                                                                                   #pragma once

#include <AP_HAL/AP_HAL_Boards.h>

#include <AP_Filesystem/AP_Filesystem_config.h>

#ifndef AP_PARAM_DEFAULTS_FILE_PARSING_ENABLED
#define AP_PARAM_DEFAULTS_FILE_PARSING_ENABLED AP_FILESYSTEM_FILE_READING_ENABLED
#endif

#ifndef FORCE_APJ_DEFAULT_PARAMETERS
#define FORCE_APJ_DEFAULT_PARAMETERS 0
#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  /*
 * Simple tool to dump the AP_Param contents from an EEPROM dump
 * Andrew Tridgell February 2012
 *
 * Build Command (Assuming starting directory is ardupilot)
 *    gcc -o eedump_ap_param libraries/AP_Param/tools/eedump_apparam.c
 *    gcc -g -o eedump_ap_param libraries/AP_Param/tools/eedump_apparam.c   // With Debugging symbols
 *
 * How to Use?
 *    ./eedump_ap_param eeprom.bin
*/

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>

uint8_t eeprom[0x1000];

struct EEPROM_header {
    uint8_t magic[2];
    uint8_t revision;
    uint8_t spare;
};

static const uint16_t k_EEPROM_magic0     = 0x50;
static const uint16_t k_EEPROM_magic1     = 0x41;
static const uint16_t k_EEPROM_revision   = 6;

enum ap_var_type {
    AP_PARAM_NONE    = 0,
    AP_PARAM_INT8,
    AP_PARAM_INT16,
    AP_PARAM_INT32,
    AP_PARAM_FLOAT,
    AP_PARAM_VECTOR3F,
    AP_PARAM_VECTOR6F,
    AP_PARAM_MATRIX3F,
    AP_PARAM_GROUP
};

static const char *type_names[8] = {
    "NONE", "INT8", "INT16", "INT32", "FLOAT", "VECTOR3F", "MATRIX6F", "GROUP"
};

struct Param_header {
    // to get 9 bits for key we needed to split it into two parts to keep binary compatibility
    uint32_t key_low : 8;
    uint32_t type : 5;
    uint32_t key_high : 1;
    uint32_t group_element : 18;
};

static const uint16_t       _sentinal_key   = 0x1FF;
static const uint8_t        _sentinal_type  = 0x1F;
static const uint8_t        _sentinal_group = 0xFF;

static uint8_t type_size(enum ap_var_type type)
{
    switch (type) {
    case AP_PARAM_NONE:
    case AP_PARAM_GROUP:
        return 0;
    case AP_PARAM_INT8:
        return 1;
    case AP_PARAM_INT16:
        return 2;
    case AP_PARAM_INT32:
        return 4;
    case AP_PARAM_FLOAT:
        return 4;
    case AP_PARAM_VECTOR3F:
        return 3*4;
    case AP_PARAM_VECTOR6F:
        return 6*4;
    case AP_PARAM_MATRIX3F:
        return 3*3*4;
    }
    printf("unknown type %u\n", (unsigned int)type);
    return 0;
}

static void
fail(const char *why)
{
    fprintf(stderr, "ERROR: %s\n", why);
    exit(1);
}

int
main(int argc, char *argv[])
{
    FILE                    *fp;
    struct EEPROM_header    *header;
    struct Param_header     *var;
    unsigned index;
    unsigned i;

    if (argc != 2) {
        fail("missing EEPROM file name");
    }
    if (NULL == (fp = fopen(argv[1], "rb"))) {
        fail("can't open EEPROM file");
    }
    if (1 != fread(eeprom, sizeof(eeprom), 1, fp)) {
        fail("can't read EEPROM file");
    }
    fclose(fp);

    header = (struct EEPROM_header *)&eeprom[0];
    if (header->magic[0] != k_EEPROM_magic0 ||
        header->magic[1] != k_EEPROM_magic1) {
        fail("bad magic in EEPROM file");
    }
    if (header->revision != k_EEPROM_revision) {
        fail("unsupported EEPROM format revision");
    }
    printf("Header OK\n");

    index = sizeof(*header);
    for (;; ) {
        uint8_t size;
        var = (struct Param_header *)&eeprom[index];
        const uint16_t key = ((uint16_t)var->key_high)<<8 | var->key_low;
        if (key == _sentinal_key ||
            var->type == _sentinal_type) {
            printf("end sentinel at %u\n", index);
            break;
        }
        size = type_size(var->type);
        printf("%04x: type %u (%s) key %u group_element %u size %d value ",
               index, var->type, type_names[var->type], key, var->group_element, size);
        index += sizeof(*var);
        switch (var->type) {
        case AP_PARAM_INT8:
            printf("%d\n", (int)*(int8_t *)&eeprom[index]);
            break;
        case AP_PARAM_INT16:
            printf("%d\n", (int)*(int16_t *)&eeprom[index]);
            break;
        case AP_PARAM_INT32:
            printf("%d\n", (int)*(int32_t *)&eeprom[index]);
            break;
        case AP_PARAM_FLOAT:
            printf("%f\n", *(float *)&eeprom[index]);
            break;
        case AP_PARAM_VECTOR3F:
            printf("%f %f %f\n",
                   *(float *)&eeprom[index],
                   *(float *)&eeprom[index+4],
                   *(float *)&eeprom[index+8]);
            break;
        case AP_PARAM_VECTOR6F:
            printf("%f %f %f %f %f %f\n",
                   *(float *)&eeprom[index],
                   *(float *)&eeprom[index+4],
                   *(float *)&eeprom[index+8],
                   *(float *)&eeprom[index+12],
                   *(float *)&eeprom[index+16],
                   *(float *)&eeprom[index+20]);
            break;
        case AP_PARAM_MATRIX3F:
            printf("%f %f %f %f %f %f %f %f %f\n",
                   *(float *)&eeprom[index],
                   *(float *)&eeprom[index+4],
                   *(float *)&eeprom[index+8],
                   *(float *)&eeprom[index+12],
                   *(float *)&eeprom[index+16],
                   *(float *)&eeprom[index+20],
                   *(float *)&eeprom[index+24],
                   *(float *)&eeprom[index+28],
                   *(float *)&eeprom[index+32]);
            break;
        default:
            printf("NONE\n");
            break;
        }
        for (i = 0; i < size; i++) {
            printf(" %02x", eeprom[index + i]);
        }
        printf("\n");
        index += size;
        if (index >= sizeof(eeprom)) {
            fflush(stdout);
            fail("missing end sentinel");
        }
    }
    return 0;
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   /*
 * This file is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This file is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Author: Oliver Walters / Currawong Engineering Pty Ltd
 */


#include <AP_HAL/AP_HAL.h>
#include <AP_AHRS/AP_AHRS.h>

#include "AP_PiccoloCAN.h"

#if HAL_PICCOLO_CAN_ENABLE

#include <AP_Param/AP_Param.h>
#include <AP_BoardConfig/AP_BoardConfig.h>
#include <AP_CANManager/AP_CANManager.h>
#include <AP_Common/AP_Common.h>
#include <AP_Scheduler/AP_Scheduler.h>
#include <AP_HAL/utility/sparse-endian.h>
#include <SRV_Channel/SRV_Channel.h>
#include <GCS_MAVLink/GCS.h>
#include <AP_Logger/AP_Logger.h>
#include <AP_CANManager/AP_CANManager.h>

#include <AP_EFI/AP_EFI_Currawong_ECU.h>

#include <stdio.h>

// Protocol files for the Velocity ESC
#include <AP_PiccoloCAN/piccolo_protocol/ESCVelocityProtocol.h>
#include <AP_PiccoloCAN/piccolo_protocol/ESCPackets.h>

// Protocol files for the CBS servo
#include <AP_PiccoloCAN/piccolo_protocol/ServoProtocol.h>
#include <AP_PiccoloCAN/piccolo_protocol/ServoPackets.h>

extern const AP_HAL::HAL& hal;

#if HAL_CANMANAGER_ENABLED
#define debug_can(level_debug, fmt, args...) do { AP::can().log_text(level_debug, "PiccoloCAN", fmt, ##args); } while (0)
#else
#define debug_can(level_debug, fmt, args...)
#endif

// table of user-configurable Piccolo CAN bus parameters
const AP_Param::GroupInfo AP_PiccoloCAN::var_info[] = {

    // @Param: ESC_BM
    // @DisplayName: ESC channels
    // @Description: Bitmask defining which ESC (motor) channels are to be transmitted over Piccolo CAN
    // @Bitmask: 0: ESC 1, 1: ESC 2, 2: ESC 3, 3: ESC 4, 4: ESC 5, 5: ESC 6, 6: ESC 7, 7: ESC 8, 8: ESC 9, 9: ESC 10, 10: ESC 11, 11: ESC 12, 12: ESC 13, 13: ESC 14, 14: ESC 15, 15: ESC 16, 16: ESC 17, 17: ESC 18, 18: ESC 19, 19: ESC 20, 20: ESC 21, 21: ESC 22, 22: ESC 23, 23: ESC 24, 24: ESC 25, 25: ESC 26, 26: ESC 27, 27: ESC 28, 28: ESC 29, 29: ESC 30, 30: ESC 31, 31: ESC 32
    // @User: Advanced
    AP_GROUPINFO("ESC_BM", 1, AP_PiccoloCAN, _esc_bm, 0xFFFF),

    // @Param: ESC_RT
    // @DisplayName: ESC output rate
    // @Description: Output rate of ESC command messages
    // @Units: Hz
    // @User: Advanced
    // @Range: 1 500
    AP_GROUPINFO("ESC_RT", 2, AP_PiccoloCAN, _esc_hz, PICCOLO_MSG_RATE_HZ_DEFAULT),

    // @Param: SRV_BM
    // @DisplayName: Servo channels
    // @Description: Bitmask defining which servo channels are to be transmitted over Piccolo CAN
    // @Bitmask: 0: Servo 1, 1: Servo 2, 2: Servo 3, 3: Servo 4, 4: Servo 5, 5: Servo 6, 6: Servo 7, 7: Servo 8, 8: Servo 9, 9: Servo 10, 10: Servo 11, 11: Servo 12, 12: Servo 13, 13: Servo 14, 14: Servo 15, 15: Servo 16
    // @User: Advanced
    AP_GROUPINFO("SRV_BM", 3, AP_PiccoloCAN, _srv_bm, 0xFFFF),

    // @Param: SRV_RT
    // @DisplayName: Servo command output rate
    // @Description: Output rate of servo command messages
    // @Units: Hz
    // @User: Advanced
    // @Range: 1 500
    AP_GROUPINFO("SRV_RT", 4, AP_PiccoloCAN, _srv_hz, PICCOLO_MSG_RATE_HZ_DEFAULT),
#if AP_EFI_CURRAWONG_ECU_ENABLED
    // @Param: ECU_ID
    // @DisplayName: ECU Node ID
    // @Description: Node ID to send ECU throttle messages to. Set to zero to disable ECU throttle messages. Set to 255 to broadcast to all ECUs.
    // @Range: 0 255
    // @User: Advanced
    AP_GROUPINFO("ECU_ID", 5, AP_PiccoloCAN, _ecu_id, PICCOLO_CAN_ECU_ID_DEFAULT),

    // @Param: ECU_RT
    // @DisplayName: ECU command output rate
    // @Description: Output rate of ECU command messages
    // @Units: Hz
    // @User: Advanced
    // @Range: 1 500
    AP_GROUPINFO("ECU_RT", 6, AP_PiccoloCAN, _ecu_hz, PICCOLO_MSG_RATE_HZ_DEFAULT),
#endif
    AP_GROUPEND
};

AP_PiccoloCAN::AP_PiccoloCAN()
{
    AP_Param::setup_object_defaults(this, var_info);

    debug_can(AP_CANManager::LOG_INFO, "PiccoloCAN: constructed\n\r");
}

AP_PiccoloCAN *AP_PiccoloCAN::get_pcan(uint8_t driver_index)
{
    if (driver_index >= AP::can().get_num_drivers() ||
        AP::can().get_driver_type(driver_index) != AP_CAN::Protocol::PiccoloCAN) {
        return nullptr;
    }

    return static_cast<AP_PiccoloCAN*>(AP::can().get_driver(driver_index));
}

bool AP_PiccoloCAN::add_interface(AP_HAL::CANIface* can_iface) {
    if (_can_iface != nullptr) {
        debug_can(AP_CANManager::LOG_ERROR, "PiccoloCAN: Multiple Interface not supported\n\r");
        return false;
    }

    _can_iface = can_iface;

    if (_can_iface == nullptr) {
        debug_can(AP_CANManager::LOG_ERROR, "PiccoloCAN: CAN driver not found\n\r");
        return false;
    }

    if (!_can_iface->is_initialized()) {
        debug_can(AP_CANManager::LOG_ERROR, "PiccoloCAN: Driver not initialized\n\r");
        return false;
    }

    if (!_can_iface->set_event_handle(&sem_handle)) {
        debug_can(AP_CANManager::LOG_ERROR, "PiccoloCAN: Cannot add event handle\n\r");
        return false;
    }
    return true;
}

// initialize PiccoloCAN bus
void AP_PiccoloCAN::init(uint8_t driver_index, bool enable_filters)
{
    _driver_index = driver_index;

    debug_can(AP_CANManager::LOG_DEBUG, "PiccoloCAN: starting init\n\r");

    if (_initialized) {
        debug_can(AP_CANManager::LOG_ERROR, "PiccoloCAN: already initialized\n\r");
        return;
    }
    // start calls to loop in separate thread
    if (!hal.scheduler->thread_create(FUNCTOR_BIND_MEMBER(&AP_PiccoloCAN::loop, void), _thread_name, 4096, AP_HAL::Scheduler::PRIORITY_MAIN, 1)) {
        debug_can(AP_CANManager::LOG_ERROR, "PiccoloCAN: couldn't create thread\n\r");
        return;
    }

    _initialized = true;

    snprintf(_thread_name, sizeof(_thread_name), "PiccoloCAN_%u", driver_index);

    debug_can(AP_CANManager::LOG_DEBUG, "PiccoloCAN: init done\n\r");
}

// loop to send output to CAN devices in background thread
void AP_PiccoloCAN::loop()
{
    AP_HAL::CANFrame txFrame {};
    AP_HAL::CANFrame rxFrame {};

    uint16_t esc_tx_counter = 0;
    uint16_t servo_tx_counter = 0;
#if AP_EFI_CURRAWONG_ECU_ENABLED
    uint16_t ecu_tx_counter = 0;
#endif

    // CAN Frame ID components
    uint8_t frame_id_group;     // Piccolo message group
    uint16_t frame_id_device;   // Device identifier

    while (true) {

        if (!_initialized) {
            debug_can(AP_CANManager::LOG_ERROR, "PiccoloCAN: not initialized\n\r");
            hal.scheduler->delay_microseconds(10000);
            continue;
        }

        // Calculate the output rate for ESC commands
        _esc_hz.set(constrain_int16(_esc_hz, PICCOLO_MSG_RATE_HZ_MIN, PICCOLO_MSG_RATE_HZ_MAX));

        uint16_t escCmdRateMs = 1000 / _esc_hz;

        // Calculate the output rate for servo commands
        _srv_hz.set(constrain_int16(_srv_hz, PICCOLO_MSG_RATE_HZ_MIN, PICCOLO_MSG_RATE_HZ_MAX));

        uint16_t servoCmdRateMs = 1000 / _srv_hz;
#if AP_EFI_CURRAWONG_ECU_ENABLED
        _ecu_hz.set(constrain_int16(_ecu_hz, PICCOLO_MSG_RATE_HZ_MIN, PICCOLO_MSG_RATE_HZ_MAX));

        uint16_t ecuCmdRateMs = 1000 / _ecu_hz;
#endif
        uint64_t timeout = AP_HAL::micros64() + 250ULL;

        // 1ms loop delay
        hal.scheduler->delay_microseconds(1000);

        // Transmit ESC commands at regular intervals
        if (esc_tx_counter++ > escCmdRateMs) {
            esc_tx_counter = 0;
            send_esc_messages();
        }

        // Transmit servo commands at regular intervals
        if (servo_tx_counter++ > servoCmdRateMs) {
            servo_tx_counter = 0;
            send_servo_messages();
        }

#if AP_EFI_CURRAWONG_ECU_ENABLED
        // Transmit ecu throttle commands at regular intervals
        if (ecu_tx_counter++ > ecuCmdRateMs) {
            ecu_tx_counter = 0;
            send_ecu_messages();
        }
#endif

        // Look for any message responses on the CAN bus
        while (read_frame(rxFrame, timeout)) {

            // Extract group and device ID values from the frame identifier
            frame_id_group = (rxFrame.id >> 24) & 0x1F;
            frame_id_device = (rxFrame.id >> 8) & 0xFF;

            // Only accept extended messages
            if ((rxFrame.id & AP_HAL::CANFrame::FlagEFF) == 0) {
                continue;
            }

            switch (PiccoloCAN_MessageGroup(frame_id_group)) {
            // ESC messages exist in the ACTUATOR group
            case PiccoloCAN_MessageGroup::ACTUATOR:

                switch (PiccoloCAN_ActuatorType(frame_id_device)) {
                case PiccoloCAN_ActuatorType::SERVO:
                    handle_servo_message(rxFrame);
                    break;
                case PiccoloCAN_ActuatorType::ESC:
                    handle_esc_message(rxFrame);
                    break;
                default:
                    // Unknown actuator type
                    break;
                }

                break;
            case PiccoloCAN_MessageGroup::ECU_OUT:
            #if AP_EFI_CURRAWONG_ECU_ENABLED
                handle_ecu_message(rxFrame);
            #endif
                break;
            default:
                break;
            }
        }
    }
}

// write frame on CAN bus, returns true on success
bool AP_PiccoloCAN::write_frame(AP_HAL::CANFrame &out_frame, uint64_t timeout)
{
    if (!_initialized) {
        debug_can(AP_CANManager::LOG_ERROR, "PiccoloCAN: Driver not initialized for write_frame\n\r");
        return false;
    }

    bool read_select = false;
    bool write_select = true;
    
    bool ret =  _can_iface->select(read_select, write_select, &out_frame, timeout);

    if (!ret || !write_select) {
        return false;
    }

    return (_can_iface->send(out_frame, timeout, AP_HAL::CANIface::AbortOnError) == 1);
}

// read frame on CAN bus, returns true on succses
bool AP_PiccoloCAN::read_frame(AP_HAL::CANFrame &recv_frame, uint64_t timeout)
{
    if (!_initialized) {
        debug_can(AP_CANManager::LOG_ERROR, "PiccoloCAN: Driver not initialized for read_frame\n\r");
        return false;
    }
    bool read_select = true;
    bool write_select = false;
    bool ret = _can_iface->select(read_select, write_select, nullptr, timeout);

    if (!ret || !read_select) {
        // No frame available
        return false;
    }

    uint64_t time;
    AP_HAL::CANIface::CanIOFlags flags {};

    return (_can_iface->receive(recv_frame, time, flags) == 1);
}

// called from SRV_Channels
void AP_PiccoloCAN::update()
{
    uint64_t timestamp = AP_HAL::micros64();

    /* Read out the servo commands from the channel mixer */
    for (uint8_t ii = 0; ii < PICCOLO_CAN_MAX_NUM_SERVO; ii++) {

        if (is_servo_channel_active(ii)) {

            uint16_t output = 0;

            SRV_Channel::Aux_servo_function_t function = SRV_Channels::channel_function(ii);

            if (SRV_Channels::get_output_pwm(function, output)) {
                _servos[ii].command = output;
                _servos[ii].newCommand = true;
            }
        }
    }

    /* Read out the ESC commands from the channel mixer */
    for (uint8_t ii = 0; ii < PICCOLO_CAN_MAX_NUM_ESC; ii++) {

        if (is_esc_channel_active(ii)) {

            uint16_t output = 0;
            
            SRV_Channel::Aux_servo_function_t motor_function = SRV_Channels::get_motor_function(ii);

            if (SRV_Channels::get_output_pwm(motor_function, output)) {
                _escs[ii].command = output;
                _escs[ii].newCommand = true;
            }
        }
    }

#if AP_EFI_CURRAWONG_ECU_ENABLED
    if (_ecu_id != 0) {
        _ecu_info.command = SRV_Channels::get_output_scaled(SRV_Channel::k_throttle);
        _ecu_info.newCommand = true;
    }
#endif // AP_EFI_CURRAWONG_ECU_ENABLED

#if HAL_LOGGING_ENABLED
    AP_Logger *logger = AP_Logger::get_singleton();

    // Push received telemetry data into the logging system
    if (logger && logger->logging_enabled()) {

        WITH_SEMAPHORE(_telem_sem);

        for (uint8_t ii = 0; ii < PICCOLO_CAN_MAX_NUM_SERVO; ii++) {

            AP_PiccoloCAN_Servo &servo = _servos[ii];

            if (servo.newTelemetry) {
                union {
                    Servo_ErrorBits_t ebits;
                    uint8_t errors;
                } err;
                err.ebits = servo.status.statusA.errors;
                logger->Write_ServoStatus(
                    timestamp,
                    ii,
                    servo.position(),                       // Servo position (represented in microsecond units)
                    servo.current() * 0.01f,                // Servo force (actually servo current, 0.01A per bit)
                    servo.speed(),                          // Servo speed (degrees per second)
                    servo.dutyCycle(),                      // Servo duty cycle (absolute value as it can be +/- 100%)
                    uint16_t(servo.commandedPosition()),    // Commanded position
                    servo.voltage(),                        // Servo voltage
                    servo.current(),                        // Servo current
                    servo.temperature(),                    // Servo temperature
                    servo.temperature(),                    // 
                    err.errors
                );

                servo.newTelemetry = false;
            }
        }
    }
#else
    (void)timestamp;
#endif  // HAL_LOGGING_ENABLED
}


// send servo messages over CAN
void AP_PiccoloCAN::send_servo_messages(void)
{
    AP_HAL::CANFrame txFrame {};

    uint64_t timeout = AP_HAL::micros64() + 1000ULL;

    // No servos are selected? Don't send anything!
    if (_srv_bm == 0x00) {
        return;
    }

    bool send_cmd = false;
    int16_t cmd[4] {};
    uint8_t idx;

    // Transmit bulk command packets to 4x servos simultaneously
    for (uint8_t ii = 0; ii < PICCOLO_CAN_MAX_GROUP_SERVO; ii++) {

        send_cmd = false;

        for (uint8_t jj = 0; jj < 4; jj++) {
            
            idx = (ii * 4) + jj;

            // Set default command value if an output field is unused
            cmd[jj] = 0x7FFF;

            // Skip servo if the output is not enabled
            if (!is_servo_channel_active(idx)) {
                continue;
            }

            /* Check if the servo is enabled.
             * If it is not enabled, send an enable message.
             */

            if (!is_servo_present(idx) || !is_servo_enabled(idx)) {
                // Servo is not enabled
                encodeServo_EnablePacket(&txFrame);
                txFrame.id |= (idx + 1);
                write_frame(txFrame, timeout);
            } else if (_servos[idx].newCommand) {
                // A new command is provided
                send_cmd = true;
                cmd[jj] = _servos[idx].command;
                _servos[idx].newCommand = false;
            }
        }

        if (send_cmd) {
            encodeServo_MultiPositionCommandPacket(
                &txFrame,
                cmd[0],
                cmd[1],
                cmd[2],
                cmd[3],
                (PKT_SERVO_MULTI_COMMAND_1 + ii)
            );

            // Broadcast the command to all servos
            txFrame.id |= 0xFF;

            write_frame(txFrame, timeout);
        }
    }
}


// send ESC messages over CAN
void AP_PiccoloCAN::send_esc_messages(void)
{
    AP_HAL::CANFrame txFrame {};

    uint64_t timeout = AP_HAL::micros64() + 1000ULL;

    // No ESCs are selected? Don't send anything
    if (_esc_bm == 0x00) {
        return;
    }

    // System is armed - send out ESC commands
    if (hal.util->get_soft_armed()) {

        bool send_cmd = false;
        int16_t cmd[4] {};
        uint8_t idx;

        // Transmit bulk command packets to 4x ESC simultaneously
        for (uint8_t ii = 0; ii < PICCOLO_CAN_MAX_GROUP_ESC; ii++) {

            send_cmd = false;

            for (uint8_t jj = 0; jj < 4; jj++) {

                idx = (ii * 4) + jj;

                // Set default command value if an output field is unused
                cmd[jj] = 0x7FFF;

                // Skip an ESC if the motor channel is not enabled
                if (!is_esc_channel_active(idx)) {
                    continue;
                }

                /* Check if the ESC is software-inhibited.
                 * If so, send a message to enable it.
                 */
                if (is_esc_present(idx) && !is_esc_enabled(idx)) {
                    encodeESC_EnablePacket(&txFrame);
                    txFrame.id |= (idx + 1);
                    write_frame(txFrame, timeout);
                }
                else if (_escs[idx].newCommand) {
                    send_cmd = true;
                    cmd[jj] = _escs[idx].command;
                    _escs[idx].newCommand = false;
                } else {
                    // A command of 0x7FFF is 'out of range' and will be ignored by the corresponding ESC
                    cmd[jj] = 0x7FFF;
                }
            }

            if (send_cmd) {
                encodeESC_CommandMultipleESCsPacket(
                    &txFrame,
                    cmd[0],
                    cmd[1],
                    cmd[2],
                    cmd[3],
                    (PKT_ESC_SETPOINT_1 + ii)
                );

                // Broadcast the command to all ESCs
                txFrame.id |= 0xFF;

                write_frame(txFrame, timeout);
            }
        }

    } else {
        // System is NOT armed - send a "disable" message to all ESCs on the bus

        // Command all ESC into software disable mode
        encodeESC_DisablePacket(&txFrame);

        // Set the ESC address to the broadcast ID (0xFF)
        txFrame.id |= 0xFF;

        write_frame(txFrame, timeout);
    }
}


// interpret a servo message received over CAN
bool AP_PiccoloCAN::handle_servo_message(AP_HAL::CANFrame &frame)
{
    // The servo address is the lower byte of the frame ID
    uint8_t addr = frame.id & 0xFF;

    // Ignore servo with an invalid node ID
    if (addr == 0x00) {
        return false;
    }

    // Subtract to get the address in memory
    addr -= 1;

    // Maximum number of servos allowed
    if (addr >= PICCOLO_CAN_MAX_NUM_SERVO) {
        return false;
    }

    // Pass the CAN frame off to the specific servo
    return _servos[addr].handle_can_frame(frame);
}


// interpret an ESC message received over CAN
bool AP_PiccoloCAN::handle_esc_message(AP_HAL::CANFrame &frame)
{
    // The ESC address is the lower byte of the frame ID
    uint8_t addr = frame.id & 0xFF;

    // Ignore any ESC with node ID of zero
    if (addr == 0x00) {
        return false;
    }

    // Subtract to get the address in memory
    addr -= 1;

    // Maximum number of ESCs allowed
    if (addr >= PICCOLO_CAN_MAX_NUM_ESC) {
        return false;
    }

    return _escs[addr].handle_can_frame(frame);
}

#if AP_EFI_CURRAWONG_ECU_ENABLED
void AP_PiccoloCAN::send_ecu_messages(void)
{
    AP_HAL::CANFrame txFrame {};

    const uint64_t timeout = AP_HAL::micros64() + 1000ULL;

    // No ECU node id set, don't send anything
    if (_ecu_id == 0) {
        return;
    }

    if (_ecu_info.newCommand) {
        encodeECU_ThrottleCommandPacket(&txFrame, _ecu_info.command);
        txFrame.id |= (uint8_t) _ecu_id;

        _ecu_info.newCommand = false;

        write_frame(txFrame, timeout);
    }
}

bool AP_PiccoloCAN::handle_ecu_message(AP_HAL::CANFrame &frame)
{
    // Get the ecu instance
    AP_EFI_Currawong_ECU* ecu = AP_EFI_Currawong_ECU::get_instance();
    if (ecu != nullptr) {
        return ecu->handle_message(frame);
    }
    return false;
}
#endif // AP_EFI_CURRAWONG_ECU_ENABLED

/**
 * Check if a given servo channel is "active" (has been configured for Piccolo control output)
 */
bool AP_PiccoloCAN::is_servo_channel_active(uint8_t chan)
{
    // First check if the particular servo channel is enabled in the channel mask
    if (((_srv_bm >> chan) & 0x01) == 0x00) {
        return false;
    }

    SRV_Channel::Aux_servo_function_t function = SRV_Channels::channel_function(chan);

    // Ignore if the servo channel does not have a function assigned
    if (function <= SRV_Channel::k_none) {
        return false;
    }

    // Ignore if the assigned function is a motor function
    if (SRV_Channel::is_motor(function)) {
        return false;
    }

    // We can safely say that the particular servo channel is active
    return true;
}

/**
 * Check if a given ESC channel is "active" (has been configured for Piccolo control output)
 */
bool AP_PiccoloCAN::is_esc_channel_active(uint8_t chan)
{
    // First check if the particular ESC channel is enabled in the channel mask
    if (((_esc_bm >> chan) & 0x01) == 0x00) {
        return false;
    }

    // Check if a motor function is assigned for this motor channel
    SRV_Channel::Aux_servo_function_t motor_function = SRV_Channels::get_motor_function(chan);

    if (SRV_Channels::function_assigned(motor_function)) {
        return true;
    }

    return false;
}


/**
 * Determine if a servo is present on the CAN bus (has telemetry data been received)
 */
bool AP_PiccoloCAN::is_servo_present(uint8_t chan, uint64_t timeout_ms)
{
    if (chan >= PICCOLO_CAN_MAX_NUM_SERVO) {
        return false;
    }

    return _servos[chan].is_connected(timeout_ms);
}


/**
 * Determine if an ESC is present on the CAN bus (has telemetry data been received)
 */
bool AP_PiccoloCAN::is_esc_present(uint8_t chan, uint64_t timeout_ms)
{
    if (chan >= PICCOLO_CAN_MAX_NUM_ESC) {
        return false;
    }

    return _escs[chan].is_connected(timeout_ms);
}


/**
 * Check if a given servo is enabled
 */
bool AP_PiccoloCAN::is_servo_enabled(uint8_t chan)
{
    if (chan >= PICCOLO_CAN_MAX_NUM_SERVO) {
        return false;
    }

    // If the servo is not present, we cannot determine if it is enabled or not
    if (!is_servo_present(chan)) {
        return false;
    }

    return _servos[chan].is_enabled();
}


/**
 * Check if a given ESC is enabled (both hardware and software enable flags)
 */
bool AP_PiccoloCAN::is_esc_enabled(uint8_t chan)
{
    if (chan >= PICCOLO_CAN_MAX_NUM_ESC) {
        return false;
    }

    // If the ESC is not present, we cannot determine if it is enabled or not
    if (!is_esc_present(chan)) {
        return false;
    }

    return _escs[chan].is_enabled();
}


bool AP_PiccoloCAN::pre_arm_check(char* reason, uint8_t reason_len)
{
    // Check that each required servo is present on the bus
    for (uint8_t ii = 0; ii < PICCOLO_CAN_MAX_NUM_SERVO; ii++) {

        if (is_servo_channel_active(ii)) {

            if (!is_servo_present(ii)) {
                snprintf(reason, reason_len, "Servo %u not detected", ii + 1);
                return false;
            }
        }
    }

    // Check that each required ESC is present on the bus
    for (uint8_t ii = 0; ii < PICCOLO_CAN_MAX_NUM_ESC; ii++) {

        // Skip any ESC channels where the motor channel is not enabled
        if (is_esc_channel_active(ii)) {

            if (!is_esc_present(ii)) {
                snprintf(reason, reason_len, "ESC %u not detected", ii + 1);
                return false;
            }

            if (_escs[ii].is_hw_inhibited()) {
                snprintf(reason, reason_len, "ESC %u is hardware inhibited", (ii + 1));
                return false;
            }
        }
    }

    return true;
}


#endif // HAL_PICCOLO_CAN_ENABLE
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              /*
 * This file is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This file is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Author: Oliver Walters / Currawong Engineering Pty Ltd
 */

#pragma once

#include <AP_HAL/AP_HAL.h>
#include <AP_CANManager/AP_CANDriver.h>

#include <AP_Param/AP_Param.h>
#include <AP_ESC_Telem/AP_ESC_Telem_Backend.h>

#include "AP_PiccoloCAN_Device.h"
#include "AP_PiccoloCAN_ESC.h"
#include "AP_PiccoloCAN_ECU.h"
#include "AP_PiccoloCAN_Servo.h"
#include <AP_EFI/AP_EFI_Currawong_ECU.h>

#if HAL_PICCOLO_CAN_ENABLE

#define PICCOLO_MSG_RATE_HZ_MIN 1
#define PICCOLO_MSG_RATE_HZ_MAX 500
#define PICCOLO_MSG_RATE_HZ_DEFAULT 50

class AP_PiccoloCAN : public AP_CANDriver, public AP_ESC_Telem_Backend
{
public:
    AP_PiccoloCAN();
    ~AP_PiccoloCAN();

    /* Do not allow copies */
    CLASS_NO_COPY(AP_PiccoloCAN);

    static const struct AP_Param::GroupInfo var_info[];

    // Return PiccoloCAN from @driver_index or nullptr if it's not ready or doesn't exist
    static AP_PiccoloCAN *get_pcan(uint8_t driver_index);

    // initialize PiccoloCAN bus
    void init(uint8_t driver_index, bool enable_filters) override;
    bool add_interface(AP_HAL::CANIface* can_iface) override;

    // called from SRV_Channels
    void update();

    // return true if a particular servo is 'active' on the Piccolo interface
    bool is_servo_channel_active(uint8_t chan);

    // return true if a particular ESC is 'active' on the Piccolo interface
    bool is_esc_channel_active(uint8_t chan);

    // return true if a particular servo has been detected on the CAN interface
    bool is_servo_present(uint8_t chan, uint64_t timeout_ms = 2000);

    // return true if a particular ESC has been detected on the CAN interface
    bool is_esc_present(uint8_t chan, uint64_t timeout_ms = 2000);

    // return true if a particular servo is enabled
    bool is_servo_enabled(uint8_t chan);

    // return true if a particular ESC is enabled
    bool is_esc_enabled(uint8_t chan);

    // test if the Piccolo CAN driver is ready to be armed
    bool pre_arm_check(char* reason, uint8_t reason_len);

private:

    // loop to send output to ESCs in background thread
    void loop();

    // write frame on CAN bus, returns true on success
    bool write_frame(AP_HAL::CANFrame &out_frame, uint64_t timeout);

    // read frame on CAN bus, returns true on succses
    bool read_frame(AP_HAL::CANFrame &recv_frame, uint64_t timeout);

    // send ESC commands over CAN
    void send_esc_messages(void);

    // interpret an ESC message received over CAN
    bool handle_esc_message(AP_HAL::CANFrame &frame);

    // send servo commands over CAN
    void send_servo_messages(void);

    // interpret a servo message received over CAN
    bool handle_servo_message(AP_HAL::CANFrame &frame);

#if AP_EFI_CURRAWONG_ECU_ENABLED
    void send_ecu_messages(void);

    // interpret an ECU message received over CAN
    bool handle_ecu_message(AP_HAL::CANFrame &frame);
#endif

    bool _initialized;
    char _thread_name[16];
    uint8_t _driver_index;
    AP_HAL::CANIface* _can_iface;
    HAL_BinarySemaphore sem_handle;

    AP_PiccoloCAN_Servo _servos[PICCOLO_CAN_MAX_NUM_SERVO];
    AP_PiccoloCAN_ESC _escs[PICCOLO_CAN_MAX_NUM_ESC];

    struct CurrawongECU_Info_t {
        float command;
        bool newCommand;
    } _ecu_info;

    // Piccolo CAN parameters
    AP_Int32 _esc_bm;       //!< ESC selection bitmask
    AP_Int16 _esc_hz;       //!< ESC update rate (Hz)

    AP_Int32 _srv_bm;       //!< Servo selection bitmask
    AP_Int16 _srv_hz;       //!< Servo update rate (Hz)

    AP_Int16 _ecu_id;       //!< ECU Node ID
    AP_Int16 _ecu_hz;       //!< ECU update rate (Hz)

    HAL_Semaphore _telem_sem;
};

#endif // HAL_PICCOLO_CAN_ENABLE
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                /*
 * This file is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This file is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Author: Oliver Walters / Currawong Engineering Pty Ltd
 */

#pragma once

#include <stdint.h>
#include <AP_HAL/AP_HAL.h>
#include <AP_CANManager/AP_CANManager.h>

#ifndef HAL_PICCOLO_CAN_ENABLE
#define HAL_PICCOLO_CAN_ENABLE HAL_NUM_CAN_IFACES
#endif

#if HAL_PICCOLO_CAN_ENABLE

//! Piccolo message groups form part of the CAN ID of each frame
enum class PiccoloCAN_MessageGroup : uint8_t {
    SIMULATOR = 0x00,       //!< Simulator messages
    SENSOR = 0x04,          //!< External sensors
    ACTUATOR = 0x07,        //!< Actuators (e.g. ESC / servo)
    ECU_OUT = 0x08,         //!< Messages *from* an ECU
    ECU_IN = 0x09,          //!< Message *to* an ECU

    SYSTEM = 0x19,          //!< System messages (e.g. bootloader)
};

//! Piccolo actuator types differentiate between actuator frames
enum class PiccoloCAN_ActuatorType : uint8_t {
    SERVO = 0x00,
    ESC = 0x20,
};


/*
 * Generic PiccoloCAN device class implementation
 */

class AP_PiccoloCAN_Device
{
public:
    virtual bool handle_can_frame(AP_HAL::CANFrame &frame) = 0;

    // Determine if this device is "enabled" (default implementation returns false)
    virtual bool is_enabled(void) const { return false; }

    // Determine if this device has been seen within a specified timeframe
    virtual bool is_connected(int64_t timeout_ms) const {
        uint64_t now = AP_HAL::micros64();

        return now < (last_msg_timestamp + (1000ULL * timeout_ms));
    }

    // Reset the received message timestamp
    void reset_rx_timestamp() {
        last_msg_timestamp = AP_HAL::micros64();
    }

    //! Timestamp of most recently received CAN message
    uint64_t last_msg_timestamp = 0;
};

#endif // HAL_PICCOLO_CAN_ENABLE
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               /*
 * This file is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This file is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Author: Oliver Walters / Currawong Engineering Pty Ltd
 */

#include "AP_PiccoloCAN_ECU.h"

#if HAL_PICCOLO_CAN_ENABLE

// Protocol files for the ECU
#include <AP_PiccoloCAN/piccolo_protocol/ECUProtocol.h>
#include <AP_PiccoloCAN/piccolo_protocol/ECUPackets.h>


/* Piccolo Glue Logic
 * The following functions are required by the auto-generated protogen code.
 */


//! \return the packet data pointer from the packet
uint8_t* getECUPacketData(void* pkt)
{
    AP_HAL::CANFrame* frame = (AP_HAL::CANFrame*) pkt;

    return (uint8_t*) frame->data;
}

//! \return the packet data pointer from the packet, const
const uint8_t* getECUPacketDataConst(const void* pkt)
{
    AP_HAL::CANFrame* frame = (AP_HAL::CANFrame*) pkt;

    return (const uint8_t*) frame->data;
}

//! Complete a packet after the data have been encoded
void finishECUPacket(void* pkt, int size, uint32_t packetID)
{
    AP_HAL::CANFrame* frame = (AP_HAL::CANFrame*) pkt;

    if (size > AP_HAL::CANFrame::MaxDataLen) {
        size = AP_HAL::CANFrame::MaxDataLen;
    }

    frame->dlc = size;

    /* Encode the CAN ID
     * 0x09mmdddd
     * - 07 = ECU_IN (to and ECU) group ID
     * - mm = Message ID
     * - dd = Device ID
     *
     * Note: The Device ID (lower 16 bits of the frame ID) will have to be inserted later
     */

    uint32_t id = (((uint8_t) PiccoloCAN_MessageGroup::ECU_IN) << 24) |       // CAN Group ID
                  ((packetID & 0xFF) << 16);                                       // Message ID

    // Extended frame format
    id |= AP_HAL::CANFrame::FlagEFF;

    frame->id = id;
}

//! \return the size of a packet from the packet header
int getECUPacketSize(const void* pkt)
{
    AP_HAL::CANFrame* frame = (AP_HAL::CANFrame*) pkt;

    return (int) frame->dlc;
}

//! \return the ID of a packet from the packet header
uint32_t getECUPacketID(const void* pkt)
{
    AP_HAL::CANFrame* frame = (AP_HAL::CANFrame*) pkt;

    // Extract the message ID field from the 29-bit ID
    return (uint32_t) ((frame->id >> 16) & 0xFF);
}

#endif // HAL_PICCOLO_CAN_ENABLE                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       /*
 * This file is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This file is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Author: Oliver Walters / Currawong Engineering Pty Ltd
 */


#pragma once

#include <AP_CANManager/AP_CANManager.h>

#include "AP_PiccoloCAN_Device.h"
#include "piccolo_protocol/ECUPackets.h"

#define PICCOLO_CAN_ECU_ID_DEFAULT 0

#if HAL_PICCOLO_CAN_ENABLE

/*
 * Class representing an individual PiccoloCAN ECU
 */
class AP_PiccoloCAN_ECU : public AP_PiccoloCAN_Device
{
public:
    // TODO
};

#endif // HAL_PICCOLO_CAN_ENABLE
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          /*
 * This file is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This file is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Author: Oliver Walters / Currawong Engineering Pty Ltd
 */

#include "AP_PiccoloCAN_ESC.h"

#if HAL_PICCOLO_CAN_ENABLE

/*
 * Decode a received CAN frame.
 * It is assumed at this point that the received frame is intended for *this* ESC
 */
bool AP_PiccoloCAN_ESC::handle_can_frame(AP_HAL::CANFrame &frame)
{
    bool result = true;

    // The ESC address is the lower byte of the frame ID
    uint8_t addr = frame.id & 0xFF;

    // Ignore any ESC with node ID of zero
    if (addr == 0x00) {
        return false;
    }

    addr -= 1;

    uint8_t extended;

    if (decodeESC_StatusAPacketStructure(&frame, &status.statusA)) {
        newTelemetry = true;
        update_rpm(addr, rpm());
    } else if (decodeESC_StatusBPacketStructure(&frame, &status.statusB)) {
        AP_ESC_Telem_Backend::TelemetryData telem {};

        telem.voltage = voltage() * 10;
        telem.current = current() * 10;
        telem.motor_temp_cdeg = int16_t(motorTemperature() * 100);
        telem.temperature_cdeg = int16_t(temperature() * 100);

        update_telem_data(addr, telem,
            AP_ESC_Telem_Backend::TelemetryType::CURRENT |
            AP_ESC_Telem_Backend::TelemetryType::VOLTAGE |
            AP_ESC_Telem_Backend::TelemetryType::TEMPERATURE |
            AP_ESC_Telem_Backend::TelemetryType::MOTOR_TEMPERATURE);

        newTelemetry = true;
    } else if (decodeESC_StatusCPacketStructure(&frame, &status.statusC)) {
        AP_ESC_Telem_Backend::TelemetryData telem {};

        telem.temperature_cdeg = temperature() * 100;
        update_telem_data(addr, telem, AP_ESC_Telem_Backend::TelemetryType::TEMPERATURE);
        newTelemetry = true;
    } else if (decodeESC_WarningErrorStatusPacket(&frame, &status.warnings, &status.errors, &extended, &status.warnings, &status.errors)) {
        newTelemetry = true;
    } else if (decodeESC_FirmwarePacketStructure(&frame, &settings.firmware)) {
    } else if (decodeESC_AddressPacketStructure(&frame, &settings.address)) {
    } else if (decodeESC_EEPROMSettingsPacketStructure(&frame, &settings.eeprom)) {
    } else {
        result = false;
    }

    if (result) {
        reset_rx_timestamp();
    }

    return result;
}


/* Piccolo Glue Logic
 * The following functions are required by the auto-generated protogen code.
 */

//! \return the packet data pointer from the packet
uint8_t* getESCVelocityPacketData(void* pkt)
{
    AP_HAL::CANFrame* frame = (AP_HAL::CANFrame*) pkt;

    return (uint8_t*) frame->data;
}

//! \return the packet data pointer from the packet, const
const uint8_t* getESCVelocityPacketDataConst(const void* pkt)
{
    AP_HAL::CANFrame* frame = (AP_HAL::CANFrame*) pkt;

    return (const uint8_t*) frame->data;
}

//! Complete a packet after the data have been encoded
void finishESCVelocityPacket(void* pkt, int size, uint32_t packetID)
{
    AP_HAL::CANFrame* frame = (AP_HAL::CANFrame*) pkt;

    if (size > AP_HAL::CANFrame::MaxDataLen) {
        size = AP_HAL::CANFrame::MaxDataLen;
    }

    frame->dlc = size;

    /* Encode the CAN ID
     * 0x07mm20dd
     * - 07 = ACTUATOR group ID
     * - mm = Message ID
     * - 20 = ESC actuator type
     * - dd = Device ID
     *
     * Note: The Device ID (lower 8 bits of the frame ID) will have to be inserted later
     */

    uint32_t id = (((uint8_t) PiccoloCAN_MessageGroup::ACTUATOR) << 24) |       // CAN Group ID
                  ((packetID & 0xFF) << 16) |                                       // Message ID
                  (((uint8_t) PiccoloCAN_ActuatorType::ESC) << 8);              // Actuator type

    // Extended frame format
    id |= AP_HAL::CANFrame::FlagEFF;

    frame->id = id;
}

//! \return the size of a packet from the packet header
int getESCVelocityPacketSize(const void* pkt)
{
    AP_HAL::CANFrame* frame = (AP_HAL::CANFrame*) pkt;

    return (int) frame->dlc;
}

//! \return the ID of a packet from the packet header
uint32_t getESCVelocityPacketID(const void* pkt)
{
    AP_HAL::CANFrame* frame = (AP_HAL::CANFrame*) pkt;

    // Extract the message ID field from the 29-bit ID
    return (uint32_t) ((frame->id >> 16) & 0xFF);
}

#endif // HAL_PICCOLO_CAN_ENABLE
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              /*
 * This file is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This file is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Author: Oliver Walters / Currawong Engineering Pty Ltd
 */


#pragma once

#include <AP_Math/AP_Math.h>
#include <AP_CANManager/AP_CANManager.h>
#include <AP_ESC_Telem/AP_ESC_Telem_Backend.h>

#include "AP_PiccoloCAN_Device.h"
#include "piccolo_protocol/ESCPackets.h"

#if HAL_PICCOLO_CAN_ENABLE

#define PICCOLO_CAN_MAX_NUM_ESC 16
#define PICCOLO_CAN_MAX_GROUP_ESC (PICCOLO_CAN_MAX_NUM_ESC / 4)


/*
 * Class representing an individual PiccoloCAN ESC
 */
class AP_PiccoloCAN_ESC : public AP_PiccoloCAN_Device, public AP_ESC_Telem_Backend
{
public:

    virtual bool handle_can_frame(AP_HAL::CANFrame &frame) override;

    bool is_sw_inhibited(void) const { return status.statusA.status.swInhibit; }
    bool is_hw_inhibited(void) const { return status.statusA.status.hwInhibit; }

    virtual bool is_enabled(void) const override { return !is_sw_inhibited() && !is_hw_inhibited(); }

    float voltage() { return (float) status.statusB.voltage * 0.01f; }      // Convert to V
    float current() { return (float) status.statusB.current * 0.01f; }      // Convert to A
    uint16_t rpm() { return status.statusA.rpm; }
    float temperature() { return MAX(status.statusB.escTemperature, status.statusC.fetTemperature); }
    float motorTemperature() { return status.statusB.motorTemperature; }

    int16_t command;    //! Raw command to send to each ESC
    bool newCommand;    //! Is the command "new"?
    bool newTelemetry;  //! Is there new telemetry data available?

    // Status / telemetry data
    struct Status_t {
        ESC_StatusA_t statusA;
        ESC_StatusB_t statusB;
        ESC_StatusC_t statusC;

        ESC_WarningBits_t warnings;
        ESC_ErrorBits_t errors;
    } status;

    // Settings information
    struct Settings_t {
        ESC_Firmware_t firmware;
        ESC_Address_t address;
        ESC_EEPROMSettings_t eeprom;
    } settings;
};

#endif // HAL_PICCOLO_CAN_ENABLE
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  /*
 * This file is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This file is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Author: Oliver Walters / Currawong Engineering Pty Ltd
 */

#include "AP_PiccoloCAN_Servo.h"

#if HAL_PICCOLO_CAN_ENABLE

/*
 * Decode a recevied CAN frame.
 * It is assumed at this point that the received frame is intended for *this* servo
 */
bool AP_PiccoloCAN_Servo::handle_can_frame(AP_HAL::CANFrame &frame)
{
    bool result = true;

    if (decodeServo_StatusAPacketStructure(&frame, &status.statusA)) {
        newTelemetry = true;
    } else if (decodeServo_StatusBPacketStructure(&frame, &status.statusB)) {
        newTelemetry = true;
    } else if (decodeServo_FirmwarePacketStructure(&frame, &settings.firmware)) {
    } else if (decodeServo_AddressPacketStructure(&frame, &settings.address)) {
    } else if (decodeServo_SettingsInfoPacketStructure(&frame, &settings.settings)) {
    } else {
        // Incoming frame did not match any packet decoding routine
        result = false;
    }

    if (result) {
        reset_rx_timestamp();
    }

    return result;
}


/* Piccolo Glue Logic
 * The following functions are required by the auto-generated protogen code.
 */

//! \return the packet data pointer from the packet
uint8_t* getServoPacketData(void* pkt)
{
    AP_HAL::CANFrame* frame = (AP_HAL::CANFrame*) pkt;

    return (uint8_t*) frame->data;
}

//! \return the packet data pointer from the packet, const
const uint8_t* getServoPacketDataConst(const void* pkt)
{
    AP_HAL::CANFrame* frame = (AP_HAL::CANFrame*) pkt;

    return (const uint8_t*) frame->data;
}

//! Complete a packet after the data have been encoded
void finishServoPacket(void* pkt, int size, uint32_t packetID)
{
    AP_HAL::CANFrame* frame = (AP_HAL::CANFrame*) pkt;

    if (size > AP_HAL::CANFrame::MaxDataLen) {
        size = AP_HAL::CANFrame::MaxDataLen;
    }

    frame->dlc = size;

    /* Encode the CAN ID
     * 0x07mm20dd
     * - 07 = ACTUATOR group ID
     * - mm = Message ID
     * - 00 = Servo actuator type
     * - dd = Device ID
     *
     * Note: The Device ID (lower 8 bits of the frame ID) will have to be inserted later
     */

    uint32_t id = (((uint8_t) PiccoloCAN_MessageGroup::ACTUATOR) << 24) |       // CAN Group ID
                  ((packetID & 0xFF) << 16) |                                       // Message ID
                  (((uint8_t) PiccoloCAN_ActuatorType::SERVO) << 8);            // Actuator type

    // Extended frame format
    id |= AP_HAL::CANFrame::FlagEFF;

    frame->id = id;
}

//! \return the size of a packet from the packet header
int getServoPacketSize(const void* pkt)
{
    AP_HAL::CANFrame* frame = (AP_HAL::CANFrame*) pkt;

    return (int) frame->dlc;
}

//! \return the ID of a packet from the packet header
uint32_t getServoPacketID(const void* pkt)
{
    AP_HAL::CANFrame* frame = (AP_HAL::CANFrame*) pkt;

    // Extract the message ID field from the 29-bit ID
    return (uint32_t) ((frame->id >> 16) & 0xFF);
}

#endif // HAL_PICCOLO_CAN_ENABLE                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  /*
 * This file is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This file is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Author: Oliver Walters / Currawong Engineering Pty Ltd
 */

#pragma once

#include <AP_CANManager/AP_CANManager.h>

#include "AP_PiccoloCAN_Device.h"
#include "piccolo_protocol/ServoPackets.h"

#if HAL_PICCOLO_CAN_ENABLE

#define PICCOLO_CAN_MAX_NUM_SERVO 16
#define PICCOLO_CAN_MAX_GROUP_SERVO (PICCOLO_CAN_MAX_NUM_SERVO / 4)


/*
 * Class representing an individual PiccoloCAN servo
 */
class AP_PiccoloCAN_Servo : public AP_PiccoloCAN_Device
{
public:

    virtual bool handle_can_frame(AP_HAL::CANFrame &frame) override;

    virtual bool is_enabled(void) const override { return status.statusA.status.enabled; }

    // Helper functions for accessing servo status data
    float position() const { return (float) status.statusA.position; }
    float commandedPosition() const { return (float) status.statusA.command; }
    float current() const { return (float) status.statusB.current * 0.01f; }
    float voltage() const { return (float) status.statusB.voltage * 0.01f; }
    float speed() const { return (float) status.statusB.speed; }
    uint8_t dutyCycle() const { return abs(status.statusB.dutyCycle); }
    float temperature() const { return (float) status.statusB.temperature; }

    int16_t command = 0;
    bool newCommand = false;
    bool newTelemetry = false;

    // Status / telemetry data
    struct Status_t {
        Servo_StatusA_t statusA;
        Servo_StatusB_t statusB;
    } status;

    // Settings information
    struct Settings_t {
        Servo_Firmware_t firmware;
        Servo_Address_t address;
        Servo_SettingsInfo_t settings;
    } settings;
};

#endif // HAL_PICCOLO_CAN_ENABLE
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               # gitignore file for temporary files generated by Protogen

html/

*.db
*.markdown
*.html                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       // ECUDefines.c was generated by ProtoGen version 3.2.a

/*
 * This file is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This file is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Author: Oliver Walters / Currawong Engineering Pty Ltd
 */
 

#include "ECUDefines.h"
#include "fielddecode.h"
#include "fieldencode.h"
#include "scaleddecode.h"
#include "scaledencode.h"

/*!
 * \brief Encode a ECU_AuxiliaryErrorBits_t into a byte array
 *

 * \param _pg_data points to the byte array to add encoded data to
 * \param _pg_bytecount points to the starting location in the byte array, and will be incremented by the number of encoded bytes.
 * \param _pg_user is the data to encode in the byte array
 */
void encodeECU_AuxiliaryErrorBits_t(uint8_t* _pg_data, int* _pg_bytecount, const ECU_AuxiliaryErrorBits_t* _pg_user)
{
    int _pg_byteindex = *_pg_bytecount;

    // 1 if CAN servo is not connected
    _pg_data[_pg_byteindex] = (uint8_t)((_pg_user->servoLink == true) ? 1 : 0) << 7;

    // 1 if CAN servo is reporting a position error
    _pg_data[_pg_byteindex] |= (uint8_t)((_pg_user->servoPosition == true) ? 1 : 0) << 6;

    // Reserved for future use
    // Range of reserved_A is 0 to 63.
    _pg_data[_pg_byteindex] |= (uint8_t)_pg_user->reserved_A;

    // Reserved for future use
    // Range of reserved_B is 0 to 255.
    _pg_data[_pg_byteindex + 1] = (uint8_t)_pg_user->reserved_B;

    // Reserved for future use
    // Range of reserved_C is 0 to 255.
    _pg_data[_pg_byteindex + 2] = (uint8_t)_pg_user->reserved_C;

    // Reserved for future use
    // Range of reserved_D is 0 to 255.
    _pg_data[_pg_byteindex + 3] = (uint8_t)_pg_user->reserved_D;
    _pg_byteindex += 4; // close bit field

    *_pg_bytecount = _pg_byteindex;

}// encodeECU_AuxiliaryErrorBits_t

/*!
 * \brief Decode a ECU_AuxiliaryErrorBits_t from a byte array
 *

 * \param _pg_data points to the byte array to decoded data from
 * \param _pg_bytecount points to the starting location in the byte array, and will be incremented by the number of bytes decoded
 * \param _pg_user is the data to decode from the byte array
 * \return 1 if the data are decoded, else 0.
 */
int decodeECU_AuxiliaryErrorBits_t(const uint8_t* _pg_data, int* _pg_bytecount, ECU_AuxiliaryErrorBits_t* _pg_user)
{
    int _pg_byteindex = *_pg_bytecount;

    // 1 if CAN servo is not connected
    _pg_user->servoLink = ((_pg_data[_pg_byteindex] >> 7)) ? true : false;

    // 1 if CAN servo is reporting a position error
    _pg_user->servoPosition = (((_pg_data[_pg_byteindex] >> 6) & 0x1)) ? true : false;

    // Reserved for future use
    // Range of reserved_A is 0 to 63.
    _pg_user->reserved_A = ((_pg_data[_pg_byteindex]) & 0x3F);

    // Reserved for future use
    // Range of reserved_B is 0 to 255.
    _pg_user->reserved_B = _pg_data[_pg_byteindex + 1];

    // Reserved for future use
    // Range of reserved_C is 0 to 255.
    _pg_user->reserved_C = _pg_data[_pg_byteindex + 2];

    // Reserved for future use
    // Range of reserved_D is 0 to 255.
    _pg_user->reserved_D = _pg_data[_pg_byteindex + 3];
    _pg_byteindex += 4; // close bit field

    *_pg_bytecount = _pg_byteindex;

    return 1;

}// decodeECU_AuxiliaryErrorBits_t

/*!
 * \brief Encode a ECU_AutronicErrorBits_t into a byte array
 *

 * \param _pg_data points to the byte array to add encoded data to
 * \param _pg_bytecount points to the starting location in the byte array, and will be incremented by the number of encoded bytes.
 * \param _pg_user is the data to encode in the byte array
 */
void encodeECU_AutronicErrorBits_t(uint8_t* _pg_data, int* _pg_bytecount, const ECU_AutronicErrorBits_t* _pg_user)
{
    int _pg_byteindex = *_pg_bytecount;

    // Reserved
    _pg_data[_pg_byteindex] = 0;

    // Knock control error
    _pg_data[_pg_byteindex + 1] = (uint8_t)_pg_user->knockControl << 7;

    // AF closed loop error
    _pg_data[_pg_byteindex + 1] |= (uint8_t)_pg_user->afCloseLoop << 6;

    // EEPROM error
    _pg_data[_pg_byteindex + 1] |= (uint8_t)_pg_user->eepromError << 5;

    // CMOS RAM error
    _pg_data[_pg_byteindex + 1] |= (uint8_t)_pg_user->cmosRam << 4;

    // Over voltage error
    _pg_data[_pg_byteindex + 1] |= (uint8_t)_pg_user->overVoltage << 3;

    // Power down error
    _pg_data[_pg_byteindex + 1] |= (uint8_t)_pg_user->powerDown << 2;

    // Knock sensor error
    _pg_data[_pg_byteindex + 1] |= (uint8_t)_pg_user->knockSensor << 1;

    // Over boost error
    _pg_data[_pg_byteindex + 1] |= (uint8_t)_pg_user->overBoost;

    // CAM2 position error
    _pg_data[_pg_byteindex + 2] = (uint8_t)_pg_user->cam2Pos << 7;

    // CAM1 position error
    _pg_data[_pg_byteindex + 2] |= (uint8_t)_pg_user->cam1Pos << 6;

    // High speed input 1 error
    _pg_data[_pg_byteindex + 2] |= (uint8_t)_pg_user->highSpeedInput2 << 5;

    // High speed input 2 error
    _pg_data[_pg_byteindex + 2] |= (uint8_t)_pg_user->highSpeedInput1 << 4;

    // Set if too many cylinder pulses
    _pg_data[_pg_byteindex + 2] |= (uint8_t)_pg_user->tooManyCylPulse << 3;

    // Set if too few cylinder pulses
    _pg_data[_pg_byteindex + 2] |= (uint8_t)_pg_user->tooFewCylPulse << 2;

    // Set if sync input pulse missing
    _pg_data[_pg_byteindex + 2] |= (uint8_t)_pg_user->syncInputPulseMissing << 1;

    // Set if cylinder input pulse missing
    _pg_data[_pg_byteindex + 2] |= (uint8_t)_pg_user->cylinderInputPulseMissing;

    // Air fuel sensor 2 error
    _pg_data[_pg_byteindex + 3] = (uint8_t)_pg_user->af2Sensor << 7;

    // Air fuel sensor 1 error
    _pg_data[_pg_byteindex + 3] |= (uint8_t)_pg_user->af1Sensor << 6;

    // Barometric pressure sensor error
    _pg_data[_pg_byteindex + 3] |= (uint8_t)_pg_user->baroSensor << 5;

    // Exhaust back pressure sensor error
    _pg_data[_pg_byteindex + 3] |= (uint8_t)_pg_user->ebpSensor << 4;

    // Manifold pressure sensor error
    _pg_data[_pg_byteindex + 3] |= (uint8_t)_pg_user->mapSensor << 3;

    // Throttle position sensor error
    _pg_data[_pg_byteindex + 3] |= (uint8_t)_pg_user->tpsSensor << 2;

    // Cylinder head temperature sensor error
    _pg_data[_pg_byteindex + 3] |= (uint8_t)_pg_user->chtSensor << 1;

    // Manifold pressure sensor error
    _pg_data[_pg_byteindex + 3] |= (uint8_t)_pg_user->matSensor;
    _pg_byteindex += 4; // close bit field

    *_pg_bytecount = _pg_byteindex;

}// encodeECU_AutronicErrorBits_t

/*!
 * \brief Decode a ECU_AutronicErrorBits_t from a byte array
 *

 * \param _pg_data points to the byte array to decoded data from
 * \param _pg_bytecount points to the starting location in the byte array, and will be incremented by the number of bytes decoded
 * \param _pg_user is the data to decode from the byte array
 * \return 1 if the data are decoded, else 0.
 */
int decodeECU_AutronicErrorBits_t(const uint8_t* _pg_data, int* _pg_bytecount, ECU_AutronicErrorBits_t* _pg_user)
{
    int _pg_byteindex = *_pg_bytecount;

    // Reserved

    // Knock control error
    _pg_user->knockControl = (_pg_data[_pg_byteindex + 1] >> 7);

    // AF closed loop error
    _pg_user->afCloseLoop = ((_pg_data[_pg_byteindex + 1] >> 6) & 0x1);

    // EEPROM error
    _pg_user->eepromError = ((_pg_data[_pg_byteindex + 1] >> 5) & 0x1);

    // CMOS RAM error
    _pg_user->cmosRam = ((_pg_data[_pg_byteindex + 1] >> 4) & 0x1);

    // Over voltage error
    _pg_user->overVoltage = ((_pg_data[_pg_byteindex + 1] >> 3) & 0x1);

    // Power down error
    _pg_user->powerDown = ((_pg_data[_pg_byteindex + 1] >> 2) & 0x1);

    // Knock sensor error
    _pg_user->knockSensor = ((_pg_data[_pg_byteindex + 1] >> 1) & 0x1);

    // Over boost error
    _pg_user->overBoost = ((_pg_data[_pg_byteindex + 1]) & 0x1);

    // CAM2 position error
    _pg_user->cam2Pos = (_pg_data[_pg_byteindex + 2] >> 7);

    // CAM1 position error
    _pg_user->cam1Pos = ((_pg_data[_pg_byteindex + 2] >> 6) & 0x1);

    // High speed input 1 error
    _pg_user->highSpeedInput2 = ((_pg_data[_pg_byteindex + 2] >> 5) & 0x1);

    // High speed input 2 error
    _pg_user->highSpeedInput1 = ((_pg_data[_pg_byteindex + 2] >> 4) & 0x1);

    // Set if too many cylinder pulses
    _pg_user->tooManyCylPulse = ((_pg_data[_pg_byteindex + 2] >> 3) & 0x1);

    // Set if too few cylinder pulses
    _pg_user->tooFewCylPulse = ((_pg_data[_pg_byteindex + 2] >> 2) & 0x1);

    // Set if sync input pulse missing
    _pg_user->syncInputPulseMissing = ((_pg_data[_pg_byteindex + 2] >> 1) & 0x1);

    // Set if cylinder input pulse missing
    _pg_user->cylinderInputPulseMissing = ((_pg_data[_pg_byteindex + 2]) & 0x1);

    // Air fuel sensor 2 error
    _pg_user->af2Sensor = (_pg_data[_pg_byteindex + 3] >> 7);

    // Air fuel sensor 1 error
    _pg_user->af1Sensor = ((_pg_data[_pg_byteindex + 3] >> 6) & 0x1);

    // Barometric pressure sensor error
    _pg_user->baroSensor = ((_pg_data[_pg_byteindex + 3] >> 5) & 0x1);

    // Exhaust back pressure sensor error
    _pg_user->ebpSensor = ((_pg_data[_pg_byteindex + 3] >> 4) & 0x1);

    // Manifold pressure sensor error
    _pg_user->mapSensor = ((_pg_data[_pg_byteindex + 3] >> 3) & 0x1);

    // Throttle position sensor error
    _pg_user->tpsSensor = ((_pg_data[_pg_byteindex + 3] >> 2) & 0x1);

    // Cylinder head temperature sensor error
    _pg_user->chtSensor = ((_pg_data[_pg_byteindex + 3] >> 1) & 0x1);

    // Manifold pressure sensor error
    _pg_user->matSensor = ((_pg_data[_pg_byteindex + 3]) & 0x1);
    _pg_byteindex += 4; // close bit field

    *_pg_bytecount = _pg_byteindex;

    return 1;

}// decodeECU_AutronicErrorBits_t

/*!
 * \brief Encode a ECU_ErrorBits_t into a byte array
 *

 * \param _pg_data points to the byte array to add encoded data to
 * \param _pg_bytecount points to the starting location in the byte array, and will be incremented by the number of encoded bytes.
 * \param _pg_user is the data to encode in the byte array
 */
void encodeECU_ErrorBits_t(uint8_t* _pg_data, int* _pg_bytecount, const ECU_ErrorBits_t* _pg_user)
{
    int _pg_byteindex = *_pg_bytecount;

    // Error information for autronic processor
    encodeECU_AutronicErrorBits_t(_pg_data, &_pg_byteindex, &_pg_user->autronic);

    // Error information for auxiliary processor
    encodeECU_AuxiliaryErrorBits_t(_pg_data, &_pg_byteindex, &_pg_user->auxiliary);

    *_pg_bytecount = _pg_byteindex;

}// encodeECU_ErrorBits_t

/*!
 * \brief Decode a ECU_ErrorBits_t from a byte array
 *

 * \param _pg_data points to the byte array to decoded data from
 * \param _pg_bytecount points to the starting location in the byte array, and will be incremented by the number of bytes decoded
 * \param _pg_user is the data to decode from the byte array
 * \return 1 if the data are decoded, else 0.
 */
int decodeECU_ErrorBits_t(const uint8_t* _pg_data, int* _pg_bytecount, ECU_ErrorBits_t* _pg_user)
{
    int _pg_byteindex = *_pg_bytecount;

    // Error information for autronic processor
    if(decodeECU_AutronicErrorBits_t(_pg_data, &_pg_byteindex, &_pg_user->autronic) == 0)
        return 0;

    // Error information for auxiliary processor
    if(decodeECU_AuxiliaryErrorBits_t(_pg_data, &_pg_byteindex, &_pg_user->auxiliary) == 0)
        return 0;

    *_pg_bytecount = _pg_byteindex;

    return 1;

}// decodeECU_ErrorBits_t

/*!
 * \brief Encode a ECU_ThrottleDelayConfigBits_t into a byte array
 *

 * \param _pg_data points to the byte array to add encoded data to
 * \param _pg_bytecount points to the starting location in the byte array, and will be incremented by the number of encoded bytes.
 * \param _pg_user is the data to encode in the byte array
 */
void encodeECU_ThrottleDelayConfigBits_t(uint8_t* _pg_data, int* _pg_bytecount, const ECU_ThrottleDelayConfigBits_t* _pg_user)
{
    int _pg_byteindex = *_pg_bytecount;

    // reserved for future use
    // Range of reserved is 0 to 127.
    _pg_data[_pg_byteindex] = (uint8_t)_pg_user->reserved << 1;

    // Set to base the delay on temperature, else the delay is manually set
    _pg_data[_pg_byteindex] |= (uint8_t)((_pg_user->delayOnTemp == true) ? 1 : 0);
    _pg_byteindex += 1; // close bit field

    *_pg_bytecount = _pg_byteindex;

}// encodeECU_ThrottleDelayConfigBits_t

/*!
 * \brief Decode a ECU_ThrottleDelayConfigBits_t from a byte array
 *

 * \param _pg_data points to the byte array to decoded data from
 * \param _pg_bytecount points to the starting location in the byte array, and will be incremented by the number of bytes decoded
 * \param _pg_user is the data to decode from the byte array
 * \return 1 if the data are decoded, else 0.
 */
int decodeECU_ThrottleDelayConfigBits_t(const uint8_t* _pg_data, int* _pg_bytecount, ECU_ThrottleDelayConfigBits_t* _pg_user)
{
    int _pg_byteindex = *_pg_bytecount;

    // reserved for future use
    // Range of reserved is 0 to 127.
    _pg_user->reserved = (_pg_data[_pg_byteindex] >> 1);

    // Set to base the delay on temperature, else the delay is manually set
    _pg_user->delayOnTemp = (((_pg_data[_pg_byteindex]) & 0x1)) ? true : false;
    _pg_byteindex += 1; // close bit field

    *_pg_bytecount = _pg_byteindex;

    return 1;

}// decodeECU_ThrottleDelayConfigBits_t

/*!
 * \brief Encode a ECU_ThrottleConfigBits_t into a byte array
 *

 * \param _pg_data points to the byte array to add encoded data to
 * \param _pg_bytecount points to the starting location in the byte array, and will be incremented by the number of encoded bytes.
 * \param _pg_user is the data to encode in the byte array
 */
void encodeECU_ThrottleConfigBits_t(uint8_t* _pg_data, int* _pg_bytecount, const ECU_ThrottleConfigBits_t* _pg_user)
{
    int _pg_byteindex = *_pg_bytecount;

    // Enable pass-through of CAN servo data over serial link
    _pg_data[_pg_byteindex] = (uint8_t)((_pg_user->servoPassthrough == true) ? 1 : 0) << 7;

    // Reserved for future use

    // Set if the CAN throttle is detected
    _pg_data[_pg_byteindex] |= (uint8_t)((_pg_user->canThrottleDetected == true) ? 1 : 0) << 1;

    // Set if CAN throttle is enabled. This bit is ignored when this packet is sent to the ECU. To enable CAN throttle you must use system commands
    _pg_data[_pg_byteindex] |= (uint8_t)((_pg_user->canThrottle == true) ? 1 : 0);
    _pg_byteindex += 1; // close bit field

    *_pg_bytecount = _pg_byteindex;

}// encodeECU_ThrottleConfigBits_t

/*!
 * \brief Decode a ECU_ThrottleConfigBits_t from a byte array
 *

 * \param _pg_data points to the byte array to decoded data from
 * \param _pg_bytecount points to the starting location in the byte array, and will be incremented by the number of bytes decoded
 * \param _pg_user is the data to decode from the byte array
 * \return 1 if the data are decoded, else 0.
 */
int decodeECU_ThrottleConfigBits_t(const uint8_t* _pg_data, int* _pg_bytecount, ECU_ThrottleConfigBits_t* _pg_user)
{
    int _pg_byteindex = *_pg_bytecount;

    // Enable pass-through of CAN servo data over serial link
    _pg_user->servoPassthrough = ((_pg_data[_pg_byteindex] >> 7)) ? true : false;

    // Reserved for future use

    // Set if the CAN throttle is detected
    _pg_user->canThrottleDetected = (((_pg_data[_pg_byteindex] >> 1) & 0x1)) ? true : false;

    // Set if CAN throttle is enabled. This bit is ignored when this packet is sent to the ECU. To enable CAN throttle you must use system commands
    _pg_user->canThrottle = (((_pg_data[_pg_byteindex]) & 0x1)) ? true : false;
    _pg_byteindex += 1; // close bit field

    *_pg_bytecount = _pg_byteindex;

    return 1;

}// decodeECU_ThrottleConfigBits_t

/*!
 * \brief Encode a ECU_ThrottleCurveConfigBits_t into a byte array
 *

 * \param _pg_data points to the byte array to add encoded data to
 * \param _pg_bytecount points to the starting location in the byte array, and will be incremented by the number of encoded bytes.
 * \param _pg_user is the data to encode inarometric pressure in kilo-Pascals
    // Range of baro is 0.0f to 131.07f.
    float32ScaledTo2UnsignedBeBytes(_pg_user->baro, _pg_data, &_pg_byteindex, 0.0f, 500.0f);

    // Percentage ratio of manifold pressure to barometric pressure
    uint8ToBytes((uint8_t)(0), _pg_data, &_pg_byteindex);

    // Reconstruct the RPM command
    _pg_data[0] = (uint8_t)(_pg_user->rpmCmd/50); _pg_data[4] = (uint8_t)(_pg_user->rpmCmd - _pg_data[0]*50);

    // Reconstruct the manifold pressure
    _pg_data[7] = (uint8_t)(0.5f + 100.0f*_pg_user->map/_pg_user->baro);

    // complete the process of creating the packet
    finishECUPacket(_pg_pkt, _pg_byteindex, getECU_TelemetrySlow0PacketID());

}// encodeECU_TelemetrySlow0PacketStructure

/*!
 * \brief Decode the ECU_TelemetrySlow0 packet
 *
 * This is the first of three slower telemetry packets which are transmitted by
 * the ECU at a user customizable period (between 0.5s and 10.0s). These three
 * packets contain data that is not likely to change as quickly as the data in
 * the fast telemetry packet. By default, the slow telemetry messages are
 * transmitted at 1Hz (period of 1.0s).
 * \param _pg_pkt points to the packet being decoded by this function
 * \param _pg_user receives the data decoded from the packet
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeECU_TelemetrySlow0PacketStructure(const void* _pg_pkt, ECU_TelemetrySlow0_t* _pg_user)
{
    int _pg_numbytes;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data;
    unsigned int _pg_tempbitfield = 0;

    // Verify the packet identifier
    if(getECUPacketID(_pg_pkt) != getECU_TelemetrySlow0PacketID())
        return 0;

    // Verify the packet size
    _pg_numbytes = getECUPacketSize(_pg_pkt);
    if(_pg_numbytes < getECU_TelemetrySlow0MinDataLength())
        return 0;

    // The raw data from the packet
    _pg_data = getECUPacketDataConst(_pg_pkt);

    // RPM command in units of 50 RPM
    _pg_byteindex += 1;

    // Source of the throttle information
    _pg_user->throttleSrc = (ECUThrottleSource)(_pg_data[_pg_byteindex] >> 4);

    // Throttle pulse width in microseconds
    // Range of throttlePulse is 0 to 4095.
    _pg_tempbitfield = (_pg_data[_pg_byteindex] & 0xF);

    _pg_tempbitfield <<= 8;
    _pg_tempbitfield |= _pg_data[_pg_byteindex + 1];

    _pg_user->throttlePulse = _pg_tempbitfield;
    _pg_byteindex += 2; // close bit field

    // Cylinder head temperature in Celsius
    // Range of cht is -10.0f to 245.0f.
    _pg_user->cht = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, -10.0f, 1.0f/1.0f);

    // Low part of RPM command from 0 to 49
    _pg_byteindex += 1;

    // Barometric pressure in kilo-Pascals
    // Range of baro is 0.0f to 131.07f.
    _pg_user->baro = float32ScaledFrom2UnsignedBeBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/500.0f);

    // Percentage ratio of manifold pressure to barometric pressure
    _pg_byteindex += 1;

    // Reconstruct the RPM command
    _pg_user->rpmCmd = (uint16_t)(_pg_data[0]*50 + _pg_data[4]);

    // Reconstruct the manifold pressure
    _pg_user->map = _pg_data[7]*0.01f*_pg_user->baro;

    return 1;

}// decodeECU_TelemetrySlow0PacketStructure

/*!
 * \brief Create the ECU_TelemetrySlow1 packet
 *
 * The second of three slow telemetry packets
 * \param _pg_pkt points to the packet which will be created by this function
 * \param _pg_user points to the user data that will be encoded in _pg_pkt
 */
void encodeECU_TelemetrySlow1PacketStructure(void* _pg_pkt, const ECU_TelemetrySlow1_t* _pg_user)
{
    uint8_t* _pg_data = getECUPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    // Inlet air temperature in Celsius
    // Range of mat is -127.0f to 127.0f.
    float32ScaledTo1SignedBytes(_pg_user->mat, _pg_data, &_pg_byteindex, 1.0f);

    // Fuel pressure in kilo-Pascals
    // Range of fuelPressure is 0.0f to 1310.7f.
    float32ScaledTo2UnsignedBeBytes(_pg_user->fuelPressure, _pg_data, &_pg_byteindex, 0.0f, 50.0f);

    // Engine run time in seconds.
    // Range of hobbs is 0 to 16777215.
    uint24ToBeBytes((uint32_t)(limitMax(_pg_user->hobbs, 16777215)), _pg_data, &_pg_byteindex);

    // Input voltage in Volts
    // Range of voltage is 0.0f to 25.5f.
    float32ScaledTo1UnsignedBytes(_pg_user->voltage, _pg_data, &_pg_byteindex, 0.0f, 10.0f);

    _pg_data[_pg_byteindex] = 0;

    // Operational mode of the governor
    _pg_data[_pg_byteindex] |= (uint8_t)_pg_user->governorMode;
    _pg_byteindex += 1; // close bit field

    // complete the process of creating the packet
    finishECUPacket(_pg_pkt, _pg_byteindex, getECU_TelemetrySlow1PacketID());

}// encodeECU_TelemetrySlow1PacketStructure

/*!
 * \brief Decode the ECU_TelemetrySlow1 packet
 *
 * The second of three slow telemetry packets
 * \param _pg_pkt points to the packet being decoded by this function
 * \param _pg_user receives the data decoded from the packet
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeECU_TelemetrySlow1PacketStructure(const void* _pg_pkt, ECU_TelemetrySlow1_t* _pg_user)
{
    int _pg_numbytes;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data;

    // Verify the packet identifier
    if(getECUPacketID(_pg_pkt) != getECU_TelemetrySlow1PacketID())
        return 0;

    // Verify the packet size
    _pg_numbytes = getECUPacketSize(_pg_pkt);
    if(_pg_numbytes < getECU_TelemetrySlow1MinDataLength())
        return 0;

    // The raw data from the packet
    _pg_data = getECUPacketDataConst(_pg_pkt);

    // Inlet air temperature in Celsius
    // Range of mat is -127.0f to 127.0f.
    _pg_user->mat = float32ScaledFrom1SignedBytes(_pg_data, &_pg_byteindex, 1.0f/1.0f);

    // Fuel pressure in kilo-Pascals
    // Range of fuelPressure is 0.0f to 1310.7f.
    _pg_user->fuelPressure = float32ScaledFrom2UnsignedBeBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/50.0f);

    // Engine run time in seconds.
    // Range of hobbs is 0 to 16777215.
    _pg_user->hobbs = (uint32_t)uint24FromBeBytes(_pg_data, &_pg_byteindex);

    // Input voltage in Volts
    // Range of voltage is 0.0f to 25.5f.
    _pg_user->voltage = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/10.0f);

    // Operational mode of the governor
    _pg_user->governorMode = (ECUGovernorMode)((_pg_data[_pg_byteindex]) & 0x7);
    _pg_byteindex += 1; // close bit field

    return 1;

}// decodeECU_TelemetrySlow1PacketStructure

/*!
 * \brief Create the ECU_TelemetrySlow2 packet
 *
 * The third of three slow telemetry packets
 * \param _pg_pkt points to the packet which will be created by this function
 * \param _pg_user points to the user data that will be encoded in _pg_pkt
 */
void encodeECU_TelemetrySlow2PacketStructure(void* _pg_pkt, const ECU_TelemetrySlow2_t* _pg_user)
{
    uint8_t* _pg_data = getECUPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    // CPU load in percent
    // Range of cpuLoad is 0.0f to 255.0f.
    float32ScaledTo1UnsignedBytes(_pg_user->cpuLoad, _pg_data, &_pg_byteindex, 0.0f, 1.0f);

    // Charge temperature in Celsius
    // Range of chargeTemp is -128.0f to 254.5f.
    float32ScaledTo1UnsignedBytes(_pg_user->chargeTemp, _pg_data, &_pg_byteindex, -128.0f, 0.666666667f);

    // Injector duty cycle in percent
    // Range of injectorDuty is 0.0f to 6553.5f.
    float32ScaledTo2UnsignedBeBytes(_pg_user->injectorDuty, _pg_data, &_pg_byteindex, 0.0f, 10.0f);

    // First ignition advance angle in degrees
    // Range of ignAngle1 is 0.0f to 127.5f.
    float32ScaledTo1UnsignedBytes(_pg_user->ignAngle1, _pg_data, &_pg_byteindex, 0.0f, 2.0f);

    // Second ignition advance angle in degrees
    // Range of ignAngle2 is 0.0f to 127.5f.
    float32ScaledTo1UnsignedBytes(_pg_user->ignAngle2, _pg_data, &_pg_byteindex, 0.0f, 2.0f);

    // Fuel flow rate in grams per minute
    // Range of flowRate is 0.0f to 1092.25f.
    float32ScaledTo2UnsignedBeBytes(_pg_user->flowRate, _pg_data, &_pg_byteindex, 0.0f, 60.0f);

    // complete the process of creating the packet
    finishECUPacket(_pg_pkt, _pg_byteindex, getECU_TelemetrySlow2PacketID());

}// encodeECU_TelemetrySlow2PacketStructure

/*!
 * \brief Decode the ECU_TelemetrySlow2 packet
 *
 * The third of three slow telemetry packets
 * \param _pg_pkt points to the packet being decoded by this function
 * \param _pg_user receives the data decoded from the packet
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeECU_TelemetrySlow2PacketStructure(const void* _pg_pkt, ECU_TelemetrySlow2_t* _pg_user)
{
    int _pg_numbytes;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data;

    // Verify the packet identifier
    if(getECUPacketID(_pg_pkt) != getECU_TelemetrySlow2PacketID())
        return 0;

    // Verify the packet size
    _pg_numbytes = getECUPacketSize(_pg_pkt);
    if(_pg_numbytes < getECU_TelemetrySlow2MinDataLength())
        return 0;

    // The raw data from the packet
    _pg_data = getECUPacketDataConst(_pg_pkt);

    // CPU load in percent
    // Range of cpuLoad is 0.0f to 255.0f.
    _pg_user->cpuLoad = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/1.0f);

    // Charge temperature in Celsius
    // Range of chargeTemp is -128.0f to 254.5f.
    _pg_user->chargeTemp = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, -128.0f, 1.0f/0.666666667f);

    // Injector duty cycle in percent
    // Range of injectorDuty is 0.0f to 6553.5f.
    _pg_user->injectorDuty = float32ScaledFrom2UnsignedBeBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/10.0f);

    // First ignition advance angle in degrees
    // Range of ignAngle1 is 0.0f to 127.5f.
    _pg_user->ignAngle1 = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/2.0f);

    // Second ignition advance angle in degrees
    // Range of ignAngle2 is 0.0f to 127.5f.
    _pg_user->ignAngle2 = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/2.0f);

    // Fuel flow rate in grams per minute
    // Range of flowRate is 0.0f to 1092.25f.
    _pg_user->flowRate = float32ScaledFrom2UnsignedBeBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/60.0f);

    return 1;

}// decodeECU_TelemetrySlow2PacketStructure

/*!
 * \brief Create the ECU_HardwareConfig packet
 *
 * The hardware config packet contains the ECU serial number and various ECU
 * configuration data. Send a zero length packet to request this data.
 * \param _pg_pkt points to the packet which will be created by this function
 * \param _pg_user points to the user data that will be encoded in _pg_pkt
 */
void encodeECU_HardwareConfigPacketStructure(void* _pg_pkt, const ECU_HardwareConfig_t* _pg_user)
{
    uint8_t* _pg_data = getECUPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    // ECU serial number
    // Range of serialNumber is 0 to 65535.
    uint16ToBeBytes(_pg_user->serialNumber, _pg_data, &_pg_byteindex);

    // Fuel used divisior. If the divisor is greater than 100 then it is interpreted as units of 0.01 (for a higher resolution fuel calibration)
    // Range of fuelDivisor is 0 to 65535.
    uint16ToBeBytes(_pg_user->fuelDivisor, _pg_data, &_pg_byteindex);

    _pg_data[_pg_byteindex] = 0;

    // Autronic relay state. This is a volatile status which will reset to AUT_RELAY_OFF on ECU power cycle.
    _pg_data[_pg_byteindex] |= (uint8_t)_pg_user->relayState << 1;

    // Set if the fuel used value is reset each on each ECU power cycle
    _pg_data[_pg_byteindex] |= (uint8_t)((_pg_user->resetFuelUsedOnStart == true) ? 1 : 0);
    _pg_byteindex += 1; // close bit field

    // complete the process of creating the packet
    finishECUPacket(_pg_pkt, _pg_byteindex, getECU_HardwareConfigPacketID());

}// encodeECU_HardwareConfigPacketStructure

/*!
 * \brief Decode the ECU_HardwareConfig packet
 *
 * The hardware config packet contains the ECU serial number and various ECU
 * configuration data. Send a zero length packet to request this data.
 * \param _pg_pkt points to the packet being decoded by this function
 * \param _pg_user receives the data decoded from the packet
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeECU_HardwareConfigPacketStructure(const void* _pg_pkt, ECU_HardwareConfig_t* _pg_user)
{
    int _pg_numbytes;
    int _pg_b