er and only operates when GPS quality permits. The third bit position controls where the corrections to the GPS reference datum are applied. Corrections can be applied to the local vertical position or to the reported EKF origin height (default).
    // @Bitmask: 0:Correct when using Baro height,1:Correct when using range finder height,2:Apply corrections to local position
    // @User: Advanced
    // @RebootRequired: True
    AP_GROUPINFO("OGN_HGT_MASK", 50, NavEKF3, _originHgtMode, 0),

    // @Param: VIS_VERR_MIN
    // @DisplayName: Visual odometry minimum velocity error
    // @Description: This is the 1-STD odometry velocity observation error that will be assumed when maximum quality is reported by the sensor. When quality is between max and min, the error will be calculated using linear interpolation between VIS_VERR_MIN and VIS_VERR_MAX.
    // @Range: 0.05 0.5
    // @Increment: 0.05
    // @User: Advanced
    // @Units: m/s
    AP_GROUPINFO("VIS_VERR_MIN", 51, NavEKF3, _visOdmVelErrMin, 0.1f),

    // @Param: VIS_VERR_MAX
    // @DisplayName: Visual odometry maximum velocity error
    // @Description: This is the 1-STD odometry velocity observation error that will be assumed when minimum quality is reported by the sensor. When quality is between max and min, the error will be calculated using linear interpolation between VIS_VERR_MIN and VIS_VERR_MAX.
    // @Range: 0.5 5.0
    // @Increment: 0.1
    // @User: Advanced
    // @Units: m/s
    AP_GROUPINFO("VIS_VERR_MAX", 52, NavEKF3, _visOdmVelErrMax, 0.9f),

    // @Param: WENC_VERR
    // @DisplayName: Wheel odometry velocity error
    // @Description: This is the 1-STD odometry velocity observation error that will be assumed when wheel encoder data is being fused.
    // @Range: 0.01 1.0
    // @Increment: 0.1
    // @User: Advanced
    // @Units: m/s
    AP_GROUPINFO("WENC_VERR", 53, NavEKF3, _wencOdmVelErr, 0.1f),

    // @Param: FLOW_USE
    // @DisplayName: Optical flow use bitmask
    // @Description: Controls if the optical flow data is fused into the 24-state navigation estimator OR the 1-state terrain height estimator.
    // @User: Advanced
    // @Values: 0:None,1:Navigation,2:Terrain
    // @RebootRequired: True
    AP_GROUPINFO("FLOW_USE", 54, NavEKF3, _flowUse, FLOW_USE_DEFAULT),

    // @Param: HRT_FILT
    // @DisplayName: Height rate filter crossover frequency
    // @Description: Specifies the crossover frequency of the complementary filter used to calculate the output predictor height rate derivative.
    // @Range: 0.1 30.0
    // @Units: Hz
    AP_GROUPINFO("HRT_FILT", 55, NavEKF3, _hrt_filt_freq, 2.0f),

    // @Param: MAG_EF_LIM
    // @DisplayName: EarthField error limit
    // @Description: This limits the difference between the learned earth magnetic field and the earth field from the world magnetic model tables. A value of zero means to disable the use of the WMM tables.
    // @User: Advanced
    // @Range: 0 500
    // @Units: mGauss
    AP_GROUPINFO("MAG_EF_LIM", 56, NavEKF3, _mag_ef_limit, 50),

    // @Param: GSF_RUN_MASK
    // @DisplayName: Bitmask of which EKF-GSF yaw estimators run
    // @Description: 1 byte bitmap of which EKF3 instances run an independant EKF-GSF yaw estimator to provide a backup yaw estimate that doesn't rely on magnetometer data. This estimator uses IMU, GPS and, if available, airspeed data. EKF-GSF yaw estimator data for the primary EKF3 instance will be logged as GSF0 and GSF1 messages. Use of the yaw estimate generated by this algorithm is controlled by the EK3_GSF_USE_MASK and EK3_GSF_RST_MAX parameters. To run the EKF-GSF yaw estimator in ride-along and logging only, set EK3_GSF_USE to 0. 
    // @Bitmask: 0:FirstEKF,1:SecondEKF,2:ThirdEKF,3:FourthEKF,4:FifthEKF,5:SixthEKF
    // @User: Advanced
    // @RebootRequired: True
    AP_GROUPINFO("GSF_RUN_MASK", 57, NavEKF3, _gsfRunMask, 3),

    // @Param: GSF_USE_MASK
    // @DisplayName: Bitmask of which EKF-GSF yaw estimators are used
    // @Description: A bitmask of which EKF3 instances will use the output from the EKF-GSF yaw estimator that has been turned on by the EK3_GSF_RUN_MASK parameter. If the inertial navigation calculation stops following the GPS, then the vehicle code can request EKF3 to attempt to resolve the issue, either by performing a yaw reset if enabled by this parameter by switching to another EKF3 instance.
    // @Bitmask: 0:FirstEKF,1:SecondEKF,2:ThirdEKF,3:FourthEKF,4:FifthEKF,5:SixthEKF
    // @User: Advanced
    // @RebootRequired: True
    AP_GROUPINFO("GSF_USE_MASK", 58, NavEKF3, _gsfUseMask, 3),

    // 59 was GSF_DELAY which was never released in a stable version

    // @Param: GSF_RST_MAX
    // @DisplayName: Maximum number of resets to the EKF-GSF yaw estimate allowed
    // @Description: Sets the maximum number of times the EKF3 will be allowed to reset its yaw to the estimate from the EKF-GSF yaw estimator. No resets will be allowed unless the use of the EKF-GSF yaw estimate is enabled via the EK3_GSF_USE_MASK parameter.
    // @Range: 1 10
    // @Increment: 1
    // @User: Advanced
    // @RebootRequired: True
    AP_GROUPINFO("GSF_RST_MAX", 60, NavEKF3, _gsfResetMaxCount, 2),

    // @Param: ERR_THRESH
    // @DisplayName: EKF3 Lane Relative Error Sensitivity Threshold
    // @Description: lanes have to be consistently better than the primary by at least this threshold to reduce their overall relativeCoreError, lowering this makes lane switching more sensitive to smaller error differences
    // @Range: 0.05 1
    // @Increment: 0.05
    // @User: Advanced
    AP_GROUPINFO("ERR_THRESH", 61, NavEKF3, _err_thresh, 0.2),

    // @Param: AFFINITY
    // @DisplayName: EKF3 Sensor Affinity Options
    // @Description: These options control the affinity between sensor instances and EKF cores
    // @User: Advanced
    // @Bitmask: 0:EnableGPSAffinity,1:EnableBaroAffinity,2:EnableCompassAffinity,3:EnableAirspeedAffinity
    // @RebootRequired: True

    AP_GROUPINFO("AFFINITY", 62, NavEKF3, _affinity, 0),

    AP_SUBGROUPEXTENSION("", 63, NavEKF3, var_info2),

    AP_GROUPEND
};

// second table of parameters. allows us to go beyond the 64 parameter limit
const AP_Param::GroupInfo NavEKF3::var_info2[] = {

    // @Group: SRC
    // @Path: ../AP_NavEKF/AP_NavEKF_Source.cpp
    AP_SUBGROUPINFO(sources, "SRC", 1, NavEKF3, AP_NavEKF_Source),

    // @Param: DRAG_BCOEF_X
    // @DisplayName: Ballistic coefficient for X axis drag
    // @Description: Ratio of mass to drag coefficient measured along the X body axis. This parameter enables estimation of wind drift for vehicles with bluff bodies and without propulsion forces in the X and Y direction (eg multicopters). The drag produced by this effect scales with speed squared.  Set to a postive value > 1.0 to enable. A starting value is the mass in Kg divided by the frontal area. The predicted drag from the rotors is specified separately by the EK3_DRAG_MCOEF parameter.
    // @Range: 0.0 1000.0
    // @Units: kg/m/m
    // @User: Advanced
    AP_GROUPINFO("DRAG_BCOEF_X", 2, NavEKF3, _ballisticCoef_x, 0.0f),

    // @Param: DRAG_BCOEF_Y
    // @DisplayName: Ballistic coefficient for Y axis drag
    // @Description: Ratio of mass to drag coefficient measured along the Y body axis. This parameter enables estimation of wind drift for vehicles with bluff bodies and without propulsion forces in the X and Y direction (eg multicopters). The drag produced by this effect scales with speed squared.  Set to a postive value > 1.0 to enable. A starting value is the mass in Kg divided by the side area. The predicted drag from the rotors is specified separately by the EK3_DRAG_MCOEF parameter.
    // @Range: 50.0 1000.0
    // @Units: kg/m/m
    // @User: Advanced
    AP_GROUPINFO("DRAG_BCOEF_Y", 3, NavEKF3, _ballisticCoef_y, 0.0f),

    // @Param: DRAG_M_NSE
    // @DisplayName: Observation noise for drag acceleration
    // @Description: This sets the amount of noise used when fusing X and Y acceleration as an observation that enables esitmation of wind velocity for multi-rotor vehicles. This feature is enabled by the EK3_DRAG_BCOEF_X and EK3_DRAG_BCOEF_Y parameters
    // @Range: 0.1 2.0
    // @Increment: 0.1
    // @User: Advanced
    // @Units: m/s/s
    AP_GROUPINFO("DRAG_M_NSE", 4, NavEKF3, _dragObsNoise, 0.5f),

    // @Param: DRAG_MCOEF
    // @DisplayName: Momentum coefficient for propeller drag
    // @Description: This parameter is used to predict the drag produced by the rotors when flying a multi-copter, enabling estimation of wind drift. The drag produced by this effect scales with speed not speed squared and is produced because some of the air velocity normal to the rotors axis of rotation is lost when passing through the rotor disc which changes the momentum of the airflow causing drag. For unducted rotors the effect is roughly proportional to the area of the propeller blades when viewed side on and changes with different propellers. It is higher for ducted rotors. For example if flying at 15 m/s at sea level conditions produces a rotor induced drag acceleration of 1.5 m/s/s, then EK3_DRAG_MCOEF would be set to 0.1 = (1.5/15.0). Set EK3_MCOEF to a postive value to enable wind estimation using this drag effect. To account for the drag produced by the body which scales with speed squared, see documentation for the EK3_DRAG_BCOEF_X and EK3_DRAG_BCOEF_Y parameters.
    // @Range: 0.0 1.0
    // @Increment: 0.01
    // @Units: 1/s
    // @User: Advanced
    AP_GROUPINFO("DRAG_MCOEF", 5, NavEKF3, _momentumDragCoef, 0.0f),

    // @Param: OGNM_TEST_SF
    // @DisplayName: On ground not moving test scale factor
    // @Description: This parameter is adjust the sensitivity of the on ground not moving test which is used to assist with learning the yaw gyro bias and stopping yaw drift before flight when operating without a yaw sensor. Bigger values allow the detection of a not moving condition with noiser IMU data. Check the XKFM data logged when the vehicle is on ground not moving and adjust the value of OGNM_TEST_SF to be slightly higher than the maximum value of the XKFM.ADR, XKFM.ALR, XKFM.GDR and XKFM.GLR test levels.
    // @Range: 1.0 10.0
    // @Increment: 0.5
    // @User: Advanced
    AP_GROUPINFO("OGNM_TEST_SF", 6, NavEKF3, _ognmTestScaleFactor, 2.0f),

    // @Param: GND_EFF_DZ
    // @DisplayName: Baro height ground effect dead zone
    // @Description: This parameter sets the size of the dead zone that is applied to negative baro height spikes that can occur when taking off or landing when a vehicle with lift rotors is operating in ground effect ground effect. Set to about 0.5m less than the amount of negative offset in baro height that occurs just prior to takeoff when lift motors are spooling up. Set to 0 if no ground effect is present.
    // @Range: 0.0 10.0
    // @Increment: 0.5
    // @User: Advanced
    AP_GROUPINFO("GND_EFF_DZ", 7, NavEKF3, _baroGndEffectDeadZone, 4.0f),

    // @Param: PRIMARY
    // @DisplayName: Primary core number
    // @Description: The core number (index in IMU mask) that will be used as the primary EKF core on startup. While disarmed the EKF will force the use of this core. A value of 0 corresponds to the first IMU in EK3_IMU_MASK.
    // @Range: 0 2
    // @Increment: 1
    // @User: Advanced
    AP_GROUPINFO("PRIMARY", 8, NavEKF3, _primary_core, EK3_PRIMARY_DEFAULT),

    // @Param: LOG_LEVEL
    // @DisplayName: Logging Level
    // @Description: Determines how verbose the EKF3 streaming logging is. A value of 0 provides full logging(default), a value of 1 only XKF4 scaled innovations are logged, a value of 2 both XKF4 and GSF are logged, and a value of 3 disables all streaming logging of EKF3.
    // @Range: 0 3
    // @Increment: 1
    // @User: Advanced
    AP_GROUPINFO("LOG_LEVEL", 9, NavEKF3, _log_level, 0),
    
    // @Param: GPS_VACC_MAX
    // @DisplayName: GPS vertical accuracy threshold
    // @Description: Vertical accuracy threshold for GPS as the altitude source. The GPS will not be used as an altitude source if the reported vertical accuracy of the GPS is larger than this threshold, falling back to baro instead. Set to zero to deactivate the threshold check.
    // @Range: 0.0 10.0
    // @Increment: 0.1
    // @User: Advanced
    // @Units: m
    AP_GROUPINFO("GPS_VACC_MAX", 10, NavEKF3, _gpsVAccThreshold, 0.0f),

    // @Param: OPTIONS
    // @DisplayName: Optional EKF behaviour
    // @Description: This controls optional EKF behaviour. Setting JammingExpected will change the EKF nehaviour such that if dead reckoning navigation is possible it will require the preflight alignment GPS quality checks controlled by EK3_GPS_CHECK and EK3_CHECK_SCALE to pass before resuming GPS use if GPS lock is lost for more than 2 seconds to prevent bad
    // @Bitmask: 0:JammingExpected
    // @User: Advanced
    AP_GROUPINFO("OPTIONS",  11, NavEKF3, _options, 0),

    AP_GROUPEND
};

NavEKF3::NavEKF3()
{
    AP_Param::setup_object_defaults(this, var_info);
    AP_Param::setup_object_defaults(this, var_info2);
}


// Initialise the filter
bool NavEKF3::InitialiseFilter(void)
{
    if (_enable == 0 || _imuMask == 0) {
        return false;
    }
    const auto &ins = AP::dal().ins();

    AP::dal().start_frame(AP_DAL::FrameType::InitialiseFilterEKF3);

    imuSampleTime_us = AP::dal().micros64();

    // remember expected frame time
    const float loop_rate = ins.get_loop_rate_hz();
    if (!is_positive(loop_rate)) {
        return false;
    }
    _frameTimeUsec = 1e6 / loop_rate;

    // expected number of IMU frames per prediction
    _framesPerPrediction = uint8_t((EKF_TARGET_DT / (_frameTimeUsec * 1.0e-6) + 0.5));

#if !APM_BUILD_TYPE(APM_BUILD_AP_DAL_Standalone)
    // convert parameters if necessary
    convert_parameters();
#endif

#if APM_BUILD_TYPE(APM_BUILD_Replay)
    if (ins.get_accel_count() == 0) {
        return false;
    }
#endif

    if (core == nullptr) {

        // don't run multiple filters for 1 IMU
        uint8_t mask = (1U<<ins.get_accel_count())-1;
        _imuMask.set_and_default(_imuMask.get() & mask);
        
        // initialise the setup variables
        for (uint8_t i=0; i<MAX_EKF_CORES; i++) {
            coreSetupRequired[i] = false;
            coreImuIndex[i] = 0;
        }
        num_cores = 0;

        // count IMUs from mask
        for (uint8_t i=0; i<INS_MAX_INSTANCES; i++) {
            if (_imuMask & (1U<<i)) {
                coreSetupRequired[num_cores] = true;
                coreImuIndex[num_cores] = i;
                num_cores++;
            }
        }

        // check if there is enough memory to create the EKF cores
        if (AP::dal().available_memory() < sizeof(NavEKF3_core)*num_cores + 4096) {
            GCS_SEND_TEXT(MAV_SEVERITY_CRITICAL, "EKF3 not enough memory");
            _enable.set(0);
            num_cores = 0;
            return false;
        }

        //try to allocate from CCM RAM, fallback to Normal RAM if not available or full
        core = (NavEKF3_core*)AP::dal().malloc_type(sizeof(NavEKF3_core)*num_cores, AP::dal().MEM_FAST);
        if (core == nullptr) {
            _enable.set(0);
            num_cores = 0;
            GCS_SEND_TEXT(MAV_SEVERITY_CRITICAL, "EKF3 allocation failed");
            return false;
        }

        // Call constructors on all cores
        for (uint8_t i = 0; i < num_cores; i++) {
            new (&core[i]) NavEKF3_core(this);
        }
    }

    // Set up any cores that have been created
    // This specifies the IMU to be used and creates the data buffers
    // If we are unable to set up a core, return false and try again next time the function is called
    bool core_setup_success = true;
    for (uint8_t core_index=0; core_index<num_cores; core_index++) {
        if (coreSetupRequired[core_index]) {
            coreSetupRequired[core_index] = !core[core_index].setup_core(coreImuIndex[core_index], core_index);
            if (coreSetupRequired[core_index]) {
                core_setup_success = false;
            }
        }
    }
    // exit with failure if any cores could not be setup
    if (!core_setup_success) {
        return false;
    }

    // set relative error scores for all cores to 0
    resetCoreErrors();

    // Set the primary initially to be users selected primary
    primary = uint8_t(_primary_core) < num_cores? _primary_core : 0;

    // invalidate shared origin
    common_origin_valid = false;

    // initialise the cores. We return success only if all cores
    // initialise successfully
    bool ret = true;
    for (uint8_t i=0; i<num_cores; i++) {
        ret &= core[i].InitialiseFilterBootstrap();
    }

    // set last time the cores were primary to 0
    memset(coreLastTimePrimary_us, 0, sizeof(coreLastTimePrimary_us));

    // zero the structs used capture reset events
    memset(&yaw_reset_data, 0, sizeof(yaw_reset_data));
    memset((void *)&pos_reset_data, 0, sizeof(pos_reset_data));
    memset(&pos_down_reset_data, 0, sizeof(pos_down_reset_data));

    return ret;
}

/*
  return true if a new core index has a better score than the current
  core
 */
bool NavEKF3::coreBetterScore(uint8_t new_core, uint8_t current_core) const
{
    const NavEKF3_core &oldCore = core[current_core];
    const NavEKF3_core &newCore = core[new_core];
    if (!newCore.healthy()) {
        // never consider a new core that isn't healthy
        return false;
    }
    if (newCore.have_aligned_tilt() != oldCore.have_aligned_tilt()) {
        // tilt alignment is most critical, if one is tilt aligned and
        // the other isn't then use the tilt aligned lane
        return newCore.have_aligned_tilt();
    }
    if (newCore.have_aligned_yaw() != oldCore.have_aligned_yaw()) {
        // yaw alignment is next most critical, if one is yaw aligned
        // and the other isn't then use the yaw aligned lane
        return newCore.have_aligned_yaw();
    }
    // if both cores are aligned then look at relative error scores
    return coreRelativeErrors[new_core] < coreRelativeErrors[current_core];
}

/* 
  Update Filter States - this should be called whenever new IMU data is available
  Execution speed governed by SCHED_LOOP_RATE
*/
void NavEKF3::UpdateFilter(void)
{
    AP::dal().start_frame(AP_DAL::FrameType::UpdateFilterEKF3);

    if (!core) {
        return;
    }

    imuSampleTime_us = AP::dal().micros64();

    for (uint8_t i=0; i<num_cores; i++) {
        // if we have not overrun by more than 3 IMU frames, and we
        // have already used more than 1/3 of the CPU budget for this
        // loop then suppress the prediction step. This allows
        // multiple EKF instances to cooperate on scheduling
        bool allow_state_prediction = true;
        if (core[i].getFramesSincePredict() < (_framesPerPrediction+3) &&
            AP::dal().ekf_low_time_remaining(AP_DAL::EKFType::EKF3, i)) {
            allow_state_prediction = false;
        }
        core[i].UpdateFilter(allow_state_prediction);
    }

    // If the current core selected has a bad error score or is unhealthy, switch to a healthy core with the lowest fault score
    // Don't start running the check until the primary core has started returned healthy for at least 10 seconds to avoid switching
    // due to initial alignment fluctuations and race conditions
    if (!runCoreSelection) {
        static uint64_t lastUnhealthyTime_us = 0;
        if (!core[primary].healthy() || lastUnhealthyTime_us == 0) {
            lastUnhealthyTime_us = imuSampleTime_us;
        }
        runCoreSelection = (imuSampleTime_us - lastUnhealthyTime_us) > 1E7;
    }

    const bool armed  = AP::dal().get_armed();

    // core selection is only available after the vehicle is armed, else forced to lane 0 if its healthy
    if (runCoreSelection && armed) {
        // update this instance's error scores for all active cores and get the primary core's error score
        float primaryErrorScore = updateCoreErrorScores();

        // update the accumulated relative error scores for all active cores
        updateCoreRelativeErrors();

        bool betterCore = false;
        bool altCoreAvailable = false;
        uint8_t newPrimaryIndex = primary;

        // loop through all available cores to find if an alternative core is available
        for (uint8_t coreIndex=0; coreIndex<num_cores; coreIndex++) {
            if (coreIndex != primary) {
                float altCoreError = coreRelativeErrors[coreIndex];

                // an alternative core is available for selection based on 2 conditions -
                // 1. healthy and states have been updated on this time step
                // 2. has relative error less than primary core error
                // 3. not been the primary core for at least 10 seconds
                altCoreAvailable = coreBetterScore(coreIndex, newPrimaryIndex) &&
                    imuSampleTime_us - coreLastTimePrimary_us[coreIndex] > 1E7;

                if (altCoreAvailable) {
                    // if this core has a significantly lower relative error to the active primary, we consider it as a 
                    // better core and would like to switch to it even if the current primary is healthy
                    betterCore = altCoreError <= -BETTER_THRESH; // a better core if its relative error is below a substantial level than the primary's
                    // handle the case where the secondary core is faster to complete yaw alignment which can happen
                    // in flight when oeprating without a magnetomer
                    const NavEKF3_core &newCore = core[coreIndex];
                    const NavEKF3_core &oldCore = core[primary];
                    betterCore |= newCore.have_aligned_yaw() && !oldCore.have_aligned_yaw();
                    newPrimaryIndex = coreIndex;
                }
            }
        }
        altCoreAvailable = newPrimaryIndex != primary;

        // Switch cores if another core is available and the active primary core meets one of the following conditions - 
        // 1. has a bad error score
        // 2. is unhealthy
        // 3. is healthy, but a better core is available
        // also update the yaw and position reset data to capture changes due to the lane switch
        if (altCoreAvailable && (primaryErrorScore > 1.0f || !core[primary].healthy() || betterCore)) {
            updateLaneSwitchYawResetData(newPrimaryIndex, primary);
            updateLaneSwitchPosResetData(newPrimaryIndex, primary);
            updateLaneSwitchPosDownResetData(newPrimaryIndex, primary);
            resetCoreErrors();
            coreLastTimePrimary_us[primary] = imuSampleTime_us;
            primary = newPrimaryIndex;
            lastLaneSwitch_ms = AP::dal().millis();
            GCS_SEND_TEXT(MAV_SEVERITY_CRITICAL, "EKF3 lane switch %u", primary);
        }       
    }

    const uint8_t user_primary = uint8_t(_primary_core) < num_cores? _primary_core : 0;
    if (primary != user_primary && core[user_primary].healthy() && !armed) {
        // when on the ground and disarmed force the selected primary
        // core. This avoids us ending with with a lottery for which
        // IMU is used in each flight. Otherwise the alignment of the
        // timing of the core selection updates with the timing of GPS
        // updates can lead to a core other than the first one being
        // used as primary for some flights. As different IMUs may
        // have quite different noise characteristics this leads to
        // inconsistent performance
        primary = user_primary;
    }

    // align position of inactive sources to ahrs
    sources.align_inactive_sources();
}

/*
  check if switching lanes will reduce the normalised
  innovations. This is called when the vehicle code is about to
  trigger an EKF failsafe, and it would like to avoid that by
  using a different EKF lane
*/
void NavEKF3::checkLaneSwitch(void)
{
    AP::dal().log_event3(AP_DAL::Event::checkLaneSwitch);

    uint32_t now = AP::dal().millis();
    if (lastLaneSwitch_ms != 0 && now - lastLaneSwitch_ms < 5000) {
        // don't switch twice in 5 seconds
        return;
    }

    float primaryErrorScore = core[primary].errorScore();
    float lowestErrorScore = primaryErrorScore;
    uint8_t newPrimaryIndex = primary;
    for (uint8_t coreIndex=0; coreIndex<num_cores; coreIndex++) {
        if (coreIndex != primary) {
            const NavEKF3_core &newCore = core[coreIndex];
            // an alternative core is available for selection only if healthy and if states have been updated on this time step
            bool altCoreAvailable = newCore.healthy() && newCore.have_aligned_yaw() && newCore.have_aligned_tilt();
            float altErrorScore = newCore.errorScore();
            if (altCoreAvailable && altErrorScore < lowestErrorScore && altErrorScore < 0.9) {
                newPrimaryIndex = coreIndex;
                lowestErrorScore = altErrorScore;
            }
        }
    }

    // update the yaw and position reset data to capture changes due to the lane switch
    if (newPrimaryIndex != primary) {
        updateLaneSwitchYawResetData(newPrimaryIndex, primary);
        updateLaneSwitchPosResetData(newPrimaryIndex, primary);
        updateLaneSwitchPosDownResetData(newPrimaryIndex, primary);
        primary = newPrimaryIndex;
        lastLaneSwitch_ms = now;
        GCS_SEND_TEXT(MAV_SEVERITY_CRITICAL, "EKF3 lane switch %u", primary);
    }
}

void NavEKF3::requestYawReset(void)
{
    AP::dal().log_event3(AP_DAL::Event::requestYawReset);

    for (uint8_t i = 0; i < num_cores; i++) {
        core[i].EKFGSF_requestYawReset();
    }
}

/*
  Update this instance error score value for all active cores
*/
float NavEKF3::updateCoreErrorScores()
{
    for (uint8_t i = 0; i < num_cores; i++) {
        coreErrorScores[i] = core[i].errorScore();
    }
    return coreErrorScores[primary];
}

/*
  Update the relative error for all alternate available cores with respect to primary core's error.
  A positive relative error for a core means it has been more erroneous than the existing primary.
  A negative relative error indicates a core which can be switched to.
*/
void NavEKF3::updateCoreRelativeErrors()
{
    float error = 0;
    for (uint8_t i = 0; i < num_cores; i++) {
        if (i != primary) {
            error = coreErrorScores[i] - coreErrorScores[primary];
            // reduce error for a core only if its better than the primary lane by at least the Relative Error Threshold, this should prevent unnecessary lane changes
            if (error > 0 || error < -MAX(_err_thresh, 0.05)) {
                coreRelativeErrors[i] += error;
                coreRelativeErrors[i] = constrain_ftype(coreRelativeErrors[i], -CORE_ERR_LIM, CORE_ERR_LIM);
            }
        }
    }
}

// Reset the relative error values
void NavEKF3::resetCoreErrors(void)
{
    for (uint8_t i = 0; i < num_cores; i++) {
        coreRelativeErrors[i] = 0;
    }
}

// set position, velocity and yaw sources to either 0=primary, 1=secondary, 2=tertiary
void NavEKF3::setPosVelYawSourceSet(uint8_t source_set_idx)
{
    if (source_set_idx < AP_NAKEKF_SOURCE_SET_MAX) {
        AP::dal().log_event3(AP_DAL::Event(uint8_t(AP_DAL::Event::setSourceSet0)+source_set_idx));
    }
    sources.setPosVelYawSourceSet(source_set_idx);
}

// Check basic filter health metrics and return a consolidated health status
bool NavEKF3::healthy(void) const
{
    if (!core) {
        return false;
    }
    return core[primary].healthy();
}

// returns false if we fail arming checks, in which case the buffer will be populated with a failure message
// requires_position should be true if horizontal position configuration should be checked
bool NavEKF3::pre_arm_check(bool requires_position, char *failure_msg, uint8_t failure_msg_len) const
{
    // check source configuration
    if (!sources.pre_arm_check(requires_position, failure_msg, failure_msg_len)) {
        return false;
    }

    // check if using compass (i.e. EK3_SRCn_YAW) with deprecated MAG_CAL values (5 was EXTERNAL_YAW, 6 was EXTERNAL_YAW_FALLBACK)
    const int8_t magCalParamVal = _magCal.get();
    const AP_NavEKF_Source::SourceYaw yaw_source = sources.getYawSource();
    if (((magCalParamVal == 5) || (magCalParamVal == 6)) && (yaw_source != AP_NavEKF_Source::SourceYaw::GPS)) {
        // yaw source is configured to use compass but MAG_CAL valid is deprecated
        AP::dal().snprintf(failure_msg, failure_msg_len, "EK3_MAG_CAL and EK3_SRC1_YAW inconsistent");
        return false;
    }

    if (!core) {
        AP::dal().snprintf(failure_msg, failure_msg_len, "no EKF3 cores");
        return false;
    }
    for (uint8_t i = 0; i < num_cores; i++) {
        if (!core[i].healthy()) {
            const char *failure = core[i].prearm_failure_reason();
            if (failure != nullptr) {
                AP::dal().snprintf(failure_msg, failure_msg_len, failure);
            } else {
                AP::dal().snprintf(failure_msg, failure_msg_len, "EKF3 core %d unhealthy", (int)i);
            }
            return false;
        }
    }
    return true;
}

// returns the index of the primary core
// return -1 if no primary core selected
int8_t NavEKF3::getPrimaryCoreIndex(void) const
{
    if (!core) {
        return -1;
    }
    return primary;
}

// returns the index of the IMU of the primary core
// return -1 if no primary core selected
int8_t NavEKF3::getPrimaryCoreIMUIndex(void) const
{
    if (!core) {
        return -1;
    }
    return core[primary].getIMUIndex();
}

// Write the last calculated NE position relative to the reference point (m).
// If a calculated solution is not available, use the best available data and return false
// If false returned, do not use for flight control
bool NavEKF3::getPosNE(Vector2f &posNE) const
{
    if (!core) {
        return false;
    }
    return core[primary].getPosNE(posNE);
}

// Write the last calculated D position relative to the reference point (m).
// If a calculated solution is not available, use the best available data and return false
// If false returned, do not use for flight control
bool NavEKF3::getPosD(float &posD) const
{
    if (!core) {
        return false;
    }
    return core[primary].getPosD(posD);
}

// return NED velocity in m/s
void NavEKF3::getVelNED(Vector3f &vel) const
{
    if (core) {
        core[primary].getVelNED(vel);
    }
}

// return estimate of true airspeed vector in body frame in m/s
// returns false if estimate is unavailable
bool NavEKF3::getAirSpdVec(Vector3f &vel) const
{
    if (core) {
        return core[primary].getAirSpdVec(vel);
    }
    return false;
}

// return the innovation in m/s, innovation variance in (m/s)^2 and age in msec of the last TAS measurement processed
bool NavEKF3::getAirSpdHealthData(float &innovation, float &innovationVariance, uint32_t &age_ms) const
{
    if (core) {
        return core[primary].getAirSpdHealthData(innovation, innovationVariance, age_ms);
    }
    return false;
}

// Return the rate of change of vertical position in the down direction (dPosD/dt) in m/s
float NavEKF3::getPosDownDerivative() const
{
    // return the value calculated from a complementary filter applied to the EKF height and vertical acceleration
    if (core) {
        return core[primary].getPosDownDerivative();
    }
    return 0.0f;
}

// return body axis gyro bias estimates in rad/sec
void NavEKF3::getGyroBias(int8_t instance, Vector3f &gyroBias) const
{
    if (instance < 0 || instance >= num_cores) instance = primary;
    if (core) {
        core[instance].getGyroBias(gyroBias);
    }
}

// return accelerometer bias estimate in m/s/s
void NavEKF3::getAccelBias(int8_t instance, Vector3f &accelBias) const
{
    if (instance < 0 || instance >= num_cores) instance = primary;
    if (core) {
        core[instance].getAccelBias(accelBias);
    }
}

// returns active source set used by EKF3
uint8_t NavEKF3::get_active_source_set() const
{
    return sources.get_active_source_set();
}

// reset body axis gyro bias estimates
void NavEKF3::resetGyroBias(void)
{
    AP::dal().log_event3(AP_DAL::Event::resetGyroBias);

    if (core) {
        for (uint8_t i=0; i<num_cores; i++) {
            core[i].resetGyroBias();
        }
    }
}

// Resets the baro so that it reads zero at the current height
// Resets the EKF height to zero
// Adjusts the EKF origin height so that the EKF height + origin height is the same as before
// Returns true if the height datum reset has been performed
// If using a range finder for height no reset is performed and it returns false
bool NavEKF3::resetHeightDatum(void)
{
    AP::dal().log_event3(AP_DAL::Event::resetHeightDatum);

    bool status = true;
    if (core) {
        for (uint8_t i=0; #include <AP_HAL/AP_HAL.h>

#include "AP_NavEKF3.h"
#include "AP_NavEKF3_core.h"

#include <GCS_MAVLink/GCS.h>
#include <AP_DAL/AP_DAL.h>

// minimum GPS horizontal speed required to use GPS ground course for yaw alignment (m/s)
#if APM_BUILD_TYPE(APM_BUILD_ArduPlane)
  #define GPS_VEL_YAW_ALIGN_MIN_SPD 5.0F
#else
  #define GPS_VEL_YAW_ALIGN_MIN_SPD 1.0F
#endif

/********************************************************
*                   RESET FUNCTIONS                     *
********************************************************/

// Control reset of yaw and magnetic field states
void NavEKF3_core::controlMagYawReset()
{

    // Vehicles that can use a zero sideslip assumption (Planes) are a special case
    // They can use the GPS velocity to recover from bad initial compass data
    // This allows recovery for heading alignment errors due to compass faults
    if (assume_zero_sideslip() && (!finalInflightYawInit || !yawAlignComplete) && inFlight) {
        gpsYawResetRequest = true;
        return;
    } else {
        gpsYawResetRequest = false;
    }

    // Quaternion and delta rotation vector that are re-used for different calculations
    Vector3F deltaRotVecTemp;
    QuaternionF deltaQuatTemp;

    bool flightResetAllowed = false;
    bool initialResetAllowed = false;
    if (!finalInflightYawInit) {
        // Use a quaternion division to calculate the delta quaternion between the rotation at the current and last time
        deltaQuatTemp = stateStruct.quat / prevQuatMagReset;
        prevQuatMagReset = stateStruct.quat;

        // convert the quaternion to a rotation vector and find its length
        deltaQuatTemp.to_axis_angle(deltaRotVecTemp);

        // check if the spin rate is OK - high spin rates can cause angular alignment errors
        bool angRateOK = deltaRotVecTemp.length() < 0.1745f;

        initialResetAllowed = angRateOK && tiltAlignComplete;
        flightResetAllowed = angRateOK && !onGround;

    }

    // reset the limit on the number of magnetic anomaly resets for each takeoff
    if (onGround) {
        magYawAnomallyCount = 0;
    }

    // Check if conditions for a interim or final yaw/mag reset are met
    bool finalResetRequest = false;
    bool interimResetRequest = false;
    if (flightResetAllowed && !assume_zero_sideslip()) {
#if APM_BUILD_TYPE(APM_BUILD_ArduSub)
        // for sub, we'd like to be far enough away from metal structures like docks and vessels
        // diving 0.5m is reasonable for both open water and pools
        finalResetRequest = (stateStruct.position.z  - posDownAtTakeoff) > EKF3_MAG_FINAL_RESET_ALT_SUB;
#else
        // check that we have reached a height where ground magnetic interference effects are insignificant
        // and can perform a final reset of the yaw and field states
        finalResetRequest = (stateStruct.position.z  - posDownAtTakeoff) < -EKF3_MAG_FINAL_RESET_ALT;
#endif

        // check for increasing height
        bool hgtIncreasing = (posDownAtLastMagReset-stateStruct.position.z) > 0.5f;
        ftype yawInnovIncrease = fabsF(innovYaw) - fabsF(yawInnovAtLastMagReset);

        // check for increasing yaw innovations
        bool yawInnovIncreasing = yawInnovIncrease > 0.25f;

        // check that the yaw innovations haven't been caused by a large change in attitude
        deltaQuatTemp = quatAtLastMagReset / stateStruct.quat;
        deltaQuatTemp.to_axis_angle(deltaRotVecTemp);
        bool largeAngleChange = deltaRotVecTemp.length() > yawInnovIncrease;

        // if yaw innovations and height have increased and we haven't rotated much
        // then we are climbing away from a ground based magnetic anomaly and need to reset
        interimResetRequest = !finalInflightYawInit
                                && !finalResetRequest
                                && (magYawAnomallyCount < MAG_ANOMALY_RESET_MAX)
                                && hgtIncreasing
                                && yawInnovIncreasing
                                && !largeAngleChange;
    }

    // an initial reset is required if we have not yet aligned the yaw angle
    bool initialResetRequest = initialResetAllowed && !yawAlignComplete;

    // a combined yaw angle and magnetic field reset can be initiated by:
    magYawResetRequest = magYawResetRequest || // an external request
            initialResetRequest || // an initial alignment performed by all vehicle types using magnetometer
            interimResetRequest || // an interim alignment required to recover from ground based magnetic anomaly
            finalResetRequest; // the final reset when we have achieved enough height to be in stable magnetic field environment

    // Perform a reset of magnetic field states and reset yaw to corrected magnetic heading
    if (magYawResetRequest && use_compass()) {
        // send initial alignment status to console
        if (!yawAlignComplete) {
            GCS_SEND_TEXT(MAV_SEVERITY_INFO, "EKF3 IMU%u MAG%u initial yaw alignment complete",(unsigned)imu_index, (unsigned)magSelectIndex);
        }

        // set yaw from a single mag sample
        setYawFromMag();

        // send in-flight yaw alignment status to console
        if (finalResetRequest) {
            GCS_SEND_TEXT(MAV_SEVERITY_INFO, "EKF3 IMU%u MAG%u in-flight yaw alignment complete",(unsigned)imu_index, (unsigned)magSelectIndex);
        } else if (interimResetRequest) {
            magYawAnomallyCount++;
            GCS_SEND_TEXT(MAV_SEVERITY_WARNING, "EKF3 IMU%u MAG%u ground mag anomaly, yaw re-aligned",(unsigned)imu_index, (unsigned)magSelectIndex);
        }

        // clear the complete flags if an interim reset has been performed to allow subsequent
        // and final reset to occur
        if (interimResetRequest) {
            finalInflightYawInit = false;
            finalInflightMagInit = false;
        }

        // mag states
        if (!magFieldLearned) {
            resetMagFieldStates();
        }
    }

    if (magStateResetRequest) {
        resetMagFieldStates();
    }
}

// this function is used to do a forced re-alignment of the yaw angle to align with the horizontal velocity
// vector from GPS. It is used to align the yaw angle after launch or takeoff.
void NavEKF3_core::realignYawGPS(bool emergency_reset)
{
    // get quaternion from existing filter states and calculate roll, pitch and yaw angles
    Vector3F eulerAngles;
    stateStruct.quat.to_euler(eulerAngles.x, eulerAngles.y, eulerAngles.z);

    if (gpsDataDelayed.vel.xy().length_squared() > sq(GPS_VEL_YAW_ALIGN_MIN_SPD)) {
        // calculate course yaw angle
        ftype velYaw = atan2F(stateStruct.velocity.y,stateStruct.velocity.x);

        // calculate course yaw angle from GPS velocity
        ftype gpsYaw = atan2F(gpsDataDelayed.vel.y,gpsDataDelayed.vel.x);

        // Check the yaw angles for consistency
        ftype yawErr = MAX(fabsF(wrap_PI(gpsYaw - velYaw)),fabsF(wrap_PI(gpsYaw - eulerAngles.z)));

        // If the angles disagree by more than 45 degrees and GPS innovations are large or no previous yaw alignment, we declare the magnetic yaw as bad
        bool badMagYaw = ((yawErr > 0.7854f) && (velTestRatio > 1.0f) && (PV_AidingMode == AID_ABSOLUTE)) || !yawAlignComplete;

        // get yaw variance from GPS speed uncertainty
        const ftype gpsVelAcc = fmaxF(gpsSpdAccuracy, ftype(frontend->_gpsHorizVelNoise));
        const ftype gps_yaw_variance = sq(asinF(constrain_float(gpsVelAcc/gpsDataDelayed.vel.xy().length(), -1.0F, 1.0F)));
        if (gps_yaw_variance < sq(radians(GPS_VEL_YAW_ALIGN_MAX_ANG_ERR))) {
            yawAlignGpsValidCount++;
        } else {
            yawAlignGpsValidCount = 0;
        }

        // correct yaw angle using GPS ground course if compass yaw bad
        if (badMagYaw) {
            // attempt to use EKF-GSF estimate if available as it is more robust to GPS glitches
            // by default fly forward vehicles use ground course for initial yaw unless the GSF is explicitly selected as the yaw source
            const bool useGSF = !assume_zero_sideslip() || (yaw_source_last == AP_NavEKF_Source::SourceYaw::GSF);
            if (useGSF && EKFGSF_resetMainFilterYaw(emergency_reset)) {
                return;
            }

            if (yawAlignGpsValidCount >= GPS_VEL_YAW_ALIGN_COUNT_THRESHOLD) {
                yawAlignGpsValidCount = 0;
                // keep roll and pitch and reset yaw
                rotationOrder order;
                bestRotationOrder(order);
                resetQuatStateYawOnly(gpsYaw, gps_yaw_variance, order);

                // reset the velocity and position states as they will be inaccurate due to bad yaw
                ResetVelocity(resetDataSource::GPS);
                ResetPosition(resetDataSource::GPS);

                // send yaw alignment information to console
                GCS_SEND_TEXT(MAV_SEVERITY_INFO, "EKF3 IMU%u yaw aligned to GPS velocity",(unsigned)imu_index);

                if (use_compass()) {
                    // request a mag field reset which may enable us to use the magnetometer if the previous fault was due to bad initialisation
                    magStateResetRequest = true;
                    // clear the all sensors failed status so that the magnetometers sensors get a second chance now that we are flying
                    allMagSensorsFailed = false;
                }
            }
        } else if (yawAlignGpsValidCount >= GPS_VEL_YAW_ALIGN_COUNT_THRESHOLD) {
                // There is no need to do a yaw reset
                yawAlignGpsValidCount = 0;
                recordYawResetsCompleted();
        }
    } else {
        yawAlignGpsValidCount = 0;
    }
}

// align the yaw angle for the quaternion states to the given yaw angle which should be at the fusion horizon
void NavEKF3_core::alignYawAngle(const yaw_elements &yawAngData)
{
    // update quaternion states and covariances
    resetQuatStateYawOnly(yawAngData.yawAng, sq(MAX(yawAngData.yawAngErr, 1.0e-2)), yawAngData.order);

    // send yaw alignment information to console
    GCS_SEND_TEXT(MAV_SEVERITY_INFO, "EKF3 IMU%u yaw aligned",(unsigned)imu_index);
}

/********************************************************
*                   FUSE MEASURED_DATA                  *
********************************************************/

// select fusion of magnetometer data
void NavEKF3_core::SelectMagFusion()
{
    // clear the flag that lets other processes know that the expensive magnetometer fusion operation has been performed on that time step
    // used for load levelling
    magFusePerformed = false;

    // Store yaw angle when moving for use as a static reference when not moving
    if (!onGroundNotMoving) {
        if (fabsF(prevTnb[0][2]) < fabsF(prevTnb[1][2])) {
            // A 321 rotation order is best conditioned because the X axis is closer to horizontal than the Y axis
            yawAngDataStatic.order = rotationOrder::TAIT_BRYAN_321;
            yawAngDataStatic.yawAng = atan2F(prevTnb[0][1], prevTnb[0][0]);
        } else {
            // A 312 rotation order is best conditioned because the Y axis is closer to horizontal than the X axis
            yawAngDataStatic.order = rotationOrder::TAIT_BRYAN_312;
            yawAngDataStatic.yawAng = atan2F(-prevTnb[1][0], prevTnb[1][1]);
        }
        yawAngDataStatic.yawAngErr = MAX(frontend->_yawNoise, 0.05f);
        yawAngDataStatic.time_ms = imuDataDelayed.time_ms;
    }

    // Handle case where we are not using a yaw sensor of any type and attempt to reset the yaw in
    // flight using the output from the GSF yaw estimator or GPS ground course.
    if ((yaw_source_last == AP_NavEKF_Source::SourceYaw::GSF) ||
        (!use_compass() &&
         yaw_source_last != AP_NavEKF_Source::SourceYaw::GPS &&
         yaw_source_last != AP_NavEKF_Source::SourceYaw::GPS_COMPASS_FALLBACK &&
         yaw_source_last != AP_NavEKF_Source::SourceYaw::EXTNAV)) {

        if ((!yawAlignComplete || yaw_source_reset) && ((yaw_source_last != AP_NavEKF_Source::SourceYaw::GSF) || (EKFGSF_yaw_valid_count >= GSF_YAW_VALID_HISTORY_THRESHOLD))) {
            realignYawGPS(false);
            yaw_source_reset = false;
        } else {
            yaw_source_reset = false;
        }

        if (imuSampleTime_ms - lastSynthYawTime_ms > 140) {
            // use the EKF-GSF yaw estimator output as this is more robust than the EKF can achieve without a yaw measurement
            // for non fixed wing platform types
            ftype gsfYaw, gsfYawVariance;
            const bool didUseEKFGSF = yawAlignComplete && (yaw_source_last == AP_NavEKF_Source::SourceYaw::GSF) && EKFGSF_getYaw(gsfYaw, gsfYawVariance) && !assume_zero_sideslip() && fuseEulerYaw(yawFusionMethod::GSF);

            // fallback methods
            if (!didUseEKFGSF) {
                if (onGroundNotMoving) {
                    // fuse last known good yaw angle before we stopped moving to allow yaw bias learning when on ground before flight
                    fuseEulerYaw(yawFusionMethod::STATIC);
                } else if (onGround || PV_AidingMode == AID_NONE || (P[0][0]+P[1][1]+P[2][2]+P[3][3] > 0.01f)) {
                    // prevent uncontrolled yaw variance growth that can destabilise the covariance matrix
                    // by fusing a zero innovation
                    fuseEulerYaw(yawFusionMethod::PREDICTED);
                }
            }
            magTestRatio.zero();
            yawTestRatio = 0.0f;
            lastSynthYawTime_ms = imuSampleTime_ms;
        }
        return;
    }

    // Handle case where we are using GPS yaw sensor instead of a magnetomer
    if (yaw_source_last == AP_NavEKF_Source::SourceYaw::GPS || yaw_source_last == AP_NavEKF_Source::SourceYaw::GPS_COMPASS_FALLBACK) {
        bool have_fused_gps_yaw = false;
        if (storedYawAng.recall(yawAngDataDelayed,imuDataDelayed.time_ms)) {
            if (tiltAlignComplete && (!yawAlignComplete || yaw_source_reset)) {
                alignYawAngle(yawAngDataDelayed);
                yaw_source_reset = false;
                have_fused_gps_yaw = true;
                lastSynthYawTime_ms = imuSampleTime_ms;
                last_gps_yaw_fuse_ms = imuSampleTime_ms;
                recordYawResetsCompleted();
            } else if (tiltAlignComplete && yawAlignComplete) {
                have_fused_gps_yaw = fuseEulerYaw(yawFusionMethod::GPS);
                if (have_fused_gps_yaw) {
                    last_gps_yaw_fuse_ms = imuSampleTime_ms;
                }
            }
            last_gps_yaw_ms = imuSampleTime_ms;
        } else if (tiltAlignComplete && !yawAlignComplete) {
            // External yaw sources can take significant time to start providing yaw data so
            // wuile waiting, fuse a 'fake' yaw observation at 7Hz to keeop the filter stable
            if (imuSampleTime_ms - lastSynthYawTime_ms > 140) {
                yawAngDataDelayed.yawAngErr = MAX(frontend->_yawNoise, 0.05f);
                // update the yaw angle using the last estimate which will be used as a static yaw reference when movement stops
                if (!onGroundNotMoving) {
                    // prevent uncontrolled yaw variance growth by fusing a zero innovation
                    fuseEulerYaw(yawFusionMethod::PREDICTED);
                } else {
                    // fuse last known good yaw angle before we stopped moving to allow yaw bias learning when on ground before flight
                    fuseEulerYaw(yawFusionMethod::STATIC);
                }
                lastSynthYawTime_ms = imuSampleTime_ms;
            }
        } else if (tiltAlignComplete && yawAlignComplete && onGround && imuSampleTime_ms - last_gps_yaw_fuse_ms > 10000) {
            // handle scenario where we were using GPS yaw previously, but the yaw fusion has timed out.
            yaw_source_reset = true;
        }

        if (yaw_source_last == AP_NavEKF_Source::SourceYaw::GPS) {
            // no fallback
            return;
        }

        // get new mag data into delay buffer
        readMagData();

        if (have_fused_gps_yaw) {
            if (gps_yaw_mag_fallback_active) {
                gps_yaw_mag_fallback_active = false;
                GCS_SEND_TEXT(MAV_SEVERITY_INFO, "EKF3 IMU%u yaw external",(unsigned)imu_index);
            }
            // update mag bias from GPS yaw
            gps_yaw_mag_fallback_ok = learnMagBiasFromGPS();
            return;
        }

        // we don't have GPS yaw data and are configured for
        // fallback. If we've only just lost GPS yaw
        if (imuSampleTime_ms - last_gps_yaw_ms < 10000) {
            // don't fallback to magnetometer fusion for 10s
            return;
        }
        if (!gps_yaw_mag_fallback_ok) {
            // mag was not consistent enough with GPS to use it as
            // fallback
            return;
        }
        if (!inFlight) {
            // don't fall back if not flying but reset to GPS yaw if it becomes available
            return;
        }
        if (!gps_yaw_mag_fallback_active) {
            gps_yaw_mag_fallback_active = true;
            GCS_SEND_TEXT(MAV_SEVERITY_INFO, "EKF3 IMU%u yaw fallback active",(unsigned)imu_index);
        }
        // fall through to magnetometer fusion
    }

#if EK3_FEATURE_EXTERNAL_NAV
    // Handle case where we are using an external nav for yaw
    const bool extNavYawDataToFuse = storedExtNavYawAng.recall(extNavYawAngDataDelayed, imuDataDelayed.time_ms);
    if (yaw_source_last == AP_NavEKF_Source::SourceYaw::EXTNAV) {
        if (extNavYawDataToFuse) {
            if (tiltAlignComplete && (!yawAlignComplete || yaw_source_reset)) {
                alignYawAngle(extNavYawAngDataDelayed);
                yaw_source_reset = false;
            } else if (tiltAlignComplete && yawAlignComplete) {
                fuseEulerYaw(yawFusionMethod::EXTNAV);
            }
            last_extnav_yaw_fusion_ms = imuSampleTime_ms;
        } else if (tiltAlignComplete && !yawAlignComplete) {
            // External yaw sources can take significant time to start providing yaw data so
            // while waiting, fuse a 'fake' yaw observation at 7Hz to keep the filter stable
            if (imuSampleTime_ms - lastSynthYawTime_ms > 140) {
                // update the yaw angle using the last estimate which will be used as a static yaw reference when movement stops
                if (!onGroundNotMoving) {
                    // prevent uncontrolled yaw variance growth by fusing a zero innovation
                    fuseEulerYaw(yawFusionMethod::PREDICTED);
                } else {
                    // fuse last known good yaw angle before we stopped moving to allow yaw bias learning when on ground before flight
                    fuseEulerYaw(yawFusionMethod::STATIC);
                }
                lastSynthYawTime_ms = imuSampleTime_ms;
            }
        }
    }
#endif // EK3_FEATURE_EXTERNAL_NAV

    // If we are using the compass and the magnetometer has been unhealthy for too long we declare a timeout
    if (magHealth) {
        magTimeout = false;
        lastHealthyMagTime_ms = imuSampleTime_ms;
    } else if ((imuSampleTime_ms - lastHealthyMagTime_ms) > frontend->magFailTimeLimit_ms && use_compass()) {
        magTimeout = true;
    }

    if (yaw_source_last != AP_NavEKF_Source::SourceYaw::GPS_COMPASS_FALLBACK) {
        // check for and read new magnetometer measurements. We don't
        // read for GPS_COMPASS_FALLBACK as it has already been read
        // above
        readMagData();
    }

    // check for availability of magnetometer or other yaw data to fuse
    magDataToFuse = storedMag.recall(magDataDelayed,imuDataDelayed.time_ms);

    // Control reset of yaw and magnetic field states if we are using compass data
    if (magDataToFuse) {
        if (yaw_source_reset && (yaw_source_last == AP_NavEKF_Source::SourceYaw::COMPASS ||
                                 yaw_source_last == AP_NavEKF_Source::SourceYaw::GPS_COMPASS_FALLBACK)) {
            magYawResetRequest = true;
            yaw_source_reset = false;
        }
        controlMagYawReset();
    }

    // determine if conditions are right to start a new fusion cycle
    // wait until the EKF time horizon catches up with the measurement
    bool dataReady = (magDataToFuse && statesInitialised && use_compass() && yawAlignComplete);
    if (dataReady) {
        // use the simple method of declination to maintain heading if we cannot use the magnetic field states
        if(inhibitMagStates || magStateResetRequest || !magStateInitComplete) {
            magFusionSel = MagFuseSel::FUSE_YAW;
            fuseEulerYaw(yawFusionMethod::MAGNETOMETER);

            // zero the test ratio output from the inactive 3-axis magnetometer fusion
            magTestRatio.zero();

        } else {
            magFusionSel = MagFuseSel::FUSE_MAG;
            // if we are not doing aiding with earth relative observations (eg GPS) then the declination is
            // maintained by fusing declination as a synthesised observation
            // We also fuse declination if we are using the WMM tables
            if (PV_AidingMode != AID_ABSOLUTE ||
                (frontend->_mag_ef_limit > 0 && have_table_earth_field)) {
                FuseDeclination(0.34f);
            }
            // fuse the three magnetometer componenents using sequential fusion for each axis
            FuseMagnetometer();
            // zero the test ratio output from the inactive simple magnetometer yaw fusion
            yawTestRatio = 0.0f;
        }
    }

    // If the final yaw reset has been performed and the state variances are sufficiently low
    // record that the earth field has been learned.
    if (!magFieldLearned && finalInflightMagInit) {
        magFieldLearned = (P[16][16] < sq(0.01f)) && (P[17][17] < sq(0.01f)) && (P[18][18] < sq(0.01f));
    }

    // record the last learned field variances
    if (magFieldLearned && !inhibitMagStates) {
        earthMagFieldVar.x = P[16][16];
        earthMagFieldVar.y = P[17][17];
        earthMagFieldVar.z = P[18][18];
        bodyMagFieldVar.x = P[19][19];
        bodyMagFieldVar.y = P[20][20];
        bodyMagFieldVar.z = P[21][21];
    }
}

/*
 * Fuse magnetometer measurements using explicit algebraic equations generated with Matlab symbolic toolbox.
 * The script file used to generate these and other equations in this filter can be found here:
 * https://github.com/PX4/ecl/blob/master/matlab/scripts/Inertial%20Nav%20EKF/GenerateNavFilterEquations.m
*/
void NavEKF3_core::FuseMagnetometer()
{
    // perform sequential fusion of magnetometer measurements.
    // this assumes that the errors in the different components are
    // uncorrelated which is not true, however in the absence of covariance
    // data fit is the only assumption we can make
    // so we might as well take advantage of the computational efficiencies
    // associated with sequential fusion
    // calculate observation jacobians and Kalman gains

    // create aliases for state to make code easier to read:
    const ftype q0       = stateStruct.quat[0];
    const ftype q1       = stateStruct.quat[1];
    const ftype q2       = stateStruct.quat[2];
    const ftype q3       = stateStruct.quat[3];
    const ftype magN     = stateStruct.earth_magfield[0];
    const ftype magE     = stateStruct.earth_magfield[1];
    const ftype magD     = stateStruct.earth_magfield[2];
    const ftype magXbias = stateStruct.body_magfield[0];
    const ftype magYbias = stateStruct.body_magfield[1];
    const ftype magZbias = stateStruct.body_magfield[2];

    // rotate predicted earth components into body axes and calculate
    // predicted measurements
    const Matrix3F DCM {
        q0*q0 + q1*q1 - q2*q2 - q3*q3,
        2.0f*(q1*q2 + q0*q3),
        2.0f*(q1*q3-q0*q2),
        2.0f*(q1*q2 - q0*q3),
        q0*q0 - q1*q1 + q2*q2 - q3*q3,
        2.0f*(q2*q3 + q0*q1),
        2.0f*(q1*q3 + q0*q2),
        2.0f*(q2*q3 - q0*q1),
        q0*q0 - q1*q1 - q2*q2 + q3*q3
    };

    const Vector3F MagPred {
        DCM[0][0]*magN + DCM[0][1]*magE  + DCM[0][2]*magD + magXbias,
        DCM[1][0]*magN + DCM[1][1]*magE  + DCM[1][2]*magD + magYbias,
        DCM[2][0]*magN + DCM[2][1]*magE  + DCM[2][2]*magD + magZbias
    };

    // calculate the measurement innovation for each axis
    innovMag = MagPred - magDataDelayed.mag;

    // scale magnetometer observation error with total angular rate to allow for timing errors
    const ftype R_MAG = sq(constrain_ftype(frontend->_magNoise, 0.01f, 0.5f)) + sq(frontend->magVarRateScale*imuDataDelayed.delAng.length() / imuDataDelayed.delAngDT);

    // calculate common expressions used to calculate observation jacobians an innovation variance for each component
    const Vector9 SH_MAG {
        2.0f*magD*q3 + 2.0f*magE*q2 + 2.0f*magN*q1,
        2.0f*magD*q0 - 2.0f*magE*q1 + 2.0f*magN*q2,
        2.0f*magD*q1 + 2.0f*magE*q0 - 2.0f*magN*q3,
        sq(q3),
        sq(q2),
        sq(q1),
        sq(q0),
        2.0f*magN*q0,
        2.0f*magE*q3
    };

    // Calculate the innovation variance for each axis
    // X axis
    varInnovMag[0] = (P[19][19] + R_MAG + P[1][19]*SH_MAG[0] - P[2][19]*SH_MAG[1] + P[3][19]*SH_MAG[2] - P[16][19]*(SH_MAG[3] + SH_MAG[4] - SH_MAG[5] - SH_MAG[6]) + (2.0f*q0*q3 + 2.0f*q1*q2)*(P[19][17] + P[1][17]*SH_MAG[0] - P[2][17]*SH_MAG[1] + P[3][17]*SH_MAG[2] - P[16][17]*(SH_MAG[3] + SH_MAG[4] - SH_MAG[5] - SH_MAG[6]) + P[17][17]*(2.0f*q0*q3 + 2.0f*q1*q2) - P[18][17]*(2.0f*q0*q2 - 2.0f*q1*q3) + P[0][17]*(SH_MAG[7] + SH_MAG[8] - 2.0f*magD*q2)) - (2.0f*q0*q2 - 2.0f*q1*q3)*(P[19][18] + P[1][18]*SH_MAG[0] - P[2][18]*SH_MAG[1] + P[3][18]*SH_MAG[2] - P[16][18]*(SH_MAG[3] + SH_MAG[4] - SH_MAG[5] - SH_MAG[6]) + P[17][18]*(2.0f*q0*q3 + 2.0f*q1*q2) - P[18][18]*(2.0f*q0*q2 - 2.0f*q1*q3) + P[0][18]*(SH_MAG[7] + SH_MAG[8] - 2.0f*magD*q2)) + (SH_MAG[7] + SH_MAG[8] - 2.0f*magD*q2)*(P[19][0] + P[1][0]*SH_MAG[0] - P[2][0]*SH_MAG[1] + P[3][0]*SH_MAG[2] - P[16][0]*(SH_MAG[3] + SH_MAG[4] - SH_MAG[5] - SH_MAG[6]) + P[17][0]*(2.0f*q0*q3 + 2.0f*q1*q2) - P[18][0]*(2.0f*q0*q2 - 2.0f*q1*q3) + P[0][0]*(SH_MAG[7] + SH_MAG[8] - 2.0f*magD*q2)) + P[17][19]*(2.0f*q0*q3 + 2.0f*q1*q2) - P[18][19]*(2.0f*q0*q2 - 2.0f*q1*q3) + SH_MAG[0]*(P[19][1] + P[1][1]*SH_MAG[0] - P[2][1]*SH_MAG[1] + P[3][1]*SH_MAG[2] - P[16][1]*(SH_MAG[3] + SH_MAG[4] - SH_MAG[5] - SH_MAG[6]) + P[17][1]*(2.0f*q0*q3 + 2.0f*q1*q2) - P[18][1]*(2.0f*q0*q2 - 2.0f*q1*q3) + P[0][1]*(SH_MAG[7] + SH_MAG[8] - 2.0f*magD*q2)) - SH_MAG[1]*(P[19][2] + P[1][2]*SH_MAG[0] - P[2][2]*SH_MAG[1] + P[3][2]*SH_MAG[2] - P[16][2]*(SH_MAG[3] + SH_MAG[4] - SH_MAG[5] - SH_MAG[6]) + P[17][2]*(2.0f*q0*q3 + 2.0f*q1*q2) - P[18][2]*(2.0f*q0*q2 - 2.0f*q1*q3) + P[0][2]*(SH_MAG[7] + SH_MAG[8] - 2.0f*magD*q2)) + SH_MAG[2]*(P[19][3] + P[1][3]*SH_MAG[0] - P[2][3]*SH_MAG[1] + P[3][3]*SH_MAG[2] - P[16][3]*(SH_MAG[3] + SH_MAG[4] - SH_MAG[5] - SH_MAG[6]) + P[17][3]*(2.0f*q0*q3 + 2.0f*q1*q2) - P[18][3]*(2.0f*q0*q2 - 2.0f*q1*q3) + P[0][3]*(SH_MAG[7] + SH_MAG[8] - 2.0f*magD*q2)) - (SH_MAG[3] + SH_MAG[4] - SH_MAG[5] - SH_MAG[6])*(P[19][16] + P[1][16]*SH_MAG[0] - P[2][16]*SH_MAG[1] + P[3][16]*SH_MAG[2] - P[16][16]*(SH_MAG[3] + SH_MAG[4] - SH_MAG[5] - SH_MAG[6]) + P[17][16]*(2.0f*q0*q3 + 2.0f*q1*q2) - P[18][16]*(2.0f*q0*q2 - 2.0f*q1*q3) + P[0][16]*(SH_MAG[7] + SH_MAG[8] - 2.0f*magD*q2)) + P[0][19]*(SH_MAG[7] + SH_MAG[8] - 2.0f*magD*q2));
    if (varInnovMag[0] >= R_MAG) {
        faultStatus.bad_xmag = false;
    } else {
        // the calculation is badly conditioned, so we cannot perform fusion on this step
        // we reset the covariance matrix and try again next measurement
        CovarianceInit();
        faultStatus.bad_xmag = true;
        return;
    }

    // Y axis
    varInnovMag[1] = (P[20][20] + R_MAG + P[0][20]*SH_MAG[2] + P[1][20]*SH_MAG[1] + P[2][20]*SH_MAG[0] - P[17][20]*(SH_MAG[3] - SH_MAG[4] + SH_MAG[5] - SH_MAG[6]) - (2.0f*q0*q3 - 2.0f*q1*q2)*(P[20][16] + P[0][16]*SH_MAG[2] + P[1][16]*SH_MAG[1] + P[2][16]*SH_MAG[0] - P[17][16]*(SH_MAG[3] - SH_MAG[4] + SH_MAG[5] - SH_MAG[6]) - P[16][16]*(2.0f*q0*q3 - 2.0f*q1*q2) + P[18][16]*(2.0f*q0*q1 + 2.0f*q2*q3) - P[3][16]*(SH_MAG[7] + SH_MAG[8] - 2.0f*magD*q2)) + (2.0f*q0*q1 + 2.0f*q2*q3)*(P[20][18] + P[0][18]*SH_MAG[2] + P[1][18]*SH_MAG[1] + P[2][18]*SH_MAG[0] - P[17][18]*(SH_MAG[3] - SH_MAG[4] + SH_MAG[5] - SH_MAG[6]) - P[16][18]*(2.0f*q0*q3 - 2.0f*q1*q2) + P[18][18]*(2.0f*q0*q1 + 2.0f*q2*q3) - P[3][18]*(SH_MAG[7] + SH_MAG[8] - 2.0f*magD*q2)) - (SH_MAG[7] + SH_MAG[8] - 2.0f*magD*q2)*(P[20][3] + P[0][3]*SH_MAG[2] + P[1][3]*SH_MAG[1] + P[2][3]*SH_MAG[0] - P[17][3]*(SH_MAG[3] - SH_MAG[4] + SH_MAG[5] - SH_MAG[6]) - P[16][3]*(2.0f*q0*q3 - 2.0f*q1*q2) + P[18][3]*(2.0f*q0*q1 + 2.0f*q2*q3) - P[3][3]*(SH_MAG[7] + SH_MAG[8] - 2.0f*magD*q2)) - P[16][20]*(2.0f*q0*q3 - 2.0f*q1*q2) + P[18][20]*(2.0f*q0*q1 + 2.0f*q2*q3) + SH_MAG[2]*(P[20][0] + P[0][0]*SH_MAG[2] + P[1][0]*SH_MAG[1] + P[2][0]*SH_MAG[0] - P[17][0]*(SH_MAG[3] - SH_MAG[4] + SH_MAG[5] - SH_MAG[6]) - P[16][0]*(2.0f*q0*q3 - 2.0f*q1*q2) + P[18][0]*(2.0f*q0*q1 + 2.0f*q2*q3) - P[3][0]*(SH_MAG[7] + SH_MAG[8] - 2.0f*magD*q2)) + SH_MAG[1]*(P[20][1] + P[0][1]*SH_MAG[2] + P[1][1]*SH_MAG[1] + P[2][1]*SH_MAG[0] - P[17][1]*(SH_MAG[3] - SH_MAG[4] + SH_MAG[5] - SH_MAG[6]) - P[16][1]*(2.0f*q0*q3 - 2.0f*q1*q2) + P[18][1]*(2.0f*q0*q1 + 2.0f*q2*q3) - P[3][1]*(SH_MAG[7] + SH_MAG[8] - 2.0f*magD*q2)) + SH_MAG[0]*(P[20][2] + P[0][2]*SH_MAG[2] + P[1][2]*SH_MAG[1] + P[2][2]*SH_MAG[0] - P[17][2]*(SH_MAG[3] - SH_MAG[4] + SH_MAG[5] - SH_MAG[6]) - P[16][2]*(2.0f*q0*q3 - 2.0f*q1*q2) + P[18][2]*(2.0f*q0*q1 + 2.0f*q2*q3) - P[3][2]*(SH_MAG[7] + SH_MAG[8] - 2.0f*magD*q2)) - (SH_MAG[3] - SH_MAG[4] + SH_MAG[5] - SH_MAG[6])*(P[20][17] + P[0][17]*SH_MAG[2] + P[1][17]*SH_MAG[1] + P[2][17]*SH_MAG[0] - P[17][17]*(SH_MAG[3] - SH_MAG[4] + SH_MAG[5] - SH_MAG[6]) - P[16][17]*(2.0f*q0*q3 - 2.0f*q1*q2) + P[18][17]*(2.0f*q0*q1 + 2.0f*q2*q3) - P[3][17]*(SH_MAG[7] + SH_MAG[8] - 2.0f*magD*q2)) - P[3][20]*(SH_MAG[7] + SH_MAG[8] - 2.0f*magD*q2));
    if (varInnovMag[1] >= R_MAG) {
        faultStatus.bad_ymag = false;
    } else {
        // the calculation is badly conditioned, so we cannot perform fusion on this step
        // we reset the covariance matrix and try again next measurement
        CovarianceInit();
        faultStatus.bad_ymag = true;
        return;
    }

    // Z axis
    varInnovMag[2] = (P[21][21] + R_MAG + P[0][21]*SH_MAG[1] - P[1][21]*SH_MAG[2] + P[3][21]*SH_MAG[0] + P[18][21]*(SH_MAG[3] - SH_MAG[4] - SH_MAG[5] + SH_MAG[6]) + (2.0f*q0*q2 + 2.0f*q1*q3)*(P[21][16] + P[0][16]*SH_MAG[1] - P[1][16]*SH_MAG[2] + P[3][16]*SH_MAG[0] + P[18][16]*(SH_MAG[3] - SH_MAG[4] - SH_MAG[5] + SH_MAG[6]) + P[16][16]*(2.0f*q0*q2 + 2.0f*q1*q3) - P[17][16]*(2.0f*q0*q1 - 2.0f*q2*q3) + P[2][16]*(SH_MAG[7] + SH_MAG[8] - 2.0f*magD*q2)) - (2.0f*q0*q1 - 2.0f*q2*q3)*(P[21][17] + P[0][17]*SH_MAG[1] - P[1][17]*SH_MAG[2] + P[3][17]*SH_MAG[0] + P[18][17]*(SH_MAG[3] - SH_MAG[4] - SH_MAG[5] + SH_MAG[6]) + P[16][17]*(2.0f*q0*q2 + 2.0f*q1*q3) - P[17][17]*(2.0f*q0*q1 - 2.0f*q2*q3) + P[2][17]*(SH_MAG[7] + SH_MAG[8] - 2.0f*magD*q2)) + (SH_MAG[7] + SH_MAG[8] - 2.0f*magD*q2)*(P[21][2] + P[0][2]*SH_MAG[1] - P[1][2]*SH_MAG[2] + P[3][2]*SH_MAG[0] + P[18][2]*(SH_MAG[3] - SH_MAG[4] - SH_MAG[5] + SH_MAG[6]) + P[16][2]*(2.0f*q0*q2 + 2.0f*q1*q3) - P[17][2]*(2.0f*q0*q1 - 2.0f*q2*q3) + P[2][2]*(SH_MAG[7] + SH_MAG[8] - 2.0f*magD*q2)) + P[16][21]*(2.0f*q0*q2 + 2.0f*q1*q3) - P[17][21]*(2.0f*q0*q1 - 2.0f*q2*q3) + SH_MAG[1]*(P[21][0] + P[0][0]*SH_MAG[1] - P[1][0]*SH_MAG[2] + P[3][0]*SH_MAG[0] + P[18][0]*(SH_MAG[3] - SH_MAG[4] - SH_MAG[5] + SH_MAG[6]) + P[16][0]*(2.0f*q0*q2 + 2.0f*q1*q3) - P[17][0]*(2.0f*q0*q1 - 2.0f*q2*q3) + P[2][0]*(SH_MAG[7] + SH_MAG[8] - 2.0f*magD*q2)) - SH_MAG[2]*(P[21][1] + P[0][1]*SH_MAG[1] - P[1][1]*SH_MAG[2] + P[3][1]*SH_MAG[0] + P[18][1]*(SH_MAG[3] - SH_MAG[4] - SH_MAG[5] + SH_MAG[6]) + P[16][1]*(2.0f*q0*q2 + 2.0f*q1*q3) - P[17][1]*(2.0f*q0*q1 - 2.0f*q2*q3) + P[2][1]*(SH_MAG[7] + SH_MAG[8] - 2.0f*magD*q2)) + SH_MAG[0]*(P[21][3] + P[0][3]*SH_MAG[1] - P[1][3]*SH_MAG[2] + P[3][3]*SH_MAG[0] + P[18][3]*(SH_MAG[3] - SH_MAG[4] - SH_MAG[5] + SH_MAG[6]) + P[16][3]*(2.0f*q0*q2 + 2.0f*q1*q3) - P[17][3]*(2.0f*q0*q1 - 2.0f*q2*q3) + P[2][3]*(SH_MAG[7] + SH_MAG[8] - 2.0f*magD*q2)) + (SH_MAG[3] - SH_MAG[4] - SH_MAG[5] + SH_MAG[6])*(P[21][18] + P[0][18]*SH_MAG[1] - P[1][18]*SH_MAG[2] + P[3][18]*SH_MAG[0] + P[18][18]*(SH_MAG[3] - SH_MAG[4] - SH_MAG[5] + SH_MAG[6]) + P[16][18]*(2.0f*q0*q2 + 2.0f*q1*q3) - P[17][18]*(2.0f*q0*q1 - 2.0f*q2*q3) + P[2][18]*(SH_MAG[7] + SH_MAG[8] - 2.0f*magD*q2)) + P[2][21]*(SH_MAG[7] + SH_MAG[8] - 2.0f*magD*q2));
    if (varInnovMag[2] >= R_MAG) {
        faultStatus.bad_zmag = false;
    } else {
        // the calculation is badly conditioned, so we cannot perform fusion on this step
        // we reset the covariance matrix and try again next measurement
        CovarianceInit();
        faultStatus.bad_zmag = true;
        return;
    }

    // calculate the innovation test ratios
    for (uint8_t i = 0; i<=2; i++) {
        magTestRatio[i] = sq(innovMag[i]) / (sq(MAX(0.01f * (ftype)frontend->_magInnovGate, 1.0f)) * varInnovMag[i]);
    }

    // check the last values from all components and set magnetometer health accordingly
    magHealth = (magTestRatio[0] < 1.0f && magTestRatio[1] < 1.0f && magTestRatio[2] < 1.0f);

    // if the magnetometer is unhealthy, do not proceed further
    if (!magHealth) {
        return;
    }

    Vector24 H_MAG;
    for (uint8_t obsIndex = 0; obsIndex <= 2; obsIndex++) {

        if (obsIndex == 0) {

            for (uint8_t i = 0; i<=stateIndexLim; i++) H_MAG[i] = 0.0f;
            H_MAG[0] = SH_MAG[7] + SH_MAG[8] - 2.0f*magD*q2;
            H_MAG[1] = SH_MAG[0];
            H_MAG[2] = -SH_MAG[1];
            H_MAG[3] = SH_MAG[2];
            H_MAG[16] = SH_MAG[5] - SH_MAG[4] - SH_MAG[3] + SH_MAG[6];
            H_MAG[17] = 2.0f*q0*q3 + 2.0f*q1*q2;
            H_MAG[18] = 2.0f*q1*q3 - 2.0f*q0*q2;
            H_MAG[19] = 1.0f;
            H_MAG[20] = 0.0f;
            H_MAG[21] = 0.0f;

            // calculate Kalman gain
            const Vector5 SK_MX {
                1.0f / varInnovMag[0],
                SH_MAG[3] + SH_MAG[4] - SH_MAG[5] - SH_MAG[6],
                SH_MAG[7] + SH_MAG[8] - 2.0f*magD*q2,
                2.0f*q0*q2 - 2.0f*q1*q3,
                2.0f*q0*q3 + 2.0f*q1*q2
            };

            Kfusion[0] = SK_MX[0]*(P[0][19] + P[0][1]*SH_MAG[0] - P[0][2]*SH_MAG[1] + P[0][3]*SH_MAG[2] + P[0][0]*SK_MX[2] - P[0][16]*SK_MX[1] + P[0][17]*SK_MX[4] - P[0][18]*SK_MX[3]);
            Kfusion[1] = SK_MX[0]*(P[1][19] + P[1][1]*SH_MAG[0] - P[1][2]*SH_MAG[1] + P[1][3]*SH_MAG[2] + P[1][0]*SK_MX[2] - P[1][16]*SK_MX[1] + P[1][17]*SK_MX[4] - P[1][18]*SK_MX[3]);
            Kfusion[2] = SK_MX[0]*(P[2][19] + P[2][1]*SH_MAG[0] - P[2][2]*SH_MAG[1] + P[2][3]*SH_MAG[2] + P[2][0]*SK_MX[2] - P[2][16]*SK_MX[1] + P[2][17]*SK_MX[4] - P[2][18]*SK_MX[3]);
            Kfusion[3] = SK_MX[0]*(P[3][19] + P[3][1]*SH_MAG[0] - P[3][2]*SH_MAG[1] + P[3][3]*SH_MAG[2] + P[3][0]*SK_MX[2] - P[3][16]*SK_MX[1] + P[3][17]*SK_MX[4] - P[3][18]*SK_MX[3]);
            Kfusion[4] = SK_MX[0]*(P[4][19] + P[4][1]*SH_MAG[0] - P[4][2]*SH_MAG[1] + P[4][3]*SH_MAG[2] + P[4][0]*SK_MX[2] - P[4][16]*SK_MX[1] + P[4][17]*SK_MX[4] - P[4][18]*SK_MX[3]);
            Kfusion[5] = SK_MX[0]*(P[5][19] + P[5][1]*SH_MAG[0] - P[5][2]*SH_MAG[1] + P[5][3]*SH_MAG[2] + P[5][0]*SK_MX[2] - P[5][16]*SK_MX[1] + P[5][17]*SK_MX[4] - P[5][18]*SK_MX[3]);
            Kfusion[6] = SK_MX[0]*(P[6][19] + P[6][1]*SH_MAG[0] - P[6][2]*SH_MAG[1] + P[6][3]*SH_MAG[2] + P[6][0]*SK_MX[2] - P[6][16]*SK_MX[1] + P[6][17]*SK_MX[4] - P[6][18]*SK_MX[3]);
            Kfusion[7] = SK_MX[0]*(P[7][19] + P[7][1]*SH_MAG[0] - P[7][2]*SH_MAG[1] + P[7][3]*SH_MAG[2] + P[7][0]*SK_MX[2] - P[7][16]*SK_MX[1] + P[7][17]*SK_MX[4] - P[7][18]*SK_MX[3]);
            Kfusion[8] = SK_MX[0]*(P[8][19] + P[8][1]*SH_MAG[0] - P[8][2]*SH_MAG[1] + P[8][3]*SH_MAG[2] + P[8][0]*SK_MX[2] - P[8][16]*SK_MX[1] + P[8][17]*SK_MX[4] - P[8][18]*SK_MX[3]);
            Kfusion[9] = SK_MX[0]*(P[9][19] + P[9][1]*SH_MAG[0] - P[9][2]*SH_MAG[1] + P[9][3]*SH_MAG[2] + P[9][0]*SK_MX[2] - P[9][16]*SK_MX[1] + P[9][17]*SK_MX[4] - P[9][18]*SK_MX[3]);

            if (!inhibitDelAngBiasStates) {
                Kfusion[10] = SK_MX[0]*(P[10][19] + P[10][1]*SH_MAG[0] - P[10][2]*SH_MAG[1] + P[10][3]*SH_MAG[2] + P[10][0]*SK_MX[2] - P[10][16]*SK_MX[1] + P[10][17]*SK_MX[4] - P[10][18]*SK_MX[3]);
                Kfusion[11] = SK_MX[0]*(P[11][19] + P[11][1]*SH_MAG[0] - P[11][2]*SH_MAG[1] + P[11][3]*SH_MAG[2] + P[11][0]*SK_MX[2] - P[11][16]*SK_MX[1] + P[11][17]*SK_MX[4] - P[11][18]*SK_MX[3]);
                Kfusion[12] = SK_MX[0]*(P[12][19] + P[12][1]*SH_MAG[0] - P[12][2]*SH_MAG[1] + P[12][3]*SH_MAG[2] + P[12][0]*SK_MX[2] - P[12][16]*SK_MX[1] + P[12][17]*SK_MX[4] - P[12][18]*SK_MX[3]);
            } else {
                // zero indexes 10 to 12
                zero_range(&Kfusion[0], 10, 12);
            }

            if (!inhibitDelVelBiasStates) {
                for (uint8_t index = 0; index < 3; index++) {
                    const uint8_t stateIndex = index + 13;
                    if (!dvelBiasAxisInhibit[index]) {
                        Kfusion[stateIndex] = SK_MX[0]*(P[stateIndex][19] + P[stateIndex][1]*SH_MAG[0] - P[stateIndex][2]*SH_MAG[1] + P[stateIndex][3]*SH_MAG[2] + P[stateIndex][0]*SK_MX[2] - P[stateIndex][16]*SK_MX[1] + P[stateIndex][17]*SK_MX[4] - P[stateIndex][18]*SK_MX[3]);
                    } else {
                        Kfusion[stateIndex] = 0.0f;
                    }
                }
            } else {
                // zero indexes 13 to 15
                zero_range(&Kfusion[0], 13, 15);
            }
            // zero Kalman gains to inhibit magnetic field state estimation
            if (!inhibitMagStates) {
                Kfusion[16] = SK_MX[0]*(P[16][19] + P[16][1]*SH_MAG[0] - P[16][2]*SH_MAG[1] + P[16][3]*SH_MAG[2] + P[16][0]*SK_MX[2] - P[16][16]*SK_MX[1] + P[16][17]*SK_MX[4] - P[16][18]*SK_MX[3]);
                Kfusion[17] = SK_MX[0]*(P[17][19] + P[17][1]*SH_MAG[0] - P[17][2]*SH_MAG[1] + P[17][3]*SH_MAG[2] + P[17][0]*SK_MX[2] - P[17][16]*SK_MX[1] + P[17][17]*SK_MX[4] - P[17][18]*SK_MX[3]);
                Kfusion[18] = SK_MX[0]*(P[18][19] + P[18][1]*SH_MAG[0] - P[18][2]*SH_MAG[1] + P[18][3]*SH_MAG[2] + P[18][0]*SK_MX[2] - P[18][16]*SK_MX[1] + P[18][17]*SK_MX[4] - P[18][18]*SK_MX[3]);
                Kfusion[19] = SK_MX[0]*(P[19][19] + P[19][1]*SH_MAG[0] - P[19][2]*SH_MAG[1] + P[19][3]*SH_MAG[2] + P[19][0]*SK_MX[2] - P[19][16]*SK_MX[1] + P[19][17]*SK_MX[4] - P[19][18]*SK_MX[3]);
                Kfusion[20] = SK_MX[0]*(P[20][19] + P[20][1]*SH_MAG[0] - P[20][2]*SH_MAG[1] + P[20][3]*SH_MAG[2] + P[20][0]*SK_MX[2] - P[20][16]*SK_MX[1] + P[20][17]*SK_MX[4] - P[20][18]*SK_MX[3]);
                Kfusion[21] = SK_MX[0]*(P[21][19] + P[21][1]*SH_MAG[0] - P[21][2]*SH_MAG[1] + P[21][3]*SH_MAG[2] + P[21][0]*SK_MX[2] - P[21][16]*SK_MX[1] + P[21][17]*SK_MX[4] - P[21][18]*SK_MX[3]);
            } else {
                // zero indexes 16 to 21
                zero_range(&Kfusion[0], 16, 21);
            }

            // zero Kalman gains to inhibit wind state estimation
            if (!inhibitWindStates && !treatWindStatesAsTruth) {
                Kfusion[22] = SK_MX[0]*(P[22][19] + P[22][1]*SH_MAG[0] - P[22][2]*SH_MAG[1] + P[22][3]*SH_MAG[2] + P[22][0]*SK_MX[2] - P[22][16]*SK_MX[1] + P[22][17]*SK_MX[4] - P[22][18]*SK_MX[3]);
                Kfusion[23] = SK_MX[0]*(P[23][19] + P[23][1]*SH_MAG[0] - P[23][2]*SH_MAG[1] + P[23][3]*SH_MAG[2] + P[23][0]*SK_MX[2] - P[23][16]*SK_MX[1] + P[23][17]*SK_MX[4] - P[23][18]*SK_MX[3]);
            } else {
                // zero indexes 22 to 23 = 2
                zero_range(&Kfusion[0], 22, 23);
            }

            // set flags to indicate to other processes that fusion has been performed and is required on the next frame
            // this can be used by other fusion processes to avoid fusing on the same frame as this expensive step
            magFusePerformed = true;
        } else if (obsIndex == 1) { // Fuse Y axis

            // calculate observation jacobians
            for (uint8_t i = 0; i<=stateIndexLim; i++) H_MAG[i] = 0.0f;
            H_MAG[0] = SH_MAG[2];
            H_MAG[1] = SH_MAG[1];
            H_MAG[2] = SH_MAG[0];
            H_MAG[3] = 2.0f*magD*q2 - SH_MAG[8] - SH_MAG[7];
            H_MAG[16] = 2.0f*q1*q2 - 2.0f*q0*q3;
            H_MAG[17] = SH_MAG[4] - SH_MAG[3] - SH_MAG[5] + SH_MAG[6];
            H_MAG[18] = 2.0f*q0*q1 + 2.0f*q2*q3;
            H_MAG[19] = 0.0f;
            H_MAG[20] = 1.0f;
            H_MAG[21] = 0.0f;

            // calculate Kalman gain
            const Vector5 SK_MY {
                1.0f / varInnovMag[1],
                SH_MAG[3] - SH_MAG[4] + SH_MAG[5] - SH_MAG[6],
                SH_MAG[7] + SH_MAG[8] - 2.0f*magD*q2,
                2.0f*q0*q3 - 2.0f*q1*q2,
                2.0f*q0*q1 + 2.0f*q2*q3
            };

            Kfusion[0] = SK_MY[0]*(P[0][20] + P[0][0]*SH_MAG[2] + P[0][1]*SH_MAG[1] + P[0][2]*SH_MAG[0] - P[0][3]*SK_MY[2] - P[0][17]*SK_MY[1] - P[0][16]*SK_MY[3] + P[0][18]*SK_MY[4]);
            Kfusion[1] = SK_MY[0]*(P[1][20] + P[1][0]*SH_MAG[2] + P[1][1]*SH_MAG[1] + P[1][2]*SH_MAG[0] - P[1][3]*SK_MY[2] - P[1][17]*SK_MY[1] - P[1][16]*SK_MY[3] + P[1][18]*SK_MY[4]);
            Kfusion[2] = SK_MY[0]*(P[2][20] + P[2][0]*SH_MAG[2] + P[2][1]*SH_MAG[1] + P[2][2]*SH_MAG[0] - P[2][3]*SK_MY[2] - P[2][17]*SK_MY[1] - P[2][16]*SK_MY[3] + P[2][18]*SK_MY[4]);
            Kfusion[3] = SK_MY[0]*(P[3][20] + P[3][0]*SH_MAG[2] + P[3][1]*SH_MAG[1] + P[3][2]*SH_MAG[0] - P[3][3]*SK_MY[2] - P[3][17]*SK_MY[1] - P[3][16]*SK_MY[3] + P[3][18]*SK_MY[4]);
            Kfusion[4] = SK_MY[0]*(P[4][20] + P[4][0]*SH_MAG[2] + P[4][1]*SH_MAG[1] + P[4][2]*SH_MAG[0] - P[4][3]*SK_MY[2] - P[4][17]*SK_MY[1] - P[4][16]*SK_MY[3] + P[4][18]*SK_MY[4]);
            Kfusion[5] = SK_MY[0]*(P[5][20] + P[5][0]*SH_MAG[2] + P[5][1]*SH_MAG[1] + P[5][2]*SH_MAG[0] - P[5][3]*SK_MY[2] - P[5][17]*SK_MY[1] - P[5][16]*SK_MY[3] + P[5][18]*SK_MY[4]);
            Kfusion[6] = SK_MY[0]*(P[6][20] + P[6][0]*SH_MAG[2] + P[6][1]*SH_MAG[1] + P[6][2]*SH_MAG[0] - P[6][3]*SK_MY[2] - P[6][17]*SK_MY[1] - P[6][16]*SK_MY[3] + P[6][18]*SK_MY[4]);
            Kfusion[7] = SK_MY[0]*(P[7][20] + P[7][0]*SH_MAG[2] + P[7][1]*SH_MAG[1] + P[7][2]*SH_MAG[0] - P[7][3]*SK_MY[2] - P[7][17]*SK_MY[1] - P[7][16]*SK_MY[3] + P[7][18]*SK_MY[4]);
            Kfusion[8] = SK_MY[0]*(P[8][20] + P[8][0]*SH_MAG[2] + P[8][1]*SH_MAG[1] + P[8][2]*SH_MAG[0] - P[8][3]*SK_MY[2] - P[8][17]*SK_MY[1] - P[8][16]*SK_MY[3] + P[8][18]*SK_MY[4]);
            Kfusion[9] = SK_MY[0]*(P[9][20] + P[9][0]*SH_MAG[2] + P[9][1]*SH_MAG[1] + P[9][2]*SH_MAG[0] - P[9][3]*SK_MY[2] - P[9][17]*SK_MY[1] - P[9][16]*SK_MY[3] + P[9][18]*SK_MY[4]);

            if (!inhibitDelAngBiasStates) {
                Kfusion[10] = SK_MY[0]*(P[10][20] + P[10][0]*SH_MAG[2] + P[10][1]*SH_MAG[1] + P[10][2]*SH_MAG[0] - P[10][3]*SK_MY[2] - P[10][17]*SK_MY[1] - P[10][16]*SK_MY[3] + P[10][18]*SK_MY[4]);
                Kfusion[11] = SK_MY[0]*(P[11][20] + P[11][0]*SH_MAG[2] + P[11][1]*SH_MAG[1] + P[11][2]*SH_MAG[0] - P[11][3]*SK_MY[2] - P[11][17]*SK_MY[1] - P[11][16]*SK_MY[3] + P[11][18]*SK_MY[4]);
                Kfusion[12] = SK_MY[0]*(P[12][20] + P[12][0]*SH_MAG[2] + P[12][1]*SH_MAG[1] + P[12][2]*SH_MAG[0] - P[12][3]*SK_MY[2] - P[12][17]*SK_MY[1] - P[12][16]*SK_MY[3] + P[12][18]*SK_MY[4]);
            } else {
                // zero indexes 10 to 12
                zero_range(&Kfusion[0], 10, 12);
            }

            if (!inhibitDelVelBiasStates) {
                for (uint8_t index = 0; index < 3; index++) {
                    const uint8_t stateIndex = index + 13;
                    if (!dvelBiasAxisInhibit[index]) {
                        Kfusion[stateIndex] = SK_MY[0]*(P[stateIndex][20] + P[stateIndex][0]*SH_MAG[2] + P[stateIndex][1]*SH_MAG[1] + P[stateIndex][2]*SH_MAG[0] - P[stateIndex][3]*SK_MY[2] - P[stateIndex][17]*SK_MY[1] - P[stateIndex][16]*SK_MY[3] + P[stateIndex][18]*SK_MY[4]);
                    } else {
                        Kfusion[stateIndex] = 0.0f;
                    }
                }
            } else {
                // zero indexes 13 to 15
                zero_range(&Kfusion[0], 13, 15);
            }

            // zero Kalman gains to inhibit magnetic field state estimation
            if (!inhibitMagStates) {
                Kfusion[16] = SK_MY[0]*(P[16][20] + P[16][0]*SH_MAG[2] + P[16][1]*SH_MAG[1] + P[16][2]*SH_MAG[0] - P[16][3]*SK_MY[2] - P[16][17]*SK_MY[1] - P[16][16]*SK_MY[3] + P[16][18]*SK_MY[4]);
                Kfusion[17] = SK_MY[0]*(P[17][20] + P[17][0]*SH_MAG[2] + P[17][1]*SH_MAG[1] + P[17][2]*SH_MAG[0] - P[17][3]*SK_MY[2] - P[17][17]*SK_MY[1] - P[17][16]*SK_MY[3] + P[17][18]*SK_MY[4]);
                Kfusion[18] = SK_MY[0]*(P[18][20] + P[18][0]*SH_MAG[2] + P[18][1]*SH_MAG[1] + P[18][2]*SH_MAG[0] - P[18][3]*SK_MY[2] - P[18][17]*SK_MY[1] - P[18][16]*SK_MY[3] + P[18][18]*SK_MY[4]);
                Kfusion[19] = SK_MY[0]*(P[19][20] + P[19][0]*SH_MAG[2] + P[19][1]*SH_MAG[1] + P[19][2]*SH_MAG[0] - P[19][3]*SK_MY[2] - P[19][17]*SK_MY[1] - P[19][16]*SK_MY[3] + P[19][18]*SK_MY[4]);
                Kfusion[20] = SK_MY[0]*(P[20][20] + P[20][0]*SH_MAG[2] + P[20][1]*SH_MAG[1] + P[20][2]*SH_MAG[0] - P[20][3]*SK_MY[2] - P[20][17]*SK_MY[1] - P[20][16]*SK_MY[3] + P[20][18]*SK_MY[4]);
                Kfusion[21] = SK_MY[0]*(P[21][20] + P[21][0]*SH_MAG[2] + P[21][1]*SH_MAG[1] + P[21][2]*SH_MAG[0] - P[21][3]*SK_MY[2] - P[21][17]*SK_MY[1] - P[21][16]*SK_MY[3] + P[21][18]*SK_MY[4]);
            } else {
                // zero indexes 16 to 21
                zero_range(&Kfusion[0], 16, 21);
            }

            // zero Kalman gains to inhibit wind state estimation
            if (!inhibitWindStates && !treatWindStatesAsTruth) {
                Kfusion[22] = SK_MY[0]*(P[22][20] + P[22][0]*SH_MAG[2] + P[22][1]*SH_MAG[1] + P[22][2]*SH_MAG[0] - P[22][3]*SK_MY[2] - P[22][17]*SK_MY[1] - P[22][16]*SK_MY[3] + P[22][18]*SK_MY[4]);
                Kfusion[23] = SK_MY[0]*(P[23][20] + P[23][0]*SH_MAG[2] + P[23][1]*SH_MAG[1] + P[23][2]*SH_MAG[0] - P[23][3]*SK_MY[2] - P[23][17]*SK_MY[1] - P[23][16]*SK_MY[3] + P[23][18]*SK_MY[4]);
            } else {
                // zero indexes 22 to 23
                zero_range(&Kfusion[0], 22, 23);
            }

            // set flags to indicate to other processes that fusion has been performed and is required on the next frame
            // this can be used by other fusion processes to avoid fusing on the same frame as this expensive step
            magFusePerformed = true;
        }
        else if (obsIndex == 2) // we are now fusing the Z measurement
        {
            // calculate observation jacobians
            for (uint8_t i = 0; i<=stateIndexLim; i++) H_MAG[i] = 0.0f;
            H_MAG[0] = SH_MAG[1];
            H_MAG[1] = -SH_MAG[2];
            H_MAG[2] = SH_MAG[7] + SH_MAG[8] - 2.0f*magD*q2;
            H_MAG[3] = SH_MAG[0];
            H_MAG[16] = 2.0f*q0*q2 + 2.0f*q1*q3;
            H_MAG[17] = 2.0f*q2*q3 - 2.0f*q0*q1;
            H_MAG[18] = SH_MAG[3] - SH_MAG[4] - SH_MAG[5] + SH_MAG[6];
            H_MAG[19] = 0.0f;
            H_MAG[20] = 0.0f;
            H_MAG[21] = 1.0f;

            // calculate Kalman gain
            const Vector5 SK_MZ {
                1.0f / varInnovMag[2],
                SH_MAG[3] - SH_MAG[4] - SH_MAG[5] + SH_MAG[6],
                SH_MAG[7] + SH_MAG[8] - 2.0f*magD*q2,
                2.0f*q0*q1 - 2.0f*q2*q3,
                2.0f*q0*q2 + 2.0f*q1*q3
            };

            Kfusion[0] = SK_MZ[0]*(P[0][21] + P[0][0]*SH_MAG[1] - P[0][1]*SH_MAG[2] + P[0][3]*SH_MAG[0] + P[0][2]*SK_MZ[2] + P[0][18]*SK_MZ[1] + P[0][16]*SK_MZ[4] - P[0][17]*SK_MZ[3]);
            Kfusion[1] = SK_MZ[0]*(P[1][21] + P[1][0]*SH_MAG[1] - P[1][1]*SH_MAG[2] + P[1][3]*SH_MAG[0] + P[1][2]*SK_MZ[2] + P[1][18]*SK_MZ[1] + P[1][16]*SK_MZ[4] - P[1][17]*SK_MZ[3]);
            Kfusion[2] = SK_MZ[0]*(P[2][21] + P[2][0]*SH_MAG[1] - P[2][1]*SH_MAG[2] + P[2][3]*SH_MAG[0] + P[2][2]*SK_MZ[2] + P[2][18]*SK_MZ[1] + P[2][16]*SK_MZ[4] - P[2][17]*SK_MZ[3]);
            Kfusion[3] = SK_MZ[0]*(P[3][21] + P[3][0]*SH_MAG[1] - P[3][1]*SH_MAG[2] + P[3][3]*SH_MAG[0] + P[3][2]*SK_MZ[2] + P[3][18]*SK_MZ[1] + P[3][16]*SK_MZ[4] - P[3][17]*SK_MZ[3]);
            Kfusion[4] = SK_MZ[0]*(P[4][21] + P[4][0]*SH_MAG[1] - P[4][1]*SH_MAG[2] + P[4][3]*SH_MAG[0] + P[4][2]*SK_MZ[2] + P[4][18]*SK_MZ[1] + P[4][16]*SK_MZ[4] - P[4][17]*SK_MZ[3]);
            Kfusion[5] = SK_MZ[0]*(P[5][21] + P[5][0]*SH_MAG[1] - P[5][1]*SH_MAG[2] + P[5][3]*SH_MAG[0] + P[5][2]*SK_MZ[2] + P[5][18]*SK_MZ[1] + P[5][16]*SK_MZ[4] - P[5][17]*SK_MZ[3]);
            Kfusion[6] = SK_MZ[0]*(P[6][21] + P[6][0]*SH_MAG[1] - P[6][1]*SH_MAG[2] + P[6][3]*SH_MAG[0] + P[6][2]*SK_MZ[2] + P[6][18]*SK_MZ[1] + P[6][16]*SK_MZ[4] - P[6][17]*SK_MZ[3]);
            Kfusion[7] = SK_MZ[0]*(P[7][21] + P[7][0]*SH_MAG[1] - P[7][1]*SH_MAG[2] + P[7][3]*SH_/ GPS modules are rather too optimistic about their
        // accuracy. Set to min of 5 degrees here to prevent
        // the user constantly receiving warnings about high
        // normalised yaw innovations
        const ftype min_yaw_accuracy_deg = 5.0f;
        yaw_accuracy_deg = MAX(yaw_accuracy_deg, min_yaw_accuracy_deg);
        writeEulerYawAngle(radians(yaw_deg), radians(yaw_accuracy_deg), yaw_time_ms, 2);
    }
}

// read the delta angle and corresponding time interval from the IMU
// return false if data is not available
bool NavEKF3_core::readDeltaAngle(uint8_t ins_index, Vector3F &dAng, ftype &dAngDT) {
    const auto &ins = dal.ins();

    if (ins_index < ins.get_gyro_count()) {
        Vector3f dAngF;
        float dAngDTF;
        ins.get_delta_angle(ins_index, dAngF, dAngDTF);
        dAng = dAngF.toftype();
        dAngDT = dAngDTF;
        return true;
    }
    return false;
}


/********************************************************
*                  Height Measurements                  *
********************************************************/

// check for new pressure altitude measurement data and update stored measurement if available
void NavEKF3_core::readBaroData()
{
    // check to see if baro measurement has changed so we know if a new measurement has arrived
    // limit update rate to avoid overflowing the FIFO buffer
    const auto &baro = dal.baro();
    if (baro.get_last_update(selected_baro) - lastBaroReceived_ms > frontend->sensorIntervalMin_ms) {

        baroDataNew.hgt = baro.get_altitude(selected_baro);

        // time stamp used to check for new measurement
        lastBaroReceived_ms = baro.get_last_update(selected_baro);

        // estimate of time height measurement was taken, allowing for delays
        baroDataNew.time_ms = lastBaroReceived_ms - frontend->_hgtDelay_ms;

        // Correct for the average intersampling delay due to the filter updaterate
        baroDataNew.time_ms -= localFilterTimeStep_ms/2;

        // Prevent time delay exceeding age of oldest IMU data in the buffer
        baroDataNew.time_ms = MAX(baroDataNew.time_ms,imuDataDelayed.time_ms);

        // save baro measurement to buffer to be fused later
        storedBaro.push(baroDataNew);
    }
}

// calculate filtered offset between baro height measurement and EKF height estimate
// offset should be subtracted from baro measurement to match filter estimate
// offset is used to enable reversion to baro from alternate height data source
void NavEKF3_core::calcFiltBaroOffset()
{
    // Apply a first order LPF with spike protection
    baroHgtOffset += 0.1f * constrain_ftype(baroDataDelayed.hgt + stateStruct.position.z - baroHgtOffset, -5.0f, 5.0f);
}

// correct the height of the EKF origin to be consistent with GPS Data using a Bayes filter.
void NavEKF3_core::correctEkfOriginHeight()
{
    // Estimate the WGS-84 height of the EKF's origin using a Bayes filter

    // calculate the variance of our a-priori estimate of the ekf origin height
    ftype deltaTime = constrain_ftype(0.001f * (imuDataDelayed.time_ms - lastOriginHgtTime_ms), 0.0, 1.0);
    if (activeHgtSource == AP_NavEKF_Source::SourceZ::BARO) {
        // Use the baro drift rate
        const ftype baroDriftRate = 0.05;
        ekfOriginHgtVar += sq(baroDriftRate * deltaTime);
    } else if (activeHgtSource == AP_NavEKF_Source::SourceZ::RANGEFINDER) {
        // use the worse case expected terrain gradient and vehicle horizontal speed
        const ftype maxTerrGrad = 0.25;
        ekfOriginHgtVar += sq(maxTerrGrad * stateStruct.velocity.xy().length() * deltaTime);
    } else {
        // by definition our height source is absolute so cannot run this filter
        return;
    }
    lastOriginHgtTime_ms = imuDataDelayed.time_ms;

    // calculate the observation variance assuming EKF error relative to datum is independent of GPS observation error
    // when not using GPS as height source
    ftype originHgtObsVar = sq(gpsHgtAccuracy) + P[9][9];

    // calculate the correction gain
    ftype gain = ekfOriginHgtVar / (ekfOriginHgtVar + originHgtObsVar);

    // calculate the innovation
    ftype innovation = - stateStruct.position.z - gpsDataDelayed.hgt;

    // check the innovation variance ratio
    ftype ratio = sq(innovation) / (ekfOriginHgtVar + originHgtObsVar);

    // correct the EKF origin and variance estimate if the innovation is less than 5-sigma
    if (ratio < 25.0f && gpsAccuracyGood) {
        ekfGpsRefHgt -= (double)(gain * innovation);
        ekfOriginHgtVar -= MAX(gain * ekfOriginHgtVar , 0.0f);
    }
}

/********************************************************
*                Air Speed Measurements                 *
********************************************************/

// check for new airspeed data and update stored measurements if available
void NavEKF3_core::readAirSpdData()
{
    const float EAS2TAS = dal.get_EAS2TAS();
    // if airspeed reading is valid and is set by the user to be used and has been updated then
    // we take a new reading, convert from EAS to TAS and set the flag letting other functions
    // know a new measurement is available

    if (useAirspeed()) {
        const auto *airspeed = dal.airspeed();
        if (airspeed &&
            (airspeed->last_update_ms(selected_airspeed) - timeTasReceived_ms) > frontend->sensorIntervalMin_ms) {
            tasDataNew.allowFusion = airspeed->healthy(selected_airspeed) && airspeed->use(selected_airspeed);
            if (tasDataNew.allowFusion) {
                tasDataNew.tas = airspeed->get_airspeed(selected_airspeed) * EAS2TAS;
                timeTasReceived_ms = airspeed->last_update_ms(selected_airspeed);
                tasDataNew.time_ms = timeTasReceived_ms - frontend->tasDelay_ms;
                tasDataNew.tasVariance = sq(MAX(frontend->_easNoise * EAS2TAS, 0.5f));
                // Correct for the average intersampling delay due to the filter update rate
                tasDataNew.time_ms -= localFilterTimeStep_ms/2;
                // Save data into the buffer to be fused when the fusion time horizon catches up with it
                storedTAS.push(tasDataNew);
            }
        }
        // Check the buffer for measurements that have been overtaken by the fusion time horizon and need to be fused
        tasDataToFuse = storedTAS.recall(tasDataDelayed,imuDataDelayed.time_ms);
    } else {
        if (is_positive(defaultAirSpeed)) {
            // this is the preferred method with the autopilot providing a model based airspeed estimate
            if (imuDataDelayed.time_ms - prevTasStep_ms > 200 ) {
                tasDataDelayed.tas = defaultAirSpeed * EAS2TAS;
                tasDataDelayed.tasVariance = MAX(defaultAirSpeedVariance, sq(MAX(frontend->_easNoise, 0.5f)));
                tasDataToFuse = true;
                tasDataDelayed.allowFusion = true;
                tasDataDelayed.time_ms = imuDataDelayed.time_ms;
            } else {
                tasDataToFuse = false;
                tasDataDelayed.allowFusion = false;
            }
        } else if (lastAspdEstIsValid && !windStateIsObservable) {
            // this uses the last airspeed estimated before dead reckoning started and
            // wind states became unobservable
            if (lastAspdEstIsValid && imuDataDelayed.time_ms - prevTasStep_ms > 200) {
                tasDataDelayed.tas = lastAirspeedEstimate;
                // this airspeed estimate has a lot of uncertainty
                tasDataDelayed.tasVariance = sq(MAX(MAX(frontend->_easNoise, 0.5f), 0.5f * lastAirspeedEstimate));
                tasDataToFuse = true;
                tasDataDelayed.allowFusion = true;
                tasDataDelayed.time_ms = imuDataDelayed.time_ms;
            } else {
                tasDataToFuse = false;
                tasDataDelayed.allowFusion = false;
            }
        }
    }
}

#if EK3_FEATURE_BEACON_FUSION
/********************************************************
*              Range Beacon Measurements                *
********************************************************/

// check for new range beacon data and push to data buffer if available
void NavEKF3_core::readRngBcnData()
{
    // check that arrays are large enough
    static_assert(ARRAY_SIZE(rngBcn.lastTime_ms) >= AP_BEACON_MAX_BEACONS, "lastTimeRngBcn_ms should have at least AP_BEACON_MAX_BEACONS elements");

    // get the location of the beacon data
    const AP_DAL_Beacon *beacon = dal.beacon();

    // exit immediately if no beacon object
    if (beacon == nullptr) {
        return;
    }

    // get the number of beacons in use
    rngBcn.N = MIN(beacon->count(), ARRAY_SIZE(rngBcn.lastTime_ms));

    // search through all the beacons for new data and if we find it stop searching and push the data into the observation buffer
    bool newDataPushed = false;
    uint8_t numRngBcnsChecked = 0;
    // start the search one index up from where we left it last time
    uint8_t index = rngBcn.lastChecked;
    while (!newDataPushed && (numRngBcnsChecked < rngBcn.N)) {
        // track the number of beacons checked
        numRngBcnsChecked++;

        // move to next beacon, wrap index if necessary
        index++;
        if (index >= rngBcn.N) {
            index = 0;
        }

        // check that the beacon is healthy and has new data
        if (beacon->beacon_healthy(index) && beacon->beacon_last_update_ms(index) != rngBcn.lastTime_ms[index]) {
            rng_bcn_elements rngBcnDataNew = {};

            // set the timestamp, correcting for measurement delay and average intersampling delay due to the filter update rate
            rngBcn.lastTime_ms[index] = beacon->beacon_last_update_ms(index);
            rngBcnDataNew.time_ms = rngBcn.lastTime_ms[index] - frontend->_rngBcnDelay_ms - localFilterTimeStep_ms/2;

            // set the range noise
            // TODO the range library should provide the noise/accuracy estimate for each beacon
            rngBcnDataNew.rngErr = frontend->_rngBcnNoise;

            // set the range measurement
            rngBcnDataNew.rng = beacon->beacon_distance(index);

            // set the beacon position
            rngBcnDataNew.beacon_posNED = beacon->beacon_position(index).toftype();

            // identify the beacon identifier
            rngBcnDataNew.beacon_ID = index;

            // indicate we have new data to push to the buffer
            newDataPushed = true;

            // update the last checked index
            rngBcn.lastChecked = index;

            // Save data into the buffer to be fused when the fusion time horizon catches up with it
            rngBcn.storedRange.push(rngBcnDataNew);
        }
    }

    // Check if the beacon system has returned a 3D fix
    Vector3f bp;
    float bperr;
    if (beacon->get_vehicle_position_ned(bp, bperr)) {
        rngBcn.last3DmeasTime_ms = imuSampleTime_ms;
    }
    rngBcn.vehiclePosNED = bp.toftype();
    rngBcn.vehiclePosErr = bperr;

    // Check if the range beacon data can be used to align the vehicle position
    if ((imuSampleTime_ms - rngBcn.last3DmeasTime_ms < 250) && (rngBcn.vehiclePosErr < 1.0f) && rngBcn.alignmentCompleted) {
        // check for consistency between the position reported by the beacon and the position from the 3-State alignment filter
        const ftype posDiffSq = sq(rngBcn.receiverPos.x - rngBcn.vehiclePosNED.x) + sq(rngBcn.receiverPos.y - rngBcn.vehiclePosNED.y);
        const ftype posDiffVar = sq(rngBcn.vehiclePosErr) + rngBcn.receiverPosCov[0][0] + rngBcn.receiverPosCov[1][1];
        if (posDiffSq < 9.0f * posDiffVar) {
            rngBcn.goodToAlign = true;
            // Set the EKF origin and magnetic field declination if not previously set
            if (!validOrigin && (PV_AidingMode != AID_ABSOLUTE)) {
                // get origin from beacon system
                Location origin_loc;
                if (beacon->get_origin(origin_loc)) {
                    setOriginLLH(origin_loc);

                    // set the NE earth magnetic field states using the published declination
                    // and set the corresponding variances and covariances
                    alignMagStateDeclination();

                    // Set the uncertainty of the origin height
                    ekfOriginHgtVar = sq(rngBcn.vehiclePosErr);
                }
            }
        } else {
            rngBcn.goodToAlign = false;
        }
    } else {
        rngBcn.goodToAlign = false;
    }

    // Check the buffer for measurements that have been overtaken by the fusion time horizon and need to be fused
    rngBcn.dataToFuse = rngBcn.storedRange.recall(rngBcn.dataDelayed, imuDataDelayed.time_ms);

    // Correct the range beacon earth frame origin for estimated offset relative to the EKF earth frame origin
    if (rngBcn.dataToFuse) {
        rngBcn.dataDelayed.beacon_posNED.x += rngBcn.posOffsetNED.x;
        rngBcn.dataDelayed.beacon_posNED.y += rngBcn.posOffsetNED.y;
    }

}
#endif  // EK3_FEATURE_BEACON_FUSION

/********************************************************
*              Independant yaw sensor measurements      *
********************************************************/

void NavEKF3_core::writeEulerYawAngle(float yawAngle, float yawAngleErr, uint32_t timeStamp_ms, uint8_t type)
{
    // limit update rate to maximum allowed by sensor buffers and fusion process
    // don't try to write to buffer until the filter has been initialised
    if (((timeStamp_ms - yawMeasTime_ms) < frontend->sensorIntervalMin_ms) || !statesInitialised) {
        return;
    }

    yawAngDataNew.yawAng = yawAngle;
    yawAngDataNew.yawAngErr = yawAngleErr;
    if (type == 2) {
        yawAngDataNew.order = rotationOrder::TAIT_BRYAN_321;
    } else if (type == 1) {
        yawAngDataNew.order = rotationOrder::TAIT_BRYAN_312;
    } else {
        return;
    }
    yawAngDataNew.time_ms = timeStamp_ms;

    storedYawAng.push(yawAngDataNew);

    yawMeasTime_ms = timeStamp_ms;
}

// Writes the default equivalent airspeed and 1-sigma uncertainty in m/s to be used in forward flight if a measured airspeed is required and not available.
void NavEKF3_core::writeDefaultAirSpeed(float airspeed, float uncertainty)
{
    defaultAirSpeed = airspeed;
    defaultAirSpeedVariance = sq(uncertainty);
}

/********************************************************
*            External Navigation Measurements           *
********************************************************/

void NavEKF3_core::writeExtNavData(const Vector3f &pos, const Quaternion &quat, float posErr, float angErr, uint32_t timeStamp_ms, uint16_t delay_ms, uint32_t resetTime_ms)
{
#if EK3_FEATURE_EXTERNAL_NAV
    // protect against NaN
    if (pos.is_nan() || isnan(posErr)) {
        return;
    }

    // limit update rate to maximum allowed by sensor buffers and fusion process
    // don't try to write to buffer until the filter has been initialised
    if (((timeStamp_ms - extNavMeasTime_ms) < frontend->extNavIntervalMin_ms) || !statesInitialised) {
        return;
    } else {
        extNavMeasTime_ms = timeStamp_ms;
    }

    ext_nav_elements extNavDataNew {};

    if (resetTime_ms != extNavLastPosResetTime_ms) {
        extNavDataNew.posReset = true;
        extNavLastPosResetTime_ms = resetTime_ms;
    } else {
        extNavDataNew.posReset = false;
    }

    extNavDataNew.pos = pos.toftype();
    extNavDataNew.posErr = posErr;

    // calculate timestamp
    timeStamp_ms = timeStamp_ms - delay_ms;
    // Correct for the average intersampling delay due to the filter update rate
    timeStamp_ms -= localFilterTimeStep_ms/2;
    // Prevent time delay exceeding age of oldest IMU data in the buffer
    timeStamp_ms = MAX(timeStamp_ms, imuDataDelayed.time_ms);
    extNavDataNew.time_ms = timeStamp_ms;

    // store position data to buffer
    storedExtNav.push(extNavDataNew);

    // protect against attitude or angle being NaN
    if (!quat.is_nan() && !isnan(angErr)) {
        // extract yaw from the attitude
        ftype roll_rad, pitch_rad, yaw_rad;
        quat.to_euler(roll_rad, pitch_rad, yaw_rad);
        yaw_elements extNavYawAngDataNew;
        extNavYawAngDataNew.yawAng = yaw_rad;
        extNavYawAngDataNew.yawAngErr = MAX(angErr, radians(5.0f)); // ensure yaw accuracy is no better than 5 degrees (some callers may send zero)
        extN#pragma once

#include "Display.h"
#include "Display_Backend.h"
#include <AP_HAL/I2CDevice.h>

#define SH1106_COLUMNS 132		// display columns
#define SH1106_ROWS 64		    // display rows
#define SH1106_ROWS_PER_PAGE 8

class Display_SH1106_I2C: public Display_Backend {

public:

    static Display_SH1106_I2C *probe(AP_HAL::OwnPtr<AP_HAL::Device> dev);

    void hw_update() override;
    void set_pixel(uint16_t x, uint16_t y) override;
    void clear_pixel(uint16_t x, uint16_t y) override;
    void clear_screen() override;

protected:

    Display_SH1106_I2C(AP_HAL::OwnPtr<AP_HAL::Device> dev);
    ~Display_SH1106_I2C() override;

private:

    bool hw_init() override;

    void _timer();

    AP_HAL::OwnPtr<AP_HAL::Device> _dev;
    uint8_t _displaybuffer[SH1106_COLUMNS * SH1106_ROWS_PER_PAGE];
    bool _need_hw_update;

};
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             /*
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include "AP_Notify_config.h"

#if AP_NOTIFY_GPIO_LED_1_ENABLED

#include "GPIO_LED_1.h"

#include <AP_HAL/HAL.h>
#include "AP_Notify.h"

#ifndef AP_NOTIFY_GPIO_LED_1_PIN
#error "define AP_NOTIFY_GPIO_LED_1_PIN"
#endif

extern const AP_HAL::HAL& hal;

bool GPIO_LED_1::init(void)
{
    // when HAL_GPIO_LED_ON is 0 then we must not use pinMode()
    // as it could remove the OPENDRAIN attribute on the pin
#if HAL_GPIO_LED_ON != 0
    hal.gpio->pinMode(AP_NOTIFY_GPIO_LED_1_PIN, HAL_GPIO_OUTPUT);
#endif
    hal.gpio->write(AP_NOTIFY_GPIO_LED_1_PIN, HAL_GPIO_LED_OFF);
    return true;
}

/*
  main update function called at 50Hz
 */
void GPIO_LED_1::update(void)
{
    uint32_t new_pattern;
    if (AP_Notify::flags.initialising) {
        new_pattern = INITIALIZING;
    } else if (AP_Notify::flags.armed) {
        new_pattern = ARMED;
    } else if (AP_Notify::flags.pre_arm_check) {
        new_pattern = READY_TO_ARM;
    } else {
        new_pattern = NOT_READY_TO_ARM;
    }
    if (new_pattern != current_pattern) {
        next_bit = 0;
        current_pattern = new_pattern;
        last_timestep_ms = 0;
    }

    const uint32_t now_ms = AP_HAL::millis();
    if (now_ms - last_timestep_ms < 100) {
        return;
    }
    last_timestep_ms = now_ms;

    const auto new_state = (current_pattern & (1U<<next_bit)) ? HAL_GPIO_LED_ON : HAL_GPIO_LED_OFF;
    hal.gpio->write(AP_NOTIFY_GPIO_LED_1_PIN, new_state);
    next_bit++;
    if (next_bit > 31) {
        next_bit = 0;
    }
}

#endif  // AP_NOTIFY_GPIO_LED_1_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     /*
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
#pragma once

#include "AP_Notify_config.h"

#if AP_NOTIFY_GPIO_LED_1_ENABLED

#include <AP_Common/AP_Common.h>
#include <AP_HAL/AP_HAL_Boards.h>

#include "NotifyDevice.h"

class GPIO_LED_1 : public NotifyDevice
{
public:
    // initialise the LED driver
    bool init(void) override;

    // should be called at 50Hz
    void update(void) override;

private:

    // left-to-right, each bit represents 100ms
    static const uint32_t INITIALIZING = 0b10101010101010101010101010101010UL;
    static const uint32_t NOT_READY_TO_ARM = 0b11111111000000001111111100000000UL;
    static const uint32_t READY_TO_ARM = 0b11111111111111100000000000000000UL;
    static const uint32_t ARMED = 0b11111111111111111111111111111111UL;

    uint32_t current_pattern = INITIALIZING;
    uint32_t last_timestep_ms;
    uint8_t next_bit;
};

#endif  // AP_NOTIFY_GPIO_LED_1_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     /*
  IS31FL3195 I2C driver
*/
/*
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/* LED driver for IS31FL3195 */

#include "IS31FL3195.h"

#if AP_NOTIFY_IS31FL3195_ENABLED

#include <utility>

#include <AP_HAL/AP_HAL.h>

extern const AP_HAL::HAL& hal;

#define IS31FL3195_LED_BRIGHT  255    // full brightness
#define IS31FL3195_LED_MEDIUM  170    // medium brightness
#define IS31FL3195_LED_DIM     85     // dim
#define IS31FL3195_LED_OFF     0      // off

#define REGISTER_MAGIC_VLAUE 0xc5

enum class Register {
    PRODUCT_ID       = 0x00,  // not really product ID, rather address of this LED
    SHUTDOWN_CONTROL = 0x01,
    OUT1             = 0x10,
    OUT2             = 0x21,
    OUT3             = 0x32,
    COLOR_UPDATE     = 0x50,
    RESET            = 0x5f,
};

IS31FL3195::IS31FL3195(uint8_t bus, uint8_t addr)
    : RGBLed(IS31FL3195_LED_OFF, IS31FL3195_LED_BRIGHT, IS31FL3195_LED_MEDIUM, IS31FL3195_LED_DIM)
    , _bus(bus)
    , _addr(addr)
{
}

bool IS31FL3195::init(void)
{
    _dev = std::move(hal.i2c_mgr->get_device(_bus, _addr));
    if (!_dev) {
        return false;
    }
    WITH_SEMAPHORE(_dev->get_semaphore());

    _dev->set_retries(10);

    // check the PRODUCT_ID register to check we have found the device. The product ID register
    // should contain the 8 bit I2C address
    uint8_t v;
    if (!_dev->read_registers((uint8_t)Register::PRODUCT_ID, &v, 1) || v != _addr<<1U) {
        return false;
    }
    
    // reset the device and probe to see if this device looks like an IS31FL3195:
    if (!_dev->write_register((uint8_t)Register::RESET, REGISTER_MAGIC_VLAUE)) {
        return false;
    }

    // reset delay; unsure if this is really required:
    hal.scheduler->delay_microseconds(100);

    // check SHUTDOWN_CONTROL as an additional ID after reset
    if (!_dev->read_registers((uint8_t)Register::SHUTDOWN_CONTROL, &v, 1) || v != 0xf0) {
        return false;
    }
    
    // come out of shutdown mode
    if (!_dev->write_register((uint8_t)Register::SHUTDOWN_CONTROL, 0xf1)) {
        return false;
    }
    
    _dev->set_retries(1);

    // update at 50Hz
    _dev->register_periodic_callback(20000, FUNCTOR_BIND_MEMBER(&IS31FL3195::_timer, void));

    return true;
}

// set_rgb - set color as a combination of red, green and blue values
bool IS31FL3195::hw_set_rgb(uint8_t red, uint8_t green, uint8_t blue)
{
    rgb[0] = red;
    rgb[1] = green;
    rgb[2] = blue;
    _need_update = true;
    return true;
}

void IS31FL3195::_timer(void)
{
    if (!_need_update) {
        return;
    }
    _need_update = false;

    // write color values
    _dev->write_register(uint8_t(Register::OUT1), rgb[0]);
    _dev->write_register(uint8_t(Register::OUT2), rgb[1]);
    _dev->write_register(uint8_t(Register::OUT3), rgb[2]);
    _dev->write_register(uint8_t(Register::COLOR_UPDATE), REGISTER_MAGIC_VLAUE);
}

#endif  // AP_NOTIFY_IS31FL3195_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            /*
   IS31FL3195 I2C driver

   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.

   Datasheet: https://www.lumissil.com/assets/pdf/core/IS31FL3195_DS.pdf

 */
#pragma once

#include "AP_Notify_config.h"

#if AP_NOTIFY_IS31FL3195_ENABLED

#include <AP_HAL/I2CDevice.h>
#include "RGBLed.h"

class IS31FL3195 : public RGBLed
{
public:
    IS31FL3195(uint8_t bus, uint8_t addr);
    bool init(void) override;
protected:
    bool hw_set_rgb(uint8_t r, uint8_t g, uint8_t b) override;

private:
    AP_HAL::OwnPtr<AP_HAL::I2CDevice> _dev;
    uint8_t _bus;
    uint8_t _addr;

    void _timer(void);
    bool _need_update;
    uint8_t rgb[3];
};

#endif  // AP_NOTIFY_IS31FL3195_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        /*
  LP5562 I2C driver
*/
/*
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/* LED driver for LP5562 */

#include "LP5562.h"

#if AP_NOTIFY_LP5562_ENABLED

#include <utility>

#include <AP_HAL/AP_HAL.h>

extern const AP_HAL::HAL& hal;

#define LP5562_LED_BRIGHT  255    // full brightness
#define LP5562_LED_MEDIUM  170    // medium brightness
#define LP5562_LED_DIM     85     // dim
#define LP5562_LED_OFF     0      // off

enum class Register {
    ENABLE  = 0x00,
    B_PWM   = 0x02,
    G_PWM   = 0x03,
    R_PWM   = 0x04,
    B_CURRENT= 0x05,
    G_CURRENT= 0x06,
    R_CURRENT= 0x07,
    CONFIG  = 0x08,
    RESET   = 0x0D,
    LED_MAP = 0x70,
};

LP5562::LP5562(uint8_t bus, uint8_t addr)
    : RGBLed(LP5562_LED_OFF, LP5562_LED_BRIGHT, LP5562_LED_MEDIUM, LP5562_LED_DIM)
    , _bus(bus)
    , _addr(addr)
{
}

bool LP5562::init(void)
{
    _dev = std::move(hal.i2c_mgr->get_device(_bus, _addr));
    if (!_dev) {
        return false;
    }
    WITH_SEMAPHORE(_dev->get_semaphore());

    _dev->set_retries(10);

    // reset the device and probe to see if this device looks like an LP5662:
    if (!_dev->write_register((uint8_t)Register::RESET, 0xff)) {
        return false;
    }

    // reset delay; unsure if this is really required:
    hal.scheduler->delay_microseconds(100);

    // check the GBR PWM control registers have their reset values:
    for (uint8_t i=(uint8_t)Register::B_CURRENT; i<=(uint8_t)Register::R_CURRENT; i++) {
        uint8_t value;
        if (!_dev->read_registers(i, &value, 1)) {
            return false;
        }
        if (value != 0xAF) {  // 0xAF is the startup value for these registers per datasheet
            return false;
        }
    }

    //  values here are taken literally from 7.3.2 in the datasheet.
    //  See the simulator for register breakdown.

    // chip enable:
    if (!_dev->write_register((uint8_t)Register::ENABLE, 0b1000000)) {
        return false;
    }

    // start-up-delay:
    hal.scheduler->delay_microseconds(500);

    // use internal clock:
    if (!_dev->write_register((uint8_t)Register::CONFIG, 0b00000001)) {
        return false;
    }

    // set direct PWM control:
    if (!_dev->write_register((uint8_t)Register::LED_MAP, 0b00000000)) {
        return false;
    }

    _dev->set_retries(1);

    _dev->register_periodic_callback(20000, FUNCTOR_BIND_MEMBER(&LP5562::_timer, void));

    return true;
}

// set_rgb - set color as a combination of red, green and blue values
bool LP5562::hw_set_rgb(uint8_t red, uint8_t green, uint8_t blue)
{
    bgr[0] = blue;
    bgr[1] = green;
    bgr[2] = red;
    _need_update = true;
    return true;
}

void LP5562::_timer(void)
{
    if (!_need_update) {
        return;
    }
    _need_update = false;

    for (uint8_t i=0; i< ARRAY_SIZE(bgr); i++) {
        const uint8_t new_colour = bgr[i];
        const uint8_t last_sent = last_sent_bgr[i];
        if (new_colour == last_sent) {
            continue;
        }
        // note that new_colour is already scaled by supplying
        // brightness values in the constructor.

        // take advantage of the linear layout of the registers.  The
        // direct PWM registers start at 0x02 for blue:
        _dev->write_register((uint8_t)0x02 + i, new_colour);

        last_sent_bgr[i] = new_colour;
    }
}

#endif  // AP_NOTIFY_LP5562_ENABLED
                                                                                                                                                      /*
   LP5562 I2C driver

   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.

   Datasheet: https://www.ti.com/lit/ds/symlink/lp5562.pdf?ts=1680437709368&ref_url=https%253A%252F%252Fwww.ti.com%252Fproduct%252FLP5562

 */
#pragma once

#include "AP_Notify_config.h"

#if AP_NOTIFY_LP5562_ENABLED

#include <AP_HAL/I2CDevice.h>
#include "RGBLed.h"

class LP5562 : public RGBLed
{
public:
    LP5562(uint8_t bus, uint8_t addr);
    bool init(void) override;
protected:
    bool hw_set_rgb(uint8_t r, uint8_t g, uint8_t b) override;

private:
    AP_HAL::OwnPtr<AP_HAL::I2CDevice> _dev;
    uint8_t _bus;
    uint8_t _addr;

    void _timer(void);
    bool _need_update;
    uint8_t bgr[3];
    uint8_t last_sent_bgr[3];
};

#endif  // AP_NOTIFY_LP5562_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             /*
 * Copyright (C) 2015  Intel Corporation. All rights reserved.
 *
 * This file is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This file is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include "AP_Notify_config.h"

#if AP_NOTIFY_RCOUTPUTRGBLED_LED_ENABLED

#include "RCOutputRGBLed.h"

#include <AP_Math/AP_Math.h>
#include <SRV_Channel/SRV_Channel.h>

extern const AP_HAL::HAL& hal;

#define LED_OFF 0
#define LED_FULL_BRIGHT 255
#define LED_MEDIUM ((LED_FULL_BRIGHT / 5) * 4)
#define LED_DIM ((LED_FULL_BRIGHT / 5) * 2)

RCOutputRGBLed::RCOutputRGBLed(uint8_t red_channel, uint8_t green_channel, uint8_t blue_channel)
    : RCOutputRGBLed(red_channel, green_channel, blue_channel, LED_OFF,
                     LED_FULL_BRIGHT, LED_MEDIUM, LED_DIM)
{
}

RCOutputRGBLed::RCOutputRGBLed(uint8_t red_channel, uint8_t green_channel,
                               uint8_t blue_channel, uint8_t led_off,
                               uint8_t led_full, uint8_t led_medium,
                               uint8_t led_dim)
    : RGBLed(led_off, led_full, led_medium, led_dim)
    , _red_channel(red_channel)
    , _green_channel(green_channel)
    , _blue_channel(blue_channel)
{
}

bool RCOutputRGBLed::init()
{
    hal.rcout->enable_ch(_red_channel);
    hal.rcout->enable_ch(_green_channel);
    hal.rcout->enable_ch(_blue_channel);

    return true;
}

uint16_t RCOutputRGBLed::get_duty_cycle_for_color(const uint8_t color, const uint16_t usec_period) const
{
    return  usec_period * color / _led_bright;
}

#if AP_NOTIFY_RCOUTPUTRGBLEDINVERTED_LED_ENABLED
uint16_t RCOutputRGBLedInverted::get_duty_cycle_for_color(const uint8_t color, const uint16_t usec_period) const
{
    return  usec_period * (255 - color) / _led_bright;
}
#endif  // AP_NOTIFY_RCOUTPUTRGBLEDINVERTED_LED_ENABLED


bool RCOutputRGBLed::hw_set_rgb(uint8_t red, uint8_t green, uint8_t blue)
{
    const uint16_t freq_motor = hal.rcout->get_freq(0);
    const uint16_t freq = hal.rcout->get_freq(_red_channel);
    const uint16_t usec_period = hz_to_usec(freq);

    if (freq_motor != freq) {
        /*
         * keep at same frequency as the first RCOutput channel, some RCOutput
         * drivers can not operate in different frequency between channels
         */
        const uint32_t mask = 1 << _red_channel | 1 << _green_channel
                              | 1 << _blue_channel;
        hal.rcout->set_freq(mask, freq_motor);
    }

    uint16_t usec_duty = get_duty_cycle_for_color(red, usec_period);
    SRV_Channels::set_output_pwm_chan(_red_channel, usec_duty);

    usec_duty = get_duty_cycle_for_color(green, usec_period);
    SRV_Channels::set_output_pwm_chan(_green_channel, usec_duty);

    usec_duty = get_duty_cycle_for_color(blue, usec_period);
    SRV_Channels::set_output_pwm_chan(_blue_channel, usec_duty);

    return true;
}
#endif  // AP_NOTIFY_RCOUTPUTRGBLED_LED_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      