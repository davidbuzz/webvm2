/*
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include "AP_Proximity_Boundary_3D.h"

#define PROXIMITY_BOUNDARY_3D_TIMEOUT_MS 750 // we should check the 3D boundary faces after this many ms

/*
  Constructor. 
  This incorporates initialisation as well.
*/
AP_Proximity_Boundary_3D::AP_Proximity_Boundary_3D() 
{
    // initialise sector edge vector used for building the boundary fence
    init();
}

// initialise the boundary and sector_edge_vector array used for object avoidance
//   should be called if the sector_middle_deg or _sector_width_deg arrays are changed
void AP_Proximity_Boundary_3D::init()
{
    for (uint8_t layer=0; layer < PROXIMITY_NUM_LAYERS; layer++) {
        const float pitch = ((float)_pitch_middle_deg[layer]);
        for (uint8_t sector=0; sector < PROXIMITY_NUM_SECTORS; sector++) {
            const float angle_rad = ((float)_sector_middle_deg[sector]+(PROXIMITY_SECTOR_WIDTH_DEG/2.0f));
            _sector_edge_vector[layer][sector].offset_bearing(angle_rad, pitch, 100.0f);
            _boundary_points[layer][sector] = _sector_edge_vector[layer][sector] * PROXIMITY_BOUNDARY_DIST_DEFAULT;
        }
    }
}

// returns face corresponding to the provided yaw and (optionally) pitch
// pitch is the vertical body-frame angle (in degrees) to the obstacle (0=directly ahead, 90 is above the vehicle)
// yaw is the horizontal body-frame angle (in degrees) to the obstacle (0=directly ahead of the vehicle, 90 is to the right of the vehicle)
AP_Proximity_Boundary_3D::Face AP_Proximity_Boundary_3D::get_face(float pitch, float yaw) const
{
    const uint8_t sector = wrap_360(yaw + (PROXIMITY_SECTOR_WIDTH_DEG * 0.5f)) / 45.0f;
    const float pitch_limited = constrain_float(pitch, -75.0f, 74.9f);
    const uint8_t layer = (pitch_limited + 75.0f)/PROXIMITY_PITCH_WIDTH_DEG;
    return Face{layer, sector};
}

// Set the actual body-frame angle(yaw), pitch, and distance of the detected object.
// This method will also mark the sector and layer to be "valid",
// This distance can then be used for Obstacle Avoidance
// Assume detected obstacle is horizontal (zero pitch), if no pitch is passed
// prx_instance should be set to the proximity sensor backend instance number
void AP_Proximity_Boundary_3D::set_face_attributes(const Face &face, float pitch, float angle, float distance, uint8_t prx_instance)
{
    if (!face.valid()) {
        return;
    }

    // ignore update if another instance has provided a shorter distance within the last 0.2 seconds
    if ((prx_instance != _prx_instance[face.layer][face.sector]) && _distance_valid[face.layer][face.sector] && (_filtered_distance[face.layer][face.sector].get() < distance)) {
        // check if recent
        const uint32_t now_ms = AP_HAL::millis();
        if (now_ms - _last_update_ms[face.layer][face.sector] < PROXIMITY_FACE_RESET_MS) {
            return;
        }
    }

    _angle[face.layer][face.sector] = angle;
    _pitch[face.layer][face.sector] = pitch;
    _distance[face.layer][face.sector] = distance;
    _distance_valid[face.layer][face.sector] = true;
    _prx_instance[face.layer][face.sector] = prx_instance;

    // apply filter
    set_filtered_distance(face, distance);

    // update boundary used for simple avoidance
    update_boundary(face);
}

// apply a new cutoff_freq to low-pass filter
void AP_Proximity_Boundary_3D::apply_filter_freq(float cutoff_freq)
{
    for (uint8_t layer=0; layer < PROXIMITY_NUM_LAYERS; layer++) {
        for (uint8_t sector=0; sector < PROXIMITY_NUM_SECTORS; sector++) {
            _filtered_distance[layer][sector].set_cutoff_frequency(cutoff_freq);
        }
    }
}

// Apply low pass filter on the raw distance
void AP_Proximity_Boundary_3D::set_filtered_distance(const Face &face, float distance)
{
    if (!face.valid()) {
        return;
    }
    if (!is_equal(_filtered_distance[face.layer][face.sector].get_cutoff_freq(), _filter_freq)) {
        // cutoff freq has changed
        apply_filter_freq(_filter_freq);
    }

    const uint32_t now_ms = AP_HAL::millis();
    const uint32_t dt = now_ms - _last_update_ms[face.layer][face.sector];
    if (dt < PROXIMITY_FILT_RESET_TIME) {
        _filtered_distance[face.layer][face.sector].apply(distance, dt* 0.001f);
    } else {
        // reset filter since last distance was passed a long time back
        _filtered_distance[face.layer][face.sector].reset(distance);
    }
    _last_update_ms[face.layer][face.sector] = now_ms;
}

// update boundary points used for object avoidance based on a single sector and pitch distance changing
//   the boundary points lie on the line between sectors meaning two boundary points may be updated based on a single sector's distance changing
//   the boundary point is set to the shortest distance found in the two adjacent sectors, this is a conservative boundary around the vehicle
void AP_Proximity_Boundary_3D::update_boundary(const Face &face)
{
    // sanity check
    if (!face.valid()) {
        return;
    }

    const uint8_t layer = face.layer;
    const uint8_t sector = face.sector;

    // find adjacent sector (clockwise)
    const uint8_t next_sector = get_next_sector(sector);

    // boundary point lies on the line between the two sectors at the shorter distance found in the two sectors
    float shortest_distance = PROXIMITY_BOUNDARY_DIST_DEFAULT;
    if (_distance_valid[layer][sector] && _distance_valid[layer][next_sector]) {
        shortest_distance = MIN(_filtered_distance[layer][sector].get(), _filtered_distance[layer][next_sector].get());
    } else if (_distance_valid[layer][sector]) {
        shortest_distance = _filtered_distance[layer][sector].get();
    } else if (_distance_valid[layer][next_sector]) {
        shortest_distance = _filtered_distance[layer][next_sector].get();
    }
    if (shortest_distance < PROXIMITY_BOUNDARY_DIST_MIN) {
        shortest_distance = PROXIMITY_BOUNDARY_DIST_MIN;
    }
    _boundary_points[layer][sector] = _sector_edge_vector[layer][sector] * shortest_distance;

    // if the next sector (clockwise) has an invalid distance, set boundary to create a cup like boundary
    if (!_distance_valid[layer][next_sector]) {
        _boundary_points[layer][next_sector] = _sector_edge_vector[layer][next_sector] * shortest_distance;
    }

    // repeat for edge between sector and previous sector
    const uint8_t prev_sector = get_prev_sector(sector);
    shortest_distance = PROXIMITY_BOUNDARY_DIST_DEFAULT;
    if (_distance_valid[layer][prev_sector] && _distance_valid[layer][sector]) {
        shortest_distance = MIN(_filtered_distance[layer][prev_sector].get(), _filtered_distance[layer][sector].get());
    } else if (_distance_valid[layer][prev_sector]) {
        shortest_distance = _filtered_distance[layer][prev_sector].get();
    } else if (_distance_valid[layer][sector]) {
        shortest_distance = _filtered_distance[layer][sector].get();
    }
    _boundary_points[layer][prev_sector] = _sector_edge_vector[layer][prev_sector] * shortest_distance;

    // if the sector counter-clockwise from the previous sector has an invalid distance, set boundary to create a cup-like boundary
    const uint8_t prev_sector_ccw = get_prev_sector(prev_sector);
    if (!_distance_valid[layer][prev_sector_ccw]) {
        _boundary_points[layer][prev_sector_ccw] = _sector_edge_vector[layer][prev_sector_ccw] * shortest_distance;
    }
}

// reset boundary.  marks all distances as invalid
void AP_Proximity_Boundary_3D::reset()
{
    for (uint8_t layer=0; layer < PROXIMITY_NUM_LAYERS; layer++) {
        for (uint8_t sector=0; sector < PROXIMITY_NUM_SECTORS; sector++) {
            _distance_valid[layer][sector] = false;
        }
    }
}

// Reset this location, specified by Face object, back to default
// i.e Distance is marked as not-valid, and set to a large number.
// prx_instance should be set to the proximity sensor's backend instance number
void AP_Proximity_Boundary_3D::reset_face(const Face &face, uint8_t prx_instance)
{
    if (!face.valid()) {
        return;
    }

    // return immediately if face already has no valid distance
    if (!_distance_valid[face.layer][face.sector]) {
        return;
    }

    // ignore reset if another instance provided this face's distance within the last 0.2 seconds
    if (prx_instance != _prx_instance[face.layer][face.sector]) {
        const uint32_t now_ms = AP_HAL::millis();
        if (now_ms - _last_update_ms[face.layer][face.sector] < 200) {
            return;
        }
    }

    _distance_valid[face.layer][face.sector] = false;

    // update simple avoidance boundary
    update_boundary(face);
}

// check if a face has valid distance even if it was updated a long time back
void AP_Proximity_Boundary_3D::check_face_timeout()
{
    // exit immediately if already checked recently
    const uint32_t now_ms = AP_HAL::millis();
    if ((now_ms - _last_check_face_timeout_ms) < PROXIMITY_BOUNDARY_3D_TIMEOUT_MS) {
        return;
    }
    _last_check_face_timeout_ms = now_ms;

    for (uint8_t layer=0; layer < PROXIMITY_NUM_LAYERS; layer++) {
        for (uint8_t sector=0; sector < PROXIMITY_NUM_SECTORS; sector++) {
            if (_distance_valid[layer][sector]) {
                if ((now_ms - _last_update_ms[layer][sector]) > PROXIMITY_FACE_RESET_MS) {
                    // this face has a valid distance but wasn't updated for a long time, reset it
                    _distance_valid[layer][sector] = false;
                    update_boundary(AP_Proximity_Boundary_3D::Face{layer, sector});
                }
            }
        }
    }
}

// get distance for a face.  returns true on success and fills in distance argument with distance in meters
bool AP_Proximity_Boundary_3D::get_distance(const Face &face, float &distance) const
{
    if (!face.valid()) {
        return false;
    }
    if (_distance_valid[face.layer][face.sector]) {
        distance = _distance[face.layer][face.sector];
        return true;
    }

    return false;
}

// get the total number of obstacles 
uint8_t AP_Proximity_Boundary_3D::get_obstacle_count() const
{
    return PROXIMITY_NUM_LAYERS * PROXIMITY_NUM_SECTORS;
}

// Converts obstacle_num passed from avoidance library into appropriate face of the boundary
// Returns false if the face is invalid
// "update_boundary" method manipulates two sectors ccw and one sector cw from any valid face.
// Any boundary that does not fall into these manipulated faces are useless, and will be marked as false
// The resultant is packed into a Boundary Location object and returned by reference as "face"
bool AP_Proximity_Boundary_3D::convert_obstacle_num_to_face(uint8_t obstacle_num, Face& face) const
{
    // obstacle num is just "flattened layers, and sectors"
    const uint8_t layer = obstacle_num / PROXIMITY_NUM_SECTORS;
    const uint8_t sector = obstacle_num % PROXIMITY_NUM_SECTORS;
    face.sector = sector;
    face.layer = layer;

    uint8_t valid_sector = sector;
    // check for 3 adjacent sectors
    for (uint8_t i=0; i < 3; i++) {
        if (_distance_valid[layer][valid_sector]) {
            // update boundary has manipulated this face
            return true;
        }
        valid_sector = get_next_sector(valid_sector);
    }

    // this face was not manipulated by "update_boundary" and is stale. Don't use it
    return false;
}

// Appropriate layer and sector are found from the passed obstacle_num
// This function then draws a line between this sector, and sector + 1 at the given layer
// Then returns the closest point on this line from vehicle, in body-frame. 
// Used by GPS based Simple Avoidance  
// False is returned if the obstacle_num provided does not produce a valid obstacle 
bool AP_Proximity_Boundary_3D::get_obstacle(uint8_t obstacle_num, Vector3f& vec_to_obstacle) const
{
    Face face;
    if (!convert_obstacle_num_to_face(obstacle_num, face)) {
        // not a valid face
        return false;
    }
    const uint8_t sector_end = face.sector;
    const uint8_t sector_start = get_next_sector(face.sector);
    
    const Vector3f start = _boundary_points[face.layer][sector_start];
    const Vector3f end = _boundary_points[face.layer][sector_end];
    vec_to_obstacle = Vector3f::point_on_line_closest_to_other_point(start, end, Vector3f{});
    return true;
}

// Appropriate layer and sector are found from the passed obstacle_num
// This function then draws a line between this sector, and sector + 1 at the given layer
// Then returns the closest point on this line from the segment that was passed, in body-frame.
// Addionally a 3-D plane is constructed using the closest point found above as normal, and a point on the line segment in the boundary.
// True is returned when the passed line segment intersects this plane.
// This helps us know if the passed line segment was in the direction of the boundary, or going in a different direction.
// Used by GPS based Simple Avoidance  - for "brake mode"
// False is returned if the obstacle_num provided does not produce a valid obstacle
bool AP_Proximity_Boundary_3D::closest_point_from_segment_to_obstacle(uint8_t obstacle_num, const Vector3f& seg_start, const Vector3f& seg_end, Vector3f& closest_point) const
{
    Face face;
    if (!convert_obstacle_num_to_face(obstacle_num, face)) {
        // not a valid a face
        return false;
    }

    const uint8_t sector_end = face.sector;
    const uint8_t sector_start = get_next_sector(face.sector);
    const Vector3f start = _boundary_points[face.layer][sector_start];
    const Vector3f end = _boundary_points[face.layer][sector_end];

    // closest point between passed line segment and boundary
    Vector3f::segment_to_segment_closest_point(seg_start, seg_end, start, end, closest_point);
    if (closest_point == start) {
        // draw a plane using the closest point as normal vector, and a point on the boundary
        // return false if the passed segment does not intersect the plane
        return Vector3f::segment_plane_intersect(seg_start, seg_end, closest_point, end);
    }
    return Vector3f::segment_plane_intersect(seg_start, seg_end, closest_point, start);
}

// get distance and angle to closest object (used for pre-arm check)
//   returns true on success, false if no valid readings
bool AP_Proximity_Boundary_3D::get_closest_object(float& angle_deg, float &distance) const
{
    bool closest_found = false;
    uint8_t closest_sector = 0;
    uint8_t closest_layer = 0;

    // check boundary for shortest distance
    // only check for middle layers and higher
    // lower layers might contain ground, which will give false pre-arm failure
    for (uint8_t layer=PROXIMITY_MIDDLE_LAYER; layer<PROXIMITY_NUM_LAYERS; layer++) {
        for (uint8_t sector=0; sector<PROXIMITY_NUM_SECTORS; sector++) {
            if (_distance_valid[layer][sector]) {
                if (!closest_found || (_distance[layer][sector] < _distance[closest_layer][closest_sector])) {
                    closest_layer = layer;
                    closest_sector = sector;
                    closest_found = true;
                }
            }
        }
    }

    if (closest_found) {
        angle_deg = _angle[closest_layer][closest_sector];
        distance = _distance[closest_layer][closest_sector];
    }
    return closest_found;
}

// get number of objects, used for non-GPS avoidance
uint8_t AP_Proximity_Boundary_3D::get_horizontal_object_count() const
{
    return PROXIMITY_NUM_SECTORS;
}

// get an object's angle and distance, used for non-GPS avoidance
// returns false if no angle or distance could be returned for some reason
bool AP_Proximity_Boundary_3D::get_horizontal_object_angle_and_distance(uint8_t object_number, float &angle_deg, float &distance) const
{
    if ((object_number < PROXIMITY_NUM_SECTORS) && _distance_valid[PROXIMITY_MIDDLE_LAYER][object_number]) {
        angle_deg = _angle[PROXIMITY_MIDDLE_LAYER][object_number];
        distance = _filtered_distance[PROXIMITY_MIDDLE_LAYER][object_number].get();
        return true;
    }
    return false;
}

// get an obstacle info for AP_Periph
// returns false if no angle or distance could be returned for some reason
bool AP_Proximity_Boundary_3D::get_obstacle_info(uint8_t obstacle_num, float &angle_deg, float &pitch_deg, float &distance) const
{
    // obstacle num is just "flattened layers, and sectors"
    const uint8_t layer = obstacle_num / PROXIMITY_NUM_SECTORS;
    const uint8_t sector = obstacle_num % PROXIMITY_NUM_SECTORS;
    if (_distance_valid[layer][sector]) {
        angle_deg = _angle[layer][sector];
        pitch_deg = _pitch[layer][sector];
        distance = _filtered_distance[layer][sector].get();
        return true;
    }

    return false;
}

// Return filtered distance for the passed in face
bool AP_Proximity_Boundary_3D::get_filtered_distance(const Face &face, float &distance) const
{
    if (!face.valid()) {
        return false;
    }

    if (!_distance_valid[face.layer][face.sector]) {
        // invalid distace
        return false;
    }

    distance = _filtered_distance[face.layer][face.sector].get();
    return true;
}

// Get raw and filtered distances in 8 directions per layer
bool AP_Proximity_Boundary_3D::get_layer_distances(uint8_t layer_number, float dist_max, Proximity_Distance_Array &prx_dist_array, Proximity_Distance_Array &prx_filt_dist_array) const
{
    // cycle through all sectors filling in distances and orientations
    // see MAV_SENSOR_ORIENTATION for orientations (0 = forward, 1 = 45 degree clockwise from north, etc)
    bool valid_distances = false;
    prx_dist_array.offset_valid = 0;
    prx_filt_dist_array.offset_valid = 0;
    for (uint8_t i=0; i<PROXIMITY_MAX_DIRECTION; i++) {
        prx_dist_array.orientation[i] = i;
        const AP_Proximity_Boundary_3D::Face face(layer_number, i);
        if (!face.valid()) {
            return false;
        }
        if (get_distance(face, prx_dist_array.distance[i]) && get_filtered_distance(face, prx_filt_dist_array.distance[i])) {
            valid_distances = true;
            prx_dist_array.offset_valid |= (1U << i);
            prx_filt_dist_array.offset_valid |= (1U << i);
        } else {
            prx_dist_array.distance[i] = dist_max;
            prx_filt_dist_array.distance[i] = dist_max;
        }
    }

    return valid_distances;
}

// reset the temporary boundary. This fills in distances with FLT_MAX
void AP_Proximity_Temp_Boundary::reset()
{
    for (uint8_t layer=0; layer < PROXIMITY_NUM_LAYERS; layer++) {
        for (uint8_t sector=0; sector < PROXIMITY_NUM_SECTORS; sector++) {
            _distances[layer][sector] = FLT_MAX;
        }
    }
}

// add a distance to the temp boundary if it is shorter than any other provided distance since the last time the boundary was reset
// pitch and yaw are in degrees, distance is in meters
void AP_Proximity_Temp_Boundary::add_distance(const AP_Proximity_Boundary_3D::Face &face, float pitch, float yaw, float distance)
{
    if (face.valid() && distance < _distances[face.layer][face.sector]) {
        _distances[face.layer][face.sector] = distance;
        _angle[face.layer][face.sector] = yaw;
        _pitch[face.layer][face.sector] = pitch;
    }
}

// fill the original 3D boundary with the contents of this temporary boundary
// prx_instance should be set to the proximity sensor's backend instance number
void AP_Proximity_Temp_Boundary::update_3D_boundary(uint8_t prx_instance, AP_Proximity_Boundary_3D &boundary)
{
    for (uint8_t layer=0; layer < PROXIMITY_NUM_LAYERS; layer++) {
        for (uint8_t sector=0; sector < PROXIMITY_NUM_SECTORS; sector++) {
            if (_distances[layer][sector] < FLT_MAX) {
                AP_Proximity_Boundary_3D::Face face{layer, sector};
                boundary.set_face_attributes(face, _pitch[layer][sector], _angle[layer][sector], _distances[layer][sector], prx_instance);
            }
        }
    }
}

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         /*
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#pragma once

#include <AP_Common/AP_Common.h>
#include <AP_Math/AP_Math.h>
#include <Filter/LowPassFilter.h>

#define PROXIMITY_NUM_SECTORS         8       // number of sectors
#define PROXIMITY_NUM_LAYERS          5       // num of layers in a sector
#define PROXIMITY_MIDDLE_LAYER        2       // middle layer
#define PROXIMITY_PITCH_WIDTH_DEG     30      // width between each layer in degrees
#define PROXIMITY_SECTOR_WIDTH_DEG    (360.0f/PROXIMITY_NUM_SECTORS)   // width of sectors in degrees
#define PROXIMITY_BOUNDARY_DIST_MIN   0.6f    // minimum distance for a boundary point.  This ensures the object avoidance code doesn't think we are outside the boundary.
#define PROXIMITY_BOUNDARY_DIST_DEFAULT 100   // if we have no data for a sector, boundary is placed 100m out
#define PROXIMITY_FILT_RESET_TIME     1000    // reset filter if last distance was pushed more than this many ms away
#define PROXIMITY_FACE_RESET_MS       1000    // face will be reset if not updated within this many ms

// structure holding distances in PROXIMITY_MAX_DIRECTION directions. used for sending distances to ground station
#define PROXIMITY_MAX_DIRECTION 8
struct Proximity_Distance_Array {
    uint8_t orientation[PROXIMITY_MAX_DIRECTION]; // orientation (i.e. rough direction) of the distance (see MAV_SENSOR_ORIENTATION)
    float distance[PROXIMITY_MAX_DIRECTION];      // distance in meters
    bool valid(uint8_t offset) const {
        // returns true if the distance stored at offset is valid
        return (offset < 8 && (offset_valid & (1U<<offset)));
    };

    uint8_t offset_valid; // bitmask
};

class AP_Proximity_Boundary_3D
{
public:
    // constructor. This incorporates initialisation as well.
	AP_Proximity_Boundary_3D();

    // stores the layer and sector as a single object to access and modify the 3-D boundary
    // Objects of this class are used temporarily to modify the boundary, i,e they are not persistant or stored anywhere
    class Face
    {
    public:

	    // constructor, invalidate id and distance
	    Face() { layer = sector = UINT8_MAX; }
	    Face(uint8_t _layer, uint8_t _sector) { layer = _layer; sector = _sector; }

	    // return true if face has valid layer and sector values
	    bool valid() const { return ((layer < PROXIMITY_NUM_LAYERS) && (sector < PROXIMITY_NUM_SECTORS)); }

	    // comparison operator
	    bool operator ==(const Face &other) const { return ((layer == other.layer) && (sector == other.sector)); }
	    bool operator !=(const Face &other) const { return ((layer != other.layer) || (sector != other.sector)); }

        uint8_t layer;  // vertical "steps" on the 3D Boundary. 0th layer is the bottom most layer, 1st layer is 30 degrees above (in body frame) and so on
        uint8_t sector; // horizontal "steps" on the 3D Boundary. 0th sector is directly in front of the vehicle. Each sector is 45 degrees wide.
    };

    // returns face corresponding to the provided yaw and (optionally) pitch
    // pitch is the vertical body-frame angle (in degrees) to the obstacle (0=directly ahead, 90 is above the vehicle?)
    // yaw is the horizontal body-frame angle (in degrees) to the obstacle (0=directly ahead of the vehicle, 90 is to the right of the vehicle)
    Face get_face(float pitch, float yaw) const;
    Face get_face(float yaw) const { return get_face(0, yaw); }

    // Set the actual body-frame angle(yaw), pitch, and distance of the detected object.
    // This method will also mark the sector and layer to be "valid",
    // This distance can then be used for Obstacle Avoidance
    // Assume detected obstacle is horizontal (zero pitch), if no pitch is passed
    // prx_instance should be set to the proximity sensor backend instance number
    void set_face_attributes(const Face &face, float pitch, float yaw, float distance, uint8_t prx_instance);
    void set_face_attributes(const Face &face, float yaw, float distance, uint8_t prx_instance) { set_face_attributes(face, 0, yaw, distance, prx_instance); }

    // update boundary points used for simple avoidance based on a single sector and pitch distance changing
    //   the boundary points lie on the line between sectors meaning two boundary points may be updated based on a single sector's distance changing
    //   the boundary point is set to the shortest distance found in the two adjacent sectors, this is a conservative boundary around the vehicle
    void update_boundary(const Face &face);

    // reset boundary.  marks all distances as invalid
    void reset();

    // Reset this location, specified by Face object, back to default
    // i.e Distance is marked as not-valid
    // prx_instance should be set to the proximity sensor's backend instance number
    void reset_face(const Face &face, uint8_t prx_instance);

    // check if a face has valid distance even if it was updated a long time back
    void check_face_timeout();

    // get distance for a face.  returns true on success and fills in distance argument with distance in meters
    bool get_distance(const Face &face, float &distance) const;

    // Get the total number of obstacles
    uint8_t get_obstacle_count() const;

    // Returns a body frame vector (in cm) to an obstacle
    // False is returned if the obstacle_num provided does not produce a valid obstacle
    bool get_obstacle(uint8_t obstacle_num, Vector3f& vec_to_boundary) const;

    // Returns a body frame vector (in cm) nearest to obstacle, in betwen seg_start and seg_end
    // True is returned if the segment intersects a plane formed by considering the "closest point" as normal vector to the plane.
    bool closest_point_from_segment_to_obstacle(uint8_t obstacle_num, const Vector3f& seg_start, const Vector3f& seg_end, Vector3f& closest_point) const;

    // get distance and angle to closest object (used for pre-arm check)
    //   returns true on success, false if no valid readings
    bool get_closest_object(float& angle_deg, float &distance) const;

    // get number of objects horizontally
    uint8_t get_horizontal_object_count() const;
    bool get_horizontal_object_angle_and_distance(uint8_t object_number, float& angle_deg, float &distance) const;

    // get obstacle info for AP_Periph
    bool get_obstacle_info(uint8_t obstacle_num, float &angle_deg, float &pitch_deg, float &distance) const;

    // get number of layers
    uint8_t get_num_layers() const { return PROXIMITY_NUM_LAYERS; }

    // get raw and filtered distances in 8 directions per layer.
    bool get_layer_distances(uint8_t layer_number, float dist_max, Proximity_Distance_Array &prx_dist_array, Proximity_Distance_Array &prx_filt_dist_array) const;

    // pass down filter cut-off freq from params
    void set_filter_freq(float filt_freq) { _filter_freq = filt_freq; }

    // sectors
    static_assert(PROXIMITY_NUM_SECTORS == 8, "PROXIMITY_NUM_SECTOR must be 8");
    const uint16_t _sector_middle_deg[PROXIMITY_NUM_SECTORS] {0, 45, 90, 135, 180, 225, 270, 315};    // middle angle of each sector
    // layers
    static_assert(PROXIMITY_NUM_LAYERS == 5, "PROXIMITY_NUM_LAYERS must be 5");
    const int16_t _pitch_middle_deg[PROXIMITY_NUM_LAYERS] {-60, -30, 0, 30, 60};

private:

    // initialise the boundary and sector_edge_vector array used for object avoidance
    void init();

    // get the next sector which is CW to the passed sector
    uint8_t get_next_sector(uint8_t sector) const {return ((sector >= PROXIMITY_NUM_SECTORS-1) ? 0 : sector+1); }

    // get the prev sector which is CCW to the passed sector
    uint8_t get_prev_sector(uint8_t sector) const {return ((sector <= 0) ? PROXIMITY_NUM_SECTORS-1 : sector-1); }

    // Converts obstacle_num passed from avoidance library into appropriate face of the boundary
    // Returns false if the face is invalid
    // "update_boundary" method manipulates two sectors ccw and one sector cw from any valid face.
    // Any boundary that does not fall into these manipulated faces are useless, and will be marked as false
    // The resultant is packed into a Boundary Location object and returned by reference as "face"
    bool convert_obstacle_num_to_face(uint8_t obstacle_num, Face& face) const WARN_IF_UNUSED;

    // Apply a new cutoff_freq to low-pass filter
    void apply_filter_freq(float cutoff_freq);

    // Apply low pass filter on the raw distance
    void set_filtered_distance(const Face &face, float distance);

    // Return filtered distance for the passed in face
    bool get_filtered_distance(const Face &face, float &distance) const;

    Vector3f _sector_edge_vector[PROXIMITY_NUM_LAYERS][PROXIMITY_NUM_SECTORS];
    Vector3f _boundary_points[PROXIMITY_NUM_LAYERS][PROXIMITY_NUM_SECTORS];

    float _angle[PROXIMITY_NUM_LAYERS][PROXIMITY_NUM_SECTORS];          // yaw angle in degrees to closest object within each sector and layer
    float _pitch[PROXIMITY_NUM_LAYERS][PROXIMITY_NUM_SECTORS];          // pitch angle in degrees to the closest object within each sector and layer
    float _distance[PROXIMITY_NUM_LAYERS][PROXIMITY_NUM_SECTORS];       // distance to closest object within each sector and layer
    bool _distance_valid[PROXIMITY_NUM_LAYERS][PROXIMITY_NUM_SECTORS];  // true if a valid distance received for each sector and layer
    uint32_t _last_update_ms[PROXIMITY_NUM_LAYERS][PROXIMITY_NUM_SECTORS]; // time when distance was last updated
    uint8_t _prx_instance[PROXIMITY_NUM_LAYERS][PROXIMITY_NUM_SECTORS]; // proximity sensor backend instance that provided the distance
    LowPassFilterFloat _filtered_distance[PROXIMITY_NUM_LAYERS][PROXIMITY_NUM_SECTORS]; // low pass filter
    float _filter_freq;                                                 // cutoff freq of low pass filter
    uint32_t _last_check_face_timeout_ms;                               // system time to throttle check_face_timeout method
};

// This class gives an easy way of making a temporary boundary, used for "sorting" distances.
// When unknown number of distances at various orientations are sent we store the least distance in the temporary boundary.
// After all the messages are received, we copy the contents of the temporary boundary and put it in the main 3-D boundary.
class AP_Proximity_Temp_Boundary
{
public:
    // constructor. This incorporates initialisation as well.
	AP_Proximity_Temp_Boundary() { reset(); }

    // reset the temporary boundary. This fills in distances with FLT_MAX
    void reset();

    // add a distance to the temp boundary if it is shorter than any other provided distance since the last time the boundary was reset
    // pitch and yaw are in degrees, distance is in meters
    void add_distance(const AP_Proximity_Boundary_3D::Face &face, float pitch, float yaw, float distance);
    void add_distance(const AP_Proximity_Boundary_3D::Face &face, float yaw, float distance) { add_distance(face, 0.0f, yaw, distance); }

    // fill the original 3D boundary with the contents of this temporary boundary
    // prx_instance should be set to the proximity sensor's backend instance number
    void update_3D_boundary(uint8_t prx_instance, AP_Proximity_Boundary_3D &boundary);

private:

    float _distances[PROXIMITY_NUM_LAYERS][PROXIMITY_NUM_SECTORS];      // distance to closest object within each sector and layer. Will start with FLT_MAX, and then be changed to a valid distance if needed
    float _angle[PROXIMITY_NUM_LAYERS][PROXIMITY_NUM_SECTORS];          // yaw angle in degrees to closest object within each sector and layer
    float _pitch[PROXIMITY_NUM_LAYERS][PROXIMITY_NUM_SECTORS];          // pitch angle in degrees to the closest object within each sector and layer
};
           #pragma once

#include "AP_Proximity_config.h"

#if AP_PROXIMITY_CYGBOT_ENABLED

#include "AP_Proximity_Backend_Serial.h"

#define CYGBOT_MAX_MSG_SIZE            350
#define CYGBOT_PACKET_HEADER_0         0x5A
#define CYGBOT_PACKET_HEADER_1         0x77
#define CYGBOT_PACKET_HEADER_2         0xFF
#define CYGBOT_PAYLOAD_HEADER 		   0x01
#define CYGBOT_2D_START_ANGLE 		   -60.0f  // Starting 2-D horizontal angle of distances received in payload
#define CYGBOT_2D_ANGLE_STEP		   0.75f   // Angle step size of each distance received. Starts from CYGBOT_2D_START_ANGLE

#define CYGBOT_TIMEOUT_MS              500    // Driver will report "unhealthy" if valid sensor readings not received within this many ms
#define CYGBOT_INIT_TIMEOUT_MS         1000   // Timeout this many ms after init
#define CYGBOT_MAX_RANGE_M             7.0f   // max range of the sensor in meters
#define CYGBOT_MIN_RANGE_M             0.2f   // min range of the sensor in meters

class AP_Proximity_Cygbot_D1 : public AP_Proximity_Backend_Serial
{

public:

    using AP_Proximity_Backend_Serial::AP_Proximity_Backend_Serial;

    // update the state of the sensor
    void update(void) override;

    // get maximum and minimum distances (in meters) of sensor
    float distance_max() const override { return CYGBOT_MAX_RANGE_M; }
    float distance_min() const override { return CYGBOT_MIN_RANGE_M; }

private:

    // send message to the sensor to start streaming 2-D data
    void send_sensor_start();

    // read bytes from the sensor
    void read_sensor_data();

    // parse one byte from the sensor. Return false on error.
    bool parse_byte(uint8_t data);

    // parse payload, to pick out distances, and feed them to the correct faces
    void parse_payload();

    // Checksum
    uint8_t calc_checksum(uint8_t *buff, int buffSize);

    // reset all variables and flags
    void reset();

    // expected bytes from the sensor
    enum PacketList {
        Header1 = 0,
        Header2,
        Header3,
        Length1,
        Length2,
        Payload_Header,
        Payload_Data,
        CheckSum
    } _parse_state;

    struct {
        uint8_t payload_len_flags_low;          // low byte for payload size
        uint8_t payload_len_flags_high;         // high byte for payload size
        uint16_t payload_len;                   // latest message expected payload length
        uint16_t payload_counter;              // counter of the number of payload bytes received
        uint8_t payload[CYGBOT_MAX_MSG_SIZE];   // payload
    } _msg;

    bool _initialized;
    uint32_t _last_init_ms;                 // system time of last sensor init
    uint32_t _last_distance_received_ms;    // system time of last distance measurement received from sensor

    AP_Proximity_Temp_Boundary _temp_boundary; // temporary boundary to store incoming payload

};

#endif // AP_PROXIMITY_CYGBOT_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     /*
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include "AP_Proximity_DroneCAN.h"

#if AP_PROXIMITY_DRONECAN_ENABLED

#include <AP_HAL/AP_HAL.h>
#include <AP_CANManager/AP_CANManager.h>
#include <AP_DroneCAN/AP_DroneCAN.h>
#include <AP_BoardConfig/AP_BoardConfig.h>
#include <GCS_MAVLink/GCS.h>

extern const AP_HAL::HAL& hal;


ObjectBuffer_TS<AP_Proximity_DroneCAN::ObstacleItem> AP_Proximity_DroneCAN::items(50);

#define PROXIMITY_TIMEOUT_MS    500 // distance messages must arrive within this many milliseconds


//links the Proximity DroneCAN message to this backend
void AP_Proximity_DroneCAN::subscribe_msgs(AP_DroneCAN* ap_dronecan)
{
    if (ap_dronecan == nullptr) {
        return;
    }

    if (Canard::allocate_sub_arg_callback(ap_dronecan, &handle_measurement, ap_dronecan->get_driver_index()) == nullptr) {
        AP_BoardConfig::allocation_error("measurement_sub");
    }
}

//Method to find the backend relating to the node id
AP_Proximity_DroneCAN* AP_Proximity_DroneCAN::get_dronecan_backend(AP_DroneCAN* ap_dronecan, uint8_t node_id, uint8_t address, bool create_new)
{
    if (ap_dronecan == nullptr) {
        return nullptr;
    }

    AP_Proximity *prx = AP::proximity();
    if (prx == nullptr) {
        return nullptr;
    }

    AP_Proximity_DroneCAN* driver = nullptr;
    //Scan through the proximity type params to find DroneCAN with matching address.
    for (uint8_t i = 0; i < PROXIMITY_MAX_INSTANCES; i++) {
        if ((AP_Proximity::Type)prx->params[i].type.get() == AP_Proximity::Type::DroneCAN &&
            prx->params[i].address == address) {
            driver = (AP_Proximity_DroneCAN*)prx->drivers[i];
        }
        //Double check if the driver was initialised as DroneCAN Type
        if (driver != nullptr && (driver->_backend_type == AP_Proximity::Type::DroneCAN)) {
            if (driver->_ap_dronecan == ap_dronecan &&
                driver->_node_id == node_id) {
                return driver;
            } else {
                //we found a possible duplicate addressed sensor
                //we return nothing in such scenario
                return nullptr;
            }
        }
    }

    if (create_new) {
        for (uint8_t i = 0; i < PROXIMITY_MAX_INSTANCES; i++) {
            if ((AP_Proximity::Type)prx->params[i].type.get() == AP_Proximity::Type::DroneCAN &&
                prx->params[i].address == address) {
                WITH_SEMAPHORE(prx->detect_sem);
                if (prx->drivers[i] != nullptr) {
                    //we probably initialised this driver as something else, reboot is required for setting
                    //it up as DroneCAN type
                    return nullptr;
                }
                prx->drivers[i] = NEW_NOTHROW AP_Proximity_DroneCAN(*prx, prx->state[i], prx->params[i]);
                driver = (AP_Proximity_DroneCAN*)prx->drivers[i];
                if (driver == nullptr) {
                    break;
                }
                GCS_SEND_TEXT(MAV_SEVERITY_INFO, "Prx[%u]: added DroneCAN node %u addr %u",
                                unsigned(i), unsigned(node_id), unsigned(address));

                if (is_zero(prx->params[i].max_m) && is_zero(prx->params[i].min_m)) {
                    // GCS reporting will be incorrect if min/max are not set
                    GCS_SEND_TEXT(MAV_SEVERITY_CRITICAL, "Configure PRX%u_MIN and PRX%u_MAX",
                                unsigned(i), unsigned(i));
                }
                //Assign node id and respective dronecan driver, for identification
                if (driver->_ap_dronecan == nullptr) {
                    driver->_ap_dronecan = ap_dronecan;
                    driver->_node_id = node_id;
                    break;
                }
            }
        }
    }

    return driver;
}


// update the state of the sensor
void AP_Proximity_DroneCAN::update(void)
{
    // check for timeout and set health status
    if ((_last_update_ms == 0 || (AP_HAL::millis() - _last_update_ms > PROXIMITY_TIMEOUT_MS))) {
        set_status(AP_Proximity::Status::NoData);
    } else {
        set_status(_status);
    }

    if (_status == AP_Proximity::Status::Good) {
        ObstacleItem object_item;
        WITH_SEMAPHORE(_sem);
        while (items.pop(object_item)) {
            const AP_Proximity_Boundary_3D::Face face = frontend.boundary.get_face(object_item.pitch_deg, object_item.yaw_deg);
            if (!is_zero(object_item.distance_m) && !ignore_reading(object_item.pitch_deg, object_item.yaw_deg, object_item.distance_m, false)) {
                // update boundary used for avoidance
                frontend.boundary.set_face_attributes(face, object_item.pitch_deg, object_item.yaw_deg, object_item.distance_m, state.instance);
                // update OA database
                database_push(object_item.pitch_deg, object_item.yaw_deg, object_item.distance_m);
            }
        }
    }
}

// get maximum and minimum distances (in meters)
float AP_Proximity_DroneCAN::distance_max() const
{
    if (is_zero(params.max_m)) {
        // GCS will not report correct correct value if max isn't set properly
        // This is a arbitrary value to prevent the above issue
        return 100.0f;
    }
    return params.max_m;
}

float AP_Proximity_DroneCAN::distance_min() const
{
    return params.min_m;
}

//Proximity message handler
void AP_Proximity_DroneCAN::handle_measurement(AP_DroneCAN *ap_dronecan, const CanardRxTransfer& transfer, const ardupilot_equipment_proximity_sensor_Proximity &msg)
{
    //fetch the matching DroneCAN driver, node id and sensor id backend instance
    AP_Proximity_DroneCAN* driver = get_dronecan_backend(ap_dronecan, transfer.source_node_id, msg.sensor_id, true);
    if (driver == nullptr) {
        return;
    }
    WITH_SEMAPHORE(driver->_sem);
    switch (msg.reading_type) {
        case ARDUPILOT_EQUIPMENT_PROXIMITY_SENSOR_PROXIMITY_READING_TYPE_GOOD: {
            //update the states in backend instance
            driver->_last_update_ms = AP_HAL::millis();
            driver->_status = AP_Proximity::Status::Good;
            const ObstacleItem item = {msg.yaw, msg.pitch, msg.distance};

            if (driver->items.space()) {
                // ignore reading if no place to put it in the queue
                driver->items.push(item);
            }
            break;
        }
        //Additional states supported by Proximity message
        case ARDUPILOT_EQUIPMENT_PROXIMITY_SENSOR_PROXIMITY_READING_TYPE_NOT_CONNECTED: {
            driver->_last_update_ms = AP_HAL::millis();
            driver->_status = AP_Proximity::Status::NotConnected;
            break;
        }
        case ARDUPILOT_EQUIPMENT_PROXIMITY_SENSOR_PROXIMITY_READING_TYPE_NO_DATA: {
            driver->_last_update_ms = AP_HAL::millis();
            driver->_status = AP_Proximity::Status::NoData;
            break;
        }
        default:
            break;
    }
}

#endif // AP_PROXIMITY_DRONECAN_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             #pragma once

#include "AP_RangeFinder_config.h"

#if AP_RANGEFINDER_ENABLED

#include "AP_RangeFinder_Backend.h"

class AP_RangeFinder_Backend_Serial : public AP_RangeFinder_Backend
{
public:
    // constructor
    AP_RangeFinder_Backend_Serial(RangeFinder::RangeFinder_State &_state,
                                  AP_RangeFinder_Params &_params);

    void init_serial(uint8_t serial_instance) override;

protected:

    // baudrate used during object construction:
    virtual uint32_t initial_baudrate(uint8_t serial_instance) const;

    // the value 0 is special to the UARTDriver - it's "use default"
    virtual uint16_t rx_bufsize() const { return 0; }
    virtual uint16_t tx_bufsize() const { return 0; }

    AP_HAL::UARTDriver *uart = nullptr;

    // update state; not all backends call this!
    virtual void update(void) override;

    // it is essential that anyone relying on the base-class update to
    // implement this:
    virtual bool get_reading(float &reading_m) = 0;

    // returns 0-100 or -1. This virtual method is for
    // serial drivers and is a companion to the previous method get_reading().
    // Like get_reading() this method is called in the base-class update() method.
    virtual int8_t get_signal_quality_pct() const WARN_IF_UNUSED
    { return RangeFinder::SIGNAL_QUALITY_UNKNOWN; }

    // maximum time between readings before we change state to NoData:
    virtual uint16_t read_timeout_ms() const { return 200; }
};

#endif  // AP_RANGEFINDER_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                /*
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include "AP_RangeFinder_Bebop.h"

#if AP_RANGEFINDER_BEBOP_ENABLED

#include <AP_HAL/AP_HAL.h>
#include <utility>

#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <fcntl.h>
#include <string.h>
#include <sys/mman.h>
#include <linux/types.h>
#include <errno.h>
#include <sys/ioctl.h>
#include <float.h>
#include <math.h>
#include <time.h>
#include <iio.h>
#include <AP_HAL_Linux/Thread.h>
#include <AP_HAL_Linux/GPIO.h>

/*
 * this mode is used at low altitude
 * send 4 wave patterns
 * gpio in low mode
 */
#define RNFD_BEBOP_DEFAULT_MODE 1

/*
 * the number of p7s in the iio buffer
 */
#define RNFD_BEBOP_P7_COUNT 8192

extern const AP_HAL::HAL& hal;

static const uint16_t waveform_mode0[14] = {
    4000, 3800, 3600, 3400, 3200, 3000, 2800,
    2600, 2400, 2200, 2000, 1800, 1600, 1400,
};

static const uint16_t waveform_mode1[32] = {
    4190, 4158, 4095, 4095, 4095, 4095, 4095, 4095, 4095,
    4095, 4090, 4058, 3943, 3924, 3841, 3679, 3588, 3403,
    3201, 3020, 2816, 2636, 2448, 2227, 2111, 1955, 1819,
    1675, 1540, 1492, 1374, 1292
};

AP_RangeFinder_Bebop::AP_RangeFinder_Bebop(RangeFinder::RangeFinder_State &_state, AP_RangeFinder_Params &_params) :
    AP_RangeFinder_Backend(_state, _params),
    _thread(NEW_NOTHROW Linux::Thread(FUNCTOR_BIND_MEMBER(&AP_RangeFinder_Bebop::_loop, void)))
{
    _init();
    _freq = RNFD_BEBOP_DEFAULT_FREQ;
    _filtered_capture_size = _adc.buffer_size / _filter_average;
    _filtered_capture = (unsigned int*) calloc(1, sizeof(_filtered_capture[0]) *
            _filtered_capture_size);
    _mode = RNFD_BEBOP_DEFAULT_MODE;
    /* SPI and IIO can not be initialized just yet */
    memset(_tx[0], 0xF0, 16);
    memset(_tx[1], 0xF0, 4);
    memset(_purge, 0xFF, RNFD_BEBOP_NB_PULSES_PURGE);
    _tx_buf = _tx[_mode];
}

AP_RangeFinder_Bebop::~AP_RangeFinder_Bebop()
{
    iio_buffer_destroy(_adc.buffer);
    _adc.buffer = nullptr;
    iio_context_destroy(_iio);
    _iio = nullptr;
}

bool AP_RangeFinder_Bebop::detect()
{
    return true;
}

unsigned short AP_RangeFinder_Bebop::get_threshold_at(int i_capture)
{
    uint16_t threshold_value = 0;

    /*
     * We define several kinds of thresholds signals ; for an echo to be
     * recorded, its maximum amplitude has to be ABOVE that threshold.
     * There is one kind of threshold per mode (mode 0 is "low" and mode 1 is
     * "high")
     * Basically they look like this :
     *
     *            on this part
     *            of the capture
     *  amplitude  we use
     *      ^     the waveform
     *      |     <---------->
     * 4195 +-----+
     *      |
     *      |
     *      |
     *      |
     *  1200|                 +----------------+
     *    +-------------------------------------->
     *      +    low         high               time
     *           limit       limit
     *
     *  */
    switch (_mode) {
    case 0:
        if (i_capture < 139) {
            threshold_value = 4195;
        } else if (i_capture < 153) {
            threshold_value = waveform_mode0[i_capture - 139];
        } else {
            threshold_value = 1200;
        }
        break;

    case 1:
        if (i_capture < 73) {
            threshold_value = 4195;
        } else if (i_capture < 105) {
            threshold_value = waveform_mode1[i_capture - 73];
        } else if (i_capture < 617) {
            threshold_value = 1200;
        } else {
            threshold_value = 4195;
        }
        break;

    default:
        break;
    }

    return threshold_value;
}

int AP_RangeFinder_Bebop::_apply_averaging_filter(void)
{

    int i_filter = 0; /* index in the filtered buffer */
    int i_capture = 0; /* index in the capture buffer : starts incrementing when
                            the captured data first exceeds
                            RNFD_BEBOP_THRESHOLD_ECHO_INIT */
    unsigned int filtered_value = 0;
    bool first_echo = false;
    unsigned char *data;
    unsigned char *start;
    unsigned char *end;
    ptrdiff_t step;

    step = iio_buffer_step(_adc.buffer);
    end = (unsigned char *) iio_buffer_end(_adc.buffer);
    start = (unsigned char *) iio_buffer_first(_adc.buffer, _adc.channel);

    for (data = start; data < end; data += step) {
        unsigned int current_value = 0;
        iio_channel_convert(_adc.channel, &current_value, data);

        /* We keep on advancing in the captured buffer without registering the
         * filtered data until the signal first exceeds a given value */
        if (!first_echo && current_value < threshold_echo_init) {
            continue;
        } else {
            first_echo = true;
        }

        filtered_value += current_value;
        if (i_capture % _filter_average == 0) {
            _filtered_capture[i_filter] = filtered_value / _filter_average;
            filtered_value = 0;
            i_filter++;
        }
        i_capture++;
    }
    return 0;
}

int AP_RangeFinder_Bebop::_search_local_maxima(void)
{
    int i_echo = 0; /* index in echo array */

    for (int i_capture = 1; i_capture <
            (int)_filtered_capture_size - 1; i_capture++) {
        if (_filtered_capture[i_capture] >= get_threshold_at(i_capture)) {
            unsigned short curr = _filtered_capture[i_capture];
            unsigned short prev = _filtered_capture[i_capture - 1];
            unsigned short next = _filtered_capture[i_capture + 1];

            if (curr >= prev && (curr > next || prev <
                        get_threshold_at(i_capture - 1))) {
                _echoes[i_echo].max_index = i_capture;
                i_echo++;
                if (i_echo >= RNFD_BEBOP_MAX_ECHOES) {
                    break;
                }
            }
        }
    }
    _nb_echoes = i_echo;
    return 0;
}

int AP_RangeFinder_Bebop::_search_maximum_with_max_amplitude(void)
{
    unsigned short max = 0;
    int max_idx = -1;

    for (int i_echo = 0; i_echo < _nb_echoes ; i_echo++) {
        unsigned short curr = _filtered_capture[_echoes[i_echo].max_index];
        if (curr > max) {
            max = curr;
            max_idx = i_echo;
        }
    }

    if (max_idx >= 0) {
        return _echoes[max_idx].max_index;
    } else {
        return -1;
    }
}

void AP_RangeFinder_Bebop::_loop(void)
{
    int max_index;

    while(1) {
        _launch();

        _capture();

        if (_apply_averaging_filter() < 0) {
            DEV_PRINTF(
                    "AR_RangeFinder_Bebop: could not apply averaging filter");
        }

        if (_search_local_maxima() < 0) {
            DEV_PRINTF("Did not find any local maximum");
        }

        max_index = _search_maximum_with_max_amplitude();
        if (max_index >= 0) {
            _altitude = (float)(max_index * RNFD_BEBOP_SOUND_SPEED) /
                (2 * (RNFD_BEBOP_DEFAULT_ADC_FREQ / _filter_average));
        }
        _mode = _update_mode(_altitude);
    }
}

void AP_RangeFinder_Bebop::update(void)
{
    static bool first_call = true;

    if (first_call) {
        _thread->start("RangeFinder_Bebop", SCHED_FIFO, 11);
        first_call = false;
    }

    state.distance_m = _altitude;
    state.last_reading_ms = AP_HAL::millis();
    update_status();
}

/*
 * purge is used when changing mode
 */
int AP_RangeFinder_Bebop::_launch_purge()
{
    iio_device_attr_write(_adc.device, "buffer/enable", "1");
    _spi->transfer(_purge, RNFD_BEBOP_NB_PULSES_PURGE, nullptr, 0);
    return 0;
}

void AP_RangeFinder_Bebop::_configure_gpio(int value)
{
    switch (value) {
    case 1: // high voltage
        _gpio->write(LINUX_GPIO_ULTRASOUND_VOLTAGE, 1);
        break;
    case 0: // low voltage
        _gpio->write(LINUX_GPIO_ULTRASOUND_VOLTAGE, 0);
        break;
    default:
        DEV_PRINTF("bad gpio value (%d)", value);
        break;
    }
}

/*
 * reconfigure the pulse that will be sent over spi
 * first send a purge then configure the new pulse
 */
void AP_RangeFinder_Bebop::_reconfigure_wave()
{
    /* configure the output buffer for a purge */
    /* perform a purge */
    if (_launch_purge() < 0) {
        DEV_PRINTF("purge could not send data overspi");
    }
    if (_capture() < 0) {
        DEV_PRINTF("purge could not capture data");
    }

    _tx_buf = _tx[_mode];
    switch (_mode) {
    case 1: /* low voltage */
        _configure_gpio(0);
        break;
    case 0: /* high voltage */
        _configure_gpio(1);
        break;
    default:
        DEV_PRINTF("WARNING, invalid value to configure gpio\n");
        break;
    }
}

/*
 * First configuration of the pulse that will be send over spi
 */
int AP_RangeFinder_Bebop::_configure_wave()
{
    _spi->set_speed(AP_HAL::Device::SPEED_HIGH);
    _configure_gpio(0);
    return 0;
}

/*
 * Configure the adc to get the samples
 */
int AP_RangeFinder_Bebop::_configure_capture()
{
    const char *adcname = "p7mu-adc_2";
    const char *adcchannel = "voltage2";
    /* configure adc interface using libiio */
    _iio = iio_create_local_context();
    if (!_iio) {
        return -1;
    }
    _adc.device = iio_context_find_device(_iio, adcname);

    if (!_adc.device) {
        DEV_PRINTF("Unable to find %s", adcname);
        goto error_destroy_context;
    }
    _adc.channel = iio_device_find_channel(_adc.device, adcchannel,
            false);
    if (!_adc.channel) {
        DEV_PRINTF("Fail to init adc channel %s", adcchannel);
        goto error_destroy_context;
    }

    iio_channel_enable(_adc.channel);

    _adc.freq = RNFD_BEBOP_DEFAULT_ADC_FREQ >> RNFD_BEBOP_FILTER_POWER;
    _adc.threshold_time_rejection = 2.0 / RNFD_BEBOP_SOUND_SPEED *
        _adc.freq;

    /* Create input buffer */
    _adc.buffer_size = RNFD_BEBOP_P7_COUNT;
    if (iio_device_set_kernel_buffers_count(_adc.device, 1)) {
        DEV_PRINTF("cannot set buffer count");
        goto error_destroy_context;
    }
    _adc.buffer = iio_device_create_buffer(_adc.device,
            _adc.buffer_size, false);
    if (!_adc.buffer) {
        DEV_PRINTF("Fail to create buffer : %s", strerror(errno));
        goto error_destroy_context;
    }

    return 0;

error_destroy_context:
    iio_buffer_destroy(_adc.buffer);
    _adc.buffer = nullptr;
    iio_context_destroy(_iio);
    _iio = nullptr;
    return -1;
}

void AP_RangeFinder_Bebop::_init()
{
    _spi = std::move(hal.spi->get_device("bebop"));

    _gpio = AP_HAL::get_HAL().gpio;
    if (_gpio == nullptr) {
        AP_HAL::panic("Could not find GPIO device for Bebop ultrasound");
    }

    if (_configure_capture() < 0) {
        return;
    }

    _configure_wave();

    return;
}

/*
 * enable the capture buffer
 * send a pulse over spi
 */
int AP_RangeFinder_Bebop::_launch()
{
    iio_device_attr_write(_adc.device, "buffer/enable", "1");
    _spi->transfer(_tx_buf, RNFD_BEBOP_NB_PULSES_MAX, nullptr, 0);
    return 0;
}

/*
 * read the iio buffer
 * iio_buffer_refill is blocking by default, so this function is also
 * blocking until samples are available
 * disable the capture buffer
 */
int AP_RangeFinder_Bebop::_capture()
{
    int ret;

    ret = iio_buffer_refill(_adc.buffer);
    iio_device_attr_write(_adc.device, "buffer/enable", "0");
    return ret;
}

int AP_RangeFinder_Bebop::_update_mode(float altitude)
{
    switch (_mode) {
    case 0:
        if (altitude < RNFD_BEBOP_TRANSITION_HIGH_TO_LOW
                && !is_zero(altitude)) {
            if (_hysteresis_counter > RNFD_BEBOP_TRANSITION_COUNT) {
                _mode = 1;
                _hysteresis_counter = 0;
                _reconfigure_wave();
            } else {
                _hysteresis_counter++;
            }
        } else {
            _hysteresis_counter = 0;
        }
        break;

    default:
    case 1:
        if (altitude > RNFD_BEBOP_TRANSITION_LOW_TO_HIGH
                || is_zero(altitude)) {
            if (_hysteresis_counter > RNFD_BEBOP_TRANSITION_COUNT) {
                _mode = 0;
                _hysteresis_counter = 0;
                _reconfigure_wave();
            } else {
                _hysteresis_counter++;
            }
        } else {
            _hysteresis_counter = 0;
        }
        break;
    }
    return _mode;
}

#endif  // AP_RANGEFINDER_BEBOP_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           /*
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
#pragma once

#include "AP_RangeFinder_config.h"

#if AP_RANGEFINDER_BEBOP_ENABLED

#include <AP_HAL_Linux/Thread.h>

/*
 * the size of the buffer sent over spi
 */
#define RNFD_BEBOP_NB_PULSES_MAX 32

/*
 * the size of the purge buffer sent over spi
 */
#define RNFD_BEBOP_NB_PULSES_PURGE 64

/*
 * default us frequency
 * 17 times by seconds
 */
#define RNFD_BEBOP_DEFAULT_FREQ 17

/*
 * default adc frequency
 */
#define RNFD_BEBOP_DEFAULT_ADC_FREQ 160000

/*
 * to filter data we make the average of (1 << this_value) datas
 */
#define RNFD_BEBOP_FILTER_POWER 2

/*
 * Speed of sound
 */
#define RNFD_BEBOP_SOUND_SPEED 340

/* above this altitude we should use mode 0 */
#define RNFD_BEBOP_TRANSITION_HIGH_TO_LOW 0.75

/* below this altitude we should use mode 1 */
#define RNFD_BEBOP_TRANSITION_LOW_TO_HIGH 1.5

/* count this times before switching mode */
#define RNFD_BEBOP_TRANSITION_COUNT 5

/*
 * the number of echoes we will keep at most
 */
#define RNFD_BEBOP_MAX_ECHOES 30

struct echo {
    int max_index; /* index in the capture buffer at which the maximum is reached */
    int distance_index; /* index in the capture buffer at which the signal is for
                            the first time above a fixed threshold below the
                            maximum => this corresponds to the real distance
                            that should be attributed to this echo */
};

/*
 * struct related to adc
 * data to receive and process adc datas
 */
struct adc_capture {
    struct iio_device *device;
    struct iio_buffer *buffer;
    unsigned int buffer_size;
    struct iio_channel *channel;
    unsigned int freq;

     /* Used in order to match two echoes of two ADC acquisitions */
    unsigned short threshold_time_rejection;
};

class AP_RangeFinder_Bebop : public AP_RangeFinder_Backend {
public:
    AP_RangeFinder_Bebop(RangeFinder::RangeFinder_State &_state, AP_RangeFinder_Params &_params);

    ~AP_RangeFinder_Bebop(void);
    static bool detect();
    void update(void) override;

protected:

    MAV_DISTANCE_SENSOR _get_mav_distance_sensor_type() const override {
        return MAV_DISTANCE_SENSOR_LASER;
    }

private:
    void _init(void);
    int _launch(void);
    int _capture(void);
    int _update_mode(float altitude);
    void _configure_gpio(int value);
    int _configure_wave();
    void _reconfigure_wave();
    int _configure_capture();
    int _launch_purge();
    void _loop(void);

    Linux::Thread *_thread;
    unsigned short get_threshold_at(int i_capture);
    int _apply_averaging_filter(void);
    int _search_local_maxima(void);
    int _search_maximum_with_max_amplitude(void);

    AP_HAL::OwnPtr<AP_HAL::Device> _spi;
    AP_HAL::GPIO *_gpio;

    struct adc_capture _adc;
    struct iio_context *_iio;

    unsigned char _tx[2][RNFD_BEBOP_NB_PULSES_MAX];
    unsigned char _purge[RNFD_BEBOP_NB_PULSES_PURGE];
    unsigned char* _tx_buf;
    int _hysteresis_counter;
    const unsigned int threshold_echo_init = 1500;
    int _fd = -1;
    uint64_t _last_timestamp;
    int _mode;
    int _nb_echoes;
    int _freq;
    float _altitude;
    unsigned int *_filtered_capture;
    unsigned int _filtered_capture_size;
    struct echo _echoes[RNFD_BEBOP_MAX_ECHOES];
    unsigned int _filter_average = 4;
    int16_t _last_max_distance_cm = 850;
    int16_t _last_min_distance_cm = 32;
};


#endif  // AP_RANGEFINDER_BEBOP_ENABLED
                                                    /*
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include "AP_RangeFinder_Benewake.h"

#if AP_RANGEFINDER_BENEWAKE_ENABLED

#include <AP_HAL/AP_HAL.h>
#include <AP_HAL/utility/sparse-endian.h>

#include <ctype.h>

extern const AP_HAL::HAL& hal;

#define BENEWAKE_FRAME_HEADER 0x59
#define BENEWAKE_FRAME_LENGTH 9
#define BENEWAKE_DIST_MAX_CM 32768
#define BENEWAKE_OUT_OF_RANGE_ADD_CM 100

// format of serial packets received from benewake lidar
//
// Data Bit             Definition      Description
// ------------------------------------------------
// byte 0               Frame header    0x59
// byte 1               Frame header    0x59
// byte 2               DIST_L          Distance (in cm) low 8 bits
// byte 3               DIST_H          Distance (in cm) high 8 bits
// byte 4               STRENGTH_L      Strength low 8 bits
// bute 4 (TF03)        (Reserved)
// byte 5               STRENGTH_H      Strength high 8 bits
// bute 5 (TF03)        (Reserved)
// byte 6 (TF02)        SIG             Reliability in 8 levels, 7 & 8 means reliable
// byte 6 (TFmini)      Distance Mode   0x02 for short distance (mm), 0x07 for long distance (cm)
// byte 6 (TF03)        (Reserved)
// byte 7 (TF02 only)   TIME            Exposure time in two levels 0x03 and 0x06
// byte 8               Checksum        Checksum byte, sum of bytes 0 to bytes 7

// distance returned in reading_m, signal_ok is set to true if sensor reports a strong signal
bool AP_RangeFinder_Benewake::get_reading(float &reading_m)
{
    if (uart == nullptr) {
        return false;
    }

    float sum_cm = 0;
    uint16_t count = 0;
    uint16_t count_out_of_range = 0;

    // read any available lines from the lidar
    for (auto j=0; j<8192; j++) {
        uint8_t c;
        if (!uart->read(c)) {
            break;
        }
        // if buffer is empty and this byte is 0x59, add to buffer
        if (linebuf_len == 0) {
            if (c == BENEWAKE_FRAME_HEADER) {
                linebuf[linebuf_len++] = c;
            }
        } else if (linebuf_len == 1) {
            // if buffer has 1 element and this byte is 0x59, add it to buffer
            // if not clear the buffer
            if (c == BENEWAKE_FRAME_HEADER) {
                linebuf[linebuf_len++] = c;
            } else {
                linebuf_len = 0;
            }
        } else {
            // add character to buffer
            linebuf[linebuf_len++] = c;
            // if buffer now has 9 items try to decode it
            if (linebuf_len == BENEWAKE_FRAME_LENGTH) {
                // calculate checksum
                uint8_t checksum = 0;
                for (uint8_t i=0; i<BENEWAKE_FRAME_LENGTH-1; i++) {
                    checksum += linebuf[i];
                }
                // if checksum matches extract contents
                if (checksum == linebuf[BENEWAKE_FRAME_LENGTH-1]) {
                    // calculate distance
                    uint16_t dist = ((uint16_t)linebuf[3] << 8) | linebuf[2];
                    if (dist >= BENEWAKE_DIST_MAX_CM || dist == uint16_t(model_dist_max_cm())) {
                        // this reading is out of range. Note that we
                        // consider getting exactly the model dist max
                        // is out of range. This fixes an issue with
                        // the TF03 which can give exactly 18000 cm
                        // when out of range
                        count_out_of_range++;
                    } else if (!has_signal_byte()) {
                        // no signal byte from TFmini so add distance to sum
                        sum_cm += dist;
                        count++;
                    } else {
                        // TF02 provides signal reliability (good = 7 or 8)
                        if (linebuf[6] >= 7) {
                            // add distance to sum
                            sum_cm += dist;
                            count++;
                        } else {
                            // this reading is out of range
                            count_out_of_range++;
                        }
                    }
                }
                // clear buffer
                linebuf_len = 0;
            }
        }
    }

    if (count > 0) {
        // return average distance of readings
        reading_m = (sum_cm * 0.01f) / count;
        return true;
    }

    if (count_out_of_range > 0) {
        // if only out of range readings return larger of
        // driver defined maximum range for the model and user defined max range + 1m
        reading_m = MAX(model_dist_max_cm(), max_distance_cm() + BENEWAKE_OUT_OF_RANGE_ADD_CM) * 0.01f;
        return true;
    }

    // no readings so return false
    return false;
}

#endif  // AP_RANGEFINDER_BENEWAKE_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          #pragma once

#include "AP_RangeFinder_config.h"

#if AP_RANGEFINDER_BENEWAKE_ENABLED

#include "AP_RangeFinder_Backend_Serial.h"
#include "AP_RangeFinder.h"

class AP_RangeFinder_Benewake : public AP_RangeFinder_Backend_Serial
{

public:

    using AP_RangeFinder_Backend_Serial::AP_RangeFinder_Backend_Serial;

protected:

    virtual MAV_DISTANCE_SENSOR _get_mav_distance_sensor_type() const override {
        return MAV_DISTANCE_SENSOR_LASER;
    }

    virtual float model_dist_max_cm() const = 0;
    virtual bool has_signal_byte() const { return false; }

private:

    // get a reading
    // distance returned in reading_m
    bool get_reading(float &reading_m) override;

    uint8_t linebuf[10];
    uint8_t linebuf_len;
};

#endif  // AP_RANGEFINDER_BENEWAKE_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    -- Copter attempts to fly home using dead reckoning if the GPS quality deteriorates or an EKF failsafe triggers
--
-- CAUTION: This script only works for Copter 4.3 (and higher)
-- this script checks for low GPS quality and/or an EKF failsafe and if either occurs, flies in the last known direction towards home
--
-- DR_ENABLE : 1 = enabled, 0 = disabled
-- DR_ENABLE_DIST : distance from home (in meters) beyond which the dead reckoning will be enabled
-- DR_GPS_SACC_MAX : GPS speed accuracy maximum, above which deadreckoning home will begin (default is 0.8).  Lower values trigger with good GPS quality, higher values will allow poorer GPS before triggering. Set to 0 to disable use of GPS speed accuracy.
-- DR_GPS_SAT_MIN : GPS satellite count threshold below which deadreckoning home will begin (default is 6).  Higher values trigger with good GPS quality, Lower values trigger with worse GPS quality. Set to 0 to disable use of GPS satellite count.
-- DR_GPS_TRIGG_SEC : GPS checks must fail for this many seconds before dead reckoning will be triggered.
-- DR_FLY_ANGLE : lean angle (in degrees) during deadreckoning.  Most vehicles reach maximum speed at 22deg
-- DR_FLY_ALT_MIN : min alt (above home in meters) during deadreckoning. zero to return at current alt
-- DR_FLY_TIMEOUT : timeout (in seconds).  Vehicle will attempt to switch to NEXT_MODE after this many seconds of deadreckoning.  If it cannot switch modes it will continue in Guided_NoGPS.  Set to 0 to disable timeout
-- DR_NEXT_MODE : flight mode vehicle will change to when GPS / EKF recovers or DR_FLY_TIMEOUT expires.  Default is 6=RTL, see FLTMODE1 parameter description for list of flight mode number.  Set to -1 to return to mode used before deadreckoning was triggered

-- How to use:
--   1. set SCR_ENABLE = 1 to enable scripting (and reboot the autopilot)
--   2. set SCR_HEAP_SIZE to 80000 or higher to allocate enough memory for this script
--   3. set DR_ENABLE = 1 to enable dead reckoning
--   4. optionally set DR_GPS_SACC_MAX and/or DR_GPS_SAT_MIN parameters to adjust how bad the GPS quality must be before triggering
--   5. confirm "DR: waiting for dist (Xm < 50m)" message is displayed on ground station (so you know script is working)
--   6. arm and takeoff to a safe altitude
--   7. fly at least DR_ENABLE_DIST meters from home and confirm "DR: activated!" is displayed on ground station
--
--   If this script senses low GPS quality or an EKF failsafe triggers:
--       - vehicle will change to Guided_NoGPS mode
--       - vehicle will lean in the last known direction of home (see DR_FLY_ANGLE)
--       - if GPS recovers or EKF failsafe is cleared the vehicle will switch to DR_NEXT_MODE (if -1 then it will switch back to the mode in use before the GPS/EKF failure)
--       - if the timeout is surpassed (see DR_FLY_TIMEOUT) the vehicle will try to switch to DR_NEXT_MODE.  If it fails to change it will continue in Guided_NoGPS but keep trying to change mode
--       - the pilot can retake control by switching to an "unprotected" mode like AltHold, Loiter (see "protected_mode_array" below)
--
-- Testing in SITL:
--   a. set map setshowsimpos 1 (to allow seeing where vehicle really is in simulator even with GPS disabled)
--   b. set SIM_GPS_DISABLE = 1 to disable GPS (confirm dead reckoning begins)
--   c. set SIM_GPS_DISABLE = 0 to re-enable GPS
--   d. set SIM_GPS_NUMSAT = 3 to lower simulated satellite count to confirm script triggers
--   e. set DR_GPS_SACC_MAX = 0.01 to lower the threshold and trigger below the simulator value which is 0.04 (remember to set this back after testing!)
--
-- Test on a real vehicle:
--   A. set DR_FLY_TIMEOUT to a low value (e.g. 5 seconds)
--   B. fly the vehicle at least DR_DIST_MIN meters from home and confirm the "DR: activated!" message is displayed
--   C. set GPS1_TYPE = 0 to disable GPS and confirm the vehicle begins deadreckoning after a few seconds
--   D. restore GPS1_TYPE to its original value (normally 1) and confirm the vehicle switches to DR_NEXT_MODE
--   E. restore DR_FLY_TIMEOUT to a higher value for real-world use
-- Note: Instaed of setting GPS1_TYPE, an auxiliary function switch can be setup to disable the GPS (e.g. RC9_OPTION = 65/"Disable GPS")
--
-- Testing that it does not require RC (in SITL):
--   a. set FS_OPTIONS's "Continue if in Guided on RC failsafe" bit
--   b. set FS_GCS_ENABLE = 1 (to enable GCS failsafe otherwise RC failsafe will trigger anyway)
--   c. optionally set SYSID_MYGCS = 77 (or almost any other unused system id) to trick the above check so that GCS failsafe can really be disabled
--   d. set SIM_RC_FAIL = 1 (to simulate RC failure, note vehicle keeps flying)
--   e. set SIM_RC_FAIL = 0 (to simulate RC recovery)
--
-- Test with wind (in SITL)
--   a. SIM_WIND_DIR <-- sets direction wind is coming from
--   b. SIM_WIND_SPD <-- sets wind speed in m/s
--

---@diagnostic disable: param-type-mismatch
---@diagnostic disable: cast-local-type

-- create and initialise parameters
local PARAM_TABLE_KEY = 86  -- parameter table key must be used by only one script on a particular flight controller
assert(param:add_table(PARAM_TABLE_KEY, "DR_", 9), 'could not add param table')
assert(param:add_param(PARAM_TABLE_KEY, 1, 'ENABLE', 1), 'could not add DR_ENABLE param')   -- 1 = enabled, 0 = disabled
assert(param:add_param(PARAM_TABLE_KEY, 2, 'ENABLE_DIST', 50), 'could not add DR_ENABLE_DIST param')   -- distance from home (in meters) beyond which the dead reckoning will be enabled
assert(param:add_param(PARAM_TABLE_KEY, 3, 'GPS_SACC_MAX', 0.8), 'could not add DR_GPS_SACC_MAX param') -- GPS speed accuracy max threshold
assert(param:add_param(PARAM_TABLE_KEY, 4, 'GPS_SAT_MIN', 6), 'could not add DR_GPS_SAT_MIN param')  -- GPS satellite count min threshold
assert(param:add_param(PARAM_TABLE_KEY, 5, 'GPS_TRIGG_SEC', 3), 'could not add DR_GPS_TRIGG_SEC parameter') -- GPS checks must fail for this many seconds before dead reckoning will be triggered

assert(param:add_param(PARAM_TABLE_KEY, 6, 'FLY_ANGLE', 10), 'could not add DR_FLY_ANGLE param')    -- lean angle (in degrees) during deadreckoning
assert(param:add_param(PARAM_TABLE_KEY, 7, 'FLY_ALT_MIN', 0), 'could not add DR_FLY_ALT_MIN param') -- min alt above home (in meters) during deadreckoning. zero to return at current alt
assert(param:add_param(PARAM_TABLE_KEY, 8, 'FLY_TIMEOUT', 30), 'could not add DR_FLY_TIMEOUT param')-- deadreckoning timeout (in seconds)
assert(param:add_param(PARAM_TABLE_KEY, 9, 'NEXT_MODE', 6), 'could not add DR_NEXT_MODE param')     -- mode to switch to after GPS recovers or timeout elapses

-- bind parameters to variables
--[[
  // @Param: DR_ENABLE
  // @DisplayName: Deadreckoning Enable
  // @Description: Deadreckoning Enable
  // @Values: 0:Disabled,1:Enabled
  // @User: Standard
--]]
local enable = Parameter("DR_ENABLE")                  -- 1 = enabled, 0 = disabled

--[[
  // @Param: DR_ENABLE_DIST
  // @DisplayName: Deadreckoning Enable Distance
  // @Description: Distance from home (in meters) beyond which the dead reckoning will be enabled
  // @Units: m
  // @User: Standard
--]]
local enable_dist = Parameter("DR_ENABLE_DIST")        -- distance from home (in meters) beyond which the dead reckoning will be enabled

--[[
  // @Param: DR_GPS_SACC_MAX
  // @DisplayName: Deadreckoning GPS speed accuracy maximum threshold
  // @Description: GPS speed accuracy maximum, above which deadreckoning home will begin (default is 0.8).  Lower values trigger with good GPS quality, higher values will allow poorer GPS before triggering. Set to 0 to disable use of GPS speed accuracy
  // @Range: 0 10
  // @User: Standard
--]]
local gps_speed_acc_max = Parameter("DR_GPS_SACC_MAX") -- GPS speed accuracy max threshold

--[[
  // @Param: DR_GPS_SAT_MIN
  // @DisplayName: Deadreckoning GPS satellite count min threshold
  // @Description: GPS satellite count threshold below which deadreckoning home will begin (default is 6).  Higher values trigger with good GPS quality, Lower values trigger with worse GPS quality. Set to 0 to disable use of GPS satellite count
  // @Range: 0 30
  // @User: Standard
--]]
local gps_sat_count_min = Parameter("DR_GPS_SAT_MIN")  -- GPS satellite count min threshold

--[[
  // @Param: DR_GPS_TRIGG_SEC
  // @DisplayName: Deadreckoning GPS check trigger seconds
  // @Description: GPS checks must fail for this many seconds before dead reckoning will be triggered
  // @Units: s
  // @User: Standard
--]]
local gps_trigger_sec = Parameter("DR_GPS_TRIGG_SEC")  -- GPS checks must fail for this many seconds before dead reckoning will be triggered

--[[
  // @Param: DR_FLY_ANGLE
  // @DisplayName: Deadreckoning Lean Angle
  // @Description: lean angle (in degrees) during deadreckoning
  // @Units: deg
  // @Range: 0 45
  // @User: Standard
--]]
local fly_angle = Parameter("DR_FLY_ANGLE")            -- lean angle (in degrees) during deadreckoning

--[[
  // @Param: DR_FLY_ALT_MIN
  // @DisplayName: Deadreckoning Altitude Min
  // @Description: Copter will fly at at least this altitude (in meters) above home during deadreckoning
  // @Units: m
  // @Range: 0 1000
  // @User: Standard
--]]
local fly_alt_min = Parameter("DR_FLY_ALT_MIN")        -- min alt above home (in meters) during deadreckoning

--[[
  // @Param: DR_FLY_TIMEOUT
  // @DisplayName: Deadreckoning flight timeout
  // @Description: Copter will attempt to switch to NEXT_MODE after this many seconds of deadreckoning.  If it cannot switch modes it will continue in Guided_NoGPS.  Set to 0 to disable timeout
  // @Units: s
  // @User: Standard
--]]
local fly_timeoout = Parameter("DR_FLY_TIMEOUT")       -- deadreckoning timeout (in seconds)

--[[
  // @Param: DR_NEXT_MODE
  // @DisplayName: Deadreckoning Next Mode
  // @Description: Copter switch to this mode after GPS recovers or DR_FLY_TIMEOUT has elapsed.  Default is 6/RTL.  Set to -1 to return to mode used before deadreckoning was triggered
  // @Values: 2:AltHold,3:Auto,4:Guided,5:Loiter,6:RTL,7:Circle,9:Land,16:PosHold,17:Brake,20:Guided_NoGPS,21:Smart_RTL,27:Auto RTL
  // @User: Standard
--]]
local next_mode = Parameter("DR_NEXT_MODE")            -- mode to switch to after GPS recovers or timeout elapses
local wpnav_speedup = Parameter("WPNAV_SPEED_UP")      -- maximum climb rate from WPNAV_SPEED_UP
local wpnav_accel_z = Parameter("WPNAV_ACCEL_Z")       -- maximum vertical acceleration from WPNAV_ACCEL_Z

-- modes deadreckoning may be activated from
-- comment out lines below to remove protection from these modes
local protected_mode_array = {
         3, -- AUTO
         4, -- GUIDED
         --5, -- LOITER
         6, -- RTL
         7, -- CIRCLE
         9, -- LAND
         --11, -- DRIFT
         --16, -- POSHOLD
         17, -- BRAKE
         21, -- SMART_RTL
         27, -- AUTO_RTL
        }
function is_protected_mode()
   local curr_mode = vehicle:get_mode()
   for i = 1, #protected_mode_array do
     if curr_mode == protected_mode_array[i] then
       return true
     end
   end
   return false
end

local copter_guided_nogps_mode = 20 -- Guided_NoGPS is mode 20 on Copter
local copter_RTL_mode = 6           -- RTL is mode 6 on Copter
local recovery_delay_ms = 3000      -- switch to NEXT_MODE happens this many milliseconds after GPS and EKF failsafe recover

local gps_bad = false               -- true if GPS is failing checks
local ekf_bad = false               -- true if EKF failsafe has triggered
local gps_or_ekf_bad = true         -- true if GPS and/or EKF is bad, true once both have recovered

local flight_stage = 0  -- 0. wait for good-gps and dist-from-home, 1=wait for bad gps or ekf, 2=level vehicle, 3=deadreckon home
local gps_bad_start_time_ms = 0 -- system time GPS quality went bad (0 if not bad)
local recovery_start_time_ms = 0-- system time GPS quality and EKF failsafe recovered (0 if not recovered)

local home_dist = 0     -- distance to home in meters
local home_yaw = 0      -- direction to home in degrees

local target_yaw = 0    -- deg
local climb_rate = 0    -- m/s

local stage1_flight_mode = nil  -- flight mode vehicle was in during stage1 (may be used during recovery)
local stage2_start_time_ms  -- system time stage2 started (level vehicle)
local stage3_start_time_ms  -- system time stage3 started (deadreckon home)
local last_print_ms = 0     -- pilot update timer
local interval_ms = 100     -- update at 10hz

function update()

  -- exit immediately if not enabled
  if (enable:get() < 1) then
    return update, 1000
  end

  -- determine if progress update should be sent to user
  local now_ms = millis()
  local update_user = false
  if (now_ms - last_print_ms > 5000) then
    last_print_ms = now_ms
    update_user = true
  end

  -- check GPS
  local gps_speed_acc = gps:speed_accuracy(gps:primary_sensor())
  if gps_speed_acc == nil then
    gps_speed_acc = 99
  end
  local gps_speed_acc_bad = ((gps_speed_acc_max:get() > 0) and (gps_speed_acc > gps_speed_acc_max:get()))
  local gps_num_sat = gps:num_sats(gps:primary_sensor())
  local gps_num_sat_bad = (gps_sat_count_min:get() > 0) and ((gps_num_sat == nil) or (gps:num_sats(gps:primary_sensor()) < gps_sat_count_min:get()))
  if gps_bad then
    -- GPS is bad, check for recovery
    if (not gps_speed_acc_bad and not gps_num_sat_bad) then
      gps_bad = false
    end
  else
    -- GPS is good, check for GPS going bad
    if (gps_speed_acc_bad or gps_num_sat_bad) then
      if (gps_bad_start_time_ms == 0) then
        -- start gps bad timer
        gps_bad_start_time_ms = now_ms
      elseif (now_ms - gps_bad_start_time_ms > gps_trigger_sec:get()) then
        gps_bad = true
      end
    end
  end

  -- check EKF failsafe
  local fs_ekf = vehicle:has_ekf_failsafed()
  if ekf_bad ~= fs_ekf then
    ekf_bad = fs_ekf
  end

  -- check for GPS and/or EKF going bad
  if not gps_or_ekf_bad and (gps_bad or ekf_bad) then
    gps_or_ekf_bad = true
    gcs:send_text(0, "DR: GPS or EKF bad")
  end

  -- check for GPS and/or EKF recovery
  if (gps_or_ekf_bad and (not gps_bad and not ekf_bad)) then
    -- start recovery timer
    if recovery_start_time_ms == 0 then
      recovery_start_time_ms = now_ms
    end
    if (now_ms - recovery_start_time_ms > recovery_delay_ms) then
      gps_or_ekf_bad = false
      recovery_start_time_ms = 0
      gcs:send_text(0, "DR: GPS and EKF recovered")
    end
  end

  -- update distance and direction home while GPS and EKF are good
  if (not gps_or_ekf_bad) then
    local home = ahrs:get_home()
    local curr_loc = ahrs:get_location()
    if home and curr_loc then
      home_dist = curr_loc:get_distance(home)
      home_yaw = math.deg(curr_loc:get_bearing(home))
    elseif (update_user) then
      -- warn user of unexpected failure
      gcs:send_text(0, "DR: could not get home or vehicle location")
    end
  end

  -- reset flight_stage when disarmed
  if not arming:is_armed() then 
    flight_stage = 0
    transition_start_time_ms = 0
    return update, interval_ms
  end

  -- flight_stage 0: wait for good gps and dist-from-home
  if (flight_stage == 0) then

    -- wait for GPS and EKF to be good
    if (gps_or_ekf_bad) then
      return update, interval_ms
    end

    -- wait for distance from home to pass DR_ENABLE_DIST
    if ((home_dist > 0) and (home_dist >= enable_dist:get())) then
      gcs:send_text(5, "DR: enabled")
      flight_stage = 1
    elseif (update_user) then
      gcs:send_text(5, "DR: waiting for dist:" .. tostring(math.floor(home_dist)) .. " need:" .. tostring(math.floor(enable_dist:get())))
    end
    return update, interval_ms
  end

  -- flight_stage 1: wait for bad gps or ekf
  if (flight_stage == 1) then
    if (gps_or_ekf_bad and is_protected_mode()) then
      -- change to Guided_NoGPS and initialise stage2
      if (vehicle:set_mode(copter_guided_nogps_mode)) then
        flight_stage = 2
        target_yaw = math.deg(ahrs:get_yaw())
        stage2_start_time_ms = now_ms
      else
        -- warn user of unexpected failure
        if (update_user) then
          gcs:send_text(5, "DR: failed to change to Guided_NoGPS mode")
        end
      end
    else
      -- store flight mode (may be used during recovery)
      stage1_flight_mode = vehicle:get_mode()
    end
    return update, interval_ms
  end

  -- flight_stage 2: level vehicle for 5 seconds
  if (flight_stage == 2) then
    -- allow pilot to retake control
    if (vehicle:get_mode() ~= copter_guided_nogps_mode) then
      gcs:send_text(5, "DR: pilot retook control")
      flight_stage = 1
      return update, interval_ms
    end

    -- level vehicle for 5 seconds
    climb_rate = 0
    vehicle:set_target_angle_and_climbrate(0, 0, target_yaw, climb_rate, false, 0)
    if ((now_ms - stage2_start_time_ms) >= 5000) then
      flight_stage = 3
      stage3_start_time_ms = now_ms
      gcs:send_text(5, "DR: flying home")
    end
    if (update_user) then
      gcs:send_text(5, "DR: leveling vehicle")
    end
    return update, interval_ms
  end

  -- flight_stage 3: deadreckon towards home
  if (flight_stage == 3) then

    -- allow pilot to retake control
    if (vehicle:get_mode() ~= copter_guided_nogps_mode) then
      gcs:send_text(5, "DR: pilot retook control")
      flight_stage = 1
      return update, interval_ms
    end

    -- check for timeout
    local time_elapsed_ms = now_ms - stage3_start_time_ms
    local timeout = (fly_timeoout:get() > 0) and (time_elapsed_ms >= (fly_timeoout:get() * 1000))

    -- calculate climb rate in m/s
    if (fly_alt_min:get() > 0) then
      local curr_alt_below_home = ahrs:get_relative_position_D_home()
      if curr_alt_below_home then
        local target_alt_above_vehicle = fly_alt_min:get() + curr_alt_below_home
        if target_alt_above_vehicle > 0 then
          -- climb at up to 1m/s towards target above vehicle.  climb rate change is limited by WPNAV_ACCEL_Z
          local climb_rate_chg_max = interval_ms * 0.001 * (wpnav_accel_z:get() * 0.01)
          climb_rate = math.min(target_alt_above_vehicle * 0.1, wpnav_speedup:get() * 0.01, climb_rate + climb_rate_chg_max)
        end
      end
    end

    -- set angle target to roll 0, pitch to lean angle (note: negative is forward), yaw towards home
    if (vehicle:set_target_angle_and_climbrate(0, -math.abs(fly_angle:get()), home_yaw, climb_rate, false, 0)) then
      if (update_user) then
        local time_left_str = ""
        if (not timeout and (fly_timeoout:get() > 0)) then
          time_left_str = " t:" .. tostring(math.max(0, ((fly_timeoout:get() * 1000) - time_elapsed_ms) / 1000))
        end
        gcs:send_text(5, "DR: fly home yaw:" .. tostring(math.floor(home_yaw)) .. " pit:" .. tostring(math.floor(fly_angle:get())) .. " cr:" .. tostring(math.floor(climb_rate*10)/10) .. time_left_str)
      end
    elseif (update_user) then
      gcs:send_text(0, "DR: failed to set attitude target")
    end

    -- if GPS and EKF recover or timeout switch to next mode
    if (not gps_or_ekf_bad) or timeout then
      local recovery_mode = stage1_flight_mode
      if (next_mode:get() >= 0) then
        recovery_mode = next_mode:get()
      end
      if (recovery_mode == nil) then
        recovery_mode = copter_RTL_mode
        gcs:send_text(0, "DR: NEXT_MODE=-1 but fallingback to RTL")
      end
      -- change to DR_NEXT_MODE
      if (vehicle:set_mode(recovery_mode)) then
        flight_stage = 0
      elseif (update_user) then
        -- warn user of unexpected failure        
        gcs:send_text(0, "DR: failed to change to mode " .. tostring(recovery_mode))
      end
    end
    return update, interval_ms
  end

  -- we should never get here but just in case
  return update, interval_ms
end

return update()

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            # Copter Deadreckon Home applet

Copter attempts to fly home using dead reckoning if the GPS quality deteriorates or an EKF failsafe triggers

CAUTION: This script only works for Copter 4.3 (and higher)

Deadreckoning will only be activated while the vehicle is in autonomous modes (e.g. Auto, Guided, RTL, Circle, Land, Brake, SmartRTL or AutoRTL modes).  Deadreckoning is not activated in pilot controlled modes (e.g. Loiter, PosHold, etc) because we assume the pilot could simply switch to AltHold and fly the vehicle home manually.

## Parmeter Descriptions

  - DR_ENABLE : 1 = enabled, 0 = disabled
  - DR_ENABLE_DIST : distance from home (in meters) beyond which the dead reckoning will be enabled
  - DR_GPS_SACC_MAX : GPS speed accuracy maximum, above which deadreckoning home will begin (default is 0.8).  Lower values trigger with good GPS quality, higher values will allow poorer GPS before triggering. Set to 0 to disable use of GPS speed accuracy.
  - DR_GPS_SAT_MIN : GPS satellite count threshold below which deadreckoning home will begin (default is 6).  Higher values trigger with good GPS quality, Lower values trigger with worse GPS quality. Set to 0 to disable use of GPS satellite count.
  - DR_GPS_TRIGG_SEC : GPS checks must fail for this many seconds before dead reckoning will be triggered.
  - DR_FLY_ANGLE : lean angle (in degrees) during deadreckoning.  Most vehicles reach maximum speed at 22deg
  - DR_FLY_ALT_MIN : min alt (above home in meters) during deadreckoning. zero to return at current alt
  - DR_FLY_TIMEOUT : timeout (in seconds).  Vehicle will attempt to switch to NEXT_MODE after this many seconds of deadreckoning.  If it cannot switch modes it will continue in Guided_NoGPS.  Set to 0 to disable timeout
  - DR_NEXT_MODE : flight mode vehicle will change to when GPS / EKF recovers or DR_FLY_TIMEOUT expires.  Default is 6=RTL, see FLTMODE1 parameter description for list of flight mode number.  Set to -1 to return to mode used before deadreckoning was triggered

## How to use

  1. set SCR_ENABLE = 1 to enable scripting (and reboot the autopilot)
  2. set SCR_HEAP_SIZE to 80000 or higher to allocate enough memory for this script
  3. set DR_ENABLE = 1 to enable dead reckoning
  4. optionally set DR_GPS_SACC_MAX and/or DR_GPS_SAT_MIN parameters to adjust how bad the GPS quality must be before triggering
  5. confirm "DR: waiting for dist (Xm < 50m)" message is displayed on ground station (so you know script is working)
  6. arm and takeoff to a safe altitude
  7. fly at least DR_ENABLE_DIST meters from home and confirm "DR: activated!" is displayed on ground station

  If this script senses low GPS quality or an EKF failsafe triggers

  - vehicle will change to Guided_NoGPS mode
  - vehicle will lean in the last known direction of home (see DR_FLY_ANGLE)
  - if GPS recovers or EKF failsafe is cleared the vehicle will switch to DR_NEXT_MODE (if -1 then it will switch back to the mode in use before the GPS/EKF failure)
  - if the timeout is surpassed (see DR_FLY_TIMEOUT) the vehicle will try to switch to DR_NEXT_MODE.  If it fails to change it will continue in Guided_NoGPS but keep trying to change mode
  - the pilot can retake control by switching to an "unprotected" mode like AltHold, Loiter (see "protected_mode_array" below)

## Testing in SITL

  - set map setshowsimpos 1 (to allow seeing where vehicle really is in simulator even with GPS disabled)
  - set SIM_GPS_DISABLE = 1 to disable GPS (confirm dead reckoning begins)
  - set SIM_GPS_DISABLE = 0 to re-enable GPS
  - set SIM_GPS_NUMSAT = 3 to lower simulated satellite count to confirm script triggers
  - set DR_GPS_SACC_MAX = 0.01 to lower the threshold and trigger below the simulator value which is 0.04 (remember to set this back after testing!)

## Test on a real vehicle

  1. set DR_FLY_TIMEOUT to a low value (e.g. 5 seconds)
  2. fly the vehicle at least DR_DIST_MIN meters from home and confirm the "DR: activated!" message is displayed
  3. set GPS1_TYPE = 0 to disable GPS and confirm the vehicle begins deadreckoning after a few seconds
  4. restore GPS1_TYPE to its original value (normally 1) and confirm the vehicle switches to DR_NEXT_MODE
  5. restore DR_FLY_TIMEOUT to a higher value for real-world use

  Note: Instaed of setting GPS1_TYPE, an auxiliary function switch can be setup to disable the GPS (e.g. RC9_OPTION = 65/"Disable GPS")

## Testing that it does not require RC (in SITL):
  - set FS_OPTIONS's "Continue if in Guided on RC failsafe" bit
  - set FS_GCS_ENABLE = 1 (to enable GCS failsafe otherwise RC failsafe will trigger anyway)
  - optionally set SYSID_MYGCS = 77 (or almost any other unused system id) to trick the above check so that GCS failsafe can really be disabled
  - set SIM_RC_FAIL = 1 (to simulate RC failure, note vehicle keeps flying)
  - set SIM_RC_FAIL = 0 (to simulate RC recovery)

## Test with wind (in SITL)
  - SIM_WIND_DIR <-- sets direction wind is coming from
  - SIM_WIND_SPD <-- sets wind speed in m/s
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        # Copter Loiter Brake

This script implements an emergency change to BRAKE mode in copter if
you are in LOITER mode and break a terrain altitude limit. The script
is useful when flying in LOITER mode in steep terrain.

# Parameters

The script adds the following parameters to control it's behaviour.

## TERR_BRK_ENABLE

This must be set to 1 to enable the script.

## TERR_BRK_ALT

This is the terrain altitude threshold for engaging BRAKE mode. The
onboard terrain system must be enabled with TERRAIN_ENABLE=1 and
terrain must have either been preloaded to the vehicle (see
https://terrain.ardupilot.org ) or be available from the ground
station over MAVLink.

Make sure you set sufficient margin to cope with obstacles such as
trees or any local towers or other obstacles.

## TERR_BRK_HDIST

This is the distance from home for the BRAKE checking to be
enabled. The default of 100 meters is good for most operations. This
threshold allows you to take over in LOITER mode for low altitude
operations and takeoff/landing when close to home.

## TERR_BRK_SPD

This is a speed threshold BRAKE checking to be enabled. If both the
horizontal speed and the descent rate are below this threshold then
BRAKE will not be engaged. This defaults to zero which means no speed
checking is performed.

You should set this to a small value if you want to be able to recover
from BRAKE mode by climbing straight up in LOITER mode. A value of 0.5
m/s is recommended. The value needed will be dependent on the amount
of noise there is in your velocity measurement and how gusty the wind
is, but 0.5 should work in most applications.

If you set this value then to recover in LOITER mode you should raise
the throttle stick to demand climb before you switch back to LOITER
mode. The positive climb rate means BRAKE will not re-engage.

# Operation

Install the lua script in the APM/SCRIPTS directory on the flight
controllers microSD card. Review the above parameter descriptions and
decide on the right parameter values for your vehicle and operations.

Make sure TERRAIN_ENABLE is 1 and you should preload terrain data for
the flight area from https://terrain.ardupilot.org

It is strongly recommended that you set TERRAIN_SPACING=30 and preload
the SRTM1 terrain data for 30m horizontal resolution of terrain data.

When the system engages you will see a message like this
 "Terrain 29.2m - BRAKE"
where in this example you are 29.2m above the terrain.

To recover you could use GUIDED mode, or RTL (make sure you have set
RTL_ALT_TYPE to terrain) or if you have set TERR_BRK_SPD to a positive
value then you could raise the throttle stick and switch back to
LOITER mode.

If the system is continually giving false positives then set
TERR_BRK_ENABLE to zero to disable.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          -- This is a script that stops motors in forward flight, for use on tiltrotors and tailsitters
-- Thanks to PteroDynamics for supporting the development of this script
-- Set the motor numbers to stop and configure a RCx_OPTION to 300 to enable and disable
-- Throttle thresholds also allow automatic enable and disable of stop motors
-- slew up and down times allow to configure how fast the motors are disabled and re-enabled

-- luacheck: only 0
---@diagnostic disable: cast-local-type


-- Config

-- Motors numbers to stop
local stop_motors = {2,4}

-- motors should be shutdown if throttle goes lower than this value (%), set to > 100 to disable auto enable/disable
local throttle_off_threshold = 50

-- motors should be re-enabled if throttle higher than this value (%)
local throttle_on_threshold = 75

local slew_down_time = 5 -- seconds
local slew_up_time = 1 -- seconds

-- end of config

local switch = assert(rc:find_channel_for_option(300),"Lua: Could not find switch")

-- read spin min param, we set motors to this PWM to stop them
local pwm_min = assert(param:get("Q_M_PWM_MIN"),"Lua: Could not read Q_M_PWM_MIN")
local pwm_max = assert(param:get("Q_M_PWM_MAX"),"Lua: Could not read Q_M_PWM_MAX")

-- calculate the slew up and down steps to achieve the given slew time
local pwm_range = pwm_max - pwm_min
local slew_down = (-pwm_range / slew_down_time) * (10/1000)
local slew_up = (pwm_range / slew_up_time) * (10/1000)

if throttle_off_threshold < 100 then
  assert((throttle_off_threshold < throttle_on_threshold) and (throttle_on_threshold < 100), "throttle on and off thresholds not configured correctly")
end

-- clear vars we don't need anymore
slew_down_time = nil
slew_up_time = nil
pwm_range = nil


for i = 1, #stop_motors do
  -- Check for a valid motor number
  assert(stop_motors[i] >= 1 and stop_motors[i] <= 12, string.format("Lua: motor %i not valid",stop_motors[i]))
end

-- find any motors enabled, populate channels to stop and channels to run
-- run channels provide a average motor PWM to slew down from
local stop_motor_chan = {}
local run_motor_fun = {}
for i = 1, 12 do

  local output_function
  if i <= 8 then
    output_function = i+32
  else
    output_function = i+81-8
  end

  local temp_chan = SRV_Channels:find_channel(output_function)

  local should_stop = false
  for j = 1, #stop_motors do
    if i == stop_motors[j] then
      should_stop = true
      break
    end
  end

  if should_stop then
    assert(temp_chan, string.format("Lua: Could not find motor %i",i))
    table.insert(stop_motor_chan, temp_chan)
  elseif temp_chan then
    table.insert(run_motor_fun, output_function)
  end
end
assert(#stop_motor_chan == #stop_motors, "Lua: could not find all motors to stop")
assert(#run_motor_fun > 0, "Lua: cannot stop all motors")

-- keep track of last time in a VTOL mode, this allows to delay switching after a transition/assist
local last_vtol_active = 0

-- current action
local script_enabled = false
local motors_disabled = false
local slew
local slew_pwm
function update()

  if switch:get_aux_switch_pos() == 2 then
    if not script_enabled then
      gcs:send_text(0, "Lua: Forward flight motor shutdown enabled")
    end
    script_enabled = true
  else
    if script_enabled then
      gcs:send_text(0, "Lua: Forward flight motor shutdown disabled")
    end
    script_enabled = false
  end

  if quadplane:in_vtol_mode() or quadplane:in_assisted_flight() or not arming:is_armed() then
    -- in a VTOL mode, nothing to do
    last_vtol_active = millis()
    motors_disabled = false
    return update, 1000 -- reschedule at 1hz
  end

  -- script not enabled
  if not script_enabled then
    motors_disabled = false
    return update, 1000 -- reschedule at 1hz
  end

  -- in forward flight and enabled with switch, if armed then check that we are at least 10s past transition
  if (millis() - last_vtol_active) < 10000 then
    -- armed and have not been in a VTOL mode for longer than 10s
    motors_disabled = false
    return update, 1000 -- reschedule at 10hz
  end

  -- check throttle level to see if motors should be disabled or enabled
  local throttle = SRV_Channels:get_output_scaled(70)

  if motors_disabled and (throttle > throttle_on_threshold) then
    gcs:send_text(0, "Lua: Throttle high motors enabled")
    slew = slew_up

  elseif (not motors_disabled) and (throttle < throttle_off_threshold) then
    slew_pwm = pwm_max
    motors_disabled = true
    gcs:send_text(0, "Lua: Throttle low motors disabled")
    slew = slew_down
  end

  if not motors_disabled then
    return update, 10
  end

  local average_pwm = 0
  for i = 1, #run_motor_fun do
    average_pwm = average_pwm + SRV_Channels:get_output_pwm(run_motor_fun[i])
  end
  average_pwm = average_pwm / #run_motor_fun

  slew_pwm = slew_pwm + slew
  if (slew > 0) and (slew_pwm > average_pwm) then
    -- slewed back up past the output of other motors, stop overriding
    motors_disabled = false
    slew_pwm = pwm_max
    return update, 1000
  end

  -- never slew lower than min
  slew_pwm = math.max(slew_pwm, pwm_min)

  -- never output higher than other motors
  local output_pwm = math.min(slew_pwm, average_pwm)

  -- make sure a integer
  output_pwm = math.floor(output_pwm + 0.5)

  for i = 1, #stop_motor_chan do
    -- override for 15ms, should be called every 10ms when active
    -- using timeout means if the script dies the timeout will expire and all motors will come back
    -- we cant leave the vehicle in a un-flyable state
    SRV_Channels:set_output_pwm_chan_timeout(stop_motor_chan[i],output_pwm,15)
  end

  return update, 10 -- reschedule at 100hz
end

return update() -- run immediately before starting to reschedule
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                # Forward flight motor shutdown script for tailsitters and tiltrotors

This allows to shutdown selected motors to be stopped once in forward flight for efficiency.

Set the motors to shutdown in with the `stop_motors` variable. Enable and disable the functionality with a RC switch with options 300 (Scripting1).

Motors will automatically be shutdown if forward throttle is lower than the value set in `throttle_off_threshold` (50% by default) the motors will then be re-enabled if the throttle goes above the value set in `throttle_on_threshold` (75% by default).

Time for stopped motors to go from throttle value to 0 and 0 back to throttle can be set with `slew_down_time` and `slew_up_time`.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      