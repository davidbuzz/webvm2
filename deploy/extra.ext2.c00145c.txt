 should already be this value after reset
          write_register(GPIO__TIO_HV_STATUS, 0x02) &&
          write_register(SIGMA_ESTIMATOR__EFFECTIVE_PULSE_WIDTH_NS, 8) && // tuning parm default
          write_register(SIGMA_ESTIMATOR__EFFECTIVE_AMBIENT_WIDTH_NS, 16) && // tuning parm default
          write_register(ALGO__CROSSTALK_COMPENSATION_VALID_HEIGHT_MM, 0x01) &&
          write_register(ALGO__RANGE_IGNORE_VALID_HEIGHT_MM, 0xFF) &&
          write_register(ALGO__RANGE_MIN_CLIP, 0) && // tuning parm default
          write_register(ALGO__CONSISTENCY_CHECK__TOLERANCE, 2) && // tuning parm default

          // general config
          write_register16(SYSTEM__THRESH_RATE_HIGH, 0x0000) &&
          write_register16(SYSTEM__THRESH_RATE_LOW, 0x0000) &&
          write_register(DSS_CONFIG__APERTURE_ATTENUATION, 0x38) &&

          // timing config
          write_register16(RANGE_CONFIG__SIGMA_THRESH, 360) && // tuning parm default
          write_register16(RANGE_CONFIG__MIN_COUNT_RATE_RTN_LIMIT_MCPS, 192) && // tuning parm default

          // dynamic config
          write_register(SYSTEM__GROUPED_PARAMETER_HOLD_0, 0x01) &&
          write_register(SYSTEM__GROUPED_PARAMETER_HOLD_1, 0x01) &&
          write_register(SD_CONFIG__QUANTIFIER, 2) && // tuning parm default

          // from VL53L1_preset_mode_timed_ranging_*
          // GPH is 0 after reset, but writing GPH0 and GPH1 above seem to set GPH to 1,
          // and things don't seem to work if we don't set GPH back to 0 (which the API
          // does here).
          write_register(SYSTEM__GROUPED_PARAMETER_HOLD, 0x00) &&
          write_register(SYSTEM__SEED_CONFIG, 1) && // tuning parm default

          // from VL53L1_config_low_power_auto_mode
          write_register(SYSTEM__SEQUENCE_CONFIG, 0x8B) && // VHV, PHASECAL, DSS1, RANGE
          write_register16(DSS_CONFIG__MANUAL_EFFECTIVE_SPADS_SELECT, 200 << 8) &&
          write_register(DSS_CONFIG__ROI_MODE_CONTROL, 2) && // REQUESTED_EFFFECTIVE_SPADS
          read_register16(MM_CONFIG__OUTER_OFFSET_MM, mm_config_outer_offset_mm) &&
          setDistanceMode(mode) &&
          setMeasurementTimingBudget(40000) &&
          // the API triggers this change in VL53L1_init_and_start_range() once a
          // measurement is started; assumes MM1 and MM2 are disabled
          write_register16(ALGO__PART_TO_PART_RANGE_OFFSET_MM, mm_config_outer_offset_mm * 4) &&
          // set continuous mode
          startContinuous(MEASUREMENT_TIME_MS)
          )) {
              return false;
          }

    // call timer() every MEASUREMENT_TIME_MS. We expect new data to be available every MEASUREMENT_TIME_MS
    dev->register_periodic_callback(MEASUREMENT_TIME_MS * 1000,
                                    FUNCTOR_BIND_MEMBER(&AP_RangeFinder_VL53L1X::timer, void));

    return true;
}

// set distance mode to Short, Medium, or Long
// based on VL53L1_SetDistanceMode()
bool AP_RangeFinder_VL53L1X::setDistanceMode(DistanceMode distance_mode)
{
    // save existing timing budget
    uint32_t budget_us = 0;
    if (!getMeasurementTimingBudget(budget_us)) {
        return false;
    }

    switch (distance_mode) {
      case DistanceMode::Short:
            // from VL53L1_preset_mode_standard_ranging_short_range()

            if (!(// timing config
                  write_register(RANGE_CONFIG__VCSEL_PERIOD_A, 0x07) &&
                  write_register(RANGE_CONFIG__VCSEL_PERIOD_B, 0x05) &&
                  write_register(RANGE_CONFIG__VALID_PHASE_HIGH, 0x38) &&

                  // dynamic config
                  write_register(SD_CONFIG__WOI_SD0, 0x07) &&
                  write_register(SD_CONFIG__WOI_SD1, 0x05) &&
                  write_register(SD_CONFIG__INITIAL_PHASE_SD0, 6) && // tuning parm default
                  write_register(SD_CONFIG__INITIAL_PHASE_SD1, 6))) { // tuning parm default
                return false;
            }

            break;

        case DistanceMode::Medium:
            // from VL53L1_preset_mode_standard_ranging()

            if (!(// timing config
                  write_register(RANGE_CONFIG__VCSEL_PERIOD_A, 0x0B) &&
                  write_register(RANGE_CONFIG__VCSEL_PERIOD_B, 0x09) &&
                  write_register(RANGE_CONFIG__VALID_PHASE_HIGH, 0x78) &&

                  // dynamic config
                  write_register(SD_CONFIG__WOI_SD0, 0x0B) &&
                  write_register(SD_CONFIG__WOI_SD1, 0x09) &&
                  write_register(SD_CONFIG__INITIAL_PHASE_SD0, 10) && // tuning parm default
                  write_register(SD_CONFIG__INITIAL_PHASE_SD1, 10))) { // tuning parm default
                return false;
            }

            break;

        case DistanceMode::Long:
            // from VL53L1_preset_mode_standard_ranging_long_range()

            if (!(// timing config
                  write_register(RANGE_CONFIG__VCSEL_PERIOD_A, 0x0F) &&
                  write_register(RANGE_CONFIG__VCSEL_PERIOD_B, 0x0D) &&
                  write_register(RANGE_CONFIG__VALID_PHASE_HIGH, 0xB8) &&

                  // dynamic config
                  write_register(SD_CONFIG__WOI_SD0, 0x0F) &&
                  write_register(SD_CONFIG__WOI_SD1, 0x0D) &&
                  write_register(SD_CONFIG__INITIAL_PHASE_SD0, 14) && // tuning parm default
                  write_register(SD_CONFIG__INITIAL_PHASE_SD1, 14))) { // tuning parm default
                return false;
            }

            break;

        default:
            // unrecognized mode - do nothing
            return false;
    }

    // reapply timing budget
    return setMeasurementTimingBudget(budget_us);
}

// Set the measurement timing budget in microseconds, which is the time allowed
// for one measurement. A longer timing budget allows for more accurate measurements.
// based on VL53L1_SetMeasurementTimingBudgetMicroSeconds()
bool AP_RangeFinder_VL53L1X::setMeasurementTimingBudget(uint32_t budget_us)
{
    // assumes PresetMode is LOWPOWER_AUTONOMOUS
    if (budget_us <= TimingGuard) {
        return false;
    }

    uint32_t range_config_timeout_us = budget_us - TimingGuard;
    if (range_config_timeout_us > 1100000) {
        return false; // FDA_MAX_TIMING_BUDGET_US * 2
    }

    range_config_timeout_us /= 2;

    // VL53L1_calc_timeout_register_values() begin

    uint8_t range_config_vcsel_period = 0;
    if (!read_register(RANGE_CONFIG__VCSEL_PERIOD_A, range_config_vcsel_period)) {
        return false;
    }

    // "Update Macro Period for Range A VCSEL Period"
    uint32_t macro_period_us = calcMacroPeriod(range_config_vcsel_period);

    // "Update Phase timeout - uses Timing A"
    // Timeout of 1000 is tuning parm default (TIMED_PHASECAL_CONFIG_TIMEOUT_US_DEFAULT)
    // via VL53L1_get_preset_mode_timing_cfg().
    uint32_t phasecal_timeout_mclks = timeoutMicrosecondsToMclks(1000, macro_period_us);
    if (phasecal_timeout_mclks > 0xFF) {
        phasecal_timeout_mclks = 0xFF;
    }

    if (!( write_register(PHASECAL_CONFIG__TIMEOUT_MACROP, phasecal_timeout_mclks) &&

          // "Update MM Timing A timeout"
          // Timeout of 1 is tuning parm default (LOWPOWERAUTO_MM_CONFIG_TIMEOUT_US_DEFAULT)
          // via VL53L1_get_preset_mode_timing_cfg(). With the API, the register
          // actually ends up with a slightly different value because it gets assigned,
          // retrieved, recalculated with a different macro period, and reassigned,
          // but it probably doesn't matter because it seems like the MM ("mode
          // mitigation"?) sequence steps are disabled in low power auto mode anyway.
          write_register16(MM_CONFIG__TIMEOUT_MACROP_A, encodeTimeout(
              timeoutMicrosecondsToMclks(1, macro_period_us))) &&

          // "Update Range Timing A timeout"
          write_register16(RANGE_CONFIG__TIMEOUT_MACROP_A, encodeTimeout(
              timeoutMicrosecondsToMclks(range_config_timeout_us, macro_period_us))) &&

          // "Update Macro Period for Range B VCSEL Period"
          read_register(RANGE_CONFIG__VCSEL_PERIOD_B, range_config_vcsel_period)
         )) {
        return false;
    }

    // "Update Macro Period for Range B VCSEL Period"
    macro_period_us = calcMacroPeriod(range_config_vcsel_period);

    // "Update MM Timing B timeout"
    // (See earlier comment about MM Timing A timeout.)
    return write_register16(MM_CONFIG__TIMEOUT_MACROP_B, encodeTimeout(
               timeoutMicrosecondsToMclks(1, macro_period_us))) &&

           // "Update Range Timing B timeout"
           write_register16(RANGE_CONFIG__TIMEOUT_MACROP_B, encodeTimeout(
               timeoutMicrosecondsToMclks(range_config_timeout_us, macro_period_us)));
}

// Get the measurement timing budget in microseconds
// based on VL53L1_SetMeasurementTimingBudgetMicroSeconds()
bool AP_RangeFinder_VL53L1X::getMeasurementTimingBudget(uint32_t &budget)
{
    // assumes PresetMode is LOWPOWER_AUTONOMOUS and these sequence steps are
    // enabled: VHV, PHASECAL, DSS1, RANGE

    // "Update Macro Period for Range A VCSEL Period"
    uint8_t range_config_vcsel_period_a = 0;
    if (!read_register(RANGE_CONFIG__VCSEL_PERIOD_A, range_config_vcsel_period_a)) {
        return false;
    }

    uint32_t macro_period_us = calcMacroPeriod(range_config_vcsel_period_a);

    uint16_t timeout_macrop_a = 0;
    if (!read_register16(RANGE_CONFIG__TIMEOUT_MACROP_A, timeout_macrop_a)) {
        return false;
    }

    // "Get Range Timing A timeout"
    uint32_t range_config_timeout_us = timeoutMclksToMicroseconds(decodeTimeout(timeout_macrop_a), macro_period_us);

    budget = 2 * range_config_timeout_us + TimingGuard;
    return true;
}

// Start continuous ranging measurements, with the given inter-measurement
// period in milliseconds determining how often the sensor takes a measurement.
bool AP_RangeFinder_VL53L1X::startContinuous(uint32_t period_ms)
{
    // fix for actual measurement period shorter than set
    uint32_t adjusted_period_ms = period_ms + (period_ms * 64 / 1000);

    // from VL53L1_set_inter_measurement_period_ms()
    return write_register32(SYSTEM__INTERMEASUREMENT_PERIOD, adjusted_period_ms * osc_calibrate_val) &&
           write_register(SYSTEM__INTERRUPT_CLEAR, 0x01) && // sys_interrupt_clear_range
           write_register(SYSTEM__MODE_START, 0x40); // mode_range__timed
}

// Decode sequence step timeout in MCLKs from register value
// based on VL53L1_decode_timeout()
uint32_t AP_RangeFinder_VL53L1X::decodeTimeout(uint16_t reg_val)
{
    return ((uint32_t)(reg_val & 0xFF) << (reg_val >> 8)) + 1;
}

// Encode sequence step timeout register value from timeout in MCLKs
// based on VL53L1_encode_timeout()
uint16_t AP_RangeFinder_VL53L1X::encodeTimeout(uint32_t timeout_mclks)
{
    // encoded format: "(LSByte * 2^MSByte) + 1"
    uint32_t ls_byte = 0;
    uint16_t ms_byte = 0;

    if (timeout_mclks > 0) {
        ls_byte = timeout_mclks - 1;
        while ((ls_byte & 0xFFFFFF00) > 0) {
            ls_byte >>= 1;
            ms_byte++;
        }
        return (ms_byte << 8) | (ls_byte & 0xFF);
    }
    else {
        return 0;
    }
}

// Convert sequence step timeout from macro periods to microseconds with given
// macro period in microseconds (12.12 format)
// based on VL53L1_calc_timeout_us()
uint32_t AP_RangeFinder_VL53L1X::timeoutMclksToMicroseconds(uint32_t timeout_mclks, uint32_t macro_period_us)
{
    return ((uint64_t)timeout_mclks * macro_period_us + 0x800) >> 12;
}

// Convert sequence step timeout from microseconds to macro periods with given
// macro period in microseconds (12.12 format)
// based on VL53L1_calc_timeout_mclks()
uint32_t AP_RangeFinder_VL53L1X::timeoutMicrosecondsToMclks(uint32_t timeout_us, uint32_t macro_period_us)
{
    return (((uint32_t)timeout_us << 12) + (macro_period_us >> 1)) / macro_period_us;
}

// Calculate macro period in microseconds (12.12 format) with given VCSEL period
// assumes fast_osc_frequency has been read and stored
// based on VL53L1_calc_macro_period_us()
uint32_t AP_RangeFinder_VL53L1X::calcMacroPeriod(uint8_t vcsel_period) const
{
    // from VL53L1_calc_pll_period_us()
    // fast osc frequency in 4.12 format; PLL period in 0.24 format
    uint32_t pll_period_us = ((uint32_t)0x01 << 30) / fast_osc_frequency;

    // from VL53L1_decode_vcsel_period()
    uint8_t vcsel_period_pclks = (vcsel_period + 1) << 1;

    // VL53L1_MACRO_PERIOD_VCSEL_PERIODS = 2304
    uint32_t macro_period_us = (uint32_t)2304 * pll_period_us;
    macro_period_us >>= 6;
    macro_period_us *= vcsel_period_pclks;
    macro_period_us >>= 6;

    return macro_period_us;
}

// "Setup ranges after the first one in low power auto mode by turning off
// FW calibration steps and programming static values"
// based on VL53L1_low_power_auto_setup_manual_calibration()
bool AP_RangeFinder_VL53L1X::setupManualCalibration(void)
{
    uint8_t saved_vhv_init = 0;
    uint8_t saved_vhv_timeout = 0;
    uint8_t phasecal_result_vcsel_start = 0;

    return // "save original vhv configs"
           read_register(VHV_CONFIG__INIT, saved_vhv_init) &&
           read_register(VHV_CONFIG__TIMEOUT_MACROP_LOOP_BOUND, saved_vhv_timeout) &&

           // "disable VHV init"
           write_register(VHV_CONFIG__INIT, saved_vhv_init & 0x7F) &&

          // "set loop bound to tuning param"
          write_register(VHV_CONFIG__TIMEOUT_MACROP_LOOP_BOUND,
                         (saved_vhv_timeout & 0x03) + (3 << 2)) && // tuning parm default (LOWPOWERAUTO_VHV_LOOP_BOUND_DEFAULT)

          // "override phasecal"
          write_register(PHASECAL_CONFIG__OVERRIDE, 0x01) &&
          read_register(PHASECAL_RESULT__VCSEL_START, phasecal_result_vcsel_start) &&
          write_register(CAL_CONFIG__VCSEL_START, phasecal_result_vcsel_start);
}

// check if sensor has new reading available
// assumes interrupt is active low (GPIO_HV_MUX__CTRL bit 4 is 1)
bool AP_RangeFinder_VL53L1X::dataReady(void)
{
    uint8_t gpio_tio_hv_status = 0;

    return read_register(GPIO__TIO_HV_STATUS, gpio_tio_hv_status) &&
           ((gpio_tio_hv_status & 0x01) == 0);
}

// read - return last value measured by sensor
bool AP_RangeFinder_VL53L1X::get_reading(uint16_t &reading_mm)
{
    uint8_t tries = 10;
    while (!dataReady()) {
        tries--;
        hal.scheduler->delay(1);
        if (tries == 0) {
            return false;
        }
    }

    uint8_t range_status = 0;

    if (!(read_register(RESULT__RANGE_STATUS, range_status) &&
          read_register16(RESULT__FINAL_CROSSTALK_CORRECTED_RANGE_MM_SD0, reading_mm))) {
        return false;
    }

    // "apply correction gain"
    // gain factor of 2011 is tuning parm default (VL53L1_TUNINGPARM_LITE_RANGING_GAIN_FACTOR_DEFAULT)
    // Basically, this appears to scale the result by 2011/2048, or about 98%
    // (with the 1024 added for proper rounding).
    reading_mm = ((uint32_t)reading_mm * 2011 + 0x0400) / 0x0800;

    if (!write_register(SYSTEM__INTERRUPT_CLEAR, 0x01)) { // sys_interrupt_clear_range
        return false;
    }

    switch ((DeviceError)range_status) {
      case RANGECOMPLETE:
        break;

      default:
#ifdef VL53L1X_DEBUG
        hal.console->printf("VL53L1X: %d ms status %d\n", AP_HAL::millis(), (int)range_status);
#endif // VL53L1X_DEBUG
        return false;
    }

    if (!calibrated) {
        calibrated = setupManualCalibration();
    }

    return calibrated;
}

bool AP_RangeFinder_VL53L1X::read_register(uint16_t reg, uint8_t &value)
{
    uint8_t b[2] = { uint8_t(reg >> 8), uint8_t(reg & 0xFF) };
    return dev->transfer(b, 2, &value, 1);
}

bool AP_RangeFinder_VL53L1X::read_register16(uint16_t reg, uint16_t & value)
{
    uint16_t v = 0;
    uint8_t b[2] = { uint8_t(reg >> 8), uint8_t(reg & 0xFF) };
    if (!dev->transfer(b, 2, (uint8_t *)&v, 2)) {
        return false;
    }
    value = be16toh(v);
    return true;
}

bool AP_RangeFinder_VL53L1X::write_register(uint16_t reg, uint8_t value)
{
    uint8_t b[3] = { uint8_t(reg >> 8), uint8_t(reg & 0xFF), value };
    return dev->transfer(b, 3, nullptr, 0);
}

bool AP_RangeFinder_VL53L1X::write_register16(uint16_t reg, uint16_t value)
{
    uint8_t b[4] = { uint8_t(reg >> 8), uint8_t(reg & 0xFF), uint8_t(value >> 8), uint8_t(value & 0xFF) };
    return dev->transfer(b, 4, nullptr, 0);
}

bool AP_RangeFinder_VL53L1X::write_register32(uint16_t reg, uint32_t value)
{
    uint8_t b[6] = { uint8_t(reg >> 8),
                     uint8_t(reg & 0xFF),
                     uint8_t((value >> 24) & 0xFF),
                     uint8_t((value >> 16) & 0xFF),
                     uint8_t((value >>  8) & 0xFF),
                     uint8_t((value)       & 0xFF) };
    return dev->transfer(b, 6, nullptr, 0);
}

/*
  timer called at 20Hz
*/
void AP_RangeFinder_VL53L1X::timer(void)
{
    uint16_t range_mm;
    if ((get_reading(range_mm)) && (range_mm <= 4000)) {
        WITH_SEMAPHORE(_sem);
        sum_mm += range_mm;
        counter++;
    }
}

/*
   update the state of the sensor
*/
void AP_RangeFinder_VL53L1X::update(void)
{
    WITH_SEMAPHORE(_sem);
    if (counter > 0) {
        state.distance_m = (sum_mm * 0.001f) / counter;
        state.last_reading_ms = AP_HAL::millis();
        update_status();
        sum_mm = 0;
        counter = 0;
    } else if (AP_HAL::millis() - state.last_reading_ms > 200) {
        // if no updates for 0.2s set no-data
        set_status(RangeFinder::Status::NoData);
    }
}

#endif  // AP_RANGEFINDER_VL53L1X_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   #pragma once

#include "AP_RangeFinder_config.h"

#if AP_RANGEFINDER_VL53L1X_ENABLED

#include "AP_RangeFinder.h"
#include "AP_RangeFinder_Backend.h"

#include <AP_HAL/I2CDevice.h>

class AP_RangeFinder_VL53L1X : public AP_RangeFinder_Backend
{

public:
    enum class DistanceMode { Short, Medium, Long, Unknown };

    // static detection function
    static AP_RangeFinder_Backend *detect(RangeFinder::RangeFinder_State &_state, AP_RangeFinder_Params &_params, AP_HAL::OwnPtr<AP_HAL::I2CDevice> _dev, DistanceMode mode);

    // update state
    void update(void) override;

protected:

    virtual MAV_DISTANCE_SENSOR _get_mav_distance_sensor_type() const override {
        return MAV_DISTANCE_SENSOR_LASER;
    }

private:
    enum DeviceError : uint8_t
    {
        NOUPDATE                    = 0,
        VCSELCONTINUITYTESTFAILURE  = 1,
        VCSELWATCHDOGTESTFAILURE    = 2,
        NOVHVVALUEFOUND             = 3,
        MSRCNOTARGET                = 4,
        RANGEPHASECHECK             = 5,
        SIGMATHRESHOLDCHECK         = 6,
        PHASECONSISTENCY            = 7,
        MINCLIP                     = 8,
        RANGECOMPLETE               = 9,
        ALGOUNDERFLOW               = 10,
        ALGOOVERFLOW                = 11,
        RANGEIGNORETHRESHOLD        = 12,
        USERROICLIP                 = 13,
        REFSPADCHARNOTENOUGHDPADS   = 14,
        REFSPADCHARMORETHANTARGET   = 15,
        REFSPADCHARLESSTHANTARGET   = 16,
        MULTCLIPFAIL                = 17,
        GPHSTREAMCOUNT0READY        = 18,
        RANGECOMPLETE_NO_WRAP_CHECK = 19,
        EVENTCONSISTENCY            = 20,
        MINSIGNALEVENTCHECK         = 21,
        RANGECOMPLETE_MERGED_PULSE  = 22,
    };

    // register addresses from API vl53l1x_register_map.h
    enum regAddr : uint16_t
    {
        SOFT_RESET                                                                 = 0x0000,
        I2C_SLAVE__DEVICE_ADDRESS                                                  = 0x0001,
        ANA_CONFIG__VHV_REF_SEL_VDDPIX                                             = 0x0002,
        ANA_CONFIG__VHV_REF_SEL_VQUENCH                                            = 0x0003,
        ANA_CONFIG__REG_AVDD1V2_SEL                                                = 0x0004,
        ANA_CONFIG__FAST_OSC__TRIM                                                 = 0x0005,
        OSC_MEASURED__FAST_OSC__FREQUENCY                                          = 0x0006,
        OSC_MEASURED__FAST_OSC__FREQUENCY_HI                                       = 0x0006,
        OSC_MEASURED__FAST_OSC__FREQUENCY_LO                                       = 0x0007,
        VHV_CONFIG__TIMEOUT_MACROP_LOOP_BOUND                                      = 0x0008,
        VHV_CONFIG__COUNT_THRESH                                                   = 0x0009,
        VHV_CONFIG__OFFSET                                                         = 0x000A,
        VHV_CONFIG__INIT                                                           = 0x000B,
        GLOBAL_CONFIG__SPAD_ENABLES_REF_0                                          = 0x000D,
        GLOBAL_CONFIG__SPAD_ENABLES_REF_1                                          = 0x000E,
        GLOBAL_CONFIG__SPAD_ENABLES_REF_2                                          = 0x000F,
        GLOBAL_CONFIG__SPAD_ENABLES_REF_3                                          = 0x0010,
        GLOBAL_CONFIG__SPAD_ENABLES_REF_4                                          = 0x0011,
        GLOBAL_CONFIG__SPAD_ENABLES_REF_5                                          = 0x0012,
        GLOBAL_CONFIG__REF_EN_START_SELECT                                         = 0x0013,
        REF_SPAD_MAN__NUM_REQUESTED_REF_SPADS                                      = 0x0014,
        REF_SPAD_MAN__REF_LOCATION                                                 = 0x0015,
        ALGO__CROSSTALK_COMPENSATION_PLANE_OFFSET_KCPS                             = 0x0016,
        ALGO__CROSSTALK_COMPENSATION_PLANE_OFFSET_KCPS_HI                          = 0x0016,
        ALGO__CROSSTALK_COMPENSATION_PLANE_OFFSET_KCPS_LO                          = 0x0017,
        ALGO__CROSSTALK_COMPENSATION_X_PLANE_GRADIENT_KCPS                         = 0x0018,
        ALGO__CROSSTALK_COMPENSATION_X_PLANE_GRADIENT_KCPS_HI                      = 0x0018,
        ALGO__CROSSTALK_COMPENSATION_X_PLANE_GRADIENT_KCPS_LO                      = 0x0019,
        ALGO__CROSSTALK_COMPENSATION_Y_PLANE_GRADIENT_KCPS                         = 0x001A,
        ALGO__CROSSTALK_COMPENSATION_Y_PLANE_GRADIENT_KCPS_HI                      = 0x001A,
        ALGO__CROSSTALK_COMPENSATION_Y_PLANE_GRADIENT_KCPS_LO                      = 0x001B,
        REF_SPAD_CHAR__TOTAL_RATE_TARGET_MCPS                                      = 0x001C,
        REF_SPAD_CHAR__TOTAL_RATE_TARGET_MCPS_HI                                   = 0x001C,
        REF_SPAD_CHAR__TOTAL_RATE_TARGET_MCPS_LO                                   = 0x001D,
        ALGO__PART_TO_PART_RANGE_OFFSET_MM                                         = 0x001E,
        ALGO__PART_TO_PART_RANGE_OFFSET_MM_HI                                      = 0x001E,
        ALGO__PART_TO_PART_RANGE_OFFSET_MM_LO                                      = 0x001F,
        MM_CONFIG__INNER_OFFSET_MM                                                 = 0x0020,
        MM_CONFIG__INNER_OFFSET_MM_HI                                              = 0x0020,
        MM_CONFIG__INNER_OFFSET_MM_LO                                              = 0x0021,
        MM_CONFIG__OUTER_OFFSET_MM                                                 = 0x0022,
        MM_CONFIG__OUTER_OFFSET_MM_HI                                              = 0x0022,
        MM_CONFIG__OUTER_OFFSET_MM_LO                                              = 0x0023,
        DSS_CONFIG__TARGET_TOTAL_RATE_MCPS                                         = 0x0024,
        DSS_CONFIG__TARGET_TOTAL_RATE_MCPS_HI                                      = 0x0024,
        DSS_CONFIG__TARGET_TOTAL_RATE_MCPS_LO                                      = 0x0025,
        DEBUG__CTRL                                                                = 0x0026,
        TEST_MODE__CTRL                                                            = 0x0027,
        CLK_GATING__CTRL                                                           = 0x0028,
        NVM_BIST__CTRL                                                             = 0x0029,
        NVM_BIST__NUM_NVM_WORDS                                                    = 0x002A,
        NVM_BIST__START_ADDRESS                                                    = 0x002B,
        HOST_IF__STATUS                                                            = 0x002C,
        PAD_I2C_HV__CONFIG                                                         = 0x002D,
        PAD_I2C_HV__EXTSUP_CONFIG                                                  = 0x002E,
        GPIO_HV_PAD__CTRL                                                          = 0x002F,
        GPIO_HV_MUX__CTRL                                                          = 0x0030,
        GPIO__TIO_HV_STATUS                                                        = 0x0031,
        GPIO__FIO_HV_STATUS                                                        = 0x0032,
        ANA_CONFIG__SPAD_SEL_PSWIDTH                                               = 0x0033,
        ANA_CONFIG__VCSEL_PULSE_WIDTH_OFFSET                                       = 0x0034,
        ANA_CONFIG__FAST_OSC__CONFIG_CTRL                                          = 0x0035,
        SIGMA_ESTIMATOR__EFFECTIVE_PULSE_WIDTH_NS                                  = 0x0036,
        SIGMA_ESTIMATOR__EFFECTIVE_AMBIENT_WIDTH_NS                                = 0x0037,
        SIGMA_ESTIMATOR__SIGMA_REF_MM                                              = 0x0038,
        ALGO__CROSSTALK_COMPENSATION_VALID_HEIGHT_MM                               = 0x0039,
        SPARE_HOST_CONFIG__STATIC_CONFIG_SPARE_0                                   = 0x003A,
        SPARE_HOST_CONFIG__STATIC_CONFIG_SPARE_1                                   = 0x003B,
        ALGO__RANGE_IGNORE_THRESHOLD_MCPS                                          = 0x003C,
        ALGO__RANGE_IGNORE_THRESHOLD_MCPS_HI                                       = 0x003C,
        ALGO__RANGE_IGNORE_THRESHOLD_MCPS_LO                                       = 0x003D,
        ALGO__RANGE_IGNORE_VALID_HEIGHT_MM                                         = 0x003E,
        ALGO__RANGE_MIN_CLIP                                                       = 0x003F,
        ALGO__CONSISTENCY_CHECK__TOLERANCE                                         = 0x0040,
        SPARE_HOST_CONFIG__STATIC_CONFIG_SPARE_2                                   = 0x0041,
        SD_CONFIG__RESET_STAGES_MSB                                                = 0x0042,
        SD_CONFIG__RESET_STAGES_LSB                                                = 0x0043,
        GPH_CONFIG__STREAM_COUNT_UPDATE_VALUE                                      = 0x0044,
        GLOBAL_CONFIG__STREAM_DIVIDER                                              = 0x0045,
        SYSTEM__INTERRUPT_CONFIG_GPIO                                              = 0x0046,
        CAL_CONFIG__VCSEL_START                                                    = 0x0047,
        CAL_CONFIG__REPEAT_RATE                                                    = 0x0048,
        CAL_CONFIG__REPEAT_RATE_HI                                                 = 0x0048,
        CAL_CONFIG__REPEAT_RATE_LO                                                 = 0x0049,
        GLOBAL_CONFIG__VCSEL_WIDTH                                                 = 0x004A,
        PHASECAL_CONFIG__TIMEOUT_MACROP                                            = 0x004B,
        PHASECAL_CONFIG__TARGET                                                    = 0x004C,
        PHASECAL_CONFIG__OVERRIDE                                                  = 0x004D,
        DSS_CONFIG__ROI_MODE_CONTROL                                               = 0x004F,
        SYSTEM__THRESH_RATE_HIGH                                                   = 0x0050,
        SYSTEM__THRESH_RATE_HIGH_HI                                                = 0x0050,
        SYSTEM__THRESH_RATE_HIGH_LO                                                = 0x0051,
        SYSTEM__THRESH_RATE_LOW                                                    = 0x0052,
        SYSTEM__THRESH_RATE_LOW_HI                                                 = 0x0052,
        SYSTEM__THRESH_RATE_LOW_LO                                                 = 0x0053,
        DSS_CONFIG__MANUAL_EFFECTIVE_SPADS_SELECT                                  = 0x0054,
        DSS_CONFIG__MANUAL_EFFECTIVE_SPADS_SELECT_HI                               = 0x0054,
        DSS_CONFIG__MANUAL_EFFECTIVE_SPADS_SELECT_LO                               = 0x0055,
        DSS_CONFIG__MANUAL_BLOCK_SELECT                                            = 0x0056,
        DSS_CONFIG__APERTURE_ATTENUATION                                           = 0x0057,
        DSS_CONFIG__MAX_SPADS_LIMIT                                                = 0x0058,
        DSS_CONFIG__MIN_SPADS_LIMIT                                                = 0x0059,
        MM_CONFIG__TIMEOUT_MACROP_A                                                = 0x005A, // added by Pololu for 16-bit accesses
        MM_CONFIG__TIMEOUT_MACROP_A_HI                                             = 0x005A,
        MM_CONFIG__TIMEOUT_MACROP_A_LO                                             = 0x005B,
        MM_CONFIG__TIMEOUT_MACROP_B                                                = 0x005C, // added by Pololu for 16-bit accesses
        MM_CONFIG__TIMEOUT_MACROP_B_HI                                             = 0x005C,
        MM_CONFIG__TIMEOUT_MACROP_B_LO                                             = 0x005D,
        RANGE_CONFIG__TIMEOUT_MACROP_A                                             = 0x005E, // added by Pololu for 16-bit accesses
        RANGE_CONFIG__TIMEOUT_MACROP_A_HI                                          = 0x005E,
        RANGE_CONFIG__TIMEOUT_MACROP_A_LO                                          = 0x005F,
        RANGE_CONFIG__VCSEL_PERIOD_A                                               = 0x0060,
        RANGE_CONFIG__TIMEOUT_MACROP_B                                             = 0x0061, // added by Pololu for 16-bit accesses
        RANGE_CONFIG__TIMEOUT_MACROP_B_HI                                          = 0x0061,
        RANGE_CONFIG__TIMEOUT_MACROP_B_LO                                          = 0x0062,
        RANGE_CONFIG__VCSEL_PERIOD_B                                               = 0x0063,
        RANGE_CONFIG__SIGMA_THRESH                                                 = 0x0064,
        RANGE_CONFIG__SIGMA_THRESH_HI                                              = 0x0064,
        RANGE_CONFIG__SIGMA_THRESH_LO                                              = 0x0065,
        RANGE_CONFIG__MIN_COUNT_RATE_RTN_LIMIT_MCPS                                = 0x0066,
        RANGE_CONFIG__MIN_COUNT_RATE_RTN_LIMIT_MCPS_HI                             = 0x0066,
        RANGE_CONFIG__MIN_COUNT_RATE_RTN_LIMIT_MCPS_LO                             = 0x0067,
        RANGE_CONFIG__VALID_PHASE_LOW                                              = 0x0068,
        RANGE_CONFIG__VALID_PHASE_HIGH                                             = 0x0069,
        SYSTEM__INTERMEASUREMENT_PERIOD                                            = 0x006C,
        SYSTEM__INTERMEASUREMENT_PERIOD_3                                          = 0x006C,
        SYSTEM__INTERMEASUREMENT_PERIOD_2                                          = 0x006D,
        SYSTEM__INTERMEASUREMENT_PERIOD_1                                          = 0x006E,
        SYSTEM__INTERMEASUREMENT_PERIOD_0                                          = 0x006F,
        SYSTEM__FRACTIONAL_ENABLE                                                  = 0x0070,
        SYSTEM__GROUPED_PARAMETER_HOLD_0                                           = 0x0071,
        SYSTEM__THRESH_HIGH                                                        = 0x0072,
        SYSTEM__THRESH_HIGH_HI                                                     = 0x0072,
        SYSTEM__THRESH_HIGH_LO                                                     = 0x0073,
        SYSTEM__THRESH_LOW                                                         = 0x0074,
        SYSTEM__THRESH_LOW_HI                                                      = 0x0074,
        SYSTEM__THRESH_LOW_LO                                                      = 0x0075,
        SYSTEM__ENABLE_XTALK_PER_QUADRANT                                          = 0x0076,
        SYSTEM__SEED_CONFIG                                                        = 0x0077,
        SD_CONFIG__WOI_SD0                                                         = 0x0078,
        SD_CONFIG__WOI_SD1                                                         = 0x0079,
        SD_CONFIG__INITIAL_PHASE_SD0                                               = 0x007A,
        SD_CONFIG__INITIAL_PHASE_SD1                                               = 0x007B,
        SYSTEM__GROUPED_PARAMETER_HOLD_1                                           = 0x007C,
        SD_CONFIG__FIRST_ORDER_SELECT                                              = 0x007D,
        SD_CONFIG__QUANTIFIER                                                      = 0x007E,
        ROI_CONFIG__USER_ROI_CENTRE_SPAD                                           = 0x007F,
        ROI_CONFIG__USER_ROI_REQUESTED_GLOBAL_XY_SIZE                              = 0x0080,
        SYSTEM__SEQUENCE_CONFIG                                                    = 0x0081,
        SYSTEM__GROUPED_PARAMETER_HOLD                                             = 0x0082,
        POWER_MANAGEMENT__GO1_POWER_FORCE                                          = 0x0083,
        SYSTEM__STREAM_COUNT_CTRL                                                  = 0x0084,
        FIRMWARE__ENABLE                                                           = 0x0085,
        SYSTEM__INTERRUPT_CLEAR                                                    = 0x0086,
        SYSTEM__MODE_START                                                         = 0x0087,
        RESULT__INTERRUPT_STATUS                                                   = 0x0088,
        RESULT__RANGE_STATUS                                                       = 0x0089,
        RESULT__REPORT_STATUS                                                      = 0x008A,
        RESULT__STREAM_COUNT                                                       = 0x008B,
        RESULT__DSS_ACTUAL_EFFECTIVE_SPADS_SD0                                     = 0x008C,
        RESULT__DSS_ACTUAL_EFFECTIVE_SPADS_SD0_HI                                  = 0x008C,
        RESULT__DSS_ACTUAL_EFFECTIVE_SPADS_SD0_LO                                  = 0x008D,
        RESULT__PEAK_SIGNAL_COUNT_RATE_MCPS_SD0                                    = 0x008E,
        RESULT__PEAK_SIGNAL_COUNT_RATE_MCPS_SD0_HI                                 = 0x008E,
        RESULT__PEAK_SIGNAL_COUNT_RATE_MCPS_SD0_LO                                 = 0x008F,
        RESULT__AMBIENT_COUNT_RATE_MCPS_SD0                                        = 0x0090,
        RESULT__AMBIENT_COUNT_RATE_MCPS_SD0_HI                                     = 0x0090,
        RESULT__AMBIENT_COUNT_RATE_MCPS_SD0_LO                                     = 0x0091,
        RESULT__SIGMA_SD0                                                          = 0x0092,
        RESULT__SIGMA_SD0_HI                                                       = 0x0092,
        RESULT__SIGMA_SD0_LO                                                       = 0x0093,
        RESULT__PHASE_SD0                                                          = 0x0094,
        RESULT__PHASE_SD0_HI                                                       = 0x0094,
        RESULT__PHASE_SD0_LO                                                       = 0x0095,
        RESULT__FINAL_CROSSTALK_CORRECTED_RANGE_MM_SD0                             = 0x0096,
        RESULT__FINAL_CROSSTALK_CORRECTED_RANGE_MM_SD0_HI                          = 0x0096,
        RESULT__FINAL_CROSSTALK_CORRECTED_RANGE_MM_SD0_LO                          = 0x0097,
        RESULT__PEAK_SIGNAL_COUNT_RATE_CROSSTALK_CORRECTED_MCPS_SD0                = 0x0098,
        RESULT__PEAK_SIGNAL_COUNT_RATE_CROSSTALK_CORRECTED_MCPS_SD0_HI             = 0x0098,
        RESULT__PEAK_SIGNAL_COUNT_RATE_CROSSTALK_CORRECTED_MCPS_SD0_LO             = 0x0099,
        RESULT__MM_INNER_ACTUAL_EFFECTIVE_SPADS_SD0                                = 0x009A,
        RESULT__MM_INNER_ACTUAL_EFFECTIVE_SPADS_SD0_HI                             = 0x009A,
        RESULT__MM_INNER_ACTUAL_EFFECTIVE_SPADS_SD0_LO                             = 0x009B,
        RESULT__MM_OUTER_ACTUAL_EFFECTIVE_SPADS_SD0                                = 0x009C,
        RESULT__MM_OUTER_ACTUAL_EFFECTIVE_SPADS_SD0_HI                             = 0x009C,
        RESULT__MM_OUTER_ACTUAL_EFFECTIVE_SPADS_SD0_LO                             = 0x009D,
        RESULT__AVG_SIGNAL_COUNT_RATE_MCPS_SD0                                     = 0x009E,
        RESULT__AVG_SIGNAL_COUNT_RATE_MCPS_SD0_HI                                  = 0x009E,
        RESULT__AVG_SIGNAL_COUNT_RATE_MCPS_SD0_LO                                  = 0x009F,
        RESULT__DSS_ACTUAL_EFFECTIVE_SPADS_SD1                                     = 0x00A0,
        RESULT__DSS_ACTUAL_EFFECTIVE_SPADS_SD1_HI                                  = 0x00A0,
        RESULT__DSS_ACTUAL_EFFECTIVE_SPADS_SD1_LO                                  = 0x00A1,
        RESULT__PEAK_SIGNAL_COUNT_RATE_MCPS_SD1                                    = 0x00A2,
        RESULT__PEAK_SIGNAL_COUNT_RATE_MCPS_SD1_HI                                 = 0x00A2,
        RESULT__PEAK_SIGNAL_COUNT_RATE_MCPS_SD1_LO                                 = 0x00A3,
        RESULT__AMBIENT_COUNT_RATE_MCPS_SD1                                        = 0x00A4,
        RESULT__AMBIENT_COUNT_RATE_MCPS_SD1_HI                                     = 0x00A4,
        RESULT__AMBIENT_COUNT_RATE_MCPS_SD1_LO                                     = 0x00A5,
        RESULT__SIGMA_SD1                                                          = 0x00A6,
        RESULT__SIGMA_SD1_HI                                                       = 0x00A6,
        RESULT__SIGMA_SD1_LO                                                       = 0x00A7,
        RESULT__PHASE_SD1                                                          = 0x00A8,
        RESULT__PHASE_SD1_HI                                                       = 0x00A8,
        RESULT__PHASE_SD1_LO                                                       = 0x00A9,
        RESULT__FINAL_CROSSTALK_CORRECTED_RANGE_MM_SD1                             = 0x00AA,
        RESULT__FINAL_CROSSTALK_CORRECTED_RANGE_MM_SD1_HI                          = 0x00AA,
        RESULT__FINAL_CROSSTALK_CORRECTED_RANGE_MM_SD1_LO                          = 0x00AB,
        RESULT__SPARE_0_SD1                                                        = 0x00AC,
        RESULT__SPARE_0_SD1_HI                                                     = 0x00AC,
        RESULT__SPARE_0_SD1_LO                                                     = 0x00AD,
        RESULT__SPARE_1_SD1                                                        = 0x00AE,
        RESULT__SPARE_1_SD1_HI                                                     = 0x00AE,
        RESULT__SPARE_1_SD1_LO                                                     = 0x00AF,
        RESULT__SPARE_2_SD1                                                        = 0x00B0,
        RESULT__SPARE_2_SD1_HI                                                     = 0x00B0,
        RESULT__SPARE_2_SD1_LO                                                     = 0x00B1,
        RESULT__SPARE_3_SD1                                                        = 0x00B2,
        RESULT__THRESH_INFO                                                        = 0x00B3,
        RESULT_CORE__AMBIENT_WINDOW_EVENTS_SD0                                     = 0x00B4,
        RESULT_CORE__AMBIENT_WINDOW_EVENTS_SD0_3                                   = 0x00B4,
        RESULT_CORE__AMBIENT_WINDOW_EVENTS_SD0_2                                   = 0x00B5,
        RESULT_CORE__AMBIENT_WINDOW_EVENTS_SD0_1                                   = 0x00B6,
        RESULT_CORE__AMBIENT_WINDOW_EVENTS_SD0_0                                   = 0x00B7,
        RESULT_CORE__RANGING_TOTAL_EVENTS_SD0                                      = 0x00B8,
        RESULT_CORE__RANGING_TOTAL_EVENTS_SD0_3                                    = 0x00B8,
        RESULT_CORE__RANGING_TOTAL_EVENTS_SD0_2                                    = 0x00B9,
        RESULT_CORE__RANGING_TOTAL_EVENTS_SD0_1                                    = 0x00BA,
        RESULT_CORE__RANGING_TOTAL_EVENTS_SD0_0                                    = 0x00BB,
        RESULT_CORE__SIGNAL_TOTAL_EVENTS_SD0                                       = 0x00BC,
        RESULT_CORE__SIGNAL_TOTAL_EVENTS_SD0_3                                     = 0x00BC,
        RESULT_CORE__SIGNAL_TOTAL_EVENTS_SD0_2                                     = 0x00BD,
        RESULT_CORE__SIGNAL_TOTAL_EVENTS_SD0_1                                     = 0x00BE,
        RESULT_CORE__SIGNAL_TOTAL_EVENTS_SD0_0                                     = 0x00BF,
        RESULT_CORE__TOTAL_PERIODS_ELAPSED_SD0                                     = 0x00C0,
        RESULT_CORE__TOTAL_PERIODS_ELAPSED_SD0_3                                   = 0x00C0,
        RESULT_CORE__TOTAL_PERIODS_ELAPSED_SD0_2                                   = 0x00C1,
        RESULT_CORE__TOTAL_PERIODS_ELAPSED_SD0_1                                   = 0x00C2,
        RESULT_CORE__TOTAL_PERIODS_ELAPSED_SD0_0                                   = 0x00C3,
        RESULT_CORE__AMBIENT_WINDOW_EVENTS_SD1                                     = 0x00C4,
        RESULT_CORE__AMBIENT_WINDOW_EVENTS_SD1_3                                   = 0x00C4,
        RESULT_CORE__AMBIENT_WINDOW_EVENTS_SD1_2                                   = 0x00C5,
        RESULT_CORE__AMBIENT_WINDOW_EVENTS_SD1_1                                   = 0x00C6,
        RESULT_CORE__AMBIENT_WINDOW_EVENTS_SD1_0                                   = 0x00C7,
        RESULT_CORE__RANGING_TOTAL_EVENTS_SD1                                      = 0x00C8,
        RESULT_CORE__RANGING_TOTAL_EVENTS_SD1_3                                    = 0x00C8,
        RESULT_CORE__RANGING_TOTAL_EVENTS_SD1_2                                    = 0x00C9,
        RESULT_CORE__RANGING_TOTAL_EVENTS_SD1_1                                    = 0x00CA,
        RESULT_CORE__RANGING_TOTAL_EVENTS_SD1_0                                    = 0x00CB,
        RESULT_CORE__SIGNAL_TOTAL_EVENTS_SD1                                       = 0x00CC,
        RESULT_CORE__SIGNAL_TOTAL_EVENTS_SD1_3                                     = 0x00CC,
        RESULT_CORE__SIGNAL_TOTAL_EVENTS_SD1_2                                     = 0x00CD,
        RESULT_CORE__SIGNAL_TOTAL_EVENTS_SD1_1                                     = 0x00CE,
        RESULT_CORE__SIGNAL_TOTAL_EVENTS_SD1_0                                     = 0x00CF,
        RESULT_CORE__TOTAL_PERIODS_ELAPSED_SD1                                     = 0x00D0,
        RESULT_CORE__TOTAL_PERIODS_ELAPSED_SD1_3                                   = 0x00D0,
        RESULT_CORE__TOTAL_PERIODS_ELAPSED_SD1_2                                   = 0x00D1,
        RESULT_CORE__TOTAL_PERIODS_ELAPSED_SD1_1                                   = 0x00D2,
        RESULT_CORE__TOTAL_PERIODS_ELAPSED_SD1_0                                   = 0x00D3,
        RESULT_CORE__SPARE_0                                                       = 0x00D4,
        PHASECAL_RESULT__REFERENCE_PHASE                                           = 0x00D6,
        PHASECAL_RESULT__REFERENCE_PHASE_HI                                        = 0x00D6,
        PHASECAL_RESULT__REFERENCE_PHASE_LO                                        = 0x00D7,
        PHASECAL_RESULT__VCSEL_START                                               = 0x00D8,
        REF_SPAD_CHAR_RESULT__NUM_ACTUAL_REF_SPADS                                 = 0x00D9,
        REF_SPAD_CHAR_RESULT__REF_LOCATION                                         = 0x00DA,
        VHV_RESULT__COLDBOOT_STATUS                                                = 0x00DB,
        VHV_RESULT__SEARCH_RESULT                                                  = 0x00DC,
        VHV_RESULT__LATEST_SETTING                                                 = 0x00DD,
        RESULT__OSC_CALIBRATE_VAL                                                  = 0x00DE,
        RESULT__OSC_CALIBRATE_VAL_HI                                               = 0x00DE,
        RESULT__OSC_CALIBRATE_VAL_LO                                               = 0x00DF,
        ANA_CONFIG__POWERDOWN_GO1                                                  = 0x00E0,
        ANA_CONFIG__REF_BG_CTRL                                                    = 0x00E1,
        ANA_CONFIG__REGDVDD1V2_CTRL                                                = 0x00E2,
        ANA_CONFIG__OSC_SLOW_CTRL                                                  = 0x00E3,
        TEST_MODE__STATUS                                                          = 0x00E4,
        FIRMWARE__SYSTEM_STATUS                                                    = 0x00E5,
        FIRMWARE__MODE_STATUS                                                      = 0x00E6,
        FIRMWARE__SECONDARY_MODE_STATUS                                            = 0x00E7,
        FIRMWARE__CAL_REPEAT_RATE_COUNTER                                          = 0x00E8,
        FIRMWARE__CAL_REPEAT_RATE_COUNTER_HI                                       = 0x00E8,
        FIRMWARE__CAL_REPEAT_RATE_COUNTER_LO                                       = 0x00E9,
        FIRMWARE__HISTOGRAM_BIN                                                    = 0x00EA,
        GPH__SYSTEM__THRESH_HIGH                                                   = 0x00EC,
        GPH__SYSTEM__THRESH_HIGH_HI                                                = 0x00EC,
        GPH__SYSTEM__THRESH_HIGH_LO                                                = 0x00ED,
        GPH__SYSTEM__THRESH_LOW                                                    = 0x00EE,
        GPH__SYSTEM__THRESH_LOW_HI                                                 = 0x00EE,
        GPH__SYSTEM__THRESH_LOW_LO                                                 = 0x00EF,
        GPH__SYSTEM__ENABLE_XTALK_PER_QUADRANT                                     = 0x00F0,
        GPH__SPARE_0                                                               = 0x00F1,
        GPH__SD_CONFIG__WOI_SD0                                                    = 0x00F2,
        GPH__SD_CONFIG__WOI_SD1                                                    = 0x00F3,
        GPH__SD_CONFIG__INITIAL_PHASE_SD0                                          = 0x00F4,
        GPH__SD_CONFIG__INITIAL_PHASE_SD1                                          = 0x00F5,
        GPH__SD_CONFIG__FIRST_ORDER_SELECT                                         = 0x00F6,
        GPH__SD_CONFIG__QUANTIFIER                                                 = 0x00F7,
        GPH__ROI_CONFIG__USER_ROI_CENTRE_SPAD                                      = 0x00F8,
        GPH__ROI_CONFIG__USER_ROI_REQUESTED_GLOBAL_XY_SIZE                         = 0x00F9,
        GPH__SYSTEM__SEQUENCE_CONFIG                                               = 0x00FA,
        GPH__GPH_ID                                                                = 0x00FB,
        SYSTEM__INTERRUPT_SET                                                      = 0x00FC,
        INTERRUPT_MANAGER__ENABLES                                                 = 0x00FD,
        INTERRUPT_MANAGER__CLEAR                                                   = 0x00FE,
        INTERRUPT_MANAGER__STATUS                                                  = 0x00FF,
        MCU_TO_HOST_BANK__WR_ACCESS_EN                                             = 0x0100,
        POWER_MANAGEMENT__GO1_RESET_STATUS                                         = 0x0101,
        PAD_STARTUP_MODE__VALUE_RO                                                 = 0x0102,
        PAD_STARTUP_MODE__VALUE_CTRL                                               = 0x0103,
        PLL_PERIOD_US                                                              = 0x0104,
        PLL_PERIOD_US_3                                                            = 0x0104,
        PLL_PERIOD_US_2                                                            = 0x0105,
        PLL_PERIOD_US_1                                                            = 0x0106,
        PLL_PERIOD_US_0                                                            = 0x0107,
        INTERRUPT_SCHEDULER__DATA_OUT                                              = 0x0108,
        INTERRUPT_SCHEDULER__DATA_OUT_3                                            = 0x0108,
        INTERRUPT_SCHEDULER__DATA_OUT_2                                            = 0x0109,
        INTERRUPT_SCHEDULER__DATA_OUT_1                                            = 0x010A,
        INTERRUPT_SCHEDULER__DATA_OUT_0                                            = 0x010B,
        NVM_BIST__COMPLETE                                                         = 0x010C,
        NVM_BIST__STATUS                                                           = 0x010D,
        IDENTIFICATION__MODEL_ID                                                   = 0x010F,
        IDENTIFICATION__MODULE_TYPE                                                = 0x0110,
        IDENTIFICATION__REVISION_ID                                                = 0x0111,
        IDENTIFICATION__MODULE_ID                                                  = 0x0112,
        IDENTIFICATION__MODULE_ID_HI                                               = 0x0112,
        IDENTIFICATION__MODULE_ID_LO                                               = 0x0113,
        ANA_CONFIG__FAST_OSC__TRIM_MAX                                             = 0x0114,
        ANA_CONFIG__FAST_OSC__FREQ_SET                                             = 0x0115,
        ANA_CONFIG__VCSEL_TRIM                                                     = 0x0116,
        ANA_CONFIG__VCSEL_SELION                                                   = 0x0117,
        ANA_CONFIG__VCSEL_SELION_MAX                                               = 0x0118,
        PROTECTED_LASER_SAFETY__LOCK_BIT                                           = 0x0119,
        LASER_SAFETY__KEY                                                          = 0x011A,
        LASER_SAFETY__KEY_RO                                                       = 0x011B,
        LASER_SAFETY__CLIP                                                         = 0x011C,
        LASER_SAFETY__MULT                                                         = 0x011D,
        GLOBAL_CONFIG__SPAD_ENABLES_RTN_0                                          = 0x011E,
        GLOBAL_CONFIG__SPAD_ENABLES_RTN_1                                          = 0x011F,
        GLOBAL_CONFIG__SPAD_ENABLES_RTN_2                                          = 0x0120,
        GLOBAL_CONFIG__SPAD_ENABLES_RTN_3                                          = 0x0121,
        GLOBAL_CONFIG__SPAD_ENABLES_RTN_4                                          = 0x0122,
        GLOBAL_CONFIG__SPAD_ENABLES_RTN_5                                          = 0x0123,
        GLOBAL_CONFIG__SPAD_ENABLES_RTN_6                                          = 0x0124,
        GLOBAL_CONFIG__SPAD_ENABLES_RTN_7                                          = 0x0125,
        GLOBAL_CONFIG__SPAD_ENABLES_RTN_8                                          = 0x0126,
        GLOBAL_CONFIG__SPAD_ENABLES_RTN_9                                          = 0x0127,
        GLOBAL_CONFIG__SPAD_ENABLES_RTN_10                                         = 0x0128,
        GLOBAL_CONFIG__SPAD_ENABLES_RTN_11                                         = 0x0129,
        GLOBAL_CONFIG__SPAD_ENABLES_RTN_12                                         = 0x012A,
        GLOBAL_CONFIG__SPAD_ENABLES_RTN_13                                         = 0x012B,
        GLOBAL_CONFIG__SPAD_ENABLES_RTN_14                                         = 0x012C,
        GLOBAL_CONFIG__SPAD_ENABLES_RTN_15                                         = 0x012D,
        GLOBAL_CONFIG__SPAD_ENABLES_RTN_16                                         = 0x012E,
        GLOBAL_CONFIG__SPAD_ENABLES_RTN_17                                         = 0x012F,
        GLOBAL_CONFIG__SPAD_ENABLES_RTN_18                                         = 0x0130,
        GLOBAL_CONFIG__SPAD_ENABLES_RTN_19                                         = 0x0131,
        GLOBAL_CONFIG__SPAD_ENABLES_RTN_20                                         = 0x0132,
        GLOBAL_CONFIG__SPAD_ENABLES_RTN_21                                         = 0x0133,
        GLOBAL_CONFIG__SPAD_ENABLES_RTN_22                                         = 0x0134,
        GLOBAL_CONFIG__SPAD_ENABLES_RTN_23                                         = 0x0135,
        GLOBAL_CONFIG__SPAD_ENABLES_RTN_24                                         = 0x0136,
        GLOBAL_CONFIG__SPAD_ENABLES_RTN_25                                         = 0x0137,
        GLOBAL_CONFIG__SPAD_ENABLES_RTN_26                                         = 0x0138,
        GLOBAL_CONFIG__SPAD_ENABLES_RTN_27                                         = 0x0139,
        GLOBAL_CONFIG__SPAD_ENABLES_RTN_28                                         = 0x013A,
        GLOBAL_CONFIG__SPAD_ENABLES_RTN_29                                         = 0x013B,
        GLOBAL_CONFIG__SPAD_ENABLES_RTN_30                                         = 0x013C,
        GLOBAL_CONFIG__SPAD_ENABLES_RTN_31                                         = 0x013D,
        ROI_CONFIG__MODE_ROI_CENTRE_SPAD                                           = 0x013E,
        ROI_CONFIG__MODE_ROI_XY_SIZE                                               = 0x013F,
        GO2_HOST_BANK_ACCESS__OVERRIDE                                             = 0x0300,
        MCU_UTIL_MULTIPLIER__MULTIPLICAND                                          = 0x0400,
        MCU_UTIL_MULTIPLIER__MULTIPLICAND_3                                        = 0x0400,
        MCU_UTIL_MULTIPLIER__MULTIPLICAND_2                                        = 0x0401,
        MCU_UTIL_MULTIPLIER__MULTIPLICAND_1                                        = 0x0402,
        MCU_UTIL_MULTIPLIER__MULTIPLICAND_0                                        = 0x0403,
        MCU_UTIL_MULTIPLIER__MULTIPLIER                                            = 0x0404,
        MCU_UTIL_MULTIPLIER__MULTIPLIER_3                                          = 0x0404,
        MCU_UTIL_MULTIPLIER__MULTIPLIER_2                                          = 0x0405,
        MCU_UTIL_MULTIPLIER__MULTIPLIER_1                                          = 0x0406,
        MCU_UTIL_MULTIPLIER__MULTIPLIER_0                                          = 0x0407,
        MCU_UTIL_MULTIPLIER__PRODUCT_HI                                            = 0x0408,
        MCU_UTIL_MULTIPLIER__PRODUCT_HI_3                                          = 0x0408,
        MCU_UTIL_MULTIPLIER__PRODUCT_HI_2                                          = 0x0409,
        MCU_UTIL_MULTIPLIER__PRODUCT_HI_1                                          = 0x040A,
        MCU_UTIL_MULTIPLIER__PRODUCT_HI_0                                          = 0x040B,
        MCU_UTIL_MULTIPLIER__PRODUCT_LO                                            = 0x040C,
        MCU_UTIL_MULTIPLIER__PRODUCT_LO_3                                          = 0x040C,
        MCU_UTIL_MULTIPLIER__PRODUCT_LO_2                                          = 0x040D,
        MCU_UTIL_MULTIPLIER__PRODUCT_LO_1                                          = 0x040E,
        MCU_UTIL_MULTIPLIER__PRODUCT_LO_0                                          = 0x040F,
        MCU_UTIL_MULTIPLIER__START                                                 = 0x0410,
        MCU_UTIL_MULTIPLIER__STATUS                                                = 0x0411,
        MCU_UTIL_DIVIDER__START                                                    = 0x0412,
        MCU_UTIL_DIVIDER__STATUS                                                   = 0x0413,
        MCU_UTIL_DIVIDER__DIVIDEND                                                 = 0x0414,
        MCU_UTIL_DIVIDER__DIVIDEND_3                                               = 0x0414,
        MCU_UTIL_DIVIDER__DIVIDEND_2                                               = 0x0415,
        MCU_UTIL_DIVIDER__DIVIDEND_1                                               = 0x0416,
        MCU_UTIL_DIVIDER__DIVIDEND_0                                               = 0x0417,
        MCU_UTIL_DIVIDER__DIVISOR                                                  = 0x0418,
        MCU_UTIL_DIVIDER__DIVISOR_3                                                = 0x0418,
        MCU_UTIL_DIVIDER__DIVISOR_2                                                = 0x0419,
        MCU_UTIL_DIVIDER__DIVISOR_1                                                = 0x041A,
        MCU_UTIL_DIVIDER__DIVISOR_0                                                = 0x041B,
        MCU_UTIL_DIVIDER__QUOTIENT                                                 = 0x041C,
        MCU_UTIL_DIVIDER__QUOTIENT_3                                               = 0x041C,
        MCU_UTIL_DIVIDER__QUOTIENT_2                                               = 0x041D,
        MCU_UTIL_DIVIDER__QUOTIENT_1                                               = 0x041E,
        MCU_UTIL_DIVIDER__QUOTIENT_0                                               = 0x041F,
        TIMER0__VALUE_IN                                                           = 0x0420,
        TIMER0__VALUE_IN_3                                                         = 0x0420,
        TIMER0__VALUE_IN_2                                                         = 0x0421,
        TIMER0__VALUE_IN_1                                                         = 0x0422,
        TIMER0__VALUE_IN_0                                                         = 0x0423,
        TIMER1__VALUE_IN                                                           = 0x0424,
        TIMER1__VALUE_IN_3                                                         = 0x0424,
        TIMER1__VALUE_IN_2                                                         = 0x0425,
        TIMER1__VALUE_IN_1                                                         = 0x0426,
        TIMER1__VALUE_IN_0                                                         = 0x0427,
        TIMER0__CTRL                                                               = 0x0428,
        TIMER1__CTRL                                                               = 0x0429,
        MCU_GENERAL_PURPOSE__GP_0                                                  = 0x042C,
        MCU_GENERAL_PURPOSE__GP_1                                                  = 0x042D,
        MCU_GENERAL_PURPOSE__GP_2                                                  = 0x042E,
        MCU_GENERAL_PURPOSE__GP_3                                                  = 0x042F,
        MCU_RANGE_CALC__CONFIG                                                     = 0x0430,
        MCU_RANGE_CALC__OFFSET_CORRECTED_RANGE                                     = 0x0432,
        MCU_RANGE_CALC__OFFSET_CORRECTED_RANGE_HI                                  = 0x0432,
        MCU_RANGE_CALC__OFFSET_CORRECTED_RANGE_LO                                  = 0x0433,
        MCU_RANGE_CALC__SPARE_4                                                    = 0x0434,
        MCU_RANGE_CALC__SPARE_4_3                                                  = 0x0434,
        MCU_RANGE_CALC__SPARE_4_2                                                  = 0x0435,
        MCU_RANGE_CALC__SPARE_4_1                                                  = 0x0436,
        MCU_RANGE_CALC__SPARE_4_0                                                  = 0x0437,
        MCU_RANGE_CALC__AMBIENT_DURATION_PRE_CALC                                  = 0x0438,
        MCU_RANGE_CALC__AMBIENT_DURATION_PRE_CALC_HI                               = 0x0438,
        MCU_RANGE_CALC__AMBIENT_DURATION_PRE_CALC_LO                               = 0x0439,
        MCU_RANGE_CALC__ALGO_VCSEL_PERIOD                                          = 0x043C,
        MCU_RANGE_CALC__SPARE_5                                                    = 0x043D,
        MCU_RANGE_CALC__ALGO_TOTAL_PERIODS                                         = 0x043E,
        MCU_RANGE_CALC__ALGO_TOTAL_PERIODS_HI                                      = 0x043E,
        MCU_RANGE_CALC__ALGO_TOTAL_PERIODS_LO                                      = 0x043F,
        MCU_RANGE_CALC__ALGO_ACCUM_PHASE                                           = 0x0440,
        MCU_RANGE_CALC__ALGO_ACCUM_PHASE_3                                         = 0x0440,
        MCU_RANGE_CALC__ALGO_ACCUM_PHASE_2                                         = 0x0441,
        MCU_RANGE_CALC__ALGO_ACCUM_PHASE_1                                         = 0x0442,
        MCU_RANGE_CALC__ALGO_ACCUM_PHASE_0                                         = 0x0443,
        MCU_RANGE_CALC__ALGO_SIGNAL_EVENTS                                         = 0x0444,
        MCU_RANGE_CALC__ALGO_SIGNAL_EVENTS_3                                       = 0x0444,
        MCU_RANGE_CALC__ALGO_SIGNAL_EVENTS_2                                       = 0x0445,
        MCU_RANGE_CALC__ALGO_SIGNAL_EVENTS_1                                       = 0x0446,
        MCU_RANGE_CALC__ALGO_SIGNAL_EVENTS_0                                       = 0x0447,
        MCU_RANGE_CALC__ALGO_AMBIENT_EVENTS                                        = 0x0448,
        MCU_RANGE_CALC__ALGO_AMBIENT_EVENTS_3                                      = 0x0448,
        MCU_RANGE_CALC__ALGO_AMBIENT_EVENTS_2                                      = 0x0449,
        MCU_RANGE_CALC__ALGO_AMBIENT_EVENTS_1                                      = 0x044A,
        MCU_RANGE_CALC__ALGO_AMBIENT_EVENTS_0                                      = 0x044B,
        MCU_RANGE_CALC__SPARE_6                                                    = 0x044C,
        MCU_RANGE_CALC__SPARE_6_HI                                                 = 0x044C,
        MCU_RANGE_CALC__SPARE_6_LO                                                 = 0x044D,
        MCU_RANGE_CALC__ALGO_ADJUST_VCSEL_PERIOD                                   = 0x044E,
        MCU_RANGE_CALC__ALGO_ADJUST_VCSEL_PERIOD_HI                                = 0x044E,
        MCU_RANGE_CALC__ALGO_ADJUST_VCSEL_PERIOD_LO                                = 0x044F,
        MCU_RANGE_CALC__NUM_SPADS                                                  = 0x0450,
        MCU_RANGE_CALC__NUM_SPADS_HI                                               = 0x0450,
        MCU_RANGE_CALC__NUM_SPADS_LO                                               = 0x0451,
        MCU_RANGE_CALC__PHASE_OUTPUT                                               = 0x0452,
        MCU_RANGE_CALC__PHASE_OUTPUT_HI                                            = 0x0452,
        MCU_RANGE_CALC__PHASE_OUTPUT_LO                                            = 0x0453,
        MCU_RANGE_CALC__RATE_PER_SPAD_MCPS                                         = 0x0454,
        MCU_RANGE_CALC__RATE_PER_SPAD_MCPS_3                                       = 0x0454,
        MCU_RANGE_CALC__RATE_PER_SPAD_MCPS_2                                       = 0x0455,
        MCU_RANGE_CALC__RATE_PER_SPAD_MCPS_1                                       = 0x0456,
        MCU_RANGE_CALC__RATE_PER_SPAD_MCPS_0                                       = 0x0457,
        MCU_RANGE_CALC__SPARE_7                                                    = 0x0458,
        MCU_RANGE_CALC__SPARE_8                                                    = 0x0459,
        MCU_RANGE_CALC__PEAK_SIGNAL_RATE_MCPS                                      = 0x045A,
        MCU_RANGE_CALC__PEAK_SIGNAL_RATE_MCPS_HI                                   = 0x045A,
        MCU_RANGE_CALC__PEAK_SIGNAL_RATE_MCPS_LO                                   = 0x045B,
        MCU_RANGE_CALC__AVG_SIGNAL_RATE_MCPS                                       = 0x045C,
        MCU_RANGE_CALC__AVG_SIGNAL_RATE_MCPS_HI                                    = 0x045C,
        MCU_RANGE_CALC__AVG_SIGNAL_RATE_MCPS_LO                                    = 0x045D,
        MCU_RANGE_CALC__AMBIENT_RATE_MCPS                                          = 0x045E,
        MCU_RANGE_CALC__AMBIENT_RATE_MCPS_HI                                       = 0x045E,
        MCU_RANGE_CALC__AMBIENT_RATE_MCPS_LO                                       = 0x045F,
        MCU_RANGE_CALC__XTALK                                                      = 0x0460,
        MCU_RANGE_CALC__XTALK_HI                                                   = 0x0460,
        MCU_RANGE_CALC__XTALK_LO                                                   = 0x0461,
        MCU_RANGE_CALC__CALC_STATUS                                                = 0x0462,
        MCU_RANGE_CALC__DEBUG                                                      = 0x0463,
        MCU_RANGE_CALC__PEAK_SIGNAL_RATE_XTALK_CORR_MCPS                           = 0x0464,
        MCU_RANGE_CALC__PEAK_SIGNAL_RATE_XTALK_CORR_MCPS_HI                        = 0x0464,
        MCU_RANGE_CALC__PEAK_SIGNAL_RATE_XTALK_CORR_MCPS_LO                        = 0x0465,
        MCU_RANGE_CALC__SPARE_0                                                    = 0x0468,
        MCU_RANGE_CALC__SPARE_1                                                    = 0x0469,
        MCU_RANGE_CALC__SPARE_2                                                    = 0x046A,
        MCU_RANGE_CALC__SPARE_3                                                    = 0x046B,
        PATCH__CTRL                                                                = 0x0470,
        PATCH__JMP_ENABLES                                                         = 0x0472,
        PATCH__JMP_ENABLES_HI                                                      = 0x0472,
        PATCH__JMP_ENABLES_LO                                                      = 0x0473,
        PATCH__DATA_ENABLES                                                        = 0x0474,
        PATCH__DATA_ENABLES_HI                                                     = 0x0474,
        PATCH__DATA_ENABLES_LO                                                     = 0x0475,
        PATCH__OFFSET_0                                                            = 0x0476,
        PATCH__OFFSET_0_HI                                                         = 0x0476,
        PATCH__OFFSET_0_LO                                                         = 0x0477,
        PATCH__OFFSET_1                                                            = 0x0478,
        PATCH__OFFSET_1_HI                                                         = 0x0478,
        PATCH__OFFSET_1_LO                                                         = 0x0479,
        PATCH__OFFSET_2                                                            = 0x047A,
        PATCH__OFFSET_2_HI                                                         = 0x047A,
        PATCH__OFFSET_2_LO                                                         = 0x047B,
        PATCH__OFFSET_3                                                            = 0x047C,
        PATCH__OFFSET_3_HI                                                         = 0x047C,
        PATCH__OFFSET_3_LO                                                         = 0x047D,
        PATCH__OFFSET_4                                                            = 0x047E,
        PATCH__OFFSET_4_HI                                                         = 0x047E,
        PATCH__OFFSET_4_LO                                                         = 0x047F,
        PATCH__OFFSET_5                                                            = 0x0480,
        PATCH__OFFSET_5_HI                                                         = 0x0480,
        PATCH__OFFSET_5_LO                                                         = 0x0481,
        PATCH__OFFSET_6                                                            = 0x0482,
        PATCH__OFFSET_6_HI                                                         = 0x0482,
        PATCH__OFFSET_6_LO                                                         = 0x0483,
        PATCH__OFFSET_7                                                            = 0x0484,
        PATCH__OFFSET_7_HI                                                         = 0x0484,
        PATCH__OFFSET_7_LO                                                         = 0x0485,
        PATCH__OFFSET_8                                                            = 0x0486,
        PATCH__OFFSET_8_HI                                                         = 0x0486,
        PATCH__OFFSET_8_LO                                                         = 0x0487,
        PATCH__OFFSET_9                                                            = 0x0488,
        PATCH__OFFSET_9_HI                                                         = 0x0488,
        PATCH__OFFSET_9_LO                                                         = 0x0489,
        PATCH__OFFSET_10                                                           = 0x048A,
        PATCH__OFFSET_10_HI                                                        = 0x048A,
        PATCH__OFFSET_10_LO                                                        = 0x048B,
        PATCH__OFFSET_11                                                           = 0x048C,
        PATCH__OFFSET_11_HI                                                        = 0x048C,
        PATCH__OFFSET_11_LO                                                        = 0x048D,
        PATCH__OFFSET_12                                                           = 0x048E,
        PATCH__OFFSET_12_HI                                                        = 0x048E,
        PATCH__OFFSET_12_LO                                                        = 0x048F,
        PATCH__OFFSET_13                                                           = 0x0490,
        PATCH__OFFSET_13_HI                                                        = 0x0490,
        PATCH__OFFSET_13_LO                                                        = 0x0491,
        PATCH__OFFSET_14                                                           = 0x0492,
        PATCH__OFFSET_14_HI                                                        = 0x0492,
        PATCH__OFFSET_14_LO                                                        = 0x0493,
        PATCH__OFFSET_15                                                           = 0x0494,
        PATCH__OFFSET_15_HI                                                        = 0x0494,
        PATCH__OFFSET_15_LO                                                        = 0x0495,
        PATCH__ADDRESS_0                                                           = 0x0496,
        PATCH__ADDRESS_0_HI                                                        = 0x0496,
        PATCH__ADDRESS_0_LO                                                        = 0x0497,
        PATCH__ADDRESS_1                                                           = 0x0498,
        PATCH__ADDRESS_1_HI                                                        = 0x0498,
        PATCH__ADDRESS_1_LO                                                        = 0x0499,
        PATCH__ADDRESS_2                                                           = 0x049A,
        PATCH__ADDRESS_2_HI                                                        = 0x049A,
        PATCH__ADDRESS_2_LO                                                        = 0x049B,
        PATCH__ADDRESS_3                                                           = 0x049C,
        PATCH__ADDRESS_3_HI                                                        = 0x049C,
        PATCH__ADDRESS_3_LO                                                        = 0x049D,
        PATCH__ADDRESS_4                                                           = 0x049E,
        PATCH__ADDRESS_4_HI                                                        = 0x049E,
        PATCH__ADDRESS_4_LO                                                        = 0x049F,
        PATCH__ADDRESS_5                                                           = 0x04A0,
        PATCH__ADDRESS_5_HI                                                        = 0x04A0,
        PATCH__ADDRESS_5_LO                                                        = 0x04A1,
        PATCH__ADDRESS_6                                                           = 0x04A2,
        PATCH__ADDRESS_6_HI                                                        = 0x04A2,
        PATCH__ADDRESS_6_LO                                                        = 0x04A3,
        PATCH__ADDRESS_7                                                           = 0x04A4,
        PATCH__ADDRESS_7_HI                                                        = 0x04A4,
        PATCH__ADDRESS_7_LO                                                        = 0x04A5,
        PATCH__ADDRESS_8                                                           = 0x04A6,
        PATCH__ADDRESS_8_HI                                                        = 0x04A6,
        PATCH__ADDRESS_8_LO                                                        = 0x04A7,
        PATCH__ADDRESS_9                                                           = 0x04A8,
        PATCH__ADDRESS_9_HI                                                        = 0x04A8,
        PATCH__ADDRESS_9_LO                                                        = 0x04A9,
        PATCH__ADDRESS_10                                                          = 0x04AA,
        PATCH__ADDRESS_10_HI                                                       = 0x04AA,
        PATCH__ADDRESS_10_LO                                                       = 0x04AB,
        PATCH__ADDRESS_11                                                          = 0x04AC,
        PATCH__ADDRESS_11_HI                                                       = 0x04AC,
        PATCH__ADDRESS_11_LO                                                       = 0x04AD,
        PATCH__ADDRESS_12                                                          = 0x04AE,
        PATCH__ADDRESS_12_HI                                                       = 0x04AE,
        PATCH__ADDRESS_12_LO                                                       = 0x04AF,
        PATCH__ADDRESS_13                                                          = 0x04B0,
        PATCH__ADDRESS_13_HI                                                       = 0x04B0,
        PATCH__ADDRESS_13_LO                                                       = 0x04B1,
        PATCH__ADDRESS_14                                                          = 0x04B2,
        PATCH__ADDRESS_14_HI                                                       = 0x04B2,
        PATCH__ADDRESS_14_LO                                                       = 0x04B3,
        PATCH__ADDRESS_15                                                          = 0x04B4,
        PATCH__ADDRESS_15_HI                                                       = 0x04B4,
        PATCH__ADDRESS_15_LO                                                       = 0x04B5,
        SPI_ASYNC_MUX__CTRL                                                        = 0x04C0,
        CLK__CONFIG                                                                = 0x04C4,
        GPIO_LV_MUX__CTRL                                                          = 0x04CC,
        GPIO_LV_PAD__CTRL                                                          = 0x04CD,
        PAD_I2C_LV__CONFIG                                                         = 0x04D0,
        PAD_STARTUP_MODE__VALUE_RO_GO1                                             = 0x04D4,
        HOST_IF__STATUS_GO1                                                        = 0x04D5,
        MCU_CLK_GATING__CTRL                                                       = 0x04D8,
        TEST__BIST_ROM_CTRL                                                        = 0x04E0,
        TEST__BIST_ROM_RESULT                                                      = 0x04E1,
        TEST__BIST_ROM_MCU_SIG                                                     = 0x04E2,
        TEST__BIST_ROM_MCU_SIG_HI                                                  = 0x04E2,
        TEST__BIST_ROM_MCU_SIG_LO                                                  = 0x04E3,
        TEST__BIST_RAM_CTRL                                                        = 0x04E4,
        TEST__BIST_RAM_RESULT                                                      = 0x04E5,
        TEST__TMC                                                                  = 0x04E8,
        TEST__PLL_BIST_MIN_THRESHOLD                                               = 0x04F0,
        TEST__PLL_BIST_MIN_THRESHOLD_HI                                            = 0x04F0,
        TEST__PLL_BIST_MIN_THRESHOLD_LO                                            = 0x04F1,
        TEST__PLL_BIST_MAX_THRESHOLD                                               = 0x04F2,
        TEST__PLL_BIST_MAX_THRESHOLD_HI                                            = 0x04F2,
        TEST__PLL_BIST_MAX_THRESHOLD_LO                                            = 0x04F3,
        TEST__PLL_BIST_COUNT_OUT                                                   = 0x04F4,
        TEST__PLL_BIST_COUNT_OUT_HI                                                = 0x04F4,
        TEST__PLL_BIST_COUNT_OUT_LO                                                = 0x04F5,
        TEST__PLL_BIST_GONOGO                                                      = 0x04F6,
        TEST__PLL_BIST_CTRL                                                        = 0x04F7,
        RANGING_CORE__DEVICE_ID                                                    = 0x0680,
        RANGING_CORE__REVISION_ID                                                  = 0x0681,
        RANGING_CORE__CLK_CTRL1                                                    = 0x0683,
        RANGING_CORE__CLK_CTRL2                                                    = 0x0684,
        RANGING_CORE__WOI_1                                                        = 0x0685,
        RANGING_CORE__WOI_REF_1                                                    = 0x0686,
        RANGING_CORE__START_RANGING                                                = 0x0687,
        RANGING_CORE__LOW_LIMIT_1                                                  = 0x0690,
        RANGING_CORE__HIGH_LIMIT_1                                                 = 0x0691,
        RANGING_CORE__LOW_LIMIT_REF_1                                              = 0x0692,
        RANGING_CORE__HIGH_LIMIT_REF_1                                             = 0x0693,
        RANGING_CORE__QUANTIFIER_1_MSB                                             = 0x0694,
        RANGING_CORE__QUANTIFIER_1_LSB                                             = 0x0695,
        RANGING_CORE__QUANTIFIER_REF_1_MSB                                         = 0x0696,
        RANGING_CORE__QUANTIFIER_REF_1_LSB                                         = 0x0697,
        RANGING_CORE__AMBIENT_OFFSET_1_MSB                                         = 0x0698,
        RANGING_CORE__AMBIENT_OFFSET_1_LSB                                         = 0x0699,
        RANGING_CORE__AMBIENT_OFFSET_REF_1_MSB                                     = 0x069A,
        RANGING_CORE__AMBIENT_OFFSET_REF_1_LSB                                     = 0x069B,
        RANGING_CORE__FILTER_STRENGTH_1                                            = 0x069C,
        RANGING_CORE__FILTER_STRENGTH_REF_1                                        = 0x069D,
        RANGING_CORE__SIGNAL_EVENT_LIMIT_1_MSB                                     = 0x069E,
        RANGING_CORE__SIGNAL_EVENT_LIMIT_1_LSB                                     = 0x069F,
        RANGING_CORE__SIGNAL_EVENT_LIMIT_REF_1_MSB                                 = 0x06A0,
        RANGING_CORE__SIGNAL_EVENT_LIMIT_REF_1_LSB                                 = 0x06A1,
        RANGING_CORE__TIMEOUT_OVERALL_PERIODS_MSB                                  = 0x06A4,
        RANGING_CORE__TIMEOUT_OVERALL_PERIODS_LSB                                  = 0x06A5,
        RANGING_CORE__INVERT_HW                                                    = 0x06A6,
        RANGING_CORE__FORCE_HW                                                     = 0x06A7,
        RANGING_CORE__STATIC_HW_VALUE                                              = 0x06A8,
        RANGING_CORE__FORCE_CONTINUOUS_AMBIENT                                     = 0x06A9,
        RANGING_CORE__TEST_PHASE_SELECT_TO_FILTER                                  = 0x06AA,
        RANGING_CORE__TEST_PHASE_SELECT_TO_TIMING_GEN                              = 0x06AB,
        RANGING_CORE__INITIAL_PHASE_VALUE_1                                        = 0x06AC,
        RANGING_CORE__INITIAL_PHASE_VALUE_REF_1                                    = 0x06AD,
        RANGING_CORE__FORCE_UP_IN                                                  = 0x06AE,
        RANGING_CORE__FORCE_DN_IN                                                  = 0x06AF,
        RANGING_CORE__STATIC_UP_VALUE_1                                            = 0x06B0,
        RANGING_CORE__STATIC_UP_VALUE_REF_1                                        = 0x06B1,
        RANGING_CORE__STATIC_DN_VALUE_1                                            = 0x06B2,
        RANGING_CORE__STATIC_DN_VALUE_REF_1                                        = 0x06B3,
        RANGING_CORE__MONITOR_UP_DN                                                = 0x06B4,
        RANGING_CORE__INVERT_UP_DN                                                 = 0x06B5,
        RANGING_CORE__CPUMP_1                                                      = 0x06B6,
        RANGING_CORE__CPUMP_2                                                      = 0x06B7,
        RANGING_CORE__CPUMP_3                                                      = 0x06B8,
        RANGING_CORE__OSC_1                                                        = 0x06B9,
        RANGING_CORE__PLL_1                                                        = 0x06BB,
        RANGING_CORE__PLL_2                                                        = 0x06BC,
        RANGING_CORE__REFERENCE_1                                                  = 0x06BD,
        RANGING_CORE__REFERENCE_3                                                  = 0x06BF,
        RANGING_CORE__REFERENCE_4                                                  = 0x06C0,
        RANGING_CORE__REFERENCE_5                                                  = 0x06C1,
        RANGING_CORE__REGAVDD1V2                                                   = 0x06C3,
        RANGING_CORE__CALIB_1          #!/usr/bin/env python
# encoding: utf-8

def build(bld):
    bld.ap_example(
        use='ap',
    )
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           /*
 * AP_Relay.cpp
 *
 *  Created on: Oct 2, 2011
 *      Author: Amilcar Lucas
 */

#include "AP_Relay_config.h"

#if AP_RELAY_ENABLED

#include "AP_Relay.h"

#include <AP_HAL/AP_HAL.h>
#include <AP_Math/AP_Math.h>
#include <GCS_MAVLink/GCS.h>
#include <AP_Logger/AP_Logger.h>

#include <AP_ICEngine/AP_ICEngine.h>
#include <AP_Parachute/AP_Parachute.h>
#include <AP_Camera/AP_Camera.h>

#include <AP_Vehicle/AP_Vehicle_Type.h>
#if APM_BUILD_TYPE(APM_BUILD_Rover)
#include <AR_Motors/AP_MotorsUGV.h>
#endif

#if AP_RELAY_DRONECAN_ENABLED
#include <AP_DroneCAN/AP_DroneCAN.h>
#include <AP_CANManager/AP_CANManager.h>
#endif

#if AP_SIM_ENABLED
#include <SITL/SITL.h>
#endif

#if CONFIG_HAL_BOARD == HAL_BOARD_SITL
  #define RELAY1_PIN_DEFAULT 13

#elif CONFIG_HAL_BOARD == HAL_BOARD_LINUX
  #if CONFIG_HAL_BOARD_SUBTYPE == HAL_BOARD_SUBTYPE_LINUX_BLUE
    #define RELAY1_PIN_DEFAULT 57
    #define RELAY2_PIN_DEFAULT 49
    #define RELAY3_PIN_DEFAULT 116
    #define RELAY4_PIN_DEFAULT 113
  #elif CONFIG_HAL_BOARD_SUBTYPE == HAL_BOARD_SUBTYPE_LINUX_BBBMINI
    #define RELAY1_PIN_DEFAULT 27
    #define RELAY2_PIN_DEFAULT 65
    #define RELAY3_PIN_DEFAULT 22
    #define RELAY4_PIN_DEFAULT 81
    #define RELAY5_PIN_DEFAULT 23
    #define RELAY6_PIN_DEFAULT 26
  #endif
#endif

#ifndef RELAY1_PIN_DEFAULT
  #define RELAY1_PIN_DEFAULT -1
#endif

#ifndef RELAY2_PIN_DEFAULT
  #define RELAY2_PIN_DEFAULT -1
#endif

#ifndef RELAY3_PIN_DEFAULT
  #define RELAY3_PIN_DEFAULT -1
#endif

#ifndef RELAY4_PIN_DEFAULT
  #define RELAY4_PIN_DEFAULT -1
#endif

#ifndef RELAY5_PIN_DEFAULT
  #define RELAY5_PIN_DEFAULT -1
#endif

#ifndef RELAY6_PIN_DEFAULT
  #define RELAY6_PIN_DEFAULT -1
#endif


const AP_Param::GroupInfo AP_Relay::var_info[] = {
    // 0 was PIN
    // 1 was PIN2
    // 2 was PIN3
    // 3 was PIN4
    // 4 was DEFAULT
    // 5 was PIN5
    // 6 was PIN6

    // @Group: 1_
    // @Path: AP_Relay_Params.cpp
    AP_SUBGROUPINFO(_params[0], "1_", 7, AP_Relay, AP_Relay_Params),

#if AP_RELAY_NUM_RELAYS > 1
    // @Group: 2_
    // @Path: AP_Relay_Params.cpp
    AP_SUBGROUPINFO(_params[1], "2_", 8, AP_Relay, AP_Relay_Params),
#endif

#if AP_RELAY_NUM_RELAYS > 2
    // @Group: 3_
    // @Path: AP_Relay_Params.cpp
    AP_SUBGROUPINFO(_params[2], "3_", 9, AP_Relay, AP_Relay_Params),
#endif

#if AP_RELAY_NUM_RELAYS > 3
    // @Group: 4_
    // @Path: AP_Relay_Params.cpp
    AP_SUBGROUPINFO(_params[3], "4_", 10, AP_Relay, AP_Relay_Params),
#endif

#if AP_RELAY_NUM_RELAYS > 4
    // @Group: 5_
    // @Path: AP_Relay_Params.cpp
    AP_SUBGROUPINFO(_params[4], "5_", 11, AP_Relay, AP_Relay_Params),
#endif

#if AP_RELAY_NUM_RELAYS > 5
    // @Group: 6_
    // @Path: AP_Relay_Params.cpp
    AP_SUBGROUPINFO(_params[5], "6_", 12, AP_Relay, AP_Relay_Params),
#endif

#if AP_RELAY_NUM_RELAYS > 6
    // @Group: 7_
    // @Path: AP_Relay_Params.cpp
    AP_SUBGROUPINFO(_params[6], "7_", 13, AP_Relay, AP_Relay_Params),
#endif

#if AP_RELAY_NUM_RELAYS > 7
    // @Group: 8_
    // @Path: AP_Relay_Params.cpp
    AP_SUBGROUPINFO(_params[7], "8_", 14, AP_Relay, AP_Relay_Params),
#endif

#if AP_RELAY_NUM_RELAYS > 8
    // @Group: 9_
    // @Path: AP_Relay_Params.cpp
    AP_SUBGROUPINFO(_params[8], "9_", 15, AP_Relay, AP_Relay_Params),
#endif

#if AP_RELAY_NUM_RELAYS > 9
    // @Group: 10_
    // @Path: AP_Relay_Params.cpp
    AP_SUBGROUPINFO(_params[9], "10_", 16, AP_Relay, AP_Relay_Params),
#endif

#if AP_RELAY_NUM_RELAYS > 10
    // @Group: 11_
    // @Path: AP_Relay_Params.cpp
    AP_SUBGROUPINFO(_params[10], "11_", 17, AP_Relay, AP_Relay_Params),
#endif

#if AP_RELAY_NUM_RELAYS > 11
    // @Group: 12_
    // @Path: AP_Relay_Params.cpp
    AP_SUBGROUPINFO(_params[11], "12_", 18, AP_Relay, AP_Relay_Params),
#endif

#if AP_RELAY_NUM_RELAYS > 12
    // @Group: 13_
    // @Path: AP_Relay_Params.cpp
    AP_SUBGROUPINFO(_params[12], "13_", 19, AP_Relay, AP_Relay_Params),
#endif

#if AP_RELAY_NUM_RELAYS > 13
    // @Group: 14_
    // @Path: AP_Relay_Params.cpp
    AP_SUBGROUPINFO(_params[13], "14_", 20, AP_Relay, AP_Relay_Params),
#endif

#if AP_RELAY_NUM_RELAYS > 14
    // @Group: 15_
    // @Path: AP_Relay_Params.cpp
    AP_SUBGROUPINFO(_params[14], "15_", 21, AP_Relay, AP_Relay_Params),
#endif

#if AP_RELAY_NUM_RELAYS > 15
    // @Group: 16_
    // @Path: AP_Relay_Params.cpp
    AP_SUBGROUPINFO(_params[15], "16_", 22, AP_Relay, AP_Relay_Params),
#endif

    AP_GROUPEND
};

AP_Relay *AP_Relay::singleton;

extern const AP_HAL::HAL& hal;

AP_Relay::AP_Relay(void)
{
    AP_Param::setup_object_defaults(this, var_info);

#if CONFIG_HAL_BOARD == HAL_BOARD_SITL
    if (singleton != nullptr) {
        AP_HAL::panic("AP_Relay must be singleton");
    }
#endif
    singleton = this;
}

void AP_Relay::convert_params()
{
    // PARAMETER_CONVERSION - Added: Dec-2023
#ifndef HAL_BUILD_AP_PERIPH
    // Dont need this conversion on periph as relay support is more recent

    // Before converting local params we must find any relays being used by index from external libs
    int8_t ice_relay = -1;
#if AP_ICENGINE_ENABLED
    AP_ICEngine *ice = AP::ice();
    int8_t ice_relay_index;
    if (ice != nullptr && ice->get_legacy_ignition_relay_index(ice_relay_index)) {
        ice_relay = ice_relay_index;
    }
#endif

    int8_t chute_relay = -1;
#if HAL_PARACHUTE_ENABLED
    AP_Parachute *parachute = AP::parachute();
    int8_t parachute_relay_index;
    if (parachute != nullptr && parachute->get_legacy_relay_index(parachute_relay_index)) {
        chute_relay = parachute_relay_index;
    }
#endif

    int8_t cam_relay = -1;
#if AP_CAMERA_ENABLED
    AP_Camera *camera = AP::camera();
    int8_t camera_relay_index;
    if ((camera != nullptr) && (camera->get_legacy_relay_index(camera_relay_index))) {
        cam_relay = camera_relay_index;
    }
#endif

#if APM_BUILD_TYPE(APM_BUILD_Rover)
    int8_t rover_relay[] = { -1, -1, -1, -1 };
    AP_MotorsUGV *motors = AP::motors_ugv();
    if (motors != nullptr) {
        motors->get_legacy_relay_index(rover_relay[0], rover_relay[1], rover_relay[2], rover_relay[3]);
    }
#endif

    // Find old default param
    int8_t default_state = 0; // off was the old behaviour
    const bool have_default = AP_Param::get_param_by_index(this, 4, AP_PARAM_INT8, &default_state);

    // grab the old values if they were set
    for (uint8_t i = 0; i < MIN(ARRAY_SIZE(_params), 6U); i++) {
        if (_params[i].function.configured()) {
            // Conversion already done, or user has configured manually
            continue;
        }

        uint8_t param_index = i;
        if (i > 3) {
            // Skip over the old DEFAULT parameter at index 4
            param_index += 1;
        }

        int8_t pin = 0;
        if (!_params[i].pin.configured() && AP_Param::get_param_by_index(this, param_index, AP_PARAM_INT8, &pin) && (pin >= 0)) {
            // Copy old pin parameter if valid
            _params[i].pin.set_and_save(pin);
        }

        // Work out what function this relay should be
        AP_Relay_Params::FUNCTION new_fun;
        if (i == chute_relay) {
            new_fun = AP_Relay_Params::FUNCTION::PARACHUTE;

        } else if (i == ice_relay) {
            new_fun = AP_Relay_Params::FUNCTION::IGNITION;

        } else if (i == cam_relay) {
            new_fun = AP_Relay_Params::FUNCTION::CAMERA;

#if APM_BUILD_TYPE(APM_BUILD_Rover)
        } else if (i == rover_relay[0]) {
            new_fun = AP_Relay_Params::FUNCTION::BRUSHED_REVERSE_1;

        } else if (i == rover_relay[1]) {
            new_fun = AP_Relay_Params::FUNCTION::BRUSHED_REVERSE_2;

        } else if (i == rover_relay[2]) {
            new_fun = AP_Relay_Params::FUNCTION::BRUSHED_REVERSE_3;

        } else if (i == rover_relay[3]) {
            new_fun = AP_Relay_Params::FUNCTION::BRUSHED_REVERSE_4;
#endif

        } else {
            if (_params[i].pin < 0) {
                // Don't enable as numbered relay if pin is invalid
                // Other functions should be enabled with a invalid pin
                // This will result in a pre-arm promoting the user to resolve
                continue;
            }
            new_fun = AP_Relay_Params::FUNCTION::RELAY;

        }
        _params[i].function.set_and_save(int8_t(new_fun));


        // Set the default state
        if (have_default) {
            _params[i].default_state.set_and_save(default_state);
        }
    }
#endif // HAL_BUILD_AP_PERIPH
}

void AP_Relay::set_defaults() {
    const int8_t pins[] = { RELAY1_PIN_DEFAULT,
                             RELAY2_PIN_DEFAULT,
                             RELAY3_PIN_DEFAULT,
                             RELAY4_PIN_DEFAULT,
                             RELAY5_PIN_DEFAULT,
                             RELAY6_PIN_DEFAULT };

    for (uint8_t i = 0; i < MIN(ARRAY_SIZE(_params), ARRAY_SIZE(pins)); i++) {
        // set the default
        if (pins[i] != -1) {
            _params[i].pin.set_default(pins[i]);
        }
    }
}

// Return true is function is valid
bool AP_Relay::function_valid(AP_Relay_Params::FUNCTION function) const
{
    return (function > AP_Relay_Params::FUNCTION::NONE) && (function < AP_Relay_Params::FUNCTION::NUM_FUNCTIONS);
}

void AP_Relay::init()
{
    set_defaults();

    convert_params();

    // setup the actual default values of all the pins
    for (uint8_t instance = 0; instance < ARRAY_SIZE(_params); instance++) {
        const int16_t pin = _params[instance].pin;
        if (pin == -1) {
            // no valid pin to set it on, skip it
            continue;
        }

        const AP_Relay_Params::FUNCTION function = _params[instance].function;
        if (!function_valid(function)) {
            // invalid function, skip it
            continue;
        }

        if (function == AP_Relay_Params::FUNCTION::RELAY) {
            // relay by instance number, set the state to match our output
            const AP_Relay_Params::DefaultState default_state = _params[instance].default_state;
            if ((default_state == AP_Relay_Params::DefaultState::OFF) ||
                (default_state == AP_Relay_Params::DefaultState::ON)) {

                set_pin_by_instance(instance, (bool)default_state);
            }
        } else {
            // all functions are supposed to be off by default
            // this will need revisiting when we support inversion
            set_pin_by_instance(instance, false);
        }

        // Make sure any DroneCAN pin is enabled for streaming
#if AP_RELAY_DRONECAN_ENABLED
        dronecan.enable_pin(pin);
#endif

    }
}

void AP_Relay::set(const AP_Relay_Params::FUNCTION function, const bool value) {
    if (!function_valid(function)) {
        // invalid function
        return;
    }

    for (uint8_t instance = 0; instance < ARRAY_SIZE(_params); instance++) {
        if (function != _params[instance].function) {
            continue;
        }

        set_pin_by_instance(instance, value);
    }
}

// set a pins output state by instance and log if required
// this is an internal helper, instance must have already been validated to be in range
void AP_Relay::set_pin_by_instance(uint8_t instance, bool value)
{
    const int16_t pin = _params[instance].pin;
    if (pin == -1) {
        // no valid pin to set it on, skip it
        return;
    }

#if AP_SIM_ENABLED
    if (!(AP::sitl()->on_hardware_relay_enable_mask & (1U << instance))) {
        return;
    }
#endif

    const bool initial_value = get_pin(pin);

    if (_params[instance].inverted > 0) {
        value = !value;
    }

    if (initial_value != value) {
        set_pin(pin, value);
#if HAL_LOGGING_ENABLED
        AP::logger().Write("RELY", "TimeUS,Instance,State", "s#-", "F--", "QBB",
                            AP_HAL::micros64(),
                            instance,
                            value);
#endif
    }
}

void AP_Relay::set(const uint8_t instance, const bool value)
{
    if (instance >= ARRAY_SIZE(_params)) {
        return;
    }

    if (_params[instance].function != AP_Relay_Params::FUNCTION::RELAY) {
        return;
    }

    set_pin_by_instance(instance, value);
}

void AP_Relay::toggle(uint8_t instance)
{
    if (instance < ARRAY_SIZE(_params)) {
        set(instance, !get(instance));
    }
}

// check settings are valid
bool AP_Relay::arming_checks(size_t buflen, char *buffer) const
{
    for (uint8_t i=0; i<ARRAY_SIZE(_params); i++) {
        if (!function_valid(_params[i].function)) {
            // Relay disabled
            continue;
        }

        const int16_t pin = _params[i].pin.get();
        if (pin == -1) {
            // Pin disabled, may want to pre-arm this in the future as function enabled with invalid pin
            // User should set function to none to disable
            continue;
        }

#if AP_RELAY_DRONECAN_ENABLED
        const bool DroneCAN_pin = dronecan.valid_pin(pin);
#else
        const bool DroneCAN_pin = false;
#endif

        if (!DroneCAN_pin && !hal.gpio->valid_pin(pin)) {
            // Check GPIO pin is valid
            char param_name_buf[14];
            hal.util->snprintf(param_name_buf, ARRAY_SIZE(param_name_buf), "RELAY%u_PIN", unsigned(i+1));
            uint8_t servo_ch;
            if (hal.gpio->pin_to_servo_channel(pin, servo_ch)) {
                hal.util->snprintf(buffer, buflen, "%s=%d, set SERVO%u_FUNCTION=-1", param_name_buf, int(pin), unsigned(servo_ch+1));
            } else {
                hal.util->snprintf(buffer, buflen, "%s=%d invalid", param_name_buf, int(pin));
            }
            return false;
        }

        // Each pin can only be used by a single relay
        for (uint8_t j=i+1; j<ARRAY_SIZE(_params); j++) {
            if (!function_valid((AP_Relay_Params::FUNCTION)_params[j].function.get())) {
                // Relay disabled
                continue;
            }
            if (pin == _params[j].pin.get()) {
                hal.util->snprintf(buffer, buflen, "pin conflict RELAY%u_PIN = RELAY%u_PIN", int(i+1), int(j+1));
                return false;
            }
        }
    }
    return true;
}

bool AP_Relay::get(uint8_t instance) const
{
    if (instance >= ARRAY_SIZE(_params)) {
        // invalid instance
        return false;
    }

    if (_params[instance].inverted > 0) {
        return !get_pin(_params[instance].pin.get());
    }

    return get_pin(_params[instance].pin.get());
}

// Get relay state from pin number
bool AP_Relay::get_pin(const int16_t pin) const
{
    if (pin < 0) {
        // invalid pin
        return false;
    }

#if AP_RELAY_DRONECAN_ENABLED
    if (dronecan.valid_pin(pin)) {
        // Virtual DroneCAN pin
        return dronecan.get_pin(pin);
    }
#endif

    // Real GPIO pin
    hal.gpio->pinMode(pin, HAL_GPIO_OUTPUT);
    return (bool)hal.gpio->read(pin);
}

// Set relay state from pin number
void AP_Relay::set_pin(const int16_t pin, const bool value)
{
    if (pin < 0) {
        // invalid pin
        return;
    }

#if AP_RELAY_DRONECAN_ENABLED
    if (dronecan.valid_pin(pin)) {
        // Virtual DroneCAN pin
        dronecan.set_pin(pin, value);
        return;
    }
#endif

    // Real GPIO pin
    hal.gpio->pinMode(pin, HAL_GPIO_OUTPUT);
    hal.gpio->write(pin, value);
}

// see if the relay is enabled
bool AP_Relay::enabled(uint8_t instance) const 
{
    // Must be a valid instance with function relay and pin set
    return (instance < ARRAY_SIZE(_params)) && (_params[instance].pin != -1) && (_params[instance].function == AP_Relay_Params::FUNCTION::RELAY);
}

// see if the relay is enabled
bool AP_Relay::enabled(AP_Relay_Params::FUNCTION function) const
{
    for (uint8_t instance = 0; instance < ARRAY_SIZE(_params); instance++) {
        if ((_params[instance].function == function) && (_params[instance].pin != -1)) {
            return true;
        }
    }
    return false;
}

#if AP_RELAY_DRONECAN_ENABLED
// Return true if pin number is a virtual DroneCAN pin
bool AP_Relay::DroneCAN::valid_pin(int16_t pin) const
{
    switch(pin) {
        case (int16_t)AP_Relay_Params::VIRTUAL_PINS::DroneCAN_0 ... (int16_t)AP_Relay_Params::VIRTUAL_PINS::DroneCAN_15:
            return true;
        default:
            return false;
    }
}

// Enable streaming of pin number
void AP_Relay::DroneCAN::enable_pin(int16_t pin)
{
    if (!valid_pin(pin)) {
        return;
    }

    const uint8_t index = hardpoint_index(pin);
    state[index].enabled = true;
}

// Get the hardpoint index of given pin number
uint8_t AP_Relay::DroneCAN::hardpoint_index(const int16_t pin) const
{
    return pin - (int16_t)AP_Relay_Params::VIRTUAL_PINS::DroneCAN_0;
}

// Set DroneCAN relay state from pin number
void AP_Relay::DroneCAN::set_pin(const int16_t pin, const bool value)
{
    const uint8_t index = hardpoint_index(pin);

    // Set pin and ensure enabled for streaming
    state[index].enabled = true;
    state[index].value = value;

    // Broadcast msg on all channels
    // Just a single send, rely on streaming to fill in any lost packet

    uavcan_equipment_hardpoint_Command msg {};
    msg.hardpoint_id = index;
    msg.command = state[index].value;

    uint8_t can_num_drivers = AP::can().get_num_drivers();
    for (uint8_t i = 0; i < can_num_drivers; i++) {
        auto *ap_dronecan = AP_DroneCAN::get_dronecan(i);
        if (ap_dronecan != nullptr) {
            ap_dronecan->relay_hardpoint.broadcast(msg);
        }
    }

}

// Get relay state from pin number, this relies on a cached value, assume remote pin is in sync
bool AP_Relay::DroneCAN::get_pin(const int16_t pin) const
{
    const uint8_t index = hardpoint_index(pin);
    return state[index].value;
}

// Populate message and update index with the sent command
// This will allow the caller to cycle through each enabled pin
bool AP_Relay::DroneCAN::populate_next_command(uint8_t &index, uavcan_equipment_hardpoint_Command &msg) const
{
    // Find the next enabled index
    for (uint8_t i = 0; i < ARRAY_SIZE(state); i++) {
        // Look for next index, wrapping back to 0 as needed
        const uint8_t new_index = (index + 1 + i) % ARRAY_SIZE(state);
        if (!state[new_index].enabled) {
            // This index is not being used
            continue;
        }

        // Update command and index then return
        msg.hardpoint_id = new_index;
        msg.command = state[new_index].value;
        index = new_index;
        return true;
    }

    return false;
}
#endif // AP_RELAY_DRONECAN_ENABLED

#if AP_MAVLINK_MSG_RELAY_STATUS_ENABLED
// this method may only return false if there is no space in the
// supplied link for the message.
bool AP_Relay::send_relay_status(const GCS_MAVLINK &link) const
{
    static_assert(AP_RELAY_NUM_RELAYS <= 16, "Too many relays for MAVLink status reporting to work.");

    if (!HAVE_PAYLOAD_SPACE(link.get_chan(), RELAY_STATUS)) {
        return false;
    }

    uint16_t present_mask = 0;
    uint16_t on_mask = 0;
    for (uint8_t i=0; i<ARRAY_SIZE(_params); i++) {
        if (!function_valid(_params[i].function)) {
            continue;
        }
        const uint16_t relay_bit_mask = 1U << i;
        present_mask |= relay_bit_mask;

        if (get(i)) {
            on_mask |= relay_bit_mask;
        }
    }

    mavlink_msg_relay_status_send(
        link.get_chan(),
        AP_HAL::millis(),
        on_mask,
        present_mask
        );
    return true;
}
#endif  // AP_MAVLINK_MSG_RELAY_STATUS_ENABLED

namespace AP {

AP_Relay *relay()
{
    return AP_Relay::get_singleton();
}

}

#endif  // AP_RELAY_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    /*
 * AP_Relay.h
 *
 *  Created on: Oct 2, 2011
 *      Author: Amilcar Lucas
 */

/// @file	AP_Relay.h
/// @brief	APM relay control class
#pragma once

#include "AP_Relay_config.h"

#if AP_RELAY_ENABLED

#include <AP_Param/AP_Param.h>
#include <AP_Relay/AP_Relay_Params.h>

#ifndef AP_RELAY_NUM_RELAYS
  #define AP_RELAY_NUM_RELAYS 6
#endif

#if AP_RELAY_NUM_RELAYS < 1
  #error There must be at least one relay instance if using AP_Relay
#endif

#if AP_RELAY_DRONECAN_ENABLED
#include <AP_DroneCAN/AP_DroneCAN.h>
#endif

/// @class	AP_Relay
/// @brief	Class to manage the ArduPilot relay
class AP_Relay {
#if AP_RELAY_DRONECAN_ENABLED
    // Allow DroneCAN to directly access private DroneCAN state
    friend class AP_DroneCAN;
#endif
public:
    AP_Relay();

    /* Do not allow copies */
    CLASS_NO_COPY(AP_Relay);

    // setup the relay pin
    void        init();

    // activate the relay
    void        on(uint8_t instance) { set(instance, true); }

    // de-activate the relay
    void        off(uint8_t instance) { set(instance, false); }

    // get state of relay
    bool        get(uint8_t instance) const;
    
    // see if the relay is enabled
    bool        enabled(uint8_t instance) const;

    // toggle the relay status
    void        toggle(uint8_t instance);

    // check settings are valid
    bool arming_checks(size_t buflen, char *buffer) const;
    
    static AP_Relay *get_singleton(void) {return singleton; }

    static const struct AP_Param::GroupInfo        var_info[];

    bool send_relay_status(const class GCS_MAVLINK &link) const;

    void set(AP_Relay_Params::FUNCTION function, bool value);

    // see if the relay is enabled
    bool enabled(AP_Relay_Params::FUNCTION function) const;

private:
    static AP_Relay *singleton;

    AP_Relay_Params _params[AP_RELAY_NUM_RELAYS];

    // Return true is function is valid
    bool function_valid(AP_Relay_Params::FUNCTION function) const;

    void set(uint8_t instance, bool value);

    void set_defaults();
    void convert_params();

    void set_pin_by_instance(uint8_t instance, bool value);

    // Set relay state from pin number
    void set_pin(const int16_t pin, const bool value);

    // Get relay state from pin number
    bool get_pin(const int16_t pin) const;

#if AP_RELAY_DRONECAN_ENABLED
    // Virtual DroneCAN pins
    class DroneCAN {
    public:
        // Return true if pin number is a virtual DroneCAN pin
        bool valid_pin(int16_t pin) const;

        // Enable streaming of pin number
        void enable_pin(int16_t pin);

        // Populate message and update index with the sent command
        bool populate_next_command(uint8_t &index, uavcan_equipment_hardpoint_Command &msg) const;

        // Set DroneCAN relay state from pin number
        void set_pin(const int16_t pin, const bool value);

        // Get relay state from pin number
        bool get_pin(const int16_t pin) const;

    private:

        // Get the hardpoint index of given pin number
        uint8_t hardpoint_index(const int16_t pin) const;

        // Send DroneCAN hardpoint message for given index on all interfaces
        void send_index(const uint8_t index);

        static constexpr uint8_t num_pins = (int16_t)AP_Relay_Params::VIRTUAL_PINS::DroneCAN_15 - (int16_t)AP_Relay_Params::VIRTUAL_PINS::DroneCAN_0;

        struct {
            bool value;
            bool enabled;
        } state[num_pins];

    } dronecan;
#endif // AP_RELAY_DRONECAN_ENABLED

};

namespace AP {
    AP_Relay *relay();
};

#endif  // AP_RELAY_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              #include <AP_Common/AP_Common.h>
#include "AP_Relay_Params.h"

const AP_Param::GroupInfo AP_Relay_Params::var_info[] = {
    // @Param: FUNCTION
    // @DisplayName: Relay function
    // @Description: The function the relay channel is mapped to.
    // @Values{Copter, Rover, Plane, Blimp,Sub}: 0:None
    // @Values{Copter, Rover, Plane, Blimp,Sub}: 1:Relay
    // @Values{Plane}: 2:Ignition
    // @Values{Plane, Copter}: 3:Parachute
    // @Values{Copter, Rover, Plane, Blimp,Sub}: 4:Camera
    // @Values{Rover}: 5:Bushed motor reverse 1 throttle or throttle-left or omni motor 1
    // @Values{Rover}: 6:Bushed motor reverse 2 throttle-right or omni motor 2
    // @Values{Rover}: 7:Bushed motor reverse 3 omni motor 3
    // @Values{Rover}: 8:Bushed motor reverse 4 omni motor 4
    // @Values{Plane}: 9:ICE Starter
    // @Values{AP_Periph}: 10: DroneCAN Hardpoint ID 0
    // @Values{AP_Periph}: 11: DroneCAN Hardpoint ID 1
    // @Values{AP_Periph}: 12: DroneCAN Hardpoint ID 2
    // @Values{AP_Periph}: 13: DroneCAN Hardpoint ID 3
    // @Values{AP_Periph}: 14: DroneCAN Hardpoint ID 4
    // @Values{AP_Periph}: 15: DroneCAN Hardpoint ID 5
    // @Values{AP_Periph}: 16: DroneCAN Hardpoint ID 6
    // @Values{AP_Periph}: 17: DroneCAN Hardpoint ID 7
    // @Values{AP_Periph}: 18: DroneCAN Hardpoint ID 8
    // @Values{AP_Periph}: 19: DroneCAN Hardpoint ID 9
    // @Values{AP_Periph}: 20: DroneCAN Hardpoint ID 10
    // @Values{AP_Periph}: 21: DroneCAN Hardpoint ID 11
    // @Values{AP_Periph}: 22: DroneCAN Hardpoint ID 12
    // @Values{AP_Periph}: 23: DroneCAN Hardpoint ID 13
    // @Values{AP_Periph}: 24: DroneCAN Hardpoint ID 14
    // @Values{AP_Periph}: 25: DroneCAN Hardpoint ID 15

    // @User: Standard
    AP_GROUPINFO_FLAGS("FUNCTION", 1, AP_Relay_Params, function, (float)FUNCTION::NONE, AP_PARAM_FLAG_ENABLE),

    // @Param: PIN
    // @DisplayName: Relay pin
    // @Description: Digital pin number for relay control. Some common values are given, but see the Wiki's "GPIOs" page for how to determine the pin number for a given autopilot.
    // @Values: -1:Disabled,49:BB Blue GP0 pin 4,50:AUXOUT1,51:AUXOUT2,52:AUXOUT3,53:AUXOUT4,54:AUXOUT5,55:AUXOUT6,57:BB Blue GP0 pin 3,113:BB Blue GP0 pin 6,116:BB Blue GP0 pin 5,62:BBBMini Pin P8.13,101:MainOut1,102:MainOut2,103:MainOut3,104:MainOut4,105:MainOut5,106:MainOut6,107:MainOut7,108:MainOut8
    // @Values: 1000: DroneCAN Hardpoint ID 0
    // @Values: 1001: DroneCAN Hardpoint ID 1
    // @Values: 1002: DroneCAN Hardpoint ID 2
    // @Values: 1003: DroneCAN Hardpoint ID 3
    // @Values: 1004: DroneCAN Hardpoint ID 4
    // @Values: 1005: DroneCAN Hardpoint ID 5
    // @Values: 1006: DroneCAN Hardpoint ID 6
    // @Values: 1007: DroneCAN Hardpoint ID 7
    // @Values: 1008: DroneCAN Hardpoint ID 8
    // @Values: 1009: DroneCAN Hardpoint ID 9
    // @Values: 1010: DroneCAN Hardpoint ID 10
    // @Values: 1011: DroneCAN Hardpoint ID 11
    // @Values: 1012: DroneCAN Hardpoint ID 12
    // @Values: 1013: DroneCAN Hardpoint ID 13
    // @Values: 1014: DroneCAN Hardpoint ID 14
    // @Values: 1015: DroneCAN Hardpoint ID 15
    // @User: Standard
    AP_GROUPINFO("PIN", 2, AP_Relay_Params, pin, -1),

    // @Param: DEFAULT
    // @DisplayName: Relay default state
    // @Description: Should the relay default to on or off, this only applies to RELAYx_FUNC "Relay" (1). All other uses will pick the appropriate default output state from within the controlling function's parameters. Note that if INVERTED is set then the default is inverted.
    // @Values: 0: Off,1:On,2:NoChange
    // @User: Standard
    AP_GROUPINFO("DEFAULT", 3, AP_Relay_Params, default_state, (float)DefaultState::OFF),

    // @Param: INVERTED
    // @DisplayName: Relay invert output signal
    // @Description: Should the relay output signal be inverted. If enabled, relay on would be pin low and relay off would be pin high. NOTE: this impact's DEFAULT.
    // @Values: 0:Normal,1:Inverted
    // @User: Standard
    AP_GROUPINFO("INVERTED", 4, AP_Relay_Params, inverted, false),

    AP_GROUPEND

};

AP_Relay_Params::AP_Relay_Params(void) {
    AP_Param::setup_object_defaults(this, var_info);
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                #pragma once

#include <AP_Param/AP_Param.h>

class AP_Relay_Params {
public:
    static const struct AP_Param::GroupInfo var_info[];

    AP_Relay_Params(void);

    /* Do not allow copies */
    CLASS_NO_COPY(AP_Relay_Params);

    enum class DefaultState : uint8_t {
        OFF = 0,
        ON = 1,
        NO_CHANGE = 2,
    };

    enum class FUNCTION : uint8_t {
        NONE     = 0,
        RELAY    = 1,
        IGNITION = 2,
        PARACHUTE = 3,
        CAMERA = 4,
        BRUSHED_REVERSE_1 = 5,
        BRUSHED_REVERSE_2 = 6,
        BRUSHED_REVERSE_3 = 7,
        BRUSHED_REVERSE_4 = 8,
        ICE_STARTER = 9,
        DroneCAN_HARDPOINT_0  = 10,
        DroneCAN_HARDPOINT_1  = 11,
        DroneCAN_HARDPOINT_2  = 12,
        DroneCAN_HARDPOINT_3  = 13,
        DroneCAN_HARDPOINT_4  = 14,
        DroneCAN_HARDPOINT_5  = 15,
        DroneCAN_HARDPOINT_6  = 16,
        DroneCAN_HARDPOINT_7  = 17,
        DroneCAN_HARDPOINT_8  = 18,
        DroneCAN_HARDPOINT_9  = 19,
        DroneCAN_HARDPOINT_10 = 20,
        DroneCAN_HARDPOINT_11 = 21,
        DroneCAN_HARDPOINT_12 = 22,
        DroneCAN_HARDPOINT_13 = 23,
        DroneCAN_HARDPOINT_14 = 24,
        DroneCAN_HARDPOINT_15 = 25,
        NUM_FUNCTIONS // must be the last entry
    };

    // Pins that do not go via GPIO
    enum class VIRTUAL_PINS {
        DroneCAN_0  = 1000,
        DroneCAN_1  = 1001,
        DroneCAN_2  = 1002,
        DroneCAN_3  = 1003,
        DroneCAN_4  = 1004,
        DroneCAN_5  = 1005,
        DroneCAN_6  = 1006,
        DroneCAN_7  = 1007,
        DroneCAN_8  = 1008,
        DroneCAN_9  = 1009,
        DroneCAN_10 = 1010,
        DroneCAN_11 = 1011,
        DroneCAN_12 = 1012,
        DroneCAN_13 = 1013,
        DroneCAN_14 = 1014,
        DroneCAN_15 = 1015,
    };

    AP_Enum<FUNCTION> function;            // relay function
    AP_Int16 pin;                          // gpio pin number
    AP_Enum<DefaultState> default_state;  // default state
    AP_Int8 inverted;                       // inverted signal
};
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  #pragma once

#include <AP_HAL/AP_HAL_Boards.h>

#ifndef AP_RELAY_ENABLED
#define AP_RELAY_ENABLED 1
#endif

#define AP_RELAY_DRONECAN_ENABLED AP_RELAY_ENABLED && HAL_ENABLE_DRONECAN_DRIVERS && !defined(HAL_BUILD_AP_PERIPH)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                