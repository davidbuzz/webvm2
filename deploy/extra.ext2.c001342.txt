VENTOUT"      	:	15,
	"PD2:LCD_COM7"      	:	11,
	"PD2:LCD_SEG31"     	:	11,
	"PD2:LCD_SEG43"     	:	11,
	"PD2:SDMMC1_CMD"    	:	12,
	"PD2:SYS_TRACED2"   	:	0,
	"PD2:TIM3_ETR"      	:	2,
	"PD2:TSC_SYNC"      	:	9,
	"PD2:UART5_RX"      	:	8,
	"PD2:USART3_DE"     	:	7,
	"PD2:USART3_RTS"    	:	7,
	"PD3:DCMI_D5"       	:	4,
	"PD3:DFSDM1_DATIN0" 	:	6,
	"PD3:EVENTOUT"      	:	15,
	"PD3:FMC_CLK"       	:	12,
	"PD3:QUADSPI_BK2_NCS"	:	10,
	"PD3:SPI2_MISO"     	:	5,
	"PD3:SPI2_SCK"      	:	3,
	"PD3:USART2_CTS"    	:	7,
	"PD4:DFSDM1_CKIN0"  	:	6,
	"PD4:EVENTOUT"      	:	15,
	"PD4:FMC_NOE"       	:	12,
	"PD4:QUADSPI_BK2_IO0"	:	10,
	"PD4:SPI2_MOSI"     	:	5,
	"PD4:USART2_DE"     	:	7,
	"PD4:USART2_RTS"    	:	7,
	"PD5:EVENTOUT"      	:	15,
	"PD5:FMC_NWE"       	:	12,
	"PD5:QUADSPI_BK2_IO1"	:	10,
	"PD5:USART2_TX"     	:	7,
	"PD6:DCMI_D10"      	:	4,
	"PD6:DFSDM1_DATIN1" 	:	6,
	"PD6:EVENTOUT"      	:	15,
	"PD6:FMC_NWAIT"     	:	12,
	"PD6:QUADSPI_BK2_IO1"	:	5,
	"PD6:QUADSPI_BK2_IO2"	:	10,
	"PD6:SAI1_SD_A"     	:	13,
	"PD6:USART2_RX"     	:	7,
	"PD7:DFSDM1_CKIN1"  	:	6,
	"PD7:EVENTOUT"      	:	15,
	"PD7:FMC_NE1"       	:	12,
	"PD7:QUADSPI_BK2_IO3"	:	10,
	"PD7:USART2_CK"     	:	7,
	"PD8:DCMI_HSYNC"    	:	10,
	"PD8:EVENTOUT"      	:	15,
	"PD8:FMC_D13"       	:	12,
	"PD8:FMC_DA13"      	:	12,
	"PD8:LCD_SEG28"     	:	11,
	"PD8:USART3_TX"     	:	7,
	"PD9:DCMI_PIXCLK"   	:	10,
	"PD9:EVENTOUT"      	:	15,
	"PD9:FMC_D14"       	:	12,
	"PD9:FMC_DA14"      	:	12,
	"PD9:LCD_SEG29"     	:	11,
	"PD9:SAI2_MCLK_A"   	:	13,
	"PD9:USART3_RX"     	:	7,
	"PD10:EVENTOUT"     	:	15,
	"PD10:FMC_D15"      	:	12,
	"PD10:FMC_DA15"     	:	12,
	"PD10:LCD_SEG30"    	:	11,
	"PD10:SAI2_SCK_A"   	:	13,
	"PD10:TSC_G6_IO1"   	:	9,
	"PD10:USART3_CK"    	:	7,
	"PD11:EVENTOUT"     	:	15,
	"PD11:FMC_A16"      	:	12,
	"PD11:I2C4_SMBA"    	:	4,
	"PD11:LCD_SEG31"    	:	11,
	"PD11:LPTIM2_ETR"   	:	14,
	"PD11:SAI2_SD_A"    	:	13,
	"PD11:TSC_G6_IO2"   	:	9,
	"PD11:USART3_CTS"   	:	7,
	"PD12:EVENTOUT"     	:	15,
	"PD12:FMC_A17"      	:	12,
	"PD12:I2C4_SCL"     	:	4,
	"PD12:LCD_SEG32"    	:	11,
	"PD12:LPTIM2_IN1"   	:	14,
	"PD12:SAI2_FS_A"    	:	13,
	"PD12:TIM4_CH1"     	:	2,
	"PD12:TSC_G6_IO3"   	:	9,
	"PD12:USART3_DE"    	:	7,
	"PD12:USART3_RTS"   	:	7,
	"PD13:EVENTOUT"     	:	15,
	"PD13:FMC_A18"      	:	12,
	"PD13:I2C4_SDA"     	:	4,
	"PD13:LCD_SEG33"    	:	11,
	"PD13:LPTIM2_OUT"   	:	14,
	"PD13:TIM4_CH2"     	:	2,
	"PD13:TSC_G6_IO4"   	:	9,
	"PD14:EVENTOUT"     	:	15,
	"PD14:FMC_D0"       	:	12,
	"PD14:FMC_DA0"      	:	12,
	"PD14:LCD_SEG34"    	:	11,
	"PD14:TIM4_CH3"     	:	2,
	"PD15:EVENTOUT"     	:	15,
	"PD15:FMC_D1"       	:	12,
	"PD15:FMC_DA1"      	:	12,
	"PD15:LCD_SEG35"    	:	11,
	"PD15:TIM4_CH4"     	:	2,
	"PE0:DCMI_D2"       	:	10,
	"PE0:EVENTOUT"      	:	15,
	"PE0:FMC_NBL0"      	:	12,
	"PE0:LCD_SEG36"     	:	11,
	"PE0:TIM16_CH1"     	:	14,
	"PE0:TIM4_ETR"      	:	2,
	"PE1:DCMI_D3"       	:	10,
	"PE1:EVENTOUT"      	:	15,
	"PE1:FMC_NBL1"      	:	12,
	"PE1:LCD_SEG37"     	:	11,
	"PE1:TIM17_CH1"     	:	14,
	"PE2:EVENTOUT"      	:	15,
	"PE2:FMC_A23"       	:	12,
	"PE2:LCD_SEG38"     	:	11,
	"PE2:SAI1_MCLK_A"   	:	13,
	"PE2:SYS_TRACECLK"  	:	0,
	"PE2:TIM3_ETR"      	:	2,
	"PE2:TSC_G7_IO1"    	:	9,
	"PE3:EVENTOUT"      	:	15,
	"PE3:FMC_A19"       	:	12,
	"PE3:LCD_SEG39"     	:	11,
	"PE3:SAI1_SD_B"     	:	13,
	"PE3:SYS_TRACED0"   	:	0,
	"PE3:TIM3_CH1"      	:	2,
	"PE3:TSC_G7_IO2"    	:	9,
	"PE4:DCMI_D4"       	:	10,
	"PE4:DFSDM1_DATIN3" 	:	6,
	"PE4:EVENTOUT"      	:	15,
	"PE4:FMC_A20"       	:	12,
	"PE4:SAI1_FS_A"     	:	13,
	"PE4:SYS_TRACED1"   	:	0,
	"PE4:TIM3_CH2"      	:	2,
	"PE4:TSC_G7_IO3"    	:	9,
	"PE5:DCMI_D6"       	:	10,
	"PE5:DFSDM1_CKIN3"  	:	6,
	"PE5:EVENTOUT"      	:	15,
	"PE5:FMC_A21"       	:	12,
	"PE5:SAI1_SCK_A"    	:	13,
	"PE5:SYS_TRACED2"   	:	0,
	"PE5:TIM3_CH3"      	:	2,
	"PE5:TSC_G7_IO4"    	:	9,
	"PE6:DCMI_D7"       	:	10,
	"PE6:EVENTOUT"      	:	15,
	"PE6:FMC_A22"       	:	12,
	"PE6:SAI1_SD_A"     	:	13,
	"PE6:SYS_TRACED3"   	:	0,
	"PE6:TIM3_CH4"      	:	2,
	"PE7:DFSDM1_DATIN2" 	:	6,
	"PE7:EVENTOUT"      	:	15,
	"PE7:FMC_D4"        	:	12,
	"PE7:FMC_DA4"       	:	12,
	"PE7:SAI1_SD_B"     	:	13,
	"PE7:TIM1_ETR"      	:	1,
	"PE8:DFSDM1_CKIN2"  	:	6,
	"PE8:EVENTOUT"      	:	15,
	"PE8:FMC_D5"        	:	12,
	"PE8:FMC_DA5"       	:	12,
	"PE8:SAI1_SCK_B"    	:	13,
	"PE8:TIM1_CH1N"     	:	1,
	"PE9:DFSDM1_CKOUT"  	:	6,
	"PE9:EVENTOUT"      	:	15,
	"PE9:FMC_D6"        	:	12,
	"PE9:FMC_DA6"       	:	12,
	"PE9:SAI1_FS_B"     	:	13,
	"PE9:TIM1_CH1"      	:	1,
	"PE10:DFSDM1_DATIN4"	:	6,
	"PE10:EVENTOUT"     	:	15,
	"PE10:FMC_D7"       	:	12,
	"PE10:FMC_DA7"      	:	12,
	"PE10:QUADSPI_CLK"  	:	10,
	"PE10:SAI1_MCLK_B"  	:	13,
	"PE10:TIM1_CH2N"    	:	1,
	"PE10:TSC_G5_IO1"   	:	9,
	"PE11:DFSDM1_CKIN4" 	:	6,
	"PE11:EVENTOUT"     	:	15,
	"PE11:FMC_D8"       	:	12,
	"PE11:FMC_DA8"      	:	12,
	"PE11:QUADSPI_BK1_NCS"	:	10,
	"PE11:TIM1_CH2"     	:	1,
	"PE11:TSC_G5_IO2"   	:	9,
	"PE12:DFSDM1_DATIN5"	:	6,
	"PE12:EVENTOUT"     	:	15,
	"PE12:FMC_D9"       	:	12,
	"PE12:FMC_DA9"      	:	12,
	"PE12:QUADSPI_BK1_IO0"	:	10,
	"PE12:SPI1_NSS"     	:	5,
	"PE12:TIM1_CH3N"    	:	1,
	"PE12:TSC_G5_IO3"   	:	9,
	"PE13:DFSDM1_CKIN5" 	:	6,
	"PE13:EVENTOUT"     	:	15,
	"PE13:FMC_D10"      	:	12,
	"PE13:FMC_DA10"     	:	12,
	"PE13:QUADSPI_BK1_IO1"	:	10,
	"PE13:SPI1_SCK"     	:	5,
	"PE13:TIM1_CH3"     	:	1,
	"PE13:TSC_G5_IO4"   	:	9,
	"PE14:EVENTOUT"     	:	15,
	"PE14:FMC_D11"      	:	12,
	"PE14:FMC_DA11"     	:	12,
	"PE14:QUADSPI_BK1_IO2"	:	10,
	"PE14:SPI1_MISO"    	:	5,
	"PE14:TIM1_BKIN2"   	:	2,
	"PE14:TIM1_BKIN2_COMP2"	:	3,
	"PE14:TIM1_CH4"     	:	1,
	"PE15:EVENTOUT"     	:	15,
	"PE15:FMC_D12"      	:	12,
	"PE15:FMC_DA12"     	:	12,
	"PE15:QUADSPI_BK1_IO3"	:	10,
	"PE15:SPI1_MOSI"    	:	5,
	"PE15:TIM1_BKIN"    	:	1,
	"PE15:TIM1_BKIN_COMP1"	:	3,
	"PF0:EVENTOUT"      	:	15,
	"PF0:FMC_A0"        	:	12,
	"PF0:I2C2_SDA"      	:	4,
	"PF1:EVENTOUT"      	:	15,
	"PF1:FMC_A1"        	:	12,
	"PF1:I2C2_SCL"      	:	4,
	"PF2:EVENTOUT"      	:	15,
	"PF2:FMC_A2"        	:	12,
	"PF2:I2C2_SMBA"     	:	4,
	"PF3:EVENTOUT"      	:	15,
	"PF3:FMC_A3"        	:	12,
	"PF4:EVENTOUT"      	:	15,
	"PF4:FMC_A4"        	:	12,
	"PF5:EVENTOUT"      	:	15,
	"PF5:FMC_A5"        	:	12,
	"PF6:EVENTOUT"      	:	15,
	"PF6:QUADSPI_BK1_IO3"	:	10,
	"PF6:SAI1_SD_B"     	:	13,
	"PF6:TIM5_CH1"      	:	2,
	"PF6:TIM5_ETR"      	:	1,
	"PF7:EVENTOUT"      	:	15,
	"PF7:QUADSPI_BK1_IO2"	:	10,
	"PF7:SAI1_MCLK_B"   	:	13,
	"PF7:TIM5_CH2"      	:	2,
	"PF8:EVENTOUT"      	:	15,
	"PF8:QUADSPI_BK1_IO0"	:	10,
	"PF8:SAI1_SCK_B"    	:	13,
	"PF8:TIM5_CH3"      	:	2,
	"PF9:EVENTOUT"      	:	15,
	"PF9:QUADSPI_BK1_IO1"	:	10,
	"PF9:SAI1_FS_B"     	:	13,
	"PF9:TIM15_CH1"     	:	14,
	"PF9:TIM5_CH4"      	:	2,
	"PF10:DCMI_D11"     	:	10,
	"PF10:EVENTOUT"     	:	15,
	"PF10:QUADSPI_CLK"  	:	3,
	"PF10:TIM15_CH2"    	:	14,
	"PF11:DCMI_D12"     	:	10,
	"PF11:EVENTOUT"     	:	15,
	"PF12:EVENTOUT"     	:	15,
	"PF12:FMC_A6"       	:	12,
	"PF13:DFSDM1_DATIN6"	:	6,
	"PF13:EVENTOUT"     	:	15,
	"PF13:FMC_A7"       	:	12,
	"PF13:I2C4_SMBA"    	:	4,
	"PF14:DFSDM1_CKIN6" 	:	6,
	"PF14:EVENTOUT"     	:	15,
	"PF14:FMC_A8"       	:	12,
	"PF14:I2C4_SCL"     	:	4,
	"PF14:TSC_G8_IO1"   	:	9,
	"PF15:EVENTOUT"     	:	15,
	"PF15:FMC_A9"       	:	12,
	"PF15:I2C4_SDA"     	:	4,
	"PF15:TSC_G8_IO2"   	:	9,
	"PG0:EVENTOUT"      	:	15,
	"PG0:FMC_A10"       	:	12,
	"PG0:TSC_G8_IO3"    	:	9,
	"PG1:EVENTOUT"      	:	15,
	"PG1:FMC_A11"       	:	12,
	"PG1:TSC_G8_IO4"    	:	9,
	"PG2:EVENTOUT"      	:	15,
	"PG2:FMC_A12"       	:	12,
	"PG2:SAI2_SCK_B"    	:	13,
	"PG2:SPI1_SCK"      	:	5,
	"PG3:EVENTOUT"      	:	15,
	"PG3:FMC_A13"       	:	12,
	"PG3:SAI2_FS_B"     	:	13,
	"PG3:SPI1_MISO"     	:	5,
	"PG4:EVENTOUT"      	:	15,
	"PG4:FMC_A14"       	:	12,
	"PG4:SAI2_MCLK_B"   	:	13,
	"PG4:SPI1_MOSI"     	:	5,
	"PG5:EVENTOUT"      	:	15,
	"PG5:FMC_A15"       	:	12,
	"PG5:LPUART1_CTS"   	:	8,
	"PG5:SAI2_SD_B"     	:	13,
	"PG5:SPI1_NSS"      	:	5,
	"PG6:EVENTOUT"      	:	15,
	"PG6:I2C3_SMBA"     	:	4,
	"PG6:LPUART1_DE"    	:	8,
	"PG6:LPUART1_RTS"   	:	8,
	"PG7:EVENTOUT"      	:	15,
	"PG7:FMC_INT"       	:	12,
	"PG7:I2C3_SCL"      	:	4,
	"PG7:LPUART1_TX"    	:	8,
	"PG7:SAI1_MCLK_A"   	:	13,
	"PG8:EVENTOUT"      	:	15,
	"PG8:I2C3_SDA"      	:	4,
	"PG8:LPUART1_RX"    	:	8,
	"PG9:EVENTOUT"      	:	15,
	"PG9:FMC_NCE"       	:	12,
	"PG9:FMC_NE2"       	:	12,
	"PG9:SAI2_SCK_A"    	:	13,
	"PG9:SPI3_SCK"      	:	6,
	"PG9:TIM15_CH1N"    	:	14,
	"PG9:USART1_TX"     	:	7,
	"PG10:EVENTOUT"     	:	15,
	"PG10:FMC_NE3"      	:	12,
	"PG10:LPTIM1_IN1"   	:	1,
	"PG10:SAI2_FS_A"    	:	13,
	"PG10:SPI3_MISO"    	:	6,
	"PG10:TIM15_CH1"    	:	14,
	"PG10:USART1_RX"    	:	7,
	"PG11:EVENTOUT"     	:	15,
	"PG11:LPTIM1_IN2"   	:	1,
	"PG11:SAI2_MCLK_A"  	:	13,
	"PG11:SPI3_MOSI"    	:	6,
	"PG11:TIM15_CH2"    	:	14,
	"PG11:USART1_CTS"   	:	7,
	"PG12:EVENTOUT"     	:	15,
	"PG12:FMC_NE4"      	:	12,
	"PG12:LPTIM1_ETR"   	:	1,
	"PG12:SAI2_SD_A"    	:	13,
	"PG12:SPI3_NSS"     	:	6,
	"PG12:USART1_DE"    	:	7,
	"PG12:USART1_RTS"   	:	7,
	"PG13:EVENTOUT"     	:	15,
	"PG13:FMC_A24"      	:	12,
	"PG13:I2C1_SDA"     	:	4,
	"PG13:USART1_CK"    	:	7,
	"PG14:EVENTOUT"     	:	15,
	"PG14:FMC_A25"      	:	12,
	"PG14:I2C1_SCL"     	:	4,
	"PG15:DCMI_D13"     	:	10,
	"PG15:EVENTOUT"     	:	15,
	"PG15:I2C1_SMBA"    	:	4,
	"PG15:LPTIM1_OUT"   	:	1,
	"PH0:EVENTOUT"      	:	15,
	"PH1:EVENTOUT"      	:	15,
	"PH3:EVENTOUT"      	:	15,
}

ADC1_map = {
	# format is PIN : ADC1_CHAN
    "PA0"	:	5,
    "PA1"	:	6,
    "PA2"	:	7,
    "PA3"	:	8,
    "PA4"	:	9,
    "PA5"	:	10,
    "PA6"	:	11,
    "PA7"	:	12,
    "PC4"   :   13,
    "PC5"   :   14,
    "PB0"   :   15,
    "PB1"   :   16,
    "PC0"   :   1,
    "PC1"   :   2,
    "PC2"   :   3,
    "PC3"   :   4,
}
    
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 #!/usr/bin/env python
'''
these tables are generated from the STM32 datasheet stm32l4R5ai.pdf
'''

# additional build information for ChibiOS
build = {
    "CHIBIOS_STARTUP_MK"  : "os/common/startup/ARMCMx/compilers/GCC/mk/startup_stm32l4xx.mk",
    "CHIBIOS_PLATFORM_MK" : "os/hal/ports/STM32/STM32L4xx+/platform.mk"
    }

pincount = {
    'A': 16,
    'B': 16,
    'C': 16,
    'D': 16,
    'E': 16,
    'F': 16,
    'G': 16,
    'H': 16,
    'I': 12,
    'J': 0,
    'K': 0
}


# MCU parameters
mcu = {
    # ram map, as list of (address, size-kb, flags)
    # flags of 1 means DMA-capable
    # flags of 2 means faster memory for CPU intensive work
    'RAM_MAP' : [
        # we treat SRAM1/SRAM2/SRAM3 as a single region for simplicifty. SRAM2 is parity checked
        # and is mapped at both 0x20030000 and at 0x10000000
        (0x20000000, 640, 1), # SRAM1/SRAM2/SRAM3
    ],

    'EXPECTED_CLOCK' : 120000000,

    'DEFINES' : {
        'STM32L4PLUS' : '1',
    }
}

# no DMA map as we will dynamically allocate DMA channels using the DMAMUX
DMA_Map = None

AltFunction_map = {
	# format is PIN:FUNCTION : AFNUM
	"PA0:EVENTOUT"      	:	15,
	"PA0:SAI1_EXTCLK"   	:	13,
	"PA0:TIM2_CH1"      	:	1,
	"PA0:TIM2_ETR"      	:	14,
	"PA0:TIM5_CH1"      	:	2,
	"PA0:TIM8_ETR"      	:	3,
	"PA0:UART4_TX"      	:	8,
	"PA0:USART2_CTS"    	:	7,
	"PA0:USART2_NSS"    	:	7,
	"PA1:EVENTOUT"      	:	15,
	"PA1:I2C1_SMBA"     	:	4,
	"PA1:OCTOSPIM_P1_DQS"	:	10,
	"PA1:SPI1_SCK"      	:	5,
	"PA1:TIM15_CH1N"    	:	14,
	"PA1:TIM2_CH2"      	:	1,
	"PA1:TIM5_CH2"      	:	2,
	"PA1:UART4_RX"      	:	8,
	"PA1:USART2_DE"     	:	7,
	"PA1:USART2_RTS"    	:	7,
	"PA2:EVENTOUT"      	:	15,
	"PA2:LPUART1_TX"    	:	8,
	"PA2:OCTOSPIM_P1_NCS"	:	10,
	"PA2:SAI2_EXTCLK"   	:	13,
	"PA2:TIM15_CH1"     	:	14,
	"PA2:TIM2_CH3"      	:	1,
	"PA2:TIM5_CH3"      	:	2,
	"PA2:USART2_TX"     	:	7,
	"PA3:EVENTOUT"      	:	15,
	"PA3:LPUART1_RX"    	:	8,
	"PA3:OCTOSPIM_P1_CLK"	:	10,
	"PA3:SAI1_CK1"      	:	3,
	"PA3:SAI1_MCLK_A"   	:	13,
	"PA3:TIM15_CH2"     	:	14,
	"PA3:TIM2_CH4"      	:	1,
	"PA3:TIM5_CH4"      	:	2,
	"PA3:USART2_RX"     	:	7,
	"PA4:DCMI_HSYNC"    	:	10,
	"PA4:EVENTOUT"      	:	15,
	"PA4:LPTIM2_OUT"    	:	14,
	"PA4:OCTOSPIM_P1_NCS"	:	3,
	"PA4:SAI1_FS_B"     	:	13,
	"PA4:SPI1_NSS"      	:	5,
	"PA4:SPI3_NSS"      	:	6,
	"PA4:USART2_CK"     	:	7,
	"PA5:EVENTOUT"      	:	15,
	"PA5:LPTIM2_ETR"    	:	14,
	"PA5:SPI1_SCK"      	:	5,
	"PA5:TIM2_CH1"      	:	1,
	"PA5:TIM2_ETR"      	:	2,
	"PA5:TIM8_CH1N"     	:	3,
	"PA6:DCMI_PIXCLK"   	:	4,
	"PA6:EVENTOUT"      	:	15,
	"PA6:LPUART1_CTS"   	:	8,
	"PA6:OCTOSPIM_P1_IO3"	:	10,
	"PA6:SPI1_MISO"     	:	5,
	"PA6:TIM16_CH1"     	:	14,
	"PA6:TIM1_BKIN"     	:	12,
	"PA6:TIM3_CH1"      	:	2,
	"PA6:TIM8_BKIN"     	:	13,
	"PA6:USART3_CTS"    	:	7,
	"PA6:USART3_NSS"    	:	7,
	"PA7:EVENTOUT"      	:	15,
	"PA7:I2C3_SCL"      	:	4,
	"PA7:OCTOSPIM_P1_IO2"	:	10,
	"PA7:SPI1_MOSI"     	:	5,
	"PA7:TIM17_CH1"     	:	14,
	"PA7:TIM1_CH1N"     	:	1,
	"PA7:TIM3_CH2"      	:	2,
	"PA7:TIM8_CH1N"     	:	3,
	"PA8:EVENTOUT"      	:	15,
	"PA8:LPTIM2_OUT"    	:	14,
	"PA8:RCC_MCO"       	:	0,
	"PA8:SAI1_CK2"      	:	3,
	"PA8:SAI1_SCK_A"    	:	13,
	"PA8:TIM1_CH1"      	:	1,
	"PA8:USART1_CK"     	:	7,
	"PA8:USB_OTG_FS_SOF"	:	10,
	"PA9:DCMI_D0"       	:	5,
	"PA9:EVENTOUT"      	:	15,
	"PA9:SAI1_FS_A"     	:	13,
	"PA9:SPI2_SCK"      	:	3,
	"PA9:TIM15_BKIN"    	:	14,
	"PA9:TIM1_CH2"      	:	1,
	"PA9:USART1_TX"     	:	7,
	"PA10:DCMI_D1"      	:	5,
	"PA10:EVENTOUT"     	:	15,
	"PA10:SAI1_D1"      	:	3,
	"PA10:SAI1_SD_A"    	:	13,
	"PA10:TIM17_BKIN"   	:	14,
	"PA10:TIM1_CH3"     	:	1,
	"PA10:USART1_RX"    	:	7,
	"PA10:USB_OTG_FS_ID"	:	10,
	"PA11:CAN1_RX"      	:	9,
	"PA11:EVENTOUT"     	:	15,
	"PA11:SPI1_MISO"    	:	5,
	"PA11:TIM1_BKIN2"   	:	12,
	"PA11:TIM1_CH4"     	:	1,
	"PA11:USART1_CTS"   	:	7,
	"PA11:USART1_NSS"   	:	7,
	"PA11:USB_OTG_FS_DM"	:	10,
	"PA12:CAN1_TX"      	:	9,
	"PA12:EVENTOUT"     	:	15,
	"PA12:SPI1_MOSI"    	:	5,
	"PA12:TIM1_ETR"     	:	1,
	"PA12:USART1_DE"    	:	7,
	"PA12:USART1_RTS"   	:	7,
	"PA12:USB_OTG_FS_DP"	:	10,
	"PA13:EVENTOUT"     	:	15,
	"PA13:IR_OUT"       	:	1,
	"PA13:SAI1_SD_B"    	:	13,
	"PA13:JTMS-SWDIO"	:	0,
	"PA13:USB_OTG_FS_NOE"	:	10,
	"PA14:EVENTOUT"     	:	15,
	"PA14:I2C1_SMBA"    	:	4,
	"PA14:I2C4_SMBA"    	:	5,
	"PA14:LPTIM1_OUT"   	:	1,
	"PA14:SAI1_FS_B"    	:	13,
	"PA14:JTCK-SWCLK"	:	0,
	"PA14:USB_OTG_FS_SOF"	:	10,
	"PA15:EVENTOUT"     	:	15,
	"PA15:SAI2_FS_B"    	:	13,
	"PA15:SPI1_NSS"     	:	5,
	"PA15:SPI3_NSS"     	:	6,
	"PA15:JTDI"     	:	0,
	"PA15:TIM2_CH1"     	:	1,
	"PA15:TIM2_ETR"     	:	2,
	"PA15:TSC_G3_IO1"   	:	9,
	"PA15:UART4_DE"     	:	8,
	"PA15:UART4_RTS"    	:	8,
	"PA15:USART2_RX"    	:	3,
	"PA15:USART3_DE"    	:	7,
	"PA15:USART3_RTS"   	:	7,
	"PB0:COMP1_OUT"     	:	12,
	"PB0:EVENTOUT"      	:	15,
	"PB0:OCTOSPIM_P1_IO1"	:	10,
	"PB0:SAI1_EXTCLK"   	:	13,
	"PB0:SPI1_NSS"      	:	5,
	"PB0:TIM1_CH2N"     	:	1,
	"PB0:TIM3_CH3"      	:	2,
	"PB0:TIM8_CH2N"     	:	3,
	"PB0:USART3_CK"     	:	7,
	"PB1:DFSDM1_DATIN0" 	:	6,
	"PB1:EVENTOUT"      	:	15,
	"PB1:LPTIM2_IN1"    	:	14,
	"PB1:LPUART1_DE"    	:	8,
	"PB1:LPUART1_RTS"   	:	8,
	"PB1:OCTOSPIM_P1_IO0"	:	10,
	"PB1:TIM1_CH3N"     	:	1,
	"PB1:TIM3_CH4"      	:	2,
	"PB1:TIM8_CH3N"     	:	3,
	"PB1:USART3_DE"     	:	7,
	"PB1:USART3_RTS"    	:	7,
	"PB2:DFSDM1_CKIN0"  	:	6,
	"PB2:EVENTOUT"      	:	15,
	"PB2:I2C3_SMBA"     	:	4,
	"PB2:LPTIM1_OUT"    	:	1,
	"PB2:OCTOSPIM_P1_DQS"	:	10,
	"PB2:RTC_OUT_ALARM" 	:	0,
	"PB2:RTC_OUT_CALIB" 	:	0,
	"PB3:CRS_SYNC"      	:	10,
	"PB3:EVENTOUT"      	:	15,
	"PB3:SAI1_SCK_B"    	:	13,
	"PB3:SPI1_SCK"      	:	5,
	"PB3:SPI3_SCK"      	:	6,
	"PB3:JTDO-SWO"  	:	0,
	"PB3:TIM2_CH2"      	:	1,
	"PB3:USART1_DE"     	:	7,
	"PB3:USART1_RTS"    	:	7,
	"PB4:DCMI_D12"      	:	10,
	"PB4:EVENTOUT"      	:	15,
	"PB4:I2C3_SDA"      	:	4,
	"PB4:SAI1_MCLK_B"   	:	13,
	"PB4:SPI1_MISO"     	:	5,
	"PB4:SPI3_MISO"     	:	6,
	"PB4:JTRST"     	:	0,
	"PB4:TIM17_BKIN"    	:	14,
	"PB4:TIM3_CH1"      	:	2,
	"PB4:TSC_G2_IO1"    	:	9,
	"PB4:UART5_DE"      	:	8,
	"PB4:UART5_RTS"     	:	8,
	"PB4:USART1_CTS"    	:	7,
	"PB4:USART1_NSS"    	:	7,
	"PB5:COMP2_OUT"     	:	12,
	"PB5:DCMI_D10"      	:	10,
	"PB5:EVENTOUT"      	:	15,
	"PB5:I2C1_SMBA"     	:	4,
	"PB5:LPTIM1_IN1"    	:	1,
	"PB5:SAI1_SD_B"     	:	13,
	"PB5:SPI1_MOSI"     	:	5,
	"PB5:SPI3_MOSI"     	:	6,
	"PB5:TIM16_BKIN"    	:	14,
	"PB5:TIM3_CH2"      	:	2,
	"PB5:TSC_G2_IO2"    	:	9,
	"PB5:UART5_CTS"     	:	8,
	"PB5:USART1_CK"     	:	7,
	"PB6:DCMI_D5"       	:	10,
	"PB6:DFSDM1_DATIN5" 	:	6,
	"PB6:EVENTOUT"      	:	15,
	"PB6:I2C1_SCL"      	:	4,
	"PB6:I2C4_SCL"      	:	5,
	"PB6:LPTIM1_ETR"    	:	1,
	"PB6:SAI1_FS_B"     	:	13,
	"PB6:TIM16_CH1N"    	:	14,
	"PB6:TIM4_CH1"      	:	2,
	"PB6:TIM8_BKIN2"    	:	12,
	"PB6:TSC_G2_IO3"    	:	9,
	"PB6:USART1_TX"     	:	7,
	"PB7:DCMI_VSYNC"    	:	10,
	"PB7:DFSDM1_CKIN5"  	:	6,
	"PB7:EVENTOUT"      	:	15,
	"PB7:FMC_NL"        	:	12,
	"PB7:I2C1_SDA"      	:	4,
	"PB7:I2C4_SDA"      	:	5,
	"PB7:LPTIM1_IN2"    	:	1,
	"PB7:TIM17_CH1N"    	:	14,
	"PB7:TIM4_CH2"      	:	2,
	"PB7:TIM8_BKIN"     	:	13,
	"PB7:TSC_G2_IO4"    	:	9,
	"PB7:UART4_CTS"     	:	8,
	"PB7:USART1_RX"     	:	7,
	"PB8:CAN1_RX"       	:	9,
	"PB8:DCMI_D6"       	:	10,
	"PB8:DFSDM1_CKOUT"  	:	5,
	"PB8:DFSDM1_DATIN6" 	:	6,
	"PB8:EVENTOUT"      	:	15,
	"PB8:I2C1_SCL"      	:	4,
	"PB8:SAI1_CK1"      	:	3,
	"PB8:SAI1_MCLK_A"   	:	13,
	"PB8:SDMMC1_CKIN"   	:	8,
	"PB8:SDMMC1_D4"     	:	12,
	"PB8:TIM16_CH1"     	:	14,
	"PB8:TIM4_CH3"      	:	2,
	"PB9:CAN1_TX"       	:	9,
	"PB9:DCMI_D7"       	:	10,
	"PB9:DFSDM1_CKIN6"  	:	6,
	"PB9:EVENTOUT"      	:	15,
	"PB9:I2C1_SDA"      	:	4,
	"PB9:IR_OUT"        	:	1,
	"PB9:SAI1_D2"       	:	3,
	"PB9:SAI1_FS_A"     	:	13,
	"PB9:SDMMC1_CDIR"   	:	8,
	"PB9:SDMMC1_D5"     	:	12,
	"PB9:SPI2_NSS"      	:	5,
	"PB9:TIM17_CH1"     	:	14,
	"PB9:TIM4_CH4"      	:	2,
	"PB10:COMP1_OUT"    	:	12,
	"PB10:DFSDM1_DATIN7"	:	6,
	"PB10:EVENTOUT"     	:	15,
	"PB10:I2C2_SCL"     	:	4,
	"PB10:I2C4_SCL"     	:	3,
	"PB10:LPUART1_RX"   	:	8,
	"PB10:OCTOSPIM_P1_CLK"	:	10,
	"PB10:SAI1_SCK_A"   	:	13,
	"PB10:SPI2_SCK"     	:	5,
	"PB10:TIM2_CH3"     	:	1,
	"PB10:TSC_SYNC"     	:	9,
	"PB10:USART3_TX"    	:	7,
	"PB11:COMP2_OUT"    	:	12,
	"PB11:DFSDM1_CKIN7" 	:	6,
	"PB11:EVENTOUT"     	:	15,
	"PB11:I2C2_SDA"     	:	4,
	"PB11:I2C4_SDA"     	:	3,
	"PB11:LPUART1_TX"   	:	8,
	"PB11:OCTOSPIM_P1_NCS"	:	10,
	"PB11:TIM2_CH4"     	:	1,
	"PB11:USART3_RX"    	:	7,
	"PB12:DFSDM1_DATIN1"	:	6,
	"PB12:EVENTOUT"     	:	15,
	"PB12:I2C2_SMBA"    	:	4,
	"PB12:LPUART1_DE"   	:	8,
	"PB12:LPUART1_RTS"  	:	8,
	"PB12:SAI2_FS_A"    	:	13,
	"PB12:SPI2_NSS"     	:	5,
	"PB12:TIM15_BKIN"   	:	14,
	"PB12:TIM1_BKIN"    	:	3,
	"PB12:TSC_G1_IO1"   	:	9,
	"PB12:USART3_CK"    	:	7,
	"PB13:DFSDM1_CKIN1" 	:	6,
	"PB13:EVENTOUT"     	:	15,
	"PB13:I2C2_SCL"     	:	4,
	"PB13:LPUART1_CTS"  	:	8,
	"PB13:SAI2_SCK_A"   	:	13,
	"PB13:SPI2_SCK"     	:	5,
	"PB13:TIM15_CH1N"   	:	14,
	"PB13:TIM1_CH1N"    	:	1,
	"PB13:TSC_G1_IO2"   	:	9,
	"PB13:USART3_CTS"   	:	7,
	"PB13:USART3_NSS"   	:	7,
	"PB14:DFSDM1_DATIN2"	:	6,
	"PB14:EVENTOUT"     	:	15,
	"PB14:I2C2_SDA"     	:	4,
	"PB14:SAI2_MCLK_A"  	:	13,
	"PB14:SPI2_MISO"    	:	5,
	"PB14:TIM15_CH1"    	:	14,
	"PB14:TIM1_CH2N"    	:	1,
	"PB14:TIM8_CH2N"    	:	3,
	"PB14:TSC_G1_IO3"   	:	9,
	"PB14:USART3_DE"    	:	7,
	"PB14:USART3_RTS"   	:	7,
	"PB15:DFSDM1_CKIN2" 	:	6,
	"PB15:EVENTOUT"     	:	15,
	"PB15:RTC_REFIN"    	:	0,
	"PB15:SAI2_SD_A"    	:	13,
	"PB15:SPI2_MOSI"    	:	5,
	"PB15:TIM15_CH2"    	:	14,
	"PB15:TIM1_CH3N"    	:	1,
	"PB15:TIM8_CH3N"    	:	3,
	"PB15:TSC_G1_IO4"   	:	9,
	"PC0:DFSDM1_DATIN4" 	:	6,
	"PC0:EVENTOUT"      	:	15,
	"PC0:I2C3_SCL"      	:	4,
	"PC0:LPTIM1_IN1"    	:	1,
	"PC0:LPTIM2_IN1"    	:	14,
	"PC0:LPUART1_RX"    	:	8,
	"PC0:SAI2_FS_A"     	:	13,
	"PC1:DFSDM1_CKIN4"  	:	6,
	"PC1:EVENTOUT"      	:	15,
	"PC1:I2C3_SDA"      	:	4,
	"PC1:LPTIM1_OUT"    	:	1,
	"PC1:LPUART1_TX"    	:	8,
	"PC1:OCTOSPIM_P1_IO4"	:	10,
	"PC1:SAI1_SD_A"     	:	13,
	"PC1:SPI2_MOSI"     	:	3,
	"PC1:TRACED0"   	:	0,
	"PC2:DFSDM1_CKOUT"  	:	6,
	"PC2:EVENTOUT"      	:	15,
	"PC2:LPTIM1_IN2"    	:	1,
	"PC2:OCTOSPIM_P1_IO5"	:	10,
	"PC2:SPI2_MISO"     	:	5,
	"PC3:EVENTOUT"      	:	15,
	"PC3:LPTIM1_ETR"    	:	1,
	"PC3:LPTIM2_ETR"    	:	14,
	"PC3:OCTOSPIM_P1_IO6"	:	10,
	"PC3:SAI1_D1"       	:	3,
	"PC3:SAI1_SD_A"     	:	13,
	"PC3:SPI2_MOSI"     	:	5,
	"PC4:EVENTOUT"      	:	15,
	"PC4:OCTOSPIM_P1_IO7"	:	10,
	"PC4:USART3_TX"     	:	7,
	"PC5:EVENTOUT"      	:	15,
	"PC5:SAI1_D3"       	:	3,
	"PC5:USART3_RX"     	:	7,
	"PC6:DCMI_D0"       	:	10,
	"PC6:DFSDM1_CKIN3"  	:	6,
	"PC6:EVENTOUT"      	:	15,
	"PC6:SAI2_MCLK_A"   	:	13,
	"PC6:SDMMC1_D0DIR"  	:	8,
	"PC6:SDMMC1_D6"     	:	12,
	"PC6:TIM3_CH1"      	:	2,
	"PC6:TIM8_CH1"      	:	3,
	"PC6:TSC_G4_IO1"    	:	9,
	"PC7:DCMI_D1"       	:	10,
	"PC7:DFSDM1_DATIN3" 	:	6,
	"PC7:EVENTOUT"      	:	15,
	"PC7:SAI2_MCLK_B"   	:	13,
	"PC7:SDMMC1_D123DIR"	:	8,
	"PC7:SDMMC1_D7"     	:	12,
	"PC7:TIM3_CH2"      	:	2,
	"PC7:TIM8_CH2"      	:	3,
	"PC7:TSC_G4_IO2"    	:	9,
	"PC8:DCMI_D2"       	:	10,
	"PC8:EVENTOUT"      	:	15,
	"PC8:SDMMC1_D0"     	:	12,
	"PC8:TIM3_CH3"      	:	2,
	"PC8:TIM8_CH3"      	:	3,
	"PC8:TSC_G4_IO3"    	:	9,
	"PC9:DCMI_D3"       	:	4,
	"PC9:EVENTOUT"      	:	15,
	"PC9:I2C3_SDA"      	:	6,
	"PC9:SAI2_EXTCLK"   	:	13,
	"PC9:SDMMC1_D1"     	:	12,
	"PC9:TRACED0"   	:	0,
	"PC9:TIM3_CH4"      	:	2,
	"PC9:TIM8_BKIN2"    	:	14,
	"PC9:TIM8_CH4"      	:	3,
	"PC9:TSC_G4_IO4"    	:	9,
	"PC9:USB_OTG_FS_NOE"	:	10,
	"PC10:DCMI_D8"      	:	10,
	"PC10:EVENTOUT"     	:	15,
	"PC10:SAI2_SCK_B"   	:	13,
	"PC10:SDMMC1_D2"    	:	12,
	"PC10:SPI3_SCK"     	:	6,
	"PC10:TRACED1"  	:	0,
	"PC10:TSC_G3_IO2"   	:	9,
	"PC10:UART4_TX"     	:	8,
	"PC10:USART3_TX"    	:	7,
	"PC11:DCMI_D2"      	:	4,
	"PC11:DCMI_D4"      	:	10,
	"PC11:EVENTOUT"     	:	15,
	"PC11:OCTOSPIM_P1_NCS"	:	5,
	"PC11:SAI2_MCLK_B"  	:	13,
	"PC11:SDMMC1_D3"    	:	12,
	"PC11:SPI3_MISO"    	:	6,
	"PC11:TSC_G3_IO3"   	:	9,
	"PC11:UART4_RX"     	:	8,
	"PC11:USART3_RX"    	:	7,
	"PC12:DCMI_D9"      	:	10,
	"PC12:EVENTOUT"     	:	15,
	"PC12:SAI2_SD_B"    	:	13,
	"PC12:SDMMC1_CK"    	:	12,
	"PC12:SPI3_MOSI"    	:	6,
	"PC12:TRACED3"  	:	0,
	"PC12:TSC_G3_IO4"   	:	9,
	"PC12:UART5_TX"     	:	8,
	"PC12:USART3_CK"    	:	7,
	"PC13:EVENTOUT"     	:	15,
	"PC14:EVENTOUT"     	:	15,
	"PC15:EVENTOUT"     	:	15,
	"PD0:CAN1_RX"       	:	9,
	"PD0:DFSDM1_DATIN7" 	:	6,
	"PD0:EVENTOUT"      	:	15,
	"PD0:FMC_D2"        	:	12,
	"PD0:FMC_DA2"       	:	12,
	"PD0:SPI2_NSS"      	:	5,
	"PD1:CAN1_TX"       	:	9,
	"PD1:DFSDM1_CKIN7"  	:	6,
	"PD1:EVENTOUT"      	:	15,
	"PD1:FMC_D3"        	:	12,
	"PD1:FMC_DA3"       	:	12,
	"PD1:SPI2_SCK"      	:	5,
	"PD2:DCMI_D11"      	:	10,
	"PD2:EVENTOUT"      	:	15,
	"PD2:SDMMC1_CMD"    	:	12,
	"PD2:TRACED2"   	:	0,
	"PD2:TIM3_ETR"      	:	2,
	"PD2:TSC_SYNC"      	:	9,
	"PD2:UART5_RX"      	:	8,
	"PD2:USART3_DE"     	:	7,
	"PD2:USART3_RTS"    	:	7,
	"PD3:DCMI_D5"       	:	4,
	"PD3:DFSDM1_DATIN0" 	:	6,
	"PD3:EVENTOUT"      	:	15,
	"PD3:FMC_CLK"       	:	12,
	"PD3:OCTOSPIM_P2_NCS"	:	10,
	"PD3:SPI2_MISO"     	:	5,
	"PD3:SPI2_SCK"      	:	3,
	"PD3:USART2_CTS"    	:	7,
	"PD3:USART2_NSS"    	:	7,
	"PD4:DFSDM1_CKIN0"  	:	6,
	"PD4:EVENTOUT"      	:	15,
	"PD4:FMC_NOE"       	:	12,
	"PD4:OCTOSPIM_P1_IO4"	:	10,
	"PD4:SPI2_MOSI"     	:	5,
	"PD4:USART2_DE"     	:	7,
	"PD4:USART2_RTS"    	:	7,
	"PD5:EVENTOUT"      	:	15,
	"PD5:FMC_NWE"       	:	12,
	"PD5:OCTOSPIM_P1_IO5"	:	10,
	"PD5:USART2_TX"     	:	7,
	"PD6:DCMI_D10"      	:	4,
	"PD6:DFSDM1_DATIN1" 	:	6,
	"PD6:EVENTOUT"      	:	15,
	"PD6:FMC_NWAIT"     	:	12,
	"PD6:OCTOSPIM_P1_IO6"	:	10,
	"PD6:SAI1_D1"       	:	3,
	"PD6:SAI1_SD_A"     	:	13,
	"PD6:SPI3_MOSI"     	:	5,
	"PD6:USART2_RX"     	:	7,
	"PD7:DFSDM1_CKIN1"  	:	6,
	"PD7:EVENTOUT"      	:	15,
	"PD7:FMC_NCE"       	:	12,
	"PD7:FMC_NE1"       	:	12,
	"PD7:OCTOSPIM_P1_IO7"	:	10,
	"PD7:USART2_CK"     	:	7,
	"PD8:DCMI_HSYNC"    	:	10,
	"PD8:EVENTOUT"      	:	15,
	"PD8:FMC_D13"       	:	12,
	"PD8:FMC_DA13"      	:	12,
	"PD8:USART3_TX"     	:	7,
	"PD9:DCMI_PIXCLK"   	:	10,
	"PD9:EVENTOUT"      	:	15,
	"PD9:FMC_D14"       	:	12,
	"PD9:FMC_DA14"      	:	12,
	"PD9:SAI2_MCLK_A"   	:	13,
	"PD9:USART3_RX"     	:	7,
	"PD10:EVENTOUT"     	:	15,
	"PD10:FMC_D15"      	:	12,
	"PD10:FMC_DA15"     	:	12,
	"PD10:SAI2_SCK_A"   	:	13,
	"PD10:TSC_G6_IO1"   	:	9,
	"PD10:USART3_CK"    	:	7,
	"PD11:EVENTOUT"     	:	15,
	"PD11:FMC_A16"      	:	12,
	"PD11:I2C4_SMBA"    	:	4,
	"PD11:LPTIM2_ETR"   	:	14,
	"PD11:SAI2_SD_A"    	:	13,
	"PD11:TSC_G6_IO2"   	:	9,
	"PD11:USART3_CTS"   	:	7,
	"PD11:USART3_NSS"   	:	7,
	"PD12:EVENTOUT"     	:	15,
	"PD12:FMC_A17"      	:	12,
	"PD12:I2C4_SCL"     	:	4,
	"PD12:LPTIM2_IN1"   	:	14,
	"PD12:SAI2_FS_A"    	:	13,
	"PD12:TIM4_CH1"     	:	2,
	"PD12:TSC_G6_IO3"   	:	9,
	"PD12:USART3_DE"    	:	7,
	"PD12:USART3_RTS"   	:	7,
	"PD13:EVENTOUT"     	:	15,
	"PD13:FMC_A18"      	:	12,
	"PD13:I2C4_SDA"     	:	4,
	"PD13:LPTIM2_OUT"   	:	14,
	"PD13:TIM4_CH2"     	:	2,
	"PD13:TSC_G6_IO4"   	:	9,
	"PD14:EVENTOUT"     	:	15,
	"PD14:FMC_D0"       	:	12,
	"PD14:FMC_DA0"      	:	12,
	"PD14:TIM4_CH3"     	:	2,
	"PD15:EVENTOUT"     	:	15,
	"PD15:FMC_D1"       	:	12,
	"PD15:FMC_DA1"      	:	12,
	"PD15:TIM4_CH4"     	:	2,
	"PE0:DCMI_D2"       	:	10,
	"PE0:EVENTOUT"      	:	15,
	"PE0:FMC_NBL0"      	:	12,
	"PE0:TIM16_CH1"     	:	14,
	"PE0:TIM4_ETR"      	:	2,
	"PE1:DCMI_D3"       	:	10,
	"PE1:EVENTOUT"      	:	15,
	"PE1:FMC_NBL1"      	:	12,
	"PE1:TIM17_CH1"     	:	14,
	"PE2:EVENTOUT"      	:	15,
	"PE2:FMC_A23"       	:	12,
	"PE2:SAI1_CK1"      	:	3,
	"PE2:SAI1_MCLK_A"   	:	13,
	"PE2:TRACECLK"  	:	0,
	"PE2:TIM3_ETR"      	:	2,
	"PE2:TSC_G7_IO1"    	:	9,
	"PE3:EVENTOUT"      	:	15,
	"PE3:FMC_A19"       	:	12,
	"PE3:OCTOSPIM_P1_DQS"	:	3,
	"PE3:SAI1_SD_B"     	:	13,
	"PE3:TRACED0"   	:	0,
	"PE3:TIM3_CH1"      	:	2,
	"PE3:TSC_G7_IO2"    	:	9,
	"PE4:DCMI_D4"       	:	10,
	"PE4:DFSDM1_DATIN3" 	:	6,
	"PE4:EVENTOUT"      	:	15,
	"PE4:FMC_A20"       	:	12,
	"PE4:SAI1_D2"       	:	3,
	"PE4:SAI1_FS_A"     	:	13,
	"PE4:TRACED1"   	:	0,
	"PE4:TIM3_CH2"      	:	2,
	"PE4:TSC_G7_IO3"    	:	9,
	"PE5:DCMI_D6"       	:	10,
	"PE5:DFSDM1_CKIN3"  	:	6,
	"PE5:EVENTOUT"      	:	15,
	"PE5:FMC_A21"       	:	12,
	"PE5:SAI1_CK2"      	:	3,
	"PE5:SAI1_SCK_A"    	:	13,
	"PE5:TRACED2"   	:	0,
	"PE5:TIM3_CH3"      	:	2,
	"PE5:TSC_G7_IO4"    	:	9,
	"PE6:DCMI_D7"       	:	10,
	"PE6:EVENTOUT"      	:	15,
	"PE6:FMC_A22"       	:	12,
	"PE6:SAI1_D1"       	:	3,
	"PE6:SAI1_SD_A"     	:	13,
	"PE6:TRACED3"   	:	0,
	"PE6:TIM3_CH4"      	:	2,
	"PE7:DFSDM1_DATIN2" 	:	6,
	"PE7:EVENTOUT"      	:	15,
	"PE7:FMC_D4"        	:	12,
	"PE7:FMC_DA4"       	:	12,
	"PE7:SAI1_SD_B"     	:	13,
	"PE7:TIM1_ETR"      	:	1,
	"PE8:DFSDM1_CKIN2"  	:	6,
	"PE8:EVENTOUT"      	:	15,
	"PE8:FMC_D5"        	:	12,
	"PE8:FMC_DA5"       	:	12,
	"PE8:SAI1_SCK_B"    	:	13,
	"PE8:TIM1_CH1N"     	:	1,
	"PE9:DFSDM1_CKOUT"  	:	6,
	"PE9:EVENTOUT"      	:	15,
	"PE9:FMC_D6"        	:	12,
	"PE9:FMC_DA6"       	:	12,
	"PE9:SAI1_FS_B"     	:	13,
	"PE9:TIM1_CH1"      	:	1,
	"PE10:DFSDM1_DATIN4"	:	6,
	"PE10:EVENTOUT"     	:	15,
	"PE10:FMC_D7"       	:	12,
	"PE10:FMC_DA7"      	:	12,
	"PE10:OCTOSPIM_P1_CLK"	:	10,
	"PE10:SAI1_MCLK_B"  	:	13,
	"PE10:TIM1_CH2N"    	:	1,
	"PE10:TSC_G5_IO1"   	:	9,
	"PE11:DFSDM1_CKIN4" 	:	6,
	"PE11:EVENTOUT"     	:	15,
	"PE11:FMC_D8"       	:	12,
	"PE11:FMC_DA8"      	:	12,
	"PE11:OCTOSPIM_P1_NCS"	:	10,
	"PE11:TIM1_CH2"     	:	1,
	"PE11:TSC_G5_IO2"   	:	9,
	"PE12:DFSDM1_DATIN5"	:	6,
	"PE12:EVENTOUT"     	:	15,
	"PE12:FMC_D9"       	:	12,
	"PE12:FMC_DA9"      	:	12,
	"PE12:OCTOSPIM_P1_IO0"	:	10,
	"PE12:SPI1_NSS"     	:	5,
	"PE12:TIM1_CH3N"    	:	1,
	"PE12:TSC_G5_IO3"   	:	9,
	"PE13:DFSDM1_CKIN5" 	:	6,
	"PE13:EVENTOUT"     	:	15,
	"PE13:FMC_D10"      	:	12,
	"PE13:FMC_DA10"     	:	12,
	"PE13:OCTOSPIM_P1_IO1"	:	10,
	"PE13:SPI1_SCK"     	:	5,
	"PE13:TIM1_CH3"     	:	1,
	"PE13:TSC_G5_IO4"   	:	9,
	"PE14:EVENTOUT"     	:	15,
	"PE14:FMC_D11"      	:	12,
	"PE14:FMC_DA11"     	:	12,
	"PE14:OCTOSPIM_P1_IO2"	:	10,
	"PE14:SPI1_MISO"    	:	5,
	"PE14:TIM1_BKIN2"   	:	3,
	"PE14:TIM1_CH4"     	:	1,
	"PE15:EVENTOUT"     	:	15,
	"PE15:FMC_D12"      	:	12,
	"PE15:FMC_DA12"     	:	12,
	"PE15:OCTOSPIM_P1_IO3"	:	10,
	"PE15:SPI1_MOSI"    	:	5,
	"PE15:TIM1_BKIN"    	:	3,
	"PF0:EVENTOUT"      	:	15,
	"PF0:FMC_A0"        	:	12,
	"PF0:I2C2_SDA"      	:	4,
	"PF0:OCTOSPIM_P2_IO0"	:	5,
	"PF1:EVENTOUT"      	:	15,
	"PF1:FMC_A1"        	:	12,
	"PF1:I2C2_SCL"      	:	4,
	"PF1:OCTOSPIM_P2_IO1"	:	5,
	"PF2:EVENTOUT"      	:	15,
	"PF2:FMC_A2"        	:	12,
	"PF2:I2C2_SMBA"     	:	4,
	"PF2:OCTOSPIM_P2_IO2"	:	5,
	"PF3:EVENTOUT"      	:	15,
	"PF3:FMC_A3"        	:	12,
	"PF3:OCTOSPIM_P2_IO3"	:	5,
	"PF4:EVENTOUT"      	:	15,
	"PF4:FMC_A4"        	:	12,
	"PF4:OCTOSPIM_P2_CLK"	:	5,
	"PF5:EVENTOUT"      	:	15,
	"PF5:FMC_A5"        	:	12,
	"PF10:DCMI_D11"     	:	10,
	"PF10:DFSDM1_CKOUT" 	:	6,
	"PF10:EVENTOUT"     	:	15,
	"PF10:OCTOSPIM_P1_CLK"	:	3,
	"PF10:SAI1_D3"      	:	13,
	"PF10:TIM15_CH2"    	:	14,
	"PF11:DCMI_D12"     	:	10,
	"PF11:EVENTOUT"     	:	15,
	"PF12:EVENTOUT"     	:	15,
	"PF12:FMC_A6"       	:	12,
	"PF12:OCTOSPIM_P2_DQS"	:	5,
	"PF13:DFSDM1_DATIN6"	:	6,
	"PF13:EVENTOUT"     	:	15,
	"PF13:FMC_A7"       	:	12,
	"PF13:I2C4_SMBA"    	:	4,
	"PF14:DFSDM1_CKIN6" 	:	6,
	"PF14:EVENTOUT"     	:	15,
	"PF14:FMC_A8"       	:	12,
	"PF14:I2C4_SCL"     	:	4,
	"PF14:TSC_G8_IO1"   	:	9,
	"PF15:EVENTOUT"     	:	15,
	"PF15:FMC_A9"       	:	12,
	"PF15:I2C4_SDA"     	:	4,
	"PF15:TSC_G8_IO2"   	:	9,
	"PG0:EVENTOUT"      	:	15,
	"PG0:FMC_A10"       	:	12,
	"PG0:OCTOSPIM_P2_IO4"	:	5,
	"PG0:TSC_G8_IO3"    	:	9,
	"PG1:EVENTOUT"      	:	15,
	"PG1:FMC_A11"       	:	12,
	"PG1:OCTOSPIM_P2_IO5"	:	5,
	"PG1:TSC_G8_IO4"    	:	9,
	"PG2:EVENTOUT"      	:	15,
	"PG2:FMC_A12"       	:	12,
	"PG2:SAI2_SCK_B"    	:	13,
	"PG2:SPI1_SCK"      	:	5,
	"PG3:EVENTOUT"      	:	15,
	"PG3:FMC_A13"       	:	12,
	"PG3:SAI2_FS_B"     	:	13,
	"PG3:SPI1_MISO"     	:	5,
	"PG4:EVENTOUT"      	:	15,
	"PG4:FMC_A14"       	:	12,
	"PG4:SAI2_MCLK_B"   	:	13,
	"PG4:SPI1_MOSI"     	:	5,
	"PG5:EVENTOUT"      	:	15,
	"PG5:FMC_A15"       	:	12,
	"PG5:LPUART1_CTS"   	:	8,
	"PG5:SAI2_SD_B"     	:	13,
	"PG5:SPI1_NSS"      	:	5,
	"PG6:EVENTOUT"      	:	15,
	"PG6:I2C3_SMBA"     	:	4,
	"PG6:LPUART1_DE"    	:	8,
	"PG6:LPUART1_RTS"   	:	8,
	"PG6:OCTOSPIM_P1_DQS"	:	3,
	"PG7:DFSDM1_CKOUT"  	:	6,
	"PG7:EVENTOUT"      	:	15,
	"PG7:FMC_INT"       	:	12,
	"PG7:I2C3_SCL"      	:	4,
	"PG7:LPUART1_TX"    	:	8,
	"PG7:OCTOSPIM_P2_DQS"	:	5,
	"PG7:SAI1_CK1"      	:	3,
	"PG7:SAI1_MCLK_A"   	:	13,
	"PG8:EVENTOUT"      	:	15,
	"PG8:I2C3_SDA"      	:	4,
	"PG8:LPUART1_RX"    	:	8,
	"PG9:EVENTOUT"      	:	15,
	"PG9:FMC_NCE"       	:	12,
	"PG9:FMC_NE2"       	:	12,
	"PG9:OCTOSPIM_P2_IO6"	:	5,
	"PG9:SAI2_SCK_A"    	:	13,
	"PG9:SPI3_SCK"      	:	6,
	"PG9:TIM15_CH1N"    	:	14,
	"PG9:USART1_TX"     	:	7,
	"PG10:EVENTOUT"     	:	15,
	"PG10:FMC_NE3"      	:	12,
	"PG10:LPTIM1_IN1"   	:	1,
	"PG10:OCTOSPIM_P2_IO7"	:	5,
	"PG10:SAI2_FS_A"    	:	13,
	"PG10:SPI3_MISO"    	:	6,
	"PG10:TIM15_CH1"    	:	14,
	"PG10:USART1_RX"    	:	7,
	"PG11:EVENTOUT"     	:	15,
	"PG11:LPTIM1_IN2"   	:	1,
	"PG11:OCTOSPIM_P1_IO5"	:	3,
	"PG11:SAI2_MCLK_A"  	:	13,
	"PG11:SPI3_MOSI"    	:	6,
	"PG11:TIM15_CH2"    	:	14,
	"PG11:USART1_CTS"   	:	7,
	"PG11:USART1_NSS"   	:	7,
	"PG12:EVENTOUT"     	:	15,
	"PG12:FMC_NE4"      	:	12,
	"PG12:LPTIM1_ETR"   	:	1,
	"PG12:OCTOSPIM_P2_NCS"	:	5,
	"PG12:SAI2_SD_A"    	:	13,
	"PG12:SPI3_NSS"     	:	6,
	"PG12:USART1_DE"    	:	7,
	"PG12:USART1_RTS"   	:	7,
	"PG13:EVENTOUT"     	:	15,
	"PG13:FMC_A24"      	:	12,
	"PG13:I2C1_SDA"     	:	4,
	"PG13:USART1_CK"    	:	7,
	"PG14:EVENTOUT"     	:	15,
	"PG14:FMC_A25"      	:	12,
	"PG14:I2C1_SCL"     	:	4,
	"PG15:DCMI_D13"     	:	10,
	"PG15:EVENTOUT"     	:	15,
	"PG15:I2C1_SMBA"    	:	4,
	"PG15:LPTIM1_OUT"   	:	1,
	"PG15:OCTOSPIM_P2_DQS"	:	5,
	"PH0:EVENTOUT"      	:	15,
	"PH1:EVENTOUT"      	:	15,
	"PH2:EVENTOUT"      	:	15,
	"PH2:OCTOSPIM_P1_IO4"	:	3,
	"PH3:EVENTOUT"      	:	15,
	"PH4:EVENTOUT"      	:	15,
	"PH4:I2C2_SCL"      	:	4,
	"PH4:OCTOSPIM_P2_DQS"	:	5,
	"PH5:DCMI_PIXCLK"   	:	10,
	"PH5:EVENTOUT"      	:	15,
	"PH5:I2C2_SDA"      	:	4,
	"PH6:DCMI_D8"       	:	10,
	"PH6:EVENTOUT"      	:	15,
	"PH6:I2C2_SMBA"     	:	4,
	"PH6:OCTOSPIM_P2_CLK"	:	5,
	"PH7:DCMI_D9"       	:	10,
	"PH7:EVENTOUT"      	:	15,
	"PH7:I2C3_SCL"      	:	4,
	"PH8:DCMI_HSYNC"    	:	10,
	"PH8:EVENTOUT"      	:	15,
	"PH8:I2C3_SDA"      	:	4,
	"PH8:OCTOSPIM_P2_IO3"	:	5,
	"PH9:DCMI_D0"       	:	10,
	"PH9:EVENTOUT"      	:	15,
	"PH9:I2C3_SMBA"     	:	4,
	"PH9:OCTOSPIM_P2_IO4"	:	5,
	"PH10:DCMI_D1"      	:	10,
	"PH10:EVENTOUT"     	:	15,
	"PH10:OCTOSPIM_P2_IO5"	:	5,
	"PH10:TIM5_CH1"     	:	2,
	"PH11:DCMI_D2"      	:	10,
	"PH11:EVENTOUT"     	:	15,
	"PH11:OCTOSPIM_P2_IO6"	:	5,
	"PH11:TIM5_CH2"     	:	2,
	"PH12:DCMI_D3"      	:	10,
	"PH12:EVENTOUT"     	:	15,
	"PH12:OCTOSPIM_P2_IO7"	:	5,
	"PH12:TIM5_CH3"     	:	2,
	"PH13:CAN1_TX"      	:	9,
	"PH13:EVENTOUT"     	:	15,
	"PH13:TIM8_CH1N"    	:	3,
	"PH14:DCMI_D4"      	:	10,
	"PH14:EVENTOUT"     	:	15,
	"PH14:TIM8_CH2N"    	:	3,
	"PH15:DCMI_D11"     	:	10,
	"PH15:EVENTOUT"     	:	15,
	"PH15:OCTOSPIM_P2_IO6"	:	5,
	"PH15:TIM8_CH3N"    	:	3,
	"PI0:DCMI_D13"      	:	10,
	"PI0:EVENTOUT"      	:	15,
	"PI0:OCTOSPIM_P1_IO5"	:	3,
	"PI0:SPI2_NSS"      	:	5,
	"PI0:TIM5_CH4"      	:	2,
	"PI1:DCMI_D8"       	:	10,
	"PI1:EVENTOUT"      	:	15,
	"PI1:SPI2_SCK"      	:	5,
	"PI2:DCMI_D9"       	:	10,
	"PI2:EVENTOUT"      	:	15,
	"PI2:SPI2_MISO"     	:	5,
	"PI2:TIM8_CH4"      	:	3,
	"PI3:DCMI_D10"      	:	10,
	"PI3:EVENTOUT"      	:	15,
	"PI3:SPI2_MOSI"     	:	5,
	"PI3:TIM8_ETR"      	:	3,
	"PI4:DCMI_D5"       	:	10,
	"PI4:EVENTOUT"      	:	15,
	"PI4:TIM8_BKIN"     	:	3,
	"PI5:DCMI_VSYNC"    	:	10,
	"PI5:EVENTOUT"      	:	15,
	"PI5:OCTOSPIM_P2_NCS"	:	5,
	"PI5:TIM8_CH1"      	:	3,
	"PI6:DCMI_D6"       	:	10,
	"PI6:EVENTOUT"      	:	15,
	"PI6:OCTOSPIM_P2_CLK"	:	5,
	"PI6:TIM8_CH2"      	:	3,
	"PI7:DCMI_D7"       	:	10,
	"PI7:EVENTOUT"      	:	15,
	"PI7:TIM8_CH3"      	:	3,
	"PI8:DCMI_D12"      	:	10,
	"PI8:EVENTOUT"      	:	15,
	"PI8:OCTOSPIM_P2_NCS"	:	5,
	"PI9:CAN1_RX"       	:	9,
	"PI9:EVENTOUT"      	:	15,
	"PI9:OCTOSPIM_P2_IO2"	:	5,
	"PI10:EVENTOUT"     	:	15,
	"PI10:OCTOSPIM_P2_IO1"	:	5,
	"PI11:EVENTOUT"     	:	15,
	"PI11:OCTOSPIM_P2_IO0"	:	5,
}

ADC1_map = {
	# format is PIN : ADC1_CHAN
    "PA0"	:	5,
    "PA1"	:	6,
    "PA2"	:	7,
    "PA3"	:	8,
    "PA4"	:	9,
    "PA5"	:	10,
    "PA6"	:	11,
    "PA7"	:	12,
    "PC4"   :   13,
    "PC5"   :   14,
    "PB0"   :   15,
    "PB1"   :   16,
    "PC0"   :   1,
    "PC1"   :   2,
    "PC2"   :   3,
    "PC3"   :   4,
}
    
                                                   #!/usr/bin/env python
'''
create additional functions ADC table, used for mapping analog pins to ADC channel numbers

Currently only extracts ADC1 channels

This assumes a csv file extracted from the datasheet using tablula:

 https://github.com/tabulapdf/tabula
'''

import sys, csv, os

def is_pin(str):
    '''see if a string is a valid pin name'''
    if len(str) < 3:
        return False
    if str[0] != 'P':
        return False
    if str[1] not in "ABCDEFGH":
        return False
    try:
        p = int(str[2:])
        if p < 0 or p > 15:
            return False
        return True
    except ValueError:
        return False

def parse_adc_table(fname, table):
    csvt = csv.reader(open(fname,'rb'))
    i = 0
    for row in csvt:
        for col in row:
            if is_pin(col) and row[-1].startswith('ADC1'):
                chan = row[-1]
                chan = chan.replace('\r', '')
                chan = chan.replace(' ', '')
                chan = chan.split('/')
                chan = chan[0]
                chan = chan.split(',')
                chan = chan[0]
                a = chan.split('_')
                if len(a) != 2:
                    continue
                chan_num = a[1]
                if chan_num.startswith('IN'):
                    chan_num = chan_num[2:]
                try:
                    chan_num = int(chan_num)
                except Exception:
                    continue
                table[col] = chan_num

table = {}

if len(sys.argv) != 2:
    print("Error: expected 1 CSV file")
    sys.exit(1)

parse_adc_table(sys.argv[1], table)

sys.stdout.write("ADC1_map = {\n");
sys.stdout.write('\t# format is PIN : ADC1_CHAN\n')
sys.stdout.write('\t# extracted from %s\n' % os.path.basename(sys.argv[1]))
for k in sorted(table.keys()):
    s = '"' + k + '"'
    sys.stdout.write('\t%-4s\t:\t%s,\n' % (s, table[k]))
sys.stdout.write("}\n");
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           #!/usr/bin/env python
'''
 create alternate function tables 

This assumes a csv file extracted from the datasheet using tablula:

 https://github.com/tabulapdf/tabula
'''

import sys, csv, os
from functools import cmp_to_key

def is_pin(str):
    '''see if a string is a valid pin name'''
    if len(str) < 3:
        return False
    if str[0] != 'P':
        return False
    if str[1] not in "ABCDEFGHIJK":
        return False
    try:
        p = int(str[2:])
        if p < 0 or p > 15:
            return False
        return True
    except ValueError:
        return False

def pin_compare(p1, p2):
    '''control pin sort order'''
    (p1,f1) = p1.split(':')
    (p2,f2) = p2.split(':')
    port1 = p1[:2]
    port2 = p2[:2]
    pin1 = int(p1[2:])
    pin2 = int(p2[2:])
    #print(port1, pin1, port2, pin2)
    if port1 == port2:
        if pin1 == pin2:
            if f1 < f2:
                return -1
            return 1
        if pin1 < pin2:
            return -1
        return 1
    if port1 < port2:
        return -1
    return 1

def parse_af_table(fname, table):
    csvt = csv.reader(open(fname,'r'))
    i = 0
    aflist = []
    for row in csvt:
        if len(row) > 2 and row[1] == 'AF0':
            # it is a AF list
            aflist = []
            for s in row[1:]:
                if s:
                    aflist.append(int(s[2:]))
        if not is_pin(row[0]):
            if len(row) < 2 or not is_pin(row[1]):
                continue
            row = row[1:]
        pin = row[0]
        for i in range(len(aflist)):
            if len(row) <= i+1:
                break
            af = aflist[i]
            s = row[i+1]
            s = s.replace('_\r', '_')
            s = s.replace('\r_', '_')
            s = s.replace('\r', '')
            s = s.replace(' ', '')
            if s == '-' or len(s) == 0:
                continue
            functions = s.split('/')
            for f in functions:
                table[pin+':'+f.upper()] = af

table = {}

if len(sys.argv) != 2:
    print("Error: expected 1 CSV file")
    sys.exit(1)

parse_af_table(sys.argv[1], table)

sys.stdout.write("AltFunction_map = {\n");
sys.stdout.write('\t# format is PIN:FUNCTION : AFNUM\n')
sys.stdout.write('\t# extracted from %s\n' % os.path.basename(sys.argv[1]))
for k in sorted(table.keys(), key=cmp_to_key(pin_compare)):
    s = '"' + k + '"'
    sys.stdout.write('\t%-20s\t:\t%s,\n' % (s, table[k]))
sys.stdout.write("}\n");
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              #!/usr/bin/env python3
'''
create alternate function tables, without using tabula

This assumes a csv file generated by STM32CubeMX this way:
"Pinout" (Above the IC view) -> "Export pinout with Alt. Functions"
'''

import sys, csv, os, re
from functools import cmp_to_key

def is_pin(str):
    '''see if a string is a valid pin name'''
    if len(str) < 3:
        return False
    if str[0] != 'P':
        return False
    if str[1] not in "ABCDEFGHIJK":
        return False
    try:
        p = int(str[2:])
        if p < 0 or p > 15:
            return False
        return True
    except ValueError:
        return False

def pin_compare(p1, p2):
    '''control pin sort order'''
    (p1,f1) = p1.split(':')
    (p2,f2) = p2.split(':')
    port1 = p1[:2]
    port2 = p2[:2]
    pin1 = int(p1[2:])
    pin2 = int(p2[2:])
    #print(port1, pin1, port2, pin2)
    if port1 == port2:
        if pin1 == pin2:
            if f1 < f2:
                return -1
            return 1
        if pin1 < pin2:
            return -1
        return 1
    if port1 < port2:
        return -1
    return 1

def parse_af_table(fname, table):
    csvt = csv.reader(open(fname,'r'))
    i = 0
    aflist = []
    row = next(csvt)

    AF_COLUMN = 5  # Columns are: "Position","Name","Type","Signal","Label","AF0","AF1"...

    if len(row) < AF_COLUMN or row[AF_COLUMN] != 'AF0':
        print("Error: This doesn't look like CubeMX pinout csv")
        sys.exit(1)

    for row in csvt:
        pin = re.findall('\w\w\d+', row[1])  # Strip function after pin like 'PC14-OSC32_IN'
        if len(pin) == 0:
            continue
        elif not is_pin(pin[0]):
            continue
        
        pin = pin[0]
        for af_index, value in enumerate(row[AF_COLUMN:]):
            if len(value) > 0:
                for single_function in value.split('/'):
                    table['{0}:{1}'.format(pin, single_function)] = af_index

# Key: PIN:FUNCTION
# Value: AFNUMBER
table = {}

if len(sys.argv) != 2:
    print("Error: expected 1 CSV file")
    sys.exit(1)

parse_af_table(sys.argv[1], table)

sys.stdout.write("AltFunction_map = {\n");
sys.stdout.write('\t# format is PIN:FUNCTION : AFNUM\n')
sys.stdout.write('\t# extracted from %s\n' % os.path.basename(sys.argv[1]))
for k in sorted(table.keys(), key=cmp_to_key(pin_compare)):
    s = '"' + k + '"'
    sys.stdout.write('\t%-20s\t:\t%s,\n' % (s, table[k]))
sys.stdout.write("}\n");
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               #!/usr/bin/env python

"""
script to encode a telemetry value using dshot and gcr and then display in binary and ascii art
see https://github.com/betaflight/betaflight/pull/8554#issuecomment-512507625
"""

import argparse

parser = argparse.ArgumentParser("bdshot_encoder.py")
parser.add_argument('value', help='Value to encode')

args = parser.parse_args()

def dshot_encode(value):
    packet = (value << 1)

    # compute checksum
    csum = 0
    csum_data = packet
    for i in range(3):
        csum ^= csum_data
        csum_data >>= 4

    csum = ~csum
    csum &= 0xF
    packet = (packet << 4) | csum

    return packet

def rll_encode(value):
    old_bit = 0
    rll_value = 0

    for i in range(1, 21):
        if value & 1:
            new_bit = (1 ^ old_bit)
        else:
            new_bit = old_bit
        value >>= 1
        rll_value |= new_bit << i
        old_bit = new_bit
    return rll_value

def gcr_encode(value):
    expo = 0

    if value:
        while value & 1 == 0:
            value >>= 1
            expo = expo + 1
    
    value = (value & 0x1FF) | (expo << 9)
    value = dshot_encode(value)

    nibble_map = [0x19, 0x1b, 0x12, 0x13, 0x1d, 0x15, 0x16, 0x17, 0x1a, 0x09, 0x0a, 0x0b, 0x1e, 0x0d, 0x0e, 0x0f ]

    new_value = 0
    for i in range(4):
        new_value |= (nibble_map[value & 0xF] << ((3-i) * 5))
        value >> 4

    return rll_encode(new_value)

def print_signal(value):
    old_bit = 0
    print("_ ", sep='', end='')
    for i in range(21):
        bit = (value>>(20-i)) & 1
        if bit != old_bit:
            print(' ', sep='', end='')
        if bit:
            print('_', sep='', end='')
        else:
            print(' ', sep='', end='')
        old_bit = bit
    print(" _", sep='', end='')
    print('')

    print(" |", sep='', end='')
    for i in range(21):
        bit = (value>>(20-i)) & 1
        if bit != old_bit:
            print('|', sep='', end='')
        print(' ', sep='', end='')
        old_bit = bit
    print("| ", sep='', end='')
    print('')

    print(" |", sep='', end='')
    for i in range(21):
        bit = (value>>(20-i)) & 1
        if bit != old_bit:
            print('|', sep='', end='')
        if bit == 0:
            print("_", sep='', end='')
        else:
            print(' ', sep='', end='')
        old_bit = bit
    print("| ", sep='', end='')
    print('')

if args.value.startswith("0b"):
    value = int(args.value[2:], 2)
elif args.value.startswith("0x"):
    value = int(args.value[2:], 16)
else:
    value = int(args.value)

encoded_value = gcr_encode(value)
print("0b{:020b}".format(encoded_value))
print_signal(encoded_value)

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 /*
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
#pragma once

namespace Linux {

class Heat {
public:
    virtual void set_imu_temp(float current) { }
    virtual void set_imu_target_temp(int8_t *target) { }
};

}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 #pragma once

#include <atomic>

#include "AP_HAL_Linux.h"

#define LINUX_RC_INPUT_NUM_CHANNELS 16

namespace Linux {

class RCInput : public AP_HAL::RCInput {
public:
    RCInput();

    static RCInput *from(AP_HAL::RCInput *rcinput) {
        return static_cast<RCInput*>(rcinput);
    }

    virtual void init() override;
    bool new_input() override;
    uint8_t num_channels() override;
    void set_num_channels(uint8_t num);
    uint16_t read(uint8_t ch) override;
    uint8_t read(uint16_t* periods, uint8_t len) override;

    int16_t get_rssi(void) override {
        return _rssi;
    }

    const char *protocol() const override { return "Unknown"; }

    // default empty _timer_tick, this is overridden by board
    // specific implementations
    virtual void _timer_tick() {}

protected:
    void _process_rc_pulse(uint16_t width_s0, uint16_t width_s1);
    void _update_periods(uint16_t *periods, uint8_t len);

    std::atomic<unsigned int> rc_input_count;
    std::atomic<unsigned int> last_rc_input_count;

    uint16_t _pwm_values[LINUX_RC_INPUT_NUM_CHANNELS];
    uint8_t  _num_channels;

    void _process_ppmsum_pulse(uint16_t width);
    void _process_sbus_pulse(uint16_t width_s0, uint16_t width_s1);
    void _process_dsm_pulse(uint16_t width_s0, uint16_t width_s1);
    void _process_pwm_pulse(uint16_t channel, uint16_t width_s0, uint16_t width_s1);

    // state of ppm decoder
    struct {
        int8_t _channel_counter;
        uint16_t _pulse_capt[LINUX_RC_INPUT_NUM_CHANNELS];
    } ppm_state;

    // state of SBUS bit decoder
    struct {
	uint16_t bytes[25]; // including start bit, parity and stop bits
	uint16_t bit_ofs;
    } sbus_state;

    // state of DSM decoder
    struct {
        uint16_t bytes[16]; // including start bit and stop bit
        uint16_t bit_ofs;
    } dsm_state;

    int16_t _rssi = -1;
};

}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           // This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU General Public License for more details.
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.


#include <AP_HAL/AP_HAL.h>

#if CONFIG_HAL_BOARD_SUBTYPE == HAL_BOARD_SUBTYPE_LINUX_BBBMINI || \
    CONFIG_HAL_BOARD_SUBTYPE == HAL_BOARD_SUBTYPE_LINUX_BLUE || \
    CONFIG_HAL_BOARD_SUBTYPE == HAL_BOARD_SUBTYPE_LINUX_POCKET

#include <errno.h>
#include <fcntl.h>
#include <poll.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <unistd.h>

#include "RCInput.h"
#include "RCInput_AioPRU.h"

extern const AP_HAL::HAL& hal;

using namespace Linux;

void RCInput_AioPRU::init()
{
    int mem_fd = open("/dev/mem", O_RDWR|O_SYNC|O_CLOEXEC);
    if (mem_fd == -1) {
        AP_HAL::panic("Unable to open /dev/mem");
    }
    ring_buffer = (volatile struct ring_buffer*) mmap(0, 0x1000, PROT_READ|PROT_WRITE, MAP_SHARED, mem_fd, RCIN_PRUSS_RAM_BASE);
    close(mem_fd);
    ring_buffer->ring_head = 0;
}

/*
  called at 1kHz to check for new pulse capture data from the PRU
 */
void RCInput_AioPRU::_timer_tick()
{
    while (ring_buffer->ring_head != ring_buffer->ring_tail) {
        if (ring_buffer->ring_tail >= NUM_RING_ENTRIES) {
            // invalid ring_tail from PRU - ignore RC input
            return;
        }
        _process_rc_pulse((ring_buffer->buffer[ring_buffer->ring_head].s1_t) / TICK_PER_US,
                          (ring_buffer->buffer[ring_buffer->ring_head].s0_t) / TICK_PER_US);
        // move to the next ring buffer entry
        ring_buffer->ring_head = (ring_buffer->ring_head + 1) % NUM_RING_ENTRIES;
    }
}

#endif // CONFIG_HAL_BOARD_SUBTYPE
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              // This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU General Public License for more details.
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.
#pragma once

/*
  This class implements RCInput on the BeagleBoneBlack with a PRU
  doing the edge detection of the PPM sum input
 */

#include "AP_HAL_Linux.h"

#if CONFIG_HAL_BOARD_SUBTYPE == HAL_BOARD_SUBTYPE_LINUX_POCKET
#define RCIN_PRUSS_RAM_BASE   0x4a301000
#else
#define RCIN_PRUSS_RAM_BASE   0x4a303000
#endif

// we use 300 ring buffer entries to guarantee that a full 25 byte
// frame of 12 bits per byte

namespace Linux {

class RCInput_AioPRU : public RCInput {
public:
    void init() override;
    void _timer_tick(void) override;

protected:
    static const uint32_t TICK_PER_US = 200;
    static const uint32_t NUM_RING_ENTRIES = 300;
    // shared ring buffer with the PRU which records pin transitions
    struct ring_buffer {
        volatile uint16_t ring_head; // owned by ARM CPU
        volatile uint16_t ring_tail; // owned by the PRU
        struct {
               volatile uint32_t s1_t; // 5ns per tick
               volatile uint32_t s0_t; // 5ns per tick
        } buffer[NUM_RING_ENTRIES];
    };
    volatile struct ring_buffer *ring_buffer;
};

}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    /*
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
/*
  this is a driver for multiple RCInput methods on one board
 */

#include <AP_HAL/AP_HAL.h>

#if CONFIG_HAL_BOARD_SUBTYPE == HAL_BOARD_SUBTYPE_LINUX_DISCO || \
    CONFIG_HAL_BOARD_SUBTYPE == HAL_BOARD_SUBTYPE_LINUX_BLUE
#include "RCInput_Multi.h"

extern const AP_HAL::HAL& hal;

using namespace Linux;

// constructor
RCInput_Multi::RCInput_Multi(uint8_t _num_inputs, ...) :
    num_inputs(_num_inputs)
{
    va_list ap;
    inputs = NEW_NOTHROW RCInput*[num_inputs];
    if (inputs == nullptr) {
        AP_HAL::panic("failed to allocated RCInput array");
    }
    va_start(ap, _num_inputs);
    for (uint8_t i=0; i<num_inputs; i++) {
        inputs[i] = va_arg(ap, RCInput *);
        if (inputs[i] == nullptr) {
            AP_HAL::panic("Bad RCInput object");
        }
    }
    va_end(ap);
}

void RCInput_Multi::init()
{
    for (uint8_t i=0; i<num_inputs; i++) {
        inputs[i]->init();
    }
}

void RCInput_Multi::_timer_tick(void)
{
    for (uint8_t i=0; i<num_inputs; i++) {
        inputs[i]->_timer_tick();
        if (inputs[i]->new_input()) {
            inputs[i]->read(_pwm_values, inputs[i]->num_channels());
            _num_channels = inputs[i]->num_channels();
            rc_input_count++;
        }        
    }
}

#endif // CONFIG_HAL_BOARD_SUBTYPE

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 #pragma once

#include <AP_HAL/AP_HAL.h>

#if CONFIG_HAL_BOARD == HAL_BOARD_SITL

#include "HAL_SITL_Class.h"

#endif  // CONFIG_HAL_BOARD
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     #pragma once

namespace HALSITL {
class UARTDriver;
class Scheduler;
class SITL_State_Common;
class SITL_State;
class Storage;
class AnalogIn;
class I2CDevice;
class I2CDeviceManager;
class RCInput;
class RCOutput;
class ADCSource;
class RCInput;
class Util;
class Semaphore;
class BinarySemaphore;
class GPIO;
class DigitalSource;
class DSP;
class CANIface;
}  // namespace HALSITL
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 #pragma once

#include "AP_HAL_SITL_Namespace.h"
#include "Scheduler.h"
#include "Storage.h"
#include "UARTDriver.h"
#include "SITL_State.h"
#include "Semaphores.h"
#include "CANSocketIface.h"
#include "DSP.h"
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              #include <AP_HAL/AP_HAL.h>
#if CONFIG_HAL_BOARD == HAL_BOARD_SITL

#include "AP_HAL_SITL.h"
#include "AnalogIn.h"
#include <stdint.h>

#define VOLTAGE_TO_PIN_VALUE(_v) (constrain_float(_v * (SITL_ADC_MAX_PIN_VALUE/SITL_ADC_FULL_SCALE_VOLTAGE), 0, SITL_ADC_MAX_PIN_VALUE))

using namespace HALSITL;

extern const AP_HAL::HAL& hal;

ADCSource::ADCSource(SITL_State *sitlState, int16_t pin) :
    _sitlState(sitlState),
    _pin(pin)
{}

float ADCSource::read_average() {
    return read_latest();
}

float ADCSource::voltage_average() {
    return voltage_latest();
}

float ADCSource::voltage_latest() {
    switch (_pin) {
    case ANALOG_INPUT_BOARD_VCC:
        return SITL_ADC_MAX_PIN_VALUE;

    case 0:
        return _sitlState->sonar_pin_voltage;

    case 1:
        return _sitlState->airspeed_pin_voltage[0];
    
    case 2:
        return _sitlState->airspeed_pin_voltage[1];

    case 12:
        return _sitlState->current_pin_voltage;

    case 13:
        return _sitlState->voltage_pin_voltage;

    case 14:
        return _sitlState->current2_pin_voltage;

    case 15:
        return _sitlState->voltage2_pin_voltage;

    case ANALOG_INPUT_NONE:
    default:
        return 0.0f;
    }
}

float ADCSource::read_latest() {
    return VOLTAGE_TO_PIN_VALUE(voltage_latest());
}

bool ADCSource::set_pin(uint8_t pin) {
    _pin = pin;
    return pin != ANALOG_INPUT_NONE;
}

void AnalogIn::init() {
}

AP_HAL::AnalogSource* AnalogIn::channel(int16_t pin) {
    return NEW_NOTHROW ADCSource(_sitlState, pin);
}

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 /*
  multicast UDP transport for SITL CAN
 */
#include "CAN_Multicast.h"

#if HAL_NUM_CAN_IFACES

#include <net/if.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <errno.h>
#include <stdlib.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netinet/udp.h>
#include <arpa/inet.h>
#include <fcntl.h>
#include <AP_Math/crc.h>

#define MCAST_ADDRESS_BASE "239.65.82.0"
#define MCAST_PORT 57732U
#define MCAST_MAGIC 0x2934U
#define MCAST_FLAG_CANFD 0x0001
#define MCAST_MAX_PKT_LEN 74 // 64 byte data + 10 byte header

struct PACKED mcast_pkt {
    uint16_t magic;
    uint16_t crc;
    uint16_t flags;
    uint32_t message_id;
    uint8_t data[MCAST_MAX_PKT_LEN-10];
};

/*
  initialise multicast transport
 */
bool CAN_Multicast::init(uint8_t instance)
{
    // setup incoming multicast socket
    char address[] = MCAST_ADDRESS_BASE;

    address[strlen(address)-1] = '0' + instance;
    return sock.connect(address, MCAST_PORT);
}

/*
  send a CAN frame
 */
bool CAN_Multicast::send(const AP_HAL::CANFrame &frame)
{
    struct mcast_pkt pkt {};
    pkt.magic = MCAST_MAGIC;
    pkt.flags = 0;
#if HAL_CANFD_SUPPORTED
    if (frame.canfd) {
        pkt.flags |= MCAST_FLAG_CANFD;
    }
#endif
    pkt.message_id = frame.id;
    const uint8_t data_length = AP_HAL::CANFrame::dlcToDataLength(frame.dlc);
    memcpy(pkt.data, frame.data, data_length);
    pkt.crc = crc16_ccitt((uint8_t*)&pkt.flags, data_length+6, 0xFFFFU);

    return sock.send((void*)&pkt, data_length+10) == data_length+10;
}

/*
  receive a CAN frame
 */
bool CAN_Multicast::receive(AP_HAL::CANFrame &frame)
{
    struct mcast_pkt pkt;
    ssize_t ret = sock.recv((void*)&pkt, sizeof(pkt), 0);
    if (ret < 10) {
        return false;
    }
    if (pkt.magic != MCAST_MAGIC) {
        return false;
    }
    if (pkt.crc != crc16_ccitt((uint8_t*)&pkt.flags, ret-4, 0xFFFFU)) {
        return false;
    }

    // run constructor to initialise
    new(&frame) AP_HAL::CANFrame(pkt.message_id, pkt.data, ret-10, (pkt.flags & MCAST_FLAG_CANFD) != 0);

    if (sem_handle != nullptr) {
        sem_handle->signal();
    }

    return true;
}

#endif // HAL_NUM_CAN_IFACES
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       /*
  multicast UDP transport for SITL CAN
 */
#pragma once

#include "CAN_Transport.h"

#if HAL_NUM_CAN_IFACES

class CAN_Multicast : public CAN_Transport {
public:

    bool init(uint8_t instance) override;
    bool send(const AP_HAL::CANFrame &frame) override;
    bool receive(AP_HAL::CANFrame &frame) override;
    int get_read_fd(void) const override {
        return sock.get_read_fd();
    }

private:
    SocketAPM_native sock{true};
};

#endif // HAL_NUM_CAN_IFACES
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     /*
  parent class for CAN transports in ArduPilot SITL
 */
#pragma once

#include "AP_HAL_SITL.h"

#if HAL_NUM_CAN_IFACES

#include <AP_HAL/CANIface.h>

class CAN_Transport {
public:
    virtual ~CAN_Transport() {}
    virtual bool init(uint8_t instance) = 0;
    virtual bool send(const AP_HAL::CANFrame &frame) = 0;
    virtual bool receive(AP_HAL::CANFrame &frame) = 0;
    virtual int get_read_fd(void) const = 0;

    void set_event_handle(AP_HAL::BinarySemaphore *handle) {
        sem_handle = handle;
    }

protected:
    AP_HAL::BinarySemaphore *sem_handle;
};

#endif // HAL_NUM_CAN_IFACES
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       /*
 * This file is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This file is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Code by Andy Piper
 */

#include <AP_HAL/AP_HAL.h>

#if HAL_WITH_DSP

#include "AP_HAL_SITL.h"
#include <AP_Math/AP_Math.h>
#include <GCS_MAVLink/GCS.h>
#include "DSP.h"
#include <cmath>
#include <assert.h>

using namespace HALSITL;

extern const AP_HAL::HAL& hal;

// The algorithms originally came from betaflight but are now substantially modified based on theory and experiment.
// https://holometer.fnal.gov/GH_FFT.pdf "Spectrum and spectral density estimation by the Discrete Fourier transform (DFT),
// including a comprehensive list of window functions and some new flat-top windows." - Heinzel et. al is a great reference
// for understanding the underlying theory although we do not use spectral density here since time resolution is equally
// important as frequency resolution. Referred to as [Heinz] throughout the code.

// initialize the FFT state machine
AP_HAL::DSP::FFTWindowState* DSP::fft_init(uint16_t window_size, uint16_t sample_rate, uint8_t sliding_window_size)
{
    DSP::FFTWindowStateSITL* fft = NEW_NOTHROW DSP::FFTWindowStateSITL(window_size, sample_rate, sliding_window_size);
    if (fft == nullptr || fft->_hanning_window == nullptr || fft->_rfft_data == nullptr || fft->_freq_bins == nullptr || fft->_derivative_freq_bins == nullptr) {
        delete fft;
        return nullptr;
    }
    return fft;
}

// start an FFT analysis
void DSP::fft_start(AP_HAL::DSP::FFTWindowState* state, FloatBuffer& samples, uint16_t advance)
{
    step_hanning((FFTWindowStateSITL*)state, samples, advance);
}

// perform remaining steps of an FFT analysis
uint16_t DSP::fft_analyse(AP_HAL::DSP::FFTWindowState* state, uint16_t start_bin, uint16_t end_bin, float noise_att_cutoff)
{
    FFTWindowStateSITL* fft = (FFTWindowStateSITL*)state;
    step_fft(fft);
    step_cmplx_mag(fft, start_bin, end_bin, noise_att_cutoff);
    return step_calc_frequencies(fft, start_bin, end_bin);
}

// create an instance of the FFT state machine
DSP::FFTWindowStateSITL::FFTWindowStateSITL(uint16_t window_size, uint16_t sample_rate, uint8_t sliding_window_size)
    : AP_HAL::DSP::FFTWindowState::FFTWindowState(window_size, sample_rate, sliding_window_size)
{
    if (_freq_bins == nullptr || _hanning_window == nullptr || _rfft_data == nullptr || _derivative_freq_bins == nullptr) {
        GCS_SEND_TEXT(MAV_SEVERITY_WARNING, "Failed to allocate window for DSP");
        return;
    }

    buf = NEW_NOTHROW complexf[window_size];
}

DSP::FFTWindowStateSITL::~FFTWindowStateSITL()
{
    delete[] buf;
}

// step 1: filter the incoming samples through a Hanning window
void DSP::step_hanning(FFTWindowStateSITL* fft, FloatBuffer& samples, uint16_t advance)
{
    // 5us
    // apply hanning window to gyro samples and store result in _freq_bins
    // hanning starts and ends with 0, could be skipped for minor speed improvement
    uint32_t read_window = samples.peek(&fft->_freq_bins[0], fft->_window_size);
    if (read_window != fft->_window_size) {
        return;
    }
    samples.advance(advance);
    mult_f32(&fft->_freq_bins[0], &fft->_hanning_window[0], &fft->_freq_bins[0], fft->_window_size);
}

// step 2: perform an in-place FFT on the windowed data
void DSP::step_fft(FFTWindowStateSITL* fft)
{
    for (uint16_t i = 0; i < fft->_window_size; i++) {
        fft->buf[i] = complexf(fft->_freq_bins[i], 0);
    }

    calculate_fft(fft->buf, fft->_window_size);

    for (uint16_t i = 0; i < fft->_bin_count; i++) {
        fft->_freq_bins[i] = std::norm(fft->buf[i]);
    }

    // components at the nyquist frequency are real only
    for (uint16_t i = 0, j = 0; i <= fft->_bin_count; i++, j += 2) {
        fft->_rfft_data[j] = fft->buf[i].real();
        fft->_rfft_data[j+1] = fft->buf[i].imag();
    }
}

void DSP::mult_f32(const float* v1, const float* v2, float* vout, uint16_t len)
{
    for (uint16_t i = 0; i < len; i++) {
        vout[i] = v1[i] * v2[i];
    }
}

void DSP::vector_max_float(const float* vin, uint16_t len, float* maxValue, uint16_t* maxIndex) const
{
    *maxValue = vin[0];
    *maxIndex = 0;
    for (uint16_t i = 1; i < len; i++) {
        if (vin[i] > *maxValue) {
            *maxValue = vin[i];
            *maxIndex = i;
        }
    }
}

void DSP::vector_scale_float(const float* vin, float scale, float* vout, uint16_t len) const
{
    for (uint16_t i = 0; i < len; i++) {
        vout[i] = vin[i] * scale;
    }
}

void DSP::vector_add_float(const float* vin1, const float* vin2, float* vout, uint16_t len) const
{
    for (uint16_t i = 0; i < len; i++) {
        vout[i] = vin1[i] + vin2[i];
    }
}

float DSP::vector_mean_float(const float* vin, uint16_t len) const
{
    float mean_value = 0.0f;
    for (uint16_t i = 0; i < len; i++) {
        mean_value += vin[i];
    }
    mean_value /= len;
    return mean_value;
}

// simple integer log2
static uint16_t fft_log2(uint16_t n)
{
    uint16_t k = n, i = 0;
    while (k) {
        k >>= 1;
        i++;
    }
    return i - 1;
}

// calculate the in-place FFT of the input using the Cooley–Tukey algorithm
// this is a translation of Ron Nicholson's version in http://www.nicholson.com/dsp.fft1.html
void DSP::calculate_fft(complexf *samples, uint16_t fftlen)
{
    uint16_t m = fft_log2(fftlen);
    // shuffle data using bit reversed addressing ***
    for (uint16_t k = 0; k < fftlen; k++) {
        // generate a bit reversed address for samples[k] ***
        uint16_t ki = k, kr = 0;
        for (uint16_t i=1; i<=m; i++) {
            kr <<= 1; //  left shift result kr by 1 bit
            if (ki % 2 == 1) {
                kr++;
            }
            ki >>= 1; // right shift temp ki by 1 bit
        }
        // swap data samples[k] to bit reversed address samples[kr]
        if (kr > k) {
            complexf t = samples[kr];
            samples[kr] = samples[k];
            samples[k] = t;
        }
    }

    // do fft butterflys in place
    uint16_t istep = 2;
    while (istep <= fftlen) {// layers 2,4,8,16, ... ,n
        uint16_t is2 = istep / 2;
        uint16_t astep = fftlen / istep;
        for (uint16_t km = 0; km < is2; km++) { // outer row loop
            uint16_t a  = km * astep; // twiddle angle index
            complexf w(sinf(2 * M_PI * (a+(fftlen/4)) / fftlen), sinf(2 * M_PI * a / fftlen));
            for (uint16_t ki = 0; ki <= (fftlen - istep); ki += istep) { // inner column loop
                uint16_t i = km + ki;
                uint16_t j = is2 + i;
                complexf t = w * samples[j];
                complexf q = samples[i];
                samples[j] = q - t;
                samples[i] = q + t;
            }
        }
        istep <<= 1;
    }
}

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             /*
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

/* 
   Graupner Hott Telemetry library
   Hott telemetry runs at 19200 8N1 on a non-inverted half-duplex UART

   With thanks to Graupner and betaflight
*/

#include "AP_Hott_Telem.h"

#if HAL_HOTT_TELEM_ENABLED

#include <AP_AHRS/AP_AHRS.h>
#include <AP_BattMonitor/AP_BattMonitor.h>
#include <AP_Baro/AP_Baro.h>
#include <AP_RPM/AP_RPM.h>
#include <AP_Airspeed/AP_Airspeed.h>
#include <AP_Stats/AP_Stats.h>
#include <AP_GPS/AP_GPS.h>
#include <AP_RTC/AP_RTC.h>
#include <AP_Notify/AP_Notify.h>
#include <AP_Mission/AP_Mission.h>
#include <AP_SerialManager/AP_SerialManager.h>
#include <stdio.h>

#define PROT_BINARY   0x80
#define PROT_ID_GAM   0x8D
#define PROT_ID_EAM   0x8E
#define PROT_ID_GPS   0x8A
#define PROT_ID_VARIO 0x89

#define BYTE_DELAY_FIRST_US 4000
#define BYTE_DELAY_US 1200

extern const AP_HAL::HAL& hal;

AP_Hott_Telem *AP_Hott_Telem::singleton;

AP_Hott_Telem::AP_Hott_Telem(void)
{
#if CONFIG_HAL_BOARD == HAL_BOARD_SITL
    if (singleton != nullptr) {
        AP_HAL::panic("AP_Hott_Telem must be singleton");
    }
#endif
    singleton = this;
}

/*
 * initialise uart
 */
void AP_Hott_Telem::init()
{
    const AP_SerialManager &serial_manager = AP::serialmanager();

    uart = serial_manager.find_serial(AP_SerialManager::SerialProtocol_Hott, 0);
    if (uart) {
        // register thread
        if (!hal.scheduler->thread_create(FUNCTOR_BIND_MEMBER(&AP_Hott_Telem::loop, void),
                                          "Hott",
                                          1024, AP_HAL::Scheduler::PRIORITY_BOOST, 1)) {
            DEV_PRINTF("Failed to create Hott thread\n");
        }
    }
}

/*
  send EAM (Electric Air Model)
 */
void AP_Hott_Telem::send_EAM(void)
{
    // EAM message
    struct PACKED {
        uint8_t start_byte = 0x7C;   //#01 start uint8_t
        uint8_t eam_sensor_id = 0x8E;//#02 EAM sensort id. constat value 0x8e
        uint8_t warning_beeps;
        uint8_t sensor_id = 0xE0;
        uint16_t alarms;             //#05 alarm bitmask. Value is displayed inverted
        uint8_t cell_low[7];         //#07 cell voltage lower value. 0.02V steps, 124=2.48V
        uint8_t cell_high[7];        //#14 cell voltage high value. 0.02V steps, 124=2.48V
        uint16_t batt1_voltage;      //#21 battery 1 voltage in 100mv steps
        uint16_t batt2_voltage;      //#23 battery 2 voltage in 100mv steps
        uint8_t temp1;               //#25 Temperature sensor 1. 20=0C, 46=26C - offset of 20.
        uint8_t temp2;               //#26 temperature sensor 2
        uint16_t altitude;           //#27 Attitude unit: meters. Value of 500 = 0m
        uint16_t current;            //#29 Current in 0.1A steps
        uint16_t main_voltage;       //#31 Main power voltage (drive) in 0.1V steps
        uint16_t batt_used;          //#33 used battery capacity in 10mAh steps
        uint16_t climbrate;          //#35 climb rate in 0.01m/s. Value of 30000 = 0.00 m/s
        uint8_t climbrate3s;         //#37 climbrate in m/3sec. Value of 120 = 0m/3sec
        uint16_t rpm;                //#38 RPM. Steps: 10 rev/min
        uint8_t electric_min;        //#40 Electric minutes. Time starts when motor current is > 3 A
        uint8_t electric_sec;        //#41
        uint16_t speed;               //#42 speed in km/h. Steps 1km/h
        uint8_t stop_byte = 0x7D;     //#44 stop
    } msg {};

#if AP_BATTERY_ENABLED
    const AP_BattMonitor &battery = AP::battery();
    if (battery.num_instances() > 0) {
        msg.batt1_voltage = uint16_t(battery.voltage(0) * 10);
    }
    if (battery.num_instances() > 1) {
        msg.batt2_voltage = uint16_t(battery.voltage(1) * 10);
    }
    float current;
    if (battery.current_amps(current)) {
        msg.current = uint16_t(current * 10);
    }
    msg.main_voltage = uint16_t(battery.voltage() * 10);
    float used_mah;
    if (battery.consumed_mah(used_mah)) {
        msg.batt_used = used_mah * 0.1;
    }
#endif  // AP_BATTERY_ENABLED

    const AP_Baro &baro = AP::baro();
    msg.temp1 = uint8_t(baro.get_temperature(0) + 20.5);
#if BARO_MAX_INSTANCES > 1
    if (baro.healthy(1)) {
        msg.temp2 = uint8_t(baro.get_temperature(1) + 20.5);
    }
#endif

    AP_AHRS &ahrs = AP::ahrs();
    float alt = 0;
    Vector3f vel;
    {
        WITH_SEMAPHORE(ahrs.get_semaphore());
        ahrs.get_relative_position_D_home(alt);
        alt = -alt;
        IGNORE_RETURN(ahrs.get_velocity_NED(vel));
    }
    msg.altitude = uint16_t(500.5 + alt);

    msg.climbrate = uint16_t(30000.5 + vel.z * -100);
    msg.climbrate3s = 120 + vel.z * -3;

#if AP_RPM_ENABLED
    const AP_RPM *rpm = AP::rpm();
    float rpm_value;
    if (rpm && rpm->get_rpm(0, rpm_value)) {
        msg.rpm = rpm_value * 0.1;
    }
#endif

    AP_Stats *stats = AP::stats();
    if (stats) {
        uint32_t t = stats->get_flight_time_s();
        msg.electric_min = t / 60U;
        msg.electric_sec = t % 60U;
    }

#if AP_AIRSPEED_ENABLED
    AP_Airspeed *airspeed = AP_Airspeed::get_singleton();
    if (airspeed && airspeed->healthy()) {
        msg.speed = uint16_t(airspeed->get_airspeed() * 3.6 + 0.5);
    } else {
        WITH_SEMAPHORE(ahrs.get_semaphore());
        msg.speed = uint16_t(ahrs.groundspeed() * 3.6 + 0.5);
    }
#else
    WITH_SEMAPHORE(ahrs.get_semaphore());
    msg.speed = uint16_t(ahrs.groundspeed() * 3.6 + 0.5);
#endif

    send_packet((const uint8_t *)&msg, sizeof(msg));
}

/*
  convert from a GPS lat/lon in decimal degrees to degrees plus decimal minutes
 */
void AP_Hott_Telem::GPS_to_DDM(float decimal, uint8_t &sign, uint16_t &dm, uint16_t &sec) const
{
    sign = decimal>=0?0:1;
    decimal = fabsf(decimal);
    uint8_t deg = uint16_t(decimal);
    uint8_t min = uint16_t((decimal - deg) * 60);
    dm = deg*100 + min;
    sec = (decimal - (deg + min/60.0)) * 60 * 10000 + 0.5;
}

/*
  send GPS packet
 */
void AP_Hott_Telem::send_GPS(void)
{
    // GPS message
    struct PACKED {
        uint8_t start_byte = 0x7c;    //#01 constant value 0x7c
        uint8_t gps_sensor_id = 0x8a; //#02 constant value 0x8a
        uint8_t warning_beeps;        //#03
        uint8_t sensor_id = 0xA0;     //#04 constant (?) value 0xa0
        uint16_t alarm;               //#05
        uint8_t flight_direction;     //#07 flight direction in 2 degreees/step (1 = 2degrees);
        uint16_t gps_speed_kmh;       //#08 km/h
        uint8_t pos_NS;               //#10 north = 0, south = 1
        uint16_t pos_NS_dm;           //#11 degree minutes
        uint16_t pos_NS_sec;          //#13 position seconds
        uint8_t pos_EW;               //#15 east = 0, west = 1
        uint16_t pos_EW_dm;           //#16 degree minutes
        uint16_t pos_EW_sec;          //#18 position seconds
        uint16_t home_distance;       //#20 meters
        uint16_t altitude;            //#22 meters. Value of 500 = 0m
        uint16_t climbrate;           //#24 m/s 0.01m/s resolution. Value of 30000 = 0.00 m/s
        uint8_t climbrate3s;          //#26 climbrate in m/3s resolution, value of 120 = 0 m/3s
        uint8_t gps_satelites;        //#27 sat count
        uint8_t gps_fix_char;         //#28 GPS fix character. display, 'D' = DGPS, '2' = 2D, '3' = 3D, '-' = no fix
        uint8_t home_direction;       //#29 direction from starting point to Model position (2 degree steps)
        int16_t vel_north;            //#30 velocity north mm/s
        uint8_t speed_acc;            //#32 speed accuracy cm/s
        uint8_t gps_time_h;           //#33 UTC time hours
        uint8_t gps_time_m;           //#34 UTC time minutes
        uint8_t gps_time_s;           //#35 UTC time seconds
        uint8_t gps_time_hs;          //#36 UTC time 0.01s units
        int16_t vel_east;             //#37 velocity north mm/s
        uint8_t horiz_acc;            //#39 horizontal accuracy
        uint8_t free_char1;           //#40 displayed to right of home
        uint8_t free_char2;           //#41
        uint8_t free_char3;           //#42 GPS fix character. display, 'D' = DGPS, '2' = 2D, '3' = 3D, '-' = no fix
        uint8_t version = 1;          //#43 0: GPS Graupner #33600, 1: ArduPilot
        uint8_t stop_byte = 0x7d;     //#44
    } msg {};

    AP_GPS &gps = AP::gps();
    Location loc;

    {
        WITH_SEMAPHORE(gps.get_semaphore());
        loc = gps.location();
        msg.flight_direction = uint16_t(gps.ground_course() * 0.5 + 0.5);
        msg.gps_speed_kmh = uint16_t(gps.ground_speed() * 3.6 + 0.5);
        float sacc, hacc;
        if (gps.speed_accuracy(sacc)) {
            msg.speed_acc = sacc * 100 + 0.5;
        }
        if (gps.horizontal_accuracy(hacc)) {
            msg.horiz_acc = hacc * 100 + 0.5;
        }
        msg.gps_satelites = gps.num_sats();
    }

    float lat = loc.lat * 1.0e-7;
    float lon = loc.lng * 1.0e-7;

    uint16_t dm, sec;
    GPS_to_DDM(lat, msg.pos_NS, dm, sec);
    msg.pos_NS_dm = dm;
    msg.pos_NS_sec = sec;

    GPS_to_DDM(lon, msg.pos_EW, dm, sec);
    msg.pos_EW_dm = dm;
    msg.pos_EW_sec = sec;

    AP_AHRS &ahrs = AP::ahrs();
    Vector2f home_vec;
    float alt = 0;
    Vector3f vel;
    {
        WITH_SEMAPHORE(ahrs.get_semaphore());
        if (ahrs.get_relative_position_NE_home(home_vec)) {
            msg.home_distance = home_vec.length();
        }
        ahrs.get_relative_position_D_home(alt);
        alt = -alt;
        IGNORE_RETURN(ahrs.get_velocity_NED(vel));
    }

    msg.climbrate = uint16_t(30000.5 + vel.z * -100);
    msg.climbrate3s = 120 + vel.z * -3;
    msg.vel_north = vel.x * 1000 + 0.5;
    msg.vel_east = vel.y * 1000 + 0.5;
    msg.altitude = uint16_t(500.5 + alt);

    msg.gps_fix_char = gps.status_onechar();
    msg.free_char3 = msg.gps_fix_char;

    msg.home_direction = degrees(atan2f(home_vec.y, home_vec.x)) * 0.5 + 0.5;

#if AP_RTC_ENABLED
    AP_RTC &rtc = AP::rtc();
    {
        WITH_SEMAPHORE(rtc.get_semaphore());
        uint16_t ms;
        rtc.get_system_clock_utc(msg.gps_time_h, msg.gps_time_m, msg.gps_time_s, ms);
    }
#endif

    send_packet((const uint8_t *)&msg, sizeof(msg));
}

/*
  send Vario
 */
void AP_Hott_Telem::send_Vario(void)
{
    // Vario message
    struct PACKED {
        uint8_t start_byte = 0x7C;   //#01 start uint8_t
        uint8_t vario_id = 0x89;     //#02 ID
        uint8_t warning_beeps;       //#03 warnings
        uint8_t sensor_id = 0x90;    //#04 sensor ID
        uint8_t inv_status;          //#05 status
        uint16_t altitude;           //#06 Attitude meters. Value of 500 = 0m
        uint16_t altitude_max;       //#08 Attitude max meters. Value of 500 = 0m
        uint16_t altitude_min;       //#10 Attitude min meters. Value of 500 = 0m
        uint16_t climbrate;          //#12 climb rate in 0.01m/s. Value of 30000 = 0.00 m/s
        uint16_t climbrate3s;        //#14 climb rate in meters per 3s Value of 30000 = 0.00 m/s
        uint16_t climbrate10s;       //#16 climb rate in meters per 10s. Value of 30000 = 0.00 m/s
        char     text[3][7];         //#18 #Text display
        char     ascii3[3];          //#39 3 extra characters
        uint8_t  yaw;                //#42 yaw in 2 degree units, 0 = north
        uint8_t  version = 1;        //#43 protocol version
        uint8_t  stop_byte = 0x7D;   //#44 stop
    } msg {};

    AP_AHRS &ahrs = AP::ahrs();
    Vector3f vel;
    float alt = 0;
    {
        WITH_SEMAPHORE(ahrs.get_semaphore());
        ahrs.get_relative_position_D_home(alt);
        alt = -alt;
        IGNORE_RETURN(ahrs.get_velocity_NED(vel));
        msg.yaw = wrap_360_cd(ahrs.yaw_sensor) * 0.005;
    }

    min_alt = MIN(alt, min_alt);
    max_alt = MAX(alt, max_alt);

    msg.altitude = uint16_t(500.5 + alt);
    msg.altitude_max = uint16_t(500.5 + max_alt);
    msg.altitude_min = uint16_t(500.5 + min_alt);

    msg.climbrate = 30000.5 + vel.z * -100;
    msg.climbrate3s = 30000.5 + vel.z * -100*3;
    msg.climbrate10s = 30000.5 + vel.z * -100*10;
    
    AP_Notify *notify = AP_Notify::get_singleton();
    char fltmode[5] {};
    if (notify) {
        strncpy(fltmode, notify->get_flight_mode_str(), sizeof(fltmode));
        strncpy(msg.text[0], fltmode, sizeof(msg.text[0]));
    }
    if (hal.util->get_soft_armed()) {
        strncpy(msg.text[1], "ARMED", sizeof(msg.text[1]));
        if (strncmp(fltmode, "AUTO", sizeof(fltmode)) == 0) {
            const AP_Mission *mission = AP::mission();
            if (mission) {
                char wp[10] {};
                snprintf(wp, sizeof(wp), "WP %3u", mission->get_current_nav_index());
                memcpy(msg.text[2], wp, sizeof(msg.text[2]));
            }
        }
    } else {
        strncpy(msg.text[1], "DISARM", sizeof(msg.text[1]));
        const char *ck = AP_Notify::flags.pre_arm_check ? "CK:PASS" : "CK:FAIL";
        memcpy(msg.text[2], ck, MIN(strlen(ck), sizeof(msg.text[2])));
    }

    send_packet((const uint8_t *)&msg, sizeof(msg));
}

/*
  send a packet out
 */
void AP_Hott_Telem::send_packet(const uint8_t *b, uint8_t len)
{
    // initial delay
    hal.scheduler->delay_microseconds(BYTE_DELAY_FIRST_US);
    uint8_t crc = 0;
    while (len) {
        uint8_t ob = *b;
        if (uart->write(ob) == 1) {
            len--;
            crc += ob;
            b++;
            hal.scheduler->delay_microseconds(BYTE_DELAY_US);
        } else {
            hal.scheduler->delay_microseconds(100);
        }
    }
    uart->write(crc);

    // discard any bytes received during the send
    hal.scheduler->delay_microseconds(BYTE_DELAY_US*2);
    while (uart->available() != 0) {
        uart->read();
        hal.scheduler->delay_microseconds(100);
    }
}

/*
  thread to process requests
 */
void AP_Hott_Telem::loop(void)
{
    uart->begin(19200, 10, 10);
    uart->set_unbuffered_writes(true);

    while (true) {
        hal.scheduler->delay_microseconds(1500);
        uint32_t n = uart->available();
        if (n < 2) {
            // wait for 2 bytes
            continue;
        }
        if (n > 2) {
            uart->discard_input();
            continue;
        }

        const uint8_t prot_type = uart->read();
        const uint8_t sensor_id = uart->read();
        if (prot_type != PROT_BINARY) {
            // only do binary protocol for now
            continue;
        }

        switch (sensor_id) {
        case PROT_ID_EAM:
            send_EAM();
            break;
        case PROT_ID_GPS:
            send_GPS();
            break;
        case PROT_ID_VARIO:
            send_Vario();
            break;
        }
    }
}

namespace AP {
    AP_Hott_Telem *hott_telem() {
        return AP_Hott_Telem::get_singleton();
    }
};

#endif // HAL_HOTT_TELEM_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               /*
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/
#pragma once

#include <AP_HAL/AP_HAL.h>

#ifndef HAL_HOTT_TELEM_ENABLED
#define HAL_HOTT_TELEM_ENABLED BOARD_FLASH_SIZE > 2048
#endif

#if HAL_HOTT_TELEM_ENABLED
class AP_Hott_Telem {
public:
    AP_Hott_Telem();

    /* Do not allow copies */
    CLASS_NO_COPY(AP_Hott_Telem);

    static AP_Hott_Telem *get_singleton(void) {
        return singleton;
    }

    // initialise
    void init(void);

private:
    static AP_Hott_Telem *singleton;

    AP_HAL::UARTDriver *uart;

    void loop(void);
    void send_EAM();
    void send_GPS();
    void send_Vario();
    void send_packet(const uint8_t *b, uint8_t len);
    void GPS_to_DDM(float decimal, uint8_t &sign, uint16_t &dm, uint16_t &sec) const;

    float min_alt, max_alt;
};

namespace AP {
    AP_Hott_Telem *hott_telem();
};
#endif // HAL_HOTT_TELEM_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   