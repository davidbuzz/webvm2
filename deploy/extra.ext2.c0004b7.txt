uff[param]
            if isinstance(wanted_value, tuple):
                max_delta = wanted_value[1]
                wanted_value = wanted_value[0]
            if abs(fetched_value - wanted_value) > max_delta:
                bad += "%s=%f (want=%f +/-%f)    " % (param, fetched_value, wanted_value, max_delta)
        if len(bad):
            raise NotAchievedException("Bad parameter values: %s" %
                                       (bad,))

    #################################################
    # UTILITIES
    #################################################
    def lineno(self):
        '''return line number'''
        frameinfo = getframeinfo(currentframe().f_back)
        # print(frameinfo.filename, frameinfo.lineno)
        return frameinfo.lineno

    @staticmethod
    def longitude_scale(lat):
        ret = math.cos(lat * (math.radians(1)))
        print("scale=%f" % ret)
        return ret

    @staticmethod
    def get_distance(loc1, loc2):
        """Get ground distance between two locations."""
        return TestSuite.get_distance_accurate(loc1, loc2)
        # dlat = loc2.lat - loc1.lat
        # try:
        #     dlong = loc2.lng - loc1.lng
        # except AttributeError:
        #     dlong = loc2.lon - loc1.lon

        # return math.sqrt((dlat*dlat) + (dlong*dlong)*TestSuite.longitude_scale(loc2.lat)) * 1.113195e5

    @staticmethod
    def get_distance_accurate(loc1, loc2):
        """Get ground distance between two locations."""
        try:
            lon1 = loc1.lng
            lon2 = loc2.lng
        except AttributeError:
            lon1 = loc1.lon
            lon2 = loc2.lon

        return mp_util.gps_distance(loc1.lat, lon1, loc2.lat, lon2)

    def assert_distance(self, loc1, loc2, min_distance, max_distance):
        dist = self.get_distance_accurate(loc1, loc2)
        if dist < min_distance or dist > max_distance:
            raise NotAchievedException("Expected distance %f to be between %f and %f" %
                                       (dist, min_distance, max_distance))
        self.progress("Distance %f is between %f and %f" %
                      (dist, min_distance, max_distance))

    @staticmethod
    def get_latlon_attr(loc, attrs):
        '''return any found latitude attribute from loc'''
        ret = None
        for attr in attrs:
            if hasattr(loc, attr):
                ret = getattr(loc, attr)
                break
        if ret is None:
            raise ValueError("None of %s in loc(%s)" % (str(attrs), str(loc)))
        return ret

    @staticmethod
    def get_lat_attr(loc):
        '''return any found latitude attribute from loc'''
        return TestSuite.get_latlon_attr(loc, ["lat", "latitude"])

    @staticmethod
    def get_lon_attr(loc):
        '''return any found latitude attribute from loc'''
        return TestSuite.get_latlon_attr(loc, ["lng", "lon", "longitude"])

    @staticmethod
    def get_distance_int(loc1, loc2):
        """Get ground distance between two locations in the normal "int" form
        - lat/lon multiplied by 1e7"""
        loc1_lat = TestSuite.get_lat_attr(loc1)
        loc2_lat = TestSuite.get_lat_attr(loc2)
        loc1_lon = TestSuite.get_lon_attr(loc1)
        loc2_lon = TestSuite.get_lon_attr(loc2)

        return TestSuite.get_distance_accurate(
            mavutil.location(loc1_lat*1e-7, loc1_lon*1e-7),
            mavutil.location(loc2_lat*1e-7, loc2_lon*1e-7))

        # dlat = loc2_lat - loc1_lat
        # dlong = loc2_lon - loc1_lon
        #
        # dlat /= 10000000.0
        # dlong /= 10000000.0
        #
        # return math.sqrt((dlat*dlat) + (dlong*dlong)) * 1.113195e5

    def bearing_to(self, loc):
        '''return bearing from here to location'''
        here = self.mav.location()
        return self.get_bearing(here, loc)

    @staticmethod
    def get_bearing(loc1, loc2):
        """Get bearing from loc1 to loc2."""
        off_x = loc2.lng - loc1.lng
        off_y = loc2.lat - loc1.lat
        bearing = 90.00 + math.atan2(-off_y, off_x) * 57.2957795
        if bearing < 0:
            bearing += 360.00
        return bearing

    def send_cmd_do_set_mode(self, mode):
        self.send_cmd(
            mavutil.mavlink.MAV_CMD_DO_SET_MODE,
            p1=mavutil.mavlink.MAV_MODE_FLAG_CUSTOM_MODE_ENABLED,
            p2=self.get_mode_from_mode_mapping(mode),
        )

    def assert_mode(self, mode):
        self.wait_mode(mode, timeout=0)

    def change_mode(self, mode, timeout=60):
        '''change vehicle flightmode'''
        self.wait_heartbeat()
        self.progress("Changing mode to %s" % mode)
        self.send_cmd_do_set_mode(mode)
        tstart = self.get_sim_time()
        while not self.mode_is(mode):
            custom_num = self.mav.messages['HEARTBEAT'].custom_mode
            self.progress("mav.flightmode=%s Want=%s custom=%u" % (
                self.mav.flightmode, mode, custom_num))
            if (timeout is not None and
                    self.get_sim_time_cached() > tstart + timeout):
                raise WaitModeTimeout("Did not change mode")
            self.send_cmd_do_set_mode(mode)
        self.progress("Got mode %s" % mode)

    def capable(self, capability):
        return self.get_autopilot_capabilities() & capability

    def assert_capability(self, capability):
        if not self.capable(capability):
            name = mavutil.mavlink.enums["MAV_PROTOCOL_CAPABILITY"][capability].name
            raise NotAchievedException("AutoPilot does not have capbility %s" % (name,))

    def assert_no_capability(self, capability):
        if self.capable(capability):
            name = mavutil.mavlink.enums["MAV_PROTOCOL_CAPABILITY"][capability].name
            raise NotAchievedException("AutoPilot has feature %s (when it shouln't)" % (name,))

    def get_autopilot_capabilities(self):
        # Cannot use run_cmd otherwise the respond is lost during the wait for ACK
        self.mav.mav.command_long_send(self.sysid_thismav(),
                                       1,
                                       mavutil.mavlink.MAV_CMD_REQUEST_AUTOPILOT_CAPABILITIES,
                                       0,  # confirmation
                                       1,  # 1: Request autopilot version
                                       0,
                                       0,
                                       0,
                                       0,
                                       0,
                                       0)
        m = self.assert_receive_message('AUTOPILOT_VERSION', timeout=10)
        return m.capabilities

    def decode_flight_sw_version(self, flight_sw_version: int):
        """ Decode 32 bit flight_sw_version mavlink parameter
        corresponds to encoding in ardupilot GCS_MAVLINK::send_autopilot_version."""
        fw_type_id = (flight_sw_version >> 0) % 256
        patch = (flight_sw_version >> 8) % 256
        minor = (flight_sw_version >> 16) % 256
        major = (flight_sw_version >> 24) % 256
        if fw_type_id == 0:
            fw_type = "dev"
        elif fw_type_id == 64:
            fw_type = "alpha"
        elif fw_type_id == 128:
            fw_type = "beta"
        elif fw_type_id == 192:
            fw_type = "rc"
        elif fw_type_id == 255:
            fw_type = "official"
        else:
            fw_type = "undefined"
        return major, minor, patch, fw_type

    def get_autopilot_firmware_version(self):
        self.mav.mav.command_long_send(self.sysid_thismav(),
                                       1,
                                       mavutil.mavlink.MAV_CMD_REQUEST_AUTOPILOT_CAPABILITIES,
                                       0,  # confirmation
                                       1,  # 1: Request autopilot version
                                       0,
                                       0,
                                       0,
                                       0,
                                       0,
                                       0)
        m = self.assert_receive_message('AUTOPILOT_VERSION', timeout=10)
        self.fcu_firmware_version = self.decode_flight_sw_version(m.flight_sw_version)

        def hex_values_to_int(hex_values):
            # Convert ascii codes to characters
            hex_chars = [chr(int(hex_value)) for hex_value in hex_values]
            # Convert hex characters to integers, handle \x00 case
            int_values = [0 if hex_char == '\x00' else int(hex_char, 16) for hex_char in hex_chars]
            return int_values

        fcu_hash_to_hex = ""
        for i in hex_values_to_int(m.flight_custom_version):
            fcu_hash_to_hex += f"{i:x}"
        self.fcu_firmware_hash = fcu_hash_to_hex
        self.progress(f"Firmware Version {self.fcu_firmware_version}")
        self.progress(f"Firmware hash {self.fcu_firmware_hash}")
        self.githash = util.get_git_hash(short=True)
        self.progress(f"Git hash {self.githash}")

    def GetCapabilities(self):
        '''Get Capabilities'''
        self.assert_capability(mavutil.mavlink.MAV_PROTOCOL_CAPABILITY_PARAM_FLOAT)
        self.assert_capability(mavutil.mavlink.MAV_PROTOCOL_CAPABILITY_COMPASS_CALIBRATION)

    def get_mode_from_mode_mapping(self, mode):
        """Validate and return the mode number from a string or int."""
        if isinstance(mode, int):
            return mode
        mode_map = self.mav.mode_mapping()
        if mode_map is None:
            mav_type = self.mav.messages['HEARTBEAT'].type
            mav_autopilot = self.mav.messages['HEARTBEAT'].autopilot
            raise ErrorException("No mode map for (mav_type=%s mav_autopilot=%s)" % (mav_type, mav_autopilot))
        if isinstance(mode, str):
            if mode in mode_map:
                return mode_map.get(mode)
        if mode in mode_map.values():
            return mode
        self.progress("No mode (%s); available modes '%s'" % (mode, mode_map))
        raise ErrorException("Unknown mode '%s'" % mode)

    def get_mode_string_for_mode(self, mode):
        if isinstance(mode, str):
            return mode
        mode_map = self.mav.mode_mapping()
        if mode_map is None:
            return f"mode={mode}"
        for (n, v) in mode_map.items():
            if v == mode:
                return n
        self.progress(f"No mode ({mode} {type(mode)}); available modes '{mode_map}'")
        raise ErrorException("Unknown mode '%s'" % mode)

    def run_cmd_do_set_mode(self,
                            mode,
                            timeout=30,
                            run_cmd=None,
                            want_result=mavutil.mavlink.MAV_RESULT_ACCEPTED):
        if run_cmd is None:
            run_cmd = self.run_cmd
        base_mode = mavutil.mavlink.MAV_MODE_FLAG_CUSTOM_MODE_ENABLED
        custom_mode = self.get_mode_from_mode_mapping(mode)
        run_cmd(
            mavutil.mavlink.MAV_CMD_DO_SET_MODE,
            p1=base_mode,
            p2=custom_mode,
            want_result=want_result,
            timeout=timeout,
        )

    def do_set_mode_via_command_XYZZY(self, mode, run_cmd, timeout=30):
        """Set mode with a command long message."""
        tstart = self.get_sim_time()
        want_custom_mode = self.get_mode_from_mode_mapping(mode)
        while True:
            remaining = timeout - (self.get_sim_time_cached() - tstart)
            if remaining <= 0:
                raise AutoTestTimeoutException("Failed to change mode")
            self.run_cmd_do_set_mode(mode, run_cmd=run_cmd, timeout=10)
            m = self.wait_heartbeat()
            self.progress("Got mode=%u want=%u" % (m.custom_mode, want_custom_mode))
            if m.custom_mode == want_custom_mode:
                return

    def do_set_mode_via_command_long(self, mode, timeout=30):
        self.do_set_mode_via_command_XYZZY(mode, self.run_cmd, timeout=timeout)

    def do_set_mode_via_command_int(self, mode, timeout=30):
        self.do_set_mode_via_command_XYZZY(mode, self.run_cmd_int, timeout=timeout)

    def mavproxy_do_set_mode_via_command_long(self, mavproxy, mode, timeout=30):
        """Set mode with a command long message with Mavproxy."""
        base_mode = mavutil.mavlink.MAV_MODE_FLAG_CUSTOM_MODE_ENABLED
        custom_mode = self.get_mode_from_mode_mapping(mode)
        tstart = self.get_sim_time()
        while True:
            remaining = timeout - (self.get_sim_time_cached() - tstart)
            if remaining <= 0:
                raise AutoTestTimeoutException("Failed to change mode")
            mavproxy.send("long DO_SET_MODE %u %u\n" %
                          (base_mode, custom_mode))
            m = self.wait_heartbeat()
            if m.custom_mode == custom_mode:
                return True

    def reach_heading_manual(self, heading, turn_right=True):
        """Manually direct the vehicle to the target heading."""
        if self.is_copter() or self.is_sub():
            self.set_rc(4, 1580)
            self.wait_heading(heading)
            self.set_rc(4, 1500)
        if self.is_plane():
            self.set_rc(1, 1800)
            self.wait_heading(heading)
            self.set_rc(1, 1500)
        if self.is_rover():
            steering_pwm = 1700
            if not turn_right:
                steering_pwm = 1300
            self.set_rc(1, steering_pwm)
            self.set_rc(3, 1550)
            self.wait_heading(heading)
            self.set_rc(3, 1500)
            self.set_rc(1, 1500)

    def assert_vehicle_location_is_at_startup_location(self, dist_max=1):
        here = self.mav.location()
        start_loc = self.sitl_start_location()
        dist = self.get_distance(here, start_loc)
        data = "dist=%f max=%f (here: %s start-loc: %s)" % (dist, dist_max, here, start_loc)

        if dist > dist_max:
            raise NotAchievedException("Far from startup location: %s" % data)
        self.progress("Close to startup location: %s" % data)

    def assert_simstate_location_is_at_startup_location(self, dist_max=1):
        simstate_loc = self.sim_location()
        start_loc = self.sitl_start_location()
        dist = self.get_distance(simstate_loc, start_loc)
        data = "dist=%f max=%f (simstate: %s start-loc: %s)" % (dist, dist_max, simstate_loc, start_loc)

        if dist > dist_max:
            raise NotAchievedException("simstate far from startup location: %s" % data)
        self.progress("Simstate Close to startup location: %s" % data)

    def reach_distance_manual(self, distance):
        """Manually direct the vehicle to the target distance from home."""
        if self.is_copter():
            self.set_rc(2, 1350)
            self.wait_distance(distance, accuracy=5, timeout=60)
            self.set_rc(2, 1500)
        if self.is_plane():
            self.progress("NOT IMPLEMENTED")
        if self.is_rover():
            self.set_rc(3, 1700)
            self.wait_distance(distance, accuracy=2)
            self.set_rc(3, 1500)

    def guided_achieve_heading(self, heading, accuracy=None):
        tstart = self.get_sim_time()
        while True:
            if self.get_sim_time_cached() - tstart > 200:
                raise NotAchievedException("Did not achieve heading")
            self.run_cmd(
                mavutil.mavlink.MAV_CMD_CONDITION_YAW,
                p1=heading,  # target angle
                p2=10,  # degrees/second
                p3=1,  # -1 is counter-clockwise, 1 clockwise
                p4=0,  # 1 for relative, 0 for absolute
            )
            m = self.mav.recv_match(type='VFR_HUD', blocking=True)
            self.progress("heading=%d want=%d" % (m.heading, int(heading)))
            if accuracy is not None:
                delta = abs(m.heading - int(heading))
                if delta <= accuracy:
                    return
            if m.heading == int(heading):
                return

    def assert_heading(self, heading, accuracy=1):
        '''assert vehicle yaw is to heading (0-360)'''
        m = self.assert_receive_message('VFR_HUD')
        if self.heading_delta(heading, m.heading) > accuracy:
            raise NotAchievedException("Unexpected heading=%f want=%f" %
                                       (m.heading, heading))

    def do_set_relay(self, relay_num, on_off, timeout=10):
        """Set relay with a command long message."""
        self.progress("Set relay %d to %d" % (relay_num, on_off))
        self.run_cmd(
            mavutil.mavlink.MAV_CMD_DO_SET_RELAY,
            p1=relay_num,
            p2=on_off,
            timeout=timeout,
        )

    def do_set_relay_mavproxy(self, relay_num, on_off):
        """Set relay with mavproxy."""
        self.progress("Set relay %d to %d" % (relay_num, on_off))
        self.mavproxy.send('module load relay\n')
        self.mavproxy.expect("Loaded module relay")
        self.mavproxy.send("relay set %d %d\n" % (relay_num, on_off))

    def do_fence_enable(self, want_result=mavutil.mavlink.MAV_RESULT_ACCEPTED):
        self.run_cmd(mavutil.mavlink.MAV_CMD_DO_FENCE_ENABLE, p1=1, want_result=want_result)

    def do_fence_disable(self, want_result=mavutil.mavlink.MAV_RESULT_ACCEPTED):
        self.run_cmd(mavutil.mavlink.MAV_CMD_DO_FENCE_ENABLE, p1=0, want_result=want_result)

    def do_fence_disable_floor(self, want_result=mavutil.mavlink.MAV_RESULT_ACCEPTED):
        self.run_cmd(mavutil.mavlink.MAV_CMD_DO_FENCE_ENABLE, p1=0, p2=8, want_result=want_result)

    def do_fence_enable_except_floor(self, want_result=mavutil.mavlink.MAV_RESULT_ACCEPTED):
        self.run_cmd(mavutil.mavlink.MAV_CMD_DO_FENCE_ENABLE, p1=1, p2=7, want_result=want_result)

    #################################################
    # WAIT UTILITIES
    #################################################
    def delay_sim_time(self, seconds_to_wait, reason=None):
        """Wait some second in SITL time."""
        tstart = self.get_sim_time()
        tnow = tstart
        r = "Delaying %f seconds"
        if reason is not None:
            r += " for %s" % reason
        self.progress(r % (seconds_to_wait,))
        while tstart + seconds_to_wait > tnow:
            tnow = self.get_sim_time(drain_mav=False)

    def send_terrain_check_message(self):
        here = self.mav.location()
        self.mav.mav.terrain_check_send(int(here.lat * 1e7), int(here.lng * 1e7))

    def get_terrain_height(self, verbose=False):
        self.send_terrain_check_message()
        m = self.assert_receive_message('TERRAIN_REPORT', very_verbose=True)
        return m.terrain_height

    def get_altitude(self, relative=False, timeout=30, altitude_source=None):
        '''returns vehicles altitude in metres, possibly relative-to-home'''
        if altitude_source is None:
            if relative:
                altitude_source = "GLOBAL_POSITION_INT.relative_alt"
            else:
                altitude_source = "GLOBAL_POSITION_INT.alt"
        (msg, field) = altitude_source.split('.')
        msg = self.poll_message(msg, quiet=True)
        divisor = 1000.0  # mm is pretty common in mavlink
        if altitude_source == "SIM_STATE.alt":
            divisor = 1.0
        return getattr(msg, field) / divisor

    def assert_altitude(self, alt, accuracy=1, **kwargs):
        got_alt = self.get_altitude(**kwargs)
        if abs(alt - got_alt) > accuracy:
            raise NotAchievedException("Incorrect alt; want=%f got=%f" %
                                       (alt, got_alt))

    def assert_rangefinder_distance_between(self, dist_min, dist_max):
        m = self.assert_receive_message('RANGEFINDER')

        if m.distance < dist_min:
            raise NotAchievedException("below min height (%f < %f)" %
                                       (m.distance, dist_min))

        if m.distance > dist_max:
            raise NotAchievedException("above max height (%f > %f)" %
                                       (m.distance, dist_max))

    def assert_distance_sensor_quality(self, quality):
        m = self.assert_receive_message('DISTANCE_SENSOR')

        if m.signal_quality != quality:
            raise NotAchievedException("Unexpected quality; want=%f got=%f" %
                                       (quality, m.signal_quality))

    def get_rangefinder_distance(self):
        m = self.assert_receive_message('RANGEFINDER', timeout=5)
        return m.distance

    def wait_rangefinder_distance(self, dist_min, dist_max, timeout=30, **kwargs):
        '''wait for RANGEFINDER distance'''
        def validator(value2, target2=None):
            if dist_min <= value2 <= dist_max:
                return True
            else:
                return False

        self.wait_and_maintain(
            value_name="RageFinderDistance",
            target=dist_min,
            current_value_getter=lambda: self.get_rangefinder_distance(),
            accuracy=(dist_max - dist_min),
            validator=lambda value2, target2: validator(value2, target2),
            timeout=timeout,
            **kwargs
        )

    def get_esc_rpm(self, esc):
        if esc > 4:
            raise ValueError("Only does 1-4")
        m = self.assert_receive_message('ESC_TELEMETRY_1_TO_4', timeout=1, verbose=True)
        return m.rpm[esc-1]

    def find_first_set_bit(self, mask):
        '''returns offset of first-set-bit (counting from right) in mask.  Returns None if no bits set'''
        pos = 0
        while mask != 0:
            if mask & 0x1:
                return pos
            mask = mask >> 1
            pos += 1
        return None

    def get_rpm(self, rpm_sensor):
        m = self.assert_receive_message('RPM')
        if rpm_sensor == 1:
            ret = m.rpm1
        elif rpm_sensor == 2:
            ret = m.rpm2
        else:
            raise ValueError("Bad sensor id")
        if ret < 0.000001:
            # yay filtering!
            return 0
        return ret

    def wait_rpm(self, rpm_sensor, rpm_min, rpm_max, **kwargs):
        '''wait for RPM to be between rpm_min and rpm_max'''
        def validator(value2, target2=None):
            return rpm_min <= value2 <= rpm_max
        self.wait_and_maintain(
            value_name="RPM%u" % rpm_sensor,
            target=(rpm_min+rpm_max)/2.0,
            current_value_getter=lambda: self.get_rpm(rpm_sensor),
            accuracy=rpm_max-rpm_min,
            validator=lambda value2, target2: validator(value2, target2),
            **kwargs
        )

    def wait_esc_telem_rpm(self, esc, rpm_min, rpm_max, **kwargs):
        '''wait for ESC to be between rpm_min and rpm_max'''
        def validator(value2, target2=None):
            return rpm_min <= value2 <= rpm_max
        self.wait_and_maintain(
            value_name="ESC %u RPM" % esc,
            target=(rpm_min+rpm_max)/2.0,
            current_value_getter=lambda: self.get_esc_rpm(esc),
            accuracy=rpm_max-rpm_min,
            validator=lambda value2, target2: validator(value2, target2),
            **kwargs
        )

    def wait_altitude(self, altitude_min, altitude_max, relative=False, timeout=None, **kwargs):
        """Wait for a given altitude range."""
        assert altitude_min <= altitude_max, "Minimum altitude should be less than maximum altitude."

        if timeout is None:
            timeout = 30

        def validator(value2, target2=None):
            if altitude_min <= value2 <= altitude_max:
                return True
            else:
                return False

        altitude_source = kwargs.get("altitude_source", None)

        self.wait_and_maintain(
            value_name="Altitude",
            target=altitude_min,
            current_value_getter=lambda: self.get_altitude(
                relative=relative,
                timeout=timeout,
                altitude_source=altitude_source,
            ),
            accuracy=(altitude_max - altitude_min),
            validator=lambda value2, target2: validator(value2, target2),
            timeout=timeout,
            **kwargs
        )

    def watch_altitude_maintained(self, altitude_min, altitude_max, minimum_duration=5, relative=True, altitude_source=None):
        """Watch altitude is maintained or not between altitude_min and altitude_max during minimum_duration"""
        return self.wait_altitude(
            altitude_min=altitude_min,
            altitude_max=altitude_max,
            relative=relative,
            minimum_duration=minimum_duration,
            timeout=minimum_duration + 1,
            altitude_source=altitude_source,
        )

    def wait_climbrate(self, speed_min, speed_max, timeout=30, **kwargs):
        """Wait for a given vertical rate."""
        assert speed_min <= speed_max, "Minimum speed should be less than maximum speed."

        def get_climbrate(timeout2):
            msg = self.assert_receive_message('VFR_HUD', timeout=timeout2)
            return msg.climb

        def validator(value2, target2=None):
            if speed_min <= value2 <= speed_max:
                return True
            else:
                return False

        self.wait_and_maintain(
            value_name="Climbrate",
            target=speed_min,
            current_value_getter=lambda: get_climbrate(timeout),
            accuracy=(speed_max - speed_min),
            validator=lambda value2, target2: validator(value2, target2),
            timeout=timeout,
            **kwargs
        )

    def groundspeed(self):
        m = self.assert_receive_message('VFR_HUD')
        return m.groundspeed

    def wait_groundspeed(self, speed_min, speed_max, timeout=30, **kwargs):
        self.wait_vfr_hud_speed("groundspeed", speed_min, speed_max, timeout=timeout, **kwargs)

    def wait_airspeed(self, speed_min, speed_max, timeout=30, **kwargs):
        self.wait_vfr_hud_speed("airspeed", speed_min, speed_max, timeout=timeout, **kwargs)

    def wait_vfr_hud_speed(self, field, speed_min, speed_max, timeout=30, **kwargs):
        """Wait for a given ground speed range."""
        assert speed_min <= speed_max, "Minimum speed should be less than maximum speed."

        def get_speed(timeout2):
            msg = self.assert_receive_message('VFR_HUD', timeout=timeout2)
            return getattr(msg, field)

        self.wait_and_maintain_range(
            value_name=field,
            minimum=speed_min,
            maximum=speed_max,
            current_value_getter=lambda: get_speed(timeout),
            validator=None,
            timeout=timeout,
            **kwargs
        )

    def wait_roll(self, roll, accuracy, timeout=30, **kwargs):
        """Wait for a given roll in degrees."""
        def get_roll(timeout2):
            msg = self.assert_receive_message('ATTITUDE', timeout=timeout2)
            p = math.degrees(msg.pitch)
            r = math.degrees(msg.roll)
            self.progress("Roll %d Pitch %d" % (r, p))
            return r

        def validator(value2, target2):
            return math.fabs((value2 - target2 + 180) % 360 - 180) <= accuracy

        self.wait_and_maintain(
            value_name="Roll",
            target=roll,
            current_value_getter=lambda: get_roll(timeout),
            validator=lambda value2, target2: validator(value2, target2),
            accuracy=accuracy,
            timeout=timeout,
            **kwargs
        )

    def wait_pitch(self, pitch, accuracy, timeout=30, **kwargs):
        """Wait for a given pitch in degrees."""
        def get_pitch(timeout2):
            msg = self.assert_receive_message('ATTITUDE', timeout=timeout2)
            p = math.degrees(msg.pitch)
            r = math.degrees(msg.roll)
            self.progress("Pitch %d Roll %d" % (p, r))
            return p

        def validator(value2, target2):
            return math.fabs((value2 - target2 + 180) % 360 - 180) <= accuracy

        self.wait_and_maintain(
            value_name="Pitch",
            target=pitch,
            current_value_getter=lambda: get_pitch(timeout),
            validator=lambda value2, target2: validator(value2, target2),
            accuracy=accuracy,
            timeout=timeout,
            **kwargs
        )

    def wait_and_maintain(self, value_name, target, current_value_getter, validator=None, accuracy=2.0, timeout=30, **kwargs):
        if isinstance(target, Vector3):
            return self.wait_and_maintain_vector(
                value_name,
                target,
                current_value_getter,
                validator,
                timeout=30,
                **kwargs
            )
        return self.wait_and_maintain_range(
            value_name,
            minimum=target - accuracy/2,
            maximum=target + accuracy/2,
            current_value_getter=current_value_getter,
            validator=validator,
            timeout=timeout,
            print_diagnostics_as_target_not_range=True,
            **kwargs
        )

    def wait_and_maintain_vector(self,
                                 value_name,
                                 target,
                                 current_value_getter,
                                 validator,
                                 timeout=30,
                                 **kwargs):
        tstart = self.get_sim_time()
        achieving_duration_start = None
        sum_of_achieved_values = Vector3()
        last_value = Vector3()
        last_fail_print = 0
        count_of_achieved_values = 0
        called_function = kwargs.get("called_function", None)
        minimum_duration = kwargs.get("minimum_duration", 0)
        if minimum_duration >= timeout:
            raise ValueError("minimum_duration >= timeout")

        self.progress("Waiting for %s=(%s)" % (value_name, str(target)))

        last_print_time = 0
        while True:  # if we failed to received message with the getter the sim time isn't updated  # noqa
            now = self.get_sim_time_cached()
            if now - tstart > timeout:
                raise AutoTestTimeoutException(
                    "Failed to attain %s want %s, reached %s" %
                    (value_name,
                     str(target),
                     str(sum_of_achieved_values / count_of_achieved_values) if count_of_achieved_values != 0 else str(last_value)))  # noqa

            last_value = current_value_getter()
            if called_function is not None:
                called_function(last_value, target)
            is_value_valid = validator(last_value, target)
            if self.get_sim_time_cached() - last_print_time > 1:
                if is_value_valid:
                    want_or_got = "got"
                else:
                    want_or_got = "want"
                achieved_duration_bit = ""
                if achieving_duration_start is not None:
                    so_far = self.get_sim_time_cached() - achieving_duration_start
                    achieved_duration_bit = " (maintain=%.1f/%.1f)" % (so_far, minimum_duration)
                    self.progress(
                        "%s=(%s) (%s (%s))%s" %
                        (value_name,
                         str(last_value),
                         want_or_got,
                         str(target),
                         achieved_duration_bit)
                    )
                last_print_time = self.get_sim_time_cached()
            if is_value_valid:
                sum_of_achieved_values += last_value
                count_of_achieved_values += 1.0
                if achieving_duration_start is None:
                    achieving_duration_start = self.get_sim_time_cached()
                if self.get_sim_time_cached() - achieving_duration_start >= minimum_duration:
                    self.progress("Attained %s=%s" % (
                        value_name,
                        str(sum_of_achieved_values * (1.0 / count_of_achieved_values))))
                    return True
            else:
                achieving_duration_start = None
                sum_of_achieved_values.zero()
                count_of_achieved_values = 0
                if now - last_fail_print > 1:
                    self.progress("Waiting for (%s), got %s" %
                                  (target, last_value))
                    last_fail_print = now

    def validate_kwargs(self, kwargs, valid={}):
        for key in kwargs:
            if key not in valid:
                raise NotAchievedException("Invalid kwarg %s" % str(key))

    def wait_and_maintain_range(self,
                                value_name,
                                minimum,
                                maximum,
                                current_value_getter,
                                validator=None,
                                value_averager=None,
                                timeout=30,
                                print_diagnostics_as_target_not_range=False,
                                **kwargs):
        self.validate_kwargs(kwargs, valid=frozenset([
            "called_function",
            "minimum_duration",
            "altitude_source",
        ]))

        if print_diagnostics_as_target_not_range:
            target = (minimum + maximum) / 2
            accuracy = (maximum - minimum) / 2
        tstart = self.get_sim_time()
        achieving_duration_start = None
        sum_of_achieved_values = 0.0
        last_value = 0.0
        count_of_achieved_values = 0
        called_function = kwargs.get("called_function", None)
        minimum_duration = kwargs.get("minimum_duration", 0)
        if minimum_duration >= timeout:
            raise ValueError("minimum_duration >= timeout")
        if print_diagnostics_as_target_not_range:
            self.progress("Waiting for %s=%.02f with accuracy %.02f" % (value_name, target, accuracy))
        else:
            self.progress("Waiting for %s between (%s) and (%s)" % (value_name, str(minimum), str(maximum)))
        last_print_time = 0
        while self.get_sim_time_cached() < tstart + timeout:  # if we failed to received message with the getter the sim time isn't updated  # noqa
            last_value = current_value_getter()
            if called_function is not None:
                if print_diagnostics_as_target_not_range:
                    called_function(last_value, target)
                else:
                    called_function(last_value, minimum, maximum)
            if validator is not None:
                if print_diagnostics_as_target_not_range:
                    is_value_valid = validator(last_value, target)
                else:
                    is_value_valid = validator(last_value, minimum, maximum)
            else:
                is_value_valid = (minimum <= last_value) and (last_value <= maximum)
            if self.get_sim_time_cached() - last_print_time > 1:
                if is_value_valid:
                    want_or_got = "got"
                else:
                    want_or_got = "want"
                achieved_duration_bit = ""
                if achieving_duration_start is not None:
                    so_far = self.get_sim_time_cached() - achieving_duration_start
                    achieved_duration_bit = " (maintain=%.1f/%.1f)" % (so_far, minimum_duration)

                if print_diagnostics_as_target_not_range:
                    self.progress(
                        "%s=%0.2f (%s %f +- %f)%s" %
                        (value_name,
                         last_value,
                         want_or_got,
                         target,
                         accuracy,
                         achieved_duration_bit)
                    )
                else:
                    if isinstance(last_value, float):
                        self.progress(
                            "%s=%0.2f (%s between %s and %s)%s" %
                            (value_name,
                             last_value,
                             want_or_got,
                             str(minimum),
                             str(maximum),
                             achieved_duration_bit)
                        )
                    else:
                        self.progress(
                            "%s=%s (%s between %s and %s)%s" %
                            (value_name,
                             last_value,
                             want_or_got,
                             str(minimum),
                             str(maximum),
                             achieved_duration_bit)
                        )
                last_print_time = self.get_sim_time_cached()
            if is_value_valid:
                if value_averager is not None:
                    average = value_averager.add_value(last_value)
                else:
                    sum_of_achieved_values += last_value
                    count_of_achieved_values += 1.0
                    average = sum_of_achieved_values / count_of_achieved_values
                if achieving_duration_start is None:
                    achieving_duration_start = self.get_sim_time_cached()
                if self.get_sim_time_cached() - achieving_duration_start >= minimum_duration:
                    self.progress("Attained %s=%s" % (value_name, average))
                    return True
            else:
                achieving_duration_start = None
                sum_of_achieved_values = 0.0
                count_of_achieved_values = 0
                if value_averager is not None:
                    value_averager.reset()
        if print_diagnostics_as_target_not_range:
            raise AutoTestTimeoutException(
                "Failed to attain %s want %s, reached %s" %
                (value_name,
                 str(target),
                 str(sum_of_achieved_values / count_of_achieved_values) if count_of_achieved_values != 0 else str(last_value)))
        else:
            raise AutoTestTimeoutException(
                "Failed to attain %s between %s and %s, reached %s" %
                (value_name,
                 str(minimum),
                 str(maximum),
                 str(sum_of_achieved_values / count_of_achieved_values) if count_of_achieved_values != 0 else str(last_value)))

    def heading_delta(self, heading1, heading2):
        '''return angle between two 0-360 headings'''
        return math.fabs((heading1 - heading2 + 180) % 360 - 180)

    def get_heading(self, timeout=1):
        '''return heading 0-359'''
        m = self.assert_receive_message('VFR_HUD', timeout=timeout)
        return m.heading

    def wait_heading(self, heading, accuracy=5, timeout=30, **kwargs):
        """Wait for a given heading."""
        def get_heading_wrapped(timeout2):
            return self.get_heading(timeout=timeout2)

        def validator(value2, target2):
            return self.heading_delta(value2, target2) <= accuracy

        self.wait_and_maintain(
            value_name="Heading",
            target=heading,
            current_value_getter=lambda: get_heading_wrapped(timeout),
            validator=lambda value2, target2: validator(value2, target2),
            accuracy=accuracy,
            timeout=timeout,
            **kwargs
        )

    def wait_yaw_speed(self, yaw_speed, accuracy=0.1, timeout=30, **kwargs):
        """Wait for a given yaw speed in radians per second."""
        def get_yawspeed(timeout2):
            msg = self.assert_receive_message('ATTITUDE', timeout=timeout2)
            return msg.yawspeed

        def validator(value2, target2):
            return math.fabs(value2 - target2) <= accuracy

        self.wait_and_maintain(
            value_name="YawSpeed",
            target=yaw_speed,
            current_value_getter=lambda: get_yawspeed(timeout),
            validator=lambda value2, target2: validator(value2, target2),
            accuracy=accuracy,
            timeout=timeout,
            **kwargs
        )

    def get_speed_vector(self, timeout=1):
        '''return speed vector, NED'''
        msg = self.assert_receive_message('LOCAL_POSITION_NED', timeout=timeout)
        return Vector3(msg.vx, msg.vy, msg.vz)

    """Wait for a given speed vector."""
    def wait_speed_vector(self, speed_vector, accuracy=0.3, timeout=30, **kwargs):
        def validator(value2, target2):
            for (want, got) in (target2.x, value2.x), (target2.y, value2.y), (target2.z, value2.z):
                if want != float("nan") and (math.fabs(got - want) > accuracy):
                    return False
            return True

        self.wait_and_maintain(
            value_name="SpeedVector",
            target=speed_vector,
            current_value_getter=lambda: self.get_speed_vector(timeout=timeout),
            validator=lambda value2, target2: validator(value2, target2),
            accuracy=accuracy,
            timeout=timeout,
            **kwargs
        )

    def get_descent_rate(self):
        '''get descent rate - a positive number if you are going down'''
        return abs(self.get_speed_vector().z)

    def wait_descent_rate(self, rate, accuracy=0.1, **kwargs):
        '''wait for descent rate rate, a positive number if going down'''
        def validator(value, target):
            return math.fabs(value - target) <= accuracy

        self.wait_and_maintain(
            value_name="DescentRate",
            target=rate,
            current_value_getter=lambda: self.get_descent_rate(),
            validator=lambda value, target: validator(value, target),
            accuracy=accuracy,
            **kwargs
        )

    def get_body_frame_velocity(self):
        gri = self.assert_receive_message('GPS_RAW_INT', timeout=1)
        att = self.assert_receive_message('ATTITUDE', timeout=1)
        return mavextra.gps_velocity_body(gri, att)

    def wait_speed_vector_bf(self, speed_vector, accuracy=0.2, timeout=30, **kwargs):
        """Wait for a given speed vector."""
        def get_speed_vector(timeout2):
            return self.get_body_frame_velocity()

        def validator(value2, target2):
            return (math.fabs(value2.x - target2.x) <= accuracy and
                    math.fabs(value2.y - target2.y) <= accuracy and
                    math.fabs(value2.z - target2.z) <= accuracy)

        self.wait_and_maintain(
            value_name="SpeedVectorBF",
            target=speed_vector,
            current_value_getter=lambda: get_speed_vector(timeout),
            validator=lambda value2, target2: validator(value2, target2),
            accuracy=accuracy,
            timeout=timeout,
            **kwargs
        )

    def wait_distance_between(self, series1, series2, min_distance, max_distance, timeout=30, **kwargs):
        """Wait for distance between two position series to be between two thresholds."""
        def get_distance():
            self.drain_mav()
            m1 = self.mav.messages[series1]
            m2 = self.mav.messages[series2]
            return self.get_distance_int(m1, m2)

        self.wait_and_maintain_range(
            value_name=f"Distance({series1}, {series2})",
            minimum=min_distance,
            maximum=max_distance,
            current_value_getter=lambda: get_distance(),
            timeout=timeout,
            **kwargs
        )

    def wait_distance(self, distance, accuracy=2, timeout=30, **kwargs):
        """Wait for flight of a given distance."""
        start = self.mav.location()

        def get_distance():
            return self.get_distance(start, self.mav.location())

        def validator(value2, target2):
            return math.fabs(value2 - target2) <= accuracy

        self.wait_and_maintain(
            value_name="Distance",
            target=distance,
            current_value_getter=lambda: get_distance(),
            validator=lambda value2, target2: validator(value2, target2),
            accuracy=accuracy,
            timeout=timeout,
            **kwargs
        )

    def wait_distance_to_waypoint(self, wp_num, distance_min, distance_max, **kwargs):
        # TODO: use mission_request_partial_list_send
        wps = self.download_using_mission_protocol(mavutil.mavlink.MAV_MISSION_TYPE_MISSION)
        m = wps[wp_num]
        self.progress("m: %s" % str(m))
        loc = mavutil.location(m.x / 1.0e7, m.y / 1.0e7, 0, 0)
        self.progress("loc: %s" % str(loc))
        self.wait_distance_to_location(loc, distance_min, distance_max, **kwargs)

    def wait_distance_to_location(self, location, distance_min, distance_max, timeout=30, **kwargs):
        """Wait for flight of a given distance."""
        assert distance_min <= distance_max, "Distance min should be less than distance max."

        def get_distance():
            return self.get_distance(location, self.mav.location())

        def validator(value2, target2=None):
            return distance_min <= value2 <= distance_max

        self.wait_and_maintain(
            value_name="Distance",
            target=distance_min,
            current_value_getter=lambda: get_distance(),
            validator=lambda value2, target2: validator(value2, target2),
            accuracy=(distance_max - distance_min), timeout=timeout,
            **kwargs
        )

    def wait_distance_to_home(self, distance_min, distance_max, timeout=10, use_cached_home=True, **kwargs):
        """Wait for distance to home to be within specified bounds."""
        assert distance_min <= distance_max, "Distance min should be less than distance max."

        def get_distance():
            return self.distance_to_home(use_cached_home)

        def validator(value2, target2=None):
            return distance_min <= value2 <= distance_max

        self.wait_and_maintain(
            value_name="Distance to home",
            target=distance_min,
            current_value_getter=lambda: get_distance(),
            validator=lambda value2, target2: validator(value2, target2),
            accuracy=(distance_max - distance_min), timeout=timeout,
            **kwargs
        )

    def assert_at_home(self, accuracy=1):
        if self.distance_to_home() > accuracy:
            raise NotAchievedException("Not at home")

    def wait_distance_to_nav_target(self,
                                    distance_min,
                                    distance_max,
                                    timeout=10,
                                    use_cached_nav_controller_output=False,
                                    **kwargs):
        """Wait for distance to home to be within specified bounds."""
        assert distance_min <= distance_max, "Distance min should be less than distance max."

        def get_distance():
            return self.distance_to_nav_target(use_cached_nav_controller_output)

        def validator(value2, target2=None):
            return distance_min <= value2 <= distance_max

        self.wait_and_maintain(
            value_name="Distance to nav target",
            target=distance_min,
            current_value_getter=lambda: get_distance(),
            validator=lambda value2,
            target2: validator(value2, target2),
            accuracy=(distance_max - distance_min),
            timeout=timeout,
            **kwargs
        )

    def distance_to_local_position(self, local_pos, timeout=30):
        (x, y, z_down) = local_pos  # alt is *up*

        pos = self.assert_receive_message('LOCAL_POSITION_NED', timeout=timeout)

        delta_x = pos.x - x
        delta_y = pos.y - y
        delta_z = pos.z - z_down
        return math.sqrt(delta_x*delta_x + delta_y*delta_y + delta_z*delta_z)

    def wait_distance_to_local_position(self,
                                        local_position,  # (x, y, z_down)
                                        distance_min,
                                        distance_max,
                                        timeout=10,
                                        **kwargs):
        """Wait for distance to home to be within specified bounds."""
        assert distance_min <= distance_max, "Distance min should be less than distance max."

        def get_distance():
            return self.distance_to_local_position(local_position)

        def validator(value2, target2=None):
            return distance_min <= value2 <= distance_max

        (x, y, z_down) = local_position
        self.wait_and_maintain(
            value_name="Distance to (%f,%f,%f)" % (x, y, z_down),
            target=distance_min,
            current_value_getter=lambda: get_distance(),
            validator=lambda value2,
            target2: validator(value2, target2),
            accuracy=(distance_max - distance_min),
            timeout=timeout,
            **kwargs
        )

    def wait_parameter_value(self, parameter, value, timeout=10):
        tstart = self.get_sim_time()
        while True:
            if self.get_sim_time_cached() - tstart > timeout:
                raise NotAchievedException("%s never got value %f" %
                                           (parameter, value))
            v = self.get_parameter(parameter, verbose=False)
            self.progress("Got parameter value (%s=%f)" %
                          (parameter, v))
            if v == value:
                return
            self.delay_sim_time(0.1)

    def get_servo_channel_value(self, channel, timeout=2):
        channel_field = "servo%u_raw" % channel
        tstart = self.get_sim_time()
        while True:
            remaining = timeout - (self.get_sim_time_cached() - tstart)
            if remaining <= 0:
                raise NotAchievedException("Channel value condition not met")
            m = self.mav.recv_match(type='SERVO_OUTPUT_RAW',
                                    blocking=True,
                                    timeout=remaining)
            if m is None:
                continue
            m_value = getattr(m, channel_field, None)
            if m_value is None:
                raise ValueError("message (%s) has no field %s" %
                                 (str(m), channel_field))
            return m_value

    def wait_servo_channel_value(self, channel, value, timeout=2, comparator=operator.eq):
        """wait for channel value comparison (default condition is equality)"""
        channel_field = "servo%u_raw" % channel
        opstring = ("%s" % comparator)[-3:-1]
        tstart = self.get_sim_time()
        while True:
            remaining = timeout - (self.get_sim_time_cached() - tstart)
            if remaining <= 0:
                raise NotAchievedException("Channel value condition not met")
            m = self.mav.recv_match(type='SERVO_OUTPUT_RAW',
                                    blocking=True,
                                    timeout=remaining)
            if m is None:
                continue
            m_value = getattr(m, channel_field, None)
            if m_value is None:
                raise ValueError("message (%s) has no field %s" %
                                 (str(m), channel_field))
            self.progress("want SERVO_OUTPUT_RAW.%s=%u %s %u" %
                          (channel_field, m_value, opstring, value))
            if comparator(m_value, value):
                return m_value

    def assert_servo_channel_value(self, channel, value, comparator=operator.eq):
        """assert channel value (default condition is equality)"""
        channel_field = "servo%u_raw" % channel
        opstring = ("%s" % comparator)[-3:-1]
        m = self.assert_receive_message('SERVO_OUTPUT_RAW', timeout=1)
        m_value = getattr(m, channel_field, None)
        if m_value is None:
            raise ValueError("message (%s) has no field %s" %
                             (str(m), channel_field))
        self.progress("assert SERVO_OUTPUT_RAW.%s=%u %s %u" %
                      (channel_field, m_value, opstring, value))
        if comparator(m_value, value):
            return m_value
        raise NotAchievedException("Wrong value")

    def get_rc_channel_value(self, channel, timeout=2):
        """wait for channel to hit value"""
        channel_field = "chan%u_raw" % channel
        tstart = self.get_sim_time()
        while True:
            remaining = timeout - (self.get_sim_time_cached() - tstart)
            if remaining <= 0:
                raise NotAchievedException("Channel never achieved value")
            m = self.mav.recv_match(type='RC_CHANNELS',
                                    blocking=True,
                                    timeout=remaining)
            if m is None:
                continue
            m_value = getattr(m, channel_field)
            if m_value is None:
                raise ValueError("message (%s) has no field %s" %
                                 (str(m), channel_field))
            return m_value

    def wait_rc_channel_value(self, channel, value, timeout=2):
        channel_field = "chan%u_raw" % channel
        tstart = self.get_sim_time()
        while True:
            remaining = timeout - (self.get_sim_time_cached() - tstart)
            if remaining <= 0:
                raise NotAchievedException("Channel never achieved value")
            m_value = self.get_rc_channel_value(channel, timeout=timeout)
            self.progress("RC_CHANNELS.%s=%u want=%u" %
                          (channel_field, m_value, value))
            if value == m_value:
                return

    def assert_rc_channel_value(self, channel, value):
        channel_field = "chan%u_raw" % channel

        m_value = self.get_rc_channel_value(channel, timeout=1)
        self.progress("RC_CHANNELS.%s=%u want=%u" %
                      (channel_field, m_value, value))
        if value != m_value:
            raise NotAchievedException("Expected %s to be %u got %u" %
                                       (channel, value, m_value))

    def send_do_reposition(self,
                           loc,
                           frame=mavutil.mavlink.MAV_FRAME_GLOBAL_RELATIVE_ALT):
        '''send a DO_REPOSITION command for a location'''
        self.run_cmd_int(
            mavutil.mavlink.MAV_CMD_DO_REPOSITION,
            0,
            0,
            0,
            0,
            int(loc.lat*1e7), # lat* 1e7
            int(loc.lng*1e7), # lon* 1e7
            loc.alt,
            frame=frame
        )

    def add_rally_point(self, loc, seq, total):
        '''add a rally point at the given location'''
        self.mav.mav.rally_point_send(1, # target system
                                      0, # target component
                                      seq, # sequence number
                                      total, # total count
                                      int(loc.lat * 1e7),
                                      int(loc.lng * 1e7),
                                      loc.alt, # relative alt
                                      0, # "break" alt?!
                                      0, # "land dir"
                                      0) # flags

    def wait_location(self, loc, **kwargs):
        waiter = WaitAndMaintainLocation(self, loc, **kwargs)
        waiter.run()

    def assert_current_waypoint(self, wpnum):
        seq = self.mav.waypoint_current()
        if seq != wpnum:
            raise NotAchievedException("Incorrect current wp")

    def wait_current_waypoint(self, wpnum, timeout=70):
        tstart = self.get_sim_time()
        while True:
            if self.get_sim_time() - tstart > timeout:
                raise AutoTestTimeoutException("Did not get wanted current waypoint")
            seq = self.mav.waypoint_current()
            wp_dist = None
            try:
                wp_dist = self.mav.messages['NAV_CONTROLLER_OUTPUT'].wp_dist
            except (KeyError, AttributeError):
                pass
            self.progress("Waiting for wp=%u current=%u dist=%sm" % (wpnum, seq, wp_dist))
            if seq == wpnum:
                break

    def wait_waypoint(self,
                      wpnum_start,
                      wpnum_end,
                      allow_skip=True,
                      max_dist=2,
                      timeout=400,
                      ignore_RTL_mode_change=False):
        """Wait for waypoint ranges."""
        tstart = self.get_sim_time()
        # this message arrives after we set the current WP
        start_wp = self.mav.waypoint_current()
        current_wp = start_wp
        mode = self.mav.flightmode

        self.progress("wait for waypoint ranges start=%u end=%u"
                      % (wpnum_start, wpnum_end))
        # if start_wp != wpnum_start:
        #    raise WaitWaypointTimeout("test: Expected start waypoint %u "
        #                              "but got %u" %
        #                  (wpnum_start, start_wp))

        last_wp_msg = 0
        while self.get_sim_time_cached() < tstart + timeout:
            seq = self.mav.waypoint_current()
            m = self.assert_receive_message('NAV_CONTROLLER_OUTPUT')
            wp_dist = m.wp_dist
            m = self.assert_receive_message('VFR_HUD')

            # if we changed mode, fail
            if not self.mode_is('AUTO'):
                self.progress(f"{self.mav.flightmode} vs {self.get_mode_from_mode_mapping(mode)}")
                if not ignore_RTL_mode_change or not self.mode_is('RTL', cached=True):
                    new_mode_str = self.get_mode_string_for_mode(self.get_mode())
                    raise WaitWaypointTimeout(f'Exited {mode} mode to {new_mode_str} ignore={ignore_RTL_mode_change}')

            if self.get_sim_time_cached() - last_wp_msg > 1:
                self.progress("WP %u (wp_dist=%u Alt=%.02f), current_wp: %u,"
                              "wpnum_end: %u" %
                              (seq, wp_dist, m.alt, current_wp, wpnum_end))
                last_wp_msg = self.get_sim_time_cached()
            if seq == current_wp+1 or (seq > current_wp+1 and allow_skip):
                self.progress("WW: Starting new waypoint %u" % seq)
                tstart = self.get_sim_time()
                current_wp = seq
                # the wp_dist check is a hack until we can sort out
                # the right seqnum for end of mission
            # if current_wp == wpnum_end or (current_wp == wpnum_end-1 and
            #                                wp_dist < 2):
            if current_wp == wpnum_end and wp_dist < max_dist:
                self.progress("Reached final waypoint %u" % seq)
                return True
            if seq >= 255:
                self.progress("Reached final waypoint %u" % seq)
                return True
            if seq > current_wp+1:
                raise WaitWaypointTimeout(("Skipped waypoint! Got wp %u expected %u"
                                           % (seq, current_wp+1)))
        raise WaitWaypointTimeout("Timed out waiting for waypoint %u of %u" %
                                  (wpnum_end, wpnum_end))

    def get_cached_message(self, message_type):
        '''returns the most-recently received instance of message_type'''
        return self.mav.messages[message_type]

    def mode_is(self, mode, cached=False, drain_mav=True, drain_mav_quietly=True):
        if not cached:
            self.wait_heartbeat(drain_mav=drain_mav, quiet=drain_mav_quietly)
        try:
            return self.get_mode_from_mode_mapping(self.mav.flightmode) == self.get_mode_from_mode_mapping(mode)
        except Exception:
            pass
        # assume this is a number....
        return self.mav.messages['HEARTBEAT'].custom_mode == mode

    def wait_mode(self, mode, timeout=60):
        """Wait for mode to change."""
        self.progress("Waiting for mode %s" % mode)
        tstart = self.get_sim_time()
        while not self.mode_is(mode, drain_mav=False):
            custom_num = self.mav.messages['HEARTBEAT'].custom_mode
            self.progress("mav.flightmode=%s Want=%s custom=%u" % (
                self.mav.flightmode, mode, custom_num))
            if (timeout is not None and
                    self.get_sim_time_cached() > tstart + timeout):
                raise WaitModeTimeout("Did not change mode")
        self.progress("Got mode %s" % mode)

    def assert_mode_is(self, mode):
        if not self.mode_is(mode):
            raise NotAchievedException("Expected mode %s" % str(mode))

    def get_mode(self, cached=False, drain_mav=True):
        '''return numeric custom mode'''
        if not cached:
            self.wait_heartbeat(drain_mav=drain_mav)
        return self.mav.messages['HEARTBEAT'].custom_mode

    def wait_gps_sys_status_not_present_or_enabled_and_healthy(self, timeout=30):
        self.progress("Waiting for GPS health")
        tstart = self.get_sim_time()
        while True:
            now = self.get_sim_time_cached()
            if now - tstart > timeout:
                raise AutoTestTimeoutException("GPS status bits did not become good")
            m = self.mav.recv_match(type='SYS_STATUS', blocking=True, timeout=1)
            if m is None:
                continue
            if (not (m.onboard_control_sensors_present & mavutil.mavlink.MAV_SYS_STATUS_SENSOR_GPS)):
                self.progress("GPS not present")
                if now > 20:
                    # it's had long enough to be detected....
                    return
                continue
            if (not (m.onboard_control_sensors_enabled & mavutil.mavlink.MAV_SYS_STATUS_SENSOR_GPS)):
                self.progress("GPS not enabled")
                continue
            if (not (m.onboard_control_sensors_health & mavutil.mavlink.MAV_SYS_STATUS_SENSOR_GPS)):
                self.progress("GPS not healthy")
                continue
            self.progress("GPS healthy after %f/%f seconds" %
                          ((now - tstart), timeout))
            return

    def assert_sensor_state(self, sensor, present=True, enabled=True, healthy=True, verbose=False):
        return self.sensor_has_state(sensor, present, enabled, healthy, do_assert=True, verbose=verbose)

    def sensor_has_state(self, sensor, present=True, enabled=True, healthy=True, do_assert=False, verbose=False):
        m = self.assert_receive_message('SYS_STATUS', timeout=5, very_verbose=verbose)
        reported_present = m.onboard_control_sensors_present & sensor
        reported_enabled = m.onboard_control_sensors_enabled & sensor
        reported_healthy = m.onboard_control_sensors_health & sensor
        if present:
            if not reported_present:
                if do_assert:
                    raise NotAchievedException("Sensor not present")
                return False
        else:
            if reported_present:
                if do_assert:
                    raise NotAchievedException("Sensor present when it shouldn't be")
                return False

        if enabled:
            if not reported_enabled:
                if do_assert:
                    raise NotAchievedException("Sensor not enabled")
                return False
        else:
            if reported_enabled:
                if do_assert:
                    raise NotAchievedException("Sensor enabled when it shouldn't be")
                return False

        if healthy:
            if not reported_healthy:
                if do_assert:
                    raise NotAchievedException("Sensor not healthy")
                return False
        else:
            if reported_healthy:
                if do_assert:
                    raise NotAchievedException("Sensor healthy when it shouldn't be")
                return False
        return True

    def wait_sensor_state(self, sensor, present=True, enabled=True, healthy=True, timeout=5, verbose=False):
        tstart = self.get_sim_time()
        while True:
            if self.get_sim_time_cached() - tstart > timeout:
                raise NotAchievedException("Sensor did not achieve state")
            if self.sensor_has_state(sensor, present=present, enabled=enabled, healthy=healthy, verbose=verbose):
                break

    def wait_not_ready_to_arm(self):
        self.wait_sensor_state(mavutil.mavlink.MAV_SYS_STATUS_PREARM_CHECK, True, True, False)

    def wait_prearm_sys_status_healthy(self, timeout=60):
        self.do_timesync_roundtrip()
        tstart = self.get_sim_time()
        while True:
            t2 = self.get_sim_time_cached()
            if t2 - tstart > timeout:
                self.progress("Prearm bit never went true.  Attempting arm to elicit reason from autopilot")
                try:
                    self.arm_vehicle()
                except Exception:
                    pass
                raise AutoTestTimeoutException("Prearm bit never went true")
            if self.sensor_has_state(mavutil.mavlink.MAV_SYS_STATUS_PREARM_CHECK, True, True, True):
                break

    def assert_fence_enabled(self, timeout=2):
        # Check fence is enabled
        m = self.assert_receive_message('FENCE_STATUS', timeout=timeout)
        self.progress("Got (%s)" % str(m))

    def assert_fence_disabled(self, timeout=2):
        # Check fence is not enabled
        self.assert_not_receiving_message('FENCE_STATUS', timeout=timeout)

    def NoArmWithoutMissionItems(self):
        '''ensure we can't arm in auto mode without mission items present'''
        # load a trivial mission
        items = []
        items.append((mavutil.mavlink.MAV_CMD_NAV_WAYPOINT, 1000, 0, 20000),)
        items.append((mavutil.mavlink.MAV_CMD_NAV_RETURN_TO_LAUNCH, 0, 0, 0))
        self.upload_simple_relhome_mission(items)

        self.change_mode('AUTO')
        self.clear_mission(mavutil.mavlink.MAV_MISSION_TYPE_ALL)
        self.assert_prearm_failure('Mode requires mission',
                                   other_prearm_failures_fatal=False)

    def assert_prearm_failure(self,
                              expected_statustext,
                              timeout=5,
                              ignore_prearm_failures=[],
                              other_prearm_failures_fatal=True):
        seen_statustext = False
        seen_command_ack = False

        self.drain_mav()
        tstart = self.get_sim_time_cached()
        arm_last_send = 0
        while True:
            if seen_command_ack and seen_statustext:
                break
            now = self.get_sim_time_cached()
            if now - tstart > timeout:
                raise NotAchievedException(
                    "Did not see failure-to-arm messages (statustext=%s command_ack=%s" %
                    (seen_statustext, seen_command_ack))
            if now - arm_last_send > 1:
                arm_last_send = now
                self.send_mavlink_run_prearms_command()
            m = self.mav.recv_match(blocking=True, timeout=1)
            if m is None:
                continue
            if m.get_type() == "STATUSTEXT":
                if expected_statustext in m.text:
                    self.progress("Got: %s" % str(m))
                    seen_statustext = True
                elif other_prearm_failures_fatal and "PreArm" in m.text and m.text[8:] not in ignore_prearm_failures:
                    self.progress("Got: %s" % str(m))
                    raise NotAchievedException("Unexpected prearm failure (%s)" % m.text)

            if m.get_type() == "COMMAND_ACK":
                print("Got: %s" % str(m))
                if m.command == mavutil.mavlink.MAV_CMD_RUN_PREARM_CHECKS:
                    if m.result != mavutil.mavlink.MAV_RESULT_ACCEPTED:
                        raise NotAchievedException("command-ack says we didn't run prearms")
                    self.progress("Got: %s" % str(m))
                    seen_command_ack = True
            if self.mav.motors_armed():
                raise NotAchievedException("Armed when we shouldn't have")

    def assert_arm_failure(self, expected_statustext, timeout=5, ignore_prearm_failures=[]):
        seen_statustext = False
        seen_command_ack = False

        self.drain_mav()
        tstart = self.get_sim_time_cached()
        arm_last_send = 0
        while True:
            if seen_command_ack and seen_statustext:
                break
            now = self.get_sim_time_cached()
            if now - tstart > timeout:
                raise NotAchievedException(
                    "Did not see failure-to-arm messages (statustext=%s command_ack=%s" %
                    (seen_statustext, seen_command_ack))
            if now - arm_last_send > 1:
                arm_last_send = now
                self.send_mavlink_arm_command()
            m = self.mav.recv_match(blocking=True, timeout=1)
            if m is None:
                continue
            if m.get_type() == "STATUSTEXT":
                if expected_statustext in m.text:
                    self.progress("Got: %s" % str(m))
                    seen_statustext = True
                elif "PreArm" in m.text and m.text[8:] not in ignore_prearm_failures:
                    self.progress("Got: %s" % str(m))
                    raise NotAchievedException("Unexpected prearm failure (%s)" % m.text)

            if m.get_type() == "COMMAND_ACK":
                print("Got: %s" % str(m))
                if m.command == mavutil.mavlink.MAV_CMD_COMPONENT_ARM_DISARM:
                    if m.result != 4:
                        raise NotAchievedException("command-ack says we didn't fail to arm")
                    self.progress("Got: %s" % str(m))
                    seen_command_ack = True
            if self.mav.motors_armed():
                raise NotAchievedException("Armed when we shouldn't have")

    def wait_ready_to_arm(self, timeout=120, require_absolute=True, check_prearm_bit=True):
        # wait for EKF checks to pass
        self.progress("Waiting for ready to arm")
        start = self.get_sim_time()
        self.wait_ekf_happy(timeout=timeout, require_absolute=require_absolute)
        if require_absolute:
            self.wait_gps_sys_status_not_present_or_enabled_and_healthy()
        if require_absolute:
            self.poll_home_position()
        if check_prearm_bit:
            self.wait_prearm_sys_status_healthy(timeout=timeout)
        armable_time = self.get_sim_time() - start
        self.progress("Took %u seconds to become armable" % armable_time)
        self.total_waiting_to_arm_time += armable_time
        self.waiting_to_arm_count += 1

    def wait_heartbeat(self, drain_mav=True, quiet=False, *args, **x):
        '''as opposed to mav.wait_heartbeat, raises an exception on timeout.
Also, ignores heartbeats not from our target system'''
        if drain_mav:
            self.drain_mav(quiet=quiet)
        orig_timeout = x.get("timeout", 20)
        x["timeout"] = 1
        tstart = time.time()
        while True:
            if time.time() - tstart > orig_timeout and not self.gdb:
                if not self.sitl_is_running():
                    self.progress("SITL is not running")
                raise AutoTestTimeoutException("Did not receive heartbeat")
            m = self.mav.wait_heartbeat(*args, **x)
            if m is None:
                continue
            if m.get_srcSystem() == self.sysid_thismav():
                return m

    def wait_ekf_happy(self, require_absolute=True, **kwargs):
        """Wait for EKF to be happy"""
        if "timeout" not in kwargs:
            kwargs["timeout"] = 45

        """ if using SITL estimates directly """
        if (int(self.get_parameter('AHRS_EKF_TYPE')) == 10):
            return True

        # all of these must be set for arming to happen:
        required_value = (mavutil.mavlink.EKF_ATTITUDE |
                          mavutil.mavlink.ESTIMATOR_VELOCITY_HORIZ |
                          mavutil.mavlink.ESTIMATOR_VELOCITY_VERT |
                          mavutil.mavlink.ESTIMATOR_POS_HORIZ_REL |
                          mavutil.mavlink.ESTIMATOR_PRED_POS_HORIZ_REL)
        # none of these bits must be set for arming to happen:
        error_bits = (mavutil.mavlink.ESTIMATOR_CONST_POS_MODE |
                      mavutil.mavlink.ESTIMATOR_ACCEL_ERROR)
        if require_absolute:
            required_value |= (mavutil.mavlink.ESTIMATOR_POS_HORIZ_ABS |
                               mavutil.mavlink.ESTIMATOR_POS_VERT_ABS |
                               mavutil.mavlink.ESTIMATOR_PRED_POS_HORIZ_ABS)
            error_bits |= mavutil.mavlink.ESTIMATOR_GPS_GLITCH
        WaitAndMaintainEKFFlags(self, required_value, error_bits, **kwargs).run()

    def wait_ekf_flags(self, required_value, error_bits, **kwargs):
        WaitAndMaintainEKFFlags(self, required_value, error_bits, **kwargs).run()

    def wait_gps_disable(self, position_horizontal=True, position_vertical=False, timeout=30):
        """Disable GPS and wait for EKF to report the end of assistance from GPS."""
        self.set_parameter("SIM_GPS_DISABLE", 1)
        tstart = self.get_sim_time()

        """ if using SITL estimates directly """
        if (int(self.get_parameter('AHRS_EKF_TYPE')) == 10):
            self.progress("GPS disable skipped")
            return

        # all of these must NOT be set for arming NOT to happen:
        not_required_value = 0
        if position_horizontal:
            not_required_value |= mavutil.mavlink.ESTIMATOR_POS_HORIZ_REL
        if position_vertical:
            not_required_value |= mavutil.mavlink.ESTIMATOR_POS_VERT_AGL
        self.progress("Waiting for EKF not having bits %u" % not_required_value)
        last_print_time = 0
        while timeout is None or self.get_sim_time_cached() < tstart + timeout:
            m = self.mav.recv_match(type='EKF_STATUS_REPORT', blocking=True, timeout=timeout)
            if m is None:
                continue
            current = m.flags
            if self.get_sim_time_cached() - last_print_time > 1:
                self.progress("Wait EKF.flags: not required:%u current:%u" %
                              (not_required_value, current))
                last_print_time = self.get_sim_time_cached()
            if current & not_required_value != not_required_value:
                self.progress("GPS disable OK")
                return
        raise AutoTestTimeoutException("Failed to get EKF.flags=%u disabled" % not_required_value)

    def wait_text(self, *args, **kwargs):
        '''wait for text to appear from vehicle, return that text'''
        statustext = self.wait_statustext(*args, **kwargs)
        if statustext is None:
            return None
        return statustext.text

    def statustext_in_collections(self, text, regex=False):
        '''searches for text in STATUSTEXT collection, returns message if found'''
        c = self.context_get()
        if "STATUSTEXT" not in c.collections:
            raise NotAchievedException("Asked to check context but it isn't collecting!")
        for x in c.collections["STATUSTEXT"]:
            self.progress("  statustext got=(%s) want=(%s)" % (x.text, text))
            if regex:
                if re.match(text, x.text):
                    return x
            elif text.lower() in x.text.lower():
                return x
        return None

    def wait_statustext(self, text, timeout=20, the_function=None, check_context=False, regex=False, wallclock_timeout=False):
        """Wait for a specific STATUSTEXT, return that statustext message"""

        # Statustexts are often triggered by something we've just
        # done, so we have to be careful not to read any traffic that
        # isn't checked for being our statustext.  That doesn't work
        # well with getting the curent simulation time (which requires
        # a new SYSTEM_TIME message), so we install a message hook
        # which checks all incoming messages.
        self.progress("Waiting for text : %s" % text.lower())
        if check_context:
            statustext = self.statustext_in_collections(text, regex=regex)
            if statustext:
                self.progress("Found expected text in collection: %s" % text.lower())
                return statustext

        global statustext_found
        global statustext_full
        statustext_full = None
        statustext_found = False

        def mh(mav, m):
            global statustext_found
            global statustext_full
            if m.get_type() != "STATUSTEXT":
                return
            if regex:
                self.re_match = re.match(text, m.text)
                if self.re_match:
                    statustext_found = True
                    statustext_full = m
            if text.lower() in m.text.lower():
                self.progress("Received expected text: %s" % m.text.lower())
                statustext_found = True
                statustext_full = m

        self.install_message_hook(mh)
        if wallclock_timeout:
            tstart = time.time()
        else:
            tstart = self.get_sim_time()
        try:
            while not statustext_found:
                if wallclock_timeout:
                    now = time.time()
                else:
                    now = self.get_sim_time_cached()
                if now - tstart > timeout:
                    raise AutoTestTimeoutException("Failed to receive text: %s" %
                                                   text.lower())
                if the_function is not None:
                    the_function()
                self.mav.recv_match(type='STATUSTEXT', blocking=True, timeout=0.1)
        finally:
            self.remove_message_hook(mh)
        return statustext_full

    # routines helpful for testing LUA scripting:
    def script_example_source_path(self, scriptname):
        return os.path.join(self.rootdir(), "libraries", "AP_Scripting", "examples", scriptname)

    def script_test_source_path(self, scriptname):
        return os.path.join(self.rootdir(), "libraries", "AP_Scripting", "tests", scriptname)

    def script_applet_source_path(self, scriptname):
        return os.path.join(self.rootdir(), "libraries", "AP_Scripting", "applets", scriptname)

    def installed_script_path(self, scriptname):
        return os.path.join("scripts", os.path.basename(scriptname))

    def install_script(self, source, scriptname, install_name=None):
        if install_name is not None:
            dest = self.installed_script_path(install_name)
        else:
            dest = self.installed_script_path(scriptname)

        destdir = os.path.dirname(dest)
        if not os.path.exists(destdir):
            os.mkdir(destdir)
        self.progress("Copying (%s) to (%s)" % (source, dest))
        shutil.copy(source, dest)

    def installed_script_module_path(self, modulename):
        return os.path.join("scripts", "modules", os.path.basename(modulename))

    def install_script_module(self, source, modulename, install_name=None):
        if install_name is not None:
            dest = self.installed_script_module_path(install_name)
        else:
            dest = self.installed_script_module_path(modulename)

        destdir = os.path.dirname(dest)
        os.makedirs(destdir, exist_ok=True)
        self.progress("Copying (%s) to (%s)" % (source, dest))
        shutil.copy(source, dest)

    def install_test_modules(self):
        source = os.path.join(self.rootdir(), "libraries", "AP_Scripting", "tests", "modules", "test")
        dest = os.path.join("scripts", "modules", "test")
        self.progress("Copying (%s) to (%s)" % (source, dest))
        shutil.copytree(source, dest)

    def install_mavlink_module(self):
        dest = os.path.join("scripts", "modules", "mavlink")
        ardupilotmega_xml = os.path.join(self.rootdir(), "modules", "mavlink",
                                         "message_definitions", "v1.0", "ardupilotmega.xml")
        mavgen.mavgen(mavgen.Opts(output=dest, wire_protocol='2.0', language='Lua'), [ardupilotmega_xml])
        self.progress("Installed mavlink module")

    def install_example_script(self, scriptname):
        source = self.script_example_source_path(scriptname)
        self.install_script(source, scriptname)

    def install_test_script(self, scriptname):
        source = self.script_test_source_path(scriptname)
        self.install_script(source, scriptname)

    def install_applet_script(self, scriptname, install_name=None):
        source = self.script_applet_source_path(scriptname)
        self.install_script(source, scriptname, install_name=install_name)

    def remove_installed_script(self, scriptname):
        dest = self.installed_script_path(os.path.basename(scriptname))
        try:
            os.unlink(dest)
        except IOError:
            pass
        except OSError:
            pass

    def remove_installed_script_module(self, modulename):
        path = self.installed_script_module_path(modulename)
        os.unlink(path)

    def remove_installed_modules(self, modulename):
        dest = os.path.join("scripts", "modules", modulename)
        try:
            shutil.rmtree(dest)
        except IOError:
            pass
        except OSError:
            pass

    def get_mavlink_connection_going(self):
        # get a mavlink connection going
        try:
            retries = 20
            if self.gdb:
                retries = 20000
            self.mav = mavutil.mavlink_connection(
                self.autotest_connection_string_to_ardupilot(),
                retries=retries,
                robust_parsing=True,
                source_system=250,
                source_component=250,
                autoreconnect=True,
                dialect="all",  # if we don't pass this in we end up with the wrong mavlink version...
            )
        except Exception as msg:
            self.progress("Failed to start mavlink connection on %s: %s" %
                          (self.autotest_connection_string_to_ardupilot(), msg,))
            raise
        self.mav.message_hooks.append(self.message_hook)
        self.mav.mav.set_send_callback(self.send_message_hook, self)
        self.mav.idle_hooks.append(self.idle_hook)

        # we need to wait for a heartbeat here.  If we don't then
        # self.mav.target_system will be zero because it hasn't
        # "locked on" to a target system yet.
        self.wait_heartbeat()
        self.set_streamrate(self.sitl_streamrate())

    def show_test_timings_key_sorter(self, t):
        (k, v) = t
        return ((v, k))

    def show_test_timings(self):
        if len(self.test_timings.keys()) == 0:
            return
        longest = 0
        for desc in self.test_timings.keys():
            if len(desc) > longest:
                longest = len(desc)
        tests_total_time = 0
        for desc, test_time in sorted(self.test_timings.items(),
                                      key=self.show_test_timings_key_sorter):
            fmt = "%" + str(longest) + "s: %.2fs"
            tests_total_time += test_time
            self.progress(fmt % (desc, test_time))
        self.progress(fmt % ("**--tests_total_time--**", tests_total_time))
        self.progress("mavproxy_start was called %u times" %
                      (self.start_mavproxy_count,))
        self.progress("Supplied terrain data to autopilot in %u messages" %
                      (self.terrain_data_messages_sent,))

    def send_statustext(self, text):
        if sys.version_info.major >= 3 and not isinstance(text, bytes):
            text = bytes(text, "ascii")
        elif 'unicode' in str(type(text)):
            text = text.encode('ascii')
        seq = 0
        while len(text):
            self.mav.mav.statustext_send(mavutil.mavlink.MAV_SEVERITY_WARNING, text[:50], id=self.statustext_id, chunk_seq=seq)
            text = text[50:]
            seq += 1
        self.statustext_id += 1
        if self.statustext_id > 255:
            self.statustext_id = 1

    def get_stacktrace(self):
        return ''.join(traceback.format_stack())

    def get_exception_stacktrace(self, e):
        if sys.version_info[0] >= 3:
            ret = "%s\n" % e
            ret += ''.join(traceback.format_exception(type(e),
                                                      e,
                                                      tb=e.__traceback__))
            return ret

        # Python2:
        return traceback.format_exc(e)

    def bin_logs(self):
        return glob.glob("logs/*.BIN")

    def remove_bin_logs(self):
        util.run_cmd('/bin/rm -f logs/*.BIN logs/LASTLOG.TXT')

    def remove_ardupilot_terrain_cache(self):
        '''removes the terrain files ArduPilot keeps in its onboiard storage'''
        util.run_cmd('/bin/rm -f %s' % util.reltopdir("terrain/*.DAT"))

    def check_logs(self, name):
        '''called to move relevant log files from our working directory to the
        buildlogs directory'''
        to_dir = self.logs_dir
        # move telemetry log files
        for log in glob.glob("autotest-*.tlog"):
            bname = os.path.basename(log)
            newname = os.path.join(to_dir, "%s-%s-%s" % (self.log_name(), name, bname))
            print("Renaming %s to %s" % (log, newname))
            shutil.move(log, newname)
        # move binary log files
        for log in sorted(self.bin_logs()):
            bname = os.path.basename(log)
            newname = os.path.join(to_dir, "%s-%s-%s" % (self.log_name(), name, bname))
            print("Renaming %s to %s" % (log, newname))
            shutil.move(log, newname)
        # move core files
        save_binaries = False
        corefiles = []
        corefiles.extend(glob.glob("core*"))
        corefiles.extend(glob.glob("ap-*.core"))
        for log in sorted(corefiles):
            bname = os.path.basename(log)
            newname = os.path.join(to_dir, "%s-%s-%s" % (bname, self.log_name(), name))
            print("Renaming %s to %s" % (log, newname))
            shutil.move(log, newname)
            save_binaries = True
        if save_binaries:
            util.run_cmd('/bin/cp build/sitl/bin/* %s' % to_dir,
                         directory=util.reltopdir('.'))

    def run_one_test(self, test, interact=False, suppress_stdout=False):
        '''new-style run-one-test used by run_tests'''
        for i in range(0, test.attempts-1):
            result = self.run_one_test_attempt(test, interact=interact, attempt=i+2, suppress_stdout=suppress_stdout)
            if result.passed:
                return result
            self.progress("Run attempt failed.  Retrying")
        return self.run_one_test_attempt(test, interact=interact, attempt=1, suppress_stdout=suppress_stdout)

    def print_exception_caught(self, e, send_statustext=True):
        self.progress("Exception caught: %s" %
                      self.get_exception_stacktrace(e))
        path = None
        try:
            path = self.current_onboard_log_filepath()
        except IndexError:
            pass
        self.progress("Most recent logfile: %s" % (path, ), send_statustext=send_statustext)

    def progress_file_content(self, filepath):
        with open(filepath) as f:
            for line in f:
                self.progress(line.rstrip())

    def dump_process_status(self, result):
        '''used to show where the SITL process is upto.  Often caused when
        we've lost contact'''

        if self.sitl.isalive():
            self.progress("pexpect says it is alive")
            for tool in "dumpstack.sh", "dumpcore.sh":
                tool_filepath = os.path.join(self.rootdir(), 'Tools', 'scripts', tool)
                if util.run_cmd([tool_filepath, str(self.sitl.pid)]) != 0:
                    reason = "Failed %s" % (tool,)
                    self.progress(reason)
                    result.reason = reason
                    result.passed = False
        else:
            self.progress("pexpect says it is dead")

        # try dumping the process status file for more information:
        status_filepath = "/proc/%u/status" % self.sitl.pid
        self.progress("Checking for status filepath (%s)" % status_filepath)
        if os.path.exists(status_filepath):
            self.progress_file_content(status_filepath)
        else:
            self.progress("... does not exist")

    def run_one_test_attempt(self, test, interact=False, attempt=1, suppress_stdout=False):
        '''called by run_one_test to actually run the test in a retry loop'''
        name = test.name
        desc = test.description
        test_function = test.function
        test_kwargs = test.kwargs
        if attempt != 1:
            self.progress("RETRYING %s" % name)
            test_output_filename = self.buildlogs_path("%s-%s-retry-%u.txt" %
                                                       (self.log_name(), name, attempt-1))
        else:
            test_output_filename = self.buildlogs_path("%s-%s.txt" %
                                                       (self.log_name(), name))

        tee = TeeBoth(test_output_filename, 'w', self.mavproxy_logfile, suppress_stdout=suppress_stdout)

        start_message_hooks = copy.copy(self.message_hooks)

        prettyname = "%s (%s)" % (name, desc)
        self.start_test(prettyname)
        self.set_current_test_name(name)
        old_contexts_length = len(self.contexts)
        self.context_push()

        start_time = time.time()

        orig_speedup = None

        hooks_removed = False

        ex = None
        try:
            self.check_rc_defaults()
            self.change_mode(self.default_mode())
            # ArduPilot can still move the current waypoint from 0,
            # even if we are not in AUTO mode, so cehck_afterwards=False:
            self.set_current_waypoint(0, check_afterwards=False)
            self.drain_mav()
            self.drain_all_pexpects()
            if test.speedup is not None:
                self.progress("Overriding speedup to %u" % test.speedup)
                orig_speedup = self.get_parameter("SIM_SPEEDUP")
                self.set_parameter("SIM_SPEEDUP", test.speedup)

            test_function(**test_kwargs)
        except Exception as e:
            self.print_exception_caught(e)
            ex = e
            # reset the message hooks; we've failed-via-exception and
            # can't expect the hooks to have been cleaned up
            for h in copy.copy(self.message_hooks):
                if h not in start_message_hooks:
                    self.message_hooks.remove(h)
            hooks_removed = True
        self.test_timings[desc] = time.time() - start_time
        reset_needed = self.contexts[-1].sitl_commandline_customised

        if orig_speedup is not None:
            self.set_parameter("SIM_SPEEDUP", orig_speedup)

        passed = True
        if ex is not None:
            passed = False

        result = Result(test)
        result.time_elapsed = self.test_timings[desc]

        ardupilot_alive = False
        try:
            self.wait_heartbeat()
            ardupilot_alive = True
        except Exception:
            # process is dead
            self.progress("No heartbeat after test", send_statustext=False)
            self.dump_process_status(result)

            passed = False
            reset_needed = True

        try:
            self.context_pop(process_interaction_allowed=ardupilot_alive, hooks_already_removed=hooks_removed)
        except Exception as e:
            self.print_exception_caught(e, send_statustext=False)
            passed = False

        # if we haven't already reset ArduPilot because it's dead,
        # then ensure the vehicle was disarmed at the end of the test.
        # If it wasn't then the test is considered failed:
        if ardupilot_alive and self.armed() and not self.is_tracker():
            if ex is None:
                ex = ArmedAtEndOfTestException("Still armed at end of test")
            self.progress("Armed at end of test; force-rebooting SITL")
            self.set_rc_default()  # otherwise we might start calibrating ESCs...
            try:
                self.disarm_vehicle(force=True)
            except AutoTestTimeoutException:
                reset_needed = True
            self.forced_post_test_sitl_reboots += 1
            if reset_needed:
                self.progress("Force-resetting SITL")
                self.reset_SITL_commandline()
            else:
                self.progress("Force-rebooting SITL")
                self.zero_throttle()
                self.reboot_sitl(startup_location_dist_max=1000000) # that'll learn it
            passed = False
        elif ardupilot_alive and not passed:  # implicit reboot after a failed test:
            self.progress("Test failed but ArduPilot process alive; rebooting")
            self.reboot_sitl() # that'll learn it

        if self._mavproxy is not None:
            self.progress("Stopping auto-started mavproxy")
            if self.use_map:
                self.mavproxy.send("module unload map\n")
                self.mavproxy.expect("Unloaded module map")

            self.expect_list_remove(self._mavproxy)
            util.pexpect_close(self._mavproxy)
            self._mavproxy = None

        corefiles = []
        corefiles.extend(glob.glob("core*"))
        corefiles.extend(glob.glob("ap-*.core"))
        if corefiles:
            self.progress('Corefiles detected: %s' % str(corefiles))
            passed = False

        if len(self.contexts) != old_contexts_length:
            self.progress("context count mismatch (want=%u got=%u); popping extras" %
                          (old_contexts_length, len(self.contexts)))
            passed = False
            # pop off old contexts to clean up message hooks etc
            while len(self.contexts) > old_contexts_length:
                try:
                    self.context_pop(process_interaction_allowed=ardupilot_alive, hooks_already_removed=hooks_removed)
                except Exception as e:
                    self.print_exception_caught(e, send_statustext=False)
            self.progress("Done popping extra contexts")

        # make sure we don't leave around stray listeners:
        if len(self.message_hooks) != len(start_message_hooks):
            self.progress("Stray message listeners: %s vs start %s" %
                          (str(self.message_hooks), str(start_message_hooks)))
            passed = False

        if passed:
#            self.remove_bin_logs() # can't do this as one of the binlogs is probably open for writing by the SITL process.  If we force a rotate before running tests then we can do this.  # noqa
            pass
        else:
            if self.logs_dir is not None:
                # stash the binary logs and corefiles away for later analysis
                self.check_logs(name)

        if passed:
            self.progress('PASSED: "%s"' % prettyname)
        else:
            self.progress('FAILED: "%s": %s (see %s)' %
                          (prettyname, repr(ex), test_output_filename))
            result.exception = ex
            result.debug_filename = test_output_filename
            if interact:
                self.progress("Starting MAVProxy interaction as directed")
                self.mavproxy.interact()

        if self.reset_after_every_test:
            reset_needed = True

        if reset_needed:
            self.reset_SITL_commandline()

        if not self.is_tracker(): # FIXME - more to the point, fix Tracker's mission handling
            self.clear_mission(mavutil.mavlink.MAV_MISSION_TYPE_ALL)
            self.set_current_waypoint(0, check_afterwards=False)

        tee.close()

        result.passed = passed
        return result

    def defaults_filepath(self):
        return None

    def start_mavproxy(self, sitl_rcin_port=None, master=None, options=None):
        self.start_mavproxy_count += 1
        if self.mavproxy is not None:
            return self.mavproxy
        self.progress("Starting MAVProxy")

        # determine a good pexpect timeout for reading MAVProxy's
        # output; some regmes may require longer timeouts.
        pexpect_timeout = 60
        if self.valgrind or self.callgrind:
            pexpect_timeout *= 10

        if sitl_rcin_port is None:
            sitl_rcin_port = self.sitl_rcin_port()

        if master is None:
            master = 'tcp:127.0.0.1:%u' % self.adjust_ardupilot_port(5762)

        if options is None:
            options = self.mavproxy_options()
        else:
            op = self.mavproxy_options().copy()
            op.extend(options)
            options = op

        mavproxy = util.start_MAVProxy_SITL(
            self.vehicleinfo_key(),
            master=master,
            logfile=self.mavproxy_logfile,
            options=options,
            pexpect_timeout=pexpect_timeout,
            sitl_rcin_port=sitl_rcin_port,
        )
        mavproxy.expect(r'Telemetry log: (\S+)\r\n')
        self.logfile = mavproxy.match.group(1)
        self.progress("LOGFILE %s" % self.logfile)
        self.try_symlink_tlog()

        self.expect_list_add(mavproxy)
        util.expect_setup_callback(mavproxy, self.expect_callback)
        self._mavproxy = mavproxy  # so we can clean up after tests....
        return mavproxy

    def stop_mavproxy(self, mavproxy):
        if self.mavproxy is not None:
            return
        self.progress("Stopping MAVProxy")
        self.expect_list_remove(mavproxy)
        util.pexpect_close(mavproxy)
        self._mavproxy = None

    def start_SITL(self, binary=None, sitl_home=None, **sitl_args):
        if sitl_home is None:
            sitl_home = self.sitl_home()
        start_sitl_args = {
            "breakpoints": self.breakpoints,
            "disable_breakpoints": self.disable_breakpoints,
            "gdb": self.gdb,
            "gdb_no_tui": self.gdb_no_tui,
            "gdbserver": self.gdbserver,
            "lldb": self.lldb,
            "home": sitl_home,
            "speedup": self.speedup,
            "valgrind": self.valgrind,
            "callgrind": self.callgrind,
            "wipe": True,
        }
        start_sitl_args.update(**sitl_args)
        if ("defaults_filepath" not in start_sitl_args or
                start_sitl_args["defaults_filepath"] is None):
            start_sitl_args["defaults_filepath"] = self.defaults_filepath()

        if "model" not in start_sitl_args or start_sitl_args["model"] is None:
            start_sitl_args["model"] = self.frame
        self.progress("Starting SITL", send_statustext=False)
        if binary is None:
            binary = self.binary
        self.sitl = util.start_SITL(binary, **start_sitl_args)
        self.expect_list_add(self.sitl)
        self.sup_prog = []
        count = 0
        for sup_binary in self.sup_binaries:
            self.progress("Starting Supplementary Program ", sup_binary)
            start_sitl_args["customisations"] = [sup_binary['customisation']]
            start_sitl_args["supplementary"] = True
            start_sitl_args["stdout_prefix"] = "%s-%u" % (os.path.basename(sup_binary['binary']), count)
            start_sitl_args["defaults_filepath"] = sup_binary['param_file']
            sup_prog_link = util.start_SITL(sup_binary['binary'], **start_sitl_args)
            self.sup_prog.append(sup_prog_link)
            self.expect_list_add(sup_prog_link)
            count += 1

        # mavlink will have disconnected here.  Explicitly reconnect,
        # or the first packet we send will be lost:
        if self.mav is not None:
            self.mav.reconnect()

    def get_supplementary_programs(self):
        return self.sup_prog

    def stop_sup_program(self, instance=None):
        self.progress("Stopping supplementary program")
        if instance is None:
            # close all sup programs
            for prog in self.sup_prog:
                self.expect_list_remove(prog)
                self.sup_prog.remove(prog)
                util.pexpect_close(prog)
        else:
            # close only the instance passed
            prog = self.sup_prog[instance]
            self.expect_list_remove(prog)
            self.sup_prog[instance] = None
            util.pexpect_close(prog)

    def start_sup_program(self, instance=None, args=None):
        self.progress("Starting supplementary program")
        start_sitl_args = {
            "breakpoints": self.breakpoints,
            "disable_breakpoints": self.disable_breakpoints,
            "gdb": self.gdb,
            "gdb_no_tui": self.gdb_no_tui,
            "gdbserver": self.gdbserver,
            "lldb": self.lldb,
            "home": self.sitl_home(),
            "speedup": self.speedup,
            "valgrind": self.valgrind,
            "callgrind": self.callgrind,
            "wipe": True,
        }
        for i in range(len(self.sup_binaries)):
            if instance is not None and instance != i:
                continue
            sup_binary = self.sup_binaries[i]
            start_sitl_args["customisations"] = [sup_binary['customisation']]
            if args is not None:
                start_sitl_args["customisations"] = [sup_binary['customisation'], args]
            start_sitl_args["supplementary"] = True
            start_sitl_args["defaults_filepath"] = sup_binary['param_file']
            sup_prog_link = util.start_SITL(sup_binary['binary'], **start_sitl_args)
            time.sleep(1)
            self.sup_prog[i] = sup_prog_link # add to list
            self.expect_list_add(sup_prog_link) # add to expect list

    def sitl_is_running(self):
        if self.sitl is None:
            return False
        return self.sitl.isalive()

    def autostart_mavproxy(self):
        return self.use_map

    def init(self):
        """Initilialize autotest feature."""
        self.mavproxy_logfile = self.open_mavproxy_logfile()

        if self.frame is None:
            self.frame = self.default_frame()

        if self.frame is None:
            raise ValueError("frame must not be None")

        self.progress("Starting simulator")
        self.start_SITL()

        os.environ['MAVLINK20'] = '1'

        self.progress("Starting MAVLink connection")
        self.get_mavlink_connection_going()

        if self.autostart_mavproxy():
            self.mavproxy = self.start_mavproxy()

        self.expect_list_clear()
        self.expect_list_extend([self.sitl, self.mavproxy])
        self.expect_list_extend(self.sup_prog)

        # need to wait for a heartbeat to arrive as then mavutil will
        # select the correct set of messages for us to receive in
        # self.mav.messages.  You can actually receive messages with
        # recv_match and those will not be in self.mav.messages until
        # you do this!
        self.wait_heartbeat()
        self.get_autopilot_firmware_version()
        self.progress("Sim time: %f" % (self.get_sim_time(),))
        self.apply_default_parameters()

        if not self.sitl_is_running():
            # we run this just to make sure exceptions are likely to
            # work OK.
            raise NotAchievedException("SITL is not running")
        self.progress("SITL is running")

        self.progress("Ready to start testing!")

    def upload_using_mission_protocol(self, mission_type, items):
        '''mavlink2 required'''
        target_system = 1
        target_component = 1
        self.do_timesync_roundtrip()
        tstart = self.get_sim_time()
        self.mav.mav.mission_count_send(target_system,
                                        target_component,
                                        len(items),
                                        mission_type)
        remaining_to_send = set(range(0, len(items)))
        sent = set()
        timeout = (10 + len(items)/10.0)
        while True:
            if self.get_sim_time_cached() - tstart > timeout:
                raise NotAchievedException("timeout uploading %s" % str(mission_type))
            if len(remaining_to_send) == 0:
                self.progress("All sent")
                break
            m = self.mav.recv_match(type=['MISSION_REQUEST', 'MISSION_ACK'],
                                    blocking=True,
                                    timeout=1)
            if m is None:
                continue

            if m.get_type() == 'MISSION_ACK':
                if (m.target_system == 255 and
                        m.target_component == 0 and
                        m.type == 1 and
                        m.mission_type == 0):
                    # this is just MAVProxy trying to screw us up
                    continue
                else:
                    raise NotAchievedException("Received unexpected mission ack %s" % str(m))

            self.progress("Handling request for item %u/%u" % (m.seq, len(items)-1))
            self.progress("Item (%s)" % str(items[m.seq]))
            if m.seq in sent:
                self.progress("received duplicate request for item %u" % m.seq)
                continue

            if m.seq not in remaining_to_send:
                raise NotAchievedException("received request for unknown item %u" % m.seq)

            if m.mission_type != mission_type:
                raise NotAchievedException("received request for item from wrong mission type")

            if items[m.seq].mission_type != mission_type:
                raise NotAchievedException(f"supplied item not of correct mission type (want={mission_type} got={items[m.seq].mission_type}")  # noqa:501
            if items[m.seq].target_system != target_system:
                raise NotAchievedException("supplied item not of correct target system")
            if items[m.seq].target_component != target_component:
                raise NotAchievedException("supplied item not of correct target component")
            if items[m.seq].seq != m.seq:
                raise NotAchievedException("supplied item has incorrect sequence number (%u vs %u)" %
                                           (items[m.seq].seq, m.seq))

            items[m.seq].pack(self.mav.mav)
            self.mav.mav.send(items[m.seq])
            remaining_to_send.discard(m.seq)
            sent.add(m.seq)

            timeout += 10  # we received a good request for item; be generous with our timeouts

        m = self.assert_receive_message('MISSION_ACK', timeout=1)
        if m.mission_type != mission_type:
            raise NotAchievedException("Mission ack not of expected mission type")
        if m.type != mavutil.mavlink.MAV_MISSION_ACCEPTED:
            raise NotAchievedException("Mission upload failed (%s)" %
                                       (mavutil.mavlink.enums["MAV_MISSION_RESULT"][m.type].name),)
        self.progress("Upload of all %u items succeeded" % len(items))

    def download_using_mission_protocol(self, mission_type, verbose=False, timeout=10):
        '''mavlink2 required'''
        target_system = 1
        target_component = 1
        self.progress("Sending mission_request_list")
        tstart = self.get_sim_time()
        self.mav.mav.mission_request_list_send(target_system,
                                               target_component,
                                               mission_type)

        while True:
            if self.get_sim_time_cached() - tstart > timeout:
                raise NotAchievedException("Did not get MISSION_COUNT packet")
            m = self.mav.recv_match(blocking=True, timeout=0.1)
            if m is None:
                raise NotAchievedException("Did not get MISSION_COUNT response")
            if verbose:
                self.progress(str(m))
            if m.get_type() == 'MISSION_ACK':
                if m.target_system == 255 and m.target_component == 0:
                    # this was for MAVProxy
                    continue
                self.progress("Mission ACK: %s" % str(m))
                raise NotAchievedException("Received MISSION_ACK while waiting for MISSION_COUNT")
            if m.get_type() != 'MISSION_COUNT':
                continue
            if m.target_component != self.mav.source_system:
                continue
            if m.mission_type != mission_type:
                raise NotAchievedException("Mission count response of incorrect type")
            break

        items = []
        tstart = self.get_sim_time_cached()
        remaining_to_receive = set(range(0, m.count))
        next_to_request = 0
        timeout = m.count
        timeout *= self.speedup / 10.0
        timeout += 10
        while True:
            delta_t = self.get_sim_time_cached() - tstart
            if delta_t > timeout:
                raise NotAchievedException(
                    "timeout downloading type=%s after %s seconds of %s allowed" %
                    (mavutil.mavlink.enums["MAV_MISSION_TYPE"][mission_type].name,
                     delta_t, timeout))
            if len(remaining_to_receive) == 0:
                self.progress("All received")
                return items
            self.progress("Requesting item %u (remaining=%u)" %
                          (next_to_request, len(remaining_to_receive)))
            self.mav.mav.mission_request_int_send(target_system,
                                                  target_component,
                                                  next_to_request,
                                                  mission_type)
            m = self.mav.recv_match(type='MISSION_ITEM_INT',
                                    blocking=True,
                                    timeout=5,
                                    condition='MISSION_ITEM_INT.mission_type==%u' % mission_type)
            if m is None:
                raise NotAchievedException("Did not receive MISSION_ITEM_INT")
            if m.target_system != self.mav.source_system:
                raise NotAchievedException("Wrong target system (want=%u got=%u)" %
                                           (self.mav.source_system, m.target_system))
            if m.target_component != self.mav.source_component:
                raise NotAchievedException("Wrong target component")
            self.progress("Got (%s)" % str(m))
            if m.mission_type != mission_type:
                raise NotAchievedException("Received waypoint of wrong type")
            if m.seq != next_to_request:
                raise NotAchievedException("Received waypoint is out of sequence")
            self.progress("Item %u OK" % m.seq)
            timeout += 10  # we received an item; be generous with our timeouts
            items.append(m)
            next_to_request += 1
            remaining_to_receive.discard(m.seq)

    def dump_message_verbose(self, m):
        '''return verbose dump of m.  Wraps the pymavlink routine which
        inconveniently takes a filehandle'''
        f = StringIO.StringIO()
        mavutil.dump_message_verbose(f, m)
        return f.getvalue()

    def poll_home_position(self, quiet=True, timeout=30):
        old = self.mav.messages.get("HOME_POSITION", None)
        tstart = self.get_sim_time()
        while True:
            if self.get_sim_time_cached() - tstart > timeout:
                raise NotAchievedException("Failed to poll home position")
            if not quiet:
                self.progress("Sending MAV_CMD_GET_HOME_POSITION")
            try:
                self.run_cmd(
                    mavutil.mavlink.MAV_CMD_GET_HOME_POSITION,
                    quiet=quiet,
                )
            except ValueError:
                continue
            m = self.mav.messages.get("HOME_POSITION", None)
            if m is None:
                continue
            if old is None:
                break
            if m._timestamp != old._timestamp:
                break
        self.progress("Polled home position (%s)" % str(m))
        return m

    def position_target_loc(self):
        '''returns target location based on POSITION_TARGET_GLOBAL_INT'''
        m = self.mav.messages.get("POSITION_TARGET_GLOBAL_INT", None)
        return mavutil.location(m.lat_int*1e-7, m.lon_int*1e-7, m.alt)

    def current_waypoint(self):
        m = self.assert_receive_message('MISSION_CURRENT')
        return m.seq

    def distance_to_nav_target(self, use_cached_nav_controller_output=False):
        '''returns distance to waypoint navigation target in metres'''
        m = self.mav.messages.get("NAV_CONTROLLER_OUTPUT", None)
        if m is None or not use_cached_nav_controller_output:
            m = self.assert_receive_message('NAV_CONTROLLER_OUTPUT', timeout=10)
        return m.wp_dist

    def distance_to_home(self, use_cached_home=False):
        m = self.mav.messages.get("HOME_POSITION", None)
        if use_cached_home is False or m is None:
            m = self.poll_home_position(quiet=True)
        here = self.assert_receive_message('GLOBAL_POSITION_INT')
        return self.get_distance_int(m, here)

    def home_position_as_mav_location(self):
        m = self.poll_home_position()
        return mavutil.location(m.latitude*1.0e-7, m.longitude*1.0e-7, m.altitude*1.0e-3, 0)

    def offset_location_ne(self, location, metres_north, metres_east):
        '''return a new location offset from passed-in location'''
        (target_lat, target_lng) = mavextra.gps_offset(location.lat,
                                                       location.lng,
                                                       metres_east,
                                                       metres_north)
        return mavutil.location(target_lat,
                                target_lng,
                                location.alt,
                                location.heading)

    def monitor_groundspeed(self, want, tolerance=0.5, timeout=5):
        tstart = self.get_sim_time()
        while True:
            if self.get_sim_time_cached() - tstart > timeout:
                break
            m = self.assert_receive_message('VFR_HUD', timeout=timeout)
            if m.groundspeed > want+tolerance:
                raise NotAchievedException("Too fast (%f > %f)" %
                                           (m.groundspeed, want))
            if m.groundspeed < want-tolerance:
                raise NotAchievedException("Too slow (%f < %f)" %
                                           (m.groundspeed, want))
            self.progress("GroundSpeed OK (got=%f) (want=%f)" %
                          (m.groundspeed, want))

    def set_home(self, loc):
        '''set home to supplied loc'''
        self.run_cmd_int(
            mavutil.mavlink.MAV_CMD_DO_SET_HOME,
            p5=int(loc.lat*1e7),
            p6=int(loc.lng*1e7),
            p7=loc.alt,
        )

    def SetHome(self):
        '''Setting and fetching of home'''
        if self.is_tracker():
            # tracker starts armed...
            self.disarm_vehicle(force=True)
        self.reboot_sitl()

        # HOME_POSITION is used as a surrogate for origin until we
        # start emitting GPS_GLOBAL_ORIGIN
        self.wait_ekf_happy()
        orig_home = self.poll_home_position()
        if orig_home is None:
            raise AutoTestTimeoutException()
        self.progress("Original home: %s" % str(orig_home))
        # original home should be close to SITL home...
        start_loc = self.sitl_start_location()
        self.progress("SITL start loc: %s" % str(start_loc))
        delta = abs(orig_home.latitude * 1.0e-7 - start_loc.lat)
        if delta > 0.000006:
            raise ValueError("homes differ in lat got=%f vs want=%f delta=%f" %
                             (orig_home.latitude * 1.0e-7, start_loc.lat, delta))
        delta = abs(orig_home.longitude * 1.0e-7 - start_loc.lng)
        if delta > 0.000006:
            raise ValueError("homes differ in lon  got=%f vs want=%f delta=%f" %
                             (orig_home.longitude * 1.0e-7, start_loc.lng, delta))
        if self.is_rover():
            self.progress("### Rover skipping altitude check unti position fixes in")
        else:
            home_alt_m = orig_home.altitude * 1.0e-3
            if abs(home_alt_m - start_loc.alt) > 2: # metres
                raise ValueError("homes differ in alt got=%fm want=%fm" %
                                 (home_alt_m, start_loc.alt))
        new_x = orig_home.latitude + 1000
        new_y = orig_home.longitude + 2000
        new_z = orig_home.altitude + 300000 # 300 metres
        print("new home: %s %s %s" % (str(new_x), str(new_y), str(new_z)))
        self.run_cmd_int(
            mavutil.mavlink.MAV_CMD_DO_SET_HOME,
            p5=new_x,
            p6=new_y,
            p7=new_z/1000.0, # mm => m
        )

        home = self.poll_home_position()
        self.progress("home: %s" % str(home))
        got_home_latitude = home.latitude
        got_home_longitude = home.longitude
        got_home_altitude = home.altitude
        if (got_home_latitude != new_x or
                got_home_longitude != new_y or
                abs(got_home_altitude - new_z) > 100): # float-conversion issues
            self.reboot_sitl()
            raise NotAchievedException(
                "Home mismatch got=(%f, %f, %f) set=(%f, %f, %f)" %
                (got_home_latitude, got_home_longitude, got_home_altitude,
                 new_x, new_y, new_z))

        self.progress("monitoring home to ensure it doesn't drift at all")
        tstart = self.get_sim_time()
        while self.get_sim_time_cached() - tstart < 10:
            home = self.poll_home_position(quiet=True)
            self.progress("home: %s" % str(home))
            if (home.latitude != got_home_latitude or
                    home.longitude != got_home_longitude or
                    home.altitude != got_home_altitude): # float-conversion issues
                self.reboot_sitl()
                raise NotAchievedException("home is drifting")

        self.progress("Waiting for EKF to start")
        self.wait_ready_to_arm()
        self.progress("now use lat=0, lon=0 to reset home to current location")
        self.run_cmd_int(
            mavutil.mavlink.MAV_CMD_DO_SET_HOME,
            p5=0, # lat
            p6=0, # lon
            p7=new_z/1000.0, # mm => m
        )
        home = self.poll_home_position()
        self.progress("home: %s" % str(home))
        if self.distance_to_home(use_cached_home=True) > 1:
            raise NotAchievedException("Setting home to current location did not work")

        self.progress("Setting home elsewhere again")
        self.run_cmd_int(
            mavutil.mavlink.MAV_CMD_DO_SET_HOME,
            p5=new_x,
            p6=new_y,
            p7=new_z/1000.0, # mm => m
        )
        if self.distance_to_home() < 10:
            raise NotAchievedException("Setting home to location did not work")

        self.progress("use param1=1 to reset home to current location")
        self.run_cmd_int(
            mavutil.mavlink.MAV_CMD_DO_SET_HOME,
            p1=1,  # use current location
            p5=37, # lat
            p6=21, # lon
            p7=new_z/1000.0, # mm => m
        )
        home = self.poll_home_position()
        self.progress("home: %s" % str(home))
        if self.distance_to_home() > 1:
            raise NotAchievedException("Setting home to current location did not work")

        if self.is_tracker():
            # tracker starts armed...
            self.disarm_vehicle(force=True)
        self.reboot_sitl()

    def zero_mag_offset_parameters(self, compass_count=3):
        self.progress("Zeroing Mag OFS parameters")
        self.get_sim_time()
        zero_offset_parameters_hash = {}
        for num in "", "2", "3":
            for axis in "X", "Y", "Z":
                name = "COMPASS_OFS%s_%s" % (num, axis)
                zero_offset_parameters_hash[name] = 0
        self.set_parameters(zero_offset_parameters_hash)
        # force-save the calibration values:
        self.run_cmd_int(mavutil.mavlink.MAV_CMD_PREFLIGHT_CALIBRATION, p2=76)
        self.progress("zeroed mag parameters")

        params = [
            [("SIM_MAG1_OFS1_X", "COMPASS_OFS_X", 0),
             ("SIM_MAG1_OFS1_Y", "COMPASS_OFS_Y", 0),
             ("SIM_MAG1_OFS1_Z", "COMPASS_OFS_Z", 0), ],
        ]
        for count in range(2, compass_count + 1):
            params += [
                [("SIM_MAG%d_OFS_X" % count, "COMPASS_OFS%d_X" % count, 0),
                 ("SIM_MAG%d_OFS_Y" % count, "COMPASS_OFS%d_Y" % count, 0),
                 ("SIM_MAG%d_OFS_Z" % count, "COMPASS_OFS%d_Z" % count, 0), ],
            ]
        self.check_zero_mag_parameters(params)

    def forty_two_mag_dia_odi_parameters(self, compass_count=3):
        self.progress("Forty twoing Mag DIA and ODI parameters")
        self.get_sim_time()
        params = [
            [("SIM_MAG1_DIA_X", "COMPASS_DIA_X", 42.0),
             ("SIM_MAG1_DIA_Y", "COMPASS_DIA_Y", 42.0),
             ("SIM_MAG1_DIA_Z", "COMPASS_DIA_Z", 42.0),
             ("SIM_MAG1_ODI_X", "COMPASS_ODI_X", 42.0),
             ("SIM_MAG1_ODI_Y", "COMPASS_ODI_Y", 42.0),
             ("SIM_MAG1_ODI_Z", "COMPASS_ODI_Z", 42.0), ],
        ]
        for count in range(2, compass_count + 1):
            params += [
                [("SIM_MAG%d_DIA_X" % count, "COMPASS_DIA%d_X" % count, 42.0),
                 ("SIM_MAG%d_DIA_Y" % count, "COMPASS_DIA%d_Y" % count, 42.0),
                 ("SIM_MAG%d_DIA_Z" % count, "COMPASS_DIA%d_Z" % count, 42.0),
                 ("SIM_MAG%d_ODI_X" % count, "COMPASS_ODI%d_X" % count, 42.0),
                 ("SIM_MAG%d_ODI_Y" % count, "COMPASS_ODI%d_Y" % count, 42.0),
                 ("SIM_MAG%d_ODI_Z" % count, "COMPASS_ODI%d_Z" % count, 42.0), ],
            ]
        self.wait_heartbeat()
        to_set = {}
        for param_set in params:
            for param in param_set:
                (_, _out, value) = param
                to_set[_out] = value
        self.set_parameters(to_set)
        self.check_zero_mag_parameters(params)

    def check_mag_parameters(self, parameter_stuff, compass_number):
        self.progress("Checking that Mag parameter")
        for idx in range(0, compass_number, 1):
            for param in parameter_stuff[idx]:
                (_in, _out, value) = param
                got_value = self.get_parameter(_out)
                if abs(got_value - value) > abs(value) * 0.15:
                    raise NotAchievedException("%s/%s not within 15%%; got %f want=%f" % (_in, _out, got_value, value))

    def check_zero_mag_parameters(self, parameter_stuff):
        self.progress("Checking that Mag OFS are zero")
        for param_set in parameter_stuff:
            for param in param_set:
                (_in, _out, _) = param
                got_value = self.get_parameter(_out)
                max = 0.15
                if "DIA" in _out or "ODI" in _out:
                    max += 42.0
                if abs(got_value) > max:
                    raise NotAchievedException(
                        "%s/%s not within 15%%; got %f want=%f" %
                        (_in, _out, got_value, 0.0 if max > 1 else 42.0))

    def check_zeros_mag_orient(self, compass_count=3):
        self.progress("zeroed mag parameters")
        self.verify_parameter_values({"COMPASS_ORIENT": 0})
        for count in range(2, compass_count + 1):
            self.verify_parameter_values({"COMPASS_ORIENT%d" % count: 0})

    # this autotest appears to interfere with FixedYawCalibration, no idea why.
    def SITLCompassCalibration(self, compass_count=3, timeout=1000):
        '''Test Fixed Yaw Calibration"'''

        timeout /= 8
        timeout *= self.speedup

        def reset_pos_and_start_magcal(mavproxy, tmask):
            mavproxy.send("sitl_stop\n")
            mavproxy.send("sitl_attitude 0 0 0\n")
            self.get_sim_time()
            self.run_cmd(
                mavutil.mavlink.MAV_CMD_DO_START_MAG_CAL,
                p1=tmask, # p1: mag_mask
                p2=0, # retry
                p3=0, # autosave
                p4=0, # delay
                want_result=mavutil.mavlink.MAV_RESULT_ACCEPTED,
                timeout=20,
            )
            mavproxy.send("sitl_magcal\n")

        def do_prep_mag_cal_test(mavproxy, params):
            self.progress("Preparing the vehicle for magcal")
            MAG_OFS = 100
            MAG_DIA = 1.0
            MAG_ODI = 0.004
            params += [
                [("SIM_MAG1_OFS_X", "COMPASS_OFS_X", MAG_OFS),
                 ("SIM_MAG1_OFS_Y", "COMPASS_OFS_Y", MAG_OFS + 100),
                 ("SIM_MAG1_OFS_Z", "COMPASS_OFS_Z", MAG_OFS + 200),
                 ("SIM_MAG1_DIA_X", "COMPASS_DIA_X", MAG_DIA),
                 ("SIM_MAG1_DIA_Y", "COMPASS_DIA_Y", MAG_DIA + 0.1),
                 ("SIM_MAG1_DIA_Z", "COMPASS_DIA_Z", MAG_DIA + 0.2),
                 ("SIM_MAG1_ODI_X", "COMPASS_ODI_X", MAG_ODI),
                 ("SIM_MAG1_ODI_Y", "COMPASS_ODI_Y", MAG_ODI + 0.001),
                 ("SIM_MAG1_ODI_Z", "COMPASS_ODI_Z", MAG_ODI + 0.001), ],
            ]
            for count in range(2, compass_count + 1):
                params += [
                    [("SIM_MAG%d_OFS_X" % count, "COMPASS_OFS%d_X" % count, MAG_OFS + 100 * ((count+2) % compass_count)),
                     ("SIM_MAG%d_OFS_Y" % count, "COMPASS_OFS%d_Y" % count, MAG_OFS + 100 * ((count+3) % compass_count)),
                     ("SIM_MAG%d_OFS_Z" % count, "COMPASS_OFS%d_Z" % count, MAG_OFS + 100 * ((count+1) % compass_count)),
                     ("SIM_MAG%d_DIA_X" % count, "COMPASS_DIA%d_X" % count, MAG_DIA + 0.1 * ((count+2) % compass_count)),
                     ("SIM_MAG%d_DIA_Y" % count, "COMPASS_DIA%d_Y" % count, MAG_DIA + 0.1 * ((count+3) % compass_count)),
                     ("SIM_MAG%d_DIA_Z" % count, "COMPASS_DIA%d_Z" % count, MAG_DIA + 0.1 * ((count+1) % compass_count)),
                     ("SIM_MAG%d_ODI_X" % count, "COMPASS_ODI%d_X" % count, MAG_ODI + 0.001 * ((count+2) % compass_count)),
                     ("SIM_MAG%d_ODI_Y" % count, "COMPASS_ODI%d_Y" % count, MAG_ODI + 0.001 * ((count+3) % compass_count)),
                     ("SIM_MAG%d_ODI_Z" % count, "COMPASS_ODI%d_Z" % count, MAG_ODI + 0.001 * ((count+1) % compass_count)), ],
                ]
            self.progress("Setting calibration mode")
            self.wait_heartbeat()
            self.customise_SITL_commandline(["-M", "calibration"])
            self.mavproxy_load_module(mavproxy, "sitl_calibration")
            self.mavproxy_load_module(mavproxy, "calibration")
            self.mavproxy_load_module(mavproxy, "relay")
            self.wait_statustext("is using GPS", timeout=60)
            mavproxy.send("accelcalsimple\n")
            mavproxy.expect("Calibrated")
            # disable it to not interfert with calibration acceptation
            self.mavproxy_unload_module(mavproxy, "calibration")
            if self.is_copter():
                # set frame class to pass arming check on copter
                self.set_parameter("FRAME_CLASS", 1)
            self.progress("Setting SITL Magnetometer model value")
            self.set_parameter("COMPASS_AUTO_ROT", 0)
            # MAG_ORIENT = 4
            # self.set_parameter("SIM_MAG1_ORIENT", MAG_ORIENT)
            # for count in range(2, compass_count + 1):
            #     self.set_parameter("SIM_MAG%d_ORIENT" % count, MAG_ORIENT * (count % 41))
            #     # set compass external to check that orientation is found and auto set
            #     self.set_parameter("COMPASS_EXTERN%d" % count, 1)
            to_set = {}
            for param_set in params:
                for param in param_set:
                    (_in, _out, value) = param
                    to_set[_in] = value
                    to_set[_out] = value
            self.set_parameters(to_set)
            self.start_subtest("Zeroing Mag OFS parameters with Mavlink")
            self.zero_mag_offset_parameters()
            self.progress("=========================================")
            # Change the default value to unexpected 42
            self.forty_two_mag_dia_odi_parameters()
            self.progress("Zeroing Mags orientations")
            self.set_parameter("COMPASS_ORIENT", 0)
            for count in range(2, compass_count + 1):
                self.set_parameter("COMPASS_ORIENT%d" % count, 0)

            # Only care about compass prearm
            self.set_parameter("ARMING_CHECK", 4)

        #################################################
        def do_test_mag_cal(mavproxy, params, compass_tnumber):
            self.start_subtest("Try magcal and make it stop around 30%")
            self.progress("Compass mask is %s" % "{0:b}".format(target_mask))
            reset_pos_and_start_magcal(mavproxy, target_mask)
            tstart = self.get_sim_time()
            reached_pct = [0] * compass_tnumber
            tstop = None
            while True:
                if self.get_sim_time_cached() - tstart > timeout:
                    raise NotAchievedException("Cannot receive enough MAG_CAL_PROGRESS")
                m = self.mav.recv_match(type='MAG_CAL_PROGRESS', blocking=True, timeout=5)
                if m is None:
                    if tstop is not None:
                        # wait 3 second to unsure that the calibration is well stopped
                        if self.get_sim_time_cached() - tstop > 10:
                            if reached_pct[0] > 33:
                                raise NotAchievedException("Mag calibration didn't stop")
                            else:
                                break
                        else:
                            continue
                    else:
                        continue
                if m is not None:
                    self.progress("Mag CAL progress: %s" % str(m))
                    cid = m.compass_id
                    new_pct = int(m.completion_pct)
                    if new_pct != reached_pct[cid]:
                        if new_pct < reached_pct[cid]:
                            raise NotAchievedException("Mag calibration restart when it shouldn't")
                        reached_pct[cid] = new_pct
                        self.progress("Calibration progress compass ID %d: %s%%" % (cid, str(reached_pct[cid])))
                        if cid == 0 and 13 <= reached_pct[0] <= 15:
                            self.progress("Request again to start calibration, it shouldn't restart from 0")
                            self.run_cmd(
                                mavutil.mavlink.MAV_CMD_DO_START_MAG_CAL,
                                p1=target_mask,
                                want_result=mavutil.mavlink.MAV_RESULT_ACCEPTED,
                                timeout=20,
                            )

                if reached_pct[0] > 30:
                    self.run_cmd(
                        mavutil.mavlink.MAV_CMD_DO_CANCEL_MAG_CAL,
                        p1=target_mask,
                        want_result=mavutil.mavlink.MAV_RESULT_ACCEPTED,
                    )
                    if tstop is None:
                        tstop = self.get_sim_time_cached()
                if tstop is not None:
                    # wait 3 second to unsure that the calibration