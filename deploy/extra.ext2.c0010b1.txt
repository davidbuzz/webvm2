ta5
1) Arming check that main loop is running at configured speed (e.g. SCHED_LOOP_RATE)
2) uBlox M10 support
3) Autopilot specific changes
    a) CubeOrange defaults to using 2nd IMU as primary
    b) SIRF and SBP GPS disabled on BeastF7v2, MatekF405-STD, MAtekF405-Wing, omnibusf4pro
4) Bug fixes
    a) Camera driver's CAM_MIN_INTERVAL fixed if pilot manually triggers extra picture
    b) Main loop slowdown after arming fixed (parameter logging was causing delays)
    c) Main loop's fast tasks always run (caused twitches in Loiter on heavily loaded CPUs)
    d) MAVLink commands received on private channels checked for valid target sysid
    e) ModalAI cameras support fixed (ODOMETRY message frame was consumed incorrectly)
    f) Param reset after firmware load fixed on these boards
        - BeastF7v2
        - CubeYellow-bdshot
        - f405-MatekAirspeed
        - FlywooF745Nano
        - KakuteF4Mini
        - KakuteF7-bdshot
        - MatekF405-bdshot
        - MatekF405-STD
        - MatekF405-Wing-bdshot
        - MatekF765-SE
        - MatekF765-Wing-bdshot
    g) Siyi A8 gimbal support fixed
    h) Windows builds move to compiling only 64-bit executables
------------------------------------------------------------------
Rover 4.3.0-beta5 17-Nov-2022
Changes from 4.3.0-beta4
1) Autopilot specific enhancements
   a) ARKV6X support
   b) MatekH743 supports 8 bi-directional dshot channels
   c) Pixhawk boards support MS5607 baros
   d) SpeedbyBee F405v3 support
2) Balancebot pitch control improvements and pitch limiting
3) DroneCAN Airspeed sensor support including hygrometer (aka water vapour) readings
4) EFI support (electronic fuel injection engines)
5) Harmonic Notch support (Rover only)
6) Pre-arm warning if multiple UARTs with SERIALx_PROTOCOL = RCIN
7) Siyi gimbal support
8) Bug fixes
    a) AtomRCF405NAVI bootloader file name fixed
    b) BRD_SAFETY_MASK fixed on boards with both FMU safety switch and IOMCU
    c) Compass calibration continues even if a single compass's cal fails
    d) Gremsy gimbal driver sends autopilot info at lower rate to save bandwidth
    e) Invensense 42605 and 42609 IMUs use anti-aliasing filter and notch filter
    f) OSD stats screen fix
    g) RC input on serial port uses first UART with SERIALx_PROTOCOL = 23 (was using last)
    h) RunCam caching fix with enablement and setup on 3-pos switch
    i) RTK CAN GPS fix when GPSs conneted to separate CAN ports on autopilot
------------------------------------------------------------------
Rover 4.3.0-beta4 24-Oct-2022
Changes from 4.3.0-beta3
1) Scripting supports implementing AUX functions
2) Bug fixes
    a) BMI085 accel scaling fixed
    b) Build with gcc 11.3 fixed (developer only)
    c) EKF3 alt discrepancy if GPS or baro alt changed soon after startup fixed
    d) Harmonic Notch and ESC telem fix when motor outputs are non-contiguous
    e) NMEA GPS's KSXT message parsing fixed (affected position accuracy)
    f) Scripting random number generator fix
------------------------------------------------------------------
Rover 4.3.0-beta3 14-Oct-2022
Changes from 4.3.0-beta2
1) Pixhawk1-1M, fmuv2, fmuv3 display warning if firmware mismatches board's flash size (1M and 2M)
2) Scripting support for multi-byte i2c reads
3) Bug fixes
    a) Airspeed CAN sensor ordering fixed (ordering could change if using multiple airspeed sensors)
    b) BRD_SAFETY_MASK fix for enabling outputs when safety is on
    c) Defaults.parm file processing fixed when a line has >100 characters and/or no new line (developer only)
    d) NMEA serial output precision fixed (was only accurate to 1m, now accurate to 1cm)
------------------------------------------------------------------
Rover 4.3.0-beta2 04-Oct-2022
Changes from 4.3.0-beta1
1) Autopilot specific fixes and enhancements
    a) AIRLink autopilot supports UART2
    b) CUAV V6X supports CAN battery monitor by default
    c) MatekF405-CAN board uses less memory to fix compass calibration issues
    d) Pixhawk1-1M only supports uBlox and NMEA GPSs to save flash space
    e) SkystarsH7HD-bdshot (allows Bi-directional DShot)
    f) SkystarsH7HD supports VTX power by default
2) EFI support
    a) Currawong ECU support (added as Electronic Fuel Injection driver)
    b) Scripting support for EFI drivers (allows writing EFI drivers in Lua)
    c) SkyPower and HFE CAN EFI drivers (via scripting)
3) Safety features
    a) Arming check that SPIN_MIN less than 0.3 and greater than SPIN_ARM
    b) Arming option to disable itermittant display of pre-arm warnings (see ARMING_OPTIONS)
4) Minor enhancements
    a) Autopilot board names max length increased to 23 characters (was 13)
    b) CAN actuators can report PWM equivalent values (eases debugging)
    c) Log download speed improved for boards with "block" backends
    d) Notch filter slew limit reduces chance of notch freq moving incorrectly 
    e) SLCAN disabled when vehicle is armed to reduce CPU load
5) Bug fixes
    a) DO_JUMP mission command fixed if active command changed before changing to Auto mode
    b) EKF3 altitude error fix when using dual GPSs and affinity enabled
    c) FFT indexing bug fixed
    d) Gimbal mount fix to default mode (see MNTx_DEFLT_MODE parameter)
    e) MSP fix to report arm status to DJI FPV goggles
    f) Notch fix for non-throttle notch (was being incorrectly disabled)
    g) OSD fixes for params, font and resolution
    h) RPM reporting from harmonic notch fixed
    i) "Sending unknown message (50)" warning removed
    j) SBF/GSOF/NOVA GPS auto detction of baud rate fixed
    k) VideoTX fixes for buffer overruns and Tramp video transmitter support
------------------------------------------------------------------
Rover 4.3.0-beta1 14-Sep-2022
Changes from 4.2.3
1) Rover specific enhancements
    a) Aux switch for SaveWP displays, "Mission Cleared" if vehicle not armed
    b) Dock mode using modified precision landing library
    c) Manual mode steering scaling with speed can be disabled using MANUAL_OPTIONS parameter
    d) S-Curves for Auto, Guided, RTL
2) Rover specific bug fixes
    a) Wheel encoder timestamp fix (WRC_xx params may need to be changed)
    b) Auto mode stick mixing fixed (see STICK_MIXING parameter)
    c) Arming check removed to support mixed Ackerman and skid-stering vehicles
3) New autopilot support
    a) AtomRCF405
    b) CubeOrange-SimOnHardWare
    c) DevEBoxH7v2
    d) KakuteH7Mini-Nand
    e) KakuteH7v2
    f) Mamba F405 Mk4
    g) SkystarsH7HD
    h) bi-directional dshot (aka "bdshot") versions for CubeOrange, CubeYellow, KakuteF7, KakuteH7, MatekF405-Wing, Matek F765, PH4-mini, Pixhawk-1M
4) EKF enhancements and fixes
    a) EK3_GPS_VACC_MAX threshold to control when GPS altitude is used as alt source
    b) EKF ring buffer fix for very slow sensor updates (those that update once every few seconds)
    c) EKF3 source set change captured in Replay logs
5) Gimbal enhancements
    a) Angle limit params renamed and scaled to degrees (e.g. MNT1_ROLL_MIN, MNT1_PITCH_MIN, etc)
    b) BrushlessPWM driver (set MNT1_TYPE = 7) is unstabilized Servo driver
    c) Dual mount support (see MNT1_, MNT2 params)
    d) Gremsy driver added (set MNT1_TYPE = 6)
    e) MAVLink gimbalv2 support including sending GIMBAL_DEVICE_STATUS_UPDATE (replaces MOUNT_STATUS message)
    f) "Mount Lock" auxiliary switch supports follow and lock modes in RC targetting (aka earth-frame and body-frame)    
    g) RC channels to control gimbal set using RCx_OPTION = 212 (Roll), 213 (Pitch) or 214 (Yaw)
    h) RC targetting rotation rate in deg/sec (see MNT1_RC_RATE which replaces MNT_JSTICK_SPD)
    i) Yaw can be disabled on 3-axis gimbals (set MNTx_YAW_MIN = MNTx_YAW_MAX)
6) Notch filter enhancements
    a) Attitude and filter logging at main loop rate
    b) Batch sampler logging both pre and post-filter
    c) FFT frame averaging
    d) In-flight throttle notch parameter learning using averaged FFTs
    e) Triple harmonic notch 
7) RemoteId and SecureBoot enhancements
    a) Remote update of secure boot's public keys (also allows remote unlocking of bootloader)
8) Safety enhancements
    a) crash_dump.bin file saved to SD Card on startup (includes details re cause of software failures)
    b) Disabling Fence clears any active breaches (e.g. FENCE_TYPE = 0 will clear breaches)
    c) "GPS Glitch" message clarified to "GPS Glitch or Compass error"
    d) Pre-arm check that configured AHRS is being used (e.g. checks AHRS_EKF_TYPE not changed since boot)
    e) Pre-arm check that gimbals are healthy (currently only for Gremsy gimbals, others in future release)
    f) Pre-arm check that scripts are running
    g) Pre-arm messages are correctly prefixed with "PreArm:" (instead of "Arm:")
    h) RC auxiliary switch option for Arm / Emergency Stop
9) Scripting enhancements
    a) CAN2 port bindings to allow scripts to communicate on 2nd CAN bus
    b) ESC RPM bindings to allow scripts to report engine RPM
    c) Gimbal bingings to allow scripts to control gimbal
    d) Pre-arm check bindings (allows scripts to check if pre-arm checks have passed)
    e) Semicolon (:) and period (.) supported (e.g both Logger:write() and Logger.write will work)
10) Sensor driver enhancements
    a) Benewake H30 radar support
    b) BMI270 IMU performance improvements
    c) IRC Tramp VTX suppor
    d) Logging pause-able with auxiliary switch.  see RCx_OPTION = 165 (Pause Stream Logging)
    e) Proximity sensor support for up to 3 sensors
    f) Precision Landing consumes LANDING_TARGET MAVLink message's PositionX,Y,Z fields
    g) RichenPower generator maintenance-required messages can be suppressed using GEN_OPTIONS param
    h) TeraRanger Neo rangefinder support
    i) GPS support to provide ellipsoid altitude instead of AMSL (see GPS_DRV_OPTIONS)
    j) W25N01GV 1Gb flash support
11) Bug fixes
    a) Accel calibration throws away queued commands from GCS (avoids commands being run long after they were sent)
    b) Cygbot proximity sensor fix to support different orientations (see PRXx_ORIENT)
    c) Lutan EFI message flood reduced
    d) Missions download to GCS corruption avoided by checking serial buffer has space
    e) Safety switch disabled if IOMCU is disabled (see BRD_IO_ENABLE=0)
    f) Script restart memory leak fixed
12) Developer items
    a) Fast loop task list available in real-time using @SYS/tasks.txt
    b) Parameter defaults sent to GCS with param FTP and recorded in onboard logs
    c) ROS+ArduPilot environment installation script
    d) Sim on Hardware allows simulator to run on autopilot (good for exhibitions)
    e) Timer info available in real-time using @SYS/timers.txt
------------------------------------------------------------------
Rover 4.2.3 30-Aug-2022
Changes from 4.2.3-rc3
1) OpenDroneId bug fix to consume open-drone-id-system-update message
------------------------------------------------------------------
Rover 4.2.3-rc3 20-Aug-2022
Changes from 4.2.3-rc2
1) OpenDroneId improvements including reporting if operator location is lost
2) Firmware ID and CRC check (disabled by default)
3) Bug Fixes
    a) Revert Notch filter ordering on loss of RPM source (see 4.2.3-rc1's 3g below) because fix is incomplete
------------------------------------------------------------------
Rover 4.2.3-rc2 13-Aug-2022
Changes from 4.2.3-rc1
1) BlueRobotics Navigator autopilot filesystem fix
------------------------------------------------------------------
Rover 4.2.3-rc1 12-Aug-2022
Changes from 4.2.2
1) OpenDroneId support (aka RemoteID)
2) New autopilot support
    a) CubeOrange+
    b) Foxeer Reaper F745
    c) MFE PixSurveyA1
    d) Pixhawk6C and Pixhawk6X
3) Bug Fixes and minor enhancements
    a) Battery monitor health check fixed to check all enabled monitors
    b) ICE Lutan EFI update serial flood fixed
    c) ICM42xxx IMU filter settings improved and allow for faster sample rates
    d) INA2xx batteries may init after startup
    e) KakuteH7 OSD parameter menu enabled
    f) Lua script support to set desired speed in Auto mode
    g) Notch filter ordering bug on loss of RPM source fixed
    h) PreArm check of Rangefinder pin conflict and servo outputs
    i) SCurve logs debug if internal error occurs
    j) WSL2 upload fixed (developer issue only)
------------------------------------------------------------------
Rover 4.2.2 28-Jun-2022 / 4.2.2-rc1 21-Jun-2022
Changes from 4.2.1
1) MambaH743v4 and MambaF405 MK4 autopilot support
2) Second full harmonic notches available (see INS_HNTC2_ parameters)
3) UAVCAN memory usage reduced (see CAN_Dn_UC_POOL parameter to control DroneCAN pool size)
5) Watchdog (caused by hardfault) saves crash dump logs to SD card
6) Bug fixes
    a) CRSF protection against watchdog on bad frames
    b) CRSF reset in flight handled
    c) FFT init watchdog fix when ARMING_REQUIRE=0
    d) OSD flight modes menu includes newer flight modes
    e) Param download (via MAVFTP) fixed for params with overlapping names
    f) PWM rangefinder bug fix and added SCALING parameter support
    g) Replay bug fix when EK3_SRCs changed
    h) SERIALx_OPTION fix when "Don't forward mavlink to/from" selected (resolves MAVLink gimbal detection)
    i) VL53L1X rangefinder preserves addresses
------------------------------------------------------------------
Rover 4.2.1 07-Jun-2022 / 4.2.1-rc1 28-May-2022
Changes from 4.2.0
1) CAN ESCs bus bandwidth efficiency improvements (see CAN_Dx_UC_ESC_OF parameter)
2) DShot timing improvements to support for ESC variants
3) Luftan EFI measures fuel consumption (see EFI_COEF1, EFI_COEF2)
4) Bug fixes
    b) CAN ESCs work on boards with no safety switch (e.g. MatekH743)
    b) Inflight Compass calibration checks GSF yaw estimate is good
    c) NeoPixel colour fix
------------------------------------------------------------------
Rover 4.2.0 23-May-2022 / 4.2.0-rc4 14-May-2022
Changes from 4.2.0-rc3
1) FlyingMoon F407 and F427 autopilots supported
2) Bug fixes
    a) Log file list with over 500 logs fixed
    b) RSSI when using IOMCU pin 103 fixed
------------------------------------------------------------------
Rover 4.2.0-rc3 07-May-2022
Changes from 4.2.0-rc2
1) Bug fixes
    a) Blended Z axis accel calculation fix when not using first IMU
    b) Custom compass orientation for DroneCAN compasses
------------------------------------------------------------------
Rover 4.2.0-rc2 29-Apr-2022
Changes from 4.2.0-rc1
1) Minor Enhancements
    a) Button, Relay and RPM GPIO pin conflict pre-arm check improved
    b) DShot uses narrower bitwidths for more accurate timing (allows BLHeli BlueJay to work)
    c) INS_NOTCH parameters renamed to INS_HNTC2
    d) Matek F765-Wing-bdshot firmware added
    e) Matek H743 supports ICM42688
    f) QiotekZealot H743 supports ICM4xxxx
    g) Scripting heap size increased to 100k on F7/H7
    h) SPRacingH7 improvements including external flash performance improvements
2) Bug fixes
    a) BMI088 IMU FIFO overruns fixed
    b) DO_SET_SERVO with SERVOn_FUNCTION=0 fixed, added pre-arm check of servo functions configured on disabled channels
    c) Log file descriptor init fixed (issues only seen on Linux autopilots)
    d) Log list cope with gaps, performance improvement to reduce impact on EKF and some ESCs
    e) Proximity sensor fix when using MAVLink lidars in non-forward orientations
    f) RPM sensor fix to avoid "failed to attach pin" spam to GCS
    g) STM32 DMA fatal exceptions disabled (caused watch dogs reboots with zero information)
------------------------------------------------------------------
Rover 4.2.0-rc1 10-Apr-2022
Changes from 4.2.0-beta3
1) Minor Enhancements
    a) Log and monitor threads stack size increased
    b) SPro H7 Extreme QSPI support improved
2) Bug fixes
    a) EKF3 accel bias fixed when an IMU is disabled
    b) MatekH743 buzzer fixed by reverting to 16 bit timer
    c) STM32 H7 flash storage bug fixed that caused re-init on overflow
    d) @SYS file logging fixed
    e) Timer bug fixed that could cause a watchdog on boards using flash storage
    f) UART driver incorrect lock class fixed
------------------------------------------------------------------
Rover 4.2.0-beta3 30-Mar-2022
Changes from 4.2.0-beta2
1) Minor Enhancements
    a) BATT_OPTIONS supports sending resting voltage (corrected for internal resistance) to the ground station
    b) KakuteH7-bdshot support
    c) MatekH743 uses a 32 bit timer to resolve occasional 68ms timing glitch
    d) RC input protocol text message sent to GCS (helps pilot awareness during RC handover)
2) Bug fixes
    a) Balance bot stands in acro mode even with no GPS
    b) Battery remaining percentage fixed when using Sum battery
    c) DShot reversal bug with IOMCU based boards (see SERVO_BLH_RVMASK)
    d) DShot commands fixed (could cause random motor movements)
    e) GPS blending fix that could have resulted in the wrong GPS being used for a short time
    f) Param conversion bug (impacted airspeed enable)
    g) RC handover between IOMCU RC input and a secondary RC input on a serial port fixed
    h) QioTek Zealot H743 SLCAN port and relays fixed
------------------------------------------------------------------
Rover 4.2.0-beta2 10-Mar-2022
Changes from 4.2.0-beta1
1) Follow mode supports FOLLOW_TARGET message (sent by QGC ground station) 
2) Bug fixes
    a) Arming checks ignore SERVOx_MIN, MAX if setup as GPIO pin
    b) BeastH7v2 BMI270 baro support
    c) DShot prescaler fix (ESCs were not initialising correctly)
    d) EKF3 variance constraint fix used to prevent "ill-conditioning"
    e) POWR log message MCU voltage fix (min and max voltage were swapped)
    f) Sailboats loiter fix (could get stuck pointing directly into the wind)
    g) SPRacingH7 firmware install fix
------------------------------------------------------------------
Rover 4.2.0-rc1 28-Feb-2022
Changes from 4.1.5
1) AHRS/EKF improvements
    a) EKF startup messages reduced
    b) LORD Microstrain CX5/GX5 external AHRS support
    c) ModalAI VOXL non-GPS system supported (set VISO_TYPE=3, uses ODOMETRY mavlink msg)
2) Rover specific enhancements
    a) AIS support
    b) Attitude control gains defaults reduced
        - ATC_STR_ANG_P reduced to 2
        - ATC_STR_RAT_MAX reduced to 120 deg/sec
        - ATC_STR_ACC_MAX reduced to 120 deg/sec
        - ATC_ACCEL_MAX reduced to 1m/s
    c) Boats loiter by default at end of mission (see MIS_DONE_BEHAVE parameter)
    d) DPTH message supports multiple rangefinders
    e) Omni motor saturation improvement (scaling applied evenly to all motors)
    f) Pivot turn overshoot reduced (would happen with bad combination of ATC_STR_ACC_MAX and ATC_STR_ANG_P)
    g) Speed control improvement when motor hits limits (especially when MOT_SLEWRATE was set to a low number)
    h) Speed control PID logging and reporting includes FF
    i) Stops maintain zero turn rate (previously steering was straight but trim could lead to turning)
    j) Torqeedo motor support
3) Custom build server support (see https://custom.ardupilot.org)
4) Lua scripting improvements
    a) ahrs::get_location replaces get_position (get_position still works for now)
    b) Auto support for NAV_SCRIPT_TIME commands (Lua within Auto)
    c) Frame string support (allows scripting based frame to display custom description after startup)
    d) Parameter support (no need to always use SCR_USERx)
    e) Script logged to onboard log (can be disabled by setting SCR_DEBUG_OPTS)
    f) Set_turn_rate_and_speed control support
5) New autopilots supported
    a) AirLink
    b) BeastF7v2, BeastH7v2
    c) JHEMCU GSF405A
    d) KakuteH7, KakuteH7Mini
    e) MambaF405US-I2C
    f) MatekF405-TE
    g) ModalAI fc-v1
    h) PixC4-Jetson
    i) Pixhawk5X
    j) QioTekZealotH743
    k) RPI-Zero2W
    l) SPRacingH7 Extreme
    m) Swan-K1
6) Safety improvements
    a) Dijkstra's avoidance performance improvements including converting to A*
    b) Parachute option to leave servo in open position (see CHUTE_OPTIONS parameter)
    c) Pre-arm check of IMU heater temp
    d) Pre-arm check of rangefinder health
    e) Pre-arm check that not in RC/throttle failsafe
7) Sensor driver enhancements
    a) ADIS16470, ADIS16507 and BMI270 IMU support
    b) AK09918 compass support
    c) Battery monitor supports voltage offset (see BATTx_VLT_OFFSET)
    d) Benewake TFMiniPlus I2C address defaults correctly
    e) Buzzer can be connected to any GPIO on any board
    f) Compass calibration (in-flight) uses GS/*
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

/*
   This is the ArduRover firmware. It was originally derived from
   ArduPlane by Jean-Louis Naudin (JLN), and then rewritten after the
   AP_HAL merge by Andrew Tridgell

   Maintainer: Randy Mackay, Grant Morphett

   Authors:    Doug Weibel, Jose Julio, Jordi Munoz, Jason Short, Andrew Tridgell, Randy Mackay, Pat Hickey, John Arne Birkeland, Olivier Adler, Jean-Louis Naudin, Grant Morphett

   Thanks to:  Chris Anderson, Michael Oborne, Paul Mather, Bill Premerlani, James Cohen, JB from rotorFX, Automatik, Fefenin, Peter Meister, Remzibi, Yury Smirnov, Sandro Benigno, Max Levine, Roberto Navoni, Lorenz Meier

   APMrover alpha version tester: Franco Borasio, Daniel Chapelat...

   Please contribute your ideas! See https://ardupilot.org/dev for details
*/

#include "Rover.h"

#define FORCE_VERSION_H_INCLUDE
#include "version.h"
#undef FORCE_VERSION_H_INCLUDE

const AP_HAL::HAL& hal = AP_HAL::get_HAL();

#define SCHED_TASK(func, _interval_ticks, _max_time_micros, _priority) SCHED_TASK_CLASS(Rover, &rover, func, _interval_ticks, _max_time_micros, _priority)

/*
  scheduler table - all regular tasks should be listed here.

  All entries in this table must be ordered by priority.

  This table is interleaved with the table in AP_Vehicle to determine
  the order in which tasks are run.  Convenience methods SCHED_TASK
  and SCHED_TASK_CLASS are provided to build entries in this structure:

SCHED_TASK arguments:
 - name of static function to call
 - rate (in Hertz) at which the function should be called
 - expected time (in MicroSeconds) that the function should take to run
 - priority (0 through 255, lower number meaning higher priority)

SCHED_TASK_CLASS arguments:
 - class name of method to be called
 - instance on which to call the method
 - method to call on that instance
 - rate (in Hertz) at which the method should be called
 - expected time (in MicroSeconds) that the method should take to run
 - priority (0 through 255, lower number meaning higher priority)

  scheduler table - all regular tasks are listed here, along with how
  often they should be called (in Hz) and the maximum time
  they are expected to take (in microseconds)
 */
const AP_Scheduler::Task Rover::scheduler_tasks[] = {
    //         Function name,          Hz,     us,
    SCHED_TASK(read_radio,             50,    200,   3),
    SCHED_TASK(ahrs_update,           400,    400,   6),
#if AP_RANGEFINDER_ENABLED
    SCHED_TASK(read_rangefinders,      50,    200,   9),
#endif
#if AP_OPTICALFLOW_ENABLED
    SCHED_TASK_CLASS(AP_OpticalFlow,      &rover.optflow,          update,         200, 160,  11),
#endif
    SCHED_TASK(update_current_mode,   400,    200,  12),
    SCHED_TASK(set_servos,            400,    200,  15),
    SCHED_TASK_CLASS(AP_GPS,              &rover.gps,              update,         50,  300,  18),
    SCHED_TASK_CLASS(AP_Baro,             &rover.barometer,        update,         10,  200,  21),
#if AP_BEACON_ENABLED
    SCHED_TASK_CLASS(AP_Beacon,           &rover.g2.beacon,        update,         50,  200,  24),
#endif
#if HAL_PROXIMITY_ENABLED
    SCHED_TASK_CLASS(AP_Proximity,        &rover.g2.proximity,     update,         50,  200,  27),
#endif
    SCHED_TASK_CLASS(AP_WindVane,         &rover.g2.windvane,      update,         20,  100,  30),
    SCHED_TASK(update_wheel_encoder,   50,    200,  36),
    SCHED_TASK(update_compass,         10,    200,  39),
#if HAL_LOGGING_ENABLED
    SCHED_TASK(update_logging1,        10,    200,  45),
    SCHED_TASK(update_logging2,        10,    200,  48),
#endif
    SCHED_TASK_CLASS(GCS,                 (GCS*)&rover._gcs,       update_receive,                    400,    500,  51),
    SCHED_TASK_CLASS(GCS,                 (GCS*)&rover._gcs,       update_send,                       400,   1000,  54),
    SCHED_TASK_CLASS(RC_Channels,         (RC_Channels*)&rover.g2.rc_channels, read_mode_switch,        7,    200,  57),
    SCHED_TASK_CLASS(RC_Channels,         (RC_Channels*)&rover.g2.rc_channels, read_aux_all,           10,    200,  60),
    SCHED_TASK_CLASS(AP_BattMonitor,      &rover.battery,          read,           10,  300,  63),
#if AP_SERVORELAYEVENTS_ENABLED
    SCHED_TASK_CLASS(AP_ServoRelayEvents, &rover.ServoRelayEvents, update_events,  50,  200,  66),
#endif
#if AC_PRECLAND_ENABLED
    SCHED_TASK(update_precland,      400,     50,  70),
#endif
#if AP_RPM_ENABLED
    SCHED_TASK_CLASS(AP_RPM,              &rover.rpm_sensor,       update,         10,  100,  72),
#endif
#if HAL_MOUNT_ENABLED
    SCHED_TASK_CLASS(AP_Mount,            &rover.camera_mount,     update,         50,  200,  75),
#endif
#if AP_CAMERA_ENABLED
    SCHED_TASK_CLASS(AP_Camera,           &rover.camera,           update,         50,  200,  78),
#endif
    SCHED_TASK(gcs_failsafe_check,     10,    200,  81),
    SCHED_TASK(fence_check,            10,    200,  84),
    SCHED_TASK(ekf_check,              10,    100,  87),
    SCHED_TASK_CLASS(ModeSmartRTL,        &rover.mode_smartrtl,    save_position,   3,  200,  90),
    SCHED_TASK(one_second_loop,         1,   1500,  96),
#if HAL_SPRAYER_ENABLED
    SCHED_TASK_CLASS(AC_Sprayer,          &rover.g2.sprayer,       update,          3,  90,  99),
#endif
    SCHED_TASK(compass_save,            0.1,  200, 105),
#if HAL_LOGGING_ENABLED
    SCHED_TASK_CLASS(AP_Logger,           &rover.logger,           periodic_tasks, 50,  300, 108),
#endif
    SCHED_TASK_CLASS(AP_InertialSensor,   &rover.ins,              periodic,      400,  200, 111),
#if HAL_LOGGING_ENABLED
    SCHED_TASK_CLASS(AP_Scheduler,        &rover.scheduler,        update_logging, 0.1, 200, 114),
#endif
#if HAL_BUTTON_ENABLED
    SCHED_TASK_CLASS(AP_Button,           &rover.button,           update,          5,  200, 117),
#endif
    SCHED_TASK(crash_check,            10,    200, 123),
    SCHED_TASK(cruise_learn_update,    50,    200, 126),
#if AP_ROVER_ADVANCED_FAILSAFE_ENABLED
    SCHED_TASK(afs_fs_check,           10,    200, 129),
#endif
};


void Rover::get_scheduler_tasks(const AP_Scheduler::Task *&tasks,
                                uint8_t &task_count,
                                uint32_t &log_bit)
{
    tasks = &scheduler_tasks[0];
    task_count = ARRAY_SIZE(scheduler_tasks);
    log_bit = MASK_LOG_PM;
}

constexpr int8_t Rover::_failsafe_priorities[7];

Rover::Rover(void) :
    AP_Vehicle(),
    param_loader(var_info),
    modes(&g.mode1),
    control_mode(&mode_initializing)
{
}

#if AP_SCRIPTING_ENABLED || AP_EXTERNAL_CONTROL_ENABLED
// set target location (for use by external control and scripting)
bool Rover::set_target_location(const Location& target_loc)
{
    // exit if vehicle is not in Guided mode or Auto-Guided mode
    if (!control_mode->in_guided_mode()) {
        return false;
    }

    return mode_guided.set_desired_location(target_loc);
}
#endif //AP_SCRIPTING_ENABLED || AP_EXTERNAL_CONTROL_ENABLED

#if AP_SCRIPTING_ENABLED
// set target velocity (for use by scripting)
bool Rover::set_target_velocity_NED(const Vector3f& vel_ned)
{
    // exit if vehicle is not in Guided mode or Auto-Guided mode
    if (!control_mode->in_guided_mode()) {
        return false;
    }

    // convert vector length into speed
    const float target_speed_m = safe_sqrt(sq(vel_ned.x) + sq(vel_ned.y));

    // convert vector direction to target yaw
    const float target_yaw_cd = degrees(atan2f(vel_ned.y, vel_ned.x)) * 100.0f;

    // send target heading and speed
    mode_guided.set_desired_heading_and_speed(target_yaw_cd, target_speed_m);

    return true;
}

// set steering and throttle (-1 to +1) (for use by scripting)
bool Rover::set_steering_and_throttle(float steering, float throttle)
{
    // exit if vehicle is not in Guided mode or Auto-Guided mode
    if (!control_mode->in_guided_mode()) {
        return false;
    }

    // set steering and throttle
    mode_guided.set_steering_and_throttle(steering, throttle);
    return true;
}

// get steering and throttle (-1 to +1) (for use by scripting)
bool Rover::get_steering_and_throttle(float& steering, float& throttle)
{
    steering = g2.motors.get_steering() / 4500.0;
    throttle = g2.motors.get_throttle() * 0.01;
    return true;
}

// set desired turn rate (degrees/sec) and speed (m/s). Used for scripting
bool Rover::set_desired_turn_rate_and_speed(float turn_rate, float speed)
{
    // exit if vehicle is not in Guided mode or Auto-Guided mode
    if (!control_mode->in_guided_mode()) {
        return false;
    }

    // set turn rate and speed. Turn rate is expected in centidegrees/s and speed in meters/s
    mode_guided.set_desired_turn_rate_and_speed(turn_rate * 100.0f, speed);
    return true;
}

// set desired nav speed (m/s). Used for scripting.
bool Rover::set_desired_speed(float speed)
{
    return control_mode->set_desired_speed(speed);
}

// get control output (for use in scripting)
// returns true on success and control_value is set to a value in the range -1 to +1
bool Rover::get_control_output(AP_Vehicle::ControlOutput control_output, float &control_value)
{
    switch (control_output) {
    case AP_Vehicle::ControlOutput::Roll:
        control_value = constrain_float(g2.motors.get_roll(), -1.0f, 1.0f);
        return true;
    case AP_Vehicle::ControlOutput::Pitch:
        control_value = constrain_float(g2.motors.get_pitch(), -1.0f, 1.0f);
        return true;
    case AP_Vehicle::ControlOutput::Walking_Height:
        control_value = constrain_float(g2.motors.get_walking_height(), -1.0f, 1.0f);
        return true;
    case AP_Vehicle::ControlOutput::Throttle:
        control_value = constrain_float(g2.motors.get_throttle() * 0.01f, -1.0f, 1.0f);
        return true;
    case AP_Vehicle::ControlOutput::Yaw:
        control_value = constrain_float(g2.motors.get_steering() / 4500.0f, -1.0f, 1.0f);
        return true;
    case AP_Vehicle::ControlOutput::Lateral:
        control_value = constrain_float(g2.motors.get_lateral() * 0.01f, -1.0f, 1.0f);
        return true;
    case AP_Vehicle::ControlOutput::MainSail:
        control_value = constrain_float(g2.motors.get_mainsail() * 0.01f, -1.0f, 1.0f);
        return true;
    case AP_Vehicle::ControlOutput::WingSail:
        control_value = constrain_float(g2.motors.get_wingsail() * 0.01f, -1.0f, 1.0f);
        return true;
    default:
        return false;
    }
    return false;
}

// returns true if mode supports NAV_SCRIPT_TIME mission commands
bool Rover::nav_scripting_enable(uint8_t mode)
{
    return mode == (uint8_t)mode_auto.mode_number();
}

// lua scripts use this to retrieve the contents of the active command
bool Rover::nav_script_time(uint16_t &id, uint8_t &cmd, float &arg1, float &arg2, int16_t &arg3, int16_t &arg4)
{
    if (control_mode != &mode_auto) {
        return false;
    }

    return mode_auto.nav_script_time(id, cmd, arg1, arg2, arg3, arg4);
}

// lua scripts use this to indicate when they have complete the command
void Rover::nav_script_time_done(uint16_t id)
{
    if (control_mode != &mode_auto) {
        return;
    }

    return mode_auto.nav_script_time_done(id);
}
#endif // AP_SCRIPTING_ENABLED

// update AHRS system
void Rover::ahrs_update()
{
    arming.update_soft_armed();

    // AHRS may use movement to calculate heading
    update_ahrs_flyforward();

    ahrs.update();

    // update position
    have_position = ahrs.get_location(current_loc);

    // set home from EKF if necessary and possible
    if (!ahrs.home_is_set()) {
        if (!set_home_to_current_location(false)) {
            // ignore this failure
        }
    }

    // if using the EKF get a speed update now (from accelerometers)
    Vector3f velocity;
    if (ahrs.get_velocity_NED(velocity)) {
        ground_speed = velocity.xy().length();
    } else if (gps.status() >= AP_GPS::GPS_OK_FIX_3D) {
        ground_speed = ahrs.groundspeed();
    }

#if HAL_LOGGING_ENABLED
    if (should_log(MASK_LOG_ATTITUDE_FAST)) {
        Log_Write_Attitude();
        Log_Write_Sail();
    }

    if (should_log(MASK_LOG_IMU)) {
        AP::ins().Write_IMU();
    }

    if (should_log(MASK_LOG_VIDEO_STABILISATION)) {
        ahrs.write_video_stabilisation();
    }
#endif
}

/*
  check for GCS failsafe - 10Hz
 */
void Rover::gcs_failsafe_check(void)
{
    if (g.fs_gcs_enabled == FS_GCS_DISABLED) {
        // gcs failsafe disabled
        return;
    }

    const uint32_t gcs_last_seen_ms = gcs().sysid_myggcs_last_seen_time_ms();
    if (gcs_last_seen_ms == 0) {
        // we've never seen the GCS, so we never failsafe for not seeing it
        return;
    }

    // calc time since last gcs update
    // note: this only looks at the heartbeat from the device id set by g.sysid_my_gcs
    const uint32_t last_gcs_update_ms = millis() - gcs_last_seen_ms;
    const uint32_t gcs_timeout_ms = uint32_t(constrain_float(g2.fs_gcs_timeout * 1000.0f, 0.0f, UINT32_MAX));

    const bool do_failsafe = last_gcs_update_ms >= gcs_timeout_ms ? true : false;

    failsafe_trigger(FAILSAFE_EVENT_GCS, "GCS", do_failsafe);
}

#if HAL_LOGGING_ENABLED
/*
  log some key data - 10Hz
 */
void Rover::update_logging1(void)
{
    if (should_log(MASK_LOG_ATTITUDE_MED) && !should_log(MASK_LOG_ATTITUDE_FAST)) {
        Log_Write_Attitude();
        Log_Write_Sail();
    }

    if (should_log(MASK_LOG_THR)) {
        Log_Write_Throttle();
#if AP_BEACON_ENABLED
        g2.beacon.log();
#endif
    }

    if (should_log(MASK_LOG_NTUN)) {
        Log_Write_Nav_Tuning();
        if (g2.pos_control.is_active()) {
            g2.pos_control.write_log();
            logger.Write_PID(LOG_PIDN_MSG, g2.pos_control.get_vel_pid().get_pid_info_x());
            logger.Write_PID(LOG_PIDE_MSG, g2.pos_control.get_vel_pid().get_pid_info_y());
        }
    }

#if HAL_PROXIMITY_ENABLED
    if (should_log(MASK_LOG_RANGEFINDER)) {
        g2.proximity.log();
    }
#endif
}

/*
  log some key data - 10Hz
 */
void Rover::update_logging2(void)
{
    if (should_log(MASK_LOG_STEERING)) {
        Log_Write_Steering();
    }

    if (should_log(MASK_LOG_RC)) {
        Log_Write_RC();
        g2.wheel_encoder.Log_Write();
    }

    if (should_log(MASK_LOG_IMU)) {
        AP::ins().Write_Vibration();
#if HAL_GYROFFT_ENABLED
        gyro_fft.write_log_messages();
#endif
    }
#if HAL_MOUNT_ENABLED
    if (should_log(MASK_LOG_CAMERA)) {
        camera_mount.write_log();
    }
#endif
}
#endif  // HAL_LOGGING_ENABLED

/*
  once a second events
 */
void Rover::one_second_loop(void)
{
    set_control_channels();

    // cope with changes to aux functions
    SRV_Channels::enable_aux_servos();

    // update notify flags
    AP_Notify::flags.pre_arm_check = arming.pre_arm_checks(false);
    AP_Notify::flags.pre_arm_gps_check = true;
    AP_Notify::flags.armed = arming.is_armed();
    AP_Notify::flags.flying = hal.util->get_soft_armed();

    // cope with changes to mavlink system ID
    mavlink_system.sysid = g.sysid_this_mav;

    // attempt to update home position and baro calibration if not armed:
    if (!hal.util->get_soft_armed()) {
        update_home();
    }

    // need to set "likely flying" when armed to allow for compass
    // learning to run
    set_likely_flying(hal.util->get_soft_armed());

    // send latest param values to wp_nav
    g2.wp_nav.set_turn_params(g2.turn_radius, g2.motors.have_skid_steering());
    g2.pos_control.set_turn_params(g2.turn_radius, g2.motors.have_skid_steering());
    g2.wheel_rate_control.set_notch_sample_rate(AP::scheduler().get_filtered_loop_rate_hz());

#if AP_STATS_ENABLED
    // Update stats "flying" time
    AP::stats()->set_flying(g2.motors.active());
#endif
}

void Rover::update_current_mode(void)
{
    // check for emergency stop
    if (SRV_Channels::get_emergency_stop()) {
        // relax controllers, motor stopping done at o#include "Rover.h"

#define AR_CIRCLE_ACCEL_DEFAULT         1.0 // default acceleration in m/s/s if not specified by user
#define AR_CIRCLE_RADIUS_MIN            0.5 // minimum radius in meters
#define AR_CIRCLE_REACHED_EDGE_DIST     0.2 // vehicle has reached edge if within 0.2m

const AP_Param::GroupInfo ModeCircle::var_info[] = {

    // @Param: _RADIUS
    // @DisplayName: Circle Radius
    // @Description: Vehicle will circle the center at this distance
    // @Units: m
    // @Range: 0 100
    // @Increment: 1
    // @User: Standard
    AP_GROUPINFO("_RADIUS", 1, ModeCircle, radius, 20),

    // @Param: _SPEED
    // @DisplayName: Circle Speed
    // @Description: Vehicle will move at this speed around the circle.  If set to zero WP_SPEED will be used
    // @Units: m/s
    // @Range: 0 10
    // @Increment: 0.1
    // @User: Standard
    AP_GROUPINFO("_SPEED", 2, ModeCircle, speed, 0),

    // @Param: _DIR
    // @DisplayName: Circle Direction
    // @Description: Circle Direction
    // @Values: 0:Clockwise, 1:Counter-Clockwise
    // @User: Standard
    AP_GROUPINFO("_DIR", 3, ModeCircle, direction, 0),

    AP_GROUPEND
};

ModeCircle::ModeCircle() : Mode()
{
    AP_Param::setup_object_defaults(this, var_info);
}

// initialise with specific center location, radius (in meters) and direction
// replaces use of _enter when initialised from within Auto mode
bool ModeCircle::set_center(const Location& center_loc, float radius_m, bool dir_ccw)
{
    Vector2f center_pos_cm;
    if (!center_loc.get_vector_xy_from_origin_NE(center_pos_cm)) {
        return false;
    }
    if (!_enter()) {
        return false;
    }

    // convert center position from cm to m
    config.center_pos = center_pos_cm * 0.01;

    // set radius
    config.radius = MAX(fabsf(radius_m), AR_CIRCLE_RADIUS_MIN);
    check_config_radius();

    // set direction
    config.dir = dir_ccw ? Direction::CCW : Direction::CW;

    // set target yaw rad (target point on circle)
    init_target_yaw_rad();

    // record center as location (only used for reporting)
    config.center_loc = center_loc;

    return true;
}

// initialize dock mode
bool ModeCircle::_enter()
{
    // capture starting point and yaw
    if (!AP::ahrs().get_relative_position_NE_origin(config.center_pos)) {
        return false;
    }
    config.radius = MAX(fabsf(radius), AR_CIRCLE_RADIUS_MIN);
    check_config_radius();

    config.dir = (direction == 1) ? Direction::CCW : Direction::CW;
    config.speed = is_positive(speed) ? speed : g2.wp_nav.get_default_speed();
    target.yaw_rad = AP::ahrs().get_yaw();
    target.speed = 0;

    // check speed around circle does not lead to excessive lateral acceleration
    check_config_speed();

    // calculate speed, accel and jerk limits
    // otherwise the vehicle uses wp_nav default speed limit
    float atc_accel_max = MIN(g2.attitude_control.get_accel_max(), g2.attitude_control.get_decel_max());
    if (!is_positive(atc_accel_max)) {
        atc_accel_max = AR_CIRCLE_ACCEL_DEFAULT;
    }
    const float accel_max = is_positive(g2.wp_nav.get_default_accel()) ? MIN(g2.wp_nav.get_default_accel(), atc_accel_max) : atc_accel_max;
    const float jerk_max = is_positive(g2.wp_nav.get_default_jerk()) ? g2.wp_nav.get_default_jerk() : accel_max;

    // initialise position controller
    g2.pos_control.set_limits(config.speed, accel_max, g2.attitude_control.get_turn_lat_accel_max(), jerk_max);
    g2.pos_control.init();

    // initialise angles covered and reached_edge state
    angle_total_rad = 0;
    reached_edge = false;
    dist_to_edge_m = 0;

    return true;
}

// initialise target_yaw_rad using the vehicle's position and yaw
// if there is no current position estimate target_yaw_rad is set to 0
void ModeCircle::init_target_yaw_rad()
{
    // if no position estimate use vehicle yaw
    Vector2f curr_pos_NE;
    if (!AP::ahrs().get_relative_position_NE_origin(curr_pos_NE)) {
        target.yaw_rad = AP::ahrs().get_yaw();
        return;
    }

    // calc vector from circle center to vehicle
    Vector2f center_to_veh = (curr_pos_NE - config.center_pos);
    float dist_m = center_to_veh.length();

    // if current position is exactly at the center of the circle return vehicle yaw
    if (is_zero(dist_m)) {
        target.yaw_rad = AP::ahrs().get_yaw();
    } else {
        target.yaw_rad = center_to_veh.angle();
    }
}

void ModeCircle::update()
{
    // get current position
    Vector2f curr_pos;
    const bool position_ok = AP::ahrs().get_relative_position_NE_origin(curr_pos);

    // if no position estimate stop vehicle
    if (!position_ok) {
        stop_vehicle();
        return;
    }

    // Update distance to destination and distance to edge
    const Vector2f center_to_veh = curr_pos - config.center_pos;
    _distance_to_destination = center_to_veh.length();
    dist_to_edge_m = fabsf(_distance_to_destination - config.radius);

    // Update depending on stage
    if (!reached_edge) {
        update_drive_to_radius();

    } else {
        update_circling();
    }

    g2.pos_control.update(rover.G_Dt);

    // get desired speed and turn rate from pos_control
    const float desired_speed = g2.pos_control.get_desired_speed();
    const float desired_turn_rate = g2.pos_control.get_desired_turn_rate_rads();

    // run steering and throttle controllers
    calc_steering_from_turn_rate(desired_turn_rate);
    calc_throttle(desired_speed, true);
}

void ModeCircle::update_drive_to_radius()
{
    // check if vehicle has reached edge of circle
    const float dist_thresh_m = MAX(g2.turn_radius, AR_CIRCLE_REACHED_EDGE_DIST);
    reached_edge |= dist_to_edge_m <= dist_thresh_m;

    // calculate target point's position, velocity and acceleration
    target.pos = config.center_pos.topostype();
    target.pos.offset_bearing(degrees(target.yaw_rad), config.radius);

    g2.pos_control.input_pos_target(target.pos, rover.G_Dt);
}

// Update position controller targets while circling
void ModeCircle::update_circling()
{

    // accelerate speed up to desired speed
    const float speed_change_max = (g2.pos_control.get_accel_max() * 0.5 * rover.G_Dt);
    const float accel_fb = constrain_float(config.speed - target.speed, -speed_change_max, speed_change_max);
    target.speed += accel_fb;

    // calculate angular rate and update target angle
    const float circumference = 2.0 * M_PI * config.radius;
    const float angular_rate_rad = (target.speed / circumference) * M_2PI * (config.dir == Direction::CW ? 1.0 : -1.0);
    const float angle_dt = angular_rate_rad * rover.G_Dt;
    target.yaw_rad = wrap_PI(target.yaw_rad + angle_dt);
    angle_total_rad += angle_dt;

    // calculate target point's position, velocity and acceleration
    target.pos = config.center_pos.topostype();
    target.pos.offset_bearing(degrees(target.yaw_rad), config.radius);

    // velocity is perpendicular to angle from the circle's center to the target point on the edge of the circle
    target.vel = Vector2f(target.speed, 0);
    target.vel.rotate(target.yaw_rad + radians(90));

    // acceleration is towards center of circle and is speed^2 / radius
    target.accel = Vector2f(-sq(target.speed) / config.radius, accel_fb / rover.G_Dt);
    target.accel.rotate(target.yaw_rad);

    g2.pos_control.set_pos_vel_accel_target(target.pos, target.vel, target.accel);

}

// return desired heading (in degrees) and cross track error (in meters) for reporting to ground station (NAV_CONTROLLER_OUTPUT message)
float ModeCircle::wp_bearing() const
{
    Vector2f curr_pos_NE;
    if (!AP::ahrs().get_relative_position_NE_origin(curr_pos_NE)) {
        return 0;
    }
    // calc vector from circle center to vehicle
    Vector2f veh_to_center = (config.center_pos - curr_pos_NE);
    if (veh_to_center.is_zero()) {
        return 0;
    }
    return degrees(veh_to_center.angle());
}

float ModeCircle::nav_bearing() const
{
    // get position error as a vector from the current position to the target position
    const Vector2p pos_error = g2.pos_control.get_pos_error();
    if (pos_error.is_zero()) {
        return 0;
    }
    return degrees(pos_error.angle());
}

float ModeCircle::get_desired_lat_accel() const
{
    return g2.pos_control.get_desired_lat_accel();
}

// set desired speed in m/s
bool ModeCircle::set_desired_speed(float speed_ms)
{
    if (is_positive(speed_ms)) {
        config.speed = speed_ms;

        // check desired speed does not lead to excessive lateral acceleration
        check_config_speed();

        // update position controller limits if required
        if (config.speed > g2.pos_control.get_speed_max()) {
            g2.pos_control.set_limits(config.speed, g2.pos_control.get_accel_max(), g2.pos_control.get_lat_accel_max(), g2.pos_control.get_jerk_max());
        }
        return true;
    }
 
    return false;
}

// return desired location
bool ModeCircle::get_desired_location(Location& destination) const
{
    destination = config.center_loc;
    return true;
}

// limit config speed so that lateral acceleration is within limits
// assumes that config.radius and attitude controller lat accel max have been set
// outputs warning to user if speed is reduced
void ModeCircle::check_config_speed()
{
    // calculate maximum speed based on radius and max lateral acceleration max
    const float speed_max = MAX(safe_sqrt(g2.attitude_control.get_turn_lat_accel_max() * config.radius), 0);

    if (config.speed > speed_max) {
        config.speed = speed_max;
        gcs().send_text(MAV_SEVERITY_WARNING, "Circle: max speed is %4.1f", (double)config.speed);
    }
}

// ensure config radius is no smaller then vehicle's TURN_RADIUS
// assumes that config.radius has been set
// radius is increased if necessary and warning is output to the user
void ModeCircle::check_config_radius()
{
    // ensure radius is at least as large as vehicle's turn radius
    if (config.radius < g2.turn_radius) {
        config.radius = g2.turn_radius;
        gcs().send_text(MAV_SEVERITY_WARNING, "Circle: radius increased to TURN_RADIUS (%4.1f)", (double)g2.turn_radius);
    }
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 #include "Rover.h"

#if MODE_DOCK_ENABLED

const AP_Param::GroupInfo ModeDock::var_info[] = {
    // @Param: _SPEED
    // @DisplayName: Dock mode speed
    // @Description: Vehicle speed limit in dock mode
    // @Units: m/s
    // @Range: 0 100
    // @Increment: 0.1
    // @User: Standard
    AP_GROUPINFO("_SPEED", 1, ModeDock, speed, 0.0f),

    // @Param: _DIR
    // @DisplayName: Dock mode direction of approach
    // @Description: Compass direction in which vehicle should approach towards dock. -1 value represents unset parameter
    // @Units: deg
    // @Range: 0 360
    // @Increment: 1
    // @User: Advanced
    AP_GROUPINFO("_DIR", 2, ModeDock, desired_dir, -1.00f),

    // @Param: _HDG_CORR_EN
    // @DisplayName: Dock mode heading correction enable/disable
    // @Description: When enabled, the autopilot modifies the path to approach the target head-on along desired line of approch in dock mode
    // @Values: 0:Disabled,1:Enabled
    // @User: Advanced
    AP_GROUPINFO("_HDG_CORR_EN", 3, ModeDock, hdg_corr_enable, 0),

    // @Param: _HDG_CORR_WT
    // @DisplayName: Dock mode heading correction weight
    // @Description: This value describes how aggressively vehicle tries to correct its heading to be on desired line of approach
    // @Range: 0.00 0.90
    // @Increment: 0.05
    // @User: Advanced
    AP_GROUPINFO("_HDG_CORR_WT", 4, ModeDock, hdg_corr_weight, 0.75f),

    // @Param: _STOP_DIST
    // @DisplayName: Distance from docking target when we should stop
    // @Description: The vehicle starts stopping when it is this distance away from docking target
    // @Units: m
    // @Range: 0 2
    // @Increment: 0.01
    // @User: Standard
    AP_GROUPINFO("_STOP_DIST", 5, ModeDock, stopping_dist, 0.30f),

    AP_GROUPEND
};

ModeDock::ModeDock(void) : Mode()
{
    AP_Param::setup_object_defaults(this, var_info);
}

#define AR_DOCK_ACCEL_MAX              20.0    // acceleration used when user has specified no acceleration limit

// initialize dock mode
bool ModeDock::_enter()
{
    // refuse to enter the mode if dock is not in sight
    if (!rover.precland.enabled() || !rover.precland.target_acquired()) {
        gcs().send_text(MAV_SEVERITY_NOTICE, "Dock: target not acquired");
        return false;
    }

    if (hdg_corr_enable && is_negative(desired_dir)) {
        // DOCK_DIR is required for heading correction
        gcs().send_text(MAV_SEVERITY_NOTICE, "Dock: Set DOCK_DIR or disable heading correction");
        return false;
    }

    // set speed limit to dock_speed param if available
    // otherwise the vehicle uses wp_nav default speed limit
    const float speed_max = is_positive(speed) ? speed : g2.wp_nav.get_default_speed();
    float atc_accel_max = MIN(g2.attitude_control.get_accel_max(), g2.attitude_control.get_decel_max());
    if (!is_positive(atc_accel_max)) {
        // accel_max of zero means no limit so use maximum acceleration
        atc_accel_max = AR_DOCK_ACCEL_MAX;
    }
    const float accel_max = is_positive(g2.wp_nav.get_default_accel()) ? MIN(g2.wp_nav.get_default_accel(), atc_accel_max) : atc_accel_max;
    const float jerk_max = is_positive(g2.wp_nav.get_default_jerk()) ? g2.wp_nav.get_default_jerk() : accel_max;

    // initialise position controller
    g2.pos_control.set_limits(speed_max, accel_max, g2.attitude_control.get_turn_lat_accel_max(), jerk_max);
    g2.pos_control.init();

    // set the position controller reversed in case the camera is mounted on vehicle's back
    g2.pos_control.set_reversed(rover.precland.get_orient() == 4);

    // construct unit vector in the desired direction from where we want the vehicle to approach the dock
    // this helps to dock the vehicle head-on even when we enter the dock mode at an angle towards the dock
    _desired_heading_NE = Vector2f{cosf(radians(desired_dir)), sinf(radians(desired_dir))};

    _docking_complete = false;

    return true;
}

void ModeDock::update()
{
    // if docking is complete, rovers stop and boats loiter
    if (_docking_complete) {
        // rovers stop, boats loiter 
        // note that loiter update must be called after successfull initialisation on mode loiter
        if (_loitering) {
            // mode loiter must be initialised before calling update method
            rover.mode_loiter.update();
        } else {
            stop_vehicle();
        }
        return;
    }

    const bool real_dock_in_sight = rover.precland.get_target_position_cm(_dock_pos_rel_origin_cm);
    Vector2f dock_pos_rel_vehicle_cm;
    if (!calc_dock_pos_rel_vehicle_NE(dock_pos_rel_vehicle_cm)) {
        g2.motors.set_throttle(0.0f);
        g2.motors.set_steering(0.0f);
        return;
    }

    _distance_to_destination = dock_pos_rel_vehicle_cm.length() * 0.01f;

    // we force the vehicle to use real dock as target when we are too close to the dock
    // note that heading correction does not work when we force real target
    const bool force_real_target = _distance_to_destination < _force_real_target_limit_cm * 0.01f;

    // if we are close enough to the dock or the target is not in sight when we strictly require it
    // we mark the docking to be completed so that the vehicle stops
    if (_distance_to_destination <= stopping_dist || (force_real_target && !real_dock_in_sight)) {
        _docking_complete = true;

        // send a one time notification to GCS
        gcs().send_text(MAV_SEVERITY_INFO, "Dock: Docking complete");

        // initialise mode loiter if it is a boat
        if (rover.is_boat()) {
            // if we fail to enter, we set _loitering to false
            _loitering = rover.mode_loiter.enter();
        }
        return;
    }

    Vector2f target_cm = _dock_pos_rel_origin_cm;

    // ***** HEADING CORRECTION *****
    // to make to vehicle dock from a given direction we simulate a virtual moving target on the line of approach
    // this target is always at DOCK_HDG_COR_WT times the distance from dock to vehicle (along the line of approach)
    // For e.g., if the dock is 100 m away form dock, DOCK_HDG_COR_WT is 0.75
    // then the position target is 75 m from the dock, i.e., 25 m from the vehicle
    // as the vehicle tries to reach this target, this target appears to move towards the dock and at last it is sandwiched b/w dock and vehicle
    // since this target is moving along desired direction of approach, the vehicle also comes on that line while following it
    if  (!force_real_target && hdg_corr_enable) {
        const float correction_vec_mag = hdg_corr_weight * dock_pos_rel_vehicle_cm.projected(_desired_heading_NE).length();
        target_cm = _dock_pos_rel_origin_cm - _desired_heading_NE * correction_vec_mag;
    }

    const Vector2p target_pos { target_cm.topostype() * 0.01 };
    g2.pos_control.input_pos_target(target_pos, rover.G_Dt);
    g2.pos_control.update(rover.G_Dt);

    // get desired speed and turn rate from pos_control
    float desired_speed = g2.pos_control.get_desired_speed();
    float desired_turn_rate = g2.pos_control.get_desired_turn_rate_rads();

    // slow down the vehicle as we approach the dock
    desired_speed = apply_slowdown(desired_speed);

    // run steering and throttle controllers
    calc_steering_from_turn_rate(desired_turn_rate);
    calc_throttle(desired_speed, true);

#if HAL_LOGGING_ENABLED
// @LoggerMessage: DOCK
// @Description: Dock mode target information
// @Field: TimeUS: Time since system startup
// @Field: DockX: Docking Station position, X-Axis
// @Field: DockY: Docking Station position, Y-Axis
// @Field: DockDist: Distance to docking station
// @Field: TPosX: Current Position Target, X-Axis
// @Field: TPosY: Current Position Target, Y-Axis
// @Field: DSpd: Desired speed
// @Field: DTrnRt: Desired Turn Rate

        AP::logger().WriteStreaming(
            "DOCK",
            "TimeUS,DockX,DockY,DockDist,TPosX,TPosY,DSpd,DTrnRt",
            "smmmmmnE",
            "FBB0BB00",
            "Qfffffff",
            AP_HAL::micros64(),
            _dock_pos_rel_origin_cm.x,
            _dock_pos_rel_origin_cm.y,
            _distance_to_destination,
            target_cm.x,
            target_cm.y,
            desired_speed,
            desired_turn_rate);
#endif
}

float ModeDock::apply_slowdown(float desired_speed)
{
    const float dock_speed_slowdown_lmt = 0.5f;

    // no slowdown for speed below dock_speed_slowdown_lmt
    if (fabsf(desired_speed) < dock_speed_slowdown_lmt) {
        return desired_speed;
    }

    Vector3f target_vec_rel_vehicle_NED;
    if(!calc_dock_pos_rel_vehicle_NE(target_vec_rel_vehicle_NED.xy())) {
        return desired_speed;
    }

    const Matrix3f &body_to_ned = AP::ahrs().get_rotation_body_to_ned();
    Vector3f target_vec_body = body_to_ned.mul_transpose(target_vec_rel_vehicle_NED);
    const float target_error_cm = fabsf(target_vec_body.y);
    float error_ratio = target_error_cm / _acceptable_pos_error_cm;
    error_ratio = constrain_float(error_ratio, 0.0f, 1.0f);

    const float dock_slow_dist_max_m = 15.0f;
    const float dock_slow_dist_min_m = 5.0f;
    // approach slowdown is not applied when the vehicle is more than dock_slow_dist_max meters away
    // within dock_slow_dist_max and dock_slow_dist_min the weight of the slowdown increases linearly
    // once the vehicle reaches dock_slow_dist_min the slowdown weight becomes 1
    float slowdown_weight = 1 - (target_vec_body.x * 0.01f - dock_slow_dist_min_m) / (dock_slow_dist_max_m - dock_slow_dist_min_m);
    slowdown_weight = constrain_float(slowdown_weight, 0.0f, 1.0f);
    
    desired_speed = MAX(dock_speed_slowdown_lmt, fabsf(desired_speed) * (1 - error_ratio * slowdown_weight));

    // restrict speed to avoid going beyond stopping distance
    desired_speed = MIN(desired_speed, safe_sqrt(2 * fabsf(_distance_to_destination - stopping_dist) * g2.pos_control.get_accel_max()));

    // we worked on absolute value of speed before
    // make it negative again if reversed
    if (g2.pos_control.get_reversed()) {
        desired_speed *= -1;
    }

    return desired_speed;
}

// calculate position of dock relative to the vehicle
// we need this method here because there can be a window during heading correction when we might lose the target
// during that window precland won't be able to give us this vector
// we can calculate it based on most recent value from precland because the dock is assumed stationary wrt ekf origin
bool ModeDock::calc_dock_pos_rel_vehicle_NE(Vector2f &dock_pos_rel_vehicle) const {
    Vector2f current_pos_m;
    if (!AP::ahrs().get_relative_position_NE_origin(current_pos_m)) {
        return false;
    }
 
    dock_pos_rel_vehicle = _dock_pos_rel_origin_cm - current_pos_m * 100.0f;
    return true;
}
#endif // MODE_DOCK_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 #include "Rover.h"

#if MODE_FOLLOW_ENABLED
// initialize follow mode
bool ModeFollow::_enter()
{
    if (!g2.follow.enabled()) {
        return false;
    }

    // initialise speed to waypoint speed
    _desired_speed = g2.wp_nav.get_default_speed();

    return true;
}

// exit handling
void ModeFollow::_exit()
{
    g2.follow.clear_offsets_if_required();
}

void ModeFollow::update()
{
    // stop vehicle if no speed estimate
    float speed;
    if (!attitude_control.get_forward_speed(speed)) {
        // no valid speed so stop
        g2.motors.set_throttle(0.0f);
        g2.motors.set_steering(0.0f);
        return;
    }

    Vector3f dist_vec;  // vector to lead vehicle
    Vector3f dist_vec_offs; // vector to lead vehicle + offset
    Vector3f vel_of_target; // velocity of lead vehicle

    // if no target simply stop the vehicle
    if (!g2.follow.get_target_dist_and_vel_ned(dist_vec, dist_vec_offs, vel_of_target)) {
        _reached_destination = true;
        stop_vehicle();
        return;
    }

    // calculate desired velocity vector
    Vector2f desired_velocity_ne;
    const float kp = g2.follow.get_pos_p().kP();
    desired_velocity_ne.x = vel_of_target.x + (dist_vec_offs.x * kp);
    desired_velocity_ne.y = vel_of_target.y + (dist_vec_offs.y * kp);

    // if desired velocity is zero stop vehicle
    if (is_zero(desired_velocity_ne.x) && is_zero(desired_velocity_ne.y)) {
        _reached_destination = true;
        stop_vehicle();
        return;
    }

    // we have not reached the target
    _reached_destination = false;

    // scale desired velocity to stay within horizontal speed limit
    float desired_speed = safe_sqrt(sq(desired_velocity_ne.x) + sq(desired_velocity_ne.y));
    if (!is_zero(desired_speed) && (desired_speed > _desired_speed)) {
        const float scalar_xy = _desired_speed / desired_speed;
        desired_velocity_ne *= scalar_xy;
        desired_speed = _desired_speed;
    }

    // calculate vehicle heading
    const float desired_yaw_cd = wrap_180_cd(atan2f(desired_velocity_ne.y, desired_velocity_ne.x) * DEGX100);

    // run steering and throttle controllers
    calc_steering_to_heading(desired_yaw_cd);
    calc_throttle(desired_speed, true);
}

// return desired heading (in degrees) for reporting to ground station (NAV_CONTROLLER_OUTPUT message)
float ModeFollow::wp_bearing() const
{
    return g2.follow.get_bearing_to_target();
}

// return distance (in meters) to destination
float ModeFollow::get_distance_to_destination() const
{
    return g2.follow.get_distance_to_target();
}

// set desired speed in m/s
bool ModeFollow::set_desired_speed(float speed)
{
    if (is_negative(speed)) {
        return false;
    }
    _desired_speed = speed;
    return true;
}

#endif // MODE_FOLLOW_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          #include "Rover.h"

bool ModeGuided::_enter()
{
    // initialise submode to stop or loiter
    if (rover.is_boat()) {
        if (!start_loiter()) {
            start_stop();
        }
    } else {
        start_stop();
    }

    // initialise waypoint navigation library
    g2.wp_nav.init();

    send_notification = false;

    return true;
}

void ModeGuided::update()
{
    switch (_guided_mode) {
        case SubMode::WP:
        {
            // check if we've reached the destination
            if (!g2.wp_nav.reached_destination()) {
                // update navigation controller
                navigate_to_waypoint();
            } else {
                // send notification
                if (send_notification) {
                    send_notification = false;
                    rover.gcs().send_mission_item_reached_message(0);
                }

                // we have reached the destination so stay here
                if (rover.is_boat()) {
                    if (!start_loiter()) {
                        stop_vehicle();
                    }
                } else {
                    stop_vehicle();
                }
                // update distance to destination
                _distance_to_destination = rover.current_loc.get_distance(g2.wp_nav.get_destination());
            }
            break;
        }

        case SubMode::HeadingAndSpeed:
        {
            // stop vehicle if target not updated within 3 seconds
            if (have_attitude_target && (millis() - _des_att_time_ms) > 3000) {
                gcs().send_text(MAV_SEVERITY_WARNING, "target not received last 3secs, stopping");
                have_attitude_target = false;
            }
            if (have_attitude_target) {
                // run steering and throttle controllers
                calc_steering_to_heading(_desired_yaw_cd);
                calc_throttle(calc_speed_nudge(_desired_speed, is_negative(_desired_speed)), true);
            } else {
                // we have reached the destination so stay here
                if (rover.is_boat()) {
                    if (!start_loiter()) {
                        stop_vehicle();
                    }
                } else {
                    stop_vehicle();
                }
            }
            break;
        }

        case SubMode::TurnRateAndSpeed:
        {
            // stop vehicle if target not updated within 3 seconds
            if (have_attitude_target && (millis() - _des_att_time_ms) > 3000) {
                gcs().send_text(MAV_SEVERITY_WARNING, "target not received last 3secs, stopping");
                have_attitude_target = false;
            }
            if (have_attitude_target) {
                // run steering and throttle controllers
                float steering_out = attitude_control.get_steering_out_rate(radians(_desired_yaw_rate_cds * 0.01f),
                                                                            g2.motors.limit.steer_left,
                                                                            g2.motors.limit.steer_right,
                                                                            rover.G_Dt);
                set_steering(steering_out * 4500.0f);
                calc_throttle(calc_speed_nudge(_desired_speed, is_negative(_desired_speed)), true);
            } else {
                // we have reached the destination so stay here
                if (rover.is_boat()) {
                    if (!start_loiter()) {
                        stop_vehicle();
                    }
                } else {
                    stop_vehicle();
                }
            }
            break;
        }

        case SubMode::Loiter:
        {
            rover.mode_loiter.update();
            break;
        }

        case SubMode::SteeringAndThrottle:
        {
            // handle timeout
            if (_have_strthr && (AP_HAL::millis() - _strthr_time_ms) > 3000) {
                _have_strthr = false;
                gcs().send_text(MAV_SEVERITY_WARNING, "target not received last 3secs, stopping");
            }
            if (_have_strthr) {
                // pass latest steering and throttle directly to motors library
                g2.motors.set_steering(_strthr_steering * 4500.0f, false);
                g2.motors.set_throttle(_strthr_throttle * 100.0f);
            } else {
                // loiter or stop vehicle
                if (rover.is_boat()) {
                    if (!start_loiter()) {
                        stop_vehicle();
                    }
                } else {
                    stop_vehicle();
                }
            }
            break;
        }

        case SubMode::Stop:
            stop_vehicle();
            break;

        default:
            gcs().send_text(MAV_SEVERITY_WARNING, "Unknown GUIDED mode");
            break;
    }
}

// return heading (in degrees) and cross track error (in meters) for reporting to ground station (NAV_CONTROLLER_OUTPUT message)
float ModeGuided::wp_bearing() const
{
    switch (_guided_mode) {
    case SubMode::WP:
        return g2.wp_nav.wp_bearing_cd() * 0.01f;
    case SubMode::HeadingAndSpeed:
    case SubMode::TurnRateAndSpeed:
        return 0.0f;
    case SubMode::Loiter:
        return rover.mode_loiter.wp_bearing();
    case SubMode::SteeringAndThrottle:
    case SubMode::Stop:
        return 0.0f;
    }

    // we should never reach here but just in case, return 0
    return 0.0f;
}

float ModeGuided::nav_bearing() const
{
    switch (_guided_mode) {
    case SubMode::WP:
        return g2.wp_nav.nav_bearing_cd() * 0.01f;
    case SubMode::HeadingAndSpeed:
    case SubMode::TurnRateAndSpeed:
        return 0.0f;
    case SubMode::Loiter:
        return rover.mode_loiter.nav_bearing();
    case SubMode::SteeringAndThrottle:
    case SubMode::Stop:
        return 0.0f;
    }

    // we should never reach here but just in case, return 0
    return 0.0f;
}

float ModeGuided::crosstrack_error() const
{
    switch (_guided_mode) {
    case SubMode::WP:
        return g2.wp_nav.crosstrack_error();
    case SubMode::HeadingAndSpeed:
    case SubMode::TurnRateAndSpeed:
        return 0.0f;
    case SubMode::Loiter:
        return rover.mode_loiter.crosstrack_error();
    case SubMode::SteeringAndThrottle:
    case SubMode::Stop:
        return 0.0f;
    }

    // we should never reach here but just in case, return 0
    return 0.0f;
}

float ModeGuided::get_desired_lat_accel() const
{
    switch (_guided_mode) {
    case SubMode::WP:
        return g2.wp_nav.get_lat_accel();
    case SubMode::HeadingAndSpeed:
    case SubMode::TurnRateAndSpeed:
        return 0.0f;
    case SubMode::Loiter:
        return rover.mode_loiter.get_desired_lat_accel();
    case SubMode::SteeringAndThrottle:
    case SubMode::Stop:
        return 0.0f;
    }

    // we should never reach here but just in case, return 0
    return 0.0f;
}

// return distance (in meters) to destination
float ModeGuided::get_distance_to_destination() const
{
    switch (_guided_mode) {
    case SubMode::WP:
        return _distance_to_destination;
    case SubMode::HeadingAndSpeed:
    case SubMode::TurnRateAndSpeed:
        return 0.0f;
    case SubMode::Loiter:
        return rover.mode_loiter.get_distance_to_destination();
    case SubMode::SteeringAndThrottle:
    case SubMode::Stop:
        return 0.0f;
    }

    // we should never reach here but just in case, return 0
    return 0.0f;
}

// return true if vehicle has reached or even passed destination
bool ModeGuided::reached_destination() const
{
    switch (_guided_mode) {
    case SubMode::WP:
        return g2.wp_nav.reached_destination();
    case SubMode::HeadingAndSpeed:
    case SubMode::TurnRateAndSpeed:
    case SubMode::Loiter:
    case SubMode::SteeringAndThrottle:
    case SubMode::Stop:
        return true;
    }

    // we should never reach here but just in case, return true is the safer option
    return true;
}

// set desired speed in m/s
bool ModeGuided::set_desired_speed(float speed)
{
    switch (_guided_mode) {
    case SubMode::WP:
        return g2.wp_nav.set_speed_max(speed);
    case SubMode::HeadingAndSpeed:
    case SubMode::TurnRateAndSpeed:
        // speed is set from mavlink message
        return false;
    case SubMode::Loiter:
        return rover.mode_loiter.set_desired_speed(speed);
    case SubMode::SteeringAndThrottle:
    case SubMode::Stop:
        // no speed control
        return false;
    }
    return false;
}

// get desired location
bool ModeGuided::get_desired_location(Location& destination) const
{
    switch (_guided_mode) {
    case SubMode::WP:
        if (g2.wp_nav.is_destination_valid()) {
            destination = g2.wp_nav.get_oa_destination();
            return true;
        }
        return false;
    case SubMode::HeadingAndSpeed:
    case SubMode::TurnRateAndSpeed:
        // not supported in these submodes
        return false;
    case SubMode::Loiter:
        // get destination from loiter
        return rover.mode_loiter.get_desired_location(destination);
    case SubMode::SteeringAndThrottle:
    case SubMode::Stop:
        // no desired location in this submode
        break;
    }

    // should never get here but just in case
    return false;
}

// set desired location
bool ModeGuided::set_desired_location(const Location &destination, Location next_destination)
{
    if (use_scurves_for_navigation()) {
        // use scurves for navigation
        if (!g2.wp_nav.set_desired_location(destination, next_destination)) {
            return false;
        }
    } else {
        // use position controller input shaping for navigation
        // this does not support object avoidance but does allow faster updates of the target
        if (!g2.wp_nav.set_desired_location_expect_fast_update(destination)) {
            return false;
        }
    }

    // handle guided specific initialisation and logging
    _guided_mode = SubMode::WP;
    send_notification = true;
#if HAL_LOGGING_ENABLED
    rover.Log_Write_GuidedTarget((uint8_t)_guided_mode, Vector3f(destination.lat, destination.lng, 0), Vector3f(g2.wp_nav.get_speed_max(), 0.0f, 0.0f));
#endif
    return true;
}

// set desired attitude
void ModeGuided::set_desired_heading_and_speed(float yaw_angle_cd, float target_speed)
{
    // initialisation and logging
    _guided_mode = SubMode::HeadingAndSpeed;
    _des_att_time_ms = AP_HAL::millis();

    // record targets
    _desired_yaw_cd = yaw_angle_cd;
    _desired_speed = target_speed;
    have_attitude_target = true;

#if HAL_LOGGING_ENABLED
    // log new target
    rover.Log_Write_GuidedTarget((uint8_t)_guided_mode, Vector3f(_desired_yaw_cd, 0.0f, 0.0f), Vector3f(_desired_speed, 0.0f, 0.0f));
#endif
}

void ModeGuided::set_desired_heading_delta_and_speed(float yaw_delta_cd, float target_speed)
{
    // handle initialisation
    if (_guided_mode != SubMode::HeadingAndSpeed) {
        _guided_mode = SubMode::HeadingAndSpeed;
        _desired_yaw_cd = ahrs.yaw_sensor;
    }
    set_desired_heading_and_speed(wrap_180_cd(_desired_yaw_cd + yaw_delta_cd), target_speed);
}

// set desired velocity
void ModeGuided::set_desired_turn_rate_and_speed(float turn_rate_cds, float target_speed)
{
    // handle initialisation
    _guided_mode = SubMode::TurnRateAndSpeed;
    _des_att_time_ms = AP_HAL::millis();

    // record targets
    _desired_yaw_rate_cds = turn_rate_cds;
    _desired_speed = target_speed;
    have_attitude_target = true;

#if HAL_LOGGING_ENABLED
    // log new target
    rover.Log_Write_GuidedTarget((uint8_t)_guided_mode, Vector3f(_desired_yaw_rate_cds, 0.0f, 0.0f), Vector3f(_desired_speed, 0.0f, 0.0f));
#endif
}

// set steering and throttle (both in the range -1 to +1)
void ModeGuided::set_steering_and_throttle(float steering, float throttle)
{
    _guided_mode = SubMode::SteeringAndThrottle;
    _strthr_time_ms = AP_HAL::millis();
    _strthr_steering = constrain_float(steering, -1.0f, 1.0f);
    _strthr_throttle = constrain_float(throttle, -1.0f, 1.0f);
    _have_strthr = true;
}

bool ModeGuided::start_loiter()
{
    if (rover.mode_loiter.enter()) {
        _guided_mode = SubMode::Loiter;
        return true;
    }
    return false;
}


// start stopping vehicle as quickly as possible
void ModeGuided::start_stop()
{
    _guided_mode = SubMode::Stop;
}

// set guided timeout and movement limits
void ModeGuided::limit_set(uint32_t timeout_ms, float horiz_max)
{
    limit.timeout_ms = timeout_ms;
    limit.horiz_max = horiz_max;
}

// clear/turn off guided limits
void ModeGuided::limit_clear()
{
    limit.timeout_ms = 0;
    limit.horiz_max = 0.0f;
}

// initialise guided start time and location as reference for limit checking
//  only called from AUTO mode's start_guided method
void ModeGuided::limit_init_time_and_location()
{
    limit.start_time_ms = AP_HAL::millis();
    limit.start_loc = rover.current_loc;
}

// returns true if guided mode has breached a limit
bool ModeGuided::limit_breached() const
{
    // check if we have passed the timeout
    if ((limit.timeout_ms > 0) && (millis() - limit.start_time_ms >= limit.timeout_ms)) {
        return true;
    }

    // check if we have gone beyond horizontal limit
    if (is_positive(limit.horiz_max)) {
        return (rover.current_loc.get_distance(limit.start_loc) > limit.horiz_max);
    }

    // if we got this far we must be within limits
    return false;
}

// returns true if GUID_OPTIONS bit set to use scurve navigation instead of position controller input shaping
// scurves provide path planning and object avoidance but cannot handle fast updates to the destination (for fast updates use position controller input shaping)
bool ModeGuided::use_scurves_for_navigation() const
{
    return ((g2.guided_options.get() & uint32_t(Options::SCurvesUsedForNavigation)) != 0);
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         #include "Rover.h"

void ModeHold::update()
{
    float throttle = 0.0f;

    // if vehicle is balance bot, calculate actual throttle required for balancing
    if (rover.is_balancebot()) {
        rover.balancebot_pitch_control(throttle);
    }

    // relax mainsail
    g2.sailboat.relax_sails();

    // hold position - stop motors and center steering
    g2.motors.set_throttle(throttle);
    g2.motors.set_steering(0.0f);
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  #include "Rover.h"

bool ModeLoiter::_enter()
{
    // set _destination to reasonable stopping point
    if (!g2.wp_nav.get_stopping_location(_destination)) {
        return false;
    }

    // initialise desired speed to current speed
    if (!attitude_control.get_forward_speed(_desired_speed)) {
        _desired_speed = 0.0f;
    }

    // initialise heading to current heading
    _desired_yaw_cd = ahrs.yaw_sensor;

    return true;
}

void ModeLoiter::update()
{
    // get distance (in meters) to destination
    _distance_to_destination = rover.current_loc.get_distance(_destination);

    const float loiter_radius = g2.sailboat.tack_enabled() ? g2.sailboat.get_loiter_radius() : g2.loit_radius;

    // if within loiter radius slew desired speed towards zero and use existing desired heading
    if (_distance_to_destination <= loiter_radius) {
        // sailboats should not stop unless motoring
        const float desired_speed_within_radius = g2.sailboat.tack_enabled() ? 0.1f : 0.0f;
        _desired_speed = attitude_control.get_desired_speed_accel_limited(desired_speed_within_radius, rover.G_Dt);

        // if we have a sail but not trying to use it then point into the wind
        if (!g2.sailboat.tack_enabled() && g2.sailboat.sail_enabled()) {
            _desired_yaw_cd = degrees(g2.windvane.get_true_wind_direction_rad()) * 100.0f;
        }
    } else {
        // P controller with hard-coded gain to convert distance to desired speed
        _desired_speed = MIN((_distance_to_destination - loiter_radius) * g2.loiter_speed_gain, g2.wp_nav.get_default_speed());

        // calculate bearing to destination
        _desired_yaw_cd = rover.current_loc.get_bearing_to(_destination);
        float yaw_error_cd = wrap_180_cd(_desired_yaw_cd - ahrs.yaw_sensor);
        // if destination is behind vehicle, reverse towards it
        if ((fabsf(yaw_error_cd) > 9000 && g2.loit_type == 0) || g2.loit_type == 2) {
            _desired_yaw_cd = wrap_180_cd(_desired_yaw_cd + 18000);
            yaw_error_cd = wrap_180_cd(_desired_yaw_cd - ahrs.yaw_sensor);
            _desired_speed = -_desired_speed;
        }

        // reduce desired speed if yaw_error is large
        // 45deg of error reduces speed to 75%, 90deg of error reduces speed to 50%
        float yaw_error_ratio = 1.0f - constrain_float(fabsf(yaw_error_cd / 9000.0f), 0.0f, 1.0f) * 0.5f;
        _desired_speed *= yaw_error_ratio;
    }

    // 0 turn rate is no limit
    float turn_rate = 0.0;

    // make sure sailboats don't try and sail directly into the wind
    if (g2.sailboat.use_indirect_route(_desired_yaw_cd)) {
        _desired_yaw_cd = g2.sailboat.calc_heading(_desired_yaw_cd);
        if (g2.sailboat.tacking()) {
            // use pivot turn rate for tacks
            turn_rate = g2.wp_nav.get_pivot_rate();
        }
    }

    // run steering and throttle controllers
    calc_steering_to_heading(_desired_yaw_cd, turn_rate);
    calc_throttle(_desired_speed, true);
}

// get desired location
bool ModeLoiter::get_desired_location(Location& destination) const
{
    destination = _destination;
    return true;
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   #include "Rover.h"

void ModeManual::_exit()
{
    // clear lateral when exiting manual mode
    g2.motors.set_lateral(0);
}

void ModeManual::update()
{
    float desired_steering, desired_throttle, desired_lateral;
    get_pilot_desired_steering_and_throttle(desired_steering, desired_throttle);
    get_pilot_desired_lateral(desired_lateral);

    // apply manual steering expo
    desired_steering = 4500.0 * input_expo(desired_steering / 4500, g2.manual_steering_expo);

    // if vehicle is balance bot, calculate actual throttle required for balancing
    if (rover.is_balancebot()) {
        rover.balancebot_pitch_control(desired_throttle);
    }

    // walking robots support roll, pitch and walking_height
    float desired_roll, desired_pitch, desired_walking_height;
    get_pilot_desired_roll_and_pitch(desired_roll, desired_pitch);
    get_pilot_desired_walking_height(desired_walking_height);
    g2.motors.set_roll(desired_roll);
    g2.motors.set_pitch(desired_pitch);
    g2.motors.set_walking_height(desired_walking_height);

    // set sailboat sails
    g2.sailboat.set_pilot_desired_mainsail();

    // copy RC scaled inputs to outputs
    g2.motors.set_throttle(desired_throttle);
    g2.motors.set_steering(desired_steering, (g2.manual_options & ManualOptions::SPEED_SCALING));
    g2.motors.set_lateral(desired_lateral);
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          #include "Rover.h"

bool ModeRTL::_enter()
{
    // refuse RTL if home has not been set
    if (!AP::ahrs().home_is_set()) {
        return false;
    }

    // initialise waypoint navigation library
    g2.wp_nav.init(MAX(0.0f, g2.rtl_speed));

    // set target to the closest rally point or home
#if HAL_RALLY_ENABLED
    if (!g2.wp_nav.set_desired_location(g2.rally.calc_best_rally_or_home_location(rover.current_loc, ahrs.get_home().alt))) {
        return false;
    }
#else
    // set destination
    if (!g2.wp_nav.set_desired_location(ahrs.get_home())) {
        return false;
    }
#endif

    send_notification = true;
    _loitering = false;
    return true;
}

void ModeRTL::update()
{
    // determine if we should keep navigating
    if (!g2.wp_nav.reached_destination()) {
        // update navigation controller
        navigate_to_waypoint();
    } else {
        // send notification
        if (send_notification) {
            send_notification = false;
            gcs().send_text(MAV_SEVERITY_INFO, "Reached destination");
        }

        // we have reached the destination
        // boats loiter, rovers stop
        if (!rover.is_boat()) {
            stop_vehicle();
        } else {
            // if not loitering yet, start loitering
            if (!_loitering) {
                _loitering = rover.mode_loiter.enter();
            }
            // update stop or loiter
            if (_loitering) {
                rover.mode_loiter.update();
            } else {
                stop_vehicle();
            }
        }

        // update distance to destination
        _distance_to_destination = rover.current_loc.get_distance(g2.wp_nav.get_destination());
    }
}

// get desired location
bool ModeRTL::get_desired_location(Location& destination) const
{
    if (g2.wp_nav.is_destination_valid()) {
        destination = g2.wp_nav.get_oa_destination();
        return true;
    }
    return false;
}

bool ModeRTL::reached_destination() const
{
    return g2.wp_nav.reached_destination();
}

// set desired speed in m/s
bool ModeRTL::set_desired_speed(float speed)
{
    return g2.wp_nav.set_speed_max(speed);
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         #include "Rover.h"

void ModeSimple::init_heading()
{
    _initial_heading_cd = ahrs.yaw_sensor;
    _desired_heading_cd = ahrs.yaw_sensor;
}

void ModeSimple::update()
{
    float desired_heading_cd, desired_speed;

    // get pilot input
    get_pilot_desired_heading_and_speed(desired_heading_cd, desired_speed);

    // rotate heading around based on initial heading
    if (g2.simple_type == Simple_InitialHeading) {
        desired_heading_cd = wrap_360_cd(_initial_heading_cd + desired_heading_cd);
    }

    // if sticks in middle, use previous desired heading (important when vehicle is slowing down)
    if (!is_positive(desired_speed)) {
        desired_heading_cd = _desired_heading_cd;
    } else {
        // record desired heading for next iteration
        _desired_heading_cd = desired_heading_cd;
    }

    // run throttle and steering controllers
    calc_steering_to_heading(desired_heading_cd);
    calc_throttle(desired_speed, true);
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                //
// functions to support precision landing
//

#include "Rover.h"

#if AC_PRECLAND_ENABLED

void Rover::init_precland()
{
    rover.precland.init(400);
}

void Rover::update_precland()
{
    // alt will be unused if we pass false through as the second parameter:
    return precland.update(0, false);
}
#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        #include "Rover.h"

/*
  allow for runtime change of control channel ordering
 */
void Rover::set_control_channels(void)
{
    // check change on RCMAP
    channel_steer    = rc().channel(rcmap.roll()-1);
    channel_throttle = rc().channel(rcmap.throttle()-1);
    channel_lateral  = rc().channel(rcmap.yaw()-1);

    // set rc channel ranges
    channel_steer->set_angle(SERVO_MAX);
    channel_throttle->set_angle(100);
    if (channel_lateral != nullptr) {
        channel_lateral->set_angle(100);
    }

    // walking robots rc input init
    channel_roll = rc().find_channel_for_option(RC_Channel::AUX_FUNC::ROLL);
    channel_pitch = rc().find_channel_for_option(RC_Channel::AUX_FUNC::PITCH);
    channel_walking_height = rc().find_channel_for_option(RC_Channel::AUX_FUNC::WALKING_HEIGHT);
    if (channel_roll != nullptr) {
        channel_roll->set_angle(SERVO_MAX);
        channel_roll->set_default_dead_zone(30);
    }
    if (channel_pitch != nullptr) {
        channel_pitch->set_angle(SERVO_MAX);
        channel_pitch->set_default_dead_zone(30);
    }
    if (channel_walking_height != nullptr) {
        channel_walking_height->set_angle(SERVO_MAX);
        channel_walking_height->set_default_dead_zone(30);
    }    

    // sailboat rc input init
    g2.sailboat.init_rc_in();

    // Allow to reconfigure output when not armed
    if (!arming.is_armed()) {
        g2.motors.setup_servo_output();
        // For a rover safety is TRIM throttle
        g2.motors.setup_safety_output();
    }
    // setup correct scaling for ESCs like the UAVCAN ESCs which
    // take a proportion of speed. Default to 1000 to 2000 for systems without
    // a k_throttle output
    hal.rcout->set_esc_scaling(1000, 2000);
    g2.servo_channels.set_esc_scaling_for(SRV_Channel::k_throttle);
}

void Rover::init_rc_in()
{
    // set rc dead zones
    channel_steer->set_default_dead_zone(30);
    channel_throttle->set_default_dead_zone(30);
    if (channel_lateral != nullptr) {
        channel_lateral->set_default_dead_zone(30);
    }
}

/*
  check for driver input on rudder/steering stick for arming/disarming
*/
void Rover::rudder_arm_disarm_check()
{
    // check if arming/disarm using rudder is allowed
    const AP_Arming::RudderArming arming_rudder = arming.get_rudder_arming_type();
    if (arming_rudder == AP_Arming::RudderArming::IS_DISABLED) {
        return;
    }

    // In Rover we need to check that its set to the throttle trim and within the DZ
    // if throttle is not within trim dz, then pilot cannot rudder arm/disarm
    if (!channel_throttle->in_trim_dz()) {
        rudder_arm_timer = 0;
        return;
    }

    // check if arming/disarming allowed from this mode
    if (!control_mode->allows_arming_from_transmitter()) {
        rudder_arm_timer = 0;
        return;
    }

    if (!arming.is_armed()) {
        // when not armed, full right rudder starts arming counter
        if (channel_steer->get_control_in() > 4000) {
            const uint32_t now = millis();

            if (rudder_arm_timer == 0 ||
                now - rudder_arm_timer < ARM_DELAY_MS) {
                if (rudder_arm_timer == 0) {
                    rudder_arm_timer = now;
                }
            } else {
                // time to arm!
                arming.arm(AP_Arming::Method::RUDDER);
                rudder_arm_timer = 0;
            }
        } else {
            // not at full right rudder
            rudder_arm_timer = 0;
        }
    } else if ((arming_rudder == AP_Arming::RudderArming::ARMDISARM) && !g2.motors.active()) {
        // when armed and motor not active (not moving), full left rudder starts disarming counter
        if (channel_steer->get_control_in() < -4000) {
            const uint32_t now = millis();

            if (rudder_arm_timer == 0 ||
                now - rudder_arm_timer < ARM_DELAY_MS) {
                if (rudder_arm_timer == 0) {
                    rudder_arm_timer = now;
                }
            } else {
                // time to disarm!
                arming.disarm(AP_Arming::Method::RUDDER);
                rudder_arm_timer = 0;
            }
        } else {
            // not at full left rudder
            rudder_arm_timer = 0;
        }
    }
}

void Rover::read_radio()
{
    if (!rc().read_input()) {
        // check if we lost RC link
        radio_failsafe_check(channel_throttle->get_radio_in());
        return;
    }

    failsafe.last_valid_rc_ms = AP_HAL::millis();
    // check that RC value are valid
    radio_failsafe_check(channel_throttle->get_radio_in());

    // check if we try to do RC arm/disarm
    rudder_arm_disarm_check();
}

void Rover::radio_failsafe_check(uint16_t pwm)
{
    if (!g.fs_throttle_enabled) {
        // radio failsafe disabled
        return;
    }

    bool failed = pwm < static_cast<uint16_t>(g.fs_throttle_value);
    if (AP_HAL::millis() - failsafe.last_valid_rc_ms > 500) {
        failed = true;
    }
    AP_Notify::flags.failsafe_radio = failed;
    failsafe_trigger(FAILSAFE_EVENT_THROTTLE, "Radio", failed);
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       #NOTE: Default parameters fro E-Flight convergence VTOL
AHRS_ORIENTATION,8
ARSPD_TYPE,0
BATT_CAPACITY,2200
BATT_MONITOR,4
BATT_VOLT_MULT,12
BRD_SAFETY_DEFLT,0
FORMAT_VERSION,13
PTCH_LIM_MAX_DEG,35.00
MIXING_GAIN,0.8
PTCH_RATE_D,0.000000
PTCH_RATE_FF,0.455000
PTCH_RATE_I,0.150000
PTCH_RATE_IMAX,0.888889
PTCH_RATE_P,0.020000
Q_A_RAT_PIT_D,0.005
Q_A_RAT_PIT_FILT,10
Q_A_RAT_PIT_FLTD,10
Q_A_RAT_PIT_I,0.25
Q_A_RAT_PIT_P,0.3
Q_A_RAT_RLL_D,0.005
Q_A_RAT_RLL_FILT,10
Q_A_RAT_RLL_FLTD,10
Q_A_RAT_RLL_I,0.25
Q_A_RAT_RLL_IMAX,0.5
Q_A_RAT_RLL_P,0.3
Q_A_RAT_YAW_D,0
Q_A_RAT_YAW_FF,0
Q_A_RAT_YAW_FILT,2
Q_A_RAT_YAW_FLTE,2
Q_A_RAT_YAW_I,0.018
Q_A_RAT_YAW_IMAX,0.7
Q_A_RAT_YAW_P,0.1
Q_A_SLEW_YAW,6000
Q_ENABLE,1
Q_FRAME_CLASS,7
Q_FRAME_TYPE,1
Q_M_PWM_MAX,2000
Q_M_PWM_MIN,1000
Q_M_PWM_TYPE,0
Q_RTL_MODE,1
Q_TILT_MASK,3
Q_TILT_MAX,55
Q_TILT_RATE_DN,15
Q_TILT_RATE_UP,25
Q_TILT_TYPE,2
Q_TILT_YAW_ANGLE,10
Q_VXY_I,0.25
Q_VXY_P,0.5
RLL_RATE_P,0.080000
RTL_AUTOLAND,2
SCHED_LOOP_RATE,300
SERVO1_FUNCTION,78
SERVO1_MAX,1900
SERVO1_MIN,1100
SERVO1_REVERSED,0
SERVO1_TRIM,1574
SERVO2_FUNCTION,77
SERVO2_MAX,1900
SERVO2_MIN,1100
SERVO2_REVERSED,1
SERVO2_TRIM,1424
SERVO3_FUNCTION,75
SERVO3_MAX,2050
SERVO3_MIN,1000
SERVO3_REVERSED,0
SERVO3_TRIM,1500
SERVO4_FUNCTION,76
SERVO4_MAX,2000
SERVO4_MIN,950
SERVO4_REVERSED,1
SERVO4_TRIM,1500
SERVO5_FUNCTION,36
SERVO6_FUNCTION,33
SERVO7_FUNCTION,34
SERVO_AUTO_TRIM,1
RLL_RATE_FF 0.245000
RLL_RATE_I 0.150000
RLL_RATE_D 0.000000
RLL_RATE_IMAX 0.666667
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ACRO_TURN_RATE	180
ARMING_RUDDER	0
ATC_ACCEL_MAX	1
ATC_SPEED_D	0
ATC_SPEED_FILT	10
ATC_SPEED_I	0.3
ATC_SPEED_IMAX	1
ATC_SPEED_P	0.4
ATC_STR_ACC_MAX	360
ATC_STR_RAT_D	0
ATC_STR_RAT_FF	1.7
ATC_STR_RAT_FILT	10
ATC_STR_RAT_I	0.5
ATC_STR_RAT_MAX	180
ATC_STR_RAT_P	0.5
BRD_SAFETYENABLE	0
COMPASS_CAL_FIT	32
COMPASS_USE	1
COMPASS_USE2	0
COMPASS_USE3	0
CRUISE_SPEED	5
CRUISE_THROTTLE	50
FRAME_CLASS	2
FRAME_TYPE	0
FS_ACTION	2
FS_CRASH_CHECK	0
FS_THR_ENABLE	1
FS_THR_VALUE	910
FS_TIMEOUT	1.5
MOT_THR_MAX	80
NTF_BUZZ_ENABLE	0
PILOT_STEER_TYPE	0
SERVO1_FUNCTION	26
SERVO1_MAX	2000
SERVO1_MIN	1000
SERVO1_REVERSED	0
SERVO1_TRIM	1500
SERVO3_FUNCTION	70
SERVO3_MAX	1900
SERVO3_MIN	1100
SERVO3_REVERSED	0
SERVO3_TRIM	1500
ATC_TURN_MAX_G	0.1
TURN_RADIUS	3
WP_OVERSHOOT	6
WP_RADIUS	2
WP_SPEED	10
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      #NOTE: HobbyKing Hydrotek using Rover-3.3.1
ACRO_TURN_RATE,120
ATC_ACCEL_MAX,2
ATC_SPEED_I,0.2
ATC_SPEED_P,0.2
ATC_STR_ACC_MAX,360
ATC_STR_ANG_P,2
ATC_STR_RAT_FF,0.6
ATC_STR_RAT_I,0.2
ATC_STR_RAT_MAX,90
ATC_STR_RAT_P,0.2
BRD_SAFETYENABLE,0
RC7_OPTION,3
COMPASS_ORIENT,4
CRUISE_SPEED,2
CRUISE_THROTTLE,20
FRAME_CLASS,2
NAVL1_DAMPING,0.75
NAVL1_PERIOD,8
NAVL1_XTRACK_I,0.02
SERVO1_FUNCTION,26
SERVO1_MAX,1900
SERVO1_MIN,1100
SERVO1_REVERSED,1
SERVO1_TRIM,1500
SERVO3_FUNCTION,70
SERVO3_MAX,1900
SERVO3_MIN,1100
SERVO3_REVERSED,0
SERVO3_TRIM,1500
SPEED_TURN_GAIN,50
ATC_TURN_MAX_G,0.4
WP_SPEED,4
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ANGLE_MAX        7500
ATC_ACCEL_P_MAX  247932.2
ATC_ACCEL_R_MAX  280459.7
ATC_ACCEL_Y_MAX  70449.61
ATC_ANG_PIT_P    20.62971
ATC_ANG_RLL_P    21.77228
ATC_ANG_YAW_P    12.07662
ATC_RAT_PIT_D    0.001443983
ATC_RAT_PIT_FLTD 40
ATC_RAT_PIT_FLTT 40
ATC_RAT_PIT_I    0.05448329
ATC_RAT_PIT_P    0.05448329
ATC_RAT_PIT_SMAX 30
ATC_RAT_RLL_D    0.001218464
ATC_RAT_RLL_FLTD 40
ATC_RAT_RLL_FLTT 40
ATC_RAT_RLL_I    0.03652912
ATC_RAT_RLL_P    0.03652912
ATC_RAT_RLL_SMAX 30
ATC_RAT_YAW_D    0.004205064
ATC_RAT_YAW_FLTD 20
ATC_RAT_YAW_FLTE 2
ATC_RAT_YAW_I    0.02155114
ATC_RAT_YAW_P    0.2155114
ATC_RAT_YAW_SMAX 30
INS_HNTC2_ATT    40
INS_HNTC2_BW     8
INS_HNTC2_ENABLE 1
INS_HNTC2_FM_RAT 1
INS_HNTC2_FREQ   47
INS_HNTC2_HMNCS  3
INS_HNTC2_MODE   1
INS_HNTC2_OPTS   16
INS_HNTC2_REF    1
INS_HNTCH_ATT    40
INS_HNTCH_BW     20
INS_HNTCH_ENABLE 1
INS_HNTCH_FM_RAT 1
INS_HNTCH_FREQ   80
INS_HNTCH_HMNCS  1
INS_HNTCH_MODE   3
INS_HNTCH_OPTS   22
INS_HNTCH_REF    1
MOT_BAT_VOLT_MAX 16.8
MOT_BAT_VOLT_MIN 13.2
MOT_PWM_TYPE     6
MOT_SPIN_ARM     0.06
MOT_SPIN_MIN     0.08
MOT_THST_EXPO    0.55
MOT_THST_HOVER   0.125
PSC_ACCZ_I       0.168
PSC_ACCZ_P       0.084
SERVO_BLH_AUTO   1
SERVO_DSHOT_ESC  2
SERVO_DSHOT_RATE 3
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 