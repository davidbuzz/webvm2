#include <AP_gtest.h>
#include <AP_Common/AP_Common.h>

#include <AP_Math/AP_Math.h>

struct PB {
    Vector2f point;
    Vector2f boundary[3];
    bool outside;
};

static const PB points_boundaries[] = {
    { {0.1f,0.1f}, {{0.0f,0.0f}, {0.0f,1.0f}, {1.0f,0.0f}}, false },

     // test for winding order issues:
    { {0.9f,0.9f}, {{0.0f,0.0f}, {1.0f,0.0f}, {0.0f,1.0f}}, true },
    { {0.9f,0.9f}, {{0.0f,1.0f}, {0.0f,0.0f}, {1.0f,0.0f}}, true },
    { {0.9f,0.9f}, {{1.0f,0.0f}, {0.0f,1.0f}, {0.0f,0.0f}}, true },
    { {0.9f,0.9f}, {{0.0f,1.0f}, {1.0f,0.0f}, {0.0f,0.0f}}, true },

    { {0.1f,0.1f}, {{0.0f,0.0f}, {1.0f,0.0f}, {0.0f,1.0f}}, false },
    { {0.1f,0.1f}, {{0.0f,1.0f}, {0.0f,0.0f}, {1.0f,0.0f}}, false },
    { {0.1f,0.1f}, {{1.0f,0.0f}, {0.0f,1.0f}, {0.0f,0.0f}}, false },
    { {0.1f,0.1f}, {{0.0f,1.0f}, {1.0f,0.0f}, {0.0f,0.0f}}, false },

    { {0.99f-10.0f,0.99f-10.0f}, {{0.0f-10.0f,1.0f-10.0f}, {1.0f-10.0f,0.0f-10.0f}, {0.0f-10.0f,0.0f-10.0f}}, true },

    { {99.0f,99.0f}, {{0.0f,100.0f}, {100.0f,0.0f}, {0.0f,0.0f}}, true },

    { {0.1f,0.0f}, {{0.0f,0.0f}, {0.0f,1.0f}, {1.0f,0.0f}}, false },
    { {0.0f,0.99f}, {{0.0f,0.0f}, {0.0f,1.0f}, {1.0f,0.0f}}, false },
    { {0.99f,0.0f}, {{0.0f,0.0f}, {0.0f,1.0f}, {1.0f,0.0f}}, false },

    { {1.01f,0.0f}, {{0.0f,0.0f}, {0.0f,1.0f}, {1.0f,0.0f}}, true },
    { {0.0f,1.01f}, {{0.0f,0.0f}, {0.0f,1.0f}, {1.0f,0.0f}}, true },

    { {2.0f,2.0f}, {{0.0f,0.0f}, {0.0f,1.0f}, {1.0f,0.0f}}, true },
    { {-2.0f,-2.0f}, {{0.0f,0.0f}, {0.0f,1.0f}, {1.0f,0.0f}}, true },

    { {-0.05f,0.0f}, {{0.0f,0.0f}, {0.0f,1.0f}, {1.0f,0.0f}}, true },
    { {0.0f,-0.05f}, {{0.0f,0.0f}, {0.0f,1.0f}, {1.0f,0.0f}}, true },
};

TEST(Polygon, outside)
{
    // uint8_t count = 0;
    for (const struct PB &pb : points_boundaries) {
        // ::fprintf(stderr, "count=%u\n", count++);
        Vector2f v[4];
        memcpy(v, pb.boundary, sizeof(pb.boundary));
        v[3] = v[0]; // close it
        EXPECT_EQ(pb.outside, Polygon_outside(pb.point, v, 4));
    }
}

struct SquareBoundary {
    Vector2f point;
    Vector2f boundary[4];
    bool outside;
};
static const SquareBoundary square_boundaries[] = {
    { {1.0f,1.0f}, {{0.0f,0.0f}, {0.0f,10.0f}, {10.0, 10.0}, {10.0f,0.0f}}, false },
    { {9.0f,9.0f}, {{0.0f,0.0f}, {0.0f,10.0f}, {10.0, 10.0}, {10.0f,0.0f}}, false },
    { {1.0f,9.0f}, {{0.0f,0.0f}, {0.0f,10.0f}, {10.0, 10.0}, {10.0f,0.0f}}, false },
    { {9.0f,1.0f}, {{0.0f,0.0f}, {0.0f,10.0f}, {10.0, 10.0}, {10.0f,0.0f}}, false },

};

TEST(Polygon, square_boundaries)
{
    // uint8_t count = 0;
    for (const auto &pb : square_boundaries) {
        // ::fprintf(stderr, "count=%u\n", count++);
        Vector2f v[5];
        memcpy(v, pb.boundary, sizeof(pb.boundary));
        v[4] = v[0]; // close it
        EXPECT_EQ(pb.outside, Polygon_outside(pb.point, v, 5));
        EXPECT_EQ(Polygon_outside(pb.point, v, 4),
                  Polygon_outside(pb.point, v, 5));
    }
}

TEST(Polygon, circle_outside_triangle)
{
    const Vector2f triangle[] = {{0.0f,0.0f}, {1.0f,0.0f}, {0.0f,1.0f}};
    Vector2f triangle_closed[4];
    memcpy(triangle_closed, triangle, sizeof(triangle));
    triangle_closed[3] = triangle_closed[0];
    const float radius = 0.8f;
    for (uint16_t i=0; i<360; i++) {
        const float x = radius * sin(radians(i)) + 0.5f;
        const float y = radius * cos(radians(i)) + 0.5f;
        EXPECT_EQ(true, Polygon_outside(Vector2f{x,y}, triangle_closed, 4));
        EXPECT_EQ(Polygon_outside(Vector2f{x,y}, triangle_closed, 3),
                  Polygon_outside(Vector2f{x,y}, triangle_closed, 4));
    }
}

TEST(Polygon, circle_inside_triangle)
{
    const Vector2f triangle[] = {{0.0f,0.0f}, {1.0f,0.0f}, {0.0f,1.0f}};
    Vector2f triangle_closed[4];
    memcpy(triangle_closed, triangle, sizeof(triangle));
    triangle_closed[3] = triangle_closed[0];
    const float radius = 0.2f;
    for (uint16_t i=0; i<360; i++) {
        const float x = radius * sin(radians(i)) + 0.2f;
        const float y = radius * cos(radians(i)) + 0.2f;
        EXPECT_EQ(false, Polygon_outside(Vector2f{x,y}, triangle_closed, 4));
        EXPECT_EQ(Polygon_outside(Vector2f{x,y}, triangle_closed, 3),
                  Polygon_outside(Vector2f{x,y}, triangle_closed, 4));
    }
}

TEST(Polygon, complex)
{
    const Vector2f poly[] = {
        {0.0f,0.0f},
        {0.0f,10.0f},
        {5.0, 10.0f},
        {5.0f,5.0f},
        {3.0f,5.0f},
        {3.0f,6.0f},
        {4.0f,6.0f},
        {4.0f,9.0f},
        {4.0f,9.0f},
        {1.0f,9.0f},
        {1.0f,6.0f},
        {2.0f,6.0f},
        {2.0f,5.0f},
        {1.0f,5.0f},
        {1.0f,0.0f},
    };
    const Vector2f inside_points[] = {
        {0.1f, 0.1f},
        {4.5f, 9.5f},
        {0.5f, 9.5f},
    };
    const Vector2f outside_points[] = {
        {3.0f, 8.0f},
        {5.5f, 10.0f},
        {2.0f, 2.0f},
        {2.5f, 5.5f},
        {1.5f, 6.5f},
    };

    Vector2f closed_poly[sizeof(poly) + sizeof(Vector2f)];
    memcpy(closed_poly, poly, sizeof(poly));
    const uint16_t n = ARRAY_SIZE(closed_poly);
    closed_poly[n-1] = closed_poly[0];

    for (const auto &point : inside_points) {
        EXPECT_EQ(false, Polygon_outside(point, closed_poly, n));
        EXPECT_EQ(Polygon_outside(point, closed_poly, n-1),
                  Polygon_outside(point, closed_poly, n));
    }
    for (const auto &point : outside_points) {
        EXPECT_EQ(true, Polygon_outside(point, closed_poly, n));
        EXPECT_EQ(Polygon_outside(point, closed_poly, n-1),
                  Polygon_outside(point, closed_poly, n));
    }
}

TEST(Polygon, circle_outside_square)
{
    const Vector2f square[] = {{0.0f,0.0f}, {0.0f,10.0f}, {10.0, 10.0}, {10.0f,0.0f}};
    Vector2f square_closed[5];
    memcpy(square_closed, square, sizeof(square));
    square_closed[4] = square_closed[0];
    const float radius = 8.0f;
    for (uint16_t i=0; i<360; i++) {
        const float x = radius * sin(radians(i)) + 5.0f;
        const float y = radius * cos(radians(i)) + 5.0f;
        EXPECT_EQ(true, Polygon_outside(Vector2f{x,y}, square_closed, 4));
        EXPECT_EQ(Polygon_outside(Vector2f{x,y}, square_closed, 3),
                  Polygon_outside(Vector2f{x,y}, square_closed, 4));
    }
}

struct PB_long {
    Vector2l point;
    Vector2l boundary[3];
    bool outside;
};

static const PB_long points_boundaries_long[] = {
    { {1000000,1000000}, {{0,0}, {0,10000000}, {10000000,0}}, false },

     // test for winding order issues:
    { {9000000,9000000}, {{0,0}, {10000000,0}, {0,10000000}}, true },
    { {9000000,9000000}, {{0,10000000}, {0,0}, {10000000,0}}, true },
    { {9000000,9000000}, {{10000000,0}, {0,10000000}, {0,0}}, true },
    { {9000000,9000000}, {{0,10000000}, {10000000,0}, {0,0}}, true },

    { {1000000,1000000}, {{0,0}, {10000000,0}, {0,10000000}}, false },
    { {1000000,1000000}, {{0,10000000}, {0,0}, {10000000,0}}, false },
    { {1000000,1000000}, {{10000000,0}, {0,10000000}, {0,0}}, false },
    { {1000000,1000000}, {{0,10000000}, {10000000,0}, {0,0}}, false },

    { {9900000-10,9900000-10}, {{0-10,10000000-10}, {10000000-10,0-10}, {0-10,0-10}}, true },

    { {990000000,990000000}, {{0,100}, {100,0}, {0,0}}, true },

    { {1000000,0}, {{0,0}, {0,10000000}, {10000000,0}}, false },
    { {0,9900000}, {{0,0}, {0,10000000}, {10000000,0}}, false },
    { {9900000,0}, {{0,0}, {0,10000000}, {10000000,0}}, false },

    { {10100000,0}, {{0,0}, {0,10000000}, {10000000,0}}, true },
    { {0,10100000}, {{0,0}, {0,10000000}, {10000000,0}}, true },

    { {20000000,20000000}, {{0,0}, {0,10000000}, {10000000,0}}, true },
    { {-20000000,-20000000}, {{0,0}, {0,10000000}, {10000000,0}}, true },

    { {-500000,0}, {{0,0}, {0,10000000}, {10000000,0}}, true },
    { {0,-500000}, {{0,0}, {0,10000000}, {10000000,0}}, true },
};

TEST(Polygon, outside_long)
{
    // uint8_t count = 0;
    for (const struct PB_long &pb : points_boundaries_long) {
        // ::fprintf(stderr, "count=%u\n", count++);
        Vector2l v[4];
        memcpy(v, pb.boundary, sizeof(pb.boundary));
        v[3] = v[0]; // close it
        EXPECT_EQ(pb.outside, Polygon_outside(pb.point, v, 4));
    }
}

TEST(Polygon, outside_long_closed_equal_to_unclosed)
{
    // uint8_t count = 0;
    for (const struct PB_long &pb : points_boundaries_long) {
        // ::fprintf(stderr, "count=%u\n", count++);
        Vector2l v[4];
        memcpy(v, pb.boundary, sizeof(pb.boundary));
        v[3] = v[0]; // close it
        EXPECT_EQ(Polygon_outside(pb.point, v, 3),
                  Polygon_outside(pb.point, v, 4));
    }
}


#define TEST_POLYGON_POINTS(POLYGON, TEST_POINTS)                       \
    do {                                                                \
        for (uint32_t i = 0; i < ARRAY_SIZE(TEST_POINTS); i++) {        \
            EXPECT_EQ(TEST_POINTS[i].outside,                           \
                      Polygon_outside(TEST_POINTS[i].point,             \
                                      POLYGON, ARRAY_SIZE(POLYGON)));   \
        }                                                               \
    } while(0)

// this OBC polygon test stolen from the polygon Math example

/*
 *  this is the boundary of the 2010 outback challenge
 *  Note that the last point must be the same as the first for the
 *  Polygon_outside() algorithm
 */
static const Vector2l OBC_boundary[] = {
    Vector2l(-265695640, 1518373730),
    Vector2l(-265699560, 1518394050),
    Vector2l(-265768230, 1518411420),
    Vector2l(-265773080, 1518403440),
    Vector2l(-265815110, 1518419500),
    Vector2l(-265784860, 1518474690),
    Vector2l(-265994890, 1518528860),
    Vector2l(-266092110, 1518747420),
    Vector2l(-266454780, 1518820530),
    Vector2l(-266435720, 1518303500),
    Vector2l(-265875990, 1518344050),
    Vector2l(-265695640, 1518373730)
};

static const struct {
    Vector2l point;
    bool outside;
} OBC_test_points[] = {
    { Vector2l(-266398870, 1518220000), true },
    { Vector2l(-266418700, 1518709260), false },
    { Vector2l(-350000000, 1490000000), true },
    { Vector2l(0, 0),                   true },
    { Vector2l(-265768150, 1518408250), false },
    { Vector2l(-265774060, 1518405860), true },
    { Vector2l(-266435630, 1518303440), true },
    { Vector2l(-266435650, 1518313540), false },
    { Vector2l(-266435690, 1518303530), false },
    { Vector2l(-266435690, 1518303490), true },
    { Vector2l(-265875990, 1518344049), true },
    { Vector2l(-265875990, 1518344051), false },
    { Vector2l(-266454781, 1518820530), true },
    { Vector2l(-266454779, 1518820530), true },
    { Vector2l(-266092109, 1518747420), true },
    { Vector2l(-266092111, 1518747420), false },
    { Vector2l(-266092110, 1518747421), true },
    { Vector2l(-266092110, 1518747419), false },
    { Vector2l(-266092111, 1518747421), true },
    { Vector2l(-266092109, 1518747421), true },
    { Vector2l(-266092111, 1518747419), false },
};

TEST(Polygon, obc)
{
    TEST_POLYGON_POINTS(OBC_boundary, OBC_test_points);
}

static const Vector2f PROX_boundary[] = {
    Vector2f{938.315063f,388.662872f},
    Vector2f{545.622803f,1317.25f},
    Vector2f{-833.382812f,2011.96423f},
    Vector2f{-2011.96411f,833.382996f},
    Vector2f{-875.159241f,-362.502838f},
    Vector2f{-153.222916f,-369.912689f},
    Vector2f{153.222931f,-369.912689f},
    Vector2f{369.91272f,-153.222855f},

    // closing point so we can call Polygon_outside(...):
    Vector2f{938.315063f,388.662872f},
};


static const struct {
    Vector2f point;
    bool outside;
} PROX_test_points[] = {
    { Vector2f{0.0f,0.0f}, false },
};

TEST(Polygon, prox)
{
    TEST_POLYGON_POINTS(PROX_boundary, PROX_test_points);
}

static const Vector2f SIMPLE_boundary[] = {
    Vector2f{-1,2},
    Vector2f{1,2},
    Vector2f{1,-3},
    Vector2f{-1,-3},

    // closing point so we can call Polygon_outside(...):
    Vector2f{-1,2},
};

static const struct {
    Vector2f point;
    bool outside;
} SIMPLE_test_points[] = {
    { Vector2f{0.0f,0.0f}, false },
    { Vector2f{0.5f,1.5f}, false },
    { Vector2f{-0.5f,1.5f}, false },
    { Vector2f{-0.5f,-2.5}, false },
};

TEST(Polygon, simple)
{
    TEST_POLYGON_POINTS(SIMPLE_boundary, SIMPLE_test_points);
}

AP_GTEST_MAIN()


int hal = 0; // bizarrely, this fixes an undefined-symbol error but doesn't raise a type exception.  Yay.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 #include <AP_gtest.h>

#include <AP_Math/AP_Math.h>

const AP_HAL::HAL& hal = AP_HAL::get_HAL();

// Tests that quaternion multiplication obeys Hamilton's quaternion multiplication convention
// i*i == j*j == k*k == i*j*k == -1
TEST(QuaternionTest, QuaternionMultiplicationOfBases) {
    const Quaternion unit(1.0f, 0.0f, 0.0f, 0.0f);
    const Quaternion i(0.0f, 1.0f, 0.0f, 0.0f);
    const Quaternion j(0.0f, 0.0f, 1.0f, 0.0f);
    const Quaternion k(0.0f, 0.0f, 0.0f, 1.0f);

    Quaternion ii, ij, ik, ji, jj, jk, ki, kj, kk, ijk;
    ii = i * i;
    ij = i * j;
    ik = i * k;
    ji = j * i;
    jj = j * j;
    jk = j * k;
    ki = k * i;
    kj = k * j;
    kk = k * k;
    ijk = i * j * k;

    for (int a = 0; a < 4; ++a) {
        EXPECT_FLOAT_EQ(ii[a], jj[a]);
        EXPECT_FLOAT_EQ(jj[a], kk[a]);
        EXPECT_FLOAT_EQ(kk[a], ijk[a]);
        EXPECT_FLOAT_EQ(ijk[a], -unit[a]);
        EXPECT_FLOAT_EQ(ij[a], k[a]);
        EXPECT_FLOAT_EQ(ii[a], -unit[a]);
        EXPECT_FLOAT_EQ(ik[a], -j[a]);
        EXPECT_FLOAT_EQ(ji[a], -k[a]);
        EXPECT_FLOAT_EQ(jj[a], -unit[a]);
        EXPECT_FLOAT_EQ(jk[a], i[a]);
        EXPECT_FLOAT_EQ(ki[a], j[a]);
        EXPECT_FLOAT_EQ(kj[a], -i[a]);
        EXPECT_FLOAT_EQ(kk[a], -unit[a]);
        EXPECT_FLOAT_EQ(ijk[a], -unit[a]);
    }
}

// Tests that the quaternion to rotation matrix conversion formula is correctly derived from the Hamilton's quaternion
// multiplication convention. This specific example is taken from "Why and How to Avoid the Flipped Quaternion
// Multiplication" (https://arxiv.org/pdf/1801.07478.pdf)
TEST(QuaternionTest, QuaternionToRotationMatrix) {
    Matrix3f res;
    Quaternion(0.5f * sqrtf(2.0f), 0.0f, 0.0f, 0.5f * sqrtf(2.0f)).rotation_matrix(res);

    EXPECT_NEAR(res.a.x, 0.0f, 1e-6f);
    EXPECT_NEAR(res.a.y, -1.0f, 1e-6f);
    EXPECT_NEAR(res.a.z, 0.0f, 1e-6f);
    EXPECT_NEAR(res.b.x, 1.0f, 1e-6f);
    EXPECT_NEAR(res.b.y, 0.0f, 1e-6f);
    EXPECT_NEAR(res.b.z, 0.0f, 1e-6f);
    EXPECT_NEAR(res.c.x, 0.0f, 1e-6f);
    EXPECT_NEAR(res.c.y, 0.0f, 1e-6f);
    EXPECT_NEAR(res.c.z, 1.0f, 1e-6f);
}

// Tests that quaternion multiplication is homomorphic with rotation matrix
// multiplication, or C(q0 * q1) = C(q0) * C(q1)
TEST(QuaternionTest, QuaternionMultiplicationIsHomomorphism) {
    Quaternion l_quat(0.8365163f, 0.48296291f, 0.22414387f, -0.12940952f);
    Quaternion r_quat(0.9576622f, 0.03378266f, 0.12607862f, 0.25660481f);

    Matrix3f res_mat_0;
    (l_quat * r_quat).rotation_matrix(res_mat_0);

    Matrix3f res_mat_1, l_mat, r_mat;
    l_quat.rotation_matrix(l_mat);
    r_quat.rotation_matrix(r_mat);
    res_mat_1 = l_mat * r_mat;

    EXPECT_NEAR(res_mat_0.a.x, res_mat_1.a.x, 1e-6f);
    EXPECT_NEAR(res_mat_0.a.y, res_mat_1.a.y, 1e-6f);
    EXPECT_NEAR(res_mat_0.a.z, res_mat_1.a.z, 1e-6f);
    EXPECT_NEAR(res_mat_0.b.x, res_mat_1.b.x, 1e-6f);
    EXPECT_NEAR(res_mat_0.b.y, res_mat_1.b.y, 1e-6f);
    EXPECT_NEAR(res_mat_0.b.z, res_mat_1.b.z, 1e-6f);
    EXPECT_NEAR(res_mat_0.c.x, res_mat_1.c.x, 1e-6f);
    EXPECT_NEAR(res_mat_0.c.y, res_mat_1.c.y, 1e-6f);
    EXPECT_NEAR(res_mat_0.c.z, res_mat_1.c.z, 1e-6f);
}

// Tests that applying a rotation by a unit quaternion does nothing
TEST(QuaternionTest, QuatenionRotationByUnitQuaternion) {
    Vector3f v(1.0f, 2.0f, 3.0f);
    Quaternion q(1.0f, 0.0f, 0.0f, 0.0f);

    Vector3f res = q * v;

    for (int i = 0; i < 3; ++i) {
        EXPECT_FLOAT_EQ(res[i], v[i]);
    }
}

// Tests that applying a rotation by a quaternion whose axis is parallel to the vector does nothing
TEST(QuaternionTest, QuatenionRotationByParallelQuaternion) {
    Vector3f v(1.0f, 2.0f, 3.0f);
    Quaternion q(0.730296743340221, 0.182574185835055, 0.365148371670111, 0.547722557505166f);

    Vector3f res = q * v;

    for (int i = 0; i < 3; ++i) {
        EXPECT_FLOAT_EQ(res[i], v[i]);
    }
}

// Tests that applying a rotation by a unit quaternion does not change the vector's length
TEST(QuaternionTest, QuatenionRotationLengthPreserving) {
    Vector3f v(1.0f, 2.0f, 3.0f);
    Quaternion q(0.8365163f, 0.48296291f, 0.22414387f, -0.12940952f);

    Vector3f res = q * v;

    EXPECT_FLOAT_EQ(res.length(), v.length());
}

// Tests that calling the quaternion rotation operator is equivalent to the formula q * v * q.inverse(), and to
// converting to rotation matrix followed by matrix multiplication
TEST(QuaternionTest, QuatenionRotationFormulaEquivalence) {
    Vector3f res_1, res_0, res_2;
    Vector3f v(1.0f, 2.0f, 3.0f);
    Quaternion q(0.8365163f, 0.48296291f, 0.22414387f, -0.12940952f);

    res_0 = q * v;

    Quaternion qv(0.0f, v.x, v.y, v.z);
    Quaternion res_qv = q * qv * q.inverse();
    res_1 = Vector3f(res_qv.q2, res_qv.q3, res_qv.q4);

    Matrix3f q_equiv_mat;
    q.rotation_matrix(q_equiv_mat);
    res_2 = q_equiv_mat * v;

    for (int i = 0; i < 3; ++i) {
        EXPECT_FLOAT_EQ(res_0[i], res_1[i]);
        EXPECT_FLOAT_EQ(res_0[i], res_2[i]);
    }
}

// Tests that the calling the rotation operator on a inverted quaternion is equivalent to q.inverse() * v * q, and to
// converting to rotation matrix, taking transpose, followed by matrix multiplication
TEST(QuaternionTest, QuatenionInverseRotationFormulaEquivalence) {
    Vector3f res_0, res_1, res_2;
    Vector3f v(1.0f, 2.0f, 3.0f);
    Quaternion q(0.8365163f, 0.48296291f, 0.22414387f, -0.12940952f);

    res_0 = q.inverse() * v;

    Quaternion qv(0.0f, v.x, v.y, v.z);
    Quaternion res_qv = q.inverse() * qv * q;
    res_1 = Vector3f(res_qv.q2, res_qv.q3, res_qv.q4);

    Matrix3f q_equiv_mat;
    q.rotation_matrix(q_equiv_mat);
    res_2 = q_equiv_mat.transposed() * v;

    for (int i = 0; i < 3; ++i) {
        EXPECT_FLOAT_EQ(res_0[i], res_1[i]);
        EXPECT_FLOAT_EQ(res_0[i], res_2[i]);
    }
}

// Test zero()
TEST(QuaternionTest, Quaternion_zero)
{
    Quaternion q {0.0, 0.0, 0.0, 0.0};
    q.zero();
    EXPECT_TRUE(q.is_zero());

    q = Quaternion{0.8365163, 0.48296291, 0.22414387, -0.12940952};
    q.zero();
    EXPECT_TRUE(q.is_zero());

    // unit length
    q = Quaternion{1.0, 0.0, 0.0, 0.0};
    q.zero();
    EXPECT_TRUE(q.is_zero());
}

// Tests is_zero()
TEST(QuaternionTest, Quaternion_is_zero)
{
    Quaternion q {0.0, 0.0, 0.0, 0.0};
    EXPECT_TRUE(q.is_zero());

    q = Quaternion{0.8365163, 0.48296291, 0.22414387, -0.12940952};
    EXPECT_FALSE(q.is_zero());

    q = Quaternion{0.9, 0.0, 0.0, 0.0};
    EXPECT_FALSE(q.is_zero());
}

// Tests is_unit_length()
TEST(QuaternionTest, Quaternion_is_unit_length)
{
    // zero length
    Quaternion q {0.0, 0.0, 0.0, 0.0};
    EXPECT_FALSE(q.is_unit_length());

    // Length == 1.0 - 0.0009, slightly within the tolerance
    q = Quaternion{0.8361398, 0.4827455, 0.2240430, -0.1293512};
    EXPECT_TRUE(q.is_unit_length());

    // unit length
    q  = Quaternion{0.8365163, 0.48296291, 0.22414387, -0.12940952};
    EXPECT_TRUE(q.is_unit_length());

    // unit length
    q = Quaternion{1.0, 0.0, 0.0, 0.0};
    EXPECT_TRUE(q.is_unit_length());

    // Length == 1.0 + 0.0009, slightly within the tolerance
    q = Quaternion{0.8368926, 0.4831802, 0.2242447, -0.1294677};
    EXPECT_TRUE(q.is_unit_length());

    // Length == 1.2
    q = Quaternion{1.00382, 0.579555, 0.268973, -0.155291};
    EXPECT_FALSE(q.is_unit_length());
}

// Tests length_squared()
TEST(QuaternionTest, Quaternion_length_squared)
{
    // zero length
    Quaternion q {0.0, 0.0, 0.0, 0.0};
    EXPECT_FLOAT_EQ(q.length_squared(), 0.0);

    // Length == 1.0 - 0.0009, slightly within the tolerance
    q = Quaternion{0.8361398, 0.4827455, 0.2240430, -0.1293512};
    EXPECT_FLOAT_EQ(q.length_squared(), 1.0 - 0.0009);

    // unit length
    q  = Quaternion{0.8365163, 0.48296291, 0.22414387, -0.12940952};
    EXPECT_FLOAT_EQ(q.length_squared(), 1.0);

    // unit length
    q = Quaternion{1.0, 0.0, 0.0, 0.0};
    EXPECT_FLOAT_EQ(q.length_squared(), 1.0);

    // Length == 1.0 + 0.0009, slightly within the tolerance
    q = Quaternion{0.8368926, 0.4831802, 0.2242447, -0.1294677};
    EXPECT_FLOAT_EQ(q.length_squared(), 1.0 + 0.0009);

    // Length == 1.2
    q = Quaternion{1.00382, 0.579555, 0.268973, -0.155291};
    EXPECT_FLOAT_EQ(q.length_squared(), 1.44);
}

AP_GTEST_MAIN()                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   #include <AP_gtest.h>

#include <AP_Math/AP_Math.h>

const AP_HAL::HAL& hal = AP_HAL::get_HAL();

const float angle_max_deg = 60;
const float angle_limit_deg = 60;
float roll_out_deg, pitch_out_deg;

// Test the corners of the input range
TEST(RC2RPTest, Corners) {
    // (-1,-1), (-1,1), (1,-1), (1,1)
    float roll_in[]  = {-1, -1,  1, 1};
    float pitch_in[] = {-1,  1, -1, 1};
    float rc = 37.761f;  // roll at 60 deg max/limit
    float pc = 50.768f;  // pitch at 60 deg max/limit
    float roll_val_deg[]  = {-rc, -rc, rc, rc};
    float pitch_val_deg[] = {-pc, pc, -pc, pc};

    for (uint i=0; i<ARRAY_SIZE(roll_val_deg); i++) {
        rc_input_to_roll_pitch(roll_in[i], pitch_in[i], angle_max_deg, angle_limit_deg, roll_out_deg, pitch_out_deg);

        EXPECT_TRUE(fabsf(roll_out_deg  - roll_val_deg[i])  < .0005f);
        EXPECT_TRUE(fabsf(pitch_out_deg - pitch_val_deg[i]) < .0005f);
    }
}

// Test some points on the axes
TEST(RC2RPTest, Axes) {
    // (0,-1), (0,1), (1,0), (-1,1)
    float roll_in[]  = { 0,  0,  0, -1,  0.5,  0.0, 1};
    float pitch_in[] = {-1,  1,  0,  0,  0.0,  0.5, 0};
    float roll_val_deg[] = {0,
                            0,
                            0, 
                            -angle_max_deg,
                            angle_max_deg/2,
                            0,
                            angle_max_deg};
    float pitch_val_deg[] = {-angle_max_deg,
                             angle_max_deg, 0,
                             0,
                             0,
                             angle_max_deg/2,
                             0};

    for (uint i=0; i<ARRAY_SIZE(roll_val_deg); i++) {
        rc_input_to_roll_pitch(roll_in[i], pitch_in[i], angle_max_deg, angle_limit_deg, roll_out_deg, pitch_out_deg);

        EXPECT_TRUE(fabsf(roll_out_deg  - roll_val_deg[i])  < .00005f);
        EXPECT_TRUE(fabsf(pitch_out_deg - pitch_val_deg[i]) < .00005f);
    }

}

// Test some points on the circle at 60 degrees
TEST(RC2RPTest, Circle) {

    // values generated by VPython implementation; roll/pitch deltas are < .02 degrees w.r.t C++ code
    float xy_rp[][4] = {
        {1.000, 0.000, 60.000, 0.000},
        {0.924, 0.383, 53.193, 22.961},
        {0.707, 0.707, 34.005, 42.426},
        {0.383, 0.924, 13.516, 55.433},
        {0.000, 1.000, 0.000, 60.000},
        {-0.383, 0.924, -13.516, 55.433},
        {-0.707, 0.707, -34.005, 42.426},
        {-0.924, 0.383, -53.193, 22.961},
        {-1.000, 0.000, -60.000, 0.000},
        {-0.924, -0.383, -53.193, -22.961},
        {-0.707, -0.707, -34.005, -42.426},
        {-0.383, -0.924, -13.516, -55.433},
        {-0.000, -1.000, -0.000, -60.000},
        {0.383, -0.924, 13.516, -55.433},
        {0.707, -0.707, 34.005, -42.426},
        {0.924, -0.383, 53.193, -22.961}
    };

    for (uint row=0; row<ARRAY_SIZE(xy_rp); row++) {
        float roll_in = xy_rp[row][0];
        float pitch_in = xy_rp[row][1];
        rc_input_to_roll_pitch(roll_in, pitch_in, angle_max_deg, angle_limit_deg, roll_out_deg, pitch_out_deg);

        EXPECT_TRUE(fabsf(roll_out_deg  - xy_rp[row][2]) < .02f);
        EXPECT_TRUE(fabsf(pitch_out_deg - xy_rp[row][3]) < .02f);
    }
}


AP_GTEST_MAIN();
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                #include <AP_gtest.h>

#include <AP_Math/AP_Math.h>
#include <AP_CustomRotations/AP_CustomRotations.h>


AP_CustomRotations cust_rot;
const AP_HAL::HAL& hal = AP_HAL::get_HAL();


static void test_euler(enum Rotation rotation, float roll, float pitch, float yaw)
{
    Vector3f v, v1, v2, diff;
    Matrix3f rotmat;
    const float accuracy = 1.0e-6f;

    v.x = 1;
    v.y = 2;
    v.z = 3;
    v1 = v;

    v1.rotate(rotation);

    rotmat.from_euler(radians(roll), radians(pitch), radians(yaw));
    v2 = v;
    v2 = rotmat * v2;

    diff = (v2 - v1);
    EXPECT_LE(diff.length(), accuracy);

    // quaternion rotation test
    const float q_accuracy = 1.0e-3f;
    Quaternion q, qe;
    q.from_rotation(rotation);
    qe.from_euler(radians(roll), radians(pitch), radians(yaw));
    float q_roll, q_pitch, q_yaw, qe_roll, qe_pitch, qe_yaw;
    q.to_euler(q_roll, q_pitch, q_yaw);
    qe.to_euler(qe_roll, qe_pitch, qe_yaw);
    float roll_diff = fabsf(wrap_PI(q_roll - qe_roll));
    float pitch_diff = fabsf(wrap_PI(q_pitch - qe_pitch));
    float yaw_diff = fabsf(wrap_PI(q_yaw - qe_yaw));
    EXPECT_LE(roll_diff, q_accuracy);
    EXPECT_LE(pitch_diff, q_accuracy);
    EXPECT_LE(yaw_diff, q_accuracy);

    // test custom rotations
    AP::custom_rotations().set(ROTATION_CUSTOM_1, roll, pitch, yaw);
    v1 = v;
    v1.rotate(ROTATION_CUSTOM_1);

    diff = (v2 - v1);
    EXPECT_LE(diff.length(), accuracy);

    Quaternion qc;
    qc.from_rotation(ROTATION_CUSTOM_1);
    float qc_roll, qc_pitch, qc_yaw;
    qc.to_euler(qc_roll, qc_pitch, qc_yaw);
    roll_diff = fabsf(wrap_PI(qc_roll - qe_roll));
    pitch_diff = fabsf(wrap_PI(qc_pitch - qe_pitch));
    yaw_diff = fabsf(wrap_PI(qc_yaw - qe_yaw));
    EXPECT_LE(roll_diff, q_accuracy);
    EXPECT_LE(pitch_diff, q_accuracy);
    EXPECT_LE(yaw_diff, q_accuracy);
}

TEST(RotationsTest, TestEulers)
{
    test_euler(ROTATION_NONE,               0,   0,   0);
    test_euler(ROTATION_YAW_45,             0,   0,  45);
    test_euler(ROTATION_YAW_90,             0,   0,  90);
    test_euler(ROTATION_YAW_135,            0,   0, 135);
    test_euler(ROTATION_YAW_180,            0,   0, 180);
    test_euler(ROTATION_YAW_225,            0,   0, 225);
    test_euler(ROTATION_YAW_270,            0,   0, 270);
    test_euler(ROTATION_YAW_315,            0,   0, 315);
    test_euler(ROTATION_ROLL_180,         180,   0,   0);
    test_euler(ROTATION_ROLL_180_YAW_45,  180,   0,  45);
    test_euler(ROTATION_ROLL_180_YAW_90,  180,   0,  90);
    test_euler(ROTATION_ROLL_180_YAW_135, 180,   0, 135);
    test_euler(ROTATION_PITCH_180,          0, 180,   0);
    test_euler(ROTATION_ROLL_180_YAW_225, 180,   0, 225);
    test_euler(ROTATION_ROLL_180_YAW_270, 180,   0, 270);
    test_euler(ROTATION_ROLL_180_YAW_315, 180,   0, 315);
    test_euler(ROTATION_ROLL_90,           90,   0,   0);
    test_euler(ROTATION_ROLL_90_YAW_45,    90,   0,  45);
    test_euler(ROTATION_ROLL_90_YAW_90,    90,   0,  90);
    test_euler(ROTATION_ROLL_90_YAW_135,   90,   0, 135);
    test_euler(ROTATION_ROLL_270,         270,   0,   0);
    test_euler(ROTATION_ROLL_270_YAW_45,  270,   0,  45);
    test_euler(ROTATION_ROLL_270_YAW_90,  270,   0,  90);
    test_euler(ROTATION_ROLL_270_YAW_135, 270,   0, 135);
    test_euler(ROTATION_PITCH_90,           0,  90,   0);
    test_euler(ROTATION_PITCH_270,          0, 270,   0);
    test_euler(ROTATION_PITCH_180_YAW_90,   0, 180,  90);
    test_euler(ROTATION_PITCH_180_YAW_270,  0, 180, 270);
    test_euler(ROTATION_ROLL_90_PITCH_90,  90,  90,   0);
    test_euler(ROTATION_ROLL_180_PITCH_90,180,  90,   0);
    test_euler(ROTATION_ROLL_270_PITCH_90,270,  90,   0);
    test_euler(ROTATION_ROLL_90_PITCH_180, 90, 180,   0);
    test_euler(ROTATION_ROLL_270_PITCH_180,270,180,   0);
    test_euler(ROTATION_ROLL_90_PITCH_270, 90, 270,   0);
    test_euler(ROTATION_ROLL_180_PITCH_270,180,270,   0);
    test_euler(ROTATION_ROLL_270_PITCH_270,270,270,   0);
    test_euler(ROTATION_ROLL_90_PITCH_180_YAW_90, 90, 180,  90);
    test_euler(ROTATION_ROLL_90_YAW_270,   90,   0, 270);
    test_euler(ROTATION_ROLL_90_PITCH_68_YAW_293,90,68.8,293.3);
    test_euler(ROTATION_ROLL_45,45,0,0);
    test_euler(ROTATION_ROLL_315,315,0,0);
    test_euler(ROTATION_PITCH_7, 0, 7, 0);
}


TEST(RotationsTest, TestRotationInverse)
{
    // rotate inverse test(Vector (1,1,1))
    Vector3f vec(1.0f,1.0f,1.0f), cmp_vec(1.0f, 1.0f, 1.0f);
    for (enum Rotation r = ROTATION_NONE;
         r < ROTATION_MAX;
         r = (enum Rotation)((uint8_t)r+1)) {
        vec.rotate(r);
        vec.rotate_inverse(r);
        EXPECT_LE((vec - cmp_vec).length(), 1e-5);
    }
}

TEST(RotationsTest, TestRotateMatrix)
{
    for (enum Rotation r = ROTATION_NONE;
         r < ROTATION_MAX;
         r = (enum Rotation)((uint8_t)r+1)) {
        Vector3f vec(1,2,3);
        Vector3f vec2 = vec;
        vec.rotate(r);
        Matrix3f m;
        m.from_rotation(r);
        vec2 = m * vec2;
        EXPECT_LE((vec - vec2).length(), 1e-5);
    }
}

#if CONFIG_HAL_BOARD == HAL_BOARD_LINUX
TEST(RotationsTest, TestFailedGetLinux)
{
    AP::custom_rotations().set(ROTATION_CUSTOM_OLD, 0, 0, 0);
    Vector3f vec(1,2,3);
    Vector3f vec2 = vec;
    AP::custom_rotations().rotate(ROTATION_CUSTOM_OLD, vec2);
    EXPECT_TRUE(vec == vec2);
    Vector3d vecd(1,2,3);
    Vector3d vecd2 = vecd;
    AP::custom_rotations().rotate(ROTATION_CUSTOM_OLD, vecd2);
    EXPECT_TRUE(vecd == vecd2);
    Quaternion q(1.0f, 0.0f, 0.0f, 0.0f);
    Quaternion q2(1.0f, 0.0f, 0.0f, 0.0f);
    AP::custom_rotations().from_rotation(ROTATION_CUSTOM_OLD, q2);
    for (int a = 0; a < 4; ++a) {
        EXPECT_FLOAT_EQ(q[a], q2[a]);
    }
    QuaternionD qd(1.0, 0.0, 0.0, 0.0);
    QuaternionD qd2(1.0, 0.0, 0.0, 0.0);
    AP::custom_rotations().from_rotation(ROTATION_CUSTOM_OLD, qd2);
    for (int a = 0; a < 4; ++a) {
        EXPECT_FLOAT_EQ(qd[a], qd2[a]);
    }
}
#endif

static void breakSingleton()
{
    AP_CustomRotations cust_rot1;
}
#if CONFIG_HAL_BOARD == HAL_BOARD_SITL
TEST(RotationsTest, TestFailedGetLinux)
{
    EXPECT_EXIT(AP::custom_rotations().set(ROTATION_CUSTOM_OLD, 0, 0, 0), testing::KilledBySignal(SIGABRT), "AP_InternalError::error_t::bad_rotation");
    EXPECT_EXIT(AP::custom_rotations().set(ROTATION_CUSTOM_END, 0, 0, 0), testing::KilledBySignal(SIGABRT), "AP_InternalError::error_t::bad_rotation");
    EXPECT_EXIT(breakSingleton(), testing::KilledBySignal(SIGABRT), "AP_CustomRotations must be singleton");
}
#endif

/*TEST(RotationsTest, TestRotateEqual)
{
    for (enum Rotation r = (enum Rotation)((uint8_t)ROTATION_MAX-1); r > ROTATION_NONE; r = (enum Rotation)((uint8_t)r-1)) {
        for (enum Rotation r2 = ROTATION_NONE; r2 < r; r2 = (enum Rotation)((uint8_t)r2+1)) {
            if (rotation_equal(r,r2)) {
                hal.console->printf("Rotation %i same as %i\n", r, r2);
            }
        }
    }
}*/

/*
  rotate a matrix using a give order, specified as a string
  for example "321"
 */
static void rotate_ordered(Matrix3f &m, const char *order,
                           const float roll_deg,
                           const float pitch_deg,
                           const float yaw_deg)
{
    while (*order) {
        Matrix3f m2;
        switch (*order) {
        case '1':
            m2.from_euler(radians(roll_deg), 0, 0);
            break;
        case '2':
            m2.from_euler(0, radians(pitch_deg), 0);
            break;
        case '3':
            m2.from_euler(0, 0, radians(yaw_deg));
            break;
        }
        m *= m2;
        order++;
    }
}

/*
  test the two euler orders we use in ArduPilot
 */
TEST(RotationsTest, TestEulerOrder)
{
    const float roll_deg = 20;
    const float pitch_deg = 31;
    const float yaw_deg = 72;
    float r, p, y;
    Vector3f v;

    Matrix3f m;

    // apply in 321 ordering
    m.identity();
    rotate_ordered(m, "321", roll_deg, pitch_deg, yaw_deg);

    // get using to_euler
    m.to_euler(&r, &p, &y);

    EXPECT_FLOAT_EQ(degrees(r), roll_deg);
    EXPECT_FLOAT_EQ(degrees(p), pitch_deg);
    EXPECT_FLOAT_EQ(degrees(y), yaw_deg);

    // get using to_euler312, should not match
    v = m.to_euler312();

    EXPECT_GE(fabsf(degrees(v.x)-roll_deg), 1);
    EXPECT_GE(fabsf(degrees(v.y)-pitch_deg), 1);
    EXPECT_GE(fabsf(degrees(v.z)-yaw_deg), 1);

    // apply in 312 ordering
    m.identity();
    rotate_ordered(m, "312", roll_deg, pitch_deg, yaw_deg);

    // get using to_euler312
    v = m.to_euler312();

    EXPECT_FLOAT_EQ(degrees(v.x), roll_deg);
    EXPECT_FLOAT_EQ(degrees(v.y), pitch_deg);
    EXPECT_FLOAT_EQ(degrees(v.z), yaw_deg);

    // get using to_euler, should not match
    m.to_euler(&r, &p, &y);

    EXPECT_GE(fabsf(degrees(r)-roll_deg), 1);
    EXPECT_GE(fabsf(degrees(p)-pitch_deg), 1);
    EXPECT_GE(fabsf(degrees(y)-yaw_deg), 1);
}


AP_GTEST_PANIC()
AP_GTEST_MAIN()
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     #include <AP_gtest.h>

#include <AP_Math/AP_Math.h>
#include <AP_Math/vector2.h>
#include <AP_Math/vector3.h>
#include <AP_Math/SCurve.h>

TEST(LinesScurve, test_calculate_path)
{
    // this test doesn't do much...
    float Jm_out, tj_out, t2_out, t4_out, t6_out;
    SCurve::calculate_path(62.8319, 10, 0, 5, 10, 100,
                           Jm_out, tj_out, t2_out, t4_out, t6_out);
    EXPECT_FLOAT_EQ(Jm_out, 10);
    EXPECT_FLOAT_EQ(t2_out, 0.25000018);
    EXPECT_FLOAT_EQ(t4_out, 1.2500002);
    EXPECT_FLOAT_EQ(t6_out, 0.25000018);
}


AP_GTEST_MAIN()
int hal = 0; //weirdly the build will fail without this
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    #include <AP_gtest.h>

#include <AP_Math/vector2.h>

const AP_HAL::HAL& hal = AP_HAL::get_HAL();

#define EXPECT_VECTOR2F_EQ(v1, v2)              \
    do {                                        \
        EXPECT_FLOAT_EQ(v1[0], v2[0]);          \
        EXPECT_FLOAT_EQ(v1[1], v2[1]);          \
    } while (false);

#define TEST_INTERSECT(s1p1x,s1p1y,s1p2x,s1p2y, s2p1x,s2p1y,s2p2x,s2p2y, ix,iy, expected) \
    do {                                                                \
        const Vector2f s1p1(s1p1x,s1p1y);                               \
        const Vector2f s1p2(s1p2x,s1p2y);                               \
        const Vector2f s2p1(s2p1x,s2p1y);                               \
        const Vector2f s2p2(s2p2x,s2p2y);                               \
        Vector2f calculated_intersection;                               \
        bool result = Vector2f::segment_intersection(s1p1, s1p2, s2p1, s2p2, calculated_intersection); \
        EXPECT_EQ(expected, result);                                    \
        if (result == expected && expected) {                           \
            Vector2f expected_intersection{ix, iy};                     \
            EXPECT_VECTOR2F_EQ(calculated_intersection, expected_intersection); \
        }                                                               \
        result = Vector2f::segment_intersection(s2p1, s2p2, s1p1, s1p2, calculated_intersection); \
        EXPECT_EQ(expected, result);                                    \
        if (expected) {                           \
            Vector2f expected_intersection{ix, iy};                     \
            EXPECT_VECTOR2F_EQ(calculated_intersection, expected_intersection); \
            EXPECT_EQ(Vector2f::point_on_segment(calculated_intersection,s1p1, s1p2), true); \
            EXPECT_EQ(Vector2f::point_on_segment(calculated_intersection,s2p1, s2p2), true); \
        }                                                               \
    } while (false);

#define SHOULD_INTERSECT(s1p1x,s1p1y,s1p2x,s1p2y, s2p1x,s2p1y,s2p2x,s2p2y, ix, iy) \
    TEST_INTERSECT(s1p1x,s1p1y,s1p2x,s1p2y, s2p1x,s2p1y,s2p2x,s2p2y, ix, iy, true)

#define SHOULD_NOT_INTERSECT(s1p1x,s1p1y,s1p2x,s1p2y, s2p1x,s2p1y,s2p2x,s2p2y) \
    TEST_INTERSECT(s1p1x,s1p1y,s1p2x,s1p2y, s2p1x,s2p1y,s2p2x,s2p2y, 0, 0, false)

TEST(SegmentIntersectionTests, Simple)
{
    SHOULD_INTERSECT(0,0,2,2, 2,0,0,2, 1,1);
    SHOULD_INTERSECT(0,0,5,5, 2,0,0,2, 1,1);
}
TEST(SegmentIntersectionTests, Parallel)
{
    SHOULD_NOT_INTERSECT(0,0,0,1, 2,0,2,1);
}
// the following should probably intersect but don't:
// TEST(SegmentIntersectionTests, Subsegment)
// {
//     SHOULD_INTERSECT(0,0,0,2, 0,0,0,1, 1,1);
// }
// TEST(SegmentIntersectionTests, Identical)
// {
//     SHOULD_INTERSECT(0,0,0,2, 0,0,0,2, 1,1);
// }
TEST(SegmentIntersectionTests, NonIntersecting)
{
    SHOULD_NOT_INTERSECT(0,0,0,2, 1,1,1,2);
    SHOULD_NOT_INTERSECT(0,0,0,1, -2,2,2,2)
}


AP_GTEST_MAIN()
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           #include <AP_gtest.h>

#include <AP_Math/AP_Math.h>  // FIXME: control.h has include issues...

#include <AP_Math/control.h>

#define EXPECT_VECTOR2F_EQ(v1, v2)              \
    do {                                        \
        EXPECT_FLOAT_EQ(v1[0], v2[0]);          \
        EXPECT_FLOAT_EQ(v1[1], v2[1]);          \
    } while (false);

TEST(control, SqrtController2f)
{
    // a zero-length error gets a zero-length response:
    Vector2f zero;
    EXPECT_VECTOR2F_EQ(zero, sqrt_controller(zero, 17, 18, 0.01));
}

TEST(control, InvSqrtControllerIsActuallyInverse)
{
    // test input - these are the parameters and expected response for
    // a call to sqrt_controller.
    const struct InvSqrtTest {
        float error;
        float p;
        float second_order_limit;
        float dt;
        float expected_sqrt_controller_output;
    } tests[] {
        { 5, 0.1, 1, 0.2, 0.5 },  // simple random number test case
        { -5, 0.1, 1, 0.2, -0.5 },  // negative error should have negavtive response
        { 5, 0.2, 1, 0.2, 1 },  // twice-the-P
        // { 5, 0.1, 1, 0.4, 1 },  // twice-the-dt
        { 0, 0.1, 1, 0.2, 0 },  // zero-error means zero response
        { 0, 0, 0, 0, 0 },  // slightly corner-case-ish....
    };

    // iterate through all tests, calling sqrt_controller, and
    // checking its output.  Take its output and some of the test
    // parameters and ensure that the inverse sqrt controller gives us
    // back the original error.
    for (auto &test : tests) {
        const float sqrt_controller_output = sqrt_controller(
            test.error,
            test.p,
            test.second_order_limit,
            test.dt
        );
        // ensure sqrt controller out put is what we expect
        EXPECT_FLOAT_EQ(sqrt_controller_output, test.expected_sqrt_controller_output);
        // ensure we can invert it back to the initial error
        EXPECT_FLOAT_EQ(test.error, inv_sqrt_controller(
                            sqrt_controller_output,
                            test.p,
                            test.second_order_limit
                            )
        );
    }
}

int hal;

AP_GTEST_MAIN()
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     #include <AP_gtest.h>

#include <AP_Math/AP_Math.h>

const AP_HAL::HAL& hal = AP_HAL::get_HAL();

TEST(Vector2Test, Operator)
{
    Vector2f v_float0{1.0f, 1.0f};
    EXPECT_FALSE(v_float0.is_zero());
    v_float0 = Vector2f();
    EXPECT_TRUE(v_float0.is_zero());
    v_float0[1] = 1.0f;
    EXPECT_FALSE(v_float0.is_zero());
    const float testf1 = v_float0[1];
    EXPECT_TRUE(is_equal(testf1, 1.0f));
    v_float0.zero();
    EXPECT_TRUE(v_float0.is_zero());

    Vector2i v_inti1{1, 1};
    EXPECT_FALSE(v_inti1.is_zero());
    v_inti1 = Vector2i();
    EXPECT_TRUE(v_inti1.is_zero());
    v_inti1[0] = 1;
    EXPECT_FALSE(v_inti1.is_zero());
    const int16_t testi1 = v_inti1[0];
    EXPECT_TRUE(1 == testi1);
    v_inti1.zero();
    EXPECT_TRUE(v_inti1.is_zero());

    Vector2ui v_uinti1{1u, 1u};
    EXPECT_FALSE(v_uinti1.is_zero());
    v_uinti1 = Vector2ui();
    EXPECT_TRUE(v_uinti1.is_zero());
    v_uinti1[0] = 1u;
    EXPECT_FALSE(v_uinti1.is_zero());
    const uint16_t testui1 = v_uinti1[0];
    EXPECT_TRUE(1u == testui1);
    v_uinti1.zero();
    EXPECT_TRUE(v_uinti1.is_zero());

    Vector2l v_intl1{1, 1};
    EXPECT_FALSE(v_intl1.is_zero());
    v_intl1 = Vector2l();
    EXPECT_TRUE(v_intl1.is_zero());
    v_intl1[0] = 1;
    EXPECT_FALSE(v_intl1.is_zero());
    const int32_t testl1 = v_intl1[0];
    EXPECT_TRUE(1 == testl1);
    v_intl1.zero();
    EXPECT_TRUE(v_intl1.is_zero());

    Vector2ul v_uint1l{1, 1};
    EXPECT_FALSE(v_uint1l.is_zero());
    v_uint1l = Vector2ul();
    EXPECT_TRUE(v_uint1l.is_zero());
    v_uint1l[0] = 1;
    EXPECT_FALSE(v_uint1l.is_zero());
    const uint32_t testul1 = v_uint1l[0];
    EXPECT_TRUE(1 == testul1);
    v_uint1l.zero();
    EXPECT_TRUE(v_uint1l.is_zero());

    Vector2f v_float1(1.0f, 1.0f);
    Vector2f v_float2(1.0f, 0.0f);
    EXPECT_FLOAT_EQ(1.0f, v_float1 * v_float2);
    EXPECT_FLOAT_EQ(-1.0f, v_float1 % v_float2);
    v_float1 *= 2.0f;
    EXPECT_TRUE(Vector2f(2.0f, 2.0f) == v_float1);
    v_float1 /= 2.0f;
    EXPECT_TRUE(Vector2f(1.0f, 1.0f) == v_float1);
    v_float1 -= v_float2;
    EXPECT_TRUE(Vector2f(0.0f, 1.0f) == v_float1);
    v_float1 += v_float2;
    EXPECT_TRUE(Vector2f(1.0f, 1.0f) == v_float1);
    EXPECT_TRUE(Vector2f(nanf("0x4152"), 1.0f).is_nan());
    EXPECT_TRUE(Vector2f(1.0f / 0.0f, 1.0f).is_inf());
    EXPECT_TRUE(Vector2f(2.0f, 2.0f) / 2.0f == v_float1);
    EXPECT_TRUE(Vector2f(2.0f, 2.0f) == v_float1 * 2.0f);
    EXPECT_TRUE(Vector2f(2.0f, 2.0f) - v_float1 == v_float1);
    EXPECT_TRUE(Vector2f(2.0f, 2.0f) == v_float1 + v_float1);
    EXPECT_TRUE(Vector2f(-1.0f, -1.0f) == -v_float1);
    v_float1.zero();
    EXPECT_TRUE(v_float1.is_zero());
}

TEST(Vector2Test, IsEqual)
{
    Vector2l v_int1(1, 1);
    Vector2l v_int2(1, 0);
    Vector2<long> v_long1(1, 1);
    Vector2<long> v_long2(1, 0);
    Vector2f v_float1(1.0f, 1.0f);
    Vector2f v_float2(1.0f, 0.0f);

    EXPECT_FALSE(v_int1 == v_int2);
    EXPECT_TRUE(v_int1 == v_int1);
    EXPECT_TRUE(v_int1 != v_int2);
    EXPECT_FALSE(v_int1 != v_int1);
    EXPECT_FALSE(v_long1 == v_long2);
    EXPECT_TRUE(v_long1 == v_long1);
    EXPECT_TRUE(v_long1 != v_long2);
    EXPECT_FALSE(v_long1 != v_long1);
    EXPECT_FALSE(v_float1 == v_float2);
    EXPECT_TRUE(v_float1 == v_float1);
    EXPECT_TRUE(v_float1 != v_float2);
    EXPECT_FALSE(v_float1 != v_float1);
}

TEST(Vector2Test, angle)
{
    EXPECT_FLOAT_EQ(M_PI/2, Vector2f(0, 1).angle());
    EXPECT_FLOAT_EQ(M_PI/4, Vector2f(1, 1).angle());
    EXPECT_TRUE(is_zero(Vector2d(1, 0).angle()));
    EXPECT_FLOAT_EQ(M_PI*5/4, Vector2f(-1, -1).angle());
    EXPECT_FLOAT_EQ(M_PI*5/4, Vector2f(-5, -5).angle());

    EXPECT_FLOAT_EQ(M_PI/2, Vector2f(0.0f, 1.0f).angle(Vector2f(1.0f, 0.0f)));
    EXPECT_FLOAT_EQ(0.0f, Vector2f(0.5f, 0.5f).angle(Vector2f(0.5f, 0.5f)));
    EXPECT_FLOAT_EQ(M_PI, Vector2f(0.5f, -0.5f).angle(Vector2f(-0.5f, 0.5f)));

    EXPECT_FLOAT_EQ(0.0f, Vector2f(-0.0f, 0).angle(Vector2f(0.0f, 1.0f)));
}

TEST(Vector2Test, length)
{
    EXPECT_FLOAT_EQ(25, Vector2f(3, 4).length_squared());
    Vector2f v_float1(1.0f, 1.0f);
    EXPECT_TRUE(v_float1.limit_length(1.0f));
    EXPECT_FALSE(Vector2f(-0.0f, 0.0f).limit_length(1.0f));
}

TEST(Vector2Test, normalized)
{
    Vector2f v_float1(3.0f, 3.0f);
    v_float1.normalize();
    EXPECT_EQ(Vector2f(3.0f, 3.0f).normalized(), v_float1);
    EXPECT_EQ(Vector2f(sqrtf(2)/2, sqrtf(2)/2), Vector2f(5, 5).normalized());
    EXPECT_EQ(Vector2f(3, 3).normalized(), Vector2f(5, 5).normalized());
    EXPECT_EQ(Vector2f(-3, 3).normalized(), Vector2f(-5, 5).normalized());
    EXPECT_NE(Vector2f(-3, 3).normalized(), Vector2f(5, 5).normalized());
}

TEST(Vector2Test, Project)
{
    Vector2f v_float1(1.0f, 1.0f);
    Vector2f v_float2(2.0f, 1.0f);
    v_float1.project(v_float2);
    EXPECT_EQ(Vector2f(1.0f, 1.0f).projected(v_float2), v_float1);
}

TEST(Vector2Test, reflect)
{
    Vector2f reflected1 = Vector2f(3, 8);
    reflected1.reflect(Vector2f(0, 1));
    EXPECT_EQ(reflected1, Vector2f(-3, 8));

    // colinear vectors
    Vector2f reflected2 = Vector2f(3, 3);
    reflected2.reflect(Vector2f(1, 1));
    EXPECT_EQ(reflected2, Vector2f(3, 3));

    // orthogonal vectors
    Vector2f reflected3 = Vector2f(3, 3);
    reflected3.reflect(Vector2f(1, -1));
    EXPECT_EQ(reflected3, Vector2f(-3, -3));

    // rotation
    Vector2f base = Vector2f(2, 1);
    base.rotate(radians(90));
    EXPECT_FLOAT_EQ(base.x, -1);
    EXPECT_FLOAT_EQ(base.y, 2);
}

TEST(Vector2Test, Offset_bearing)
{
    Vector2f v_float1(1.0f, 0.0f);
    v_float1.offset_bearing(0.0f, 1.0f);
    EXPECT_EQ(Vector2f(2.0f, 0.0f), v_float1);
}

TEST(Vector2Test, Perpendicular)
{
    Vector2f v_float1(1.0f, 1.0f);
    EXPECT_EQ(Vector2f(0.0f, 2.0f), v_float1.perpendicular(v_float1, Vector2f(2.0f, 0.0f)));
    EXPECT_EQ(Vector2f(2.0f, 0.0f), v_float1.perpendicular(v_float1, Vector2f(0.0f, 2.0f)));
}

TEST(Vector2Test, closest_point)
{
    // closest_point is (p, v,w)

    // the silly case:
    EXPECT_EQ((Vector2f{0, 0}),
              (Vector2f::closest_point(Vector2f{0, 0}, Vector2f{0, 0}, Vector2f{0, 0})));
    // on line:
    EXPECT_EQ((Vector2f{0, 0}),
              (Vector2f::closest_point(Vector2f{0, 0}, Vector2f{0, 0}, Vector2f{1, 1})));
    EXPECT_EQ((Vector2f{5, 5}),
              (Vector2f::closest_point(Vector2f{5, 5}, Vector2f{0, 0}, Vector2f{5, 5})));
    // on line but not segment:
    EXPECT_EQ((Vector2f{5, 5}),
              (Vector2f::closest_point(Vector2f{6, 6}, Vector2f{0, 0}, Vector2f{5, 5})));

    EXPECT_EQ((Vector2f{0.5, 0.5}),
              (Vector2f::closest_point(Vector2f{1,0}, Vector2f{0, 0}, Vector2f{5, 5})));
    EXPECT_EQ((Vector2f{0, 1}),
              (Vector2f::closest_point(Vector2f{0,0}, Vector2f{-1, 1}, Vector2f{1, 1})));

    // to (0,w)
    // the silly case:
    EXPECT_EQ((Vector2f{0, 0}),
            (Vector2f::closest_point(Vector2f{0, 0}, Vector2f{0, 0})));
    // on line:
    EXPECT_EQ((Vector2f{0, 0}),
            (Vector2f::closest_point(Vector2f{0, 0}, Vector2f{1, 1})));
    EXPECT_EQ((Vector2f{5, 5}),
            (Vector2f::closest_point(Vector2f{5, 5}, Vector2f{5, 5})));
    // on line but not segment:
    EXPECT_EQ((Vector2f{5, 5}),
            (Vector2f::closest_point(Vector2f{6, 6}, Vector2f{5, 5})));

    EXPECT_EQ((Vector2f{0.5, 0.5}),
            (Vector2f::closest_point(Vector2f{1,0}, Vector2f{5, 5})));
    EXPECT_EQ((Vector2f{0, 0}),
            (Vector2f::closest_point(Vector2f{0,0}, Vector2f{1, 1})));
}

TEST(Vector2Test, closest_distance)
{
    EXPECT_FLOAT_EQ(1.0f, Vector2f::closest_distance_between_line_and_point_squared(Vector2f{0,0}, Vector2f{1, 0}, Vector2f{0, 1}));
    EXPECT_FLOAT_EQ(1.0f, Vector2f::closest_distance_between_line_and_point(Vector2f{0,0}, Vector2f{1, 0}, Vector2f{0, 1}));
    EXPECT_FLOAT_EQ(1.0f, Vector2f::closest_distance_between_lines_squared(Vector2f{0,0}, Vector2f{1, 0}, Vector2f{0, 1}, Vector2f{1, 1}));
    EXPECT_FLOAT_EQ(1.0f, Vector2f::closest_distance_between_radial_and_point_squared(Vector2f{0, 1}, Vector2f{1, 1}));
    EXPECT_FLOAT_EQ(1.0f, Vector2f::closest_distance_between_radial_and_point(Vector2f{0, 1}, Vector2f{1, 1}));
}

TEST(Vector2Test, segment_intersectionx)
{
    Vector2f intersection;
    EXPECT_EQ(Vector2f::segment_intersection(
            Vector2f{-1.0f, 0.0f}, // seg start
            Vector2f{1.0f, 0.0f}, // seg end
            Vector2f{0.0f, -1.0f}, // seg start
            Vector2f{0.0f, 1.0f}, // seg end
            intersection         // return value for intersection point
    ), true);
    EXPECT_EQ(intersection, Vector2f(0.0f, 0.0f));
    EXPECT_EQ(Vector2f::segment_intersection(
            Vector2f{1.0f, 0.0f}, // seg start
            Vector2f{2.0f, 0.0f}, // seg end
            Vector2f{0.0f, -1.0f}, // seg start
            Vector2f{0.0f, 1.0f}, // seg end
            intersection         // return value for intersection point
    ), false);
    EXPECT_EQ(Vector2f::segment_intersection(
            Vector2f{1.0f, 0.0f}, // seg start
            Vector2f{2.0f, 0.0f}, // seg end
            Vector2f{1.0f, 1.0f}, // seg start
            Vector2f{2.0f, 1.0f}, // seg end
            intersection         // return value for intersection point
    ), false);
}

TEST(Vector2Test, circle_segment_intersectionx)
{
    Vector2f intersection;
    EXPECT_EQ(Vector2f::circle_segment_intersection(
                  Vector2f{0,0}, // seg start
                  Vector2f{1,1}, // seg end
                  Vector2f{0,0}, // circle center
                  0.5,                 // circle radius
                  intersection         // return value for intersection point
                  ), true);
    EXPECT_EQ(intersection, Vector2f(sqrtf(0.5)/2,sqrtf(0.5)/2));

    EXPECT_EQ(Vector2f::circle_segment_intersection(
                  Vector2f{std::numeric_limits<float>::quiet_NaN(),
                          std::numeric_limits<float>::quiet_NaN()}, // seg start
                  Vector2f{1,1}, // seg end
                  Vector2f{0,0}, // circle center
                  0.5,                 // circle radius
                  intersection         // return value for intersection point
                  ), false);

}

TEST(Vector2Test, point_on_segmentx)
{
    EXPECT_EQ(Vector2f::point_on_segment(
            Vector2f{0.0f, 1.0f}, // point
            Vector2f{0.0f, 0.0f}, // seg start
            Vector2f{0.0f, 2.0f} // seg end
    ), true);
    EXPECT_EQ(Vector2f::point_on_segment(
            Vector2f{1.0f, 1.0f}, // point
            Vector2f{0.0f, 0.0f}, // seg start
            Vector2f{0.0f, 2.0f} // seg end
    ), false);
    EXPECT_EQ(Vector2f::point_on_segment(
            Vector2f{1.0f, 1.0f}, // point
            Vector2f{0.0f, 0.0f}, // seg start
            Vector2f{3.0f, 1.0f} // seg end
    ), false);
    printf("4\n");
    EXPECT_EQ(Vector2f::point_on_segment(
            Vector2f{1.0f, 0.0f}, // point
            Vector2f{2.0f, 1.0f}, // seg start
            Vector2f{3.0f, 2.0f} // seg end
    ), false);
    EXPECT_EQ(Vector2f::point_on_segment(
            Vector2f{5.0f, 0.0f}, // point
            Vector2f{4.0f, 1.0f}, // seg start
            Vector2f{3.0f, 2.0f} // seg end
    ), false);
    EXPECT_EQ(Vector2f::point_on_segment(
            Vector2f{3.0f, 0.0f}, // point
            Vector2f{3.0f, 1.0f}, // seg start
            Vector2f{3.0f, 2.0f} // seg end
    ), false);
    EXPECT_EQ(Vector2f::point_on_segment(
            Vector2f{3.0f, 0.0f}, // point
            Vector2f{3.0f, 2.0f}, // seg start
            Vector2f{3.0f, 1.0f} // seg end
    ), false);

}

AP_GTEST_MAIN()
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      #include <AP_gtest.h>
#include <AP_Math/AP_Math.h>

const AP_HAL::HAL& hal = AP_HAL::get_HAL();

TEST(Vector3Test, Operator)
{
    Vector3f v_float0{1.0f, 1.0f,1.0f};
    EXPECT_FALSE(v_float0.is_zero());
    v_float0 = Vector3f();
    EXPECT_TRUE(v_float0.is_zero());
    v_float0[1] = 1.0f;
    EXPECT_FALSE(v_float0.is_zero());
    const float testf1 = v_float0[1];
    EXPECT_TRUE(is_equal(testf1, 1.0f));
    v_float0.zero();
    EXPECT_TRUE(v_float0.is_zero());

    Vector3i v_inti1{1, 1, 1};
    EXPECT_FALSE(v_inti1.is_zero());
    v_inti1 = Vector3i();
    EXPECT_TRUE(v_inti1.is_zero());
    v_inti1[0] = 1;
    EXPECT_FALSE(v_inti1.is_zero());
    const int16_t testi1 = v_inti1[0];
    EXPECT_TRUE(1 == testi1);
    v_inti1.zero();
    EXPECT_TRUE(v_inti1.is_zero());

    Vector3ui v_uinti1{1u, 1u, 1u};
    EXPECT_FALSE(v_uinti1.is_zero());
    v_uinti1 = Vector3ui();
    EXPECT_TRUE(v_uinti1.is_zero());
    v_uinti1[0] = 1u;
    EXPECT_FALSE(v_uinti1.is_zero());
    const uint16_t testui1 = v_uinti1[0];
    EXPECT_TRUE(1u == testui1);
    v_uinti1.zero();
    EXPECT_TRUE(v_uinti1.is_zero());

    Vector3l v_intl1{1, 1, 1};
    EXPECT_FALSE(v_intl1.is_zero());
    v_intl1 = Vector3l();
    EXPECT_TRUE(v_intl1.is_zero());
    v_intl1[0] = 1;
    EXPECT_FALSE(v_intl1.is_zero());
    const int32_t testl1 = v_intl1[0];
    EXPECT_TRUE(1 == testl1);
    v_intl1.zero();
    EXPECT_TRUE(v_intl1.is_zero());

    Vector3ul v_uint1l{1, 1, 1};
    EXPECT_FALSE(v_uint1l.is_zero());
    v_uint1l = Vector3ul();
    EXPECT_TRUE(v_uint1l.is_zero());
    v_uint1l[0] = 1;
    EXPECT_FALSE(v_uint1l.is_zero());
    const uint32_t testul1 = v_uint1l[0];
    EXPECT_TRUE(1 == testul1);
    v_uint1l.zero();
    EXPECT_TRUE(v_uint1l.is_zero());

    Vector3f v_float1(1.0f, 1.0f, 1.0f);
    Vector3f v_float2(1.0f, 1.0f, 0.0f);
    EXPECT_FLOAT_EQ(2.0f, v_float1 * v_float2);
    EXPECT_TRUE(Vector3f(-1.0f, 1.0f, 0.0f) == v_float1 % v_float2);
    v_float1 *= 2.0f;
    EXPECT_TRUE(Vector3f(2.0f, 2.0f, 2.0f) == v_float1);
    v_float1 /= 2.0f;
    EXPECT_TRUE(Vector3f(1.0f, 1.0f, 1.0f) == v_float1);
    v_float1 -= v_float2;
    EXPECT_TRUE(Vector3f(0.0f, 0.0f, 1.0f) == v_float1);
    v_float1 += v_float2;
    EXPECT_TRUE(Vector3f(1.0f, 1.0f, 1.0f) == v_float1);
    EXPECT_TRUE(Vector3f(nanf("0x4152"), 1.0f, 1.0f).is_nan());
    EXPECT_TRUE(Vector3f(1.0f / 0.0f, 1.0f, 1.0f).is_inf());
    EXPECT_TRUE(Vector3f(2.0f, 2.0f, 2.0f) / 2.0f == v_float1);
    EXPECT_TRUE(Vector3f(2.0f, 2.0f, 2.0f) == v_float1 * 2.0f);
    EXPECT_TRUE(Vector3f(2.0f, 2.0f, 2.0f) - v_float1 == v_float1);
    EXPECT_TRUE(Vector3f(2.0f, 2.0f, 2.0f) == v_float1 + v_float1);
    EXPECT_TRUE(Vector3f(-1.0f, -1.0f, -1.0f) == -v_float1);
    v_float1.zero();
    EXPECT_TRUE(v_float1.is_zero());
}

TEST(Vector3Test, OperatorDouble)
{
    Vector3d v_double0{1.0, 1.0,1.0};
    EXPECT_FALSE(v_double0.is_zero());
    v_double0 = Vector3d();
    EXPECT_TRUE(v_double0.is_zero());
    v_double0[1] = 1.0;
    EXPECT_FALSE(v_double0.is_zero());
    const double testf1 = v_double0[1];
    EXPECT_TRUE(is_equal(testf1, 1.0));
    v_double0.zero();
    EXPECT_TRUE(v_double0.is_zero());

    Vector3d v_double1(1.0, 1.0, 1.0);
    Vector3d v_double2(1.0, 1.0, 0.0);
    EXPECT_FLOAT_EQ(2.0, v_double1 * v_double2);
    EXPECT_TRUE(Vector3d(-1.0, 1.0, 0.0) == v_double1 % v_double2);
    v_double1 *= 2.0;
    EXPECT_TRUE(Vector3d(2.0, 2.0, 2.0) == v_double1);
    v_double1 /= 2.0;
    EXPECT_TRUE(Vector3d(1.0, 1.0, 1.0) == v_double1);
    v_double1 -= v_double2;
    EXPECT_TRUE(Vector3d(0.0, 0.0, 1.0) == v_double1);
    v_double1 += v_double2;
    EXPECT_TRUE(Vector3d(1.0, 1.0, 1.0) == v_double1);
    EXPECT_TRUE(Vector3d(nan("0x4152"), 1.0, 1.0).is_nan());
    EXPECT_TRUE(Vector3d(1.0 / 0.0, 1.0, 1.0).is_inf());
    EXPECT_TRUE(Vector3d(2.0, 2.0, 2.0) / 2.0 == v_double1);
    EXPECT_TRUE(Vector3d(2.0, 2.0, 2.0) == v_double1 * 2.0);
    EXPECT_TRUE(Vector3d(2.0, 2.0, 2.0) - v_double1 == v_double1);
    EXPECT_TRUE(Vector3d(2.0, 2.0, 2.0) == v_double1 + v_double1);
    EXPECT_TRUE(Vector3d(-1.0, -1.0, -1.0) == -v_double1);
    v_double1.zero();
    EXPECT_TRUE(v_double1.is_zero());
}

TEST(Vector3Test, IsEqual)
{
    Vector3f v_float1(1.0f, 1.0f, 1.0f);
    Vector3f v_float2(1.0f, 1.0f, 0.0f);

    EXPECT_FALSE(v_float1 == v_float2);
    EXPECT_TRUE(v_float1 == v_float1);
    EXPECT_TRUE(v_float1 != v_float2);
    EXPECT_FALSE(v_float1 != v_float1);

    Vector3d v_double1(1.0, 1.0, 1.0);
    Vector3d v_double2(1.0, 1.0, 0.0);

    EXPECT_FALSE(v_double1 == v_double2);
    EXPECT_TRUE(v_double1 == v_double1);
    EXPECT_TRUE(v_double1 != v_double2);
    EXPECT_FALSE(v_double1 != v_double1);
}
/*
TEST(Vector3Test, angle)
{
    EXPECT_FLOAT_EQ(M_PI/2, Vector3f(0.0f, 1.0f).angle(Vector3f(1.0f, 0.0f)));
    EXPECT_FLOAT_EQ(0.0f, Vector3f(0.5f, 0.5f).angle(Vector3f(0.5f, 0.5f)));
    EXPECT_FLOAT_EQ(M_PI, Vector3f(0.5f, -0.5f).angle(Vector3f(-0.5f, 0.5f)));

    EXPECT_FLOAT_EQ(0.0f, Vector3f(-0.0f, 0).angle(Vector3f(0.0f, 1.0f)));
}
*/
TEST(Vector3Test, length)
{
    EXPECT_FLOAT_EQ(12, Vector3f(2, 2, 2).length_squared());
    EXPECT_FLOAT_EQ(sqrtf(12), Vector3f(2, 2, 2).length());
    Vector3f v_float1(1.0f, 1.0f, 1.0f);
    EXPECT_TRUE(v_float1.limit_length_xy(1.0f));
    EXPECT_FALSE(Vector3f(-0.0f, -0.0f, -0.0f).limit_length_xy(1.0f));

    EXPECT_DOUBLE_EQ(12, Vector3d(2, 2, 2).length_squared());
    EXPECT_FLOAT_EQ(sqrt(12), Vector3d(2, 2, 2).length());
    Vector3d v_double1(1.0, 1.0, 1.0);
    EXPECT_TRUE(v_double1.limit_length_xy(1.0));
    EXPECT_FALSE(Vector3d(-0.0, -0.0, -0.0).limit_length_xy(1.0));
}

TEST(Vector3Test, normalized)
{
    Vector3f v_float1(3.0f, 3.0f, 3.0f);
    v_float1.normalize();
    EXPECT_EQ(Vector3f(3.0f, 3.0f, 3.0f).normalized(), v_float1);
    EXPECT_EQ(Vector3f(1 / sqrtf(3), 1 / sqrtf(3), 1 / sqrtf(3)), Vector3f(2, 2, 2).normalized());
    EXPECT_EQ(Vector3f(3, 3, 3).normalized(), Vector3f(5, 5, 5).normalized());
    EXPECT_EQ(Vector3f(-3, 3, 3).normalized(), Vector3f(-5, 5, 5).normalized());
    EXPECT_NE(Vector3f(-3, 3, 3).normalized(), Vector3f(5, 5, 5).normalized());
}
/*
TEST(Vector3Test, Project)
{
    Vector3f v_float1(1.0f, 1.0f, 1.0f);
    Vector3f v_float2(2.0f, 2.0f, 1.0f);
    v_float1.project(v_float2);
    EXPECT_EQ(Vector3f(1.0f, 1.0f, 1.0f).projected(v_float2), v_float1);
}

TEST(Vector3Test, reflect)
{
    Vector3f reflected1 = Vector3f(3, 3, 8);
    reflected1.reflect(Vector3f(0, 0, 1));
    EXPECT_EQ(reflected1, Vector3f(-3, -3, 8));

    // colinear vectors
    Vector3f reflected2 = Vector3f(3, 3, 3);
    reflected2.reflect(Vector3f(1, 1, 1));
    EXPECT_EQ(reflected2, Vector3f(3, 3, 3));

    // orthogonal vectors
    Vector3f reflected3 = Vector3f(3, 3, 3);
    reflected3.reflect(Vector3f(1, 1, -1));
    EXPECT_EQ(reflected3, Vector3f(-3, -3, -3));

    // rotation
    Vector3f base = Vector3f(2, 2, 1);
    base.rotate(radians(90));
    EXPECT_FLOAT_EQ(base.x, -1);
    EXPECT_FLOAT_EQ(base.y, 2);
    EXPECT_FLOAT_EQ(base.z, 2);
}

TEST(Vector3Test, Offset_bearing)
{
    Vector3f v_float1(1.0f, 0.0f);
    v_float1.offset_bearing(0.0f, 1.0f);
    EXPECT_EQ(Vector3f(2.0f, 0.0f), v_float1);
}

TEST(Vector3Test, Perpendicular)
{
    Vector3f v_float1(1.0f, 1.0f);
    EXPECT_EQ(Vector3f(0.0f, 2.0f), v_float1.perpendicular(v_float1, Vector3f(2.0f, 0.0f)));
    EXPECT_EQ(Vector3f(2.0f, 0.0f), v_float1.perpendicular(v_float1, Vector3f(0.0f, 2.0f)));
}

TEST(Vector3Test, closest_point)
{
    // closest_point is (p, v,w)

    // the silly case:
    EXPECT_EQ((Vector3f{0, 0}),
            (Vector3f::closest_point(Vector3f{0, 0}, Vector3f{0, 0}, Vector3f{0, 0})));
    // on line:
    EXPECT_EQ((Vector3f{0, 0}),
            (Vector3f::closest_point(Vector3f{0, 0}, Vector3f{0, 0}, Vector3f{1, 1})));
    EXPECT_EQ((Vector3f{5, 5}),
            (Vector3f::closest_point(Vector3f{5, 5}, Vector3f{0, 0}, Vector3f{5, 5})));
    // on line but not segment:
    EXPECT_EQ((Vector3f{5, 5}),
            (Vector3f::closest_point(Vector3f{6, 6}, Vector3f{0, 0}, Vector3f{5, 5})));

    EXPECT_EQ((Vector3f{0.5, 0.5}),
            (Vector3f::closest_point(Vector3f{1,0}, Vector3f{0, 0}, Vector3f{5, 5})));
    EXPECT_EQ((Vector3f{0, 1}),
            (Vector3f::closest_point(Vector3f{0,0}, Vector3f{-1, 1}, Vector3f{1, 1})));

    // to (0,w)
    // the silly case:
    EXPECT_EQ((Vector3f{0, 0}),
            (Vector3f::closest_point(Vector3f{0, 0}, Vector3f{0, 0})));
    // on line:
    EXPECT_EQ((Vector3f{0, 0}),
            (Vector3f::closest_point(Vector3f{0, 0}, Vector3f{1, 1})));
    EXPECT_EQ((Vector3f{5, 5}),
            (Vector3f::closest_point(Vector3f{5, 5}, Vector3f{5, 5})));
    // on line but not segment:
    EXPECT_EQ((Vector3f{5, 5}),
            (Vector3f::closest_point(Vector3f{6, 6}, Vector3f{5, 5})));

    EXPECT_EQ((Vector3f{0.5, 0.5}),
            (Vector3f::closest_point(Vector3f{1,0}, Vector3f{5, 5})));
    EXPECT_EQ((Vector3f{0, 0}),
            (Vector3f::closest_point(Vector3f{0,0}, Vector3f{1, 1})));
}

TEST(Vector3Test, closest_distance)
{
    EXPECT_FLOAT_EQ(1.0f, Vector3f::closest_distance_between_line_and_point_squared(Vector3f{0,0}, Vector3f{1, 0}, Vector3f{0, 1}));
    EXPECT_FLOAT_EQ(1.0f, Vector3f::closest_distance_between_line_and_point(Vector3f{0,0}, Vector3f{1, 0}, Vector3f{0, 1}));
    EXPECT_FLOAT_EQ(1.0f, Vector3f::closest_distance_between_lines_squared(Vector3f{0,0}, Vector3f{1, 0}, Vector3f{0, 1}, Vector3f{1, 1}));
    EXPECT_FLOAT_EQ(1.0f, Vector3f::closest_distance_between_radial_and_point_squared(Vector3f{0, 1}, Vector3f{1, 1}));
    EXPECT_FLOAT_EQ(1.0f, Vector3f::closest_distance_between_radial_and_point(Vector3f{0, 1}, Vector3f{1, 1}));
}

TEST(Vector3Test, segment_intersectionx)
{
    Vector3f intersection;
    EXPECT_EQ(Vector3f::segment_intersection(
            Vector3f{-1.0f, 0.0f}, // seg start
            Vector3f{1.0f, 0.0f}, // seg end
            Vector3f{0.0f, -1.0f}, // seg start
            Vector3f{0.0f, 1.0f}, // seg end
            intersection         // return value for intersection point
    ), true);
    EXPECT_EQ(intersection, Vector3f(0.0f, 0.0f));
    EXPECT_EQ(Vector3f::segment_intersection(
            Vector3f{1.0f, 0.0f}, // seg start
            Vector3f{2.0f, 0.0f}, // seg end
            Vector3f{0.0f, -1.0f}, // seg start
            Vector3f{0.0f, 1.0f}, // seg end
            intersection         // return value for intersection point
    ), false);
    EXPECT_EQ(Vector3f::segment_intersection(
            Vector3f{1.0f, 0.0f}, // seg start
            Vector3f{2.0f, 0.0f}, // seg end
            Vector3f{1.0f, 1.0f}, // seg start
            Vector3f{2.0f, 1.0f}, // seg end
            intersection         // return value for intersection point
    ), false);
}

TEST(Vector3Test, circle_segment_intersectionx)
{
    Vector3f intersection;
    EXPECT_EQ(Vector3f::circle_segment_intersection(
            Vector3f{0,0}, // seg start
            Vector3f{1,1}, // seg end
            Vector3f{0,0}, // circle center
            0.5,                 // circle radius
            intersection         // return value for intersection point
    ), true);
    EXPECT_EQ(intersection, Vector3f(sqrtf(0.5)/2,sqrtf(0.5)/2));

    EXPECT_EQ(Vector3f::circle_segment_intersection(
            Vector3f{std::numeric_limits<float>::quiet_NaN(),
                     std::numeric_limits<float>::quiet_NaN()}, // seg start
            Vector3f{1,1}, // seg end
            Vector3f{0,0}, // circle center
            0.5,                 // circle radius
            intersection         // return value for intersection point
    ), false);

}

TEST(Vector3Test, point_on_segmentx)
{
    EXPECT_EQ(Vector3f::point_on_segment(
            Vector3f{0.0f, 1.0f}, // point
            Vector3f{0.0f, 0.0f}, // seg start
            Vector3f{0.0f, 2.0f} // seg end
    ), true);
    EXPECT_EQ(Vector3f::point_on_segment(
            Vector3f{1.0f, 1.0f}, // point
            Vector3f{0.0f, 0.0f}, // seg start
            Vector3f{0.0f, 2.0f} // seg end
    ), false);
    EXPECT_EQ(Vector3f::point_on_segment(
            Vector3f{1.0f, 1.0f}, // point
            Vector3f{0.0f, 0.0f}, // seg start
            Vector3f{3.0f, 1.0f} // seg end
    ), false);
    printf("4\n");
    EXPECT_EQ(Vector3f::point_on_segment(
            Vector3f{1.0f, 0.0f}, // point
            Vector3f{2.0f, 1.0f}, // seg start
            Vector3f{3.0f, 2.0f} // seg end
    ), false);
    EXPECT_EQ(Vector3f::point_on_segment(
            Vector3f{5.0f, 0.0f}, // point
            Vector3f{4.0f, 1.0f}, // seg start
            Vector3f{3.0f, 2.0f} // seg end
    ), false);
    EXPECT_EQ(Vector3f::point_on_segment(
            Vector3f{3.0f, 0.0f}, // point
            Vector3f{3.0f, 1.0f}, // seg start
            Vector3f{3.0f, 2.0f} // seg end
    ), false);
    EXPECT_EQ(Vector3f::point_on_segment(
            Vector3f{3.0f, 0.0f}, // point
            Vector3f{3.0f, 2.0f}, // seg start
            Vector3f{3.0f, 1.0f} // seg end
    ), false);

}
*/
AP_GTEST_MAIN()
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             #!/usr/bin/env python
# encoding: utf-8

def build(bld):
    bld.ap_find_tests(
        use='ap',
        DOUBLE_PRECISION_SOURCES = ['test_math_double.cpp', 'test_vector3.cpp']
    )
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        # Geodesic Grid Tool #

This folder a toolset for helping understanding the concepts used by
[`AP_GeodesicGrid`](../../AP_GeodesicGrid.cpp) as well as for aiding its
development. The main script is named `geodesic_grid.py`. Use `geodesic_grid.py
--help` to know how to use it.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           #!/usr/bin/env python

# Copyright (C) 2016  Intel Corporation. All rights reserved.
#
# This file is free software: you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This file is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program.  If not, see <http://www.gnu.org/licenses/>.
from __future__ import print_function
import argparse
import numpy as np
import sys

import icosahedron as ico
import grid

def print_code_gen_notice():
    print("/* This was generated with")
    print(" * libraries/AP_Math/tools/geodesic_grid/geodesic_grid.py */")

def header_neighbor_umbrella(index):
    t = ico.triangles[0]
    a, b, c = t

    triangle, edge = (
        ( t, ( a,  b)),
        ( t, ( b,  c)),
        ( t, ( c,  a)),
        (-t, (-a, -b)),
        (-t, (-b, -c)),
        (-t, (-c, -a)),
    )[index]

    return ico.neighbor_umbrella(triangle, edge), edge

parser = argparse.ArgumentParser(
    description="""
Utility script for helping to understand concepts used by AP_GeodesicGrid as
well as for aiding its development.

When passing a vertex as argument to one of the options, the valid values for
the coordinates are 0, -1, 1, g and -g, where g is the golden ratio.
""",
)

parser.add_argument(
    '-p', '--plot',
    action='store_true',
    help="""
Plot results when applicable.
""",
)

parser.add_argument(
    '-b', '--plot-subtriangles',
    action='store_true',
    help="""
Plot subtriangles as well. This implies -p.
""",
)

parser.add_argument(
    '--icosahedron',
    action='store_true',
    help='Get the icosahedron triangles.',
)

parser.add_argument(
    '-t', '--triangle',
    action='append',
    type=int,
    nargs='+',
    metavar='INDEX',
    help="""
Get the icosahedron triangle at INDEX.
""",
)

parser.add_argument(
    '-s', '--section',
    action='append',
    type=int,
    nargs='+',
    help="""
Get the grid section SECTION. If --plot is passed, then --plot-subtriangles is
implied.
""",
)

parser.add_argument(
    '-u', '--umbrella',
    action='append',
    nargs=3,
    metavar=('X', 'Y', 'Z'),
    help="""
Get the umbrella with pivot denoted by (X, Y, Z). The pivot must be one of the
icosahedron's vertices.
""",
)

parser.add_argument(
    '-n', '--neighbor-umbrella',
    action='append',
    nargs='+',
    metavar='INDEX',
    help="""
Get the neighbor umbrella at INDEX as described by _neighbor_umbrellas in
AP_GeodesicGrid.h. The special value "all" for INDEX is also accepted, which
will make it ignore other indexes passed and get all neighbor umbrellas for
that member.
""",
)

parser.add_argument(
    '--neighbor-umbrella-gen',
    action='store_true',
    help="""
Generate C++ code for the initialization of the member _neighbor_umbrellas
described in AP_GeodesicGrid.h.
""",
)

parser.add_argument(
    '--inverses-gen',
    action='store_true',
    help="""
Generate C++ code for the initialization of members _inverses and _mid_inverses
declared in AP_GeodesicGrid.h.
""")


args = parser.parse_args()

if args.plot_subtriangles:
    args.plot = True

if args.plot:
    import plot

polygons_to_plot = []

if args.triangle:
    indexes = []
    for l in args.triangle:
        indexes += l

    for i in indexes:
        if 0 > i or i >= len(ico.triangles):
            print(
                'Triangle index must be in the range [0,%d)' % len(ico.triangles),
                file=sys.stderr,
            )
            sys.exit(1)

        print(ico.triangles[i])
        if args.plot:
            plot.polygon(ico.triangles[i])

if args.section:
    sections = []
    for l in args.section:
        sections += l

    for s in sections:
        if 0 > s or s >= 4 * len(ico.triangles):
            print(
                'Section must be in the range [0,%d)' % 4 * len(ico.triangles),
                file=sys.stderr,
            )
            sys.exit(1)
        print(grid.section_triangle(s))
    if args.plot:
        args.plot_subtriangles = True
        plot.sections(sections)

if args.umbrella:
    for pivot in args.umbrella:
        for i, x in enumerate(pivot):
            if x == 'g':
                x = ico.g
            elif x == '-g':
                x = -ico.g
            else:
                try:
                    x = int(x)
                    if x not in (0, -1, 1):
                        raise ValueError()
                except ValueError:
                    print(
                        'umbrella: invalid pivot coordinate: %s' % str(x),
                        file=sys.stderr,
                    )
                    sys.exit(1)
            pivot[i] = x

        pivot = ico.Vertex(*pivot)
        if pivot not in ico.vertices:
            print(
                'umbrella: invalid pivot:', pivot,
                file=sys.stderr,
            )
            sys.exit(1)
        u = ico.umbrella(pivot)

        print("Components of the umbrella of %s:" % str(pivot))
        for c in u.components:
            print("    %s" % str(c))

        if args.plot:
            plot.polygons(u.components)

if args.neighbor_umbrella:
    indexes = []
    for l in args.neighbor_umbrella:
        indexes += l

    if 'all' in indexes:
        indexes = range(6)
    else:
        for i, arg in enumerate(indexes):
            try:
                arg = int(arg)
                if arg not in range(6):
                    raise ValueError()
            except ValueError:
                print(
                    'neighbor_umbrella: invalid index %s' % str(arg),
                    file=sys.stderr,
                )
                sys.exit(1)
            indexes[i] = arg

    for i in indexes:
        u, order_edge = header_neighbor_umbrella(i)
        print("Header umbrella %d:" % i)
        print("    Pivot:", u.pivot)
        for i in range(5):
            print("    Vertex %d:" % i, u.vertex(i, order_edge))
        for i in range(5):
            print("    Component %d:" % i, u.component(i, order_edge))

    if args.plot:
        plot.polygons(u.components)

if args.neighbor_umbrella_gen:
    print("Header neighbor umbrellas code generation:")
    print_code_gen_notice()
    print("const struct AP_GeodesicGrid::neighbor_umbrella")
    print("AP_GeodesicGrid::_neighbor_umbrellas[3]{")
    for i in range(6):
        u, order_edge = header_neighbor_umbrella(i)

        components = tuple(
            ico.triangles.index(u.component(i, order_edge)) for i in range(5)
        )

        def vi_cj(i, j):
            v = u.vertex(i, order_edge)
            t = u.component(j, order_edge)
            return t.index(v)

        vi_cj_values = tuple(
            vi_cj(a, b) for a, b in ((0, 0), (1, 1), (2, 1), (4, 4), (0, 4))
        )

        print("    {{%s}, %s}," % (
            ", ".join("%2d" % i for i in components),
            ", ".join(str(i) for i in vi_cj_values),
        ))
    print("};")

if args.inverses_gen:
    print("Header inverses code generation:")
    print_code_gen_notice()
    print("const Matrix3f AP_GeodesicGrid::_inverses[10]{")
    for i in range(10):
        a, b, c = ico.triangles[i]
        m = np.matrix((
            (a.x, b.x, c.x),
            (a.y, b.y, c.y),
            (a.z, b.z, c.z),
        )).getI()
        print("    {{%9.6ff, %9.6ff, %9.6ff}," % (m[0,0], m[0,1], m[0,2]))
        print("     {%9.6ff, %9.6ff, %9.6ff}," % (m[1,0], m[1,1], m[1,2]))
        print("     {%9.6ff, %9.6ff, %9.6ff}}," % (m[2,0], m[2,1], m[2,2]))
    print("};")
    print()
    print_code_gen_notice()
    print("const Matrix3f AP_GeodesicGrid::_mid_inverses[10]{")
    for i in range(10):
        a, b, c = ico.triangles[i]
        ma, mb, mc = .5 * (a + b), .5 * (b + c), .5 * (c + a)
        m = np.matrix((
            (ma.x, mb.x, mc.x),
            (ma.y, mb.y, mc.y),
            (ma.z, mb.z, mc.z),
        )).getI()
        print("    {{%9.6ff, %9.6ff, %9.6ff}," % (m[0,0], m[0,1], m[0,2]))
        print("     {%9.6ff, %9.6ff, %9.6ff}," % (m[1,0], m[1,1], m[1,2]))
        print("     {%9.6ff, %9.6ff, %9.6ff}}," % (m[2,0], m[2,1], m[2,2]))
    print("};")


if args.icosahedron:
    print('Icosahedron:')
    for i, t in enumerate(ico.triangles):
        print('    %s' % str(t))
    if args.plot:
        plot.polygons(ico.triangles)

if args.plot:
    plot.show(subtriangles=args.plot_subtriangles)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   # Copyright (C) 2016  Intel Corporation. All rights reserved.
#
# This file is free software: you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This file is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program.  If not, see <http://www.gnu.org/licenses/>.
import icosahedron as ico

def section_triangle(s):
    a, b, c = ico.triangles[s / 4]
    # project the middle points to the sphere
    alpha = a.length() / (2.0 * ico.g)
    ma, mb, mc = alpha * (a + b), alpha * (b + c), alpha * (c + a)

    sub = s % 4
    if sub == 0:
        return ico.Triangle(ma, mb, mc)
    elif sub == 1:
        return ico.Triangle(a, ma, mc)
    elif sub == 2:
        return ico.Triangle(ma, b, mb)
    else:
        return ico.Triangle(mc, mb, c)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               # Copyright (C) 2016  Intel Corporation. All rights reserved.
#
# This file is free software: you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This file is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program.  If not, see <http://www.gnu.org/licenses/>.
import math
from scipy.constants import golden as g

class Vertex(tuple):
    def __new__(cls, x, y, z):
        instance = tuple.__new__(cls, (x, y, z))
        instance.x = x
        instance.y = y
        instance.z = z
        return instance

    def __repr__(self):
        return "(" + ",".join(Vertex._print_map.get(x, str(x)) for x in self) + ")"

    def __str__(self):
        return self.__repr__()

    def __neg__(self):
        return Vertex(-self.x, -self.y, -self.z)

    def __add__(self, other):
        return Vertex(self.x + other.x, self.y + other.y, self.z + other.z)

    def __sub__(self, other):
        return Vertex(self.x - other.x, self.y - other.y, self.z - other.z)

    def __mul__(self, s):
        return Vertex(s * self.x, s * self.y, s * self.z)
    __rmul__ = __mul__

    def length(self):
        return math.sqrt(self.x ** 2 + self.y ** 2 + self.z ** 2)

    def normalized(self):
        return (1.0 / self.length()) * self

class Triangle(tuple):
    def __new__(cls, a, b, c):
        instance = tuple.__new__(cls, (a, b, c))
        instance.a = a
        instance.b = b
        instance.c = c
        return instance

    def __neg__(self):
        return Triangle(-self.a, -self.b, -self.c)

    def __str__(self):
        if self in triangles:
            i = triangles.index(self)
            return "Triangle %2d: %s" % (i, self.__repr__())
        else:
            return self.__repr__()

Vertex._print_map = {
    g: ' g', -g: '-g', 1: ' 1', -1: '-1', 0: ' 0',
}

vertices = tuple(
    Vertex(x, y, z) for x, y, z in (
        ( g, 1, 0),
        ( g,-1, 0),
        (-g, 1, 0),
        (-g,-1, 0),
        ( 1, 0, g),
        (-1, 0, g),
        ( 1, 0,-g),
        (-1, 0,-g),
        ( 0, g, 1),
        ( 0, g,-1),
        ( 0,-g, 1),
        ( 0,-g,-1),
    )
)

_first_half = (
    Triangle(Vertex(-g, 1, 0), Vertex(-1, 0,-g), Vertex(-g,-1, 0)),
    Triangle(Vertex(-1, 0,-g), Vertex(-g,-1, 0), Vertex( 0,-g,-1)),
    Triangle(Vertex(-g,-1, 0), Vertex( 0,-g,-1), Vertex( 0,-g, 1)),
    Triangle(Vertex(-1, 0,-g), Vertex( 0,-g,-1), Vertex( 1, 0,-g)),
    Triangle(Vertex( 0,-g,-1), Vertex( 0,-g, 1), Vertex( g,-1, 0)),
    Triangle(Vertex( 0,-g,-1), Vertex( 1, 0,-g), Vertex( g,-1, 0)),
    Triangle(Vertex( g,-1, 0), Vertex( 1, 0,-g), Vertex( g, 1, 0)),
    Triangle(Vertex( 1, 0,-g), Vertex( g, 1, 0), Vertex( 0, g,-1)),
    Triangle(Vertex( 1, 0,-g), Vertex( 0, g,-1), Vertex(-1, 0,-g)),
    Triangle(Vertex( 0, g,-1), Vertex(-g, 1, 0), Vertex(-1, 0,-g)),
)

_second_half = tuple(-t for t in _first_half)

triangles = _first_half + _second_half

_neighbor_triangle_data = {}
def neighbor_triangle(t, edge):
    """ Return the neighbor triangle of t with respect to edge = (a, b) """
    e = frozenset(edge)
    if (t, e) in _neighbor_triangle_data:
        return _neighbor_triangle_data[(t, e)]

    a, b = edge
    if a not in t or b not in t:
        return None

    for w in triangles:
        if a in w and b in w and w != t:
            _neighbor_triangle_data[(t, e)] = w
            return w

    return None

class _Umbrella:
    def __init__(self, pivot):
        self.pivot = pivot
        self.components = frozenset(t for t in triangles if pivot in t)

        all_vertices = set()
        for t in self.components:
            for v in t:
                if v != pivot:
                    all_vertices.add(v)
        self.all_vertices = frozenset(all_vertices)

        self._vertex_data = {}
        self._component_data = {}

    def vertex(self, i, ordered_edge):
        """ Return the i-th vertex with respect to ordered_edge = (a, b) """
        a, b = ordered_edge
        if a not in self.all_vertices:
            return None
        if b not in self.all_vertices:
            return None

        if i == 0:
            return a
        if i == 1:
            return b

        if (i, a, b) in self._vertex_data:
            return self._vertex_data[(i, a, b)]

        previous = self.vertex(i - 1, ordered_edge)
        comp = self.component(i - 2, ordered_edge)
        neighbor = neighbor_triangle(comp, (self.pivot, previous))

        for v in neighbor:
            if v not in (self.pivot, previous):
                self._vertex_data[(i, a, b)] = v
                return v
        return None

    def component(self, i, ordered_edge):
        """ Return the i-th component with respect to ordered_edge = (a, b) """
        a, b = ordered_edge
        if (i, a, b) in self._component_data:
            return self._component_data[(i, a, b)]

        vi = self.vertex(i, ordered_edge)
        vj = self.vertex(i + 1, ordered_edge)

        for t in self.components:
            if vi in t and vj in t:
                self._component_data[(i, a, b)] = t
                return t
        return None

_umbrelas = {}
def umbrella(pivot):
    if pivot not in vertices:
        return None

    if pivot not in _umbrelas:
        _umbrelas[pivot] = _Umbrella(pivot)
    return _umbrelas[pivot]

def neighbor_umbrella(t, edge):
    neighbor = neighbor_triangle(t, edge)
    if not neighbor:
        return None

    for pivot in neighbor:
        if pivot in edge:
            continue
        return umbrella(pivot)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      e
        if ((-d + b) < 0.0) {
            sN = 0;
        } else if ((-d + b) > a) {
            sN = sD;
        } else {
            sN = (-d +  b);
            sD = a;
        }
    }
    // finally do the division to get tc
    tc = (::is_zero(tN) ? 0.0 : tN / tD);

    // closest point on seg2
    closest_point = seg2_start + line2*tc;
}

// Returns true if the passed 3D segment passes through a plane defined by plane normal, and a point on the plane
template <typename T>
bool Vector3<T>::segment_plane_intersect(const Vector3<T>& seg_start, const Vector3<T>& seg_end, const Vector3<T>& plane_normal, const Vector3<T>& plane_point)
{
    Vector3<T> u = seg_end - seg_start;
    Vector3<T> w = seg_start - plane_point;

    T D = plane_normal * u;
    T N = -(plane_normal * w);

    if (::is_zero(D)) {
        if (::is_zero(N)) {
            // segment lies in this plane
            return true;
        } else {
            // does not intersect
            return false;
        }
    }
    const T sI = N / D;
    if (sI < 0 || sI > 1) {
        // does not intersect
        return false;
    }
    // intersects at unique point
    return true;
}

// define for float and double
template class Vector3<float>;
template class Vector3<double>;

// define needed ops for Vector3l, Vector3i as needed
template Vector3<int32_t> &Vector3<int32_t>::operator +=(const Vector3<int32_t> &v);
template bool Vector3<int16_t>::operator ==(const Vector3<int16_t> &v) const;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         /*
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

// Copyright 2010 Michael Smith, all rights reserved.

// Derived closely from:
/****************************************
* 3D Vector Classes
* By Bill Perone (billperone@yahoo.com)
* Original: 9-16-2002
* Revised: 19-11-2003
*          11-12-2003
*          18-12-2003
*          06-06-2004
*
* Copyright 2003, This code is provided "as is" and you can use it freely as long as
* credit is given to Bill Perone in the application it is used in
*
* Notes:
* if a*b = 0 then a & b are orthogonal
* a%b = -b%a
* a*(b%c) = (a%b)*c
* a%b = a(cast to matrix)*b
* (a%b).length() = area of parallelogram formed by a & b
* (a%b).length() = a.length()*b.length() * sin(angle between a & b)
* (a%b).length() = 0 if angle between a & b = 0 or a.length() = 0 or b.length() = 0
* a * (b%c) = volume of parallelpiped formed by a, b, c
* vector triple product: a%(b%c) = b*(a*c) - c*(a*b)
* scalar triple product: a*(b%c) = c*(a%b) = b*(c%a)
* vector quadruple product: (a%b)*(c%d) = (a*c)*(b*d) - (a*d)*(b*c)
* if a is unit vector along b then a%b = -b%a = -b(cast to matrix)*a = 0
* vectors a1...an are linearly dependent if there exists a vector of scalars (b) where a1*b1 + ... + an*bn = 0
*           or if the matrix (A) * b = 0
*
****************************************/
#pragma once

#ifndef MATH_CHECK_INDEXES
#define MATH_CHECK_INDEXES 0
#endif

#include <cmath>
#include <float.h>
#include <string.h>
#if MATH_CHECK_INDEXES
#include <assert.h>
#endif

#include "rotations.h"

#include "ftype.h"

template <typename T>
class Matrix3;

template <typename T>
class Vector2;

template <typename T>
class Vector3
{

public:
    T        x, y, z;

    // trivial ctor
    constexpr Vector3()
        : x(0)
        , y(0)
        , z(0) {}

    // setting ctor
    constexpr Vector3(const T x0, const T y0, const T z0)
        : x(x0)
        , y(y0)
        , z(z0) {}

    //Create a Vector3 from a Vector2 with z
    constexpr Vector3(const Vector2<T> &v0, const T z0)
        : x(v0.x)
        , y(v0.y)
        , z(z0) {}

    // test for equality
    bool operator ==(const Vector3<T> &v) const;

    // test for inequality
    bool operator !=(const Vector3<T> &v) const;

    // negation
    Vector3<T> operator -(void) const;

    // addition
    Vector3<T> operator +(const Vector3<T> &v) const;

    // subtraction
    Vector3<T> operator -(const Vector3<T> &v) const;

    // uniform scaling
    Vector3<T> operator *(const T num) const;

    // uniform scaling
    Vector3<T> operator  /(const T num) const;

    // addition
    Vector3<T> &operator +=(const Vector3<T> &v);

    // subtraction
    Vector3<T> &operator -=(const Vector3<T> &v);

    // uniform scaling
    Vector3<T> &operator *=(const T num);

    // uniform scaling
    Vector3<T> &operator /=(const T num);

    // non-uniform scaling
    Vector3<T> &operator *=(const Vector3<T> &v) {
        x *= v.x; y *= v.y; z *= v.z;
        return *this;
    }

    // allow a vector3 to be used as an array, 0 indexed
    T & operator[](uint8_t i) {
        T *_v = &x;
#if MATH_CHECK_INDEXES
        assert(i >= 0 && i < 3);
#endif
        return _v[i];
    }

    const T & operator[](uint8_t i) const {
        const T *_v = &x;
#if MATH_CHECK_INDEXES
        assert(i >= 0 && i < 3);
#endif
        return _v[i];
    }

    // dot product
    T operator *(const Vector3<T> &v) const;

    // dot product for Lua
    T dot(const Vector3<T> &v) const {
        return *this * v;
    }
    
    // multiply a row vector by a matrix, to give a row vector
    Vector3<T> row_times_mat(const Matrix3<T> &m) const;

    // multiply a column vector by a row vector, returning a 3x3 matrix
    Matrix3<T> mul_rowcol(const Vector3<T> &v) const;

    // cross product
    Vector3<T> operator %(const Vector3<T> &v) const;

    // cross product for Lua
    Vector3<T> cross(const Vector3<T> &v) const {
        return *this % v;
    }

    // scale a vector3
    Vector3<T> scale(const T v) const {
        return *this * v;
    }
    
    // computes the angle between this vector and another vector
    T angle(const Vector3<T> &v2) const;

    // check if any elements are NAN
    bool is_nan(void) const WARN_IF_UNUSED;

    // check if any elements are infinity
    bool is_inf(void) const WARN_IF_UNUSED;

    // check if all elements are zero
    bool is_zero(void) const WARN_IF_UNUSED {
        return x == 0 && y == 0 && z == 0;
    }


    // rotate by a standard rotation
    void rotate(enum Rotation rotation);
    void rotate_inverse(enum Rotation rotation);

    // rotate vector by angle in radians in xy plane leaving z untouched
    void rotate_xy(T rotation_rad);

    // return xy components of a vector3 as a vector2.
    // this returns a reference to the original vector3 xy data
    const Vector2<T> &xy() const {
        return *(const Vector2<T> *)this;
    }
    Vector2<T> &xy() {
        return *(Vector2<T> *)this;
    }

    // gets the length of this vector squared
    T  length_squared() const
    {
        return (T)(*this * *this);
    }

    // gets the length of this vector
    T length(void) const;

    // limit xy component vector to a given length. returns true if vector was limited
    bool limit_length_xy(T max_length);

    // normalizes this vector
    void normalize()
    {
        *this /= length();
    }

    // zero the vector
    void zero()
    {
        x = y = z = 0;
    }

    // returns the normalized version of this vector
    Vector3<T> normalized() const
    {
        return *this/length();
    }

    // reflects this vector about n
    void  reflect(const Vector3<T> &n)
    {
        Vector3<T>        orig(*this);
        project(n);
        *this = *this*2 - orig;
    }

    // projects this vector onto v
    void project(const Vector3<T> &v)
    {
        *this= v * (*this * v)/(v*v);
    }

    // returns this vector projected onto v
    Vector3<T> projected(const Vector3<T> &v) const
    {
        return v * (*this * v)/(v*v);
    }

    // distance from the tip of this vector to another vector squared (so as to avoid the sqrt calculation)
    T distance_squared(const Vector3<T> &v) const {
        const T dist_x = x-v.x;
        const T dist_y = y-v.y;
        const T dist_z = z-v.z;
        return (dist_x*dist_x + dist_y*dist_y + dist_z*dist_z);
    }

    // distance from the tip of this vector to a line segment specified by two vectors
    T distance_to_segment(const Vector3<T> &seg_start, const Vector3<T> &seg_end) const;

    // extrapolate position given bearing and pitch (in degrees) and distance
    void offset_bearing(T bearing, T pitch, T distance);

    /*
      conversion to/from double
     */
    Vector3<float> tofloat() const {
        return Vector3<float>{float(x),float(y),float(z)};
    }
    Vector3<double> todouble() const {
        return Vector3<double>{x,y,z};
    }

    // convert from right-front-up to front-right-down
    // or ENU to NED
    Vector3<T> rfu_to_frd() const {
        return Vector3<T>{y,x,-z};
    }

    // given a position p1 and a velocity v1 produce a vector
    // perpendicular to v1 maximising distance from p1.  If p1 is the
    // zero vector the return from the function will always be the
    // zero vector - that should be checked for.
    static Vector3<T> perpendicular(const Vector3<T> &p1, const Vector3<T> &v1)
    {
        const T d = p1 * v1;
        if (::is_zero(d)) {
            return p1;
        }
        const Vector3<T> parallel = (v1 * d) / v1.length_squared();
        Vector3<T> perpendicular = p1 - paralle