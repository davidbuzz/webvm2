 CPCFG0_PRU1_GPI_DIV0_S)
#define  CPCFG0_PRU1_GPI_DIV0_9		(16 << CPCFG0_PRU1_GPI_DIV0_S)
#define  CPCFG0_PRU1_GPI_DIV0_9_5	(17 << CPCFG0_PRU1_GPI_DIV0_S)
#define  CPCFG0_PRU1_GPI_DIV0_10	(18 << CPCFG0_PRU1_GPI_DIV0_S)
#define  CPCFG0_PRU1_GPI_DIV0_10_5	(19 << CPCFG0_PRU1_GPI_DIV0_S)
#define  CPCFG0_PRU1_GPI_DIV0_11	(20 << CPCFG0_PRU1_GPI_DIV0_S)
#define  CPCFG0_PRU1_GPI_DIV0_11_5	(21 << CPCFG0_PRU1_GPI_DIV0_S)
#define  CPCFG0_PRU1_GPI_DIV0_12	(22 << CPCFG0_PRU1_GPI_DIV0_S)
#define  CPCFG0_PRU1_GPI_DIV0_12_5	(23 << CPCFG0_PRU1_GPI_DIV0_S)
#define  CPCFG0_PRU1_GPI_DIV0_13	(24 << CPCFG0_PRU1_GPI_DIV0_S)
#define  CPCFG0_PRU1_GPI_DIV0_13_5	(25 << CPCFG0_PRU1_GPI_DIV0_S)
#define  CPCFG0_PRU1_GPI_DIV0_14	(26 << CPCFG0_PRU1_GPI_DIV0_S)
#define  CPCFG0_PRU1_GPI_DIV0_14_5	(27 << CPCFG0_PRU1_GPI_DIV0_S)
#define  CPCFG0_PRU1_GPI_DIV0_15	(28 << CPCFG0_PRU1_GPI_DIV0_S)
#define  CPCFG0_PRU1_GPI_DIV0_15_5	(29 << CPCFG0_PRU1_GPI_DIV0_S)
#define  CPCFG0_PRU1_GPI_DIV0_16	(30 << CPCFG0_PRU1_GPI_DIV0_S)
#define  CPCFG0_PRU1_GPI_DIV1_S		8
#define  CPCFG0_PRU1_GPI_DIV1_W		5
#define  CPCFG0_PRU1_GPI_DIV1_M		((CPCFG0_PRU1_GPI_DIV1_W - 1) << CPCFG0_PRU1_GPI_DIV1_S)
#define  CPCFG0_PRU1_GPI_DIV1_1		(0 << CPCFG0_PRU1_GPI_DIV1_S)
#define  CPCFG0_PRU1_GPI_DIV1_1_5	(1 << CPCFG0_PRU1_GPI_DIV1_S)
#define  CPCFG0_PRU1_GPI_DIV1_2		(2 << CPCFG0_PRU1_GPI_DIV1_S)
#define  CPCFG0_PRU1_GPI_DIV1_2_5	(3 << CPCFG0_PRU1_GPI_DIV1_S)
#define  CPCFG0_PRU1_GPI_DIV1_3		(4 << CPCFG0_PRU1_GPI_DIV1_S)
#define  CPCFG0_PRU1_GPI_DIV1_3_5	(5 << CPCFG0_PRU1_GPI_DIV1_S)
#define  CPCFG0_PRU1_GPI_DIV1_4		(6 << CPCFG0_PRU1_GPI_DIV1_S)
#define  CPCFG0_PRU1_GPI_DIV1_4_5	(7 << CPCFG0_PRU1_GPI_DIV1_S)
#define  CPCFG0_PRU1_GPI_DIV1_5		(8 << CPCFG0_PRU1_GPI_DIV1_S)
#define  CPCFG0_PRU1_GPI_DIV1_5_5	(9 << CPCFG0_PRU1_GPI_DIV1_S)
#define  CPCFG0_PRU1_GPI_DIV1_6		(10 << CPCFG0_PRU1_GPI_DIV1_S)
#define  CPCFG0_PRU1_GPI_DIV1_6_5	(11 << CPCFG0_PRU1_GPI_DIV1_S)
#define  CPCFG0_PRU1_GPI_DIV1_7		(12 << CPCFG0_PRU1_GPI_DIV1_S)
#define  CPCFG0_PRU1_GPI_DIV1_7_5	(13 << CPCFG0_PRU1_GPI_DIV1_S)
#define  CPCFG0_PRU1_GPI_DIV1_8		(14 << CPCFG0_PRU1_GPI_DIV1_S)
#define  CPCFG0_PRU1_GPI_DIV1_8_5	(15 << CPCFG0_PRU1_GPI_DIV1_S)
#define  CPCFG0_PRU1_GPI_DIV1_9		(16 << CPCFG0_PRU1_GPI_DIV1_S)
#define  CPCFG0_PRU1_GPI_DIV1_9_5	(17 << CPCFG0_PRU1_GPI_DIV1_S)
#define  CPCFG0_PRU1_GPI_DIV1_10	(18 << CPCFG0_PRU1_GPI_DIV1_S)
#define  CPCFG0_PRU1_GPI_DIV1_10_5	(19 << CPCFG0_PRU1_GPI_DIV1_S)
#define  CPCFG0_PRU1_GPI_DIV1_11	(20 << CPCFG0_PRU1_GPI_DIV1_S)
#define  CPCFG0_PRU1_GPI_DIV1_11_5	(21 << CPCFG0_PRU1_GPI_DIV1_S)
#define  CPCFG0_PRU1_GPI_DIV1_12	(22 << CPCFG0_PRU1_GPI_DIV1_S)
#define  CPCFG0_PRU1_GPI_DIV1_12_5	(23 << CPCFG0_PRU1_GPI_DIV1_S)
#define  CPCFG0_PRU1_GPI_DIV1_13	(24 << CPCFG0_PRU1_GPI_DIV1_S)
#define  CPCFG0_PRU1_GPI_DIV1_13_5	(25 << CPCFG0_PRU1_GPI_DIV1_S)
#define  CPCFG0_PRU1_GPI_DIV1_14	(26 << CPCFG0_PRU1_GPI_DIV1_S)
#define  CPCFG0_PRU1_GPI_DIV1_14_5	(27 << CPCFG0_PRU1_GPI_DIV1_S)
#define  CPCFG0_PRU1_GPI_DIV1_15	(28 << CPCFG0_PRU1_GPI_DIV1_S)
#define  CPCFG0_PRU1_GPI_DIV1_15_5	(29 << CPCFG0_PRU1_GPI_DIV1_S)
#define  CPCFG0_PRU1_GPI_DIV1_16	(30 << CPCFG0_PRU1_GPI_DIV1_S)
#define  CPCFG0_PRU1_GPI_S8		(1 << 13)
#define  CPCFG0_PRU1_GPO_MODE		(1 << 14)
#define  CPCFG0_PRU1_GPO_DIV0_S		15
#define  CPCFG0_PRU1_GPO_DIV0_W		5
#define  CPCFG0_PRU1_GPO_DIV0_M		((CPCFG0_PRU1_GPO_DIV0_W - 1) << CPCFG0_PRU1_GPO_DIV0_S)
#define  CPCFG0_PRU1_GPO_DIV0_1		(0 << CPCFG0_PRU1_GPO_DIV0_S)
#define  CPCFG0_PRU1_GPO_DIV0_1_5	(1 << CPCFG0_PRU1_GPO_DIV0_S)
#define  CPCFG0_PRU1_GPO_DIV0_2		(2 << CPCFG0_PRU1_GPO_DIV0_S)
#define  CPCFG0_PRU1_GPO_DIV0_2_5	(3 << CPCFG0_PRU1_GPO_DIV0_S)
#define  CPCFG0_PRU1_GPO_DIV0_3		(4 << CPCFG0_PRU1_GPO_DIV0_S)
#define  CPCFG0_PRU1_GPO_DIV0_3_5	(5 << CPCFG0_PRU1_GPO_DIV0_S)
#define  CPCFG0_PRU1_GPO_DIV0_4		(6 << CPCFG0_PRU1_GPO_DIV0_S)
#define  CPCFG0_PRU1_GPO_DIV0_4_5	(7 << CPCFG0_PRU1_GPO_DIV0_S)
#define  CPCFG0_PRU1_GPO_DIV0_5		(8 << CPCFG0_PRU1_GPO_DIV0_S)
#define  CPCFG0_PRU1_GPO_DIV0_5_5	(9 << CPCFG0_PRU1_GPO_DIV0_S)
#define  CPCFG0_PRU1_GPO_DIV0_6		(10 << CPCFG0_PRU1_GPO_DIV0_S)
#define  CPCFG0_PRU1_GPO_DIV0_6_5	(11 << CPCFG0_PRU1_GPO_DIV0_S)
#define  CPCFG0_PRU1_GPO_DIV0_7		(12 << CPCFG0_PRU1_GPO_DIV0_S)
#define  CPCFG0_PRU1_GPO_DIV0_7_5	(13 << CPCFG0_PRU1_GPO_DIV0_S)
#define  CPCFG0_PRU1_GPO_DIV0_8		(14 << CPCFG0_PRU1_GPO_DIV0_S)
#define  CPCFG0_PRU1_GPO_DIV0_8_5	(15 << CPCFG0_PRU1_GPO_DIV0_S)
#define  CPCFG0_PRU1_GPO_DIV0_9		(16 << CPCFG0_PRU1_GPO_DIV0_S)
#define  CPCFG0_PRU1_GPO_DIV0_9_5	(17 << CPCFG0_PRU1_GPO_DIV0_S)
#define  CPCFG0_PRU1_GPO_DIV0_10	(18 << CPCFG0_PRU1_GPO_DIV0_S)
#define  CPCFG0_PRU1_GPO_DIV0_10_5	(19 << CPCFG0_PRU1_GPO_DIV0_S)
#define  CPCFG0_PRU1_GPO_DIV0_11	(20 << CPCFG0_PRU1_GPO_DIV0_S)
#define  CPCFG0_PRU1_GPO_DIV0_11_5	(21 << CPCFG0_PRU1_GPO_DIV0_S)
#define  CPCFG0_PRU1_GPO_DIV0_12	(22 << CPCFG0_PRU1_GPO_DIV0_S)
#define  CPCFG0_PRU1_GPO_DIV0_12_5	(23 << CPCFG0_PRU1_GPO_DIV0_S)
#define  CPCFG0_PRU1_GPO_DIV0_13	(24 << CPCFG0_PRU1_GPO_DIV0_S)
#define  CPCFG0_PRU1_GPO_DIV0_13_5	(25 << CPCFG0_PRU1_GPO_DIV0_S)
#define  CPCFG0_PRU1_GPO_DIV0_14	(26 << CPCFG0_PRU1_GPO_DIV0_S)
#define  CPCFG0_PRU1_GPO_DIV0_14_5	(27 << CPCFG0_PRU1_GPO_DIV0_S)
#define  CPCFG0_PRU1_GPO_DIV0_15	(28 << CPCFG0_PRU1_GPO_DIV0_S)
#define  CPCFG0_PRU1_GPO_DIV0_15_5	(29 << CPCFG0_PRU1_GPO_DIV0_S)
#define  CPCFG0_PRU1_GPO_DIV0_16	(30 << CPCFG0_PRU1_GPO_DIV0_S)
#define  CPCFG0_PRU1_GPO_DIV1_S		20
#define  CPCFG0_PRU1_GPO_DIV1_W		5
#define  CPCFG0_PRU1_GPO_DIV1_M		((CPCFG0_PRU1_GPO_DIV1_W - 1) << CPCFG0_PRU1_GPO_DIV1_S)
#define  CPCFG0_PRU1_GPO_DIV1_1		(0 << CPCFG0_PRU1_GPO_DIV1_S)
#define  CPCFG0_PRU1_GPO_DIV1_1_5	(1 << CPCFG0_PRU1_GPO_DIV1_S)
#define  CPCFG0_PRU1_GPO_DIV1_2		(2 << CPCFG0_PRU1_GPO_DIV1_S)
#define  CPCFG0_PRU1_GPO_DIV1_2_5	(3 << CPCFG0_PRU1_GPO_DIV1_S)
#define  CPCFG0_PRU1_GPO_DIV1_3		(4 << CPCFG0_PRU1_GPO_DIV1_S)
#define  CPCFG0_PRU1_GPO_DIV1_3_5	(5 << CPCFG0_PRU1_GPO_DIV1_S)
#define  CPCFG0_PRU1_GPO_DIV1_4		(6 << CPCFG0_PRU1_GPO_DIV1_S)
#define  CPCFG0_PRU1_GPO_DIV1_4_5	(7 << CPCFG0_PRU1_GPO_DIV1_S)
#define  CPCFG0_PRU1_GPO_DIV1_5		(8 << CPCFG0_PRU1_GPO_DIV1_S)
#define  CPCFG0_PRU1_GPO_DIV1_5_5	(9 << CPCFG0_PRU1_GPO_DIV1_S)
#define  CPCFG0_PRU1_GPO_DIV1_6		(10 << CPCFG0_PRU1_GPO_DIV1_S)
#define  CPCFG0_PRU1_GPO_DIV1_6_5	(11 << CPCFG0_PRU1_GPO_DIV1_S)
#define  CPCFG0_PRU1_GPO_DIV1_7		(12 << CPCFG0_PRU1_GPO_DIV1_S)
#define  CPCFG0_PRU1_GPO_DIV1_7_5	(13 << CPCFG0_PRU1_GPO_DIV1_S)
#define  CPCFG0_PRU1_GPO_DIV1_8		(14 << CPCFG0_PRU1_GPO_DIV1_S)
#define  CPCFG0_PRU1_GPO_DIV1_8_5	(15 << CPCFG0_PRU1_GPO_DIV1_S)
#define  CPCFG0_PRU1_GPO_DIV1_9		(16 << CPCFG0_PRU1_GPO_DIV1_S)
#define  CPCFG0_PRU1_GPO_DIV1_9_5	(17 << CPCFG0_PRU1_GPO_DIV1_S)
#define  CPCFG0_PRU1_GPO_DIV1_10	(18 << CPCFG0_PRU1_GPO_DIV1_S)
#define  CPCFG0_PRU1_GPO_DIV1_10_5	(19 << CPCFG0_PRU1_GPO_DIV1_S)
#define  CPCFG0_PRU1_GPO_DIV1_11	(20 << CPCFG0_PRU1_GPO_DIV1_S)
#define  CPCFG0_PRU1_GPO_DIV1_11_5	(21 << CPCFG0_PRU1_GPO_DIV1_S)
#define  CPCFG0_PRU1_GPO_DIV1_12	(22 << CPCFG0_PRU1_GPO_DIV1_S)
#define  CPCFG0_PRU1_GPO_DIV1_12_5	(23 << CPCFG0_PRU1_GPO_DIV1_S)
#define  CPCFG0_PRU1_GPO_DIV1_13	(24 << CPCFG0_PRU1_GPO_DIV1_S)
#define  CPCFG0_PRU1_GPO_DIV1_13_5	(25 << CPCFG0_PRU1_GPO_DIV1_S)
#define  CPCFG0_PRU1_GPO_DIV1_14	(26 << CPCFG0_PRU1_GPO_DIV1_S)
#define  CPCFG0_PRU1_GPO_DIV1_14_5	(27 << CPCFG0_PRU1_GPO_DIV1_S)
#define  CPCFG0_PRU1_GPO_DIV1_15	(28 << CPCFG0_PRU1_GPO_DIV1_S)
#define  CPCFG0_PRU1_GPO_DIV1_15_5	(29 << CPCFG0_PRU1_GPO_DIV1_S)
#define  CPCFG0_PRU1_GPO_DIV1_16	(30 << CPCFG0_PRU1_GPO_DIV1_S)
#define  CPCFG0_PRU1_GPO_SH_SE		(1 << 25)

#define PRUCFG_CGR	PRUCFG(0x0010)

#define PRUCFG_ISRP	PRUCFG(0x0014)

#define PRUCFG_ISP	PRUCFG(0x0018)

#define PRUCFG_IESP	PRUCFG(0x001C)

#define PRUCFG_PMAO	PRUCFG(0x0028)
#define  PMAO_PMAO_PRU0		(1 << 0)
#define  PMAO_PMAO_PRU1		(1 << 1)

#define PRUCFG_MII_RT	PRUCFG(0x002C)

#define PRUCFG_IEPCLK	PRUCFG(0x0030)

#define PRUCFG_PINMX	PRUCFG(0x0040)

#define PINTC(_reg) \
	(*(volatile u32 *)((char *)C0 + (_reg)))

#define PINTC_REVID		PINTC(0x0000)
#define PINTC_CR		PINTC(0x0004)
#define PINTC_GER		PINTC(0x0010)
#define PINTC_GNLR		PINTC(0x001C)
#define PINTC_SISR		PINTC(0x0020)
#define PINTC_SICR		PINTC(0x0024)
#define PINTC_EISR		PINTC(0x0028)
#define PINTC_EICR		PINTC(0x002C)
#define PINTC_HIEISR		PINTC(0x0034)
#define PINTC_HIDISR		PINTC(0x0038)
#define PINTC_GPIR		PINTC(0x0080)
#define PINTC_SRSR0		PINTC(0x0200)
#define PINTC_SRSR1		PINTC(0x0204)
#define PINTC_SECR0		PINTC(0x0280)
#define PINTC_SECR1		PINTC(0x0284)
#define PINTC_ESR0		PINTC(0x0300)
#define PINTC_ESR1		PINTC(0x0304)
#define PINTC_ECR0		PINTC(0x0380)
#define PINTC_ECR1		PINTC(0x0384)
#define PINTC_CMR0		PINTC(0x0400)
#define PINTC_CMR1		PINTC(0x0404)
#define PINTC_CMR2		PINTC(0x0408)
#define PINTC_CMR3		PINTC(0x040C)
#define PINTC_CMR4		PINTC(0x0410)
#define PINTC_CMR5		PINTC(0x0414)
#define PINTC_CMR6		PINTC(0x0418)
#define PINTC_CMR7		PINTC(0x041C)
#define PINTC_CMR8		PINTC(0x0420)
#define PINTC_CMR9		PINTC(0x0424)
#define PINTC_CMR10		PINTC(0x0428)
#define PINTC_CMR11		PINTC(0x042C)
#define PINTC_CMR12		PINTC(0x0430)
#define PINTC_CMR13		PINTC(0x0434)
#define PINTC_CMR14		PINTC(0x0438)
#define PINTC_CMR15		PINTC(0x043C)
#define PINTC_HMR0		PINTC(0x0800)
#define PINTC_HMR1		PINTC(0x0804)
#define PINTC_HMR2		PINTC(0x0808)
#define PINTC_HIPIR0		PINTC(0x0900)
#define PINTC_HIPIR1		PINTC(0x0904)
#define PINTC_HIPIR2		PINTC(0x0908)
#define PINTC_HIPIR3		PINTC(0x090C)
#define PINTC_HIPIR4		PINTC(0x0910)
#define PINTC_HIPIR5		PINTC(0x0914)
#define PINTC_HIPIR6		PINTC(0x0918)
#define PINTC_HIPIR7		PINTC(0x091C)
#define PINTC_HIPIR8		PINTC(0x0920)
#define PINTC_HIPIR9		PINTC(0x0924)
#define PINTC_SIPR0		PINTC(0x0D00)
#define PINTC_SIPR1		PINTC(0x0D04)
#define PINTC_SITR0		PINTC(0x0D80)
#define PINTC_SITR1		PINTC(0x0D84)
#define PINTC_HINLR0		PINTC(0x1100)
#define PINTC_HINLR1		PINTC(0x1104)
#define PINTC_HINLR2		PINTC(0x1108)
#define PINTC_HINLR3		PINTC(0x110C)
#define PINTC_HINLR4		PINTC(0x1110)
#define PINTC_HINLR5		PINTC(0x1114)
#define PINTC_HINLR6		PINTC(0x1118)
#define PINTC_HINLR7		PINTC(0x111C)
#define PINTC_HINLR8		PINTC(0x1120)
#define PINTC_HINLR9		PINTC(0x1124)
#define PINTC_HIER		PINTC(0x1500)

/* PRU Industrial Ethernet Peripheral */
#define PIEP(_reg) \
	(*(volatile u32 *)((char *)C26 + (_reg)))

#define PIEP_GLOBAL_CFG		PIEP(0x0000)
#define  GLOBAL_CFG_CNT_ENABLE		(1 << 0)
#define  GLOBAL_CFG_DEFAULT_INC_S	4
#define  GLOBAL_CFG_DEFAULT_INC_W	4
#define  GLOBAL_CFG_DEFAULT_INC_M	((GLOBAL_CFG_DEFAULT_INC_W - 1) << GLOBAL_CFG_DEFAULT_INC_S)
#define  GLOBAL_CFG_DEFAULT_INC(x)	(((x) << GLOBAL_CFG_DEFAULT_INC_S) & GLOBAL_CFG_DEFAULT_INC_M)
#define  GLOBAL_CFG_CMP_INC_S		8
#define  GLOBAL_CFG_CMP_INC_W		12
#define  GLOBAL_CFG_CMP_INC_M		((GLOBAL_CFG_CMP_INC_W - 1) << GLOBAL_CFG_CMP_INC_S)
#define  GLOBAL_CFG_CMP_INC(x)		(((x) << GLOBAL_CFG_CMP_INC_S) & GLOBAL_CFG_CMP_INC_M)

#define PIEP_GLOBAL_STATUS	PIEP(0x0004)
#define  GLOBAL_STATUS_CNT_OVF		(1 << 0)

#define PIEP_COMPEN		PIEP(0x0008)
#define PIEP_COUNT		PIEP(0x000C)
#define PIEP_CMP_CFG		PIEP(0x0040)
#define  CMP_CFG_CMP0_RST_CNT_EN	(1 << 0)
#define  CMP_CFG_CMP_EN_S		1
#define  CMP_CFG_CMP_EN_W		8
#define  CMP_CFG_CMP_EN_M		((CMP_CFG_CMP_EN_W - 1) << CMP_CFG_CMP_EN_S)
#define  CMP_CFG_CMP_EN(x)		((1 << ((x) + CMP_CFG_CMP_EN_S)) & CMP_CFG_CMP_EN_M)

#define PIEP_CMP_STATUS		PIEP(0x0044)
#define  CMD_STATUS_CMP_HIT_S		0
#define  CMD_STATUS_CMP_HIT_W		8
#define  CMD_STATUS_CMP_HIT_M		((CMD_STATUS_CMP_HIT_W - 1) << CMD_STATUS_CMP_HIT_S)
#define  CMD_STATUS_CMP_HIT(x)		((1 << ((x) + CMD_STATUS_CMP_HIT_S)) & CMD_STATUS_CMP_HIT_M)

#define PIEP_CMP_CMP0		PIEP(0x0048)
#define PIEP_CMP_CMP1		PIEP(0x004C)
#define PIEP_CMP_CMP2		PIEP(0x0050)
#define PIEP_CMP_CMP3		PIEP(0x0054)
#define PIEP_CMP_CMP4		PIEP(0x0058)
#define PIEP_CMP_CMP5		PIEP(0x005C)
#define PIEP_CMP_CMP6		PIEP(0x0060)
#define PIEP_CMP_CMP7		PIEP(0x0064)
#define PIEP_CMP_CMP(x)		PIEP(0x0048 + ((x) << 2))

#if defined(PRU0) || defined(PRU1)

#ifdef PRU0
#define PCTRL(_reg) \
	(*(volatile u32 *)((char *)0x22000 + (_reg)))
#define PCTRL_OTHER(_reg) \
	(*(volatile u32 *)((char *)0x24000 + (_reg)))
#else
#define PCTRL(_reg) \
	(*(volatile u32 *)((char *)0x24000 + (_reg)))
#define PCTRL_OTHER(_reg) \
	(*(volatile u32 *)((char *)0x22000 + (_reg)))
#endif

#define PCTRL_CONTROL		PCTRL(0x0000)
#define  CONTROL_SOFT_RST_N	(1 << 0)
#define  CONTROL_ENABLE		(1 << 1)
#define  CONTROL_SLEEPING	(1 << 2)
#define  CONTROL_COUNTER_ENABLE	(1 << 3)
#define  CONTROL_SINGLE_STEP	(1 << 8)
#define  CONTROL_RUNSTATE	(1 << 15)
#define PCTRL_STATUS		PCTRL(0x0004)
#define PCTRL_WAKEUP_EN		PCTRL(0x0008)
#define PCTRL_CYCLE		PCTRL(0x000C)
#define PCTRL_STALL		PCTRL(0x0010)
#define PCTRL_CTBIR0		PCTRL(0x0020)
#define PCTRL_CTBIR1		PCTRL(0x0024)
#define PCTRL_CTPPR0		PCTRL(0x0028)
#define PCTRL_CTPPR1		PCTRL(0x002C)

/* we can't access our debug registers (since we have to be stopped) */
#ifdef PRU0
#define PDBG_OTHER(_reg) \
	(*(volatile u32 *)((char *)0x24400 + (_reg)))
#else
#define PDBG_OTHER(_reg) \
	(*(volatile u32 *)((char *)0x22400 + (_reg)))
#endif

#endif

/* secondary access by C28 (which must point to 0x20200 */
#define PINTC_0200(_reg) \
	(*(volatile u32 *)((char *)C28 + ((_reg) - 0x200)))

#define SIGNAL_EVENT(x) \
	do { \
		__R31 = (1 << 5) | ((x) - 16); \
	} while(0)


#ifndef PRU_CLK
/* default PRU clock (200MHz) */
#define PRU_CLK	200000000
#endif

/* NOTE: Do no use it for larger than 5 secs */
#define PRU_200MHz_sec(x)	((u32)(((x) * 200000000)))
#define PRU_200MHz_ms(x)	((u32)(((x) * 200000)))
#define PRU_200MHz_ms_err(x)	0
#define PRU_200MHz_us(x)	((u32)(((x) * 200)))
#define PRU_200MHz_us_err(x)	0
#define PRU_200MHz_ns(x)	((u32)(((x) * 2) / 10))
#define PRU_200MHz_ns_err(x)	((u32)(((x) * 2) % 10))

#if PRU_CLK != 200000000 
/* NOTE: Do no use it for larger than 5 secs */
#define PRU_sec(x)	((u32)(((u64)(x) * PRU_CLK)))
#define PRU_ms(x)	((u32)(((u64)(x) * PRU_CLK) / 1000))
#define PRU_ms_err(x)	((u32)(((u64)(x) * PRU_CLK) % 1000))
#define PRU_us(x)	((u32)(((u64)(x) * PRU_CLK) / 1000000))
#define PRU_us_err(x)	((u32)(((u64)(x) * PRU_CLK) % 1000000))
#define PRU_ns(x)	((u32)(((u64)(x) * PRU_CLK) / 1000000000))
#define PRU_ns_err(x)	((u32)(((u64)(x) * PRU_CLK) % 1000000000))
#else
/* NOTE: Do no use it for larger than 5 secs */
#define PRU_sec(x)	PRU_200MHz_sec(x)
#define PRU_ms(x)	PRU_200MHz_ms(x)
#define PRU_ms_err(x)	PRU_200MHz_ms_err(x)
#define PRU_us(x)	PRU_200MHz_us(x)
#define PRU_us_err(x)	PRU_200MHz_us_err(x)
#define PRU_ns(x)	PRU_200MHz_ns(x)
#define PRU_ns_err(x)	PRU_200MHz_ns_err(x)
#endif

#define DPRAM_SHARED	0x00012000

/* event definitions */
#define SYSEV_ARM_TO_PRU0	21
#define SYSEV_ARM_TO_PRU1	22
#define SYSEV_PRU0_TO_ARM	19
#define SYSEV_PRU0_TO_PRU1	17
#define SYSEV_PRU1_TO_ARM	20
#define SYSEV_PRU1_TO_PRU0	19

/* for communication with the host we have another set of events */
#define SYSEV_VR_ARM_TO_PRU0	24
#define SYSEV_VR_PRU0_TO_ARM	25
#define SYSEV_VR_ARM_TO_PRU1	26
#define SYSEV_VR_PRU1_TO_ARM	27

#define pru0_signal() (__R31 & (1U << 30))
#define pru1_signal() (__R31 & (1U << 31))

#ifdef PRU0
#define pru_signal()	pru0_signal()
#define SYSEV_OTHER_PRU_TO_THIS_PRU	SYSEV_PRU1_TO_PRU0
#define SYSEV_ARM_TO_THIS_PRU		SYSEV_ARM_TO_PRU0
#define SYSEV_THIS_PRU_TO_OTHER_PRU	SYSEV_PRU0_TO_PRU1
#define SYSEV_THIS_PRU_TO_ARM		SYSEV_PRU0_TO_ARM
#define SYSEV_VR_ARM_TO_THIS_PRU	SYSEV_VR_ARM_TO_PRU0
#define SYSEV_VR_THIS_PRU_TO_ARM	SYSEV_VR_PRU0_TO_ARM
#endif

#ifdef PRU1
#define pru_signal()	pru1_signal()
#define SYSEV_OTHER_PRU_TO_THIS_PRU	SYSEV_PRU0_TO_PRU1
#define SYSEV_ARM_TO_THIS_PRU		SYSEV_ARM_TO_PRU1
#define SYSEV_THIS_PRU_TO_OTHER_PRU	SYSEV_PRU1_TO_PRU0
#define SYSEV_THIS_PRU_TO_ARM		SYSEV_PRU1_TO_ARM
#define SYSEV_VR_ARM_TO_THIS_PRU	SYSEV_VR_ARM_TO_PRU1
#define SYSEV_VR_THIS_PRU_TO_ARM	SYSEV_VR_PRU1_TO_ARM
#endif

/* all events < 32 */
#define SYSEV_THIS_PRU_INCOMING_MASK	\
	(BIT(SYSEV_ARM_TO_THIS_PRU) | \
	 BIT(SYSEV_OTHER_PRU_TO_THIS_PRU) | \
	 BIT(SYSEV_VR_ARM_TO_THIS_PRU))

#define DELAY_CYCLES(x) \
	do { \
		unsigned int t = (x) >> 1; \
		do { \
			__asm(" "); \
		} while (--t); \
	} while(0)

#ifndef BIT
#define BIT(x) (1U << (x))
#endif

/* access to the resources of the other PRU (halt it and have your way) */
#if defined(PRU0) || defined(PRU1)

static inline void pru_other_halt(void)
{
	PCTRL_OTHER(0x0000) &= ~CONTROL_ENABLE;	/* clear enable */
	/* loop until RUNSTATE clears */
	while ((PCTRL_OTHER(0x0000) & CONTROL_RUNSTATE) != 0)
		;
}

static inline void pru_other_resume(void)
{
	PCTRL_OTHER(0x0000) |= CONTROL_ENABLE;	/* set enable */
}

static inline u32 pru_other_read_reg(u16 reg)
{
	u32 val;

	reg <<= 2;	/* multiply by 4 */
	pru_other_halt();
	val = PDBG_OTHER(reg);
	pru_other_resume();
	return val;
}

static inline void pru_other_write_reg(u16 reg, u32 val)
{
	reg <<= 2;	/* multiply by 4 */
	pru_other_halt();
	PDBG_OTHER(reg) = val;
	pru_other_resume();
}

static inline void pru_other_and_or_reg(u16 reg, u32 andmsk, u32 ormsk)
{
	reg <<= 2;	/* multiply by 4 */
	pru_other_halt();
	PDBG_OTHER(reg) = (PDBG_OTHER(reg) & andmsk) | ormsk;
	pru_other_resume();
}

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       /*
 * prucomm.h - structure definitions for communication
 *
 */
#pragma once

#include "pru_defs.h"

#define NUM_RING_ENTRIES 300
    
#define PWM_CMD_MAGIC    0xf00fbaaf
#define PWM_REPLY_MAGIC  0xbaaff00f

struct ring_buffer {
    volatile uint16_t ring_head;
    volatile uint16_t ring_tail;
    struct {
           uint16_t pin_value;
           uint16_t delta_t;
    } buffer[NUM_RING_ENTRIES];
};

/* the command is at the start of shared DPRAM */
#define RBUFF        ((volatile struct ring_buffer *)DPRAM_SHARED)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      /*
 * testpru
 *
 */

#define PRU0
#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <stdio.h>
#include <strings.h>

#include "linux_types.h"
#include "pru_defs.h"
#include "prucomm.h"


void add_to_ring_buffer(uint8_t v, uint16_t deltat)
{
    RBUFF->buffer[RBUFF->ring_tail].pin_value = v;
    RBUFF->buffer[RBUFF->ring_tail].delta_t = deltat;
    RBUFF->ring_tail = (RBUFF->ring_tail + 1) % NUM_RING_ENTRIES;
}

static inline u32 read_PIEP_COUNT(void)
{
    return PIEP_COUNT;
}

uint32_t read_pin(void){
    return ((__R31&(1<<15)) != 0);
}

void main()
{
     uint32_t last_time_us = 0;
     uint8_t last_pin_value = 0;
     
     /*PRU Initialisation*/
     PRUCFG_SYSCFG &= ~SYSCFG_STANDBY_INIT;
     PRUCFG_SYSCFG = (PRUCFG_SYSCFG &
             ~(SYSCFG_IDLE_MODE_M | SYSCFG_STANDBY_MODE_M)) |
             SYSCFG_IDLE_MODE_NO | SYSCFG_STANDBY_MODE_NO;

     /* our PRU wins arbitration */
     PRUCFG_SPP |=  SPP_PRU1_PAD_HP_EN;
    
    /* configure timer */
    PIEP_GLOBAL_CFG = GLOBAL_CFG_DEFAULT_INC(1) |
              GLOBAL_CFG_CMP_INC(1);
    PIEP_CMP_STATUS = CMD_STATUS_CMP_HIT(1); /* clear the interrupt */
        PIEP_CMP_CMP1   = 0x0;
    PIEP_CMP_CFG |= CMP_CFG_CMP_EN(1);
        PIEP_GLOBAL_CFG |= GLOBAL_CFG_CNT_ENABLE;

     
     RBUFF->ring_tail = 20;
     while (1) {
        uint32_t v;
        while ((v=read_pin()) == last_pin_value) {
          // noop
        }
        uint32_t now = read_PIEP_COUNT()/200;
        uint32_t delta_time_us = now - last_time_us;
        last_time_us = now;

        add_to_ring_buffer(last_pin_value, delta_time_us);
        last_pin_value = v;
     }
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ELF              Ä  @'  à'      4    ( ) ( À $€ `$áà! ñîî! á$‘áá$ 4ñáá  4á€ÿ.á $€! áî@œ$áá 1!á! áááÁ $ à$î$! áî $!Dá€!Lá!@ñîî!@á! ñîî ! á!ñá $! ñááhğááò N$Ø $˜@$× $—€,$Ö $–À9$Õ $• ¿$9  $ñ $ 1óîñó i’0á’0á A !0 á˜0á—0áÓ $“ $ô9	óôó –3 á•3áññ	ğğ99Ñ $‘  $€1áÖ¯º$–ğ$–1 á•1ñğááÓ $“l $”ÿ.  $òòÉ2ÿ.÷ $ø÷òòøõ÷ÿ$÷ò÷÷ Q× $— $÷ô÷ ùòîù iîîòşşò0 áòîh:‘òø øòõø iîîòşşò’7ñ’0á—7 ñò÷ò’0á’0 ñ’3 á’0ñ’3áğğôôóóÛg–1 á1ÌáÒî WĞ1$ -$÷ïğ ÿ.’ÿ.Ó1$“ -$î É”! ñ˜!ñ™!ñ ˆ !ôôø àà ğğ õïôãõÑØ1$˜ -$øõ`óõõ÷ôô”! áîÉ”!ñ˜!ñ™!ñ ˜ !ôôø ààğğõïôÎõÑóõ`óõõ÷ôô”!áîÉ”!ñ˜!ñ™! ñ ¦ !ôôø ààğğõïô»õÑóõ`óõõ÷ôô”!áîÉ”!$ñ˜!(ñ™!,ñ ´ !ôôø ààğğõïô¨õÑóõ`óõõ÷ôô”!$áîÉ”!0ñ˜!4ñ™!8ñ Â !ôôø ààğğõïô•õÑóõ`óõõ÷ôô”!0áîÉ”!<ñ˜!@ñ™!Dñ Ğ !ôôø ààğğõïô‚õÑóõ`óõõ÷ôô”!<áîÉ”!Hñ˜!Lñ™!Pñ Ş !ôôø ààğğõïôoõÑóõ`óõõ÷ôô”!HáîÉ”!Tñ˜!Xñ™!\ñ ì !ôôø ààğğõïô\õÑóõ`óõõ÷ôô”!TáîÉ”!`ñ˜!dñ™!hñ ú !ôôø ààğğõïôIõÑóõ`óõõ÷ôô”!`áî	É”!lñ˜!pñ™!tñ !ôôø àà	ğğ	õïô6õÑóõ`óõõ÷ôô”!láî
É”!xñ˜!|ñ™!€ñ !ôôø àà
ğğ
õïô#õÑóõ`óõõ÷ôô”!xáîÉ”!„ñ˜!ˆñ™!Œñ $!ôôø ààğğõïôõÑóõ`÷ôô”!„áïòşğïğïÿ$şğï:‘Ğğ$¯º$’1 ñğòVğ÷ïğ× -!ìàÏôôù ààòò $!Ùà
Ïôôù àà
òò
 !Æà	Ïôôù àà	òò	 !³àÏôôù ààòò ú ! àÏôôù ààòò ì !àÏôôù ààòò Ş !zàÏôôù ààòò Ğ !gàÏôôù ààòò Â !TàÏôôù ààòò ´ !AàÏôôù ààòò ¦ !.àÏôôù ààòò ˜ !à Ïôôù àà òò  ˆ !À  $€ $âàÃ  #Ãv#Ãx# w!      Ã                        Ğ        boot.c     /sim/sds10/releasevalidation/PRU/200b2/build/product/linux/lib/src TI PRU C/C++ Codegen Unix v2.0.0B2 Copyright (c) 2012-2014 Texas Instruments Incorporated     _stack 3  _stack  €    )   *      [   `   e   q      ‡      œ       ­   ²   À   Ê   İ   ã   ê    V   H   boot_special.c J   Ä  Ø  /sim/sds10/releasevalidation/PRU/200b2/build/product/linux/lib/src TI PRU C/C++ Codegen Unix v2.0.0B2 Copyright (c) 2012-2014 Texas Instruments Incorporated Y  _c_int00_noinit_noargs_noexit Ä  Ø  C_c_int00_noinit_noargs_noexit boot_special.c Cboot_special.c HTI Library  main Ğ  abort Ô          exit.c ‘   à  è  /sim/sds10/releasevalidation/PRU/200b2/build/product/linux/lib/src TI PRU C/C++ Codegen Unix v2.0.0B2 Copyright (c) 2012-2014 Texas Instruments Incorporated   loader_exit à  è  3loader_exit exit.c 3exit.c 7TI Library  ä    	   î   exit.c È   Ø  à  /sim/sds10/releasevalidation/PRU/200b2/build/product/linux/lib/src TI PRU C/C++ Codegen Unix v2.0.0B2 Copyright (c) 2012-2014 Texas Instruments Incorporated   abort Ø  à  kabort exit.c kexit.c oTI Library  loader_exit Ø    ¼    C  __TI_internal /media/psf/Home/Documents/Programming/beaglepilot/Tools/Linux_HAL_Essentials/pwmpru TI PRU Linker Unix v2.0.0 Copyright (c) 2012-2014 Texas Instruments Incorporated &        ÿ        boot.c              ÿ          C    %    <        boot_special.c      Ä  Ã ÂJ 3        y        exit.c      à  @ 7        y        exit.c      Ø  x‡   ÿÿÿÿ   	
 !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~€‚ƒ„…       Ä        ÿÿÿÿ   	
 !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~€‚ƒ„…   2  à     A  ÿÿÿÿ   	
 !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~€‚ƒ„…   e  Ø     A%‹@  4 
9:;?I@   %‹@  $ >  ;    %‹@  .9:;?@ƒ@„@…@†@‡@ˆ@@”@  ˆ Š@   %‹@  .9:;@ƒ@„@…@†@‡@ˆ@@”@  ˆ ‰@   %‹@  .9:;?@ƒ@„@…@†@‡@ˆ@@”@  ˆ Š@    %‹@    TI PRU C/C++ Codegen Unix v2.0.0B2 Copyright (c) 2012-2014 Texas Instruments Incorporated void bool signed char unsigned char wchar_t short unsigned short int unsigned int long unsigned long long long unsigned long long float double long double     X       Ä                 ²       à                 ¾       Ø                     Ğ   ¶   _stack     0    X  V  Æ   _c_int00_noinit_noargs_noexit         ²    ¾   loader_exit         ¾  	  ¾   abort     é    Ô   €      void    bool !   signed char (   unsigned char /   wchar_t 6   short =   unsigned short D   int K   unsigned int R   long Y   unsigned long `   long long g   unsigned long long n   float u   double |   long double     A   TI    Linker 
   pruabi                                                                                     #             *             1             7            	 C            
 K             T             _             e             z             ˆ             œ             ©    `       ¾    `       Ì    a       à    a       í    à          à          á       '   á       5            A            M            Z            h            s            ‚             ’           ! ¢          ñÿ¬          ²  T        ¸  à        ¾         Ä         Ê  (       Ğ  @       Ö  L       Ü  Œ       ã          ê  ´       ñ         ø          ÿ  <         @         T         `         t       "  x       )  Œ       0  ˜       7  ¬       >  °       E  Ä       L  Ğ       S  ä       Z  è       a  ü       h         o         v          }  4       „  @       ‹  T       ’  X       ™  l          x       §  Œ       ®         µ  ¤       ¼  °       Ã  Ä       Ê  È       Ñ  Ü       Ø  è       ß  ü       æ          í         ô          û  4         8       	  L         X         l         p       %  „       ,         3          :  ¤       A  ´       H  Ô       O  è       V  ü       ]         d  $       k  8       r  L       y  `       €  t       ‡  ˆ         œ       •  °          à      ¾    `                 œ           Z  C        §          ñÿ            5           5  Ô        A           A  *        Z           h           Z  )        ‚            ’          ! °          ñÿÁ  Ä       5  X       A  J        M           Z  H        s           ‚           å          ñÿî  à       ú  Ü          à         Ø       5  ²       5  ¾       A  ‘        A  È        M  2       M  e       Z          Z  î        s           s  @        ‚  Q         ‚  s                   ñÿ(          ñÿ6          ñÿC          ñÿQ         ñÿd         ñÿr   `     ñÿ…         ñÿ”   à     ñÿ¨  ÿÿÿÿ    ñÿ®  ÿÿÿÿ    ñÿ¸         ñÿÈ          ×  ÿÿÿÿ    ñÿâ           ç          ë   `     î   à     ò         ñÿÿ            Ä       $  à       ,  Ø       2         ñÿ<         ñÿK         ñÿ                                                                 .bss .data .rodata .sysmem .stack .cinit .const .args .init_array .farbss .fardata .rofardata .text .creg.C0.noload.near .creg.C0.near .creg.C0.noload.far .creg.C0.far .creg.C4.noload.near .creg.C4.near .creg.C4.noload.far .creg.C4.far .creg.C26.noload.near .creg.C26.near .creg.C26.noload.far .creg.C26.far .debug_info .debug_line .debug_frame .debug_abbrev .debug_str .debug_aranges .debug_pubnames .debug_pubtypes pwmpru1.s $O1$$ $C$L2 $C$L4 $C$L5 $C$L6 $C$L7 $C$L8 $C$L9 $C$L10 $C$L11 $C$L12 $C$L13 $C$L14 $C$L15 $C$L16 $C$L17 $C$L18 $C$L19 $C$L20 $C$L21 $C$L22 $C$L23 $C$L24 $C$L25 $C$L26 $C$L27 $C$L28 $C$L29 $C$L30 $C$L31 $C$L32 $C$L33 $C$L34 $C$L35 $C$L36 $C$L37 $C$L38 $C$L39 $C$L40 $C$L41 $C$L42 $C$L43 $C$L44 $C$L45 $C$L46 $C$L47 $C$L48 $C$L49 $C$L50 $C$L51 $C$L52 $C$L53 $C$L54 $C$L55 $C$L56 $C$L57 $C$L58 $C$L59 $C$L60 $C$L61 $C$L62 $C$L63 $C$L64 $C$L65 $C$L66 $C$L67 $C$L68 $C$L69 $C$L70 $C$L71 $C$L72 $C$L73 .text:main boot.asm boot_special.asm .text:_c_int00_noinit_noargs_noexit exit.asm loader_exit $C$L1 .text:loader_exit .text:abort _lock.asm args_main.asm autoinit.asm __PRU_CREG_C0 __PRU_CREG_BASE_C0 __PRU_CREG_C4 __PRU_CREG_BASE_C4 __PRU_CREG_C26 __PRU_CREG_BASE_C26 binit __binit__ __TI_STACK_SIZE __TI_STACK_END __c_args__ main cfg C4 C26 __TI_c_int00 _stack _c_int00_noinit_noargs_noexit C$$EXIT abort __TI_exit __TI_args_main __TI_auto_init  .bss .data .rodata .sysmem .stack .cinit .const .args .init_array .farbss .fardata .rofardata .text .creg.C0.noload.near .creg.C0.near .creg.C0.noload.far .creg.C0.far .creg.C4.noload.near .creg.C4.near .creg.C4.noload.far .creg.C4.far .creg.C26.noload.near .creg.C26.near .creg.C26.noload.far .creg.C26.far .debug_info .debug_line .debug_frame .debug_abbrev .debug_str .debug_aranges .debug_pubnames .debug_pubtypes __TI_build_attributes .symtab .TI.phattrs .TI.section.flags .TI.section.page .strtab .shstrtab       4           è  è                                       `  `                    à  à                 p                                                                                                             <                                  <                                                                                           #                                     *                                     1                                     7             <                     C                                     K                                     T                                     _             4   è                 e                                     z                                     ˆ                                     œ                                     ©           `                        ¾          `                     Ì           a                        à          a <                     í           à                                 à                               á                        '         á <                     5             <  ‹                 A             Ç                   M             Ê  ˜                 Z             b  R                 h             ´  ö                  s             ª  `                  ‚             
                    ’             ™  í                  ¢    p        †  -                   ¸             ´  à
  '   —          À                                 Ì            ”                     Ş            ®  4                   ï             â  Z                 ÷             <%                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ELF              ,  lD  E      4    ( ) ( àï'à Qàà  !à  $áî'á Qğá 
 !ğ  $àğàïîHî iÿ.  Ã ï iÿ.  Ã ğ  ğÉ0ÿ.ğïğá iï  $  !ïáÿ.ï iá $ï  ïÉ/ÿ.ñáïîğXññá Qîğ`îğîğğ , !ğğîğî , !ààïààoo€á  $aa€ïápïààÿ.ğîHá $ğîHîğîîî	îîáïïøï oáàààÉ ÿ.àîààà	àà
ààîàñ  Ã ââCâ áÀ $€ `$áà! ñîî! á$‘áá$ 4ñáá  4áÀ $€ à$á$  áá $ Dáá  $ Lá @ñáá @á€: ‘àà €: Ä $„  $€ $€á…ÿ.  $àÿæààıàæV:‘ïÈ $Ã  #àåîåîîÀñáÀ	Î $ $ÀÀáàÀñáÀ	Î $ $€áà€ñî€ï,$Ã³ #á g !àï'à Qàà ‡ !à  $áî'á Qğá Œ !ğ  $àğàïîp  Ã î iÿ.  Ã ï iÿ.  Ã ğ  ğÉ0ÿ.ğïğáiîğ`îğîğğ ¢ !ğğîğî ¢ !ààïààoo€á  $aa€ïápïààÿ.ğîHá $ğîHîğîîî	îîáïïøï oîî 
  Ã ââÃB áäîîáääaa€à  $``€áàXîä àïï``€á  $aa€àáXïï Ã‚ #dd€à  $``€äàXîî ÃB ñââ  Ã À  $€ $âàÃE #ÃĞ #ÃÒ # Ñ !      Ã                        Ğ        boot.c     /sim/sds10/releasevalidation/PRU/200b2/build/product/linux/lib/src TI PRU C/C++ Codegen Unix v2.0.0B2 Copyright (c) 2012-2014 Texas Instruments Incorporated     _stack 3  _stack  €    )   *      [   `   e   q      ‡      œ       ­   ²   À   Ê   İ   ã   ê    V   H   boot_special.c J   ,  @  /sim/sds10/releasevalidation/PRU/200b2/build/product/linux/lib/src TI PRU C/C++ Codegen Unix v2.0.0B2 Copyright (c) 2012-2014 Texas Instruments Incorporated Y  _c_int00_noinit_noargs_noexit ,  @  C_c_int00_noinit_noargs_noexit boot_special.c Cboot_special.c HTI Library  main 8  abort <          divu_c.c ‘   /sim/sds10/releasevalidation/PRU/200b2/build/product/linux/lib/src TI PRU C/C++ Codegen Unix v2.0.0B2 Copyright (c) 2012-2014 Texas Instruments Incorporated Ü   __lmbd   __lmbd        PR0_b0 QR0_b1 RR0_b2 SR0_b3 TR1_b0 UR1_b1 VR1_b2 WR1_b3 XR2_b0 YR2_b1 ZR2_b2 [R2_b3 \R3_b0 ]R3_b1 ^R3_b2 _R3_b3 `R4_b0 aR4_b1 bR4_b2 cR4_b3 dR5_b0 eR5_b1 fR5_b2 gR5_b3 hR6_b0 iR6_b1 jR6_b2 kR6_b3 lR7_b0 mR7_b1 nR7_b2 oR7_b3  R8_b0 !R8_b1 "R8_b2 #R8_b3 $R9_b0 %R9_b1 &R9_b2 'R9_b3 (R10_b0 )R10_b1 *R10_b2 +R10_b3 ,R11_b0 -R11_b1 .R11_b2 /R11_b3 0R12_b0 1R12_b1 2R12_b2 3R12_b3 4R13_b0 5R13_b1 6R13_b2 7R13_b3 8R14_b0 9R14_b1 :R14_b2 ;R14_b3 <R15_b0 =R15_b1 >R15_b2 ?R15_b3 @R16_b0 AR16_b1 BR16_b2 CR16_b3 DR17_b0 ER17_b1 FR17_b2 GR17_b3 HR18_b0 IR18_b1 JR18_b2 KR18_b3 LR19_b0 MR19_b1 NR19_b2 OR19_b3 PR20_b0 QR20_b1 RR20_b2 SR20_b3 TR21_b0 UR21_b1 VR21_b2 WR21_b3 XR22_b0 YR22_b1 ZR22_b2 [R22_b3 \R23_b0 ]R23_b1 ^R23_b2 _R23_b3 `R24_b0 aR24_b1 bR24_b2 cR24_b3 dR25_b0 eR25_b1 fR25_b2 gR25_b3 hR26_b0 iR26_b1 jR26_b2 kR26_b3 lR27_b0 mR27_b1 nR27_b2 oR27_b3 pR28_b0 qR28_b1 rR28_b2 sR28_b3 tR29_b0 uR29_b1 vR29_b2 wR29_b3 xR30_b0 yR30_b1 zR30_b2 {R30_b3 |R31_b0 }R31_b1 ~R31_b2 R31_b3     Û   divu_c.c ±         /sim/sds10/releasevalidation/PRU/200b2/build/product/linux/lib/src TI PRU C/C++ Codegen Unix v2.0.0B2 Copyright (c) 2012-2014 Texas Instruments Incorporated   __pruabi_divu       
9  __pruabi_divu divu_c.c 9
divu_c.c ]TI Library  8dividend   dividend <divisor   divisor 8src1   src1 Ttest   test Tnum32   num32 Dfirst_div   first_div Pshift   shift @den   den 8num   num <divisor   divisor 8dividend   dividend 8   D          L  exit.c T  H  P  /sim/sds10/releasevalidation/PRU/200b2/build/product/linux/lib/src TI PRU C/C++ Codegen Unix v2.0.0B2 Copyright (c) 2012-2014 Texas Instruments Incorporated   loader_exit H  P  3loader_exit exit.c 3exit.c 7TI Library  L    	     exit.c ‹  @  H  /sim/sds10/releasevalidation/PRU/200b2/build/product/linux/lib/src TI PRU C/C++ Codegen Unix v2.0.0B2 Copyright (c) 2012-2014 Texas Instruments Incorporated   abort @  H  kabort exit.c kexit.c oTI Library  loader_exit @    ò   ò  remi_c.c Æ  /sim/sds10/releasevalidation/PRU/200b2/build/product/linux/lib/src TI PRU C/C++ Codegen Unix v2.0.0B2 Copyright (c) 2012-2014 Texas Instruments Incorporated   PR0_b0 QR0_b1 RR0_b2 SR0_b3 TR1_b0 UR1_b1 VR1_b2 WR1_b3 XR2_b0 YR2_b1 ZR2_b2 [R2_b3 \R3_b0 ]R3_b1 ^R3_b2 _R3_b3 `R4_b0 aR4_b1 bR4_b2 cR4_b3 dR5_b0 eR5_b1 fR5_b2 gR5_b3 hR6_b0 iR6_b1 jR6_b2 kR6_b3 lR7_b0 mR7_b1 nR7_b2 oR7_b3  R8_b0 !R8_b1 "R8_b2 #R8_b3 $R9_b0 %R9_b1 &R9_b2 'R9_b3 (R10_b0 )R10_b1 *R10_b2 +R10_b3 ,R11_b0 -R11_b1 .R11_b2 /R11_b3 0R12_b0 1R12_b1 2R12_b2 3R12_b3 4R13_b0 5R13_b1 6R13_b2 7R13_b3 8R14_b0 9R14_b1 :R14_b2 ;R14_b3 <R15_b0 =R15_b1 >R15_b2 ?R15_b3 @R16_b0 AR16_b1 BR16_b2 CR16_b3 DR17_b0 ER17_b1 FR17_b2 GR17_b3 HR18_b0 IR18_b1 JR18_b2 KR18_b3 LR19_b0 MR19_b1 NR19_b2 OR19_b3 PR20_b0 QR20_b1 RR20_b2 SR20_b3 TR21_b0 UR21_b1 VR21_b2 WR21_b3 XR22_b0 YR22_b1 ZR22_b2 [R22_b3 \R23_b0 ]R23_b1 ^R23_b2 _R23_b3 `R24_b0 aR24_b1 bR24_b2 cR24_b3 dR25_b0 eR25_b1 fR25_b2 gR25_b3 hR26_b0 iR26_b1 jR26_b2 kR26_b3 lR27_b0 mR27_b1 nR27_b2 oR27_b3 pR28_b0 qR28_b1 rR28_b2 sR28_b3 tR29_b0 uR29_b1 vR29_b2 wR29_b3 xR30_b0 yR30_b1 zR30_b2 {R30_b3 |R31_b0 }R31_b1 ~R31_b2 R31_b3  ä     remi_c.c æ  Ì  ,  /sim/sds10/releasevalidation/PRU/200b2/build/product/linux/lib/src TI PRU C/C++ Codegen Unix v2.0.0B2 Copyright (c) 2012-2014 Texas Instruments Incorporated ç  __pruabi_remi Ì  ,  &  __pruabi_remi remi_c.c &remi_c.c 1TI Library 8dividend   dividend <divisor   divisor <u_divisor   u_divisor 8u_dividend   u_dividend 8remainder   remainder <divisor ­  divisor `dividend ­  dividend __pruabi_remu   (       –  remu_c.c 1  /sim/sds10/releasevalidation/PRU/200b2/build/product/linux/lib/src TI PRU C/C++ Codegen Unix v2.0.0B2 Copyright (c) 2012-2014 Texas Instruments Incorporated Ü   __lmbd   __lmbd        PR0_b0 QR0_b1 RR0_b2 SR0_b3 TR1_b0 UR1_b1 VR1_b2 WR1_b3 XR2_b0 YR2_b1 ZR2_b2 [R2_b3 \R3_b0 ]R3_b1 ^R3_b2 _R3_b3 `R4_b0 aR4_b1 bR4_b2 cR4_b3 dR5_b0 eR5_b1 fR5_b2 gR5_b3 hR6_b0 iR6_b1 jR6_b2 kR6_b3 lR7_b0 mR7_b1 nR7_b2 oR7_b3  R8_b0 !R8_b1 "R8_b2 #R8_b3 $R9_b0 %R9_b1 &R9_b2 'R9_b3 (R10_b0 )R10_b1 *R10_b2 +R10_b3 ,R11_b0 -R11_b1 .R11_b2 /R11_b3 0R12_b0 1R12_b1 2R12_b2 3R12_b3 4R13_b0 5R13_b1 6R13_b2 7R13_b3 8R14_b0 9R14_b1 :R14_b2 ;R14_b3 <R15_b0 =R15_b1 >R15_b2 ?R15_b3 @R16_b0 AR16_b1 BR16_b2 CR16_b3 DR17_b0 ER17_b1 FR17_b2 GR17_b3 HR18_b0 IR18_b1 JR18_b2 KR18_b3 LR19_b0 MR19_b1 NR19_b2 OR19_b3 PR20_b0 QR20_b1 RR20_b2 SR20_b3 TR21_b0 UR21_b1 VR21_b2 WR21_b3 XR22_b0 YR22_b1 ZR22_b2 [R22_b3 \R23_b0 ]R23_b1 ^R23_b2 _R23_b3 `R24_b0 aR24_b1 bR24_b2 cR24_b3 dR25_b0 eR25_b1 fR25_b2 gR25_b3 hR26_b0 iR26_b1 jR26_b2 kR26_b3 lR27_b0 mR27_b1 nR27_b2 oR27_b3 pR28_b0 qR28_b1 rR28_b2 sR28_b3 tR29_b0 uR29_b1 vR29_b2 wR29_b3 xR30_b0 yR30_b1 zR30_b2 {R30_b3 |R31_b0 }R31_b1 ~R31_b2 R31_b3  ã   Ô  remu_c.c Q    Ì  /sim/sds10/releasevalidation/PRU/200b2/build/product/linux/lib/src TI PRU C/C++ Codegen Unix v2.0.0B2 Copyright (c) 2012-2014 Texas Instruments Incorporated æ  __pruabi_remu   Ì  
9  __pruabi_remu remu_c.c 9
remu_c.c [TI Library  8dividend   dividend <divisor   divisor 8src1   src1 Ttest   test Pshift   shift @den   den 8num   num <divisor ¯  divisor 8dividend ¯  dividend 8  D  P  È    Ç    E  __TI_internal /media/psf/Home/Documents/Programming/beaglepilot/ardupilot/Tools/Linux_HAL_Essentials/rcinpru TI PRU Linker Unix v2.0.0 Copyright (c) 2012-2014 Texas Instruments Incorporated &        ÿ        boot.c              ÿ          C    %    <        boot_special.c      ,  Ã ÂJ         ÿ          Ÿ        8        divu_c.c          9y	€~}E	€~}RG~~E€	líí·ïEGGFE})}
HGQE·EG§‚
 3        y        exit.c      H  @ 7        y        exit.c      @  x‡         ÿ          G                remi_c.c      Ì  &c”)”*)         ÿ                  A        remu_c.c        Fy	’~N	’~[PNN’PON)
QPQNÒNP¹’   ÿÿÿÿ   	
 !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~€‚ƒ„…       ,        ÿÿÿÿ   	
 !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~€‚ƒ„…   2        M
BA
Bs  ÿÿÿÿ   	
 !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~€‚ƒ„…   m  H     A  ÿÿÿÿ   	
 !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~€‚ƒ„…      @     A  ÿÿÿÿ   	
 !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~€‚ƒ„…'   Ó  Ì  `   AA‘’“TÎÏĞÑÒÓA A  ÿÿÿÿ   	
 !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~€‚ƒ„…        Ä   L
AA
BA
B^%‹@  4 
9:;?I@   %‹@  $ >  ;    %‹@  .9:;?@ƒ@„@…@†@‡@ˆ@@”@  ˆ Š@    I  %‹@  & I  .<?I@  ‚ 
    
I@  %‹@  .9:;?I@ƒ@„@…@†@‡@ˆ@@”@  4 
I@  ˆ ‰@   %‹@  .9:;@ƒ@„@…@†@‡@ˆ@@”@  ˆ ‰@   %‹@  .9:;?@ƒ@„@…@†@‡@ˆ@@”@  ˆ Š@   %‹@  & I  ‚ 
    
I@  %‹@  .9:;?I@ƒ@„@…@†@‡@ˆ@@”@  4 
I@  ˆ Š@  ˆ ‰@    I  %‹@  & I  .<?I@  ‚ 
    
I@  %‹@  .9:;?I@ƒ@„@…@†@‡@ˆ@@”@  4 
I@  ˆ ‰@    %‹@    TI PRU C/C++ Codegen Unix v2.0.0B2 Copyright (c) 2012-2014 Texas Instruments Incorporated void bool signed char unsigned char wchar_t short unsigned short int unsigned int long unsigned long long long unsigned long long float double long double     X       ,                 Ì                         Ü
       H                 è       @                 ë       Ì  `               í         Ä                   Ğ   ¶   _stack     0    X  V  Æ   _c_int00_noinit_noargs_noexit          Ì    À   __pruabi_divu         Ü
    ¾   loader_exit         è  	  ¾   abort          ë  ä  À   __pruabi_remi          í  ã  À   __pruabi_remu     é    Ô   €      void    bool !   signed char (   unsigned char /   wchar_t 6   short =   unsigned short D   int K   unsigned int R   long Y   unsigned long `   long long g   unsigned long long n   float u   double |   long double     A   TI    Linker 
   pruabi                                                                                        #             *             1             7            	 C            
 K             T             _             e             z             ˆ             œ             ©    `       ¾    `       Ì    a       à    a       í    à          à          á       '   á       5            A            M            Z            h            s            ‚             ’           ! ¢          ñÿ­  œ          à      ¾    `      ³         Z  E        ¾          ñÿ            5           5  Ô        A           A  *        Z           h           Z  )        ‚            ’          ! Ç          ñÿØ  ,       5  X       A  J        M           Z  H        s           ‚           ü          ñÿ­                      $          (          4          <        %  H        +  T        1  d        7  h        >  t        E  €        L  Œ        S           Z  ¬        a  °        h  È        o  Ô        v  Ü        }  ì        „  ü        ‹           5  ²       5  Ì       A  ‘        A  ±        M  2       Z          Z  Û        s           ‚  Q         Ÿ          ñÿ¨  H       ­  D       ´  H       Æ  @       5  Ü
       5  è       A  T       A  ‹       M  m       M          Z  L       Z         s  @        s  `        ‚  u         ‚  —         Ò          ñÿÜ          ñÿ­  ğ                          ç  Ì       5  õ       5  ë       A  Æ       A  æ       M  Ó       Z  ò       Z         s  €        ‚  ³         û          ñÿ­                    ,         0         <         H       %  T       +  `       1  x       7  „       >  ˆ       E          L  ¬       S  ´       Z  Ä                5  Ó       5  í       A  1       A  Q       M          Z  –       Z  Ô       s           ‚  ×                   ñÿ(          ñÿ5          ñÿC         ñÿV         ñÿd   `     ñÿw         ñÿ†   à     ñÿš  ÿÿÿÿ    ñÿ   ÿÿÿÿ    ñÿª         ñÿº          É  ÿÿÿÿ    ñÿÔ         Ù   `     Ü   à     à         ñÿí          ô  ,                     H       (  @       .         ñÿ8  Ì       F         T         ñÿc         ñÿ                                                                  .bss .data .rodata .sysmem .stack .cinit .const .args .init_array .farbss .fardata .rofardata .text .creg.C0.noload.near .creg.C0.near .creg.C0.noload.far .creg.C0.far .creg.C4.noload.near .creg.C4.near .creg.C4.noload.far .creg.C4.far .creg.C26.noload.near .creg.C26.near .creg.C26.noload.far .creg.C26.far .debug_info .debug_line .debug_frame .debug_abbrev .debug_str .debug_aranges .debug_pubnames .debug_pubtypes rcinpru0.s $C$L1 .text:main boot.asm boot_special.asm .text:_c_int00_noinit_noargs_noexit divu_c.asm $C$L2 $C$L3 $C$L4 $C$L5 $C$L6 $C$L7 $C$L8 $C$L9 $C$L10 $C$L11 $C$L12 $C$L13 $C$L14 $C$L15 $C$L16 $C$L17 $C$L18 $C$L19 $C$L20 $C$L21 .text:__pruabi_divu exit.asm loader_exit .text:loader_exit .text:abort _lock.asm remi_c.asm .text:__pruabi_remi remu_c.asm .text:__pruabi_remu args_main.asm autoinit.asm __PRU_CREG_C0 __PRU_CREG_BASE_C0 __PRU_CREG_C4 __PRU_CREG_BASE_C4 __PRU_CREG_C26 __PRU_CREG_BASE_C26 binit __binit__ __TI_STACK_SIZE __TI_STACK_END __c_args__ main C4 C26 __TI_c_int00 _stack _c_int00_noinit_noargs_noexit __pruabi_divu C$$EXIT abort __TI_exit __pruabi_remi __pruabi_remu __TI_args_main __TI_auto_init  .bss .data .rodata .sysmem .stack .cinit .const .args .init_array .farbss .fardata .rofardata .text .creg.C0.noload.near .creg.C0.near .creg.C0.noload.far .creg.C0.far .creg.C4.noload.near .creg.C4.near .creg.C4.noload.far .creg.C4.far .creg.C26.noload.near .creg.C26.near .creg.C26.noload.far .creg.C26.far .debug_info .debug_line .debug_frame .debug_abbrev .debug_str .debug_aranges .debug_pubnames .debug_pubtypes __TI_build_attributes .symtab .TI.phattrs .TI.section.flags .TI.section.page .strtab .shstrtab       4           P  P           „                          „   `  `                 „   à  à                 p„                                                                              ¤                                  ¤                                  ¤                                                                       „                    #                                     *                                     1                                     7             ¤                     C                                     K                                     T                                     _             4   P                 e                                     z                                     ˆ                                     œ                                     ©           `                        ¾          ` „                    Ì           a                        à          a ¤                     í           à                                 à „                              á                        '         á ¤                     5             ¤  Ÿ                 A             C!  ä                 M             '$  _                 Z             †+  T                 h             Ú.  ö                  s             Ğ/  À                  ‚             0  û                  ’             ‹1  í                  ¢    p        x2  -                   ¸             ¨2     '   —          À            „                     Ì            ¨=                     Ş            Â=  4                   ï             ö=  r                 ÷             hB                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               #include <Pozyx.h>
#include <Pozyx_definitions.h>

#include <SoftwareSerial.h>
#include <Wire.h>

////////////////// Pozyx Prams //////////////////////////////
#define CONFIG_TX_GAIN 33.5f

#define NUM_ANCHORS 4
// the network id of the anchors: change these to the network ids of your anchors.
uint16_t anchor_id[4] = { 0x601C, // (0,0)
                          0x6020, // x-axis
                          0x6057, // y-axis
                          0x605E};     

// only required for manual anchor calibration. 
// Please change this to the coordinates measured for the anchors
int32_t anchors_x[NUM_ANCHORS] = {0,     10000, 0,     10000};    // anchor x-coorindates in mm (horizontal)
int32_t anchors_y[NUM_ANCHORS] = {0,     0,     10000, 10000};    // anchor y-coordinates in mm (vertical)
int32_t heights[NUM_ANCHORS] =   {-1200, -1200, -1200, -1200};    // anchor z-coordinates in mm (1.2m above vehicle's starting altitude)

// RX TX serial for flight controller ex) Pixhawk
// https://github.com/PaulStoffregen/AltSoftSerial
SoftwareSerial fcboardSerial(10, 11); // rx, tx

#define MSG_HEADER          0x01
#define MSGID_BEACON_CONFIG 0x02
#define MSGID_BEACON_DIST   0x03
#define MSGID_POSITION      0x04

// structure for messages uploaded to ardupilot
union beacon_config_msg {
    struct {
        uint8_t beacon_id;
        uint8_t beacon_count;
        int32_t x;
        int32_t y;
        int32_t z;
    } info;
    uint8_t buf[14];
};
union beacon_distance_msg {
    struct {
        uint8_t beacon_id;
        uint32_t distance;
    } info;
    uint8_t buf[5];
};
union vehicle_position_msg {
    struct {
        int32_t x;
        int32_t y;
        int32_t z;
        int16_t position_error;
    } info;
    uint8_t buf[14];
};
////////////////////////////////////////////////

void setup()
{
    Serial.begin(115200);
    fcboardSerial.begin(115200);

    if (Pozyx.begin() == POZYX_FAILURE) {
        Serial.println(("ERR: shield"));
        delay(100);
        abort();
    }

    Serial.println(("V1.0"));

    // clear all previous devices in the device list
    Pozyx.clearDevices();

    // configure beacons
    while (!configure_beacons()) {
        delay(1000);
    }

    // if the automatic anchor calibration is unsuccessful, try manually setting the anchor coordinates.
    // fot this, you must update the arrays anchors_x, anchors_y and heights above
    // comment out the doAnchorCalibration block and the if-statement above if you are using manual mode
    SetAnchorsManual();

    print_anchor_coordinates();

    Serial.println(("Waiting.."));
    delay(5000);

    Serial.println(("Starting: "));
}

void loop()
{
    static uint32_t loop_start = 0;
    static uint8_t stage = 0;   // 0 = initialisation, 1 = normal flight
    static uint16_t beacon_sent_count = 0;
    static uint32_t beacon_sent_time = 0;

    // initialise start time
    if (loop_start == 0) {
        loop_start = millis();
    }

    // advance to normal flight stage after 1min
    if (stage == 0) {
        uint32_t time_diff =  (millis() - loop_start);
        if (time_diff > 60000) {
            stage = 1;
            Serial.println("Stage1");
        }
    }

    // slow down counter
    static uint8_t counter = 0;
    counter++;
    if (counter >= 20) {
        counter = 0;
    }

    // during stage 0 (init) send position and beacon config as quickly as possible
    // during stage 1 send about every 2 seconds
    if (stage == 0 || counter == 0) {
        send_beacon_config();
        get_position();
        if (beacon_sent_count > 0 && beacon_sent_time != 0) {
            uint32_t time_diff = millis() - beacon_sent_time;
            float hz = (float)beacon_sent_count / (time_diff / 1000.0f);
            Serial.print("Beacon hz:");
            Serial.println(hz);
        }
        beacon_sent_count = 0;
        beacon_sent_time = millis();
    }

    // send beacon distances
    get_ranges();
    beacon_sent_count++;
}

uint32_t time_start_ms;
void timer_start()
{
    time_start_ms = millis();
}
void timer_end()
{
    uint32_t time_diff = millis() - time_start_ms;
    Serial.print("ms:");
    Serial.println(time_diff);
}

void print_comma()
{  
    Serial.print(",");
}

void print_tab()
{  
    Serial.print("\t");
}

// set a tag or anchor's gain
//   set tag_id to zero to set local device's gain
//   returns true on success
bool set_device_gain(uint16_t dev_id, float gain)
{
    float tx_power = -1;

    // get/set transmit power of tag
    bool gain_ok = false;
    uint8_t retry = 0;
    while (!gain_ok && retry < 5) {
        if (Pozyx.getTxPower(&tx_power, dev_id) == POZYX_SUCCESS) {
            if (tx_power != gain) {
                Pozyx.setTxPower(CONFIG_TX_GAIN, dev_id);
            } else {
                gain_ok = true;
            }
        }
        retry++;
    }

    // display final gain
    Serial.print("Dev ");
    Serial.print(dev_id, HEX);
    Serial.print(" gain ");
    if (tx_power > 0) {
        Serial.print(tx_power);
    } else {
        Serial.print("unknown");
    }
    Serial.print(" (retry ");
    Serial.print(retry);
    Serial.print(")");
    Serial.println();

    return gain_ok;
}

// performs repeated calls to get reliable distance between devices
bool get_remote_range(uint16_t dev1, uint16_t dev2, int32_t& range)
{
    // set distances between tags
    uint32_t range_tot = 0;
    uint16_t count = 0;
    device_range_t dev_range;
    for (uint8_t i=0; i <= 10; i++) {
        // origin to 1st
        if (Pozyx.doRemoteRanging(dev1, dev2, &dev_range) == POZYX_SUCCESS) {
            range_tot += dev_range.distance;
            count++;
        }
        if (Pozyx.doRemoteRanging(dev2, dev1, &dev_range) == POZYX_SUCCESS) {
            range_tot += dev_range.distance;
            count++;
        }
    }
    // success if at least 5 successful ranges were retrieved
    if (count > 5) {
        range = range_tot / count;
        return true;
    }
    return false;
}

void print_failed_to_range(uint16_t dev1, uint16_t dev2)
{  
    Serial.print("ranging fail ");
    Serial.print(dev1,HEX);
    Serial.print(" to ");
    Serial.println(dev2,HEX);
}

void set_beacon_position(uint8_t index, int32_t x_mm, int32_t y_mm, int32_t z_mm)
{
    anchors_x[index] = x_mm;
    anchors_y[index] = y_mm;
    heights[index] = z_mm;
}

// configure beacons
bool configure_beacons()
{
    bool configured_ok = true;

    // get/set transmit power of tag
    if (!set_device_gain(0, CONFIG_TX_GAIN)) {
        configured_ok = false;
    }

    // set transmit power of beacons    
    for (uint8_t i=0; i < NUM_ANCHORS; i++) {
        if (!set_device_gain(anchor_id[i], CONFIG_TX_GAIN)) {
            configured_ok = false;
        }
    }

    // set distances between tags
    int32_t x_range = 0, y_range = 0;
    // origin to x-axis (i.e. bottom right)
    if (get_remote_range(anchor_id[0], anchor_id[1], x_range)) {
        set_beacon_position(1, x_range, 0, heights[1]);
    } else {
        print_failed_to_range(anchor_id[0], anchor_id[1]);
        configured_ok = false;
    }
    // origin to y-axis (i.e. top left)
    if (get_remote_range(anchor_id[0], anchor_id[2], y_range)) {
        set_beacon_position(2, 0, y_range, heights[2]);
    } else {
        print_failed_to_range(anchor_id[0], anchor_id[2]);
        configured_ok = false;
    }
    // top right
    if (x_range != 0 && y_range != 0) {
        set_beacon_position(3, x_range, y_range, heights[3]);
    } else {
        Serial.println("beacons too close");
        configured_ok = false;
    }

    if (configured_ok) {
        Serial.println("Beacon Configuration complete");
    } else {
        Serial.println("Beacon Configuration failed!");
    }

    return configured_ok;
}

// function to manually set the anchor coordinates
void SetAnchorsManual()
{
    for (uint8_t i=0; i<NUM_ANCHORS; i++) {
        device_coordinates_t anchor;
        anchor.network_id = anchor_id[i];
        anchor.flag = 0x1; 
        anchor.pos.x = anchors_x[i];
        anchor.pos.y = anchors_y[i];
        anchor.pos.z = heights[i];
        Pozyx.addDevice(anchor);
    }
}

// print coordinates to the serial monitor
void print_coordinates(coordinates_t coor, pos_error_t pos_error)
{  
    Serial.print("Pos x:");
    Serial.print(coor.x);
    print_tab();
    Serial.print("y:");
    Serial.print(coor.y);
    print_tab();
    Serial.print("z:");
    Serial.print(coor.z);
    Serial.print(" err x:");
    Serial.print(pos_error.x);
    Serial.print(" y:");
    Serial.print(pos_error.y);
    Serial.println(); 
}

// print out the anchor coordinates
void print_anchor_coordinates()
{
  uint8_t list_size;
  int status;

  status = Pozyx.getDeviceListSize(&list_size);
  Serial.print("list: ");
  Serial.println(status*list_size);

  // print error if no anchors are setup
  if (list_size == 0) {
    Serial.println("No Anchors");
    Serial.println(Pozyx.getSystemError());
    return;
  }

  // retrieve anchor information
  uint16_t device_ids[list_size];
  status &= Pozyx.getDeviceIds(device_ids,list_size);

  Serial.print("Anchors found: ");
  Serial.println(list_size);

  coordinates_t anchor_coor;
  
  for (int i=0; i<list_size; i++) {
    Serial.print("A0x");
    Serial.print(device_ids[i], HEX);
    print_comma();
    status = Pozyx.getDeviceCoordinates(device_ids[i], &anchor_coor);
    Serial.print(anchor_coor.x);
    print_comma();
    Serial.print(anchor_coor.y);
    print_comma();
    Serial.println(anchor_coor.z);
  }    
}

// get ranges for each anchor
void get_ranges()
{
    // get range for each anchor
    device_range_t range;
    bool success = false;
    for (uint8_t i=0; i<NUM_ANCHORS; i++) {
        if (Pozyx.doRanging(anchor_id[i], &range) == POZYX_SUCCESS) {
            // send info to ardupilot
            send_beacon_distance(i, range.distance);
            success = true;
        }
    }

    // display errors
    if (!success) {
        Serial.println("failed to get any ranges");
    }
}

// get position of tag
void get_position()
{
    coordinates_t position;
    pos_error_t pos_error;

    //if (Pozyx.doPositioning(&position, POZYX_2_5D, 0) == POZYX_SUCCESS) {
    if (Pozyx.doPositioning(&position, POZYX_3D, 0, 0x00) == POZYX_SUCCESS) {
        if (Pozyx.getPositionError(&pos_error) == POZYX_SUCCESS) {
            // display position
            print_coordinates(position, pos_error);
            // send to ardupilot
            send_vehicle_position(position, pos_error);
        }
    } else {
        // display errors
        Serial.println("failed to calc position");
    }
}

// send all beacon config to ardupilot
void send_beacon_config()
{
    beacon_config_msg msg;
    msg.info.beacon_count = NUM_ANCHORS;
    for (uint8_t i=0; i<NUM_ANCHORS; i++) {
        msg.info.beacon_id = i;
        msg.info.x = anchors_x[i];
        msg.info.y = anchors_y[i];
        msg.info.z = heights[i];
        send_message(MSGID_BEACON_CONFIG, sizeof(msg.buf), msg.buf);
    }
    Serial.println("Sent anchor info");
}

// send a beacon's distance to ardupilot
void send_beacon_distance(uint8_t beacon_id, uint32_t distance_mm)
{
    beacon_distance_msg msg;
    msg.info.beacon_id = beacon_id;
    msg.info.distance = distance_mm;
    send_message(MSGID_BEACON_DIST, sizeof(msg.buf), msg.buf);
}

// send vehicle's position to ardupilot
void send_vehicle_position(coordinates_t& position, pos_error_t& pos_error)
{
    vehicle_position_msg msg;

    // sanity check position
    if (position.x == 0 || position.y == 0) {
        return;
    }

    msg.info.x = position.x;
    msg.info.y = position.y;
    //msg.info.z = position.z;
    msg.info.z = 0;
    msg.info.position_error = pos_error.xy;
    send_message(MSGID_POSITION, sizeof(msg.buf), msg.buf);
}

void send_message(uint8_t msg_id, uint8_t data_len, uint8_t data_buf[])
{
    // sanity check
    if (data_len == 0) {
        return;
    }

    // message is buffer length + 1 (for checksum)
    uint8_t msg_len = data_len+1;

    // calculate checksum and place in last element of array
    uint8_t checksum = 0;
    checksum ^= msg_id;
    checksum ^= msg_len;
    for (uint8_t i=0; i<data_len; i++) {
        checksum = checksum ^ data_buf[i];
    }

    // send message
    int16_t num_sent = 0;
    num_sent += fcboardSerial.write(MSG_HEADER);
    num_sent += fcboardSerial.write(msg_id);
    num_sent += fcboardSerial.write(msg_len);
    num_sent += fcboardSerial.write(data_buf, data_len);
    num_sent += fcboardSerial.write(&checksum, 1);
    fcboardSerial.flush();
}

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  #!/usr/bin/env python

"""
Extract version information for the various vehicle types, print it

AP_FLAKE8_CLEAN

"""

import os
import re
import sys

from optparse import OptionParser

parser = OptionParser("print_version.py [options] ArduCopter|ArduPlane|Rover|AntennaTracker")

(opts, args) = parser.parse_args()

includefiles = {
    "ArduCopter": "version.h",
    "ArduPlane": "version.h",
    "Rover": "version.h",
    "AntennaTracker": "version.h",
    "ArduSub": "version.h",
}

if len(args) > 0:
    vehicle = args[0]
    if vehicle not in includefiles:
        print("Unknown vehicle (%s) (be in a vehicle directory or supply a vehicle type as an argument)" % (vehicle,))
        sys.exit(1)
    includefilepath = "%s/%s" % (vehicle, includefiles[vehicle])
else:
    # assume we are in e.g. APM/Rover/
    vehicle = os.path.basename(os.getcwd())
    if vehicle not in includefiles:
        print("Unknown vehicle (%s) (be in a vehicle directory or supply a vehicle type as an argument)" % (vehicle,))
        sys.exit(1)
    includefilepath = includefiles[vehicle]


file = open(includefilepath)

firmware_version_regex = re.compile(r".*define +FIRMWARE_VERSION.*")
firmware_version_extract_regex = re.compile(r".*define +FIRMWARE_VERSION[	 ]+(?P<major>\d+)[ ]*,[ 	]*(?P<minor>\d+)[ ]*,[	 ]*(?P<point>\d+)[ ]*,[	 ]*(?P<type>[A-Z_]+)[	 ]*")  # noqa: E501

for line in file:
    if not firmware_version_regex.match(line):
        continue
    match = firmware_version_extract_regex.match(line)
    if not match:
        print("Failed to match FIRMWARE_VERSION line (%s)" % (line,))
        sys.exit(1)
    print("%d.%d.%d-%s" % (int(match.group("major")),
                           int(match.group("minor")),
                           int(match.group("point")),
                           match.group("type")))
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    #!/usr/bin/env python
'''
run Replay over a set of logs to check for code regressions
'''

import optparse, os, sys

parser = optparse.OptionParser("CheckLogs")
parser.add_option("--logdir", type='string', default='testlogs', help='directory of logs to use')
parser.add_option("--create-checked-logs", action='store_true', default=False, help="created logs with CHEK messages")
parser.add_option("--tolerance-euler", type=float, default=3, help="tolerance for euler angles in degrees");
parser.add_option("--tolerance-pos", type=float, default=2, help="tolerance for position angles in meters");
parser.add_option("--tolerance-vel", type=float, default=2, help="tolerance for velocity in meters/second");

opts, args = parser.parse_args()

def run_cmd(cmd, dir=".", show=False, output=False, checkfail=True):
    '''run a shell command'''
    from subprocess import call, check_call,Popen, PIPE
    if show:
        print("Running: '%s' in '%s'" % (cmd, dir))
    if output:
        return Popen([cmd], shell=True, stdout=PIPE, cwd=dir).communicate()[0]
    elif checkfail:
        return check_call(cmd, shell=True, cwd=dir)
    else:
        return call(cmd, shell=True, cwd=dir)

def run_replay(logfile):
    '''run Replay on one logfile'''
    print("Processing %s" % logfile)
    cmd = "./Replay.elf -- --check %s --tolerance-euler=%f --tolerance-pos=%f --tolerance-vel=%f " % (
        logfile,
        opts.tolerance_euler,
        opts.tolerance_pos,
        opts.tolerance_vel)
    run_cmd(cmd, checkfail=False)

def get_log_list():
    '''get a list of log files to process'''
    import glob, sys
    pattern = os.path.join(opts.logdir, "*-checked.bin")
    file_list = glob.glob(pattern)
    print("Found %u logs to processs" % len(file_list))
    if len(file_list) == 0:
        print("No logs to process matching %s" % pattern)
        sys.exit(1)
    return file_list

def create_html_results():
    '''create a HTML file with results'''
    error_count = 0

    git_version = run_cmd('git log --pretty=oneline HEAD~1..HEAD', output=True)
    
    f = open("replay_results.html", "w")
    f.write(
'''<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html lang="en" xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Replay results</title>
<meta charset="utf-8"/>
</head>
<body>
<h1>Replay Results</h1>
Git version: %s
<p>
<table border="1">
<tr bgcolor="lightgrey">
 <th>Filename</th>
 <th>RollError(deg)</th>
 <th>PitchError(deg)</th>
 <th>YawError(deg)</th>
 <th>PosError(m)</th>
 <th>VelError(m/s)</th>
</tr>
''' % git_version)
    infile = open("replay_results.txt", "r")

    line_count = 0
    line_errors = 0
    
    for line in infile:
        line = line.strip()
        line_count += 1
        a = line.split("\t")
        if len(a) != 6:
            print("Invalid line: %s" % line)
            error_count += 1
            continue
        tolerances = [opts.tolerance_euler,
                      opts.tolerance_euler,
                      opts.tolerance_euler,
                      opts.tolerance_pos,
                      opts.tolerance_vel]
        f.write('''<tr><td><a href="%s">%s</a></td>''' % (a[0],a[0]))
        error_in_this_log = False
        for i in range(1,6):
            tol = tolerances[i-1]
            if a[i] == "FPE":
                bgcolor = "red"
                error_count += 1
                error_in_this_log = True
            elif float(a[i]) > tol:
                bgcolor = "red"
                error_count += 1
                error_in_this_log = True
            else:
                bgcolor = "white"
            f.write('''<td bgcolor="%s" align="right">%s</td>\n''' % (bgcolor, a[i]))

        if error_in_this_log:
            line_errors += 1
        f.write('''</tr>\n''')

    f.write('''</table>\n''')

    # write summary
    f.write(
'''<h2>Summary</h2>
<p>Processed %u logs<br/>
%u errors from %u logs<br/>
<hr>
<p>Tolerance Euler: %.3f degrees<br/>
Tolerance Position: %.3f meters<br/>
Tolerance Velocity: %.3f meters/second
''' % (line_count, error_count, line_errors,
       opts.tolerance_euler,
       opts.tolerance_pos,
       opts.tolerance_vel))

    # add trailer
    f.write(
'''
</body>
</html>
''')
    f.close()
    infile.close()

def check_logs():
    '''run log checking'''
    log_list = get_log_list()

    # remove old results file
    try:
        os.unlink("replay_results.txt")
    except Exception as ex:
        print(ex)

    for logfile in log_list:
        run_replay(logfile)

    create_html_results()

def create_checked_logs():
    '''create a set of CHEK logs'''
    import glob, sys
    if os.path.isfile(opts.logdir):
        full_file_list = [opts.logdir]
    else:
        pattern = os.path.join(opts.logdir, "*.bin")
        full_file_list = glob.glob(pattern)
    file_list = []
    for f in full_file_list:
        if not f.endswith("-checked.bin"):
            file_list.append(f)
    if len(file_list) == 0:
        print("No files to process")
        sys.exit(1)
    for f in file_list:
        print("Processing %s" % f)
        log_list_current = set(glob.glob("logs/*.BIN"))
        cmd = "./Replay.elf -- --check-generate %s" % f
        run_cmd(cmd, checkfail=True)
        log_list_after = set(glob.glob("logs/*.BIN"))
        changed = log_list_after.difference(log_list_current)
        if len(changed) != 1:
            print("Failed to generate log for %s" % f)
            sys.exit(1)
        outlog = list(changed)[0]
        name, ext = os.path.splitext(f)
        newname = name + '-checked.bin'
        os.rename(outlog, newname)
        print("Created %s" % newname)

if opts.create_checked_logs:
    create_checked_logs()
    sys.exit(0)

check_logs()
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          #include "DataFlashFileReader.h"
#include <AP_Filesystem/AP_Filesystem.h>

#include <fcntl.h>
#include <string.h>
#include <sys/types.h>
#include <stdio.h>
#include <unistd.h>
#include <time.h>
#include <cinttypes>

#ifndef PRIu64
#define PRIu64 "llu"
#endif

AP_LoggerFileReader::AP_LoggerFileReader()
{}

AP_LoggerFileReader::~AP_LoggerFileReader()
{
    ::printf("Replay counts: %" PRIu64 " bytes  %u entries\n", bytes_read, message_count);
}

bool AP_LoggerFileReader::open_log(const char *logfile)
{
    fd = AP::FS().open(logfile, O_RDONLY);
    if (fd == -1) {
        return false;
    }
    return true;
}

ssize_t AP_LoggerFileReader::read_input(void *buffer, const size_t count)
{
    uint64_t ret = AP::FS().read(fd, buffer, count);
    bytes_read += ret;
    return ret;
}

void AP_LoggerFileReader::format_type(uint16_t type, char dest[5])
{
    const struct log_Format &f = formats[type];
    memset(dest,0,5);
    if (f.length == 0) {
        return;
    }
    strncpy(dest, f.name, 4);
}
void AP_LoggerFileReader::get_packet_counts(uint64_t dest[])
{
    memcpy(dest, packet_counts, sizeof(packet_counts));
}

bool AP_LoggerFileReader::update()
{
    uint8_t hdr[3];
    if (read_input(hdr, 3) != 3) {
        return false;
    }
    if (hdr[0] != HEAD_BYTE1 || hdr[1] != HEAD_BYTE2) {
        printf("bad log header\n");
        return false;
    }

#if CONFIG_HAL_BOARD == HAL_BOARD_CHIBIOS
    // running on stm32 is slow enough it is nice to see progress
    if (message_count % 500 == 0) {
        ::printf("line %u pkt 0x%02x t=%u\n", message_count, hdr[2], AP_HAL::millis());
    }
#endif
    packet_counts[hdr[2]]++;

    if (hdr[2] == LOG_FORMAT_MSG) {
        struct log_Format f;
        memcpy(&f, hdr, 3);
        if (read_input(&f.type, sizeof(f)-3) != sizeof(f)-3) {
            return false;
        }
        memcpy(&formats[f.type], &f, sizeof(formats[f.type]));

        message_count++;
        return handle_log_format_msg(f);
    }

    const struct log_Format &f = formats[hdr[2]];
    if (f.length == 0) {
        // can't just throw these away as the format specifies the
        // number of bytes in the message
        ::printf("No format defined for type (%d)\n", hdr[2]);
        exit(1);
    }

    uint8_t msg[f.length];

    memcpy(msg, hdr, 3);
    if (read_input(&msg[3], f.length-3) != f.length-3) {
        return false;
    }

    message_count++;
    return handle_msg(f, msg);
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            #pragma once

#include <AP_Logger/AP_Logger.h>

#define LOGREADER_MAX_FORMATS 255 // must be >= highest MESSAGE

class AP_LoggerFileReader
{
public:

    AP_LoggerFileReader();
    ~AP_LoggerFileReader();

    bool open_log(const char *logfile);
    bool update();

    virtual bool handle_log_format_msg(const struct log_Format &f) = 0;
    virtual bool handle_msg(const struct log_Format &f, uint8_t *msg) = 0;

    void format_type(uint16_t type, char dest[5]);
    void get_packet_counts(uint64_t dest[]);

protected:
    int fd = -1;

    struct log_Format formats[LOGREADER_MAX_FORMATS] {};

private:
    ssize_t read_input(void *buf, size_t count);

    uint64_t bytes_read = 0;
    uint32_t message_count = 0;
    uint64_t start_micros;

    uint64_t packet_counts[LOGREADER_MAX_FORMATS] = {};
};
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           #include "LR_MsgHandler.h"
#include "LogReader.h"
#include "Replay.h"

#include <AP_DAL/AP_DAL.h>

#include <cinttypes>

extern const AP_HAL::HAL& hal;

#define MSG_CREATE(sname,msgbytes) log_ ##sname msg; memcpy((void*)&msg, (msgbytes)+3, sizeof(msg));

LR_MsgHandler::LR_MsgHandler(struct log_Format &_f) :
    MsgHandler(_f) {
}

void LR_MsgHandler_RFRH::process_message(uint8_t *msgbytes)
{
    MSG_CREATE(RFRH, msgbytes);
    AP::dal().handle_message(msg);
}

void LR_MsgHandler_RFRF::process_message(uint8_t *msgbytes)
{
    MSG_CREATE(RFRF, msgbytes);
#define MAP_FLAG(flag1, flag2) if (msg.frame_types & uint8_t(flag1)) msg.frame_types |= uint8_t(flag2)
    /*
      when we force an EKF we map the trigger flags over
     */
    if (replay_force_ekf2) {
        MAP_FLAG(AP_DAL::FrameType::InitialiseFilterEKF3, AP_DAL::FrameType::InitialiseFilterEKF2);
        MAP_FLAG(AP_DAL::FrameType::UpdateFilterEKF3, AP_DAL::FrameType::UpdateFilterEKF2);
        MAP_FLAG(AP_DAL::FrameType::LogWriteEKF3, AP_DAL::FrameType::LogWriteEKF2);
    }
    if (replay_force_ekf3) {
        MAP_FLAG(AP_DAL::FrameType::InitialiseFilterEKF2, AP_DAL::FrameType::InitialiseFilterEKF3);
        MAP_FLAG(AP_DAL::FrameType::UpdateFilterEKF2, AP_DAL::FrameType::UpdateFilterEKF3);
        MAP_FLAG(AP_DAL::FrameType::LogWriteEKF2, AP_DAL::FrameType::LogWriteEKF3);
    }
#undef MAP_FLAG
    AP::dal().handle_message(msg, ekf2, ekf3);
}

void LR_MsgHandler_RFRN::process_message(uint8_t *msgbytes)
{
    MSG_CREATE(RFRN, msgbytes);
    AP::dal().handle_message(msg);
}

void LR_MsgHandler_REV2::process_message(uint8_t *msgbytes)
{
    MSG_CREATE(REV2, msgbytes);

    switch ((AP_DAL::Event)msg.event) {

    case AP_DAL::Event::resetGyroBias:
        ekf2.resetGyroBias();
        break;
    case AP_DAL::Event::resetHeightDatum:
        ekf2.resetHeightDatum();
        break;
    case AP_DAL::Event::setTerrainHgtStable:
        ekf2.setTerrainHgtStable(true);
        break;
    case AP_DAL::Event::unsetTerrainHgtStable:
        ekf2.setTerrainHgtStable(false);
        break;
    case AP_DAL::Event::requestYawReset:
        ekf2.requestYawReset();
        break;
    case AP_DAL::Event::checkLaneSwitch:
        ekf2.checkLaneSwitch();
        break;
    case AP_DAL::Event::setSourceSet0 ... AP_DAL::Event::setSourceSet2:
        break;
    }
    if (replay_force_ekf3) {
        LR_MsgHandler_REV3 h{f, ekf2, ekf3};
        h.process_message(msgbytes);
    }
}

void LR_MsgHandler_RSO2::process_message(uint8_t *msgbytes)
{
    MSG_CREATE(RSO2, msgbytes);
    Location loc;
    loc.lat = msg.lat;
    loc.lng = msg.lng;
    loc.alt = msg.alt;
    ekf2.setOriginLLH(loc);

    if (replay_force_ekf3) {
        LR_MsgHandler_RSO2 h{f, ekf2, ekf3};
        h.process_message(msgbytes);
    }
}

void LR_MsgHandler_RWA2::process_message(uint8_t *msgbytes)
{
    MSG_CREATE(RWA2, msgbytes);
    ekf2.writeDefaultAirSpeed(msg.airspeed);
    if (replay_force_ekf3) {
        LR_MsgHandler_RWA2 h{f, ekf2, ekf3};
        h.process_message(msgbytes);
    }
}


void LR_MsgHandler_REV3::process_message(uint8_t *msgbytes)
{
    MSG_CREATE(REV3, msgbytes);

    switch ((AP_DAL::Event)msg.event) {

    case AP_DAL::Event::resetGyroBias:
        ekf3.resetGyroBias();
        break;
    case AP_DAL::Event::resetHeightDatum:
        ekf3.resetHeightDatum();
        break;
    case AP_DAL::Event::setTerrainHgtStable:
        ekf3.setTerrainHgtStable(true);
        break;
    case AP_DAL::Event::unsetTerrainHgtStable:
        ekf3.setTerrainHgtStable(false);
        break;
    case AP_DAL::Event::requestYawReset:
        ekf3.requestYawReset();
        break;
    case AP_DAL::Event::checkLaneSwitch:
        ekf3.checkLaneSwitch();
        break;
    case AP_DAL::Event::setSourceSet0 ... AP_DAL::Event::setSourceSet2:
        ekf3.setPosVelYawSourceSet(uint8_t(msg.event)-uint8_t(AP_DAL::Event::setSourceSet0));
        break;
    }

    if (replay_force_ekf2) {
        LR_MsgHandler_REV2 h{f, ekf2, ekf3};
        h.process_message(msgbytes);
    }
}

void LR_MsgHandler_RSO3::process_message(uint8_t *msgbytes)
{
    MSG_CREATE(RSO3, msgbytes);
    Location loc;
    loc.lat = msg.lat;
    loc.lng = msg.lng;
    loc.alt = msg.alt;
    ekf3.setOriginLLH(loc);
    if (replay_force_ekf2) {
        LR_MsgHandler_RSO2 h{f, ekf2, ekf3};
        h.process_message(msgbytes);
    }
}

void LR_MsgHandler_RWA3::process_message(uint8_t *msgbytes)
{
    MSG_CREATE(RWA3, msgbytes);
    ekf3.writeDefaultAirSpeed(msg.airspeed, msg.uncertainty);
    if (replay_force_ekf2) {
        LR_MsgHandler_RWA2 h{f, ekf2, ekf3};
        h.process_message(msgbytes);
    }
}

void LR_MsgHandler_REY3::process_message(uint8_t *msgbytes)
{
    MSG_CREATE(REY3, msgbytes);
    ekf3.writeEulerYawAngle(msg.yawangle, msg.yawangleerr, msg.timestamp_ms, msg.type);
}

void LR_MsgHandler_RISH::process_message(uint8_t *msgbytes)
{
    MSG_CREATE(RISH, msgbytes);
    AP::dal().handle_message(msg);
}
void LR_MsgHandler_RISI::process_message(uint8_t *msgbytes)
{
    MSG_CREATE(RISI, msgbytes);
    AP::dal().handle_message(msg);
}

void LR_MsgHandler_RASH::process_message(uint8_t *msgbytes)
{
    MSG_CREATE(RASH, msgbytes);
    AP::dal().handle_message(msg);
}
void LR_MsgHandler_RASI::process_message(uint8_t *msgbytes)
{
    MSG_CREATE(RASI, msgbytes);
    AP::dal().handle_message(msg);
}

void LR_MsgHandler_RBRH::process_message(uint8_t *msgbytes)
{
    MSG_CREATE(RBRH, msgbytes);
    AP::dal().handle_message(msg);
}

void LR_MsgHandler_RBRI::process_message(uint8_t *msgbytes)
{
    MSG_CREATE(RBRI, msgbytes);
    AP::dal().handle_message(msg);
}

void LR_MsgHandler_RRNH::process_message(uint8_t *msgbytes)
{
    MSG_CREATE(RRNH, msgbytes);
    AP::dal().handle_message(msg);
}

void LR_MsgHandler_RRNI::process_message(uint8_t *msgbytes)
{
    MSG_CREATE(RRNI, msgbytes);
    AP::dal().handle_message(msg);
}

void LR_MsgHandler_RGPH::process_message(uint8_t *msgbytes)
{
    MSG_CREATE(RGPH, msgbytes);
    AP::dal().handle_message(msg);
}

void LR_MsgHandler_RGPI::process_message(uint8_t *msgbytes)
{
    MSG_CREATE(RGPI, msgbytes);
    AP::dal().handle_message(msg);
}

void LR_MsgHandler_RGPJ::process_message(uint8_t *msgbytes)
{
    MSG_CREATE(RGPJ, msgbytes);
    AP::dal().handle_message(msg);
}

void LR_MsgHandler_RMGH::process_message(uint8_t *msgbytes)
{
    MSG_CREATE(RMGH, msgbytes);
    AP::dal().handle_message(msg);
}

void LR_MsgHandler_RMGI::process_message(uint8_t *msgbytes)
{
    MSG_CREATE(RMGI, msgbytes);
    AP::dal().handle_message(msg);
}

void LR_MsgHandler_RBCH::process_message(uint8_t *msgbytes)
{
    MSG_CREATE(RBCH, msgbytes);
    AP::dal().handle_message(msg);
}

void LR_MsgHandler_RBCI::process_message(uint8_t *msgbytes)
{
    MSG_CREATE(RBCI, msgbytes);
    AP::dal().handle_message(msg);
}

void LR_MsgHandler_RVOH::process_message(uint8_t *msgbytes)
{
    MSG_CREATE(RVOH, msgbytes);
    AP::dal().handle_message(msg);
}

void LR_MsgHandler_ROFH::process_message(uint8_t *msgbytes)
{
    MSG_CREATE(ROFH, msgbytes);
    AP::dal().handle_message(msg, ekf2, ekf3);
}

void LR_MsgHandler_RWOH::process_message(uint8_t *msgbytes)
{
    MSG_CREATE(RWOH, msgbytes);
    AP::dal().handle_message(msg, ekf2, ekf3);
}

void LR_MsgHandler_RBOH::process_message(uint8_t *msgbytes)
{
    MSG_CREATE(RBOH, msgbytes);
    AP::dal().handle_message(msg, ekf2, ekf3);
}

void LR_MsgHandler_REPH::process_message(uint8_t *msgbytes)
{
    MSG_CREATE(REPH, msgbytes);
    AP::dal().handle_message(msg, ekf2, ekf3);
}

void LR_MsgHandler_RSLL::process_message(uint8_t *msgbytes)
{
    MSG_CREATE(RSLL, msgbytes);
    AP::dal().handle_message(msg, ekf2, ekf3);
}

void LR_MsgHandler_REVH::process_message(uint8_t *msgbytes)
{
    MSG_CREATE(REVH, msgbytes);
    AP::dal().handle_message(msg, ekf2, ekf3);
}

#include <AP_AHRS/AP_AHRS.h>
#include "VehicleType.h"

bool LR_MsgHandler_PARM::set_parameter(const char *name, const float value)
{
    const char *ignore_parms[] = {
        "LOG_FILE_BUFSIZE",
        "LOG_DISARMED"
    };
    for (uint8_t i=0; i < ARRAY_SIZE(ignore_parms); i++) {
        if (strncmp(name, ignore_parms[i], AP_MAX_NAME_SIZE) == 0) {
            ::printf("Ignoring set of %s to %f\n", name, value);
            return true;
        }
    }

    return LogReader::set_parameter(name, value);
}

void LR_MsgHandler_PARM::process_message(uint8_t *msg)
{
    const uint8_t parameter_name_len = AP_MAX_NAME_SIZE + 1; // null-term
    char parameter_name[parameter_name_len];

    require_field(msg, "Name", parameter_name, parameter_name_len);

    float value = require_field_float(msg, "Value");
    set_parameter(parameter_name, value);
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        #pragma once

#include "MsgHandler.h"
#include <AP_AHRS/AP_AHRS.h>
#include <AP_GPS/AP_GPS.h>
#include <AP_NavEKF2/AP_NavEKF2.h>
#include <AP_NavEKF3/AP_NavEKF3.h>

class LR_MsgHandler : public MsgHandler {
public:
    LR_MsgHandler(struct log_Format &f);
    virtual void process_message(uint8_t *msg) = 0;
    virtual void process_message(uint8_t *msg, uint8_t &core) {
        // base implementation just ignores the core parameter;
        // subclasses can override to fill the core in if they feel
        // like it.
        process_message(msg);
    }
};

class LR_MsgHandler_RFRH : public LR_MsgHandler
{
public:
    using LR_MsgHandler::LR_MsgHandler;
    void process_message(uint8_t *msg) override;
};

class LR_MsgHandler_EKF : public LR_MsgHandler
{
public:
    LR_MsgHandler_EKF(struct log_Format &_f, NavEKF2 &_ekf2, NavEKF3 &_ekf3) :
        LR_MsgHandler(_f),
        ekf2(_ekf2),
        ekf3(_ekf3) {}
    using LR_MsgHandler::LR_MsgHandler;
    virtual void process_message(uint8_t *msg) override = 0;
protected:
    NavEKF2 &ekf2;
    NavEKF3 &ekf3;
};

class LR_MsgHandler_RFRF : public LR_MsgHandler_EKF
{
    using LR_MsgHandler_EKF::LR_MsgHandler_EKF;
    void process_message(uint8_t *msg) override;
};

class LR_MsgHandler_ROFH : public LR_MsgHandler_EKF
{
    using LR_MsgHandler_EKF::LR_MsgHandler_EKF;
    void process_message(uint8_t *msg) override;
};

class LR_MsgHandler_REPH : public LR_MsgHandler_EKF
{
    using LR_MsgHandler_EKF::LR_MsgHandler_EKF;
    void process_message(uint8_t *msg) override;
};

class LR_MsgHandler_RSLL : public LR_MsgHandler_EKF
{
    using LR_MsgHandler_EKF::LR_MsgHandler_EKF;
    void process_message(uint8_t *msg) override;
};

class LR_MsgHandler_REVH : public LR_MsgHandler_EKF
{
    using LR_MsgHandler_EKF::LR_MsgHandler_EKF;
    void process_message(uint8_t *msg) override;
};

class LR_MsgHandler_RWOH : public LR_MsgHandler_EKF
{
    using LR_MsgHandler_EKF::LR_MsgHandler_EKF;
    void process_message(uint8_t *msg) override;
};

class LR_MsgHandler_RBOH : public LR_MsgHandler_EKF
{
    using LR_MsgHandler_EKF::LR_MsgHandler_EKF;
    void process_message(uint8_t *msg) override;
};

class LR_MsgHandler_RFRN : public LR_MsgHandler
{
public:
    using LR_MsgHandler::LR_MsgHandler;
    void process_message(uint8_t *msg) override;
};

class LR_MsgHandler_REV2 : public LR_MsgHandler_EKF
{
public:
    using LR_MsgHandler_EKF::LR_MsgHandler_EKF;
    void process_message(uint8_t *msg) override;
};

class LR_MsgHandler_RSO2 : public LR_MsgHandler_EKF
{
public:
    using LR_MsgHandler_EKF::LR_MsgHandler_EKF;
    void process_message(uint8_t *msg) override;
};

class LR_MsgHandler_RWA2 : public LR_MsgHandler_EKF
{
public:
    using LR_MsgHandler_EKF::LR_MsgHandler_EKF;
    void process_message(uint8_t *msg) override;
};


class LR_MsgHandler_REV3 : public LR_MsgHandler_EKF
{
public:
    using LR_MsgHandler_EKF::LR_MsgHandler_EKF;
    void process_message(uint8_t *msg) override;
};

class LR_MsgHandler_RSO3 : public LR_MsgHandler_EKF
{
public:
    using LR_MsgHandler_EKF::LR_MsgHandler_EKF;
    void process_message(uint8_t *msg) override;
};

class LR_MsgHandler_RWA3 : public LR_MsgHandler_EKF
{
public:
    using LR_MsgHandler_EKF::LR_MsgHandler_EKF;
    void process_message(uint8_t *msg) override;
};

class LR_MsgHandler_REY3 : public LR_MsgHandler_EKF
{
public:
    using LR_MsgHandler_EKF::LR_MsgHandler_EKF;
    void process_message(uint8_t *msg) override;
};

class LR_MsgHandler_RISH : public LR_MsgHandler
{
public:
    using LR_MsgHandler::LR_MsgHandler;
    void process_message(uint8_t *msg) override;
};
class LR_MsgHandler_RISI : public LR_MsgHandler
{
public:
    using LR_MsgHandler::LR_MsgHandler;
    void process_message(uint8_t *msg) override;
};
class LR_MsgHandler_RASH : public LR_MsgHandler
{
public:
    using LR_MsgHandler::LR_MsgHandler;
    void process_message(uint8_t *msg) override;
};
class LR_MsgHandler_RASI : public LR_MsgHandler
{
public:
    using LR_MsgHandler::LR_MsgHandler;
    void process_message(uint8_t *msg) override;
};

class LR_MsgHandler_RBRH : public LR_MsgHandler
{
public:
    using LR_MsgHandler::LR_MsgHandler;
    void process_message(uint8_t *msg) override;
};
class LR_MsgHandler_RBRI : public LR_MsgHandler
{
public:
    using LR_MsgHandler::LR_MsgHandler;
    void process_message(uint8_t *msg) override;
};

class LR_MsgHandler_RRNH : public LR_MsgHandler
{
public:
    using LR_MsgHandler::LR_MsgHandler;
    void process_message(uint8_t *msg) override;
};
class LR_MsgHandler_RRNI : public LR_MsgHandler
{
public:
    using LR_MsgHandler::LR_MsgHandler;
    void process_message(uint8_t *msg) override;
};

class LR_MsgHandler_RGPH : public LR_MsgHandler
{
public:
    using LR_MsgHandler::LR_MsgHandler;
    void process_message(uint8_t *msg) override;
};
class LR_MsgHandler_RGPI : public LR_MsgHandler
{
public:
    using LR_MsgHandler::LR_MsgHandler;
    void process_message(uint8_t *msg) override;
};
class LR_MsgHandler_RGPJ : public LR_MsgHandler
{
public:
    using LR_MsgHandler::LR_MsgHandler;
    void process_message(uint8_t *msg) override;
};

class LR_MsgHandler_RMGH : public LR_MsgHandler
{
public:
    using LR_MsgHandler::LR_MsgHandler;
    void process_message(uint8_t *msg) override;
};
class LR_MsgHandler_RMGI : public LR_MsgHandler
{
public:
    using LR_MsgHandler::LR_MsgHandler;
    void process_message(uint8_t *msg) override;
};
class LR_MsgHandler_RBCH : public LR_MsgHandler
{
public:
    using LR_MsgHandler::LR_MsgHandler;
    void process_message(uint8_t *msg) override;
};
class LR_MsgHandler_RBCI : public LR_MsgHandler
{
public:
    using LR_MsgHandler::LR_MsgHandler;
    void process_message(uint8_t *msg) override;
};

class LR_MsgHandler_RVOH : public LR_MsgHandler
{
public:
    using LR_MsgHandler::LR_MsgHandler;
    void process_message(uint8_t *msg) override;
};

class LR_MsgHandler_PARM : public LR_MsgHandler
{
public:
    LR_MsgHandler_PARM(log_Format &_f) :
        LR_MsgHandler(_f)
        {};

    void process_message(uint8_t *msg) override;

private:
    bool set_parameter(const char *name, const float value);
};
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       #include "LogReader.h"

#include "MsgHandler.h"
#include "Replay.h"

#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <signal.h>


#define DEBUG 1
#if DEBUG
# define debug(fmt, args...)     printf(fmt "\n", ##args)
#else
# define debug(fmt, args...)
#endif

#define streq(x, y) (!strcmp(x, y))

extern struct user_parameter *user_parameters;

LogReader::LogReader(struct LogStructure *log_structure, NavEKF2 &_ekf2, NavEKF3 &_ekf3) :
    AP_LoggerFileReader(),
    _log_structure(log_structure),
    ekf2(_ekf2),
    ekf3(_ekf3)
{
}

/*
  see if a type is in a list of types
 */
bool LogReader::in_list(const char *type, const char *list[])
{
    if (list == NULL) {
        return false;
    }
    for (uint8_t i=0; list[i] != NULL; i++) {
        if (strcmp(type, list[i]) == 0) {
            return true;
        }
    }
    return false;
}

bool LogReader::handle_log_format_msg(const struct log_Format &f)
{
    // emit the output as we receive it:
    AP::logger().WriteBlock((void*)&f, sizeof(f));

	char name[5];
	memset(name, '\0', 5);
	memcpy(name, f.name, 4);

    if (msgparser[f.type] != NULL) {
        return true;
    }

    // map from format name to a parser subclass:
	if (streq(name, "PARM")) {
        msgparser[f.type] = NEW_NOTHROW LR_MsgHandler_PARM(formats[f.type]);
    } else if (streq(name, "RFRH")) {
        msgparser[f.type] = NEW_NOTHROW LR_MsgHandler_RFRH(formats[f.type]);
    } else if (streq(name, "RFRF")) {
        msgparser[f.type] = NEW_NOTHROW LR_MsgHandler_RFRF(formats[f.type], ekf2, ekf3);
    } else if (streq(name, "RFRN")) {
        msgparser[f.type] = NEW_NOTHROW LR_MsgHandler_RFRN(formats[f.type]);
    } else if (streq(name, "REV2")) {
        msgparser[f.type] = NEW_NOTHROW LR_MsgHandler_REV2(formats[f.type], ekf2, ekf3);
	} else if (streq(name, "RSO2")) {
        msgparser[f.type] = NEW_NOTHROW LR_MsgHandler_RSO2(formats[f.type], ekf2, ekf3);
	} else if (streq(name, "RWA2")) {
        msgparser[f.type] = NEW_NOTHROW LR_MsgHandler_RWA2(formats[f.type], ekf2, ekf3);
	} else if (streq(name, "REV3")) {
        msgparser[f.type] = NEW_NOTHROW LR_MsgHandler_REV3(formats[f.type], ekf2, ekf3);
	} else if (streq(name, "RSO3")) {
        msgparser[f.type] = NEW_NOTHROW LR_MsgHandler_RSO3(formats[f.type], ekf2, ekf3);
	} else if (streq(name, "RWA3")) {
        msgparser[f.type] = NEW_NOTHROW LR_MsgHandler_RWA3(formats[f.type], ekf2, ekf3);
	} else if (streq(name, "REY3")) {
        msgparser[f.type] = NEW_NOTHROW LR_MsgHandler_REY3(formats[f.type], ekf2, ekf3);
	} else if (streq(name, "RISH")) {
	    msgparser[f.type] = NEW_NOTHROW LR_MsgHandler_RISH(formats[f.type]);
	} else if (streq(name, "RISI")) {
	    msgparser[f.type] = NEW_NOTHROW LR_MsgHandler_RISI(formats[f.type]);
    } else if (streq(name, "RASH")) {
	    msgparser[f.type] = NEW_NOTHROW LR_MsgHandler_RASH(formats[f.type]);
	} else if (streq(name, "RASI")) {
	    msgparser[f.type] = NEW_NOTHROW LR_MsgHandler_RASI(formats[f.type]);
	} else if (streq(name, "RBRH")) {
	    msgparser[f.type] = NEW_NOTHROW LR_MsgHandler_RBRH(formats[f.type]);
	} else if (streq(name, "RBRI")) {
	    msgparser[f.type] = NEW_NOTHROW LR_MsgHandler_RBRI(formats[f.type]);
	} else if (streq(name, "RRNH")) {
	    msgparser[f.type] = NEW_NOTHROW LR_MsgHandler_RRNH(formats[f.type]);
	} else if (streq(name, "RRNI")) {
	    msgparser[f.type] = NEW_NOTHROW LR_MsgHandler_RRNI(formats[f.type]);
	} else if (streq(name, "RGPH")) {
	    msgparser[f.type] = NEW_NOTHROW LR_MsgHandler_RGPH(formats[f.type]);
	} else if (streq(name, "RGPI")) {
	    msgparser[f.type] = NEW_NOTHROW LR_MsgHandler_RGPI(formats[f.type]);
    } else if (streq(name, "RGPJ")) {
        msgparser[f.type] = NEW_NOTHROW LR_MsgHandler_RGPJ(formats[f.type]);
	} else if (streq(name, "RMGH")) {
	    msgparser[f.type] = NEW_NOTHROW LR_MsgHandler_RMGH(formats[f.type]);
	} else if (streq(name, "RMGI")) {
	    msgparser[f.type] = NEW_NOTHROW LR_MsgHandler_RMGI(formats[f.type]);
	} else if (streq(name, "RBCH")) {
	    msgparser[f.type] = NEW_NOTHROW LR_MsgHandler_RBCH(formats[f.type]);
	} else if (streq(name, "RBCI")) {
	    msgparser[f.type] = NEW_NOTHROW LR_MsgHandler_RBCI(formats[f.type]);
    } else if (streq(name, "RVOH")) {
        msgparser[f.type] = NEW_NOTHROW LR_MsgHandler_RVOH(formats[f.type]);
    } else if (streq(name, "ROFH")) {
        msgparser[f.type] = NEW_NOTHROW LR_MsgHandler_ROFH(formats[f.type], ekf2, ekf3);
    } else if (streq(name, "REPH")) {
        msgparser[f.type] = NEW_NOTHROW LR_MsgHandler_REPH(formats[f.type], ekf2, ekf3);
	} else if (streq(name, "RSLL")) {
        msgparser[f.type] = NEW_NOTHROW LR_MsgHandler_RSLL(formats[f.type], ekf2, ekf3);
    } else if (streq(name, "REVH")) {
        msgparser[f.type] = NEW_NOTHROW LR_MsgHandler_REVH(formats[f.type], ekf2, ekf3);
    } else if (streq(name, "RWOH")) {
        msgparser[f.type] = NEW_NOTHROW LR_MsgHandler_RWOH(formats[f.type], ekf2, ekf3);
    } else if (streq(name, "RBOH")) {
        msgparser[f.type] = NEW_NOTHROW LR_MsgHandler_RBOH(formats[f.type], ekf2, ekf3);
	} else {
        // debug("  No parser for (%s)\n", name);
    }

    return true;
}

bool LogReader::handle_msg(const struct log_Format &f, uint8_t *msg) {
    // emit the output as we receive it:
    AP::logger().WriteBlock(msg, f.length);

    LR_MsgHandler *p = msgparser[f.type];
    if (p == NULL) {
        return true;
    }

    p->process_message(msg);

    return true;
}

/*
  see if a user parameter is set
 */
bool LogReader::check_user_param(const char *name)
{
    for (struct user_parameter *u=user_parameters; u; u=u->next) {
        if (strcmp(name, u->name) == 0) {
            return true;
        }
    }
    return false;
}

bool LogReader::set_parameter(const char *name, float value, bool force)
{
    if (!force && check_user_param(name)) {
        // ignore user set parameters
        return false;
    }
    enum ap_var_type var_type;
    AP_Param *vp = AP_Param::find(name, &var_type);
    if (vp == NULL) {
        // a lot of parameters will not be found - e.g. FORMAT_VERSION
        // and all of the vehicle-specific parameters, ....
        return false;
    }
    float old_value = 0;
    if (var_type == AP_PARAM_FLOAT) {
        old_value = ((AP_Float *)vp)->cast_to_float();
        ((AP_Float *)vp)->set(value);
    } else if (var_type == AP_PARAM_INT32) {
        old_value = ((AP_Int32 *)vp)->cast_to_float();
        ((AP_Int32 *)vp)->set(value);
    } else if (var_type == AP_PARAM_INT16) {
        old_value = ((AP_Int16 *)vp)->cast_to_float();
        ((AP_Int16 *)vp)->set(value);
    } else if (var_type == AP_PARAM_INT8) {
        old_value = ((AP_Int8 *)vp)->cast_to_float();
        ((AP_Int8 *)vp)->set(value);
    } else {
        AP_HAL::panic("What manner of evil is var_type=%u", var_type);
    }
    if (fabsf(old_value - value) > 1.0e-12) {
        ::printf("Changed %s to %.8f from %.8f\n", name, value, old_value);
    }
    return true;
}

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                #pragma once

#include "VehicleType.h"
#include "DataFlashFileReader.h"
#include "LR_MsgHandler.h"
#include "Parameters.h"

class LogReader : public AP_LoggerFileReader
{
public:
    LogReader(struct LogStructure *log_structure, NavEKF2 &_ekf, NavEKF3 &_ekf3);

    VehicleType::vehicle_type vehicle;

    static bool check_user_param(const char *name);
    static bool set_parameter(const char *name, float value, bool force=false);

    bool handle_log_format_msg(const struct log_Format &f) override;
    bool handle_msg(const struct log_Format &f, uint8_t *msg) override;

    static bool in_list(const char *type, const char *list[]);

protected:

private:

    NavEKF2 &ekf2;
    NavEKF3 &ekf3;

    struct LogStructure *_log_structure;
    uint8_t _log_structure_count;

    class LR_MsgHandler *msgparser[LOGREADER_MAX_FORMATS] {};
};

// some vars are difficult to get through the layers
struct globals {
    bool no_params;
};

extern struct globals globals;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       