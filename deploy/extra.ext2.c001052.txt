 fix for battery voltage reporting
    - Serial/UART reading performance improvement using readstring binding
    - sport_aerobatics.lua rudder control fixed
    - Thread priority can be set using SCR_THD_PRIORITY (useful for Lua drivers)
    - Wind alignment and head_wind speed bindings
12) Safety related enhancements and fixes
    - Advanced GCS failsafe action to switch to Auto mode
    - Advanced GCS failsafe timeout configurable (see AFS_GCS_TIMEOUT)
    - Arm in AUTO/TAKEOFF modes only after stick returns to center
    - Arm/Disarmed GPIO may be disabled using BRD_OPTIONS
    - Arming allowed with Fence enabled but without a compass (previously failed)
    - Arming check of compass vs world magnetic model to detect metal in ground (see ARMING_MAGTHRESH)
    - Arming check of GPIO pin interrupt storm
    - Arming check of Lua script CRC
    - Arming check of mission loaded from SD card
    - Arming check of Relay pin conflicts
    - Arming check to allow Tricopter-Plane with no yaw servo
    - Arming check of emergency stop skipped if emergency stop aux function configured
    - Arming failures reported more quickly when changing from success to failed
    - ARMING_OPTIONS allows supressing "Armed", "Disarmed" text messages
    - BRD_SAFETY_MASK extended to apply to CAN ESCs and servos
    - Buzzer noise for gyro calibration and arming checks passed
    - FENCE_OPTIONS supports union OR intersection of all polygon fences
    - FLTMODE_GCSBLOCK blocks GCS from changing vehicle to specified modes
    - Long failsafe action to switch to Auto mode (see FS_LONG_ACTN)
    - Main loop lockup recovery by forcing mutex release (only helps if caused by software bug)
    - Parachute releases causes disarm and ICE shutoff
    - Rally points supports altitude frame (AMSL, Relative or Terrain)
    - RC failsafe does not trigger until RC has been received at least once
    - SERVO_RC_FS_MSK allows outputs using RC passthrough to move to SERVOx_TRIM on RC failsafe
    - Takeoff mode gets failsafe protections
13) System Enhancements
    - CAN port can support a second CAN protocol on the same bus (2nd protocol must be 11 bit, see CAN_Dn_PROTOCOL2)
    - CAN-FD support (allows faster data transfer rates)
    - Crash dump info logged if main thread locksup (helps with root cause analysis)
    - Ethernet/Networking support for UDP and TCP server and client (see NET_ENABLED) and PPP (see SERIALx_PROTOCOL)
    - Firmware flashing from SD card
    - Linux board SBUS input decoding made consistent with ChibiOS
    - Linux boards support DroneCAN
    - Parameter defaults stored in @ROMFS/defaults.parm
    - SD Card formatting supported on all boards
    - Second USB endpoint defaults to MAVLink (instead of SLCAN) except on CubePilot boards
    - Serial over DroneCAN (see CAN_D1_UC_SER_EN) useful for configuring F9P DroneCAN GPSs using uCenter
14) Custom Build server include/exclude features extended to include
    - APJ Tools
    - Bootloader flashing
    - Button
    - Compass calibration
    - DroneCAN GPS
    - ExternalAHRS (e.g. MicroStrain, Vectornav)
    - Generator
    - Highmark Servo
    - Hobbywing ESCs
    - Kill IMU
    - Payload Place
    - Plane BlackBox arming allows Plane to be used as logger (see ARMING_BBOX_SPD)
    - Plane's TX Tuning
    - Precision landing
    - Proximity sensor
    - RC Protocol
    - Relay
    - SBUS Output
    - ToneAlarm
    - Winch
15) Developer specific items
    - ChibiOS upgrade to 21.11
    - UAVCAN replaced with DroneCAN
    - AUTOPILOT_VERSION_REQUEST message deprecated (use REQUEST_MESSAGE instead)
    - PREFLIGHT_SET_SENSOR_OFFSETS support deprecated (was unused by all known ground stations)
    - MISSION_SET_CURRENT message deprecated (use DO_SET_MISSION_CURRENT command instead)
    - MISSION_CURRENT message sends num commands and stopped/paused/running/complete state
    - Python version requirement increased to 3.6.9
    - mavlink_parse.py shows all suported mavlink messages
    - COMMAND_INT messages can be used for nearly all commands (previously COMMAND_LONG)
16) Bug fixes:
    - 3DR Solo gimbal mavlink routing fixed
    - Airbrakes auxiliary function fixed
    - Airspeed health always checked before use (may not have been checked when using "affinity")
    - always ignore invalid pilot input throttle
    - Bootloop fixed if INS_GYRO_FILTER set too high
    - Button Internal Error caused by floating pin or slow device power-up fixed
    - CAN Compass order maintained even if compass powered up after autopilot
    - Compass device IDs only saved when calibrated to ensure external compasses appear as primary on new boards
    - Cruise mode locks in heading only once moving forwards (improves VTOL transition reliability in high winds)
    - Currawong ECU EFI does not send exhaust gas temperature
    - DO_REPOSITION interprets NaN as zero
    - DCM fallback in order to get better GPS is disabled if GPS is not used
    - DJI RS2/RS3 gimbal reported angle fix
    - DO_SET_ROI, ROI_LOCATION, ROI_NONE bug fix that could lead to gimbal pointing at old target
    - Fix throttle going bellow min in fbwa RC failsafe
    - Generator parameter init fix (defaults might not always have been loaded correctly)
    - GPS_TC_BLEND parameter removed (it was unused)
    - Ground speed undershoot correction during loss of GPS fixed
    - Guided mode heading control anti windup fix
    - Harmonic Notch gets protection against extremely low notch filter frequencies
    - Home altitude change while navigating handled correctly (previously led to sudden demanded height change)
    - IE 650/800 Generators report fuel remaining
    - INS calibration prevents unlikely case of two calibrations running at same time
    - LPS2XH Baro supported over I2C fixed
    - MatekH743 storage eeprom size fixed
    - MAVLink routing fix to avoid processing packet meant for another vehicle
    - Mount properly enforces user defined angle limits
    - MPU6500 IMU filter corrected to 4k
    - nav_roll (aka target roll) calculation improved
    - NMEA output time and altitude fixed
    - OSD gets labels for all supported serial protocols
    - OSD RF panel format fixed
    - Reset mission if in landing sequence while also disarmed and on the ground (avoids pre-arm check)
    - RTL_AUTOLAND with rally points fix (could skip climb to rally point's altitude)
    - RobotisServo initialisation fix
    - RPM accuracy and time wrap handling improved
    - Sagetech ADSB MXS altitude fix (needs amsl, was sending alt-above-terrain)
    - SageTechMXS ADSB climb rate direction fixed
    - SBUS out exactly matches SBUS in decoding
    - Serial port RTS pins default to pulldown (SiK radios could getting stuck in bootloader mode)
    - SERIALx_ parameters removed for ports that can't actually be used
    - Servo gimbal attitude reporting fix
    - Servo output fix when using scaled RC passthrough (e.g. SERVOx_FUNCTION = RCinXScaled)
    - Siyi continuous zoom stutter fixed
    - Siyi gimbal upside-down mode fixed (avoid bobbing if upside-down)
    - TECS's max deceleration scales properly with vehicle velocity
    - ST24 RC protocol fixed
    - STM32L496 CAN2 init fix (AP_Periph only?)
    - VFR_HUD climb rate reports best estimate during high vibration events (previously it would stop updating)
    - Visual Odometry healthy check fix in case of out-of-memory
    - VTX_MAX_POWER restored (allows setting radio's power)

Release 4.4.4 19th December 2023
--------------------------------

Changes from 4.4.3:

- CubeOrange Sim-on-hardware compilation fix
- RADIX2HD supports external I2C compasses
- SpeedyBeeF405v4 support
- DroneCAN battery monitor with cell monitor SoC reporting fix
- ProfiLED output fixed in both Notify and Scripting
- NTF_LED_TYPES parameter description fixed (was missing IS31FL3195)
- Scripting bug that could cause crash if parameters were added in flight
- STAT_BOOTCNT param fix (was not updating in some cases)
- don't query hobbywing DroneCAN ESC IDs while armed
- clamp empy version to prevent build errors

Release 4.4.3 14th November 2023
--------------------------------

Changes from 4.4.2:

 - fixed setup of ICM45486 IMU on CubeOrangePlus-BG edition
 - disable AFSR on IxM42xxx IMUs to prevent gyro bias for "stuck" gyros
 - fixed AK09916 compass being non-responsive
 - implement GPS_DRV_OPTION for using ellipsoid height in more GPS drivers
 - fixed SIYI AP_Mount parsing bug
 - configuration fixes for BETAFTP-F405 boards
 - fixed origin versus home relative bug in quadplane landing and guided takeoff
 - correct mavlink response for no airspeed sensor on preflight calibration
 - protect against notch filtering with uninitialised RPM source in ESC telemetry
 - allow lua scripts to populate full ESC telemetry data
 - added YJUAV_A6SE_H743 support
 - fixed uBlox M10 GPS support on boards with 1M flash

Release 4.4.2 23th October 2023
-------------------------------

Changes from 4.4.1

- BETAFPV-F405 support
- MambaF405v2 battery and serial setup corrected
- mRo Control Zero OEM H7 bdshot support
- SpeedyBee-F405-Wing gets VTX power control
- SpeedyBee-F405-Mini support
- T-Motor H743 Mini support
- EKF3 supports baroless boards
- INA battery monitor supports config of shunt resistor used (see BATTx_SHUNT)
- BMI088 IMU error value handling fixed to avoid occasional negative spike
- Dev environment CI autotest stability improvements
- OSD correct DisplayPort BF MSP symbols
- OSD option to correct direction arrows for BF font set
- Sensor status reporting to GCS fixed for baroless boards
- added opendroneid option to auto-store IDs in persistent flash
- fixed TECS bug that could cause inability to climb or descend
- fixed race condition when starting TECS controlled mode
- fixed RTL with rally point and terrain follow
- protect against invalid data in SBUS for first 4 channels
- added build type to VER message
- allow moving baseline rover at 3Hz
- use RC deadzones in stick mixing


Release 4.4.1 26th September 2023
---------------------------------

No changes from beta2

Release 4.4.1-beta2 12th September 2023
--------------------------------------

Changes from 4.4.1-beta1

- Airbotf4 features minimised to build for 4.4
- ChibiOS clock fix for 480Mhz H7 boards (affected FDCAN)
- H750 external flash optimisations for to lower CPU load
- MambaF405Mini fixes to match manufacturer's recommended wiring
- RADIX2 HD support
- RPI hardware version check fix
- YJUAV_A6SE support

Release 4.4.1-beta1 5th September 2023
--------------------------------------

Changes from 4.4.1

- support Himark DroneCAN servos
- support Hobbywing DroneCAN ESCs
- fixed control surface deflection on quadplanes in VTOL takeoff wait
- fixed bug in parameter default handling in SITL
- allow selection of mission sdcard storage on custom.ardupilot.org
- added support for SDMODELH7V1
- fixed battery monitor default for QiotekZealotF427 and QiotekZealotH743
- support 8 bit directional dshot channels on KakuteH7-wing
- improved handling of high vibration in EKF3 with new EK3_GLITCH_RADIUS options
- allow reset of battery SoC for DroneCAN battery monitors
- update GPIOs for Navigator board in HAL_Linux
- pull RTS lines low on Pixhawk6C on startup
- added log_file_content in scripting for aerobatics
- added asymmetry factor for skid steering on rovers
- updated defaults for luminousbee5 boards

Happy flying!

Release 4.4.0 18th August 2023
------------------------------

No changes from beta5

Release 4.4.0-beta5 11th August 2023
------------------------------------

Changes from 4.4.0-beta4

- fixed handling of missing DroneCAN airspeed packet
- fixed reset of target altitude in plane GUIDED mode
- added SIYI N7 flight controller
- fixed auto-enable of fence with forced arm
- fixed race condition that caused notch filter gyro glitches
- fixed bug with RTK injection for DroneCAN

Release 4.4.0 beta4
-------------------

Changes from 4.4.0-beta3

1) flight controller specific changes
    - Diatone-Mamba-MK4-H743v2 uses SPL06 baro (was DPS280)
    - DMA for I2C disabled on F7 and H7 boards
    - Foxeer H743v1 default serial protocol config fixes
    - HeeWing-F405 and F405v2 support
    - iFlight BlitzF7 support
2) Scripts may take action based on VTOL motor loss
3) Bug fixes
    - BLHeli returns batter#include "Blimp.h"

/**
 *
 * Detects failures of the ekf or inertial nav system triggers an alert
 * to the pilot and helps take countermeasures
 *
 */

#ifndef EKF_CHECK_ITERATIONS_MAX
# define EKF_CHECK_ITERATIONS_MAX          10      // 1 second (ie. 10 iterations at 10hz) of bad variances signals a failure
#endif

#ifndef EKF_CHECK_WARNING_TIME
# define EKF_CHECK_WARNING_TIME            (30*1000)   // warning text messages are sent to ground no more than every 30 seconds
#endif

////////////////////////////////////////////////////////////////////////////////
// EKF_check structure
////////////////////////////////////////////////////////////////////////////////
static struct {
    uint8_t fail_count;         // number of iterations ekf or dcm have been out of tolerances
    uint8_t bad_variance : 1;   // true if ekf should be considered untrusted (fail_count has exceeded EKF_CHECK_ITERATIONS_MAX)
    uint32_t last_warn_time;    // system time of last warning in milliseconds.  Used to throttle text warnings sent to GCS
} ekf_check_state;

// ekf_check - detects if ekf variance are out of tolerance and triggers failsafe
// should be called at 10hz
void Blimp::ekf_check()
{
    // ensure EKF_CHECK_ITERATIONS_MAX is at least 7
    static_assert(EKF_CHECK_ITERATIONS_MAX >= 7, "EKF_CHECK_ITERATIONS_MAX must be at least 7");

    // exit immediately if ekf has no origin yet - this assumes the origin can never become unset
    Location temp_loc;
    if (!ahrs.get_origin(temp_loc)) {
        return;
    }

    // return immediately if motors are not armed, or ekf check is disabled
    if (!motors->armed() || (g.fs_ekf_thresh <= 0.0f)) {
        ekf_check_state.fail_count = 0;
        ekf_check_state.bad_variance = false;
        AP_Notify::flags.ekf_bad = ekf_check_state.bad_variance;
        failsafe_ekf_off_event();   // clear failsafe
        return;
    }

    // compare compass and velocity variance vs threshold and also check
    // if we are still navigating
    bool is_navigating = ekf_has_relative_position() || ekf_has_absolute_position();
    if (ekf_over_threshold() || !is_navigating) {
        // if compass is not yet flagged as bad
        if (!ekf_check_state.bad_variance) {
            // increase counter
            ekf_check_state.fail_count++;
            if (ekf_check_state.fail_count == (EKF_CHECK_ITERATIONS_MAX-2) && ekf_over_threshold()) {
                // we are two iterations away from declaring an EKF failsafe, ask the EKF if we can reset
                // yaw to resolve the issue
                ahrs.request_yaw_reset();
            }
            if (ekf_check_state.fail_count == (EKF_CHECK_ITERATIONS_MAX-1)) {
                // we are just about to declare a EKF failsafe, ask the EKF if we can
                // change lanes to resolve the issue
                ahrs.check_lane_switch();
            }
            // if counter above max then trigger failsafe
            if (ekf_check_state.fail_count >= EKF_CHECK_ITERATIONS_MAX) {
                // limit count from climbing too high
                ekf_check_state.fail_count = EKF_CHECK_ITERATIONS_MAX;
                ekf_check_state.bad_variance = true;
                LOGGER_WRITE_ERROR(LogErrorSubsystem::EKFCHECK, LogErrorCode::EKFCHECK_BAD_VARIANCE);
                // send message to gcs
                if ((AP_HAL::millis() - ekf_check_state.last_warn_time) > EKF_CHECK_WARNING_TIME) {
                    gcs().send_text(MAV_SEVERITY_CRITICAL,"EKF variance");
                    ekf_check_state.last_warn_time = AP_HAL::millis();
                }
                failsafe_ekf_event();
            }
        }
    } else {
        // reduce counter
        if (ekf_check_state.fail_count > 0) {
            ekf_check_state.fail_count--;

            // if compass is flagged as bad and the counter reaches zero then clear flag
            if (ekf_check_state.bad_variance && ekf_check_state.fail_count == 0) {
                ekf_check_state.bad_variance = false;
                LOGGER_WRITE_ERROR(LogErrorSubsystem::EKFCHECK, LogErrorCode::EKFCHECK_VARIANCE_CLEARED);
                // clear failsafe
                failsafe_ekf_off_event();
            }
        }
    }

    // set AP_Notify flags
    AP_Notify::flags.ekf_bad = ekf_check_state.bad_variance;

    // To-Do: add ekf variances to extended status
}

// ekf_over_threshold - returns true if the ekf's variance are over the tolerance
bool Blimp::ekf_over_threshold()
{
    // return false immediately if disabled
    if (g.fs_ekf_thresh <= 0.0f) {
        return false;
    }

    // use EKF to get variance
    float position_variance, vel_variance, height_variance, tas_variance;
    Vector3f mag_variance;
    ahrs.get_variances(vel_variance, position_variance, height_variance, mag_variance, tas_variance);

    const float mag_max = fmaxf(fmaxf(mag_variance.x,mag_variance.y),mag_variance.z);

    // return true if two of compass, velocity and position variances are over the threshold OR velocity variance is twice the threshold
    uint8_t over_thresh_count = 0;
    if (mag_max >= g.fs_ekf_thresh) {
        over_thresh_count++;
    }

    bool optflow_healthy = false;
    if (!optflow_healthy && (vel_variance >= (2.0f * g.fs_ekf_thresh))) {
        over_thresh_count += 2;
    } else if (vel_variance >= g.fs_ekf_thresh) {
        over_thresh_count++;
    }

    if ((position_variance >= g.fs_ekf_thresh && over_thresh_count >= 1) || over_thresh_count >= 2) {
        return true;
    }

    return false;
}


// failsafe_ekf_event - perform ekf failsafe
void Blimp::failsafe_ekf_event()
{
    // return immediately if ekf failsafe already triggered
    if (failsafe.ekf) {
        return;
    }

    // EKF failsafe event has occurred
    failsafe.ekf = true;
    LOGGER_WRITE_ERROR(LogErrorSubsystem::FAILSAFE_EKFINAV, LogErrorCode::FAILSAFE_OCCURRED);

    // does this mode require position?
    if (!blimp.flightmode->requires_GPS() && (g.fs_ekf_action != FS_EKF_ACTION_LAND_EVEN_MANUAL)) {
        return;
    }

    // take action based on fs_ekf_action parameter
    switch (g.fs_ekf_action) {
    case FS_EKF_ACTION_LAND:
    case FS_EKF_ACTION_LAND_EVEN_MANUAL:
    default:
        set_mode_land_failsafe(ModeReason::EKF_FAILSAFE);
        break;
    }
}

// failsafe_ekf_off_event - actions to take when EKF failsafe is cleared
void Blimp::failsafe_ekf_off_event(void)
{
    // return immediately if not in ekf failsafe
    if (!failsafe.ekf) {
        return;
    }

    failsafe.ekf = false;
    LOGGER_WRITE_ERROR(LogErrorSubsystem::FAILSAFE_EKFINAV, LogErrorCode::FAILSAFE_RESOLVED);
}

// check for ekf yaw reset and adjust target heading, also log position reset
void Blimp::check_ekf_reset()
{
    // check for yaw reset
    float yaw_angle_change_rad;
    uint32_t new_ekfYawReset_ms = ahrs.getLastYawResetAngle(yaw_angle_change_rad);
    if (new_ekfYawReset_ms != ekfYawReset_ms) {
        ekfYawReset_ms = new_ekfYawReset_ms;
        LOGGER_WRITE_EVENT(LogEvent::EKF_YAW_RESET);
    }

    // check for change in primary EKF, reset attitude target and log.  AC_PosControl handles position target adjustment
    if ((ahrs.get_primary_core_index() != ekf_primary_core) && (ahrs.get_primary_core_index() != -1)) {
        ekf_primary_core = ahrs.get_primary_core_index();
        LOGGER_WRITE_ERROR(LogErrorSubsystem::EKF_PRIMARY, LogErrorCode(ekf_primary_core));
        gcs().send_text(MAV_SEVERITY_WARNING, "EKF primary changed:%d", (unsigned)ekf_primary_core);
    }
}

// check for high vibrations affecting altitude control
void Blimp::check_vibration()
{
    uint32_t now = AP_HAL::millis();

    // assume checks will succeed
    bool checks_succeeded = true;

    // check if vertical velocity and position innovations are positive (NKF3.IVD & NKF3.IPD are both positive)
    Vector3f vel_innovation;
    Vector3f pos_innovation;
    Vector3f mag_innovation;
    float tas_innovation;
    float yaw_innovation;
    if (!ahrs.get_innovations(vel_innovation, pos_innovation, mag_innovation, tas_innovation, yaw_innovation)) {
        checks_succeeded = false;
    }
    const bool innov_velD_posD_positive = is_positive(vel_innovation.z) && is_positive(pos_innovation.z);

    // check if vertical velocity variance is at least 1 (NK4.SV >= 1.0)
    float position_variance, vel_variance, height_variance, tas_variance;
    Vector3f mag_variance;
    if (!ahrs.get_variances(vel_variance, position_variance, height_variance, mag_variance, tas_variance)) {
        checks_succeeded = false;
    }

    // if no failure
    if ((g2.fs_vibe_enabled == 0) || !checks_succeeded || !motors->armed() || !innov_velD_posD_positive || (vel_variance < 1.0f)) {
        if (vibration_check.high_vibes) {
            // start clear time
            if (vibration_check.clear_ms == 0) {
                vibration_check.clear_ms = now;
                return;
            }
            // turn off vibration compensation after 15 seconds
            if (now - vibration_check.clear_ms > 15000) {
                // restore ekf gains, reset timers and update user
                vibration_check.high_vibes = false;
                vibration_check.clear_ms = 0;
                LOGGER_WRITE_ERROR(LogErrorSubsystem::FAILSAFE_VIBE, LogErrorCode::FAILSAFE_RESOLVED);
                gcs().send_text(MAV_SEVERITY_CRITICAL, "Vibration compensation OFF");
            }
        }
        vibration_check.start_ms = 0;
        return;
    }

    // start timer
    if (vibration_check.start_ms == 0) {
        vibration_check.start_ms = now;
        vibration_check.clear_ms = 0;
        return;
    }

    // check if failure has persisted for at least 1 second
    if (now - vibration_check.start_ms > 1000) {
        if (!vibration_check.high_vibes) {
            // switch ekf to use resistant gains
            vibration_check.high_vibes = true;
            LOGGER_WRITE_ERROR(LogErrorSubsystem::FAILSAFE_VIBE, LogErrorCode::FAILSAFE_OCCURRED);
            gcs().send_text(MAV_SEVERITY_CRITICAL, "Vibration compensation ON");
        }
    }
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 #include "Blimp.h"

/*
 *       This event will be called when the failsafe changes
 *       boolean failsafe reflects the current state
 */

#include <AP_Vehicle/AP_MultiCopter.h>

bool Blimp::failsafe_option(FailsafeOption opt) const
{
    return (g2.fs_options & (uint32_t)opt);
}

void Blimp::failsafe_radio_on_event()
{
    LOGGER_WRITE_ERROR(LogErrorSubsystem::FAILSAFE_RADIO, LogErrorCode::FAILSAFE_OCCURRED);

    // set desired action based on FS_THR_ENABLE parameter
    Failsafe_Action desired_action;
    switch (g.failsafe_throttle) {
    case FS_THR_DISABLED:
        desired_action = Failsafe_Action_None;
        break;
    case FS_THR_ENABLED_ALWAYS_LAND:
        desired_action = Failsafe_Action_Land;
        break;
    default:
        desired_action = Failsafe_Action_Land;
    }

    // Conditions to deviate from FS_THR_ENABLE selection and send specific GCS warning
    if (should_disarm_on_failsafe()) {
        // should immediately disarm when we're on the ground
        gcs().send_text(MAV_SEVERITY_WARNING, "Radio Failsafe - Disarming");
        arming.disarm(AP_Arming::Method::RADIOFAILSAFE);
        desired_action = Failsafe_Action_None;

    } else if (flightmode->is_landing() && ((battery.has_failsafed() && battery.get_highest_failsafe_priority() <= FAILSAFE_LAND_PRIORITY))) {
        // Allow landing to continue when battery failsafe requires it (not a user option)
        gcs().send_text(MAV_SEVERITY_WARNING, "Radio + Battery Failsafe - Continuing Landing");
        desired_action = Failsafe_Action_Land;

    } else if (flightmode->is_landing() && failsafe_option(FailsafeOption::CONTINUE_IF_LANDING)) {
        // Allow landing to continue when FS_OPTIONS is set to continue landing
        gcs().send_text(MAV_SEVERITY_WARNING, "Radio Failsafe - Continuing Landing");
        desired_action = Failsafe_Action_Land;

    } else {
        gcs().send_text(MAV_SEVERITY_WARNING, "Radio Failsafe");
    }

    // Call the failsafe action handler
    do_failsafe_action(desired_action, ModeReason::RADIO_FAILSAFE);
}

// failsafe_off_event - respond to radio contact being regained
void Blimp::failsafe_radio_off_event()
{
    // no need to do anything except log the error as resolved
    // user can now override roll, pitch, yaw and throttle and even use flight mode switch to restore previous flight mode
    LOGGER_WRITE_ERROR(LogErrorSubsystem::FAILSAFE_RADIO, LogErrorCode::FAILSAFE_RESOLVED);
    gcs().send_text(MAV_SEVERITY_WARNING, "Radio Failsafe Cleared");
}

void Blimp::handle_battery_failsafe(const char *type_str, const int8_t action)
{
    LOGGER_WRITE_ERROR(LogErrorSubsystem::FAILSAFE_BATT, LogErrorCode::FAILSAFE_OCCURRED);

    Failsafe_Action desired_action = (Failsafe_Action)action;

    // Conditions to deviate from BATT_FS_XXX_ACT parameter setting
    if (should_disarm_on_failsafe()) {
        // should immediately disarm when we're on the ground
        arming.disarm(AP_Arming::Method::BATTERYFAILSAFE);
        desired_action = Failsafe_Action_None;
        gcs().send_text(MAV_SEVERITY_WARNING, "Battery Failsafe - Disarming");

    } else if (flightmode->is_landing() && failsafe_option(FailsafeOption::CONTINUE_IF_LANDING) && desired_action != Failsafe_Action_None) {
        // Allow landing to continue when FS_OPTIONS is set to continue when landing
        desired_action = Failsafe_Action_Land;
        gcs().send_text(MAV_SEVERITY_WARNING, "Battery Failsafe - Continuing Landing");
    } else {
        gcs().send_text(MAV_SEVERITY_WARNING, "Battery Failsafe");
    }

    // Battery FS options already use the Failsafe_Options enum. So use them directly.
    do_failsafe_action(desired_action, ModeReason::BATTERY_FAILSAFE);

}
// failsafe_gcs_check - check for ground station failsafe
void Blimp::failsafe_gcs_check()
{
    // Bypass GCS failsafe checks if disabled or GCS never connected
    if (g.failsafe_gcs == FS_GCS_DISABLED) {
        return;
    }

    const uint32_t gcs_last_seen_ms = gcs().sysid_myggcs_last_seen_time_ms();
    if (gcs_last_seen_ms == 0) {
        return;
    }

    // calc time since last gcs update
    // note: this only looks at the heartbeat from the device id set by g.sysid_my_gcs
    const uint32_t last_gcs_update_ms = millis() - gcs_last_seen_ms;
    const uint32_t gcs_timeout_ms = uint32_t(constrain_float(g2.fs_gcs_timeout * 1000.0f, 0.0f, UINT32_MAX));

    // Determine which event to trigger
    if (last_gcs_update_ms < gcs_timeout_ms && failsafe.gcs) {
        // Recovery from a GCS failsafe
        set_failsafe_gcs(false);
        // failsafe_gcs_off_event();

    } else if (last_gcs_update_ms < gcs_timeout_ms && !failsafe.gcs) {
        // No problem, do nothing

    } else if (last_gcs_update_ms > gcs_timeout_ms && failsafe.gcs) {
        // Already in failsafe, do nothing

    } else if (last_gcs_update_ms > gcs_timeout_ms && !failsafe.gcs) {
        // New GCS failsafe event, trigger events
        set_failsafe_gcs(true);
        arming.disarm(AP_Arming::Method::GCSFAILSAFE); // failsafe_gcs_on_event() should replace this when written
    }
}

bool Blimp::should_disarm_on_failsafe()
{
    if (ap.in_arming_delay) {
        return true;
    }

    switch (control_mode) {
    case Mode::Number::MANUAL:
    default:
        // if landed disarm
        return ap.land_complete;
    }
}


void Blimp::do_failsafe_action(Failsafe_Action action, ModeReason reason)
{

    // Execute the specified desired_action
    switch (action) {
    case Failsafe_Action_None:
        return;
    case Failsafe_Action_Land:
        set_mode_land_failsafe(reason);
        break;
    case Failsafe_Action_Terminate: {
        arming.disarm(AP_Arming::Method::FAILSAFE_ACTION_TERMINATE);
    }
    break;
    }
}

// check for gps glitch failsafe
void Blimp::gpsglitch_check()
{
    // get filter status
    nav_filter_status filt_status = inertial_nav.get_filter_status();
    bool gps_glitching = filt_status.flags.gps_glitching;

    // log start or stop of gps glitch.  AP_Notify update is handled from within AP_AHRS
    if (ap.gps_glitching != gps_glitching) {
        ap.gps_glitching = gps_glitching;
        if (gps_glitching) {
            LOGGER_WRITE_ERROR(LogErrorSubsystem::GPS, LogErrorCode::GPS_GLITCH);
            gcs().send_text(MAV_SEVERITY_CRITICAL,"GPS Glitch");
        } else {
            LOGGER_WRITE_ERROR(LogErrorSubsystem::GPS, LogErrorCode::ERROR_RESOLVED);
            gcs().send_text(MAV_SEVERITY_CRITICAL,"GPS Glitch cleared");
        }
    }
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                #include "Blimp.h"
/*
 * Init and run calls for loiter flight mode
 */

//Number of seconds of movement that the target position can be ahead of actual position.
#define POS_LAG 1

bool ModeLoiter::init(bool ignore_checks)
{
    target_pos = blimp.pos_ned;
    target_yaw = blimp.ahrs.get_yaw();

    return true;
}

//Runs the main loiter controller
void ModeLoiter::run()
{
    const float dt = blimp.scheduler.get_last_loop_time_s();

    Vector3f pilot;
    float pilot_yaw;
    get_pilot_input(pilot, pilot_yaw);
    pilot.x *= g.max_pos_xy * dt;
    pilot.y *= g.max_pos_xy * dt;
    pilot.z *= g.max_pos_z * dt;
    pilot_yaw *= g.max_pos_yaw * dt;

    if (g.simple_mode == 0) {
        //If simple mode is disabled, input is in body-frame, thus needs to be rotated.
        blimp.rotate_BF_to_NE(pilot.xy());
    }

    if (fabsf(target_pos.x-blimp.pos_ned.x) < (g.max_pos_xy*POS_LAG)) {
        target_pos.x += pilot.x;
    }
    if (fabsf(target_pos.y-blimp.pos_ned.y) < (g.max_pos_xy*POS_LAG)) {
        target_pos.y += pilot.y;
    }
    if (fabsf(target_pos.z-blimp.pos_ned.z) < (g.max_pos_z*POS_LAG)) {
        target_pos.z += pilot.z;
    }
    if (fabsf(wrap_PI(target_yaw-ahrs.get_yaw())) < (g.max_pos_yaw*POS_LAG)) {
        target_yaw = wrap_PI(target_yaw + pilot_yaw);
    }

    blimp.loiter->run(target_pos, target_yaw, Vector4b{false,false,false,false});
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           #include "flash_from_sd.h"

#if AP_BOOTLOADER_FLASH_FROM_SD_ENABLED

#include "ch.h"
#include "ff.h"

#include "md5.h"

#include <string.h>
#include <stdint.h>
#include <stdio.h>
#include <fcntl.h>
#include "stm32_util.h"

#include <AP_HAL_ChibiOS/hwdef/common/flash.h>
#include <AP_Math/AP_Math.h>
#include "support.h"

// swiped from support.cpp:
static const uint8_t *flash_base = (const uint8_t *)(0x08000000 + (FLASH_BOOTLOADER_LOAD_KB + APP_START_OFFSET_KB)*1024U);


// taken from AP_Common.cpp as we don't want to compile the AP_Common
// directory.  This function is defined in AP_Common.h - so we can't
// use "static" here.
/**
 * return the numeric value of an ascii hex character
 * 
 * @param[in] a Hexadecimal character 
 * @return  Returns a binary value
 */
int16_t char_to_hex(char a)
{
    if (a >= 'A' && a <= 'F')
        return a - 'A' + 10;
    else if (a >= 'a' && a <= 'f')
        return a - 'a' + 10;
    else
        return a - '0';
}

#define MAX_IO_SIZE 4096
static uint8_t buffer[MAX_IO_SIZE];

// a class which provides parsing functionality for abin files;
// inheritors must supply a function to deal with the body of the abin
// and may supply methods run() (to initialise their state) and
// name_value_callback (to handle name/value pairs extracted from the
// abin header.
class ABinParser {
public:
    ABinParser(const char *_path) :
        path{_path}
    { }
    virtual ~ABinParser() {}

    virtual bool run() = 0;

protected:

    virtual void name_value_callback(const char *name, const char *value) {}
    virtual void body_callback(const uint8_t *bytes, uint32_t n) = 0;
    bool parse();

private:

    const char *path;

};

bool ABinParser::parse()
{
    FIL fh;
    if (f_open(&fh, path, FA_READ) != FR_OK) {
        return false;
    }
    enum class State {
        START_NAME=17, // "MD5: "
        ACCUMULATING_NAME=19,
        ACCUMULATING_VALUE = 30,
        START_BODY = 40,
        PROCESSING_BODY = 45,
        SKIPPING_POST_COLON_SPACES = 50,
        START_VALUE = 55,
    };

    State state = State::START_NAME;
    uint16_t name_start = 0;
    uint16_t name_end = 0;
    uint16_t value_start = 0;
    // for efficiency we assume all headers are within the first chunk
    // read i.e. the name/value pairs do not cross a MAX_IO_SIZE
    // boundary
    while (true) {
        UINT bytes_read;
        if (f_read(&fh, buffer, sizeof(buffer), &bytes_read) != FR_OK) {
            return false;
        }
        if (bytes_read > sizeof(buffer)) {
            // error
            return false;
        }
        if (bytes_read == 0) {
            break;
        }
        for (uint16_t i=0; i<bytes_read; i++) {
            switch (state) {
            case State::START_NAME: {
                // check for delimiter:
                if (bytes_read-i >= 3) {
                    if (!strncmp((char*)&buffer[i], "--\n", bytes_read-i)) {
                        // end of headers
                        i += 2;
                        state = State::START_BODY;
                        continue;
                    }
                }
                // sanity check input:
                if (buffer[i] == ':') {
                    // zero-length name?! just say no:
                    return false;
                }
                if (buffer[i] == '\n') {
                    // empty line... ignore it
                    continue;
                }
                name_start = i;
                state = State::ACCUMULATING_NAME;
                continue;
            }
            case State::ACCUMULATING_NAME: {
                if (buffer[i] == '\n') {
                    // no colon on this line; just say no:
                    return false;
                }
                if (buffer[i] == ':') {
                    name_end = i;
                    state = State::SKIPPING_POST_COLON_SPACES;
                    continue;
                }
                // continue to accumulate name
                continue;
            }
            case State::SKIPPING_POST_COLON_SPACES:
                if (buffer[i] == ' ') {
                    // continue to accumulate spaces
                    continue;
                }
                state = State::START_VALUE;
                FALLTHROUGH;
            case State::START_VALUE:
                value_start = i;
                state = State::ACCUMULATING_VALUE;
                FALLTHROUGH;
            case State::ACCUMULATING_VALUE: {
                if (buffer[i] != '\n') {
                    // continue to accumate value bytes
                    continue;
                }
                char name[80];
                char value[80];
                strncpy(name, (char*)&buffer[name_start], MIN(sizeof(name)-1, name_end-name_start));
                strncpy(value, (char*)&buffer[value_start], MIN(sizeof(value)-1, i-value_start));
                name_value_callback(name, value);
                state = State::START_NAME;
                continue;
            }
            case State::START_BODY:
                state = State::PROCESSING_BODY;
                FALLTHROUGH;
            case State::PROCESSING_BODY:
                body_callback(&buffer[i], bytes_read-i);
                i = bytes_read;
                continue;
            }
        }
    }

    // successfully parsed the abin.  Call the body callback once more
    // with zero bytes indicating EOF:
    body_callback((uint8_t*)"", 0);

    return true;
}

// a sub-class of ABinParser which takes the supplied MD5 from the
// abin header and compares it against the calculated md5sum of the
// abin body
class ABinVerifier : ABinParser {
public:

    using ABinParser::ABinParser;

    bool run() override {
        MD5Init(&md5_context);

        if (!parse()) {
            return false;
        }

        // verify the checksum is as expected
        uint8_t calculated_md5[16];
        MD5Final(calculated_md5, &md5_context);
        if (!memcmp(calculated_md5, expected_md5, sizeof(calculated_md5))) {
            // checksums match
            return true;
        }

        return false;
    }

protected:

    void name_value_callback(const char *name, const char *value) override {
        if (strncmp(name, "MD5", 3)) {
            // only interested in MD5 header
            return;
        }

        // convert from 32-byte-string to 16-byte number:
        for (uint8_t j=0; j<16; j++) {
            expected_md5[j] = (char_to_hex(value[j*2]) << 4) | char_to_hex(value[j*2+1]);
        }
    }

    void body_callback(const uint8_t *bytes, uint32_t nbytes) override {
        MD5Update(&md5_context, bytes, nbytes);
    }

private:

    uint8_t expected_md5[16];
    MD5Context md5_context;
};


// a sub-class of ABinParser which flashes the body of the supplied abin
class ABinFlasher : public ABinParser {
public:
    using ABinParser::ABinParser;

    bool run() override {
        // start by erasing all sectors
        for (uint8_t i = 0; flash_func_sector_size(i) != 0; i++) {
            if (!flash_func_erase_sector(i)) {
                return false;
            }
            led_toggle(LED_BOOTLOADER);
        }

        // parse and flash
        if (!parse()) {
            return false;
        }

        return !failed;
    }

protected:

    void body_callback(const uint8_t *bytes, uint32_t nbytes) override {
        if (failed) {
            return;
        }

        memcpy(&buffer[buffer_ofs], bytes, nbytes);
        buffer_ofs += nbytes;

        const uint32_t WRITE_CHUNK_SIZE = 32*1024; // must be less than size of state buffer
        // nbytes is zero after the last chunk in the body
        if (buffer_ofs > WRITE_CHUNK_SIZE || nbytes == 0) {
            uint32_t write_size = WRITE_CHUNK_SIZE;
            uint32_t padded_write_size = write_size;
            if (nbytes == 0) {
                // final chunk.  We have to align to 128 bytes
                write_size = buffer_ofs;
                padded_write_size = write_size;
                const uint8_t pad_size = 128 - (write_size % 128);
                // zero those extra bytes:
                memset(&buffer[buffer_ofs], '\0', pad_size);
                padded_write_size += pad_size;
            }
            const uint32_t ofs = uint32_t(flash_base) + flash_ofs;
            if (!stm32_flash_write(ofs, buffer, padded_write_size)) {
                failed = true;
                return;
            }
            flash_ofs += padded_write_size;
            buffer_ofs -= write_size;
            memcpy(buffer, &buffer[write_size], buffer_ofs);
            led_toggle(LED_BOOTLOADER);
        }
    }

private:

    uint32_t flash_ofs = 0;
    uint32_t buffer_ofs = 0;
    uint8_t buffer[64*1024];  // constrained by memory map on bootloader
    bool failed = false;
};


// main entry point to the flash-from-sd-card functionality; called
// from the bootloader main function
bool flash_from_sd()
{
    peripheral_power_enable();

    if (!sdcard_init()) {
        return false;
    }

    bool ret = false;

    // expected filepath for abin:
    const char *abin_path = "/ardupilot.abin";
    // we rename to this before verifying the abin:
    const char *verify_abin_path = "/ardupilot-verify.abin";
    // we rename to this before flashing the abin:
    const char *flash_abin_path = "/ardupilot-flash.abin";
    // we rename to this after flashing the abin:
    const char *flashed_abin_path = "/ardupilot-flashed.abin";

    ABinVerifier *verifier = nullptr;
    ABinFlasher *flasher = nullptr;

    FILINFO info;
    if (f_stat(abin_path, &info) != FR_OK) {
        goto out;
    }

    f_unlink(verify_abin_path);
    f_unlink(flash_abin_path);
    f_unlink(flashed_abin_path);

    // rename the file so we only ever attempt to flash from it once:
    if (f_rename(abin_path, verify_abin_path) != FR_OK) {
        // we would be nice to indicate an error here.
        // we could try to drop a message on the SD card?
        return false;
    }

    verifier = NEW_NOTHROW ABinVerifier{verify_abin_path};
    if (!verifier->run()) {
        goto out;
    }

    // rename the file so we only ever attempt to flash from it once:
    if (f_rename(verify_abin_path, flash_abin_path) != FR_OK) {
        // we would be nice to indicate an error here.
        // we could try to drop a message on the SD card?
        return false;
    }

    flasher = NEW_NOTHROW ABinFlasher{flash_abin_path};
    if (!flasher->run()) {
        goto out;
    }

    // rename the file to indicate successful flash:
    if (f_rename(flash_abin_path, flashed_abin_path) != FR_OK) {
        // we would be nice to indicate an error here.
        // we could try to drop a message on the SD card?
        return false;
    }

    ret = true;

out:

    delete verifier;
    verifier = nullptr;

    delete flasher;
    flasher = nullptr;

    sdcard_stop();
    // should we disable peripheral power again?!

    return ret;
}

#endif  // AP_BOOTLOADER_FLASH_FROM_SD_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              #pragma once

#include "AP_Bootloader_config.h"

#if AP_BOOTLOADER_FLASH_FROM_SD_ENABLED

#include <AP_HAL_ChibiOS/sdcard.h>
#include <stdbool.h>

bool flash_from_sd();

#endif  // AP_BOOTLOADER_FLASH_FROM_SD_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       /*
 * This code implements the MD5 message-digest algorithm.
 * The algorithm is due to Ron Rivest.  This code was
 * written by Colin Plumb in 1993, no copyright is claimed.
 * This code is in the public domain; do with it what you wish.
 *
 * Equivalent code is available from RSA Data Security, Inc.
 * This code has been tested against that, and is equivalent,
 * except that you don't need to include two pages of legalese
 * with every copy.
 *
 * To compute the message digest of a chunk of bytes, declare an
 * MD5Context structure, pass it to MD5Init, call MD5Update as
 * needed on buffers full of bytes, and then call MD5Final, which
 * will fill a supplied 16-byte array with the digest.
 */

/* This code slightly modified to fit into Samba by 
   abartlet@samba.org Jun 2001 */

// swiped and modified from tridge's junk code repository -pb20220818
#include "md5.h"
#include <string.h>

#pragma GCC diagnostic ignored "-Wcast-align"

static void MD5Transform(uint32 buf[4], uint32 const in[16]);

/*
 * Note: this code is harmless on little-endian machines.
 */
static void byteReverse(unsigned char *buf, unsigned longs)
{
    uint32 t;
    do {
	t = (uint32) ((unsigned) buf[3] << 8 | buf[2]) << 16 |
	    ((unsigned) buf[1] << 8 | buf[0]);
	*(uint32 *) buf = t;
	buf += 4;
    } while (--longs);
}

/*
 * Start MD5 accumulation.  Set bit count to 0 and buffer to mysterious
 * initialization constants.
 */
void MD5Init(struct MD5Context *ctx)
{
    ctx->buf[0] = 0x67452301;
    ctx->buf[1] = 0xefcdab89;
    ctx->buf[2] = 0x98badcfe;
    ctx->buf[3] = 0x10325476;

    ctx->bits[0] = 0;
    ctx->bits[1] = 0;
}

/*
 * Update context to reflect the concatenation of another buffer full
 * of bytes.
 */
void MD5Update(struct MD5Context *ctx, unsigned char const *buf, unsigned len)
{
    register uint32 t;

    /* Update bitcount */

    t = ctx->bits[0];
    if ((ctx->bits[0] = t + ((uint32) len << 3)) < t)
	ctx->bits[1]++;		/* Carry from low to high */
    ctx->bits[1] += len >> 29;

    t = (t >> 3) & 0x3f;	/* Bytes already in shsInfo->data */

    /* Handle any leading odd-sized chunks */

    if (t) {
	unsigned char *p = (unsigned char *) ctx->in + t;

	t = 64 - t;
	if (len < t) {
	    memmove(p, buf, len);
	    return;
	}
	memmove(p, buf, t);
	byteReverse(ctx->in, 16);
	MD5Transform(ctx->buf, (uint32 *) ctx->in);
	buf += t;
	len -= t;
    }
    /* Process data in 64-byte chunks */

    while (len >= 64) {
	memmove(ctx->in, buf, 64);
	byteReverse(ctx->in, 16);
	MD5Transform(ctx->buf, (uint32 *) ctx->in);
	buf += 64;
	len -= 64;
    }

    /* Handle any remaining bytes of data. */

    memmove(ctx->in, buf, len);
}

/*
 * Final wrapup - pad to 64-byte boundary with the bit pattern 
 * 1 0* (64-bit count of bits processed, MSB-first)
 */
void MD5Final(unsigned char digest[16], struct MD5Context *ctx)
{
    unsigned int count;
    unsigned char *p;

    /* Compute number of bytes mod 64 */
    count = (ctx->bits[0] >> 3) & 0x3F;

    /* Set the first char of padding to 0x80.  This is safe since there is
       always at least one byte free */
    p = ctx->in + count;
    *p++ = 0x80;

    /* Bytes of padding needed to make 64 bytes */
    count = 64 - 1 - count;

    /* Pad out to 56 mod 64 */
    if (count < 8) {
	/* Two lots of padding:  Pad the first block to 64 bytes */
	memset(p, 0, count);
	byteReverse(ctx->in, 16);
	MD5Transform(ctx->buf, (uint32 *) ctx->in);

	/* Now fill the next block with 56 bytes */
	memset(ctx->in, 0, 56);
    } else {
	/* Pad block to 56 bytes */
	memset(p, 0, count - 8);
    }
    byteReverse(ctx->in, 14);

    /* Append length in bits and transform */
    ((uint32 *) ctx->in)[14] = ctx->bits[0];
    ((uint32 *) ctx->in)[15] = ctx->bits[1];

    MD5Transform(ctx->buf, (uint32 *) ctx->in);
    byteReverse((unsigned char *) ctx->buf, 4);
    memmove(digest, ctx->buf, 16);
    memset(ctx, 0, sizeof(*ctx));	/* In case it's sensitive */
}

/* The four core functions - F1 is optimized somewhat */

/* #define F1(x, y, z) (x & y | ~x & z) */
#define F1(x, y, z) (z ^ (x & (y ^ z)))
#define F2(x, y, z) F1(z, x, y)
#define F3(x, y, z) (x ^ y ^ z)
#define F4(x, y, z) (y ^ (x | ~z))

/* This is the central step in the MD5 algorithm. */
#define MD5STEP(f, w, x, y, z, data, s) \
	( w += f(x, y, z) + data,  w = w<<s | w>>(32-s),  w += x )

/*
 * The core of the MD5 algorithm, this alters an existing MD5 hash to
 * reflect the addition of 16 longwords of new data.  MD5Update blocks
 * the data and converts bytes into longwords for this routine.
 */
static void MD5Transform(uint32 buf[4], uint32 const in[16])
{
    register uint32 a, b, c, d;

    a = buf[0];
    b = buf[1];
    c = buf[2];
    d = buf[3];

    MD5STEP(F1, a, b, c, d, in[0] + 0xd76aa478, 7);
    MD5STEP(F1, d, a, b, c, in[1] + 0xe8c7b756, 12);
    MD5STEP(F1, c, d, a, b, in[2] + 0x242070db, 17);
    MD5STEP(F1, b, c, d, a, in[3] + 0xc1bdceee, 22);
    MD5STEP(F1, a, b, c, d, in[4] + 0xf57c0faf, 7);
    MD5STEP(F1, d, a, b, c, in[5] + 0x4787c62a, 12);
    MD5STEP(F1, c, d, a, b, in[6] + 0xa8304613, 17);
    MD5STEP(F1, b, c, d, a, in[7] + 0xfd469501, 22);
    MD5STEP(F1, a, b, c, d, in[8] + 0x698098d8, 7);
    MD5STEP(F1, d, a, b, c, in[9] + 0x8b44f7af, 12);
    MD5STEP(F1, c, d, a, b, in[10] + 0xffff5bb1, 17);
    MD5STEP(F1, b, c, d, a, in[11] + 0x895cd7be, 22);
    MD5STEP(F1, a, b, c, d, in[12] + 0x6b901122, 7);
    MD5STEP(F1, d, a, b, c, in[13] + 0xfd987193, 12);
    MD5STEP(F1, c, d, a, b, in[14] + 0xa679438e, 17);
    MD5STEP(F1, b, c, d, a, in[15] + 0x49b40821, 22);

    MD5STEP(F2, a, b, c, d, in[1] + 0xf61e2562, 5);
    MD5STEP(F2, d, a, b, c, in[6] + 0xc040b340, 9);
    MD5STEP(F2, c, d, a, b, in[11] + 0x265e5a51, 14);
    MD5STEP(F2, b, c, d, a, in[0] + 0xe9b6c7aa, 20);
    MD5STEP(F2, a, b, c, d, in[5] + 0xd62f105d, 5);
    MD5STEP(F2, d, a, b, c, in[10] + 0x02441453, 9);
    MD5STEP(F2, c, d, a, b, in[15] + 0xd8a1e681, 14);
    MD5STEP(F2, b, c, d, a, in[4] + 0xe7d3fbc8, 20);
    MD5STEP(F2, a, b, c, d, in[9] + 0x21e1cde6, 5);
    MD5STEP(F2, d, a, b, c, in[14] + 0xc33707d6, 9);
    MD5STEP(F2, c, d, a, b, in[3] + 0xf4d50d87, 14);
    MD5STEP(F2, b, c, d, a, in[8] + 0x455a14ed, 20);
    MD5STEP(F2, a, b, c, d, in[13] + 0xa9e3e905, 5);
    MD5STEP(F2, d, a, b, c, in[2] + 0xfcefa3f8, 9);
    MD5STEP(F2, c, d, a, b, in[7] + 0x676f02d9, 14);
    MD5STEP(F2, b, c, d, a, in[12] + 0x8d2a4c8a, 20);

    MD5STEP(F3, a, b, c, d, in[5] + 0xfffa3942, 4);
    MD5STEP(F3, d, a, b, c, in[8] + 0x8771f681, 11);
    MD5STEP(F3, c, d, a, b, in[11] + 0x6d9d6122, 16);
    MD5STEP(F3, b, c, d, a, in[14] + 0xfde5380c, 23);
    MD5STEP(F3, a, b, c, d, in[1] + 0xa4beea44, 4);
    MD5STEP(F3, d, a, b, c, in[4] + 0x4bdecfa9, 11);
    MD5STEP(F3, c, d, a, b, in[7] + 0xf6bb4b60, 16);
    MD5STEP(F3, b, c, d, a, in[10] + 0xbebfbc70, 23);
    MD5STEP(F3, a, b, c, d, in[13] + 0x289b7ec6, 4);
    MD5STEP(F3, d, a, b, c, in[0] + 0xeaa127fa, 11);
    MD5STEP(F3, c, d, a, b, in[3] + 0xd4ef3085, 16);
    MD5STEP(F3, b, c, d, a, in[6] + 0x04881d05, 23);
    MD5STEP(F3, a, b, c, d, in[9] + 0xd9d4d039, 4);
    MD5STEP(F3, d, a, b, c, in[12] + 0xe6db99e5, 11);
    MD5STEP(F3, c, d, a, b, in[15] + 0x1fa27cf8, 16);
    MD5STEP(F3, b, c, d, a, in[2] + 0xc4ac5665, 23);

    MD5STEP(F4, a, b, c, d, in[0] + 0xf4292244, 6);
    MD5STEP(F4, d, a, b, c, in[7] + 0x432aff97, 10);
    MD5STEP(F4, c, d, a, b, in[14] + 0xab9423a7, 15);
    MD5STEP(F4, b, c, d, a, in[5] + 0xfc93a039, 21);
    MD5STEP(F4, a, b, c, d, in[12] + 0x655b59c3, 6);
    MD5STEP(F4, d, a, b, c, in[3] + 0x8f0ccc92, 10);
    MD5STEP(F4, c, d, a, b, in[10] + 0xffeff47d, 15);
    MD5STEP(F4, b, c, d, a, in[1] + 0x85845dd1, 21);
    MD5STEP(F4, a, b, c, d, in[8] + 0x6fa87e4f, 6);
    MD5STEP(F4, d, a, b, c, in[15] + 0xfe2ce6e0, 10);
    MD5STEP(F4, c, d, a, b, in[6] + 0xa3014314, 15);
    MD5STEP(F4, b, c, d, a, in[13] + 0x4e0811a1, 21);
    MD5STEP(F4, a, b, c, d, in[4] + 0xf7537e82, 6);
    MD5STEP(F4, d, a, b, c, in[11] + 0xbd3af235, 10);
    MD5STEP(F4, c, d, a, b, in[2] + 0x2ad7d2bb, 15);
    MD5STEP(F4, b, c, d, a, in[9] + 0xeb86d391, 21);

    buf[0] += a;
    buf[1] += b;
    buf[2] += c;
    buf[3] += d;
}
                        #ifndef MD5_H
#define MD5_H
#ifndef HEADER_MD5_H
/* Try to avoid clashes with OpenSSL */
#define HEADER_MD5_H 
#endif

// swiped and modified from tridge's junk code repository -pb20220818
#include "stdint.h"
#define uint32 uint32_t
// ignore cast errors in this case to keep complexity down
// on x86 where replay is run we don't care about cast alignment

struct MD5Context {
	uint32 buf[4];
	uint32 bits[2];
	unsigned char in[64];
};

void MD5Init(struct MD5Context *context);
void MD5Update(struct MD5Context *context, unsigned char const *buf,
	       unsigned len);
void MD5Final(unsigned char digest[16], struct MD5Context *context);

/*
 * This is needed to make RSAREF happy on some MS-DOS compilers.
 */
typedef struct MD5Context MD5_CTX;

#endif /* !MD5_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              # -*- coding: utf-8 -*-

""" ArduPilot IMU Filter Test Class

This program is free software: you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation, either version 3 of the License, or (at your option) any later
version.
This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
You should have received a copy of the GNU General Public License along with
this program. If not, see <http://www.gnu.org/licenses/>.
"""

__author__ = "Guglielmo Cassinelli"
__contact__ = "gdguglie@gmail.com"

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.widgets import Slider
from matplotlib.animation import FuncAnimation
from scipy import signal
from BiquadFilter import BiquadFilterType, BiquadFilter

sliders = []  # matplotlib sliders must be global
anim = None  # matplotlib animations must be global


class FilterTest:
    FILTER_DEBOUNCE = 10  # ms

    FILT_SHAPE_DT_FACTOR = 1  # increase to reduce filter shape size

    FFT_N = 512

    filters = {}

    def __init__(self, acc_t, acc_x, acc_y, acc_z, gyr_t, gyr_x, gyr_y, gyr_z, acc_freq, gyr_freq,
                 acc_lpf_cutoff, gyr_lpf_cutoff,
                 acc_notch_freq, acc_notch_att, acc_notch_band,
                 gyr_notch_freq, gyr_notch_att, gyr_notch_band,
                 log_name, accel_notch=False, second_notch=False):

        self.filter_color_map = plt.get_cmap('summer')

        self.filters["acc"] = [
            BiquadFilter(acc_lpf_cutoff, acc_freq)
        ]

        if accel_notch:
            self.filters["acc"].append(
                BiquadFilter(acc_notch_freq, acc_freq, BiquadFilterType.PEAK, acc_notch_att, acc_notch_band),
            )

        self.filters["gyr"] = [
            BiquadFilter(gyr_lpf_cutoff, gyr_freq),
            BiquadFilter(gyr_notch_freq, gyr_freq, BiquadFilterType.PEAK, gyr_notch_att, gyr_notch_band)
        ]

        if second_notch:
            self.filters["acc"].append(
                BiquadFilter(acc_notch_freq * 2, acc_freq, BiquadFilterType.PEAK, acc_notch_att, acc_notch_band)
            )
            self.filters["gyr"].append(
                BiquadFilter(gyr_notch_freq * 2, gyr_freq, BiquadFilterType.PEAK, gyr_notch_att, gyr_notch_band)
            )

        self.ACC_t = acc_t
        self.ACC_x = acc_x
        self.ACC_y = acc_y
        self.ACC_z = acc_z

        self.GYR_t = gyr_t
        self.GYR_x = gyr_x
        self.GYR_y = gyr_y
        self.GYR_z = gyr_z

        self.GYR_freq = gyr_freq
        self.ACC_freq = acc_freq

        self.gyr_dt = 1. / gyr_freq
        self.acc_dt = 1. / acc_freq

        self.timer = None

        self.updated_artists = []

        # INIT
        self.init_plot(log_name)

    def test_acc_filters(self):
        filt_xs = self.test_filters(self.filters["acc"], self.ACC_t, self.ACC_x)
        filt_ys = self.test_filters(self.filters["acc"], self.ACC_t, self.ACC_y)
        filt_zs = self.test_filters(self.filters["acc"], self.ACC_t, self.ACC_z)
        return filt_xs, filt_ys, filt_zs

    def test_gyr_filters(self):
        filt_xs = self.test_filters(self.filters["gyr"], self.GYR_t, self.GYR_x)
        filt_ys = self.test_filters(self.filters["gyr"], self.GYR_t, self.GYR_y)
        filt_zs = self.test_filters(self.filters["gyr"], self.GYR_t, self.GYR_z)
        return filt_xs, filt_ys, filt_zs

    def test_filters(self, filters, Ts, Xs):
        for f in filters:
            f.reset()

        x_filtered = []

        for i, t in enumerate(Ts):
            x = Xs[i]

            x_f = x
            for filt in filters:
                x_f = filt.apply(x_f)

            x_filtered.append(x_f)

        return x_filtered

    def get_filter_shape(self, filter):
        samples = int(filter.get_sample_freq())  # resolution of filter shape based on sample rate
        x_space = np.linspace(0.0, samples // 2, samples // int(2 * self.FILT_SHAPE_DT_FACTOR))
        return x_space, filter.freq_response(x_space)

    def init_signal_plot(self, ax, Ts, Xs, Ys, Zs, Xs_filtered, Ys_filtered, Zs_filtered, label):
        ax.plot(Ts, Xs, linewidth=1, label="{}X".format(label), alpha=0.5)
        ax.plot(Ts, Ys, linewidth=1, label="{}Y".format(label), alpha=0.5)
        ax.plot(Ts, Zs, linewidth=1, label="{}Z".format(label), alpha=0.5)
        filtered_x_ax, = ax.plot(Ts, Xs_filtered, linewidth=1, label="{}X filtered".format(label), alpha=1)
        filtered_y_ax, = ax.plot(Ts, Ys_filtered, linewidth=1, label="{}Y filtered".format(label), alpha=1)
        filtered_z_ax, = ax.plot(Ts, Zs_filtered, linewidth=1, label="{}Z filtered".format(label), alpha=1)
        ax.legend(prop={'size': 8})
        return filtered_x_ax, filtered_y_ax, filtered_z_ax

    def fft_to_xdata(self, fft):
        n = len(fft)
        norm_factor = 2. / n
        return norm_factor * np.abs(fft[:n // 2])

    def plot_fft(self, ax, x, fft, label):
        fft_ax, = ax.plot(x, self.fft_to_xdata(fft), label=label)
        return fft_ax

    def init_fft(self, ax, Ts, Xs, Ys, Zs, sample_rate, dt, Xs_filtered, Ys_filtered, Zs_filtered, label):

        _freqs_raw_x, _times_raw_x, _stft_raw_x = signal.stft(Xs, sample_rate, window='hann', nperseg=self.FFT_N)
        raw_fft_x = np.average(np.abs(_stft_raw_x), axis=1)

        _freqs_raw_y, _times_raw_y, _stft_raw_y = signal.stft(Ys, sample_rate, window='hann', nperseg=self.FFT_N)
        raw_fft_y = np.average(np.abs(_stft_raw_y), axis=1)

        _freqs_raw_z, _times_raw_z, _stft_raw_z = signal.stft(Zs, sample_rate, window='hann', nperseg=self.FFT_N)
        raw_fft_z = np.average(np.abs(_stft_raw_z), axis=1)

        _freqs_x, _times_x, _stft_x = signal.stft(Xs_filtered, sample_rate, window='hann', nperseg=self.FFT_N)
        filtered_fft_x = np.average(np.abs(_stft_x), axis=1)

        _freqs_y, _times_y, _stft_y = signal.stft(Ys_filtered, sample_rate, window='hann', nperseg=self.FFT_N)
        filtered_fft_y = np.average(np.abs(_stft_y), axis=1)

        _freqs_z, _times_z, _stft_z = signal.stft(Zs_filtered, sample_rate, window='hann', nperseg=self.FFT_N)
        filtered_fft_z = np.average(np.abs(_stft_z), axis=1)

        ax.plot(_freqs_raw_x, raw_fft_x, alpha=0.5, linewidth=1, label="{}x FFT".format(label))
        ax.plot(_freqs_raw_y, raw_fft_y, alpha=0.5, linewidth=1, label="{}y FFT".format(label))
        ax.plot(_freqs_raw_z, raw_fft_z, alpha=0.5, linewidth=1, label="{}z FFT".format(label))

        filtered_fft_ax_x, = ax.plot(_freqs_x, filtered_fft_x, label="filt. {}x FFT".format(label))
        filtered_fft_ax_y, = ax.plot(_freqs_y, filtered_fft_y, label="filt. {}y FFT".format(label))
        filtered_fft_ax_z, = ax.plot(_freqs_z, filtered_fft_z, label="filt. {}z FFT".format(label))

        # FFT
        # samples = len(Ts)
        # x_space = np.linspace(0.0, 1.0 / (2.0 * dt), samples // 2)
        # filtered_data = np.hanning(len(Xs_filtered)) * Xs_filtered
        # raw_fft = np.fft.fft(np.hanning(len(Xs)) * Xs)
        # filtered_fft = np.fft.fft(filtered_data, n=self.FFT_N)
        # self.plot_fft(ax, x_space, raw_fft, "{} FFT".format(label))
        # fft_freq = np.fft.fftfreq(self.FFT_N, d=dt)
        # x_space
        # filtered_fft_ax = self.plot_fft(ax, fft_freq[:self.FFT_N // 2], filtered_fft, "filtered {} FFT".format(label))

        ax.set_xlabel("frequency")
        # ax.set_xscale("log")
        # ax.xaxis.set_major_formatter(ScalarFormatter())
        ax.legend(prop={'size': 8})

        return filtered_fft_ax_x, filtered_fft_ax_y, filtered_fft_ax_z

    def init_filter_shape(self, ax, filter, color):
        center = filter.get_center_freq()
        x_space, lpf_shape = self.get_filter_shape(filter)

        plot_slpf_shape, = ax.plot(x_space, lpf_shape, c=color, label="LPF shape")
        xvline_lpf_cutoff = ax.axvline(x=center, linestyle="--", c=color)  # LPF cutoff freq

        return plot_slpf_shape, xvline_lpf_cutoff

    def create_slider(self, name, rect, max, value, color, callback):
        global sliders
        ax_slider = self.fig.add_axes(rect, facecolor='lightgoldenrodyellow')
        slider = Slider(ax_slider, name, 0, max, valinit=np.sqrt(max * value), valstep=1, color=color)
        slider.valtext.set_text(value)

        # slider.drawon = False

        def changed(val, cbk, max, slider):
            # non linear slider to better control small values
            val = int(val ** 2 / max)
            slider.valtext.set_text(val)
            cbk(val)

        slider.on_changed(lambda val, cbk=callback, max=max, s=slider: changed(val, cbk, max, s))
        sliders.append(slider)

    def delay_update(self, update_cbk):
        def _delayed_update(self, cbk):
            self.timer.stop()
            cbk()

        # delay actual filtering
        if self.fig:
            if self.timer:
                self.timer.stop()
            self.timer = self.fig.canvas.new_timer(interval=self.FILTER_DEBOUNCE)
            self.timer.add_callback(lambda self=self: _delayed_update(self, update_cbk))
            self.timer.start()

    def update_filter_shape(self, filter, shape, center_line):
        x_data, new_shape = self.get_filter_shape(filter)

        shape.set_ydata(new_shape)
        center_line.set_xdata(filter.get_center_freq())

        self.updated_artists.extend([
            shape,
            center_line,
        ])

    def update_signal_and_fft_plot(self, filters_key, time_list, sample_lists, signal_shapes, fft_shapes, shape,
                                   center_line, sample_rate):
        # print("update_signal_and_fft_plot", self.filters[filters_key][0].get_center_freq())
        Xs, Ys, Zs = sample_lists
        signal_shape_x, signal_shape_y, signal_shape_z = signal_shapes
        fft_shape_x, fft_shape_y, fft_shape_z = fft_shapes

        Xs_filtered = self.test_filters(self.filters[filters_key], time_list, Xs)
        Ys_filtered = self.test_filters(self.filters[filters_key], time_list, Ys)
        Zs_filtered = self.test_filters(self.filters[filters_key], time_list, Zs)

        signal_shape_x.set_ydata(Xs_filtered)
        signal_shape_y.set_ydata(Ys_filtered)
        signal_shape_z.set_ydata(Zs_filtered)

        self.updated_artists.extend([signal_shape_x, signal_shape_y, signal_shape_z])

        _freqs_x, _times_x, _stft_x = signal.stft(Xs_filtered, sample_rate, window='hann', nperseg=self.FFT_N)
        filtered_fft_x = np.average(np.abs(_stft_x), axis=1)

        _freqs_y, _times_y, _stft_y = signal.stft(Ys_filtered, sample_rate, window='hann', nperseg=self.FFT_N)
        filtered_fft_y = np.average(np.abs(_stft_y), axis=1)

        _freqs_z, _times_z, _stft_z = signal.stft(Zs_filtered, sample_rate, window='hann', nperseg=self.FFT_N)
        filtered_fft_z = np.average(np.abs(_stft_z), axis=1)

        fft_shape_x.set_ydata(filtered_fft_x)
        fft_shape_y.set_ydata(filtered_fft_y)
        fft_shape_z.set_ydata(filtered_fft_z)

        self.updated_artists.extend([
            fft_shape_x, fft_shape_y, fft_shape_z,
            shape, center_line,
        ])

        # self.fig.canvas.draw()

    def animation_update(self):
        updated_artists = self.updated_artists.copy()

        # if updated_artists:
        #    print("animation update")

        # reset updated artists
        self.updated_artists = []

        return updated_artists

    def update_filter(self, val, cbk, filter, shape, center_line, filters_key, time_list, sample_lists, signal_shapes,
                      fft_shapes):
        # this callback sets the parameter controlled by the slider
        cbk(val)
        # print("filter update",val)
        # update filter shape and delay fft update
        self.update_filter_shape(filter, shape, center_line)
        sample_freq = filter.get_sample_freq()
        self.delay_update(
            lambda self=self: self.update_signal_and_fft_plot(filters_key, time_list, sample_lists, signal_shapes,
                                                              fft_shapes, shape, center_line, sample_freq))

    def create_filter_control(self, name, filter, rect, max, default, shape, center_line, cbk, filters_key, time_list,
                              sample_lists, signal_shapes, fft_shapes, filt_color):
        self.create_slider(name, rect, max, default, filt_color, lambda val, cbk=cbk, self=self, filter=filter, shape=shape,
                                                                        center_line=center_line, filters_key=filters_key,
                                                                        time_list=time_list, sample_list=sample_lists,
                                                                        signal_shape=signal_shapes, fft_shape=fft_shapes:
                                                        self.update_filter(val, cbk, filter, shape, center_line, filters_key,
                                                                           time_list, sample_list, signal_shape, fft_shape))

    def create_controls(self, filters_key, base_rect, padding, ax_fft, time_list, sample_lists, signal_shapes,
                        fft_shapes):
        ax_filter = ax_fft.twinx()
        ax_filter.set_navigate(False)
        ax_filter.set_yticks([])

        num_filters = len(self.filters[filters_key])

        for i, filter in enumerate(self.filters[filters_key]):
            filt_type = filter.get_type()
            filt_color = self.filter_color_map(i / num_filters)
            filt_shape, filt_cutoff = self.init_filter_shape(ax_filter, filter, filt_color)

            if filt_type == BiquadFilterType.PEAK:
                name = "Notch"
            else:
                name = "LPF"

            # control for center freq is common to all filters
            self.create_filter_control("{} freq".format(name), filter, base_rect, 500, filter.get_center_freq(),
                                       filt_shape, filt_cutoff,
                                       lambda val, filter=filter: filter.set_center_freq(val),
                                       filters_key, time_list, sample_lists, signal_shapes, fft_shapes, filt_color)
            # move down of control height + padding
            base_rect[1] -= (base_rect[3] + padding)

            if filt_type == BiquadFilterType.PEAK:
                self.create_filter_control("{} att (db)".format(name), filter, base_rect, 100, filter.get_attenuation(),
                                           filt_shape, filt_cutoff,
                                           lambda val, filter=filter: filter.set_attenuation(val),
                                           filters_key, time_list, sample_lists, signal_shapes, fft_shapes, filt_color)
                base_rect[1] -= (base_rect[3] + padding)
                self.create_filter_control("{} band".format(name), filter, base_rect, 300, filter.get_bandwidth(),
                                           filt_shape, filt_cutoff,
                                           lambda val, filter=filter: filter.set_bandwidth(val),
                                           filters_key, time_list, sample_lists, signal_shapes, fft_shapes, filt_color)
                base_rect[1] -= (base_rect[3] + padding)

    def create_spectrogram(self, data, name, sample_rate):
        freqs, times, Sx = signal.spectrogram(np.array(data), fs=sample_rate, window='hanning',
                                              nperseg=self.FFT_N, noverlap=self.FFT_N - self.FFT_N // 10,
                                              detrend=False, scaling='spectrum')

        f, ax = plt.subplots(figsize=(4.8, 2.4))
        ax.pcolormesh(times, freqs, 10 * np.log10(Sx), cmap='viridis')
        ax.set_title(name)
        ax.set_ylabel('Frequency (Hz)')
        ax.set_xlabel('Time (s)')

    def init_plot(self, log_name):

        self.fig = plt.figure(figsize=(14, 9))
        self.fig.canvas.set_window_title("ArduPilot Filter Test Tool - {}".format(log_name))
        self.fig.canvas.draw()

        rows = 2
        cols = 3
        raw_acc_index = 1
        fft_acc_index = raw_acc_index + 1
        raw_gyr_index = cols + 1
        fft_gyr_index = raw_gyr_index + 1

        # signal
        self.ax_acc = self.fig.add_subplot(rows, cols, raw_acc_index)
        self.ax_gyr = self.fig.add_subplot(rows, cols, raw_gyr_index, sharex=self.ax_acc)

        accx_filtered, accy_filtered, accz_filtered = self.test_acc_filters()
        self.ax_filtered_accx, self.ax_filtered_accy, self.ax_filtered_accz = self.init_signal_plot(self.ax_acc,
                                                                                                    self.ACC_t,
                                                                                                    self.ACC_x,
                                                                                                    self.ACC_y,
                                                                                                    self.ACC_z,
                                                                                                    accx_filtered,
                                                                                                    accy_filtered,
                                                                                                    accz_filtered,
                                                                                                    "AccX")

        gyrx_filtered, gyry_filtered, gyrz_filtered = self.test_gyr_filters()
        self.ax_filtered_gyrx, self.ax_filtered_gyry, self.ax_filtered_gyrz = self.init_signal_plot(self.ax_gyr,
                                                                                                    self.GYR_t,
                                                                                                    self.GYR_x,
                                                                                                    self.GYR_y,
                                                                                                    self.GYR_z,
                                                                                                    gyrx_filtered,
                                                                                                    gyry_filtered,
                                                                                                    gyrz_filtered,
                                                                                                    "GyrX")

        # FFT
        self.ax_acc_fft = self.fig.add_subplot(rows, cols, fft_acc_index)
        self.ax_gyr_fft = self.fig.add_subplot(rows, cols, fft_gyr_index)

        self.acc_filtered_fft_ax_x, self.acc_filtered_fft_ax_y, self.acc_filtered_fft_ax_z = self.init_fft(
            self.ax_acc_fft, self.ACC_t, self.ACC_x, self.ACC_y, self.ACC_z, self.ACC_freq, self.acc_dt, accx_filtered,
            accy_filtered, accz_filtered, "AccX")
        self.gyr_filtered_fft_ax_x, self.gyr_filtered_fft_ax_y, self.gyr_filtered_fft_ax_z = self.init_fft(
            self.ax_gyr_fft, self.GYR_t, self.GYR_x, self.GYR_y, self.GYR_z, self.GYR_freq, self.gyr_dt, gyrx_filtered,
            gyry_filtered, gyrz_filtered, "GyrX")

        self.fig.tight_layout()

        # TODO add y z
        self.create_controls("acc", [0.75, 0.95, 0.2, 0.02], 0.01, self.ax_acc_fft, self.ACC_t,
                             (self.ACC_x, self.ACC_y, self.ACC_z),
                             (self.ax_filtered_accx, self.ax_filtered_accy, self.ax_filtered_accz),
                             (self.acc_filtered_fft_ax_x, self.acc_filtered_fft_ax_y, self.acc_filtered_fft_ax_z))
        self.create_controls("gyr", [0.75, 0.45, 0.2, 0.02], 0.01, self.ax_gyr_fft, self.GYR_t,
                             (self.GYR_x, self.GYR_y, self.GYR_z),
                             (self.ax_filtered_gyrx, self.ax_filtered_gyry, self.ax_filtered_gyrz),
                             (self.gyr_filtered_fft_ax_x, self.gyr_filtered_fft_ax_y, self.gyr_filtered_fft_ax_z))

        # setup animation for continuous update
        global anim
        anim = FuncAnimation(self.fig, lambda frame, self=self: self.animation_update(), interval=1, blit=False)

        # Work in progress here...
        # self.create_spectrogram(self.GYR_x, "GyrX", self.GYR_freq)
        # self.create_spectrogram(gyrx_filtered, "GyrX filtered", self.GYR_freq)
        # self.create_spectrogram(self.ACC_x, "AccX", self.ACC_freq)
        # self.create_spectrogram(accx_filtered, "AccX filtered", self.ACC_freq)

        plt.show()

        self.print_filter_param_info()

    def print_filter_param_info(self):
        if len(self.filters["acc"]) > 2 or len(self.filters["gyr"]) > 2:
            print("Testing too many filters unsupported from firmware, cannot calculate parameters to set them")
            return

        print("To have the last filter settings in the graphs set the following parameters:\n")

        for f in self.filters["acc"]:
            filt_type = f.get_type()

            if filt_type == BiquadFilterType.PEAK:  # NOTCH
                print("INS_NOTCA_ENABLE,", 1)
                print("INS_NOTCA_FREQ,", f.get_center_freq())
                print("INS_NOTCA_BW,", f.get_bandwidth())
                print("INS_NOTCA_ATT,", f.get_attenuation())
            else:  # LPF
                print("INS_ACCEL_FILTER,", f.get_center_freq())

        for f in self.filters["gyr"]:
            filt_type = f.get_type()

            if filt_type == BiquadFilterType.PEAK:  # NOTCH
                print("INS_HNTC2_ENABLE,", 1)
                print("INS_HNTC2_FREQ,", f.get_center_freq())
                print("INS_HNTC2_BW,", f.get_bandwidth())
                print("INS_HNTC2_ATT,", f.get_attenuation())
            else:  # LPF
                print("INS_GYRO_FILTER,", f.get_center_freq())

        print("\n+---------+")
        print("| WARNING |")
        print("+---------+")
        print("Always check the onboard FFT to setup filters, this tool only simulate effects of filtering.")
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   # ArduPilot IMU Filter Test Tool

**Warning: always check the onboard FFT to setup filters, this tool only simulates the effects of filtering.**

This is a tool to simulate IMU filtering on a raw IMU log.
This requires activating the RAW_IMU bit on the LOG_BITMASK parameter.
Currently only supports the primary IMU and does not use batch sampling.

To run it:

```bash
 python run_filter_test.py
```

This will open a file chooser dialog to select a log file.


Log file can also be specified from command line 

```bash
 python run_filter_test.py logfile.bin
```

To choose a smaller section of the log begin and/or end time can be specified in seconds.
E.g. to open only the log section between 60 and 120 seconds:

```bash
 python run_filter_test.py logfile.bin -b 60 -e 120
```

More info here:

  https://discuss.ardupilot.org/t/imu-filter-tool/43633
  

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   #!/usr/bin/env python
# -*- coding: utf-8 -*-

""" ArduPilot IMU Filter Test Tool

This program is free software: you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation, either version 3 of the License, or (at your option) any later
version.
This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
You should have received a copy of the GNU General Public License along with
this program. If not, see <http://www.gnu.org/licenses/>.
"""

__author__ = "Guglielmo Cassinelli"
__contact__ = "gdguglie@gmail.com"

try: # Python 3.x
    from tkinter import Tk
    from tkinter.filedialog import askopenfilename
except ImportError: # Python 2.x
    from Tkinter import Tk
    from tkFileDialog import askopenfilename

import argparse
import ntpath
import numpy as np
from pymavlink import mavutil


"""
read command line parameters
"""

parser = argparse.ArgumentParser(description='ArduPilot IMU Filter Tester Tool. Input one log file from ')
parser.add_argument('file', nargs='?', default=None, help='bin log file containing raw IMU logs')
parser.add_argument('--begin-time', '-b', type=int, default=0, help='start from second')
parser.add_argument('--end-time', '-e', type=int, default=-1, help='end to second')
parser.add_argument('--instance', type=int, default=0, help='IMU instance')

args = parser.parse_args()

log_file = args.file
begin_time = args.begin_time
end_time = args.end_time

# if log not input by command line
if not log_file:
    # GUI log file chooser
    root = Tk()
    root.withdraw()
    root.focus_force()
    log_file = askopenfilename(title="Select log file", filetypes=(("log files", ".BIN .bin .log"), ("all files", "*.*")))
    root.update()
    root.destroy()

if log_file is None or log_file == "":
    print("No log file to open")
    quit()

log_name = ntpath.basename(log_file)

"""
default settings
"""
POST_FILTER_LOGGING_BIT = 2 ** 1

RAW_IMU_LOG_BIT = 2 ** 19

PREVENT_POST_FILTER_LOGS = False

PARAMS_TO_CHECK = [
    "INS_LOG_BAT_OPT", "INS_GYRO_FILTER", "INS_ACCEL_FILTER",
    "INS_HNTC2_ENABLE", "INS_HNTC2_FREQ", "INS_HNTC2_BW", "INS_HNTC2_ATT",
    "INS_NOTCA_ENABLE", "INS_NOTCA_FREQ", "INS_NOTCA_BW", "INS_NOTCA_ATT",
    "LOG_BITMASK"
]

DEFAULT_ACC_FILTER = 80  # hz
DEFAULT_GYR_FILTER = 80  # hz

DEFAULT_ACC_NOTCH_FREQ = 150  # hz
DEFAULT_ACC_NOTCH_ATTENUATION = 30  # db
DEFAULT_ACC_NOTCH_BANDWIDTH = 100  # hz

DEFAULT_GYR_NOTCH_FREQ = 145
DEFAULT_GYR_NOTCH_ATTENUATION = 30  # db
DEFAULT_GYR_NOTCH_BANDWIDTH = 100  # hz

ACCEL_NOTCH_FILTER = True

"""
load LOG
"""
print("Loading %s...\n" % log_name)

mlog = mavutil.mavlink_connection(log_file)

log_start_time = 0
log_end_time = 0

ACC_t = []
ACC_x = []
ACC_y = []
ACC_z = []

GYR_t = []
GYR_x = []
GYR_y = []
GYR_z = []

params = {}

while True:
    m = mlog.recv_match(type=['PARM', 'GYR', 'ACC'])
    """
    @type m DFMessage
    """

    if m is None:
        break

    if m.fmt.name == "PARM":
        # check param value

        if m.Name in PARAMS_TO_CHECK:
            print(m.Name, ", ", m.Value)
            params[m.Name] = m.Value

    try:
        m_time_sec = m.TimeUS / 1000000.

        if log_start_time == 0:
            log_start_time = m_time_sec

        if m_time_sec < begin_time:
            continue

        if end_time > 0 and m_time_sec > end_time:
            continue
    except AttributeError:
        pass

    if m.fmt.name == "ACC" and m.I == args.instance:
        ACC_t.append(m_time_sec)
        ACC_x.append(m.AccX)
        ACC_y.append(m.AccY)
        ACC_z.append(m.AccZ)

    elif m.fmt.name == "GYR" and m.I == args.instance:
        GYR_t.append(m_time_sec)
        GYR_x.append(m.GyrX)
        GYR_y.append(m.GyrY)
        GYR_z.append(m.GyrZ)


def print_log_msg_stats(log_time_list, msg_name):
    msg_count = len(log_time_list)

    if msg_count > 0:
        msg_total_time = log_time_list[-1] - log_time_list[0]
        msg_freq = msg_count / msg_total_time
    else:
        msg_total_time = 0
        msg_freq = 0

    print("\n{} {} logs for a duration of {:.1f} secs".format(msg_count, msg_name, msg_total_time))
    print(msg_name + " frequency = {:.2f} hz".format(msg_freq))

    return msg_freq


def get_mean_and_std(np_arr):
    mean = np.mean(np_arr)
    std = np.std(np_arr)
    return mean, std


def print_mean_and_std(np_arr, name=""):
    mean, std = get_mean_and_std(np_arr)
    print("{} mean {:.3f}  std {:.3f}".format(name, mean, std))


def set_bit(number, bit_index, bit_value):
    """Set the index:th bit of v to 1 if x is truthy, else to 0, and return the new value."""
    mask = 1 << bit_index  # Compute mask, an integer with just bit 'index' set.
    number &= ~mask  # Clear the bit indicated by the mask (if x is False)
    if bit_value:
        number |= mask  # If x was True, set the bit indicated by the mask.
    return number  # Return the result, we're done.


ACC_freq = print_log_msg_stats(ACC_t, "ACC")
GYR_freq = print_log_msg_stats(GYR_t, "GYR")

if not ACC_t or not GYR_t:
    print("\nNo RAW IMU logs to analyze")
    quit()

if "INS_LOG_BAT_OPT" in params:
    log_bat_opt = int(params["INS_LOG_BAT_OPT"])
    if log_bat_opt & POST_FILTER_LOGGING_BIT:
        print("\nINS_LOG_BAT_OPT was set to {} which enables post filter logging,"
              "use pre filter logging to not sum multiple filter passes.".format(log_bat_opt))
        print("(set INS_LOG_BAT_OPT = {})".format(set_bit(log_bat_opt, 1, 0)))

        if PREVENT_POST_FILTER_LOGS:
            quit()
else:
    print("couldn't check ")

if "LOG_BITMASK" in params:
    log_bitmask = int(params["LOG_BITMASK"])
    if not log_bitmask & RAW_IMU_LOG_BIT:
        print("\nWARNING: LOG_BITMASK was not set to enable RAW_IMU logging, please enable it to have best resolution")
else:
    print("\nWARNING: Cannot read LOG_BITMASK, please ensure to have enabled RAW_IMU logging")

# set filter parameters
print("Reading filter parameters to set initial filter values...")

if "INS_GYRO_FILTER" in params:
    DEFAULT_GYR_FILTER = params["INS_GYRO_FILTER"]

if "INS_ACCEL_FILTER" in params:
    DEFAULT_ACC_FILTER = params["INS_ACCEL_FILTER"]

if "INS_HNTC2_ENABLE" in params:
    if params["INS_HNTC2_ENABLE"] != 0:
        if "INS_HNTC2_ATT" in params:
            DEFAULT_GYR_NOTCH_ATTENUATION = params["INS_HNTC2_ATT"]
    else:
        DEFAULT_GYR_NOTCH_ATTENUATION = 0

    if "INS_HNTC2_BW" in params:
        DEFAULT_GYR_NOTCH_BANDWIDTH = params["INS_HNTC2_BW"]

    if "INS_HNTC2_FREQ" in params:
        DEFAULT_GYR_NOTCH_FREQ = params["INS_HNTC2_FREQ"]

if "INS_NOTCA_ENABLE" in params:
    if params["INS_NOTCA_ENABLE"] != 0:
        if "INS_NOTCA_ATT" in params:
            DEFAULT_ACC_NOTCH_ATTENUATION = params["INS_NOTCA_ATT"]
    else:
        DEFAULT_ACC_NOTCH_ATTENUATION = 0

    if "INS_NOTCA_BW" in params:
        DEFAULT_ACC_NOTCH_BANDWIDTH = params["INS_NOTCA_BW"]

    if "INS_NOTCA_FREQ" in params:
        DEFAULT_ACC_NOTCH_FREQ = params["INS_NOTCA_FREQ"]

else:
    print("The firmware that produced this log does not support notch filter on accelerometer")
    ACCEL_NOTCH_FILTER = False


"""
run filter tet
"""
from FilterTest import FilterTest

filter_test = FilterTest(ACC_t, ACC_x, ACC_y, ACC_z, GYR_t, GYR_x, GYR_y, GYR_z, ACC_freq, GYR_freq,
                         DEFAULT_ACC_FILTER, DEFAULT_GYR_FILTER,
                         DEFAULT_ACC_NOTCH_FREQ, DEFAULT_ACC_NOTCH_ATTENUATION, DEFAULT_ACC_NOTCH_BANDWIDTH,
                         DEFAULT_GYR_NOTCH_FREQ, DEFAULT_GYR_NOTCH_ATTENUATION, DEFAULT_GYR_NOTCH_BANDWIDTH,
                         log_name, ACCEL_NOTCH_FILTER)
                                                                                                                                                                                                                                                                                                                                                                       #NOTE: 3DR IRIS+ on AC3.4 and higher
ACCEL_Z_D,0
ACCEL_Z_FILT,20
ACCEL_Z_I,1
ACCEL_Z_IMAX,800
ACCEL_Z_P,0.5
ACRO_YAW_P,3.0
ANGLE_MAX,3000
ATC_ACCEL_P_MAX,110000
ATC_ACCEL_R_MAX,110000
ATC_ACCEL_Y_MAX,18000
ATC_ANG_PIT_P,11.25
ATC_ANG_RLL_P,11.25
ATC_ANG_YAW_P,6
ATC_RAT_PIT_D,0.008325
ATC_RAT_PIT_FILT,20
ATC_RAT_PIT_FLTD,20
ATC_RAT_PIT_I,0.126
ATC_RAT_PIT_IMAX,0.2222222
ATC_RAT_PIT_P,0.126
ATC_RAT_RLL_D,0.01125
ATC_RAT_RLL_FILT,20
ATC_RAT_RLL_FLTD,20
ATC_RAT_RLL_I,0.18225
ATC_RAT_RLL_IMAX,0.2222222
ATC_RAT_RLL_P,0.18225
ATC_RAT_YAW_D,0.0036
ATC_RAT_YAW_FILT,5
ATC_RAT_YAW_FLTE,5
ATC_RAT_YAW_I,0.036
ATC_RAT_YAW_IMAX,0.222
ATC_RAT_YAW_P,0.36
ATC_RATE_FF_ENAB,1
ATC_SLEW_YAW,6000
BATT_AMP_PERVOLT,17
BATT_CAPACITY,5100
BATT_CURR_PIN,3
BATT_MONITOR,4
BATT_VOLT_MULT,12.02
BATT_VOLT_PIN,2
FENCE_ACTION,1
FENCE_ALT_MAX,100
FENCE_ENABLE,1
FENCE_MARGIN,2
FENCE_RADIUS,300
FENCE_TYPE,3
FRAME,2
FRAME_CLASS,1
FRAME_TYPE,2
FS_BATT_ENABLE,1
FS_BATT_VOLTAGE,10.5
FS_THR_ENABLE,1
GPS_HDOP_GOOD,140
MNT_ANGMAX_TIL,0
MNT_ANGMIN_TIL,-9000
MNT_MODE,3
MNT_RC_IN_TILT,6
MNT_TYPE,1
MOT_SPIN_ARM,0.1
MOT_SPIN_MIN,0.15
MOT_THST_EXPO,0.65
MOT_THST_HOVER,0.46
PILOT_ACCEL_Z,250
PILOT_VELZ_MAX,250
POS_XY_P,1
POS_Z_P,1
RC_FEEL_RP,25
RC9_FUNCTION,7
RC9_MAX,1520
RC9_MIN,1000
RTL_ALT,2000
SERIAL2_PROTOCOL,3
THR_DZ,50
VEL_XY_FILT_HZ,5
VEL_XY_I,0.5
VEL_XY_IMAX,1000
VEL_XY_P,1
VEL_Z_P,5
WPNAV_ACCEL,250
WPNAV_ACCEL_Z,50
WPNAV_LOIT_JERK,4000
WPNAV_LOIT_MAXA,980
WPNAV_LOIT_MINA,100
WPNAV_LOIT_SPEED,1000
WPNAV_RADIUS,200
WPNAV_SPEED,650
WPNAV_SPEED_DN,150
WPNAV_SPEED_UP,250
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 #NOTE: AION Robotics Params for Rover V4.5.0 (and higher)
ACRO_TURN_RATE,120
ATC_ACCEL_MAX,0.75
ATC_DECEL_MAX,1.5
ATC_SPEED_P,0.5
ATC_SPEED_I,0.5
ATC_SPEED_D,0.018
ATC_SPEED_FLTE,10
ATC_STR_ACC_MAX,120
ATC_STR_ANG_P,2
ATC_STR_RAT_FF,0.25
ATC_STR_RAT_P,0.13
ATC_STR_RAT_I,0.13
ATC_STR_RAT_D,0.0
ATC_STR_RAT_FLTD,2
ATC_STR_RAT_FLTE,10
ATC_STR_RAT_FLTT,2
ATC_STR_RAT_MAX,120
ATC_TURN_MAX_G,0.3
BATT_MONITOR,4
BRD_PWM_COUNT,2
BRD_SAFETY_DEFLT,0
COMPASS_OFFS_MAX,2000
COMPASS_USE,1
COMPASS_USE2,0
COMPASS_USE3,0
CRUISE_SPEED,1.0
CRUISE_THROTTLE,70
FRAME_CLASS,1
FRAME_TYPE,0
PSC_POS_P,0.2
PSC_VEL_FLTD,5
PSC_VEL_FLTE,5
PSC_VEL_I,0
PSC_VEL_P,1
WP_PIVOT_ANGLE,60
WP_PIVOT_RATE,60
SERVO1_FUNCTION,73
SERVO1_MAX,2000
SERVO1_MIN,1000
SERVO3_FUNCTION,74
SERVO3_MAX,2000
SERVO3_MIN,1000
WENC_CPR,1120
WENC_PINA,55
WENC_PINB,54
WENC_POS_X,-0.15
WENC_POS_Y,-0.16
WENC_POS_Z,0
WENC_RADIUS,0.0775
WENC_TYPE,0
WENC2_CPR,1120
WENC2_PINA,53
WENC2_PINB,52
WENC2_POS_X,-0.15
WENC2_POS_Y,0.16
WENC2_POS_Z,0
WENC_RADIUS,0.0775
WENC2_TYPE,0
WP_RADIUS,2
WP_SPEED,1
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   #NOTE: ArduRoller balance bot parameters for Rover-4.3 and higher
ACRO_TURN_RATE,90
AHRS_ORIENTATION,29
ATC_ACCEL_MAX,5
ATC_BAL_D,0.18
ATC_BAL_FF,0
ATC_BAL_FLTD,0
ATC_BAL_FILT,0
ATC_BAL_FLTE,0
ATC_BAL_I,7
ATC_BAL_IMAX,1
ATC_BAL_P,5
ATC_BRAKE,1
ATC_STR_ACC_MAX,120
BAL_PITCH_MAX,10
CRASH_ANGLE,45
CRUISE_SPEED,0.4
CRUISE_THROTTLE,50
FRAME_CLASS,3
FS_CRASH_CHECK,1
MOT_PWM_TYPE,0
MOT_SLEWRATE,0
MOT_THR_MIN,6
MOT_THST_EXPO,-0.5
RELAY_PIN,-1
RELAY_PIN2,-1
SCHED_LOOP_RATE,200
SERVO1_FUNCTION,73
SERVO1_MAX,2000
SERVO1_MIN,1000
SERVO1_REVERSED,0
SERVO1_TRIM,1500
SERVO3_FUNCTION,74
SERVO3_MAX,2000
SERVO3_MIN,1000
SERVO3_REVERSED,1
SERVO3_TRIM,1500
SERVO11_FUNCTION,-1
SERVO12_FUNCTION,-1
SERVO13_FUNCTION,-1
SERVO14_FUNCTION,-1
ATC_TURN_MAX_G,0.2
WENC_CPR,1600
WENC_PINA,55
WENC_PINB,54
WENC_POS_X,0
WENC_POS_Y,-0.1
WENC_POS_Z,0
WENC_RADIUS,0.06
WENC_TYPE,1
WENC2_CPR,1600
WENC2_PINA,53
WENC2_PINB,52
WENC2_POS_X,0
WENC2_POS_Y,0.1
WENC2_POS_Z,0
WENC2_RADIUS,0.06
WENC2_TYPE,1
WRC_RATE_D,0.2
WRC_RATE_FF,4.2
WRC_RATE_FLTD,50
WRC_RATE_I,4
WRC_RATE_IMAX,1
WRC_RATE_MAX,12
WRC_RATE_P,0
WRC2_RATE_D,0.2
WRC2_RATE_FF,4.2
WRC2_RATE_FLTD,50
WRC2_RATE_I,4
WRC2_RATE_IMAX,1
WRC2_RATE_P,0
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  #NOTE: DJI AGRAS MG-1params for ArduPilot Copter 4.1.3, Provided by Axel Weckschmied
ACRO_YAW_P,1.9
ATC_ACCEL_P_MAX,46200
ATC_ACCEL_R_MAX,46200
ATC_ACCEL_Y_MAX,17100
ATC_RAT_PIT_FLTD,11.5
ATC_RAT_PIT_FLTT,11.5
ATC_RAT_RLL_FLTD,11.5
ATC_RAT_RLL_FLTT,11.5
ATC_RAT_YAW_FLTE,2
ATC_RAT_YAW_FLTT,11.5
BATT_AMP_PERVLT,36
BATT_CAPACITY,12000
BATT_MONITOR,3
BATT_VOLT_MULT,18.1
BRD_IMU_TARGTEMP,60
BRD_PWM_COUNT,5
FRAME_CLASS,3
INS_GYRO_FILTER,23
MOT_BAT_VOLT_MAX,50.4
MOT_BAT_VOLT_MIN,39.6
MOT_SPIN_ARM,0.15
MOT_SPIN_MIN,0.2
MOT_THST_EXPO,0.75
MOT_THST_HOVER,0.1869573
PSC_ACCZ_I,0.4
PSC_ACCZ_P,0.2
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      # encoding: utf-8

from __future__ import print_function
from waflib import Build, ConfigSet, Configure, Context, Errors, Logs, Options, Utils, Task
from waflib.Configure import conf
from waflib.Scripting import run_command
from waflib.TaskGen import before_method, after_method, feature
import os.path, os
from collections import OrderedDict
import subprocess

import ap_persistent

SOURCE_EXTS = [
    '*.S',
    '*.c',
    '*.cpp',
]

COMMON_VEHICLE_DEPENDENT_CAN_LIBRARIES = [
    'AP_CANManager',
    'AP_KDECAN',
    'AP_PiccoloCAN',
    'AP_PiccoloCAN/piccolo_protocol',
]

COMMON_VEHICLE_DEPENDENT_LIBRARIES = [
    'AP_Airspeed',
    'AP_AccelCal',
    'AP_ADC',
    'AP_AHRS',
    'AP_Airspeed',
    'AP_Baro',
    'AP_BattMonitor',
    'AP_BoardConfig',
    'AP_Camera',
    'AP_Common',
    'AP_Compass',
    'AP_Declination',
    'AP_GPS',
    'AP_GSOF',
    'AP_HAL',
    'AP_HAL_Empty',
    'AP_InertialSensor',
    'AP_Math',
    'AP_Mission',
    'AP_DAL',
    'AP_NavEKF',
    'AP_NavEKF2',
    'AP_NavEKF3',
    'AP_Notify',
    'AP_OpticalFlow',
    'AP_Param',
    'AP_Rally',
    'AP_RangeFinder',
    'AP_Scheduler',
    'AP_SerialManager',
    'AP_Terrain',
    'AP_Vehicle',
    'AP_InternalError',
    'AP_Logger',
    'Filter',
    'GCS_MAVLink',
    'RC_Channel',
    'SRV_Channel',
    'StorageManager',
    'AP_Tuning',
    'AP_RPM',
    'AP_RSSI',
    'AP_Mount',
    'AP_Module',
    'AP_Button',
    'AP_ICEngine',
    'AP_Networking',
    'AP_Frsky_Telem',
    'AP_IBus_Telem',
    'AP_FlashStorage',
    'AP_Relay',
    'AP_ServoRelayEvents',
    'AP_Volz_Protocol',
    'AP_SBusOut',
    'AP_IOMCU',
    'AP_Parachute',
    'AP_RAMTRON',
    'AP_RCProtocol',
    'AP_Radio',
    'AP_TempCalibration',
    'AP_VisualOdom',
    'AP_BLHeli',
    'AP_ROMFS',
    'AP_Proximity',
    'AP_Gripper',
    'AP_RTC',
    'AC_Sprayer',
    'AC_Fence',
    'AC_Avoidance',
    'AP_LandingGear',
    'AP_RobotisServo',
    'AP_NMEA_Output',
    'AP_OSD',
    'AP_Filesystem',
    'AP_ADSB',
    'AP_ADSB/sagetech-sdk',
    'AC_PID',
    'AP_SerialLED',
    'AP_EFI',
    'AP_Hott_Telem',
    'AP_ESC_Telem',
    'AP_Stats',
    'AP_GyroFFT',
    'AP_RCTelemetry',
    'AP_Generator',
    'AP_MSP',
    'AP_OLC',
    'AP_WheelEncoder',
    'AP_ExternalAHRS',
    'AP_VideoTX',
    'AP_FETtecOneWire',
    'AP_TemperatureSensor',
    'AP_Torqeedo',
    'AP_CustomRotations',
    'AP_AIS',
    'AP_OpenDroneID',
    'AP_CheckFirmware',
    'AP_ExternalControl',
    'AP_JSON',
    'AP_Beacon',
    'AP_Arming',
    'AP_RCMapper',
]

def get_legacy_defines(sketch_name, bld):
    # If we are building heli, we adjust the build directory define so that 
    # we do not need to actually split heli and copter directories
    if bld.cmd == 'heli' or 'heli' in bld.targets:
        return [
        'APM_BUILD_DIRECTORY=APM_BUILD_Heli',
        'AP_BUILD_TARGET_NAME="' + sketch_name + '"',
        ]

    return [
        'APM_BUILD_DIRECTORY=APM_BUILD_' + sketch_name,
        'AP_BUILD_TARGET_NAME="' + sketch_name + '"',
    ]

IGNORED_AP_LIBRARIES = [
    'doc',
    'AP_Scripting', # this gets explicitly included when it is needed and should otherwise never be globbed in
    'AP_DDS',
]


def ap_autoconfigure(execute_method):
    """
    Decorator that enables context commands to run *configure* as needed.
    """
    def execute(self):
        """
        Wraps :py:func:`waflib.Context.Context.execute` on the context class
        """
        if 'tools/' in self.targets:
            raise Errors.WafError('\"tools\" name has been replaced with \"tool\" for build please use that!')
        if not Configure.autoconfig:
            return execute_method(self)

        # Disable autoconfig so waf's version doesn't run (and don't end up on loop of bad configure)
        Configure.autoconfig = False

        if self.variant == '':
            raise Errors.WafError('The project is badly configured: run "waf configure" again!')

        env = ConfigSet.ConfigSet()
        do_config = False

        try:
            p = os.path.join(Context.out_dir, Build.CACHE_DIR, self.variant + Build.CACHE_SUFFIX)
            env.load(p)
        except EnvironmentError:
            raise Errors.WafError('The project is not configured for board {0}: run "waf configure --board {0} [...]" first!'.format(self.variant))

        lock_env = ConfigSet.ConfigSet()

        try:
            lock_env.load(os.path.join(Context.top_dir, Options.lockfile))
        except EnvironmentError:
            Logs.warn('Configuring the project')
            do_config = True
        else:
            if lock_env.run_dir != Context.run_dir:
                do_config = True
            else:
                h = 0

                for f in env.CONFIGURE_FILES:
                    try:
                        h = Utils.h_list((h, Utils.readf(f, 'rb')))
                    except EnvironmentError:
                        do_config = True
                        break
                else:
                    do_config = h != env.CONFIGURE_HASH

        if do_config:
            cmd = lock_env.config_cmd or 'configure'
            tmp = Options.options.__dict__

            if env.OPTIONS and sorted(env.OPTIONS.keys()) == sorted(tmp.keys()):
                Options.options.__dict__ = env.OPTIONS
            else:
                raise Errors.WafError('The project configure options have changed: run "waf configure" again!')

            try:
                run_command(cmd)
            finally:
                Options.options.__dict__ = tmp

            run_command(self.cmd)
        else:
            return execute_method(self)

    return execute

def ap_configure_post_recurse():
    post_recurse_orig = Configure.ConfigurationContext.post_recurse

    def post_recurse(self, node):
        post_recurse_orig(self, node)

        self.all_envs[self.variant].CONFIGURE_FILES = self.files
        self.all_envs[self.variant].CONFIGURE_HASH = self.hash

    return post_recurse

@conf
def ap_get_all_libraries(bld):
    if bld.env.BOOTLOADER:
        # we don't need the full set of libraries for the bootloader build
        return ['AP_HAL']
    libraries = []
    for lib_node in bld.srcnode.ant_glob('libraries/*', dir=True, src=False):
        name = lib_node.name
        if name in IGNORED_AP_LIBRARIES:
            continue
        if name.startswith('AP_HAL'):
            continue
        if name == 'SITL':
            continue
        libraries.append(name)
    libraries.extend(['AP_HAL', 'AP_HAL_Empty'])
    libraries.append('AP_PiccoloCAN/piccolo_protocol')
    return libraries

@conf
def ap_common_vehicle_libraries(bld):
    libraries = COMMON_VEHICLE_DEPENDENT_LIBRARIES

    if bld.env.with_can or bld.env.HAL_NUM_CAN_IFACES:
        libraries.extend(COMMON_VEHICLE_DEPENDENT_CAN_LIBRARIES)

    return libraries

_grouped_programs = {}

class check_elf_symbols(Task.Task):
    color='CYAN'
    always_run = True
    def keyword(self):
        return "checking symbols"

    def run(self):
        '''
        check for disallowed symbols in elf file, such as C++ exceptions
        '''
        elfpath = self.inputs[0].abspath()

        if not self.env.CHECK_SYMBOLS:
            # checking symbols disabled on this build
            return

        if not self.env.vehicle_binary or self.env.SIM_ENABLED:
            # we only want to check symbols for vehicle binaries, allowing examples
            # to use C++ exceptions. We also allow them in simulator builds
            return

        # we use string find on these symbols, so this catches all types of throw
        # calls this should catch all uses of exceptions unless the compiler
        # manages to inline them
        blacklist = ['std::__throw',
                     'operator new[](unsigned int)',
                     'operator new[](unsigned long)',
                     'operator new(unsigned int)',
                     'operator new(unsigned long)']

        nmout = subprocess.getoutput("%s -C %s" % (self.env.get_flat('NM'), elfpath))
        for b in blacklist:
            if nmout.find(b) != -1:
                raise Errors.WafError("Disallowed symbol in %s: %s" % (elfpath, b))


@feature('post_link')
@after_method('process_source')
def post_link(self):
    '''
    setup tasks to run after link stage
    '''
    self.link_task.always_run = True

    link_output = self.link_task.outputs[0]

    check_elf_task = self.create_task('check_elf_symbols', src=link_output)
    check_elf_task.set_run_after(self.link_task)
    
@conf
def ap_program(bld,
               program_groups='bin',
               program_dir=None,
               use_legacy_defines=True,
               program_name=None,
               vehicle_binary=True,
               **kw):
    if 'target' in kw:
        bld.fatal('Do not pass target for program')
    if 'defines' not in kw:
        kw['defines'] = []
    if 'source' not in kw:
        kw['source'] = bld.path.ant_glob(SOURCE_EXTS)

    if not program_name:
        program_name = bld.path.name

    if use_legacy_defines:
        kw['defines'].extend(get_legacy_defines(bld.path.name, bld))

    kw['features'] = kw.get('features', []) + bld.env.AP_PROGRAM_FEATURES + ['post_link']

    program_groups = Utils.to_list(program_groups)

    if not program_dir:
        program_dir = program_groups[0]

    name = os.path.join(program_dir, program_name)

    tg_constructor = bld.program
    if bld.env.AP_PROGRAM_AS_STLIB:
        tg_constructor = bld.stlib
    else:
        if bld.env.STATIC_LINKING:
            kw['features'].append('static_linking')


    tg = tg_constructor(
        target='#%s' % name,
        name=name,
        program_name=program_name,
        program_dir=program_dir,
        **kw
    )

    tg.env.vehicle_binary = vehicle_binary

    if 'use' in kw and bld.env.STATIC_LINKING:
        # ensure we link against vehicle library
        tg.env.STLIB += [kw['use']]

    for group in program_groups:
        _grouped_programs.setdefault(group, {}).update({tg.name : tg})

    return tg


@conf
def ap_example(bld, **kw):
    kw['program_groups'] = 'examples'
    ap_program(bld, use_legacy_defines=False, vehicle_binary=False, **kw)

def unique_list(items):
    '''remove duplicate elements from a list while maintaining ordering'''
    return list(OrderedDict.fromkeys(items))

@conf
def ap_stlib(bld, **kw):
    if 'name' not in kw:
        bld.fatal('Missing name for ap_stlib')
    if 'ap_vehicle' not in kw:
        bld.fatal('Missing ap_vehicle for ap_stlib')
    if 'ap_libraries' not in kw:
        bld.fatal('Missing ap_libraries for ap_stlib')

    kw['ap_libraries'] = unique_list(kw['ap_libraries'] + bld.env.AP_LIBRARIES)
    for l in kw['ap_libraries']:
        bld.ap_library(l, kw['ap_vehicle'])

    if 'dynamic_source' not in kw:
        kw['dynamic_source'] = 'modules/DroneCAN/libcanard/dsdlc_generated/src/**.c'

    kw['features'] = kw.get('features', []) + ['cxx', 'cxxstlib']
    kw['target'] = kw['name']
    kw['source'] = []

    bld.stlib(**kw)

_created_program_dirs = set()
@feature('cxxstlib', 'cxxprogram')
@before_method('process_rule')
def ap_create_program_dir(self):
    if not hasattr(self, 'program_dir'):
        return
    if self.program_dir in _created_program_dirs:
        return
    self.bld.bldnode.make_node(self.program_dir).mkdir()
    _created_program_dirs.add(self.program_dir)

@feature('cxxstlib')
@before_method('process_rule')
def ap_stlib_target(self):
    if self.target.startswith('#'):
        self.target = self.target[1:]
    self.target = '#%s' % os.path.join('lib', self.target)

@conf
def ap_find_tests(bld, use=[], DOUBLE_PRECISION_SOURCES=[]):
    if not bld.env.HAS_GTEST:
        return

    features = []
    if bld.cmd == 'check':
        features.append('test')

    use = Utils.to_list(use)
    use.append('GTEST')

    includes = [bld.srcnode.abspath() + '/tests/']

    for f in bld.path.ant_glob(incl='*.cpp'):
        t = ap_program(
            bld,
            features=features,
            includes=includes,
            source=[f],
            use=use,
            program_name=f.change_ext('').name,
            program_groups='tests',
            use_legacy_defines=False,
            vehicle_binary=False,
            cxxf