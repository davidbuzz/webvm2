               num_outputs = 8;
                        break;

                    case AP_Motors::MOTOR_FRAME_HELI_QUAD:
                        motors_heli = new AP_MotorsHeli_Quad(400);
                        motors = motors_heli;
                        num_outputs = 4; // Only 4 collective servos
                        break;

                    default:
                        ::printf("ERROR: frame_class=%d not implemented\n", frame_class);
                        exit(1);
                }

                // Init motors
                motors->init(frame_class, AP_Motors::MOTOR_FRAME_TYPE_X);

                // Get the numper of outputs for a regular copter dynamically.  We can't currently do this for heli because the motor mask doesn't tell us the write thing
                if (motors_matrix != nullptr) {
                    num_outputs = __builtin_popcount(motors->get_motor_mask());
                }

                // Check that init worked
                if (!motors->initialised_ok()) {
                    ::printf("ERROR: frame_class=%d initialisation failed\n", frame_class);
                    exit(1);
                }

            } else if (strcmp(cmd,"COL2YAW") == 0) {
                if (frame_class != AP_Motors::MOTOR_FRAME_HELI) {
                    ::printf("COL2YAW only supported by single heli frame type (%i), got %i\n", AP_Motors::MOTOR_FRAME_HELI, frame_class);
                    exit(1);
                }

                // Union allows pointers to be aligned despite different sizes
                // avoids "increases required alignment of target type" error when casting from char* to AP_Int16*
                union {
                    char *char_ptr;
                    AP_Float *ap_float;
                } collective_yaw_scale;

                collective_yaw_scale.char_ptr = (char*)motors + AP_MotorsHeli_Single::var_info[7].offset;
                collective_yaw_scale.ap_float->set(value);

            } else if (strcmp(cmd,"autorotation") == 0) {
                if (motors_heli == nullptr) {
                    ::printf("autorotation only supported by heli frame types, got %i\n", frame_class);
                    exit(1);
                }
                motors_heli->set_in_autorotation(!is_zero(value));

            } else {
                ::printf("Expected \"frame_class\", \"yaw_headroom\" or \"throttle_avg_max\"\n");
                exit(1);
            }
        }

        // if we haven't been given a frame class by argument we just assume a quad by default
        // so that the single first argument s or t still works
        if (motors == nullptr) {
            motors_matrix = new AP_MotorsMatrix(400);
            motors = motors_matrix;
            motors->init(AP_Motors::MOTOR_FRAME_QUAD, AP_Motors::MOTOR_FRAME_TYPE_X);
            num_outputs = 4;
        }

        // motor initialisation
        motors->set_dt(1.0/400.0);
        motors->set_update_rate(490);
        motors->output_min();

        // Start a test type based on the input argument
        if (strcmp(argv[1],"t") == 0) {
            motor_order_test();

        } else if (strcmp(argv[1],"s") == 0) {
            stability_test();

        } else if (strcmp(argv[1],"p") == 0) {
            if (motors_matrix == nullptr) {
                motors_matrix = new AP_MotorsMatrix(400);
            }
            if (motors_tri == nullptr) {
                motors_tri = new AP_MotorsTri(400);
            }
            print_all_motors();

        } else {
            ::printf("Expected first argument: 't', 's' or 'p'\n");

        }

        hal.scheduler->delay(1000);
        exit(0);

    } else {
        // We haven't been given a frame class so we just assume a quad frame as default
        motors_matrix = new AP_MotorsMatrix(400);
        motors = motors_matrix;
        motors->init(AP_Motors::MOTOR_FRAME_QUAD, AP_Motors::MOTOR_FRAME_TYPE_X);
        num_outputs = 4;
    }

    // motor initialisation
    motors->set_dt(1.0/400.0);
    motors->set_update_rate(490);

    char frame_and_type_string[30];
    motors->get_frame_and_type_string(frame_and_type_string, ARRAY_SIZE(frame_and_type_string));
    hal.console->printf("%s\n", frame_and_type_string);

    if (motors_matrix != nullptr) {
        motors_matrix->update_throttle_range();
        motors_matrix->set_throttle_avg_max(0.5f);
    }

    motors->output_min();

    hal.scheduler->delay(1000);
}

// loop
void loop()
{
    int16_t value;

    // display help
    hal.console->printf("Press 't' to run motor orders test, 's' to run stability patch test.  Be careful the motors will spin!\n");

    // wait for user to enter something
    while( !hal.console->available() ) {
        hal.scheduler->delay(20);
    }

    // get character from user
    value = hal.console->read();

    // test motors
    if (value == 't' || value == 'T') {
        motor_order_test();
        hal.console->printf("finished test.\n");
    }
    if (value == 's' || value == 'S') {
        stability_test();
        hal.console->printf("finished test.\n");
    }
}

bool first_layout = true;

// print motor layout for all frame types in json format
void print_all_motors()
{
    hal.console->printf("{\n");
    hal.console->printf("\t\"Version\": \"%s\",\n", VERSION);
    hal.console->printf("\t\"layouts\": [\n");

    first_layout = true;

    for (uint8_t frame_class=0; frame_class <= AP_Motors::MOTOR_FRAME_DECA; frame_class++) {
        for (uint8_t frame_type=0; frame_type < AP_Motors::MOTOR_FRAME_TYPE_Y4; frame_type++) {
            if (frame_class == AP_Motors::MOTOR_FRAME_TRI) {
                print_motor_tri(frame_class, frame_type);
            } else {
                print_motor_matrix(frame_class, frame_type);
            }
        }
    }

    hal.console->printf("\n");
    hal.console->printf("\t]\n");
    hal.console->printf("}\n");
}

void print_motor_tri(uint8_t frame_class, uint8_t frame_type)
{
    char frame_and_type_string[30];
    motors_tri->init((AP_Motors::motor_frame_class)frame_class, (AP_Motors::motor_frame_type)frame_type);
    if (motors_tri->initialised_ok()) {
        if (!first_layout) {
            hal.console->printf(",\n");
        }
        first_layout = false;

        // Grab full frame string and strip "Frame: " and split
        // This is the long way round, motors does have direct getters, but there protected
        motors_tri->get_frame_and_type_string(frame_and_type_string, ARRAY_SIZE(frame_and_type_string));
        char *frame_string = strchr(frame_and_type_string, ':');
        char *type_string = strchr(frame_and_type_string, '/');
        if (type_string != nullptr) {
            *type_string = 0;
        }

        hal.console->printf("\t\t{\n");
        hal.console->printf("\t\t\t\"Class\": %i,\n", frame_class);
        hal.console->printf("\t\t\t\"ClassName\": \"%s\",\n", frame_string+2);
        hal.console->printf("\t\t\t\"Type\": %i,\n", frame_type);
        hal.console->printf("\t\t\t\"TypeName\": \"%s\",\n", (type_string != nullptr) ? type_string + 1 : "default");
        hal.console->printf("\t\t\t\"motors\": [\n");
        bool first_motor = true;
        for (uint8_t i = 0; i < AP_MOTORS_MAX_NUM_MOTORS; i++) {
            float roll, pitch;
            uint8_t testing_order;
            roll = motors_tri->get_roll_factor(i);
            pitch = motors_tri->get_pitch_factor_json(i);
            testing_order = motors_tri->get_motor_test_order(i);
            if (testing_order) {
                if (!first_motor) {
                    hal.console->printf(",\n");
                }
                first_motor = false;
                hal.console->printf("\t\t\t\t{\n");
                hal.console->printf("\t\t\t\t\t\"Number\": %i,\n", i+1);
                hal.console->printf("\t\t\t\t\t\"TestOrder\": %i,\n", testing_order);
                hal.console->printf("\t\t\t\t\t\"Rotation\": \"?\",\n");
                hal.console->printf("\t\t\t\t\t\"Roll\": %0.4f,\n", roll);
                hal.console->printf("\t\t\t\t\t\"Pitch\": %0.4f\n", pitch);
                hal.console->printf("\t\t\t\t}");
                while (hal.console->tx_pending()) { ; }
            }
        }
        hal.console->printf("\n");
        hal.console->printf("\t\t\t]\n");
        hal.console->printf("\t\t}");

    }
}

void print_motor_matrix(uint8_t frame_class, uint8_t frame_type)
{
    char frame_and_type_string[30];
    motors_matrix->init((AP_Motors::motor_frame_class)frame_class, (AP_Motors::motor_frame_type)frame_type);
    if (motors_matrix->initialised_ok()) {
        if (!first_layout) {
            hal.console->printf(",\n");
        }
        first_layout = false;

        // Grab full frame string and strip "Frame: " and split
        // This is the long way round, motors does have direct getters, but there protected
        motors_matrix->get_frame_and_type_string(frame_and_type_string, ARRAY_SIZE(frame_and_type_string));
        char *frame_string = strchr(frame_and_type_string, ':');
        char *type_string = strchr(frame_and_type_string, '/');
        if (type_string != nullptr) {
            *type_string = 0;
        }

        hal.console->printf("\t\t{\n");
        hal.console->printf("\t\t\t\"Class\": %i,\n", frame_class);
        hal.console->printf("\t\t\t\"ClassName\": \"%s\",\n", frame_string+2);
        hal.console->printf("\t\t\t\"Type\": %i,\n", frame_type);
        hal.console->printf("\t\t\t\"TypeName\": \"%s\",\n", (type_string != nullptr) ? type_string + 1 : "?");
        hal.console->printf("\t\t\t\"motors\": [\n");
        bool first_motor = true;
        for (uint8_t i = 0; i < AP_MOTORS_MAX_NUM_MOTORS; i++) {
            float roll, pitch, yaw, throttle;
            uint8_t testing_order;
            if (motors_matrix->get_factors(i, roll, pitch, yaw, throttle, testing_order)) {
                if (!first_motor) {
                    hal.console->printf(",\n");
                }
                first_motor = false;
                hal.console->printf("\t\t\t\t{\n");
                hal.console->printf("\t\t\t\t\t\"Number\": %i,\n", i+1);
                hal.console->printf("\t\t\t\t\t\"TestOrder\": %i,\n", testing_order);
                hal.console->printf("\t\t\t\t\t\"Rotation\": ");
                if (is_positive(yaw)) {
                    hal.console->printf("\"CCW\",\n");
                } else if (is_negative(yaw)) {
                    hal.console->printf("\"CW\",\n");
                } else {
                    hal.console->printf("\"?\",\n");
                }
                hal.console->printf("\t\t\t\t\t\"Roll\": %0.4f,\n", roll);
                hal.console->printf("\t\t\t\t\t\"Pitch\": %0.4f\n", pitch);
                hal.console->printf("\t\t\t\t}");
                while (hal.console->tx_pending()) { ; }
            }
        }
        hal.console->printf("\n");
        hal.console->printf("\t\t\t]\n");
        hal.console->printf("\t\t}");

    }
}

// stability_test
void motor_order_test()
{
    hal.console->printf("testing motor order\n");
    motors->armed(true);
    for (int8_t i=1; i <= num_outputs; i++) {
        hal.console->printf("Motor %d\n",(int)i);
        motors->output_test_seq(i, 1150);
        hal.scheduler->delay(300);
        motors->output_test_seq(i, 1000);
        hal.scheduler->delay(2000);
    }
    motors->armed(false);

}

// stability_test
void stability_test()
{
    hal.console->printf("%s\n", VERSION);
    char frame_and_type_string[30];
    motors->get_frame_and_type_string(frame_and_type_string, ARRAY_SIZE(frame_and_type_string));
    hal.console->printf("%s\n", frame_and_type_string);

    if (motors_matrix != nullptr) {
        hal.console->printf("Throttle average max: %0.4f\n",  motors_matrix->get_throttle_avg_max());
        hal.console->printf("Yaw headroom: %i\n", motors_matrix->get_yaw_headroom());
        hal.console->printf("Thrust boost: %s\n", thrust_boost?"True":"False");
    }

    const float throttle_tests[] = {0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0};
    const uint8_t throttle_tests_num = ARRAY_SIZE(throttle_tests);
    const float rpy_tests[] = {-1.0, -0.9, -0.8, -0.7, -0.6, -0.5, -0.4, -0.3, -0.2, -0.1, 0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0};
    const uint8_t rpy_tests_num = ARRAY_SIZE(rpy_tests);

    // arm motors
    motors->armed(true);
    motors->set_interlock(true);
    SRV_Channels::enable_aux_servos();

    hal.console->printf("Roll,Pitch,Yaw,Thr,");
    for (uint8_t i=0; i<num_outputs; i++) {
        hal.console->printf("Mot%i,",i+1);
    }

    if (motors_matrix != nullptr) {
        for (uint8_t i=0; i<num_outputs; i++) {
            hal.console->printf("Mot%i_norm,",i+1);
        }
    }

    hal.console->printf("LimR,LimP,LimY,LimThD,LimThU\n");

    // run stability test
    for (uint8_t y=0; y<rpy_tests_num; y++) {
        for (uint8_t p=0; p<rpy_tests_num; p++) {
            for (uint8_t r=0; r<rpy_tests_num; r++) {
                for (uint8_t t=0; t<throttle_tests_num; t++) {
                    const float roll_in = rpy_tests[r];
                    const float pitch_in = rpy_tests[p];
                    const float yaw_in = rpy_tests[y];
                    const float throttle_in = throttle_tests[t];
                    motors->set_roll(roll_in);
                    motors->set_pitch(pitch_in);
                    motors->set_yaw(yaw_in);
                    motors->set_throttle(throttle_in);
                    motors->set_desired_spool_state(AP_Motors::DesiredSpoolState::THROTTLE_UNLIMITED);
                    update_motors();
                    SRV_Channels::calc_pwm();
                    SRV_Channels::output_ch_all();
                    // display input and output
                    hal.console->printf("%0.2f,%0.2f,%0.2f,%0.2f,", roll_in, pitch_in, yaw_in, throttle_in);
                    for (uint8_t i=0; i<num_outputs; i++) {
                        hal.console->printf("%d,",(int)hal.rcout->read(i));
                    }

                    if (motors_matrix != nullptr) {
                        for (uint8_t i=0; i<num_outputs; i++) {
                            hal.console->printf("%0.4f,", motors_matrix->get_thrust_rpyt_out(i));
                        }
                    }

                    hal.console->printf("%d,%d,%d,%d,%d\n",
                            (int)motors->limit.roll,
                            (int)motors->limit.pitch,
                            (int)motors->limit.yaw,
                            (int)motors->limit.throttle_lower,
                            (int)motors->limit.throttle_upper);
                }
            }
        }
    }

    // set all inputs to motor library to zero and disarm motors
    motors->set_pitch(0);
    motors->set_roll(0);
    motors->set_yaw(0);
    motors->set_throttle(0);
    motors->armed(false);

}

void update_motors()
{
    // call update motors 1000 times to get any ramp limiting complete
    for (uint16_t i=0; i<1000; i++) {
        motors->set_thrust_boost(thrust_boost);
        motors->output();
    }
}

AP_HAL_MAIN();
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          #!/usr/bin/env bash
# Build and run the motors example stability test at a range of yaw headroom and throttle average max values
# Output results to files for comparison

cd "$(dirname "$0")"
cd ../../../..

mkdir -p MotorTestSweep

./waf configure --board linux
./waf build --target examples/AP_Motors_test
echo

YAW_HEADROOM="0 100 200 300 400 500 600 700 800 900 1000"
THR_AVERAGE_MAX="0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0"

# Change this to change the frame classes to test. Testing all takes a while.
FRAME_CLASS="1 2 3 6 11 13"

COUNTER=0
for frame_class in $FRAME_CLASS; do
    echo "Frame Class: $frame_class"
    for headroom in $YAW_HEADROOM; do
        echo "Yaw Headroom: $headroom"
        for Thr in $THR_AVERAGE_MAX; do
            echo "    Throttle average max: $Thr"
            # Test with and without boost
            ./build/linux/examples/AP_Motors_test s frame_class=$frame_class yaw_headroom=$headroom throttle_avg_max=$Thr thrust_boost=0 > MotorTestSweep/$COUNTER.csv
            let COUNTER++
            ./build/linux/examples/AP_Motors_test s frame_class=$frame_class yaw_headroom=$headroom throttle_avg_max=$Thr thrust_boost=1 > MotorTestSweep/$COUNTER.csv
            let COUNTER++
        done
        echo
    done
done

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     # Script that automatically runs multipoint output comparison for all AP_Motors_Heli frames
# To prove equivalence when doing restructuring PR's
#
# Run from "ardupilot" directory
# Run the command below. The first argument is the number of commits to rewind the HEAD to get the "old"
# comparison point.  This should rewind back past all of the commits you have added
#
# If you just want to run a specific frame class, (e.g. dual heli = 11) then add the -f argument giving the
# frame class number (e.g. -f 11) to only run that frame class.  Default is to run all heli frame classes
#
# command to run:
# ---------------
# python3 libraries/AP_Motors/examples/AP_Motors_test/run_heli_comparison.py <INESRT No COMMITS TO REWIND>
#
# You may have to run "./waf distclean" if failing to build

import os
import subprocess
import csv
from matplotlib import pyplot as plt
from argparse import ArgumentParser


class DataPoints:

    # Instantiate the object and parse the data from the provided file
    # file: path to the csv file to be parsed
    def __init__(self, file):
        self.data = {}
        self.limit_case = []
        self.init_failed = False
        self.seen_header = False

        with open(file, 'r') as csvfile:
            # creating a csv reader object
            csvreader = csv.reader(csvfile)

            # extracting field names through first row
            for row in csvreader:

                if not self.seen_header:
                    # Warn the user if the an init failed message has been found in the file
                    if 'initialisation failed' in row[0]:
                        print('\n%s\n' % row[0])
                        self.init_failed = True
                        break

                    if (row[0] == 'Roll') and (row[1] == 'Pitch') and (row[2] == 'Yaw') and (row[3] == 'Thr'):
                        self.seen_header = True
                        for field in row:
                            self.data[field] = []

                else:
                    # stow all of the data
                    case_is_limited = False
                    for field, data in zip(self.data.keys(), row):
                        self.data[field].append(float(data))

                        # Keep track of all cases where a limit flag is set
                        if ('lim' in field.lower()) and (float(data) > 0.5):
                            case_is_limited = True
                    self.limit_case.append(case_is_limited)

            if not self.seen_header:
                self.init_failed = True

            # Make data immutable
            for field in self.data.keys():
                self.data[field] = tuple(self.data[field])

    # get the data from a given field
    # field: dict index, name of field data to be returned
    # lim_tf: limit bool, return limit cases or not
    def get_data(self, field, lim_tf):
        if field not in self.data.keys():
            raise Exception('%s is not a valid data field' % field)

        ret = []
        for data, flag in zip(self.data[field], self.limit_case):
            if (flag == lim_tf):
                ret.append(data)
        return ret

    def get_fields(self):
        return self.data.keys()


frame_class_lookup = {6: 'Single_Heli',
                      11: 'Dual_Heli',
                      13: 'Heli_Quad'}

swash_type_lookup = {0: 'H3',
                     1: 'H1',
                     2: 'H3_140',
                     3: 'H3_120',
                     4: 'H4_90',
                     5: 'H4_45'}

dual_mode_lookup = {0: 'Longitudinal',
                    1: 'Transverse',
                    2: 'Intermeshing_or_Coaxial'}

tail_type_lookup = {0: 'Servo_only',
                    1: 'Servo_with_ExtGyro',
                    2: 'DirectDrive_VarPitch',
                    3: 'DirectDrive_FixedPitch_CW',
                    4: 'DirectDrive_FixedPitch_CCW',
                    5: 'DDVP_with_external_governor'}

# Run sweep over range of types
def run_sweep(frame_class, swash_type, secondary_iter, secondary_lookup, secondary_name, dir_name):

    # configure and build the test
    os.system('./waf configure --board linux')
    os.system('./waf build --target examples/AP_Motors_test')

    # Run sweep
    for fc in frame_class:
        for swash in swash_type:
            for sec in secondary_iter:
                if swash is not None:
                    swash_cmd = 'swash=%d' % swash

                    if sec is not None:
                        name = 'frame class = %s (%i), swash = %s (%i), %s = %s (%i)' % (frame_class_lookup[fc], fc, swash_type_lookup[swash], swash, secondary_name.replace('_', ' '), secondary_lookup[sec], sec)
                        filename = '%s_%s_%s_motor_test.csv' % (frame_class_lookup[fc], swash_type_lookup[swash], secondary_lookup[sec])
                        sec_cmd = '%s=%d' % (secondary_name, sec)

                    else:
                        name = 'frame class = %s (%i), swash = %s (%i)' % (frame_class_lookup[fc], fc, swash_type_lookup[swash], swash)
                        filename = '%s_%s_motor_test.csv' % (frame_class_lookup[fc], swash_type_lookup[swash])
                        sec_cmd = ''

                else:
                    name = 'frame class = %s (%i)' % (frame_class_lookup[fc], fc)
                    filename = '%s_motor_test.csv' % (frame_class_lookup[fc])
                    swash_cmd = ''
                    sec_cmd = ''

                print('Running motors test for %s' % name)
                os.system('./build/linux/examples/AP_Motors_test s frame_class=%d %s %s > %s/%s' % (fc, swash_cmd, sec_cmd, dir_name, filename))
                print('%s complete\n' % name)


if __name__ == '__main__':

    BLUE =  [0, 0, 1]
    RED =   [1, 0, 0]
    BLACK = [0, 0, 0]

    # Build input parser
    parser = ArgumentParser(description='Find logs in which the input string is found in messages')
    parser.add_argument("-H", "--head", type=int, help='number of commits to roll back the head for comparing the work done')
    parser.add_argument("-f", "--frame-class", type=int, dest='frame_class', nargs="+", default=(6, 11), help="list of frame classes to run comparison on. Defaults to test single and dual helis.")
    parser.add_argument("-s", "--swash-type", type=int, dest='swash_type', nargs="+", help="list of swashplate types to run comparison on. Defaults to test all types. Invalid for heli quad")
    parser.add_argument("-c", "--compare", action='store_true', help='Compare only, do not re-run tests')
    parser.add_argument("-p", "--plot", action='store_true', help='Plot comparison results')
    parser.add_argument("-m", "--dual_mode", type=int, dest='dual_mode', help='Set DUAL_MODE, 0:Longitudinal, 1:Transverse, 2:Intermeshing/Coaxial, default:run all')
    parser.add_argument("-t", "--tail_type", type=int, dest='tail_type', help='Set TAIL_TYPE, 0:Servo Only, 1:Servo with ExtGyro, 2:DirectDrive VarPitch, 3:DirectDrive FixedPitch CW, 4:DirectDrive FixedPitch CCW, 5:DDVP with external governor, default:run all')
    args = parser.parse_args()

    if 13 in args.frame_class:
        if args.swash_type:
            print('Frame %s (%i) does not support swash' % (frame_class_lookup[13], 13))
            quit()
        args.swash_type = [None]

    else:
        if not args.swash_type:
            args.swash_type = (0, 1, 2, 3, 4, 5)

    if (args.frame_class != [11]) and (args.dual_mode is not None):
        print('Only Frame %s (%i) supports dual_mode' % (frame_class_lookup[11], 11))
        quit()

    if args.frame_class == [11]:
        if args.dual_mode is None:
            args.dual_mode = (0, 1, 2)
    else:
        args.dual_mode = [None]

    if (args.frame_class != [6]) and (args.tail_type is not None):
        print('Only Frame %s (%i) supports tail_type' % (frame_class_lookup[6], 6))
        quit()

    if args.frame_class == [6]:
        if args.tail_type is None:
            args.tail_type = (0, 1, 2, 3, 4, 5)
    else:
        args.tail_type = [None]

    # Secondary iterator, tail type for single heli and dual mode for dual heli
    secondary_iter = [None]
    secondary_lookup = None
    secondary_name = None
    if args.dual_mode != [None]:
        secondary_iter = args.dual_mode
        secondary_lookup = dual_mode_lookup
        secondary_name = 'dual_mode'

    elif args.tail_type != [None]:
        secondary_iter = args.tail_type
        secondary_lookup = tail_type_lookup
        secondary_name = 'tail_type'

    dir_name = 'motors_comparison'

    if not args.compare:
        # Create the new directory
        if dir_name not in os.listdir('./'):
            os.mkdir(dir_name)

        new_name = dir_name + "/new"
        if "new" not in os.listdir(dir_name):
            os.mkdir(new_name)

        print('\nRunning motor tests with current changes\n')

        # run the test
        run_sweep(args.frame_class, args.swash_type, secondary_iter, secondary_lookup, secondary_name, new_name)

        if args.head:
            # rewind head and repeat test
            if args.head <= 0:
                print('Number of commits to roll back HEAD must be a positive integer value')
                quit()

            # Warn the user that we are about to move things around with git.
            response = input("WARNING: this tool uses git to checkout older commits.  It is safest to do this in a separate test branch.\nDo you wish to continue y/n?:[n]")
            if response.lower() != 'y':
                quit()

            # Rewind the HEAD by the requested number of commits
            original_name = dir_name + "/original"
            if "original" not in os.listdir(dir_name):
                os.mkdir(original_name)

            cmd = 'git log -%d --format=format:"%%H"' % (args.head+1)
            result = subprocess.run([cmd], shell=True, capture_output=True, text=True)
            git_history = result.stdout.split('\n')
            latest_commit = git_history[0]
            base_commit = git_history[-1]

            print('Rewinding head by %d commits to: %s\n' % (args.head, base_commit))

            # Checkout to a detached head to test the old code before improvements
            cmd = 'git checkout %s' % base_commit
            result = subprocess.run([cmd], shell=True, capture_output=True, text=True)
            print('\n%s\n' % cmd)

            if result.returncode > 0:
                print('ERROR: Could not rewind HEAD.  Exited with error:\n%s\n%s' % (result.stdout, result.stderr))
                quit()

            # Rebuild
            os.system('./waf clean')

            run_sweep(args.frame_class, args.swash_type, original_name)

            # Move back to active branch
            print('Returning to original branch, commit = %s\n' % latest_commit)
            cmd = 'git switch -'
            result = subprocess.run([cmd], shell=True, capture_output=True, text=True)
            print('\n%s\n' % cmd)

            if result.returncode > 0:
                print('WARNING: Could not return head to branch with commit %s. \nError messages:\n%s\n%s' % (latest_commit, result.stdout, result.stderr))

    # Print comparison
    for fc in args.frame_class:
        for sw in args.swash_type:
            for sec in secondary_iter:
                frame = frame_class_lookup[fc]
                if sw is not None:
                    swash = swash_type_lookup[sw]
                    if sec is not None:
                        sec_str = secondary_lookup[sec]
                        name = frame + ' ' + swash + ' ' + sec_str
                        filename = '%s_%s_%s_motor_test.csv' % (frame, swash, sec_str)

                    else:
                        name = frame + ' ' + swash
                        filename = '%s_%s_motor_test.csv' % (frame, swash)

                else:
                    name = frame
                    filename = '%s_motor_test.csv' % (frame)

                print('%s:' % name)

                new_points = DataPoints(os.path.join(dir_name, 'new/%s' % filename))
                old_points = DataPoints(os.path.join(dir_name, 'original/%s' % filename))

                if new_points.init_failed:
                    print('\t failed!\n')

                print('\tInputs max change:')
                INPUTS = ['Roll', 'Pitch', 'Yaw', 'Thr']
                input_diff = {}
                for field in INPUTS:
                    input_diff[field] = [i-j for i, j in zip(old_points.data[field], new_points.data[field])]
                    print('\t\t%s: %f' % (field, max(map(abs, input_diff[field]))))

                # Find number of motors
                num_motors = 0
                while True:
                    num_motors += 1
                    if 'Mot%i' % (num_motors+1) not in new_points.get_fields():
                        break

                print('\tOutputs max change:')
                output_diff = {}
                for i in range(num_motors):
                    field = 'Mot%i' % (i+1)
                    output_diff[field] = [i-j for i, j in zip(old_points.data[field], new_points.data[field])]
                    print('\t\t%s: %f' % (field, max(map(abs, output_diff[field]))))

                print('\tLimits max change:')
                LIMITS = ['LimR', 'LimP', 'LimY', 'LimThD', 'LimThU']
                limit_diff = {}
                for field in LIMITS:
                    limit_diff[field] = [i-j for i, j in zip(old_points.data[field], new_points.data[field])]
                    print('\t\t%s: %f' % (field, max(map(abs, limit_diff[field]))))
                print('\n')

                if not args.plot:
                    continue

                # Plot comparison
                fig_size = (16, 8)
                fig, ax = plt.subplots(2, 2, figsize=fig_size)
                fig.suptitle('%s Input Diff' % name, fontsize=16)
                ax = ax.flatten()
                for i, field in enumerate(INPUTS):
                    ax[i].plot(input_diff[field], color=RED)
                    ax[i].set_xlabel('Test Number')
                    ax[i].set_ylabel('%s Old - New' % field)
                plt.tight_layout(rect=[0, 0.0, 1, 0.95])

                fig, ax = plt.subplots(2, num_motors, figsize=fig_size)
                fig.suptitle('%s Outputs' % name, fontsize=16)
                for i in range(num_motors):
                    field = 'Mot%i' % (i+1)
                    ax[0, i].plot(old_points.data[field], color=RED)
                    ax[0, i].plot(new_points.data[field], color=BLUE)
                    ax[0, i].set_ylabel(field)
                    ax[0, i].set_xlabel('Test No')
                    ax[1, i].plot(output_diff[field], color=BLACK)
                    ax[1, i].set_ylabel('Change in %s' % field)
                    ax[1, i].set_xlabel('Test No')
                plt.tight_layout(rect=[0, 0.0, 1, 0.95])

                fig, ax = plt.subplots(2, 5, figsize=fig_size)
                fig.suptitle(name + ' Limits', fontsize=16)
                for i, field in enumerate(LIMITS):
                    ax[0, i].plot(old_points.data[field], color=RED)
                    ax[0, i].plot(new_points.data[field], color=BLUE)
                    ax[0, i].set_ylabel(field)
                    ax[0, i].set_xlabel('Test No')
                    ax[1, i].plot(limit_diff[field], color=BLACK)
                    ax[1, i].set_ylabel('Change in %s' % field)
                    ax[1, i].set_xlabel('Test No')
                plt.tight_layout(rect=[0, 0.0, 1, 0.95])

if args.plot:
    plt.show()
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          #!/usr/bin/env python
# encoding: utf-8

def build(bld):
    bld.ap_example(
        use='ap',
    )
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           /*
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
#include <AP_HAL/AP_HAL.h>
#include <AP_Math/AP_Math.h>
#include <AP_Motors/AP_Motors.h>

/* run with:
    ./waf configure --board linux
    ./waf build --targets examples/expo_inverse_test
    ./build/linux/examples/expo_inverse_test
*/

void setup();
void loop();

const AP_HAL::HAL& hal = AP_HAL::get_HAL();

class AP_MotorsMulticopter_test : public AP_MotorsMulticopter {
public:

    AP_MotorsMulticopter_test(uint16_t speed_hz = AP_MOTORS_SPEED_DEFAULT) :
        AP_MotorsMulticopter(speed_hz)
    {
    };

    // have to have these functions as they are pure virtual
    void init(motor_frame_class frame_class, motor_frame_type frame_type) override {};
    void set_frame_class_and_type(motor_frame_class frame_class, motor_frame_type frame_type) override {};
    void _output_test_seq(uint8_t motor_seq, int16_t pwm) override {};
    const char* _get_frame_string() const override { return "TEST"; }
    void output_armed_stabilizing() override {};
    void output_to_motors() override {};

    // helper function to allow setting of expo
    void set_expo(float v) { thr_lin.curve_expo.set(v); }

};

AP_MotorsMulticopter_test motors;

/*
 *  rotation tests
 */
void setup(void)
{
    hal.console->begin(115200);
    hal.console->printf("\n\nMotors expo inverse test\n\n");

    const float expo_step = 0.01;
    const float throttle_step = 0.01;

    double max_diff = 0.0;
    float max_diff_throttle = 0;
    float max_diff_expo = 0;

    float expo = -1.0;
    motors.set_dt(1);
    while (expo < 1.0+expo_step*0.5) {
        hal.console->printf("expo: %0.4f\n",expo);
        motors.set_expo(expo);

        float throttle = 0.0;
        while (throttle < 1.0+throttle_step*0.5) {

            const float throttle_out = motors.thr_lin.actuator_to_thrust(motors.thr_lin.thrust_to_actuator(throttle));
            const double diff = fabsf(throttle_out - throttle);
            if (diff > max_diff) {
                max_diff_throttle = throttle;
                max_diff_expo = expo;
                max_diff = diff;
            }

            hal.console->printf("\tthrottle: %0.4f, error %0.8f\n", throttle, diff);

            throttle += throttle_step;
        }
        hal.console->printf("\n");
        expo += expo_step;
    }

    hal.console->printf("\nMotors expo inverse done, max error of %0.8f at expo %0.4f, throttle %0.4f\n\n", max_diff, max_diff_expo, max_diff_throttle);
}

void loop(void) {}

AP_HAL_MAIN();
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           #!/usr/bin/env python
# encoding: utf-8

def build(bld):
    bld.ap_example(
        use='ap',
    )
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           #include <AP_Common/AP_Common.h>
#include <AP_Param/AP_Param.h>
#include "AP_Mount.h"

#if HAL_MOUNT_ENABLED

#include "AP_Mount_Backend.h"
#include "AP_Mount_Servo.h"
#include "AP_Mount_SoloGimbal.h"
#include "AP_Mount_Alexmos.h"
#include "AP_Mount_SToRM32.h"
#include "AP_Mount_SToRM32_serial.h"
#include "AP_Mount_Gremsy.h"
#include "AP_Mount_Siyi.h"
#include "AP_Mount_Scripting.h"
#include "AP_Mount_Xacti.h"
#include "AP_Mount_Viewpro.h"
#include "AP_Mount_Topotek.h"
#include <stdio.h>
#include <AP_Math/location.h>
#include <SRV_Channel/SRV_Channel.h>
#include <AP_Logger/AP_Logger.h>

const AP_Param::GroupInfo AP_Mount::var_info[] = {

    // @Group: 1
    // @Path: AP_Mount_Params.cpp
    AP_SUBGROUPINFO(_params[0], "1", 43, AP_Mount, AP_Mount_Params),

#if AP_MOUNT_MAX_INSTANCES > 1
    // @Group: 2
    // @Path: AP_Mount_Params.cpp
    AP_SUBGROUPINFO(_params[1], "2", 44, AP_Mount, AP_Mount_Params),
#endif

    AP_GROUPEND
};

AP_Mount::AP_Mount()
{
    if (_singleton != nullptr) {
#if CONFIG_HAL_BOARD == HAL_BOARD_SITL
        AP_HAL::panic("Mount must be singleton");
#endif
        return;
    }
    _singleton = this;

    AP_Param::setup_object_defaults(this, var_info);
}

// init - detect and initialise all mounts
void AP_Mount::init()
{
    // check init has not been called before
    if (_num_instances != 0) {
        return;
    }

    // perform any required parameter conversion
    convert_params();

    // primary is reset to the first instantiated mount
    bool primary_set = false;

    // keep track of number of serial instances for initialisation
    uint8_t serial_instance = 0;

    // create each instance
    for (uint8_t instance=0; instance<AP_MOUNT_MAX_INSTANCES; instance++) {
        switch (get_mount_type(instance)) {
        case Type::None:
            break;
#if HAL_MOUNT_SERVO_ENABLED
        case Type::Servo:
            _backends[instance] = NEW_NOTHROW AP_Mount_Servo(*this, _params[instance], true, instance);
            _num_instances++;
            break;
#endif
#if HAL_SOLO_GIMBAL_ENABLED
        case Type::SoloGimbal:
            _backends[instance] = NEW_NOTHROW AP_Mount_SoloGimbal(*this, _params[instance], instance);
            _num_instances++;
            break;
#endif // HAL_SOLO_GIMBAL_ENABLED

#if HAL_MOUNT_ALEXMOS_ENABLED
        case Type::Alexmos:
            _backends[instance] = NEW_NOTHROW AP_Mount_Alexmos(*this, _params[instance], instance);
            _num_instances++;
            break;
#endif

#if HAL_MOUNT_STORM32MAVLINK_ENABLED
        // check for SToRM32 mounts using MAVLink protocol
        case Type::SToRM32:
            _backends[instance] = NEW_NOTHROW AP_Mount_SToRM32(*this, _params[instance], instance);
            _num_instances++;
            break;
#endif

#if HAL_MOUNT_STORM32SERIAL_ENABLED
        // check for SToRM32 mounts using serial protocol
        case Type::SToRM32_serial:
            _backends[instance] = NEW_NOTHROW AP_Mount_SToRM32_serial(*this, _params[instance], instance, serial_instance);
            _num_instances++;
            serial_instance++;
            break;
#endif

#if HAL_MOUNT_GREMSY_ENABLED
        // check for Gremsy mounts
        case Type::Gremsy:
            _backends[instance] = NEW_NOTHROW AP_Mount_Gremsy(*this, _params[instance], instance);
            _num_instances++;
            break;
#endif // HAL_MOUNT_GREMSY_ENABLED

#if HAL_MOUNT_SERVO_ENABLED
        // check for BrushlessPWM mounts (uses Servo backend)
        case Type::BrushlessPWM:
            _backends[instance] = NEW_NOTHROW AP_Mount_Servo(*this, _params[instance], false, instance);
            _num_instances++;
            break;
#endif

#if HAL_MOUNT_SIYI_ENABLED
        // check for Siyi gimbal
        case Type::Siyi:
            _backends[instance] = NEW_NOTHROW AP_Mount_Siyi(*this, _params[instance], instance, serial_instance);
            _num_instances++;
            serial_instance++;
            break;
#endif // HAL_MOUNT_SIYI_ENABLED

#if HAL_MOUNT_SCRIPTING_ENABLED
        // check for Scripting gimbal
        case Type::Scripting:
            _backends[instance] = NEW_NOTHROW AP_Mount_Scripting(*this, _params[instance], instance);
            _num_instances++;
            break;
#endif // HAL_MOUNT_SCRIPTING_ENABLED

#if HAL_MOUNT_XACTI_ENABLED
        // check for Xacti gimbal
        case Type::Xacti:
            _backends[instance] = NEW_NOTHROW AP_Mount_Xacti(*this, _params[instance], instance);
            _num_instances++;
            break;
#endif // HAL_MOUNT_XACTI_ENABLED

#if HAL_MOUNT_VIEWPRO_ENABLED
        // check for Xacti gimbal
        case Type::Viewpro:
            _backends[instance] = NEW_NOTHROW AP_Mount_Viewpro(*this, _params[instance], instance, serial_instance);
            _num_instances++;
            serial_instance++;
            break;
#endif // HAL_MOUNT_VIEWPRO_ENABLED

#if HAL_MOUNT_TOPOTEK_ENABLED
        // check for Topotek gimbal
        case Type::Topotek:
            _backends[instance] = NEW_NOTHROW AP_Mount_Topotek(*this, _params[instance], instance, serial_instance);
            _num_instances++;
            serial_instance++;
            break;
#endif // HAL_MOUNT_TOPOTEK_ENABLED
        }

        // init new instance
        if (_backends[instance] != nullptr) {
            if (!primary_set) {
                _primary = instance;
                primary_set = true;
            }
        }
    }

    // init each instance, do it after all instances were created, so that they all know things
    for (uint8_t instance=0; instance<AP_MOUNT_MAX_INSTANCES; instance++) {
        if (_backends[instance] != nullptr) {
            _backends[instance]->init();
            set_mode_to_default(instance);
        }
    }

    (void)serial_instance;
}

// update - give mount opportunity to update servos.  should be called at 10hz or higher
void AP_Mount::update()
{
    // update each instance
    for (uint8_t instance=0; instance<AP_MOUNT_MAX_INSTANCES; instance++) {
        if (_backends[instance] != nullptr) {
            _backends[instance]->update();
        }
    }
}

// used for gimbals that need to read INS data at full rate
void AP_Mount::update_fast()
{
    // update each instance
    for (uint8_t instance=0; instance<AP_MOUNT_MAX_INSTANCES; instance++) {
        if (_backends[instance] != nullptr) {
            _backends[instance]->update_fast();
        }
    }
}

// get_mount_type - returns the type of mount
AP_Mount::Type AP_Mount::get_mount_type(uint8_t instance) const
{
    if (instance >= AP_MOUNT_MAX_INSTANCES) {
        return Type::None;
    }

    return (Type)_params[instance].type.get();
}

// has_pan_control - returns true if the mount has yaw control (required for copters)
bool AP_Mount::has_pan_control(uint8_t instance) const
{
    const auto *backend = get_instance(instance);
    if (backend == nullptr) {
        return false;
    }

    // ask backend if it support pan
    return backend->has_pan_control();
}

// get_mode - returns current mode of mount (i.e. Retracted, Neutral, RC_Targeting, GPS Point)
MAV_MOUNT_MODE AP_Mount::get_mode(uint8_t instance) const
{
    const auto *backend = get_instance(instance);
    if (backend == nullptr) {
        return MAV_MOUNT_MODE_RETRACT;
    }

    // ask backend its mode
    return backend->get_mode();
}

// set_mode_to_default - restores the mode to it's default mode held in the MNTx__DEFLT_MODE parameter
//      this operation requires 60us on a Pixhawk/PX4
void AP_Mount::set_mode_to_default(uint8_t instance)
{
    auto *backend = get_instance(instance);
    if (backend == nullptr) {
        return;
    }
    backend->set_mode((enum MAV_MOUNT_MODE)_params[instance].default_mode.get());
}

// set_mode - sets mount's mode
void AP_Mount::set_mode(uint8_t instance, enum MAV_MOUNT_MODE mode)
{
    auto *backend = get_instance(instance);
    if (backend == nullptr) {
        return;
    }

    // call backend's set_mode
    backend->set_mode(mode);
}

// set yaw_lock used in RC_TARGETING mode.  If true, the gimbal's yaw target is maintained in earth-frame meaning it will lock onto an earth-frame heading (e.g. North)
// If false (aka "follow") the gimbal's yaw is maintained in body-frame meaning it will rotate with the vehicle
void AP_Mount::set_yaw_lock(uint8_t instance, bool yaw_lock)
{
    auto *backend = get_instance(instance);
    if (backend == nullptr) {
        return;
    }

    // call backend's set_yaw_lock
    backend->set_yaw_lock(yaw_lock);
}

// set angle target in degrees
// roll and pitch are in earth-frame
// yaw_is_earth_frame (aka yaw_lock) should be true if yaw angle is earth-frame, false if body-frame
void AP_Mount::set_angle_target(uint8_t instance, float roll_deg, float pitch_deg, float yaw_deg, bool yaw_is_earth_frame)
{
    auto *backend = get_instance(instance);
    if (backend == nullptr) {
        return;
    }

    // send command to backend
    backend->set_angle_target(roll_deg, pitch_deg, yaw_deg, yaw_is_earth_frame);
}

// sets rate target in deg/s
// yaw_lock should be true if the yaw rate is earth-frame, false if body-frame (e.g. rotates with body of vehicle)
void AP_Mount::set_rate_target(uint8_t instance, float roll_degs, float pitch_degs, float yaw_degs, bool yaw_lock)
{
    auto *backend = get_instance(instance);
    if (backend == nullptr) {
        return;
    }

    // send command to backend
    backend->set_rate_target(roll_degs, pitch_degs, yaw_degs, yaw_lock);
}

MAV_RESULT AP_Mount::handle_command_do_mount_configure(const mavlink_command_int_t &packet)
{
    auto *backend = get_primary();
    if (backend == nullptr) {
        return MAV_RESULT_FAILED;
    }

    backend->set_mode((MAV_MOUNT_MODE)packet.param1);

    return MAV_RESULT_ACCEPTED;
}


MAV_RESULT AP_Mount::handle_command_do_mount_control(const mavlink_command_int_t &packet)
{
    auto *backend = get_primary();
    if (backend == nullptr) {
        return MAV_RESULT_FAILED;
    }

    return backend->handle_command_do_mount_control(packet);
}

MAV_RESULT AP_Mount::handle_command_do_gimbal_manager_pitchyaw(const mavlink_command_int_t &packet)
{
    AP_Mount_Backend *backend;

    // check gimbal device id.  0 is primary, 1 is 1st gimbal, 2 is
    // 2nd gimbal, etc
    const uint8_t instance = packet.z;
    if (instance == 0) {
        backend = get_primary();
    } else {
        backend = get_instance(instance - 1);
    }

    if (backend == nullptr) {
        return MAV_RESULT_FAILED;
    }

    // check flags for change to RETRACT
    const uint32_t flags = packet.x;
    if ((flags & GIMBAL_MANAGER_FLAGS_RETRACT) > 0) {
        backend->set_mode(MAV_MOUNT_MODE_RETRACT);
        return MAV_RESULT_ACCEPTED;
    }
    // check flags for change to NEUTRAL
    if ((flags & GIMBAL_MANAGER_FLAGS_NEUTRAL) > 0) {
        backend->set_mode(MAV_MOUNT_MODE_NEUTRAL);
        return MAV_RESULT_ACCEPTED;
    }

    // param1 : pitch_angle (in degrees)
    // param2 : yaw angle (in degrees)
    const float pitch_angle_deg = packet.param1;
    const float yaw_angle_deg = packet.param2;
    if (!isnan(pitch_angle_deg) && !isnan(yaw_angle_deg)) {
        backend->set_angle_target(0, pitch_angle_deg, yaw_angle_deg, flags & GIMBAL_MANAGER_FLAGS_YAW_LOCK);
        return MAV_RESULT_ACCEPTED;
    }

    // param3 : pitch_rate (in deg/s)
    // param4 : yaw rate (in deg/s)
    const float pitch_rate_degs = packet.param3;
    const float yaw_rate_degs = packet.param4;
    if (!isnan(pitch_rate_degs) && !isnan(yaw_rate_degs)) {
        backend->set_rate_target(0, pitch_rate_degs, yaw_rate_degs, flags & GIMBAL_MANAGER_FLAGS_YAW_LOCK);
        return MAV_RESULT_ACCEPTED;
    }

    // if neither angles nor rates were provided set the RC_TARGETING yaw lock state
    if (isnan(pitch_angle_deg) && isnan(yaw_angle_deg) && isnan(pitch_rate_degs) && isnan(yaw_rate_degs)) {
        backend->set_yaw_lock(flags & GIMBAL_MANAGER_FLAGS_YAW_LOCK);
        return MAV_RESULT_ACCEPTED;
    }

    return MAV_RESULT_FAILED;
}

// handle mav_cmd_do_gimbal_manager_configure for deconflicting different mavlink message senders
MAV_RESULT AP_Mount::handle_command_do_gimbal_manager_configure(const mavlink_command_int_t &packet, const mavlink_message_t &msg)
{
    AP_Mount_Backend *backend;

    // check gimbal device id.  0 is primary, 1 is 1st gimbal, 2 is 2nd gimbal, etc
    const uint8_t instance = packet.z;
    if (instance == 0) {
        backend = get_primary();
    } else {
        backend = get_instance(instance - 1);
    }

    if (backend == nullptr) {
        return MAV_RESULT_FAILED;
    }

    return backend->handle_command_do_gimbal_manager_configure(packet, msg);
}

void AP_Mount::handle_gimbal_manager_set_attitude(const mavlink_message_t &msg) {
    mavlink_gimbal_manager_set_attitude_t packet;
    mavlink_msg_gimbal_manager_set_attitude_decode(&msg,&packet);

    AP_Mount_Backend *backend;

    // check gimbal device id.  0 is primary, 1 is 1st gimbal, 2 is
    // 2nd gimbal, etc
    const uint8_t instance = packet.gimbal_device_id;
    if (instance == 0) {
        backend = get_primary();
    } else {
        backend = get_instance(instance - 1);
    }

    if (backend == nullptr) {
        return;
    }

    // check flags for change to RETRACT
    const uint32_t flags = packet.flags;
    if ((flags & GIMBAL_MANAGER_FLAGS_RETRACT) > 0) {
        backend->set_mode(MAV_MOUNT_MODE_RETRACT);
        return;
    }

    // check flags for change to NEUTRAL
    if ((flags & GIMBAL_MANAGER_FLAGS_NEUTRAL) > 0) {
        backend->set_mode(MAV_MOUNT_MODE_NEUTRAL);
        return;
    }

    const Quaternion att_quat{packet.q};
    const Vector3f att_rate_degs {
        packet.angular_velocity_x,
        packet.angular_velocity_y,
        packet.angular_velocity_y
    };

    // ensure that we are only demanded to a specific attitude or to
    // achieve a specific rate.  Do not allow both to be specified at
    // the same time:
    if (!att_quat.is_nan() && !att_rate_degs.is_nan()) {
        return;
    }

    if (!att_quat.is_nan()) {
        // convert quaternion to euler angles
        Vector3f attitude;
        att_quat.to_euler(attitude);  // attitude is in radians here
        attitude *= RAD_TO_DEG;  // convert to degrees

        backend->set_angle_target(attitude.x, attitude.y, attitude.z, flags & GIMBAL_MANAGER_FLAGS_YAW_LOCK);
        return;
    }

    {
        const float roll_rate_degs = degrees(packet.angular_velocity_x);
        const float pitch_rate_degs = degrees(packet.angular_velocity_y);
        const float yaw_rate_degs = degrees(packet.angular_velocity_z);
        backend->set_rate_target(roll_rate_degs, pitch_rate_degs, yaw_rate_degs, flags & GIMBAL_MANAGER_FLAGS_YAW_LOCK);
        return;
    }
}

void AP_Mount::handle_gimbal_manager_set_pitchyaw(const mavlink_message_t &msg)
{
    mavlink_gimbal_manager_set_pitchyaw_t packet;
    mavlink_msg_gimbal_manager_set_pitchyaw_decode(&msg,&packet);

    AP_Mount_Backend *backend;

    // check gimbal device id.  0 is primary, 1 is 1st gimbal, 2 is
    // 2nd gimbal, etc
    const uint8_t instance = packet.gimbal_device_id;
    if (instance == 0) {
        backend = get_primary();
    } else {
        backend = get_instance(instance - 1);
    }

    if (backend == nullptr) {
        return;
    }

    // check flags for change to RETRACT
    uint32_t flags = (uint32_t)packet.flags;
    if ((flags & GIMBAL_MANAGER_FLAGS_RETRACT) > 0) {
        backend->set_mode(MAV_MOUNT_MODE_RETRACT);
        return;
    }
    // check flags for change to NEUTRAL
    if ((flags & GIMBAL_MANAGER_FLAGS_NEUTRAL) > 0) {
        backend->set_mode(MAV_MOUNT_MODE_NEUTRAL);
        return;
    }

    // Do not allow both angle and rate to be specified at the same time
    if (!isnan(packet.pitch) && !isnan(packet.yaw) && !isnan(packet.pitch_rate) && !isnan(packet.yaw_rate)) {
        return;
    }

    // pitch and yaw from packet are in radians
    if (!isnan(packet.pitch) && !isnan(packet.yaw)) {
        const float pitch_angle_deg = degrees(packet.pitch);
        const float yaw_angle_deg = degrees(packet.yaw);
        backend->set_angle_target(0, pitch_angle_deg, yaw_angle_deg, flags & GIMBAL_MANAGER_FLAGS_YAW_LOCK);
        return;
    }

    // pitch_rate and yaw_rate from packet are in rad/s
    if (!isnan(packet.pitch_rate) && !isnan(packet.yaw_rate)) {
        const float pitch_rate_degs = degrees(packet.pitch_rate);
        const float yaw_rate_degs = degrees(packet.yaw_rate);
        backend->set_rate_target(0, pitch_rate_degs, yaw_rate_degs, flags & GIMBAL_MANAGER_FLAGS_YAW_LOCK);
        return;
    }

    // if neither angles nor rates were provided set the RC_TARGETING yaw lock state
    if (isnan(packet.pitch) && isnan(packet.yaw) && isnan(packet.pitch_rate) && isnan(packet.yaw_rate)) {
        backend->set_yaw_lock(flags & GIMBAL_MANAGER_FLAGS_YAW_LOCK);
        return;
    }
}

MAV_RESULT AP_Mount::handle_command_do_set_roi_sysid(const mavlink_command_int_t &packet)
{
    set_target_sysid((uint8_t)packet.param1);
    return MAV_RESULT_ACCEPTED;
}

MAV_RESULT AP_Mount::handle_command(const mavlink_command_int_t &packet, const mavlink_message_t &msg)
{
    switch (packet.command) {
    case MAV_CMD_DO_MOUNT_CONFIGURE:
        return handle_command_do_mount_configure(packet);
    case MAV_CMD_DO_MOUNT_CONTROL:
        return handle_command_do_mount_control(packet);
    case MAV_CMD_DO_GIMBAL_MANAGER_PITCHYAW:
        return handle_command_do_gimbal_manager_pitchyaw(packet);
    case MAV_CMD_DO_GIMBAL_MANAGER_CONFIGURE:
        return handle_command_do_gimbal_manager_configure(packet, msg);
    case MAV_CMD_DO_SET_ROI_SYSID:
        return handle_command_do_set_roi_sysid(packet);
    default:
        return MAV_RESULT_UNSUPPORTED;
    }
}

/// Change the configuration of the mount
void AP_Mount::handle_global_position_int(const mavlink_message_t &msg)
{
    mavlink_global_position_int_t packet;
    mavlink_msg_global_position_int_decode(&msg, &packet);

    if (!check_latlng(packet.lat, packet.lon)) {
        return;
    }

    for (uint8_t instance=0; instance<AP_MOUNT_MAX_INSTANCES; instance++) {
        if (_backends[instance] != nullptr) {
            _backends[instance]->handle_global_position_int(msg.sysid, packet);
        }
    }
}

#if AP_MAVLINK_MSG_MOUNT_CONFIGURE_ENABLED
/// Change the configuration of the mount
void AP_Mount::handle_mount_configure(const mavlink_message_t &msg)
{
    auto *backend = get_primary();
    if (backend == nullptr) {
        return;
    }

    mavlink_mount_configure_t packet;
    mavlink_msg_mount_configure_decode(&msg, &packet);

    // send message to backend
    backend->handle_mount_configure(packet);
}
#endif

#if AP_MAVLINK_MSG_MOUNT_CONTROL_ENABLED
/// Control the mount (depends on the previously set mount configuration)
void AP_Mount::handle_mount_control(const mavlink_message_t &msg)
{
    auto *backend = get_primary();
    if (backend == nullptr) {
        return;
    }

    mavlink_mount_control_t packet;
    mavlink_msg_mount_control_decode(&msg, &packet);

    // send message to backend
    backend->handle_mount_control(packet);
}
#endif

#if HAL_GCS_ENABLED
// send a GIMBAL_DEVICE_ATTITUDE_STATUS message to GCS
void AP_Mount::send_gimbal_device_attitude_status(mavlink_channel_t chan)
{
    // call send_gimbal_device_attitude_status for each instance
    for (uint8_t instance=0; instance<AP_MOUNT_MAX_INSTANCES; instance++) {
        if (_backends[instance] != nullptr) {
            _backends[instance]->send_gimbal_device_attitude_status(chan);
        }
    }
}

// send a GIMBAL_MANAGER_INFORMATION message to GCS
void AP_Mount::send_gimbal_manager_information(mavlink_channel_t chan)
{
    // call send_gimbal_device_attitude_status for each instance
    for (uint8_t instance=0; instance<AP_MOUNT_MAX_INSTANCES; instance++) {
        if (_backends[instance] != nullptr) {
            _backends[instance]->send_gimbal_manager_information(chan);
        }
    }
}

// send a GIMBAL_MANAGER_STATUS message to GCS
void AP_Mount::send_gimbal_manager_status(mavlink_channel_t chan)
{
    // call send_gimbal_device_attitude_status for each instance
    for (uint8_t instance=0; instance<AP_MOUNT_MAX_INSTANCES; instance++) {
        if (_backends[instance] != nullptr) {
            _backends[instance]->send_gimbal_manager_status(chan);
        }
    }
}
#endif  // HAL_GCS_ENABLED

#if AP_MOUNT_POI_TO_LATLONALT_ENABLED
// get poi information.  Returns true on success and fills in gimbal attitude, location and poi location
bool AP_Mount::get_poi(uint8_t instance, Quaternion &quat, Location &loc, Location &poi_loc) const
{
    auto *backend = get_instance(instance);
    if (backend == nullptr) {
        return false;
    }
    return backend->get_poi(instance, quat, loc, poi_loc);
}
#endif

// get mount's current attitude in euler angles in degrees.  yaw angle is in body-frame
// returns true on success
bool AP_Mount::get_attitude_euler(uint8_t instance, float& roll_deg, float& pitch_deg, float& yaw_bf_deg)
{
    auto *backend = get_instance(instance);
    if (backend == nullptr) {
        return false;
    }

    // re-use get_attitude_quaternion and convert to Euler angles
    Quaternion att_quat;
    if (!backend->get_attitude_quaternion(att_quat)) {
        return false;
    }

    float roll_rad, pitch_rad, yaw_rad;
    att_quat.to_euler(roll_rad, pitch_rad, yaw_rad);
    roll_deg = degrees(roll_rad);
    pitch_deg = degrees(pitch_rad);
    yaw_bf_deg = degrees(yaw_rad);
    return true;
}

// run pre-arm check.  returns false on failure and fills in failure_msg
// any failure_msg returned will not include a prefix
bool AP_Mount::pre_arm_checks(char *failure_msg, uint8_t failure_msg_len)
{
    // check type parameters
    for (uint8_t i=0; i<AP_MOUNT_MAX_INSTANCES; i++) {
        if ((get_mount_type(i) != Type::None) && (_backends[i] == nullptr)) {
            strncpy(failure_msg, "check TYPE", failure_msg_len);
            return false;
        }
    }

    // return true if no mount configured
    if (_num_instances == 0) {
        return true;
    }

    // check healthy
    for (uint8_t i=0; i<AP_MOUNT_MAX_INSTANCES; i++) {
        if ((_backends[i] != nullptr) && !_backends[i]->healthy()) {
            strncpy(failure_msg, "not healthy", failure_msg_len);
            return false;
        }
    }

    return true;
}

// get target rate in deg/sec. returns true on success
bool AP_Mount::get_rate_target(uint8_t instance, float& roll_degs, float& pitch_degs, float& yaw_degs, bool& yaw_is_earth_frame)
{
    auto *backend = get_instance(instance);
    if (backend == nullptr) {
        return false;
    }
    return backend->get_rate_target(roll_degs, pitch_degs, yaw_degs, yaw_is_earth_frame);
}

// get target angle in deg. returns true on success
bool AP_Mount::get_angle_target(uint8_t instance, float& roll_deg, float& pitch_deg, float& yaw_deg, bool& yaw_is_earth_frame)
{
    auto *backend = get_instance(instance);
    if (backend == nullptr) {
        return false;
    }
    return backend->get_angle_target(roll_deg, pitch_deg, yaw_deg, yaw_is_earth_frame);
}

// accessors for scripting backends and logging
bool AP_Mount::get_location_target(uint8_t instance, Location& target_loc)
{
    auto *backend = get_instance(instance);
    if (backend == nullptr) {
        return false;
    }
    return backend->get_location_target(target_loc);
}

void AP_Mount::set_attitude_euler(uint8_t instance, float roll_deg, float pitch_deg, float yaw_bf_deg)
{
    auto *backend = get_instance(instance);
    if (backend == nullptr) {
        return;
    }
    backend->set_attitude_euler(roll_deg, pitch_deg, yaw_bf_deg);
}

#if HAL_LOGGING_ENABLED
// write mount log packet for all backends
void AP_Mount::write_log()
{
    // each instance writes log
    for (uint8_t instance=0; instance<AP_MOUNT_MAX_INSTANCES; instance++) {
        if (_backends[instance] != nullptr) {
            _backends[instance]->write_log(0);
        }
    }
}

void AP_Mount::write_log(uint8_t instance, uint64_t timestamp_us)
{
    auto *backend = get_instance(instance);
    if (backend == nullptr) {
        return;
    }
    backend->write_log(timestamp_us);
}
#endif

// point at system ID sysid
void AP_Mount::set_target_sysid(uint8_t instance, uint8_t sysid)
{
    auto *backend = get_instance(instance);
    if (backend == nullptr) {
        return;
    }
    // call instance's set_roi_cmd
    backend->set_target_sysid(sysid);
}

// set_roi_target - sets target location that mount should attempt to point towards
void AP_Mount::set_roi_target(uint8_t instance, const Location &target_loc)
{
    auto *backend = get_instance(instance);
    if (backend == nullptr) {
        return;
    }
    backend->set_roi_target(target_loc);
}

// clear_roi_target - clears target location that mount should attempt to point towards
void AP_Mount::clear_roi_target(uint8_t instance)
{
    auto *backend = get_instance(instance);
    if (backend == nullptr) {
        return;
    }
    backend->clear_roi_target();
}

//
// camera controls for gimbals that include a camera
//

// take a picture.  returns true on success
bool AP_Mount::take_picture(uint8_t instance)
{
    auto *backend = get_instance(instance);
    if (backend == nullptr) {
        return false;
    }
    return backend->take_picture();
}

// start or stop video recording.  returns true on success
// set start_recording = true to start record, false to stop recording
bool AP_Mount::record_video(uint8_t instance, bool start_recording)
{
    auto *backend = get_instance(instance);
    if (backend == nullptr) {
        return false;
    }
    return backend->record_video(start_recording);
}

// set zoom specified as a rate or percentage
bool AP_Mount::set_zoom(uint8_t instance, ZoomType zoom_type, float zoom_value)
{
    auto *backend = get_instance(instance);
    if (backend == nullptr) {
        return false;
    }
    return backend->set_zoom(zoom_type, zoom_value);
}

// set focus specified as rate, percentage or auto
// focus in = -1, focus hold = 0, focus out = 1
SetFocusResult AP_Mount::set_focus(uint8_t instance, FocusType focus_type, float focus_value)
{
    auto *backend = get_instance(instance);
    if (backend == nullptr) {
        return SetFocusResult::FAILED;
    }
    return backend->set_focus(focus_type, focus_value);
}

// set tracking to none, point or rectangle (see TrackingType enum)
// if POINT only p1 is used, if RECTANGLE then p1 is top-left, p2 is bottom-right
// p1,p2 are in range 0 to 1.  0 is left or top, 1 is right or bottom
bool AP_Mount::set_tracking(uint8_t instance, TrackingType tracking_type, const Vector2f& p1, const Vector2f& p2)
{
    auto *backend = get_instance(instance);
    if (backend == nullptr) {
        return false;
    }
    return backend->set_tracking(tracking_type, p1, p2);
}

// set camera lens as a value from 0 to 5
bool AP_Mount::set_lens(uint8_t instance, uint8_t lens)
{
    auto *backend = get_instance(instance);
    if (backend == nullptr) {
        return false;
    }
    return backend->set_lens(lens);
}

#if HAL_MOUNT_SET_CAMERA_SOURCE_ENABLED
// set_camera_source is functionally the same as set_lens except primary and secondary lenses are specified by type
// primary and secondary sources use the AP_Camera::CameraSource enum cast to uint8_t
bool AP_Mount::set_camera_source(uint8_t instance, uint8_t primary_source, uint8_t secondary_source)
{
    auto *backend = get_instance(instance);
    if (backend == nullptr) {
        return false;
    }
    return backend->set_camera_source(primary_source, secondary_source);
}
#endif

// send camera information message to GCS
void AP_Mount::send_camera_information(uint8_t instance, mavlink_channel_t chan) const
{
    auto *backend = get_instance(instance);
    if (backend == nullptr) {
        return;
    }
    backend->send_camera_information(chan);
}

// send camera settings message to GCS
void AP_Mount::send_camera_settings(uint8_t instance, mavlink_channel_t chan) const
{
    auto *backend = get_instance(instance);
    if (backend == nullptr) {
        return;
    }
    backend->send_camera_settings(chan);
}

// send camera capture status message to GCS
void AP_Mount::send_camera_capture_status(uint8_t instance, mavlink_channel_t chan) const
{
    auto *backend = get_instance(instance);
    if (backend == nullptr) {
        return;
    }
    backend->send_camera_capture_status(chan);
}

// get rangefinder distance.  Returns true on success
bool AP_Mount::get_rangefinder_distance(uint8_t instance, float& distance_m) const
{
    auto *backend = get_instance(instance);
    if (backend == nullptr) {
        return false;
    }
    return backend->get_rangefinder_distance(distance_m);
}

// enable/disable rangefinder.  Returns true on success
bool AP_Mount::set_rangefinder_enable(uint8_t instance, bool enable)
{
    auto *backend = get_instance(instance);
    if (backend == nullptr) {
        return false;
    }
    return backend->set_rangefinder_enable(enable);
}

AP_Mount_Backend *AP_Mount::get_primary() const
{
    return get_instance(_primary);
}

AP_Mount_Backend *AP_Mount::get_instance(uint8_t instance) const
{
    if (instance >= ARRAY_SIZE(_backends)) {
        return nullptr;
    }
    return _backends[instance];
}

// pass a GIMBAL_REPORT message to the backend
void AP_Mount::handle_gimbal_report(mavlink_channel_t chan, const mavlink_message_t &msg)
{
    for (uint8_t instance=0; instance<AP_MOUNT_MAX_INSTANCES; instance++) {
        if (_backends[instance] != nullptr) {
            _backends[instance]->handle_gimbal_report(chan, msg);
        }
    }
}

void AP_Mount::handle_message(mavlink_channel_t chan, const mavlink_message_t &msg)
{
    switch (msg.msgid) {
    case MAVLINK_MSG_ID_GIMBAL_REPORT:
        handle_gimbal_report(chan, msg);
        break;
#if AP_MAVLINK_MSG_MOUNT_CONFIGURE_ENABLED
    case MAVLINK_MSG_ID_MOUNT_CONFIGURE:
        handle_mount_configure(msg);
        break;
#endif
#if AP_MAVLINK_MSG_MOUNT_CONTROL_ENABLED
    case MAVLINK_MSG_ID_MOUNT_CONTROL:
        handle_mount_control(msg);
        break;
#endif
    case MAVLINK_MSG_ID_GLOBAL_POSITION_INT:
        handle_global_position_int(msg);
        break;
    case MAVLINK_MSG_ID_GIMBAL_MANAGER_SET_ATTITUDE:
        handle_gimbal_manager_set_attitude(msg);
        break;
    case MAVLINK_MSG_ID_GIMBAL_MANAGER_SET_PITCHYAW:
        handle_gimbal_manager_set_pitchyaw(msg);
        break;
    case MAVLINK_MSG_ID_GIMBAL_DEVICE_INFORMATION:
        handle_gimbal_device_information(msg);
        break;
    case MAVLINK_MSG_ID_GIMBAL_DEVICE_ATTITUDE_STATUS:
        handle_gimbal_device_attitude_status(msg);
        break;
    default:
#if CONFIG_HAL_BOARD == HAL_BOARD_SITL
        AP_HAL::panic("Unhandled mount case");
#endif
        break;
    }
}

// handle PARAM_VALUE
void AP_Mount::handle_param_value(const mavlink_message_t &msg)
{
    for (uint8_t instance=0; instance<AP_MOUNT_MAX_INSTANCES; instance++) {
        if (_backends[instance] != nullptr) {
            _backends[instance]->handle_param_value(msg);
        }
    }
}


// handle GIMBAL_DEVICE_INFORMATION message
void AP_Mount::handle_gimbal_device_information(const mavlink_message_t &msg)
{
    for (uint8_t instance=0; instance<AP_MOUNT_MAX_INSTANCES; instance++) {
        if (_backends[instance] != nullptr) {
            _backends[instance]->handle_gimbal_device_information(msg);
        }
    }
}

// handle GIMBAL_DEVICE_ATTITUDE_STATUS message
void AP_Mount::handle_gimbal_device_attitude_status(const mavlink_message_t &msg)
{
    for (uint8_t instance=0; instance<AP_MOUNT_MAX_INSTANCES; instance++) {
        if (_backends[instance] != nullptr) {
            _backends[instance]->handle_gimbal_device_attitude_status(msg);
        }
    }
}

// perform any required parameter conversion
void AP_Mount::convert_params()
{
    // exit immediately if MNT1_TYPE has already been configured
    if (_params[0].type.configured()) {
        return;
    }

    // below conversions added Sep 2022 ahead of 4.3 release

    // convert MNT_TYPE to MNT1_TYPE
    int8_t mnt_type = 0;
    IGNORE_RETURN(AP_Param::get_param_by_index(this, 19, AP_PARAM_INT8, &mnt_type));
    if (mnt_type == 0) {
        // if the mount was not previously set, no need to perform the upgrade logic
        return;
    } else if (mnt_type > 0) {
        int8_t stab_roll = 0;
        int8_t stab_pitch = 0;
        IGNORE_RETURN(AP_Param::get_param_by_index(this, 4, AP_PARAM_INT8, &stab_roll));
        IGNORE_RETURN(AP_Param::get_param_by_index(this, 5, AP_PARAM_INT8, &stab_pitch));
        if (mnt_type == 1 && stab_roll == 0 && stab_pitch == 0)  {
            // Servo type without stabilization is changed to BrushlessPWM
            // conversion is still done even if HAL_MOUNT_SERVO_ENABLED is false
            mnt_type = 7;  // (int8_t)Type::BrushlessPWM;
        }
        // if the mount was previously set, then we need to save the upgraded mount type
        _params[0].type.set_and_save(mnt_type);
    }

    // convert MNT_JSTICK_SPD to MNT1_RC_RATE
    int8_t jstick_spd = 0;
    if (AP_Param::get_param_by_index(this, 16, AP_PARAM_INT8, &jstick_spd) && (jstick_spd > 0)) {
        _params[0].rc_rate_max.set_and_save(jstick_spd * 0.3);
    }

    // find Mount's top level key
    uint16_t k_param_mount_key;
    if (!AP_Param::find_top_level_key_by_pointer(this, k_param_mount_key)) {
        return;
    }

    // table of mount parameters to be converted without scaling
    static const AP_Param::ConversionInfo mnt_param_conversion_info[] {
        { k_param_mount_key, 0, AP_PARAM_INT8, "MNT1_DEFLT_MODE" },
        { k_param_mount_key, 1, AP_PARAM_VECTOR3F, "MNT1_RETRACT" },
        { k_param_mount_key, 2, AP_PARAM_VECTOR3F, "MNT1_NEUTRAL" },
        { k_param_mount_key, 17, AP_PARAM_FLOAT, "MNT1_LEAD_RLL" },
        { k_param_mount_key, 18, AP_PARAM_FLOAT, "MNT1_LEAD_PTCH" },
    };
    uint8_t table_size = ARRAY_SIZE(mnt_param_conversion_info);
    for (uint8_t i=0; i<table_size; i++) {
        AP_Param::convert_old_parameter(&mnt_param_conversion_info[i], 1.0f);
    }

    // mount parameters conversion from centi-degrees to degrees
    static const AP_Param::ConversionInfo mnt_param_deg_conversion_info[] {
        { k_param_mount_key, 8, AP_PARAM_INT16, "MNT1_ROLL_MIN" },
        { k_param_mount_key, 9, AP_PARAM_INT16, "MNT1_ROLL_MAX" },
        { k_param_mount_key, 11, AP_PARAM_INT16, "MNT1_PITCH_MIN" },
        { k_param_mount_key, 12, AP_PARAM_INT16, "MNT1_PITCH_MAX" },
        { k_param_mount_key, 14, AP_PARAM_INT16, "MNT1_YAW_MIN" },
        { k_param_mount_key, 15, AP_PARAM_INT16, "MNT1_YAW_MAX" },
    };
    table_size = ARRAY_SIZE(mnt_param_deg_conversion_info);
    for (uint8_t i=0; i<table_size; i++) {
        AP_Param::convert_old_parameter(&mnt_param_deg_conversion_info[i], 0.01f);
    }

    // struct and array holding mapping between old param table index and new RCx_OPTION value
    struct MountRCConversionTable {
        uint8_t old_rcin_idx;
        uint16_t new_rc_option;
    };
    const struct MountRCConversionTable mnt_rc_conversion_table[] = {
        {7, 212},   // MTN_RC_IN_ROLL to RCx_OPTION = 212 (MOUNT1_ROLL)
        {10, 213},  // MTN_RC_IN_TILT to RCx_OPTION = 213 (MOUNT1_PITCH)
        {13, 214},  // MTN_RC_IN_PAN to RCx_OPTION = 214 (MOUNT1_YAW)
    };
    for (uint8_t i = 0; i < ARRAY_SIZE(mnt_rc_conversion_table); i++) {
        int8_t mnt_rcin = 0;
        if (AP_Param::get_param_by_index(this, mnt_rc_conversion_table[i].old_rcin_idx, AP_PARAM_INT8, &mnt_rcin) && (mnt_rcin > 0)) {
            // get pointers to the appropriate RCx_OPTION parameter
            char pname[17];
            enum ap_var_type ptype;
            snprintf(pname, sizeof(pname), "RC%u_OPTION", (unsigned)mnt_rcin);
            AP_Int16 *rcx_option = (AP_Int16 *)AP_Param::find(pname, &ptype);
            if ((rcx_option != nullptr) && !rcx_option->configured()) {
                rcx_option->set_and_save(mnt_rc_conversion_table[i].new_rc_option);
            }
        }
    }
}

// singleton instance
AP_Mount *AP_Mount::_singleton;

namespace AP {

AP_Mount *mount()
{
    return AP_Mount::get_singleton();
}

};

#endif /* HAL_MOUNT_ENABLED */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     /************************************************************
* AP_mount -- library to control a 2 or 3 axis mount.		*
*															*
* Author:  Joe Holdsworth;									*
*		   Ritchie Wilson;									*
*		   Amilcar Lucas;									*
*		   Gregory Fletcher;								*
*          heavily modified by Randy Mackay                 *
*															*
* Purpose:  Move a 2 or 3 axis mount attached to vehicle,	*
*			Used for mount to track targets or stabilise	*
*			camera plus	other modes.						*
*															*
* Usage:	Use in main code to control	mounts attached to	*
*			vehicle.										*
*															*
* Comments: All angles in degrees, distances in meters      *
*			unless otherwise stated.						*
************************************************************/
#pragma once

#include "AP_Mount_config.h"

#if HAL_MOUNT_ENABLED

#include <GCS_MAVLink/GCS_config.h>
#include <AP_HAL/AP_HAL_Boards.h>
#include <AP_Math/AP_Math.h>
#include <AP_Common/AP_Common.h>
#include <AP_Common/Location.h>
#include <GCS_MAVLink/GCS_MAVLink.h>
#include <AP_Camera/AP_Camera_shareddefs.h>
#include "AP_Mount_Params.h"

// maximum number of mounts
#define AP_MOUNT_MAX_INSTANCES          2

// declare backend classes
class AP_Mount_Backend;
class AP_Mount_Servo;
class AP_Mount_SoloGimbal;
class AP_Mount_Alexmos;
class AP_Mount_SToRM32;
class AP_Mount_SToRM32_serial;
class AP_Mount_Gremsy;
class AP_Mount_Siyi;
class AP_Mount_Scripting;
class AP_Mount_Xacti;
class AP_Mount_Viewpro;
class AP_Mount_Topotek;

/*
  This is a workaround to allow the MAVLink backend access to the
  SmallEKF. It would be nice to find a neater solution to this
 */

class AP_Mount
{
    // declare backends as friends
    friend class AP_Mount_Backend;
    friend class AP_Mount_Servo;
    friend class AP_Mount_SoloGimbal;
    friend class AP_Mount_Alexmos;
    friend class AP_Mount_SToRM32;
    friend class AP_Mount_SToRM32_serial;
    friend class AP_Mount_Gremsy;
    friend class AP_Mount_Siyi;
    friend class AP_Mount_Scripting;
    friend class AP_Mount_Xacti;
    friend class AP_Mount_Viewpro;
    friend class AP_Mount_Topotek;

public:
    AP_Mount();

    /* Do not allow copies */
    CLASS_NO_COPY(AP_Mount);

    // get singleton instance
    static AP_Mount *get_singleton() {
        return _singleton;
    }

    // Enums
    enum class Type {
        None = 0,            /// no mount
#if HAL_MOUNT_SERVO_ENABLED
        Servo = 1,           /// servo controlled mount
#endif
#if HAL_SOLO_GIMBAL_ENABLED
        SoloGimbal = 2,      /// Solo's gimbal
#endif
#if HAL_MOUNT_ALEXMOS_ENABLED
        Alexmos = 3,         /// Alexmos mount
#endif
#if HAL_MOUNT_STORM32MAVLINK_ENABLED
        SToRM32 = 4,         /// SToRM32 mount using MAVLink protocol
#endif
#if HAL_MOUNT_STORM32SERIAL_ENABLED
        SToRM32_serial = 5,  /// SToRM32 mount using custom serial protocol
#endif
#if HAL_MOUNT_GREMSY_ENABLED
        Gremsy = 6,          /// Gremsy gimbal using MAVLink v2 Gimbal protocol
#endif
#if HAL_MOUNT_SERVO_ENABLED
        BrushlessPWM = 7,    /// Brushless (stabilized) gimbal using PWM protocol
#endif
#if HAL_MOUNT_SIYI_ENABLED
        Siyi = 8,            /// Siyi gimbal using custom serial protocol
#endif
#if HAL_MOUNT_SCRIPTING_ENABLED
        Scripting = 9,       /// Scripting gimbal driver
#endif
#if HAL_MOUNT_XACTI_ENABLED
        Xacti = 10,          /// Xacti DroneCAN gimbal driver
#endif
#if HAL_MOUNT_VIEWPRO_ENABLED
        Viewpro = 11,        /// Viewpro gimbal using a custom serial protocol
#endif
#if HAL_MOUNT_TOPOTEK_ENABLED
        Topotek = 12,        /// Topotek gimbal using a custom serial protocol
#endif
    };

    // init - detect and initialise all mounts
    void init();

    // update - give mount opportunity to update servos.  should be called at 10hz or higher
    void update();

    // used for gimbals that need to read INS data at full rate
    void update_fast();

    // return primary instance ID
    uint8_t get_primary_instance() const { return _primary; }

    // get_mount_type - returns the type of mount
    Type get_mount_type() const { return get_mount_type(_primary); }
    Type get_mount_type(uint8_t instance) const;

    // has_pan_control - returns true if the mount has yaw control (required for copters)
    bool has_pan_control() const { return has_pan_control(_primary); }
    bool has_pan_control(uint8_t instance) const;

    // get_mode - returns current mode of mount (i.e. Retracted, Neutral, RC_Targeting, GPS Point)
    enum MAV_MOUNT_MODE get_mode() const { return get_mode(_primary); }
    enum MAV_MOUNT_MODE get_mode(uint8_t instance) const;

    // set_mode - sets mount's mode
    //  returns true if mode is successfully set
    void set_mode(enum MAV_MOUNT_MODE mode) { return set_mode(_primary, mode); }
    void set_mode(uint8_t instance, enum MAV_MOUNT_MODE mode);

    // set_mode_to_default - restores the mode to it's default mode held in the MNTx_DEFLT_MODE parameter
    //      this operation requires 60us on a Pixhawk/PX4
    void set_mode_to_default() { set_mode_to_default(_primary); }
    void set_mode_to_default(uint8_t instance);

    // set yaw_lock used in RC_TARGETING mode.  If true, the gimbal's yaw target is maintained in earth-frame meaning it will lock onto an earth-frame heading (e.g. North)
    // If false (aka "follow") the gimbal's yaw is maintained in body-frame meaning it will rotate with the vehicle
    void set_yaw_lock(bool yaw_lock) { set_yaw_lock(_primary, yaw_lock); }
    void set_yaw_lock(uint8_t instance, bool yaw_lock);

    // set angle target in degrees
    // roll and pitch are in earth-frame
    // yaw_is_earth_frame (aka yaw_lock) should be true if yaw angle is earth-frame, false if body-frame
    void set_angle_target(float roll_deg, float pitch_deg, float yaw_deg, bool yaw_is_earth_frame) { set_angle_target(_primary, roll_deg, pitch_deg, yaw_deg, yaw_is_earth_frame); }
    void set_angle_target(uint8_t instance, float roll_deg, float pitch_deg, float yaw_deg, bool yaw_is_earth_frame);

    // sets rate target in deg/s
    // yaw_lock should be true if the yaw rate is earth-frame, false if body-frame (e.g. rotates with body of vehicle)
    void set_rate_target(float roll_degs, float pitch_degs, float yaw_degs, bool yaw_lock) { set_rate_target(_primary, roll_degs, pitch_degs, yaw_degs, yaw_lock); }
    void set_rate_target(uint8_t instance, float roll_degs, float pitch_degs, float yaw_degs, bool yaw_lock);

    // set_roi_target - sets target location that mount should attempt to point towards
    void set_roi_target(const Location &target_loc) { set_roi_target(_primary,target_loc); }
    void set_roi_target(uint8_t instance, const Location &target_loc);

    // clear_roi_target - clears target location that mount should attempt to point towards
    void clear_roi_target() { clear_roi_target(_primary); }
    void clear_roi_target(uint8_t instance);

    // point at system ID sysid
    void set_target_sysid(uint8_t sysid) { set_target_sysid(_primary, sysid); }
    void set_target_sysid(uint8_t instance, uint8_t sysid);

    // handling of set_roi_sysid message
    MAV_RESULT handle_command_do_set_roi_sysid(const mavlink_command_int_t &packet);

    // mavlink message handling:
    MAV_RESULT handle_command(const mavlink_command_int_t &packet, const mavlink_message_t &msg);
    void handle_param_value(const mavlink_message_t &msg);
    void handle_message(mavlink_channel_t chan, const mavlink_message_t &msg);

    // send a GIMBAL_DEVICE_ATTITUDE_STATUS message to GCS
    void send_gimbal_device_attitude_status(mavlink_channel_t chan);

    // send a GIMBAL_MANAGER_INFORMATION message to GCS
    void send_gimbal_manager_information(mavlink_channel_t chan);

    // send a GIMBAL_MANAGER_STATUS message to GCS
    void send_gimbal_manager_status(mavlink_channel_t chan);

#if AP_MOUNT_POI_TO_LATLONALT_ENABLED
    // get poi information.  Returns true on success and fills in gimbal attitude, location and poi location
    bool get_poi(uint8_t instance, Quaternion &quat, Location &loc, Location &poi_loc) const;
#endif

    // get mount's current attitude in euler angles in degrees.  yaw angle is in body-frame
    // returns true on success
    bool get_attitude_euler(uint8_t instance, float& roll_deg, float& pitch_deg, float& yaw_bf_deg);

    // run pre-arm check.  returns false on failure and fills in failure_msg
    // any failure_msg returned will not include a prefix
    bool pre_arm_checks(char *failure_msg, uint8_t failure_msg_len);

    // get target rate in deg/sec. returns true on success
    bool get_rate_target(uint8_t instance, float& roll_degs, float& pitch_degs, float& yaw_degs, bool& yaw_is_earth_frame);

    // get target angle in deg. returns true on success
    bool get_angle_target(uint8_t instance, float& roll_deg, float& pitch_deg, float& yaw_deg, bool& yaw_is_earth_frame);

    // accessors for scripting backends and logging
    bool get_location_target(uint8_t instance, Location& target_loc);
    void set_attitude_euler(uint8_t instance, float roll_deg, float pitch_deg, float yaw_bf_deg);

    // write mount log packet for all backends
    void write_log();

    // write mount log packet for a single backend (called by camera library)
    void write_log(uint8_t instance, uint64_t timestamp_us);

    //
    // camera controls for gimbals that include a camera
    //

    // take a picture
    bool take_picture(uint8_t instance);

    // start or stop video recording
    // set start_recording = true to start record, false to stop recording
    bool record_video(uint8_t instance, bool start_recording);

    // set zoom specified as a rate or percentage
    bool set_zoom(uint8_t instance, ZoomType zoom_type, float zoom_value);

    // set focus specified as rate, percentage or auto
    // focus in = -1, focus hold = 0, focus out = 1
    SetFocusResult set_focus(uint8_t instance, FocusType focus_type, float focus_value);

    // set tracking to none, point or rectangle (see TrackingType enum)
    // if POINT only p1 is used, if RECTANGLE then p1 is top-left, p2 is bottom-right
    // p1,p2 are in range 0 to 1.  0 is left or top, 1 is right or bottom
    bool set_tracking(uint8_t instance, TrackingType tracking_type, const Vector2f& p1, const Vector2f& p2);

    // set camera lens as a value from 0 to 5
    bool set_lens(uint8_t instance, uint8_t lens);

#if HAL_MOUNT_SET_CAMERA_SOURCE_ENABLED
    // set_camera_source is functionally the same as set_lens except primary and secondary lenses are specified by type
    // primary and secondary sources use the AP_Camera::CameraSource enum cast to uint8_t
    bool set_camera_source(uint8_t instance, uint8_t primary_source, uint8_t secondary_source);
#endif

    // send camera information message to GCS
    void send_camera_information(uint8_t instance, mavlink_channel_t chan) const;

    // send camera settings message to GCS
    void send_camera_settings(uint8_t instance, mavlink_channel_t chan) const;

    // send camera capture status message to GCS
    void send_camera_capture_status(uint8_t instance, mavlink_channel_t chan) const;

    //
    // rangefinder
    //

    // get rangefinder distance.  Returns true on success
    bool get_rangefinder_distance(uint8_t instance, float& distance_m) const;

    // enable/disable rangefinder.  Returns true on success
    bool set_rangefinder_enable(uint8_t instance, bool enable);

    // parameter var table
    static const struct AP_Param::GroupInfo        var_info[];

protected:

    static AP_Mount *_singleton;

    // parameters for backends
    AP_Mount_Params _params[AP_MOUNT_MAX_INSTANCES];

    // front end members
    uint8_t             _num_instances;     // number of mounts instantiated
    uint8_t             _primary;           // primary mount
    AP_Mount_Backend    *_backends[AP_MOUNT_MAX_INSTANCES];         // pointers to instantiated mounts

private:
    // Check if instance backend is ok
    AP_Mount_Backend *get_primary() const;
    AP_Mount_Backend *get_instance(uint8_t instance) const;

    void handle_gimbal_report(mavlink_channel_t chan, const mavlink_message_t &msg);
#if AP_MAVLINK_MSG_MOUNT_CONFIGURE_ENABLED
    void handle_mount_configure(const mavlink_message_t &msg);
#endif
#if AP_MAVLINK_MSG_MOUNT_CONTROL_ENABLED
    void handle_mount_control(const mavlink_message_t &msg);
#endif

    MAV_RESULT handle_command_do_mount_configure(const mavlink_command_int_t &packet);
    MAV_RESULT handle_command_do_mount_control(const mavlink_command_int_t &packet);
    MAV_RESULT handle_command_do_gimbal_manager_pitchyaw(const mavlink_command_int_t &packet);
    MAV_RESULT handle_command_do_gimbal_manager_configure(const mavlink_command_int_t &packet, const mavlink_message_t &msg);
    void handle_gimbal_manager_set_attitude(const mavlink_message_t &msg);
    void handle_gimbal_manager_set_pitchyaw(const mavlink_message_t &msg);
    void handle_global_position_int(const mavlink_message_t &msg);
    void handle_gimbal_device_information(const mavlink_message_t &msg);
    void handle_gimbal_device_attitude_status(const mavlink_message_t &msg);

    // perform any required parameter conversion
    void convert_params();
};

namespace AP {
    AP_Mount *mount();
};

#endif // HAL_MOUNT_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 #include "AP_Mount_Alexmos.h"

#if HAL_MOUNT_ALEXMOS_ENABLED
#include <AP_SerialManager/AP_SerialManager.h>

//definition of the commands id for the Alexmos Serial Protocol
#define CMD_READ_PARAMS 'R'
#define CMD_WRITE_PARAMS 'W'
#define CMD_REALTIME_DATA 'D'
#define CMD_BOARD_INFO 'V'
#define CMD_CALIB_ACC 'A'
#define CMD_CALIB_GYRO 'g'
#define CMD_CALIB_EXT_GAIN 'G'
#define CMD_USE_DEFAULTS 'F'
#define CMD_CALIB_POLES 'P'
#define CMD_RESET 'r'
#define CMD_HELPER_DATA 'H'
#define CMD_CALIB_OFFSET 'O'
#define CMD_CALIB_BAT 'B'
#define CMD_MOTORS_ON 'M'
#define CMD_MOTORS_OFF 'm'
#define CMD_CONTROL 'C'
#define CMD_TRIGGER_PIN 'T'
#define CMD_EXECUTE_MENU 'E'
#define CMD_GET_ANGLES 'I'
#define CMD_CONFIRM 'C'
// Board v3.x only
#define CMD_BOARD_INFO_3 20
#define CMD_READ_PARAMS_3 21
#define CMD_WRITE_PARAMS_3 22
#define CMD_REALTIME_DATA_3 23
#define CMD_SELECT_IMU_3 24
#define CMD_READ_PROFILE_NAMES 28
#define CMD_WRITE_PROFILE_NAMES 29
#define CMD_QUEUE_PARAMS_INFO_3 30
#define CMD_SET_PARAMS_3 31
#define CMD_SAVE_PARAMS_3 32
#define CMD_READ_PARAMS_EXT 33
#define CMD_WRITE_PARAMS_EXT 34
#define CMD_AUTO_PID 35
#define CMD_SERVO_OUT 36
#define CMD_ERROR 255

#define AP_MOUNT_ALEXMOS_MODE_NO_CONTROL 0
#define AP_MOUNT_ALEXMOS_MODE_SPEED 1
#define AP_MOUNT_ALEXMOS_MODE_ANGLE 2
#define AP_MOUNT_ALEXMOS_MODE_SPEED_ANGLE 3
#define AP_MOUNT_ALEXMOS_MODE_RC 4

#define AP_MOUNT_ALEXMOS_SPEED 30 // deg/s

#define INT14_DEGREES (360.0f / float(0x3FFF)) // 1 full rotation in degrees over 14 bit range
#define VALUE_TO_DEGREE(d) (float(d)*INT14_DEGREES)
#define DEGREE_TO_VALUE(d) ((int16_t)((float)(d)*(1.0f/INT14_DEGREES)))
#define DEGREE_PER_SEC_TO_VALUE(d) ((int16_t)((float)(d)*(1.0f/0.1220740379f)))

void AP_Mount_Alexmos::init()
{
    const AP_SerialManager& serial_manager = AP::serialmanager();

    // check for alexmos protcol
    if ((_port = serial_manager.find_serial(AP_SerialManager::SerialProtocol_AlexMos, 0))) {
        _initialised = true;
        get_boardinfo();
        read_params(0); //we request parameters for profile 0 and therfore get global and profile parameters
    }
    AP_Mount_Backend::init();
}

// update mount position - should be called periodically
void AP_Mount_Alexmos::update()
{
    if (!_initialised) {
        return;
    }

    read_incoming(); // read the incoming messages from the gimbal

    // update based on mount mode
    switch (get_mode()) {
        // move mount to a "retracted" position.  we do not implement a separate servo based retract mechanism
        case MAV_MOUNT_MODE_RETRACT: {
            const Vector3f &target = _params.retract_angles.get();
            mnt_target.target_type = MountTargetType::ANGLE;
            mnt_target.angle_rad.set(target*DEG_TO_RAD, false);
            break;
        }

        // move mount to a neutral position, typically pointing forward
        case MAV_MOUNT_MODE_NEUTRAL: {
            const Vector3f &target = _params.neutral_angles.get();
            mnt_target.target_type = MountTargetType::ANGLE;
            mnt_target.angle_rad.set(target*DEG_TO_RAD, false);
            break;
        }

        // point to the angles given by a mavlink message
        case MAV_MOUNT_MODE_MAVLINK_TARGETING:
            // mavlink targets are stored while handling the incoming message
            break;

        // RC radio manual angle control, but with stabilization from the AHRS
        case MAV_MOUNT_MODE_RC_TARGETING: {
            // update targets using pilot's RC inputs
            MountTarget rc_target;
            get_rc_target(mnt_target.target_type, rc_target);
            switch (mnt_target.target_type) {
            case MountTargetType::ANGLE:
                mnt_target.angle_rad = rc_target;
                break;
            case MountTargetType::RATE:
                mnt_target.rate_rads = rc_target;
                break;
            }
            break;
        }

        // point mount to a GPS point given by the mission planner
        case MAV_MOUNT_MODE_GPS_POINT:
            if (get_angle_target_to_roi(mnt_target.angle_rad)) {
                mnt_target.target_type = MountTargetType::ANGLE;
            }
            break;

        // point mount to Home location
        case MAV_MOUNT_MODE_HOME_LOCATION:
            if (get_angle_target_to_home(mnt_target.angle_rad)) {
                mnt_target.target_type = MountTargetType::ANGLE;
            }
            break;

        // point mount to another vehicle
        case MAV_MOUNT_MODE_SYSID_TARGET:
            if (get_angle_target_to_sysid(mnt_target.angle_rad)) {
                mnt_target.target_type = MountTargetType::ANGLE;
            }
            break;

        default:
            // we do not know this mode so do nothing
            break;
    }

    // send target angles or rates depending on the target type
    switch (mnt_target.target_type) {
        case MountTargetType::RATE:
            update_angle_target_from_rate(mnt_target.rate_rads, mnt_target.angle_rad);
            FALLTHROUGH;
        case MountTargetType::ANGLE:
            // send latest angle targets to gimbal
            control_axis(mnt_target.angle_rad);
            break;
    }
}

// has_pan_control - returns true if this mount can control its pan (required for multicopters)
bool AP_Mount_Alexmos::has_pan_control() const
{
    return _gimbal_3axis && yaw_range_valid();
}

// get attitude as a quaternion.  returns true on success
bool AP_Mount_Alexmos::get_attitude_quaternion(Quaternion& att_quat)
{
    if (!_initialised) {
        return false;
    }

    // request attitude from gimbal
    get_angles();

    // construct quaternion
    att_quat.from_euler(radians(_current_angle.x), radians(_current_angle.y), radians(_current_angle.z));
    return true;
}

/*
 * get_angles
 */
void AP_Mount_Alexmos::get_angles()
{
    uint8_t data[1] = {(uint8_t)1};
    send_command(CMD_GET_ANGLES, data, 1);
}

/*
 * set_motor will activate motors if true, and disable them if false.
 */
void AP_Mount_Alexmos::set_motor(bool on)
{
    if (on) {
        uint8_t data[1] = {(uint8_t)1};
        send_command(CMD_MOTORS_ON, data, 1);
    } else {
        uint8_t data[1] = {(uint8_t)1};
        send_command(CMD_MOTORS_OFF, data, 1);
    }
}

/*
 * get board version and firmware version
 */
void AP_Mount_Alexmos::get_boardinfo()
{
    if (_board_version != 0) {
        return;
    }
    uint8_t data[1] = {(uint8_t)1};
    send_command(CMD_BOARD_INFO, data, 1);
}

/*
  control_axis : send new angle target to the gimbal at a fixed speed of 30 deg/s
*/
void AP_Mount_Alexmos::control_axis(const MountTarget& angle_target_rad)
{
    alexmos_parameters outgoing_buffer;
    outgoing_buffer.angle_speed.mode = AP_MOUNT_ALEXMOS_MODE_ANGLE;
    outgoing_buffer.angle_speed.speed_roll = DEGREE_PER_SEC_TO_VALUE(AP_MOUNT_ALEXMOS_SPEED);
    outgoing_buffer.angle_speed.angle_roll = DEGREE_TO_VALUE(degrees(angle_target_rad.roll));
    outgoing_buffer.angle_speed.speed_pitch = DEGREE_PER_SEC_TO_VALUE(AP_MOUNT_ALEXMOS_SPEED);
    outgoing_buffer.angle_speed.angle_pitch = DEGREE_TO_VALUE(degrees(angle_target_rad.pitch));
    outgoing_buffer.angle_speed.speed_yaw = DEGREE_PER_SEC_TO_VALUE(AP_MOUNT_ALEXMOS_SPEED);
    outgoing_buffer.angle_speed.angle_yaw = DEGREE_TO_VALUE(angle_target_rad.get_bf_yaw());
    send_command(CMD_CONTROL, (uint8_t *)&outgoing_buffer.angle_speed, sizeof(alexmos_angles_speed));
}

/*
  read current profile profile_id and global parameters from the gimbal settings
*/
void AP_Mount_Alexmos::read_params(uint8_t profile_id)
{
    uint8_t data[1] = {(uint8_t) profile_id}; 
    send_command(CMD_READ_PARAMS, data, 1);
}

/*
  write new parameters to the gimbal settings
*/
void AP_Mount_Alexmos::write_params()
{
    if (!_param_read_once) {
        return;
    }
    send_command(CMD_WRITE_PARAMS, (uint8_t *)&_current_parameters.params, sizeof(alexmos_params));
}

/*
 send a command to the Alemox Serial API
*/
void AP_Mount_Alexmos::send_command(uint8_t cmd, uint8_t* data, uint8_t size)
{
    if (_port->txspace() < (size + 5U)) {
        return;
    }
    uint8_t checksum = 0;
    _port->write( '>' );
    _port->write( cmd );  // write command id
    _port->write( size );  // write body size
    _port->write( cmd+size ); // write header checkum

    for (uint8_t i = 0;  i != size ; i++) {
        checksum += data[i];
        _port->write( data[i] );
    }
    _port->write(checksum);
}

/*
 * Parse the body of the message received from the Alexmos gimbal
 */
void AP_Mount_Alexmos::parse_body()
{
    switch (_command_id ) {
        case CMD_BOARD_INFO:
            _board_version = _buffer.version._board_version/ 10;
            _current_firmware_version = _buffer.version._firmware_version * 0.001f ;
            _firmware_beta_version = _buffer.version._firmware_version % 10 ;
            _gimbal_3axis = (_buffer.version._board_features & 0x1);
            _gimbal_bat_monitoring = (_buffer.version._board_features & 0x2);
            break;

        case CMD_GET_ANGLES:
            _current_angle.x = VALUE_TO_DEGREE(_buffer.angles.angle_roll);
            _current_angle.y = VALUE_TO_DEGREE(_buffer.angles.angle_pitch);
            _current_angle.z = VALUE_TO_DEGREE(_buffer.angles.angle_yaw);
            break;

        case CMD_READ_PARAMS:
            _param_read_once = true;
            _current_parameters.params = _buffer.params;
            break;

        case CMD_WRITE_PARAMS:
            break;

        default :
            _last_command_confirmed = true;
            break;
    }
}

/*
 * detect and read the header of the incoming message from the gimbal
 */
void AP_Mount_Alexmos::read_incoming()
{
    uint8_t data;
    int16_t numc;

    numc = _port->available();

    if (numc < 0 ) {
        return;
    }

    for (int16_t i = 0; i < numc; i++) {        // Process bytes received
        data = _port->read();
        switch (_step) {
            case 0:
                if ( '>' == data) {
                    _step = 1;
                    _checksum = 0; //reset checksum accumulator
                    _last_command_confirmed = false;
                }
                break;

            case 1: // command ID
                _checksum = data;
                _command_id = data;
                _step++;
                break;

            case 2: // Size of the body of the message
                _checksum += data;
                _payload_length = data;
                _step++;
                break;

            case 3:	// checksum of the header
                if (_checksum != data ) {
                    _step = 0;
                    _checksum = 0;
                    // checksum error
                    break;
                }
                _step++;
                _checksum = 0;
                _payload_counter = 0;                               // prepare to receive payload
                break;

            case 4: // parsing body
                _checksum += data;
                if (_payload_counter < sizeof(_buffer)) {
                    _buffer[_payload_counter] = data;
                }
                if (++_payload_counter == _payload_length)
                    _step++;
                break;

            case 5:// body checksum
                _step = 0;
                if (_checksum  != data) {
                    break;
                }
                parse_body();
        }
    }
}
#endif // HAL_MOUNT_ALEXMOS_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 /*
  Alexmos Serial controlled mount backend class
*/
#pragma once

#include "AP_Mount_Backend.h"

#if HAL_MOUNT_ALEXMOS_ENABLED
#include <AP_HAL/AP_HAL.h>
#include <AP_Param/AP_Param.h>
#include <AP_Math/AP_Math.h>

class AP_Mount_Alexmos : public AP_Mount_Backend
{
public:
    //constructor
    using AP_Mount_Backend::AP_Mount_Backend;

    // init - performs any required initialisation for this instance
    void init() override;

    // update mount position - should be called periodically
    void update() override;

    // has_pan_control - returns true if this mount can control its pan (required for multicopters)
    bool has_pan_control() const override;

protected:

    // get attitude as a quaternion.  returns true on success
    bool get_attitude_quaternion(Quaternion& att_quat) override;

private:

    // get_angles -
    void get_angles();

    // set_motor will activate motors if true, and disable them if false
    void set_motor(bool on);

    // get_boardinfo - get board version and firmware version
    void get_boardinfo();

    // send new angles to the gimbal at a fixed speed of 30 deg/s
    void control_axis(const MountTarget& angle_target_rad);

    // read_params - read current profile profile_id and global parameters from the gimbal settings
    void read_params(uint8_t profile_id);

    // write_params - write new parameters to the gimbal settings
    void write_params();

    bool get_realtimedata(Vector3f& angle);

    // Alexmos Serial Protocol reading part implementation
    // send_command - send a command to the Alemox Serial API
    void send_command(uint8_t cmd, uint8_t* data, uint8_t size);

    // Parse the body of the message received from the Alexmos gimbal
    void parse_body();

    // read_incoming - detect and read the header of the incoming message from the gimbal
    void read_incoming();

    // structure for the Serial Protocol

    // CMD_BOARD_INFO
    struct PACKED alexmos_version {
        uint8_t _board_version;
        uint16_t _firmware_version;
        uint8_t debug_mode;
        uint16_t _board_features;
    };

    // CMD_GET_ANGLES
    struct PACKED alexmos_angles {
        int16_t angle_roll;
        int16_t rc_angle_roll;
        int16_t rc_speed_roll;
        int16_t angle_pitch;
        int16_t rc_angle_pitch;
        int16_t rc_speed_pitch;
        int16_t angle_yaw;
        int16_t rc_angle_yaw;
        int16_t rc_speed_yaw;
    };

    // CMD_CONTROL
    struct PACKED alexmos_angles_speed {
        int8_t mode;
        int16_t speed_roll;
        int16_t angle_roll;
        int16_t speed_pitch;
        int16_t angle_pitch;
        int16_t speed_yaw;
        int16_t angle_yaw;
    };

    // CMD_READ_PARAMS
    struct PACKED alexmos_params {
        uint8_t profile_id;
        uint8_t roll_P;
        uint8_t roll_I;
        uint8_t roll_D;
        uint8_t roll_power;
        uint8_t roll_invert;
        uint8_t roll_poles;
        uint8_t pitch_P;
        uint8_t pitch_I;
        uint8_t pitch_D;
        uint8_t pitch_power;
        uint8_t pitch_invert;
        uint8_t pitch_poles;
        uint8_t yaw_P;
        uint8_t yaw_I;
        uint8_t yaw_D;
        uint8_t yaw_power;
        uint8_t yaw_invert;
        uint8_t yaw_poles;
        uint8_t acc_limiter;
        int8_t ext_fc_gain_roll;
        int8_t ext_fc_gain_pitch;
        int16_t roll_rc_min_angle;
        int16_t roll_rc_max_angle;
        uint8_t roll_rc_mode;
        uint8_t roll_rc_lpf;
        uint8_t roll_rc_speed;
        uint8_t roll_rc_follow;
        int16_t pitch_rc_min_angle;
        int16_t pitch_rc_max_angle;
        uint8_t pitch_rc_mode;
        uint8_t pitch_rc_lpf;
        uint8_t pitch_rc_speed;
        uint8_t pitch_rc_follow;
        int16_t yaw_rc_min_angle;
        int16_t yaw_rc_max_angle;
        uint8_t yaw_rc_mode;
        uint8_t yaw_rc_lpf;
        uint8_t yaw_rc_speed;
        uint8_t yaw_rc_follow;
        uint8_t gyro_trust;
        uint8_t use_model;
        uint8_t pwm_freq;
        uint8_t serial_speed;
        int8_t rc_trim_roll;
        int8_t rc_trim_pitch;
        int8_t rc_trim_yaw;
        uint8_t rc_deadband;
        uint8_t rc_expo_rate;
        uint8_t rc_virt_mode;
        uint8_t rc_map_roll;
        uint8_t rc_map_pitch;	
        uint8_t rc_map_yaw;
        uint8_t rc_map_cmd;
        uint8_t rc_map_fc_roll;
        uint8_t rc_map_fc_pitch;

        uint8_t rc_mix_fc_roll;
        uint8_t rc_mix_fc_pitch;

        uint8_t follow_mode;
        uint8_t follow_deadband;
        uint8_t follow_expo_rate;
        int8_t follow_offset_roll;
        int8_t follow_offset_pitch;
        int8_t follow_offset_yaw;

        int8_t axis_top;
        int8_t axis_right;

        uint8_t gyro_lpf;

        uint8_t gyro_sens;
        uint8_t i2c_internal_pullups;
        uint8_t sky_gyro_calib;

        uint8_t rc_cmd_low;
        uint8_t rc_cmd_mid;
        uint8_t rc_cmd_high;

        uint8_t menu_cmd_1;
        uint8_t menu_cmd_2;
        uint8_t menu_cmd_3;
        uint8_t menu_cmd_4;
        uint8_t menu_cmd_5;
        uint8_t menu_cmd_long;

        uint8_t output_roll;
        uint8_t output_pitch;
        uint8_t output_yaw;

        int16_t bat_threshold_alarm;
        int16_t bat_threshold_motors;
        int16_t bat_comp_ref;

        uint8_t beeper_modes;

        uint8_t follow_roll_mix_start;
        uint8_t follow_roll_mix_range;

        uint8_t booster_power_roll;
        uint8_t booster_power_pitch;
        uint8_t booster_power_yaw;

        uint8_t follow_speed_roll;
        uint8_t follow_speed_pitch;
        uint8_t follow_speed_yaw;

        uint8_t frame_angle_from_motors;

        uint8_t cur_profile_id;

    };
    union PACKED alexmos_parameters {
        DEFINE_BYTE_ARRAY_METHODS
        alexmos_version version;
        alexmos_angles angles;
        alexmos_params params;
        alexmos_angles_speed angle_speed;
    } _buffer,_current_parameters;

    AP_HAL::UARTDriver *_port;
    bool _initialised : 1;

    // result of the get_boardinfo
    uint8_t _board_version;
    float _current_firmware_version;
    uint8_t _firmware_beta_version;
    bool _gimbal_3axis : 1;
    bool _gimbal_bat_monitoring : 1;

    // keep the last _current_angle values
    Vector3f _current_angle;

    // CMD_READ_PARAMS has been called once
    bool _param_read_once : 1;

    // Serial Protocol Variables
    uint8_t _checksum;
    uint8_t _step;
    uint8_t _command_id;
    uint8_t _payload_length;
    uint8_t _payload_counter;

    // confirmed that last command was ok
    bool _last_command_confirmed : 1;
};
#endif // HAL_MOUNT_ALEXMOS_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           #include "AP_Mount_Backend.h"
#if HAL_MOUNT_ENABLED
#include <AP_AHRS/AP_AHRS.h>
#include <GCS_MAVLink/GCS.h>
#include <AP_Logger/AP_Logger.h>
#include <AP_Terrain/AP_Terrain.h>

extern const AP_HAL::HAL& hal;

#define AP_MOUNT_UPDATE_DT 0.02     // update rate in seconds.  update() should be called at this rate
#define AP_MOUNT_POI_REQUEST_TIMEOUT_MS 30000   // POI calculations continue to be updated for this many seconds after last request
#define AP_MOUNT_POI_RESULT_TIMEOUT_MS  3000    // POI calculations valid for 3 seconds
#define AP_MOUNT_POI_DIST_M_MAX         10000   // POI calculations limit of 10,000m (10km)

// Default init function for every mount
void AP_Mount_Backend::init()
{
    // setting default target sysid from parameters
    _target_sysid = _params.sysid_default.get();

#if AP_MOUNT_POI_TO_LATLONALT_ENABLED
    // create a calculation thread for poi.
    if (!hal.scheduler->thread_create(FUNCTOR_BIND_MEMBER(&AP_Mount_Backend::calculate_poi, void),
                                      "mount_calc_poi",
                                      8192, AP_HAL::Scheduler::PRIORITY_IO, -1)) {
        GCS_SEND_TEXT(MAV_SEVERITY_ERROR, "Mount: failed to start POI thread");
    }
#endif
}

// set device id of this instance, for MNTx_DEVID parameter
void AP_Mount_Backend::set_dev_id(uint32_t id)
{
    _params.dev_id.set_and_save(int32_t(id));
}

// return true if this mount accepts roll targets
bool AP_Mount_Backend::has_roll_control() const
{
    return (_params.roll_angle_min < _params.roll_angle_max);
}

// return true if this mount accepts pitch targets
bool AP_Mount_Backend::has_pitch_control() const
{
    return (_params.pitch_angle_min < _params.pitch_angle_max);
}

bool AP_Mount_Backend::valid_mode(MAV_MOUNT_MODE mode) const
{
    switch (mode) {
    case MAV_MOUNT_MODE_RETRACT...MAV_MOUNT_MODE_HOME_LOCATION:
        return true;
    case MAV_MOUNT_MODE_ENUM_END:
        return false;
    }
    return false;
}

bool AP_Mount_Backend::set_mode(MAV_MOUNT_MODE mode)
{
    if (!valid_mode(mode)) {
        return false;
    }
    _mode = mode;
    return true;
}

// set angle target in degrees
// roll and pitch are in earth-frame
// yaw_is_earth_frame (aka yaw_lock) should be true if yaw angle is earth-frame, false if body-frame
void AP_Mount_Backend::set_angle_target(float roll_deg, float pitch_deg, float yaw_deg, bool yaw_is_earth_frame)
{
    // enforce angle limits
    roll_deg = constrain_float(roll_deg, _params.roll_angle_min, _params.roll_angle_max);
    pitch_deg = constrain_float(pitch_deg, _params.pitch_angle_min, _params.pitch_angle_max);
    if (!yaw_is_earth_frame) {
        // only limit yaw if in body-frame.  earth-frame yaw limiting is backend specific
        // custom wrap code (instead of wrap_180) to better handle yaw of <= -180
        if (yaw_deg > 180) {
            yaw_deg -= 360;
        }
        yaw_deg = constrain_float(yaw_deg, _params.yaw_angle_min, _params.yaw_angle_max);
    }

    // set angle targets
    mnt_target.target_type = MountTargetType::ANGLE;
    mnt_target.angle_rad.roll = radians(roll_deg);
    mnt_target.angle_rad.pitch = radians(pitch_deg);
    mnt_target.angle_rad.yaw = radians(yaw_deg);
    mnt_target.angle_rad.yaw_is_ef = yaw_is_earth_frame;

    // set the mode to mavlink targeting
    set_mode(MAV_MOUNT_MODE_MAVLINK_TARGETING);

    // optionally set RC_TARGETING yaw lock state
    if (option_set(Options::RCTARGETING_LOCK_FROM_PREVMODE)) {
        set_yaw_lock(yaw_is_earth_frame);
    }
}

// sets rate target in deg/s
// yaw_lock should be true if the yaw rate is earth-frame, false if body-frame (e.g. rotates with body of vehicle)
void AP_Mount_Backend::set_rate_target(float roll_degs, float pitch_degs, float yaw_degs, bool yaw_is_earth_frame)
{
    // set rate targets
    mnt_target.target_type = MountTargetType::RATE;
    mnt_target.rate_rads.roll = radians(roll_degs);
    mnt_target.rate_rads.pitch = radians(pitch_degs);
    mnt_target.rate_rads.yaw = radians(yaw_degs);
    mnt_target.rate_rads.yaw_is_ef = yaw_is_earth_frame;

    // set the mode to mavlink targeting
    set_mode(MAV_MOUNT_MODE_MAVLINK_TARGETING);

    // optionally set RC_TARGETING yaw lock state
    if (option_set(Options::RCTARGETING_LOCK_FROM_PREVMODE)) {
        set_yaw_lock(yaw_is_earth_frame);
    }
}

// set_roi_target - sets target location that mount should attempt to point towards
void AP_Mount_Backend::set_roi_target(const Location &target_loc)
{
    // set the target gps location
    _roi_target = target_loc;
    _roi_target_set = true;

    // set the mode to GPS tracking mode
    set_mode(MAV_MOUNT_MODE_GPS_POINT);

    // optionally set RC_TARGETING yaw lock state
    if (option_set(Options::RCTARGETING_LOCK_FROM_PREVMODE)) {
        set_yaw_lock(true);
    }
}

// clear_roi_target - clears target location that mount should attempt to point towards
void AP_Mount_Backend::clear_roi_target()
{
    // clear the target GPS location
    _roi_target_set = false;

    // reset the mode if in GPS tracking mode
    if (get_mode() == MAV_MOUNT_MODE_GPS_POINT) {
        MAV_MOUNT_MODE default_mode = (MAV_MOUNT_MODE)_params.default_mode.get();
        set_mode(default_mode);
    }
}

// set_sys_target - sets system that mount should attempt to point towards
void AP_Mount_Backend::set_target_sysid(uint8_t sysid)
{
    _target_sysid = sysid;

    // set the mode to sysid tracking mode
    set_mode(MAV_MOUNT_MODE_SYSID_TARGET);

    // optionally set RC_TARGETING yaw lock state
    if (option_set(Options::RCTARGETING_LOCK_FROM_PREVMODE)) {
        set_yaw_lock(true);
    }
}

#if AP_MAVLINK_MSG_MOUNT_CONFIGURE_ENABLED
// process MOUNT_CONFIGURE messages received from GCS. deprecated.
void AP_Mount_Backend::handle_mount_configure(const mavlink_mount_configure_t &packet)
{
    set_mode((MAV_MOUNT_MODE)packet.mount_mode);
}
#endif

#if HAL_GCS_ENABLED
// send a GIMBAL_DEVICE_ATTITUDE_STATUS message to GCS
void AP_Mount_Backend::send_gimbal_device_attitude_status(mavlink_channel_t chan)
{
    if (suppress_heartbeat()) {
        // block heartbeat from transmitting to the GCS
        GCS_MAVLINK::disable_channel_routing(chan);
    }

    Quaternion att_quat;
    if (!get_attitude_quaternion(att_quat)) {
        return;
    }
    Vector3f ang_velocity { nanf(""), nanf(""), nanf("") };
    IGNORE_RETURN(get_angular_velocity(ang_velocity));

    // construct quaternion array
    const float quat_array[4] = {att_quat.q1, att_quat.q2, att_quat.q3, att_quat.q4};

    mavlink_msg_gimbal_device_attitude_status_send(chan,
                                                   0,   // target system
                                                   0,   // target component
                                                   AP_HAL::millis(),    // autopilot system time
                                                   get_gimbal_device_flags(),
                                                   quat_array,    // attitude expressed as quaternion
                                                   ang_velocity.x,    // roll axis angular velocity (NaN for unknown)
                                                   ang_velocity.y,    // pitch axis angular velocity (NaN for unknown)
                                                   ang_velocity.z,    // yaw axis angular velocity (NaN for unknown)
                                                   0,                                           // failure flags (not supported)
                                                   std::numeric_limits<double>::quiet_NaN(),    // delta_yaw (NaN for unknonw)
                                                   std::numeric_limits<double>::quiet_NaN(),    // delta_yaw_velocity (NaN for unknonw)
                                                   _instance + 1);  // gimbal_device_id
}
#endif

// return gimbal manager capability flags used by GIMBAL_MANAGER_INFORMATION message
uint32_t AP_Mount_Backend::get_gimbal_manager_capability_flags() const
{
    uint32_t cap_flags = GIMBAL_MANAGER_CAP_FLAGS_HAS_RETRACT |
                         GIMBAL_MANAGER_CAP_FLAGS_HAS_NEUTRAL |
                         GIMBAL_MANAGER_CAP_FLAGS_HAS_RC_INPUTS |
    