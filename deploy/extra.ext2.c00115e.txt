nt32(Param::Recording, start_recording ? 1 : 0);
}

// set zoom specified as a rate or percentage
bool AP_Mount_Xacti::set_zoom(ZoomType zoom_type, float zoom_value)
{
    // zoom rate
    if (zoom_type == ZoomType::RATE) {
        if (is_zero(zoom_value)) {
            // stop zooming
            _zoom_rate_control.enabled = false;
        } else {
            // zoom in or out
            _zoom_rate_control.enabled = true;
            _zoom_rate_control.dir = (zoom_value < 0) ? -1 : 1;
        }
        return true;
    }

    // zoom percentage
    if (zoom_type == ZoomType::PCT) {
        if (capabilities.optical_zoom == Capability::True) {
            // optical zoom capable cameras use combination of optical and digital zoom
            // convert zoom percentage (0 ~ 100) to zoom times using linear interpolation
            // optical zoom covers 1x to 2.5x, param values are in 100 to 250
            // digital zoom covers 2.5x to 25x, param values are 100 to 1000
            const float zoom_times = linear_interpolate(1, 25, zoom_value, 0, 100);
            const uint16_t optical_zoom_param = constrain_uint16(uint16_t(zoom_times * 10) * 10, 100, 250);
            const uint16_t digital_zoom_param = constrain_uint16(uint16_t(zoom_times * 0.4) * 100, 100, 1000);
            bool ret = true;
            if (optical_zoom_param != _last_optical_zoom_param_value) {
                ret = set_param_int32(Param::OpticalZoomMagnification, optical_zoom_param);
            }
            if (digital_zoom_param != _last_digital_zoom_param_value) {
                ret &= set_param_int32(Param::DigitalZoomMagnification, digital_zoom_param);
            }
            return ret;
        }
        // digital only zoom
        // convert zoom percentage (0 ~ 100) to zoom parameter value (100, 200, 300, ... 1000)
        // 0~11pct:100, 12~22pct:200, 23~33pct:300, 34~44pct:400, 45~55pct:500, 56~66pct:600, 67~77pct:700, 78~88pct:800, 89~99pct:900, 100:1000
        const uint16_t zoom_param_value = uint16_t(linear_interpolate(1, 10, zoom_value, 0, 100)) * 100;
        return set_param_int32(Param::DigitalZoomMagnification, zoom_param_value);
    }

    // unsupported zoom type
    return false;
}

// set focus specified as rate, percentage or auto
// focus in = -1, focus hold = 0, focus out = 1
SetFocusResult AP_Mount_Xacti::set_focus(FocusType focus_type, float focus_value)
{
    // convert focus type and value to parameter value
    uint8_t focus_param_value;
    switch (focus_type) {
    case FocusType::RATE:
    case FocusType::PCT:
        // focus rate and percentage control not supported so simply switch to manual focus
        // FocusMode of 0:Manual Focus
        focus_param_value = 0;
        break;
    case FocusType::AUTO:
        // FocusMode of 1:Single AutoFocus, 2:Continuous AutoFocus
        focus_param_value = 2;
        break;
    default:
        // unsupported forucs mode
        return SetFocusResult::INVALID_PARAMETERS;
    }

    // set FocusMode parameter
    return set_param_int32(Param::FocusMode, focus_param_value) ? SetFocusResult::ACCEPTED : SetFocusResult::FAILED;
}

// set camera lens as a value from 0 to 5
bool AP_Mount_Xacti::set_lens(uint8_t lens)
{
    // sanity check
    if (lens > (uint8_t)SensorsMode::NDVI) {
        return false;
    }

    return set_param_int32(Param::SensorMode, lens);
}

// set_camera_source is functionally the same as set_lens except primary and secondary lenses are specified by type
// primary and secondary sources use the AP_Camera::CameraSource enum cast to uint8_t
bool AP_Mount_Xacti::set_camera_source(uint8_t primary_source, uint8_t secondary_source)
{
    // maps primary and secondary source to xacti SensorsMode
    SensorsMode new_sensor_mode;
    switch (primary_source) {
    case 0: // Default (RGB)
        FALLTHROUGH;
    case 1: // RGB
        switch (secondary_source) {
        case 0: // RGB + Default (None)
            new_sensor_mode = SensorsMode::RGB;
            break;
        case 2: // PIP RGB+IR
            new_sensor_mode = SensorsMode::PIP;
            break;
        default:
            return false;
        }
        break;
    case 2: // IR
        if (secondary_source != 0) {
            return false;
        }
        new_sensor_mode = SensorsMode::IR;
        break;
    case 3: // NDVI
        if (secondary_source != 0) {
            return false;
        }
        // NDVI + Default (None)
        new_sensor_mode = SensorsMode::NDVI;
        break;
    default:
        return false;
    }

    // send desired sensor mode to camera
    return set_param_int32(Param::SensorMode, (uint8_t)new_sensor_mode);
}

// send camera information message to GCS
void AP_Mount_Xacti::send_camera_information(mavlink_channel_t chan) const
{
    // exit immediately if not initialised
    if (!_initialised) {
        return;
    }

    static const uint8_t vendor_name[32] = "Xacti";
    static uint8_t model_name[32] = "CX-GB100";
    const char cam_definition_uri[140] {};
    const float NaN = nanf("0x4152");

    // capability flags
    const uint32_t flags = CAMERA_CAP_FLAGS_CAPTURE_VIDEO |
                           CAMERA_CAP_FLAGS_CAPTURE_IMAGE |
                           CAMERA_CAP_FLAGS_HAS_BASIC_FOCUS;

    // send CAMERA_INFORMATION message
    mavlink_msg_camera_information_send(
        chan,
        AP_HAL::millis(),       // time_boot_ms
        vendor_name,            // vendor_name uint8_t[32]
        model_name,             // model_name uint8_t[32]
        _firmware_version.received ? _firmware_version.mav_ver : 0, // firmware version uint32_t
        NaN,                    // focal_length float (mm)
        NaN,                    // sensor_size_h float (mm)
        NaN,                    // sensor_size_v float (mm)
        0,                      // resolution_h uint16_t (pix)
        0,                      // resolution_v uint16_t (pix)
        0,                      // lens_id uint8_t
        flags,                  // flags uint32_t (CAMERA_CAP_FLAGS)
        0,                      // cam_definition_version uint16_t
        cam_definition_uri,     // cam_definition_uri char[140]
        _instance + 1);         // gimbal_device_id uint8_t
}

// send camera settings message to GCS
void AP_Mount_Xacti::send_camera_settings(mavlink_channel_t chan) const
{
    const float NaN = nanf("0x4152");

    // send CAMERA_SETTINGS message
    mavlink_msg_camera_settings_send(
        chan,
        AP_HAL::millis(),   // time_boot_ms
        _recording_video ? CAMERA_MODE_VIDEO : CAMERA_MODE_IMAGE,   // camera mode (0:image, 1:video, 2:image survey)
        0,                  // zoomLevel float, percentage from 0 to 100, NaN if unknown
        NaN);               // focusLevel float, percentage from 0 to 100, NaN if unknown
}

// get attitude as a quaternion.  returns true on success
bool AP_Mount_Xacti::get_attitude_quaternion(Quaternion& att_quat)
{
    att_quat = _current_attitude_quat;
    return true;
}

// send target pitch and yaw rates to gimbal
// yaw_is_ef should be true if yaw_rads target is an earth frame rate, false if body_frame
void AP_Mount_Xacti::send_target_rates(float pitch_rads, float yaw_rads, bool yaw_is_ef)
{
    // send gimbal rate target to gimbal
    send_gimbal_control(3, degrees(pitch_rads) * 100, degrees(yaw_rads) * 100);
}

// send target pitch and yaw angles to gimbal
// yaw_is_ef should be true if yaw_rad target is an earth frame angle, false if body_frame
void AP_Mount_Xacti::send_target_angles(float pitch_rad, float yaw_rad, bool yaw_is_ef)
{
    // convert yaw to body frame
    const float yaw_bf_rad = yaw_is_ef ? wrap_PI(yaw_rad - AP::ahrs().get_yaw()) : yaw_rad;

    // send angle target to gimbal
    send_gimbal_control(2, degrees(pitch_rad) * 100, degrees(yaw_bf_rad) * 100);
}

// subscribe to Xacti DroneCAN messages
void AP_Mount_Xacti::subscribe_msgs(AP_DroneCAN* ap_dronecan)
{
    // return immediately if DroneCAN is unavailable
    if (ap_dronecan == nullptr) {
        GCS_SEND_TEXT(MAV_SEVERITY_CRITICAL, "%s DroneCAN subscribe failed", send_text_prefix);
        return;
    }

    _subscribed = true;

    if (Canard::allocate_sub_arg_callback(ap_dronecan, &handle_gimbal_attitude_status, ap_dronecan->get_driver_index()) == nullptr) {
        AP_BoardConfig::allocation_error("gimbal_attitude_status_sub");
        _subscribed = false;
    }

    if (Canard::allocate_sub_arg_callback(ap_dronecan, &handle_gnss_status_req, ap_dronecan->get_driver_index()) == nullptr) {
        AP_BoardConfig::allocation_error("gnss_status_req_sub");
        _subscribed = false;
    }
}

// register backend in detected modules array used to map DroneCAN port and node id to backend
void AP_Mount_Xacti::register_backend()
{
    WITH_SEMAPHORE(_sem_registry);

    // add this backend to _detected_modules array
    _detected_modules[_instance].driver = this;

    // return if devid is zero meaning this backend has not yet been associated with a mount
    const uint32_t devid = (uint32_t)_params.dev_id.get();
    if (devid == 0) {
        return;
    }

    // get DroneCan port from device id
    const uint8_t can_driver_index = AP_HAL::Device::devid_get_bus(devid);
    const uint8_t can_num_drivers = AP::can().get_num_drivers();
    for (uint8_t i = 0; i < can_num_drivers; i++) {
        AP_DroneCAN *ap_dronecan = AP_DroneCAN::get_dronecan(i);
        if (ap_dronecan != nullptr && ap_dronecan->get_driver_index() == can_driver_index) {
            _detected_modules[_instance].ap_dronecan = ap_dronecan;
        }
    }

    // get node_id from device id
    _detected_modules[_instance].node_id = AP_HAL::Device::devid_get_address(devid);
}

// find backend associated with the given dronecan port and node_id.  also associates backends with zero node ids
// returns pointer to backend on success, nullptr on failure
AP_Mount_Xacti* AP_Mount_Xacti::get_dronecan_backend(AP_DroneCAN* ap_dronecan, uint8_t node_id)
{
    WITH_SEMAPHORE(_sem_registry);

    // exit immediately if DroneCAN is unavailable or invalid node id
    if (ap_dronecan == nullptr || node_id == 0) {
        return nullptr;
    }

    // search for backend with matching dronecan port and node id
    for (uint8_t i = 0; i < ARRAY_SIZE(_detected_modules); i++) {
        if (_detected_modules[i].driver != nullptr &&
            _detected_modules[i].ap_dronecan == ap_dronecan &&
            _detected_modules[i].node_id == node_id ) {
            return _detected_modules[i].driver;
        }
    }

    // if we got this far, this dronecan port and node id are not associated with any backend
    // associate with first backend with node id of zero
    for (uint8_t i = 0; i < ARRAY_SIZE(_detected_modules); i++) {
        if (_detected_modules[i].driver != nullptr &&
            _detected_modules[i].node_id == 0) {
                _detected_modules[i].ap_dronecan = ap_dronecan;
                _detected_modules[i].node_id = node_id;
                const auto dev_id = AP_HAL::Device::make_bus_id(AP_HAL::Device::BUS_TYPE_UAVCAN,
                                                                ap_dronecan->get_driver_index(),
                                                                node_id, 0);
                _detected_modules[i].driver->set_dev_id(dev_id);
                return _detected_modules[i].driver;
        }
    }

    return nullptr;
}

// handle xacti gimbal attitude status message
void AP_Mount_Xacti::handle_gimbal_attitude_status(AP_DroneCAN* ap_dronecan, const CanardRxTransfer& transfer, const com_xacti_GimbalAttitudeStatus &msg)
{
    // fetch the matching backend driver, node id and gimbal id backend instance
    AP_Mount_Xacti* driver = get_dronecan_backend(ap_dronecan, transfer.source_node_id);
    if (driver == nullptr) {
        return;
    }

    // convert body-frame Euler angles to Quaternion.  Note yaw direction is reversed from normal
    driver->_current_attitude_quat.from_euler(radians(msg.gimbal_roll * 0.01), radians(msg.gimbal_pitch * 0.01), radians(-msg.gimbal_yaw * 0.01));
    driver->_last_current_attitude_quat_ms = AP_HAL::millis();
}

// handle xacti gnss status request message
void AP_Mount_Xacti::handle_gnss_status_req(AP_DroneCAN* ap_dronecan, const CanardRxTransfer& transfer, const com_xacti_GnssStatusReq &msg)
{
    // sanity check dronecan port
    if (ap_dronecan == nullptr) {
        return;
    }

    // get current location
    uint8_t gps_status = 2;
    Location loc;
    if (!AP::ahrs().get_location(loc)) {
        gps_status = 0;
    }

    // get date and time
    uint16_t year, ms;
    uint8_t month, day, hour, min, sec;
#if AP_RTC_ENABLED
    if (!AP::rtc().get_date_and_time_utc(year, month, day, hour, min, sec, ms)) {
        year = month = day = hour = min = sec = 0;
    }
#else
    year = month = day = hour = min = sec = 0;
    (void)ms;
#endif

    // send xacti specific gnss status message
    com_xacti_GnssStatus xacti_gnss_status_msg {};
    xacti_gnss_status_msg.gps_status = gps_status;
    xacti_gnss_status_msg.order = msg.requirement;
    xacti_gnss_status_msg.remain_buffer = 1;
    xacti_gnss_status_msg.utc_year = year;
    xacti_gnss_status_msg.utc_month = month + 1;
    xacti_gnss_status_msg.utc_day = day;
    xacti_gnss_status_msg.utc_hour = hour;
    xacti_gnss_status_msg.utc_minute = min;
    xacti_gnss_status_msg.utc_seconds = sec;
    xacti_gnss_status_msg.latitude = loc.lat * 1e-7;
    xacti_gnss_status_msg.longitude = loc.lng * 1e-7;
    xacti_gnss_status_msg.altitude = loc.alt * 1e-2;
    ap_dronecan->xacti_gnss_status.broadcast(xacti_gnss_status_msg);
}

// handle param get/set response
bool AP_Mount_Xacti::handle_param_get_set_response_int(AP_DroneCAN* ap_dronecan, uint8_t node_id, const char* name, int32_t &value)
{
    // error string prefix to save on flash
    const char* err_prefix_str = "Xacti: failed to";

    // take picture
    if (strcmp(name, get_param_name_str(Param::SingleShot)) == 0) {
        if (value < 0) {
            GCS_SEND_TEXT(MAV_SEVERITY_ERROR, "%s take pic", err_prefix_str);
        }
        return false;
    }

    // recording
    if (strcmp(name, get_param_name_str(Param::Recording)) == 0) {
        if (value < 0) {
            _recording_video = false;
            GCS_SEND_TEXT(MAV_SEVERITY_ERROR, "%s record", err_prefix_str);
        } else {
            _recording_video = (value == 1);
            GCS_SEND_TEXT(MAV_SEVERITY_INFO, "%s recording %s", send_text_prefix, _recording_video ? "ON" : "OFF");
        }
        return false;
    }

    // focus
    if (strcmp(name, get_param_name_str(Param::FocusMode)) == 0) {
        if (value < 0) {
            GCS_SEND_TEXT(MAV_SEVERITY_ERROR, "%s change focus", err_prefix_str);
        } else {
            GCS_SEND_TEXT(MAV_SEVERITY_INFO, "%s %s focus", send_text_prefix, value == 0 ? "manual" : "auto");
        }
        return false;
    }

    // camera lens (aka sensor mode)
    if (strcmp(name, get_param_name_str(Param::SensorMode)) == 0) {
        if (value < 0) {
            GCS_SEND_TEXT(MAV_SEVERITY_ERROR, "%s change lens", err_prefix_str);
        } else if ((uint32_t)value < ARRAY_SIZE(sensor_mode_str)) {
            GCS_SEND_TEXT(MAV_SEVERITY_INFO, "%s %s", send_text_prefix, sensor_mode_str[(uint8_t)value]);
        }
        return false;
    }

    // digital zoom
    if (strcmp(name, get_param_name_str(Param::DigitalZoomMagnification)) == 0) {
        if (value < 0) {
            GCS_SEND_TEXT(MAV_SEVERITY_ERROR, "%s change zoom", err_prefix_str);
            // disable zoom rate control (if active) to avoid repeated failures
            _zoom_rate_control.enabled = false;
        } else if (value >= 100 && value <= 1000) {
            _last_digital_zoom_param_value = value;
        }
        return false;
    }

    // optical zoom
    if (strcmp(name, get_param_name_str(Param::OpticalZoomMagnification)) == 0) {
        if (value < 0) {
            GCS_SEND_TEXT(MAV_SEVERITY_ERROR, "%s change optical zoom", err_prefix_str);
            // disable zoom rate control (if active) to avoid repeated failures
            _zoom_rate_control.enabled = false;
        } else if (value >= 100 && value <= 250) {
            capabilities.optical_zoom = Capability::True;
            capabilities.received = true;
            _last_optical_zoom_param_value = value;
        }
        return false;
    }
    
    // unhandled parameter get or set
    GCS_SEND_TEXT(MAV_SEVERITY_INFO, "%s get/set %s res:%ld", send_text_prefix, name, (long int)value);
    return false;
}

// handle param get/set response
bool AP_Mount_Xacti::handle_param_get_set_response_string(AP_DroneCAN* ap_dronecan, uint8_t node_id, const char* name, AP_DroneCAN::string &value)
{
    if (strcmp(name, get_param_name_str(Param::FirmwareVersion)) == 0) {
        _firmware_version.received = true;
        const uint8_t len = MIN(value.len, ARRAY_SIZE(_firmware_version.str)-1);
        memcpy(_firmware_version.str, (const char*)value.data, len);
        GCS_SEND_TEXT(MAV_SEVERITY_INFO, "Mount: Xacti fw:%s", _firmware_version.str);

        // firmware str from gimbal is of the format YYMMDD[b]xx.  Convert to uint32 for reporting to GCS
        if (len >= 9) {
            const char major_str[3] = {_firmware_version.str[0], _firmware_version.str[1], 0};
            const char minor_str[3] = {_firmware_version.str[2], _firmware_version.str[3], 0};
            const char patch_str[3] = {_firmware_version.str[4], _firmware_version.str[5], 0};
            const char dev_str[3] = {_firmware_version.str[7], _firmware_version.str[8], 0};
            const uint8_t major_ver_num = atoi(major_str) & 0xFF;
            const uint8_t minor_ver_num = atoi(minor_str) & 0xFF;
            const uint8_t patch_ver_num = atoi(patch_str) & 0xFF;
            const uint8_t dev_ver_num = atoi(dev_str) & 0xFF;
            _firmware_version.mav_ver = UINT32_VALUE(dev_ver_num, patch_ver_num, minor_ver_num, major_ver_num);
        }
        return false;
    } else if (strcmp(name, get_param_name_str(Param::DateTime)) == 0) {
        // display when time and date have been set
        GCS_SEND_TEXT(MAV_SEVERITY_INFO, "%s datetime set %s", send_text_prefix, (const char*)value.data);
        return false;
    } else if (strcmp(name, get_param_name_str(Param::Status)) == 0) {
        // check for expected length
        const char* error_str = "error";
        if (value.len != sizeof(_status)) {
            INTERNAL_ERROR(AP_InternalError::error_t::invalid_arg_or_result);
            return false;
        }

        // backup error status and copy to structure
        const uint32_t last_error_status = _status.error_status;
        memcpy(&_status, value.data, value.len);

        // report change in status
        uint32_t changed_bits = last_error_status ^ _status.error_status;
        const char* ok_str = "OK";
        if (changed_bits & (uint32_t)ErrorStatus::TIME_NOT_SET) {
            GCS_SEND_TEXT(MAV_SEVERITY_INFO, "%s time %sset", send_text_prefix, _status.error_status & (uint32_t)ErrorStatus::TIME_NOT_SET ? "not " : "");
            if (_status.error_status & (uint32_t)ErrorStatus::TIME_NOT_SET) {
                // try to set time again
                _datetime.set = false;
            }
        }
        if (changed_bits & (uint32_t)ErrorStatus::MEDIA_ERROR) {
            GCS_SEND_TEXT(MAV_SEVERITY_INFO, "%s media %s", send_text_prefix, _status.error_status & (uint32_t)ErrorStatus::MEDIA_ERROR ? error_str : ok_str);
        }
        if (changed_bits & (uint32_t)ErrorStatus::LENS_ERROR) {
            GCS_SEND_TEXT(MAV_SEVERITY_INFO, "%s lens %s", send_text_prefix, _status.error_status & (uint32_t)ErrorStatus::LENS_ERROR ? error_str : ok_str);
        }
        if (changed_bits & (uint32_t)ErrorStatus::MOTOR_INIT_ERROR) {
            GCS_SEND_TEXT(MAV_SEVERITY_INFO, "%s motor %s", send_text_prefix, _status.error_status & (uint32_t)ErrorStatus::MOTOR_INIT_ERROR ? "init error" : ok_str);
        }
        if (changed_bits & (uint32_t)ErrorStatus::MOTOR_OPERATION_ERROR) {
            GCS_SEND_TEXT(MAV_SEVERITY_INFO, "%s motor op %s", send_text_prefix, _status.error_status & (uint32_t)ErrorStatus::MOTOR_OPERATION_ERROR ? error_str : ok_str);
        }
        if (changed_bits & (uint32_t)ErrorStatus::GIMBAL_CONTROL_ERROR) {
            GCS_SEND_TEXT(MAV_SEVERITY_INFO, "%s control %s", send_text_prefix, _status.error_status & (uint32_t)ErrorStatus::GIMBAL_CONTROL_ERROR ? error_str : ok_str);
        }
        if (changed_bits & (uint32_t)ErrorStatus::TEMP_WARNING) {
            GCS_SEND_TEXT(MAV_SEVERITY_INFO, "%s temp %s", send_text_prefix, _status.error_status & (uint32_t)ErrorStatus::TEMP_WARNING ? "warning" : ok_str);
        }

        // set motor error for health reporting
        _motor_error = _status.error_status & ((uint32_t)ErrorStatus::MOTOR_INIT_ERROR | (uint32_t)ErrorStatus::MOTOR_OPERATION_ERROR | (uint32_t)ErrorStatus::GIMBAL_CONTROL_ERROR);
        _camera_error = _status.error_status & ((uint32_t)ErrorStatus::LENS_ERROR | (uint32_t)ErrorStatus::MEDIA_ERROR);
        return false;
    }

    // unhandled parameter get or set
    GCS_SEND_TEXT(MAV_SEVERITY_INFO, "%s get/set string %s res:%s", send_text_prefix, name, (const char*)value.data);
    return false;
}

void AP_Mount_Xacti::handle_param_save_response(AP_DroneCAN* ap_dronecan, const uint8_t node_id, bool success)
{
    // display failure to save parameter
    if (!success) {
        GCS_SEND_TEXT(MAV_SEVERITY_ERROR, "%s CAM%u failed to set param", send_text_prefix, (int)_instance+1);
    }
}

// get parameter name for a particular param enum value
// returns an empty string if not found (which should never happen)
const char* AP_Mount_Xacti::get_param_name_str(Param param) const
{
    // check to avoid reading beyond end of array.  This should never happen
    if ((uint8_t)param > ARRAY_SIZE(_param_names)) {
        INTERNAL_ERROR(AP_InternalError::error_t::invalid_arg_or_result);
        return "";
    }
    return _param_names[(uint8_t)param];
}

// helper function to set integer parameters
bool AP_Mount_Xacti::set_param_int32(Param param, int32_t param_value)
{
    if (_set_param_int32_queue == nullptr) {
        return false;
    }

    // set param request added to queue to be sent.  throttling requests improves reliability
    return _set_param_int32_queue->push(SetParamQueueItem{param, param_value});
}

// helper function to set string parameters
bool AP_Mount_Xacti::set_param_string(Param param, const AP_DroneCAN::string& param_value)
{
    if (_detected_modules[_instance].ap_dronecan == nullptr) {
        return false;
    }

    // convert param to string
    const char* param_name_str = get_param_name_str(param);
    if (param_name_str == nullptr) {
        return false;
    }

    if (_detected_modules[_instance].ap_dronecan->set_parameter_on_node(_detected_modules[_instance].node_id, param_name_str, param_value, &param_string_cb)) {
        last_send_getset_param_ms = AP_HAL::millis();
        return true;
    }
    return false;
}

// helper function to get string parameters
bool AP_Mount_Xacti::get_param_string(Param param)
{
    if (_detected_modules[_instance].ap_dronecan == nullptr) {
        return false;
    }

    // convert param to string
    const char* param_name_str = get_param_name_str(param);
    if (_detected_modules[_instance].ap_dronecan->get_parameter_on_node(_detected_modules[_instance].node_id, param_name_str, &param_string_cb)) {
        last_send_getset_param_ms = AP_HAL::millis();
        return true;
    }
    return false;
}

// process queue of set parameter items
bool AP_Mount_Xacti::process_set_param_int32_queue()
{
    if ((_set_param_int32_queue == nullptr) || (_detected_modules[_instance].ap_dronecan == nullptr)) {
        return false;
    }

    SetParamQueueItem param_to_set;
    if (_set_param_int32_queue->pop(param_to_set)) {
        // convert param to string
        const char* param_name_str = get_param_name_str(param_to_set.param);
        if (_detected_modules[_instance].ap_dronecan->set_parameter_on_node(_detected_modules[_instance].node_id, param_name_str, param_to_set.value, &param_int_cb)) {
            last_send_getset_param_ms = AP_HAL::millis();
            return true;
        }
        return false;
    }
    return false;
}

// send gimbal control message via DroneCAN
// mode is 2:angle control or 3:rate control
// pitch_cd is pitch angle in centi-degrees or pitch rate in cds
// yaw_cd is angle in centi-degrees or yaw rate in cds
void AP_Mount_Xacti::send_gimbal_control(uint8_t mode, int16_t pitch_cd, int16_t yaw_cd)
{
    // exit immediately if no DroneCAN port
    if (_detected_modules[_instance].ap_dronecan == nullptr) {
        return;
    }

    // send at no faster than 5hz
    const uint32_t now_ms = AP_HAL::millis();
    if (now_ms - last_send_gimbal_control_ms < 200) {
        return;
    }
    last_send_gimbal_control_ms = now_ms;

    // send xacti specific gimbal control message
    com_xacti_GimbalControlData gimbal_control_data_msg {};
    gimbal_control_data_msg.pitch_cmd_type = mode;
    gimbal_control_data_msg.yaw_cmd_type = mode;
    gimbal_control_data_msg.pitch_cmd_value = pitch_cd;
    gimbal_control_data_msg.yaw_cmd_value = -yaw_cd;
    _detected_modules[_instance].ap_dronecan->xacti_gimbal_control_data.broadcast(gimbal_control_data_msg);
}

// send copter attitude status message to gimbal.  now_ms is current system time
// returns true if sent so that we avoid immediately trying to also send other messages
bool AP_Mount_Xacti::send_copter_att_status(uint32_t now_ms)
{
    // exit immediately if no DroneCAN port
    if (_detected_modules[_instance].ap_dronecan == nullptr) {
        return false;
    }

    // send at no faster than 5hz
    if (now_ms - last_send_copter_att_status_ms < 100) {
        return false;
    }

    // send xacti specific vehicle attitude message
    Quaternion veh_att;
    if (!AP::ahrs().get_quaternion(veh_att)) {
        return false;
    }

    last_send_copter_att_status_ms = now_ms;
    com_xacti_CopterAttStatus copter_att_status_msg {};
    copter_att_status_msg.quaternion_wxyz_e4[0] = veh_att.q1 * 1e4;
    copter_att_status_msg.quaternion_wxyz_e4[1] = veh_att.q2 * 1e4;
    copter_att_status_msg.quaternion_wxyz_e4[2] = veh_att.q3 * 1e4;
    copter_att_status_msg.quaternion_wxyz_e4[3] = veh_att.q4 * 1e4;
    copter_att_status_msg.reserved.len = 2;
    copter_att_status_msg.reserved.data[0] = 0;
    copter_att_status_msg.reserved.data[1] = 0;
    _detected_modules[_instance].ap_dronecan->xacti_copter_att_status.broadcast(copter_att_status_msg);
    return true;
}

// update zoom rate controller.  now_ms is current system time
// returns true if sent so that we avoid immediately trying to also send other messages
bool AP_Mount_Xacti::update_zoom_rate_control(uint32_t now_ms)
{
    // return immediately if zoom rate control is not enabled
    if (!_zoom_rate_control.enabled) {
        return false;
    }

    // we are controlling optical zoom if the camera has it and we are below the optical zoom upper limit
    // or at the optical zoom upper limit, the lower digital zoom limit and are zooming out
    bool optical_zoom_control = (capabilities.optical_zoom == Capability::True) &&
                                ((_last_optical_zoom_param_value < 250) ||
                                 ((_last_optical_zoom_param_value == 250) && (_last_digital_zoom_param_value == 100) && (_zoom_rate_control.dir < 0)));

    // update every 0.25 or 0.5 sec
    const uint32_t update_interval_ms = optical_zoom_control ? XACTI_OPTICAL_ZOOM_RATE_UPDATE_INTERVAL_MS : XACTI_DIGITAL_ZOOM_RATE_UPDATE_INTERVAL_MS;
    if (now_ms - _zoom_rate_control.last_update_ms < update_interval_ms) {
        return false;
    }
    _zoom_rate_control.last_update_ms = now_ms;

    // optical zoom
    if (optical_zoom_control) {
        const uint16_t optical_zoom_value = _last_optical_zoom_param_value + _zoom_rate_control.dir * 10;
        // if reached lower limit of optical zoom, disable zoom control
        if (optical_zoom_value < 100) {
            _zoom_rate_control.enabled = false;
            return false;
        }

        // send desired optical zoom to camera
        return set_param_int32(Param::OpticalZoomMagnification, MIN(optical_zoom_value, 250));
    }

    // digital zoom
    const uint16_t digital_zoom_value = _last_digital_zoom_param_value + _zoom_rate_control.dir * 100;
    // if reached limit then disable zoom
    if (((capabilities.optical_zoom != Capability::True) && (digital_zoom_value < 100)) || (digital_zoom_value > 1000)) {
        _zoom_rate_control.enabled = false;
        return false;
    }

    // send desired digital zoom to camera
    return set_param_int32(Param::DigitalZoomMagnification, digital_zoom_value);
}

// request firmware version. now_ms should be current system time (reduces calls to AP_HAL::millis)
// returns true if sent so that we avoid immediately trying to also send other messages
bool AP_Mount_Xacti::request_firmware_version(uint32_t now_ms)
{
    // return immediately if already have version or no dronecan
    if (_firmware_version.received) {
        return false;
    }

    // send request once per second until received
    if (now_ms - _firmware_version.last_request_ms < 1000) {
        return false;
    }
    _firmware_version.last_request_ms = now_ms;
    return get_param_string(Param::FirmwareVersion);
}

// request parameters used to determine camera capabilities.  now_ms is current system time
// returns true if a param get/set was sent so that we avoid sending other messages
bool AP_Mount_Xacti::request_capabilities(uint32_t now_ms)
{
    // return immediately if we have already determined this models capabilities
    if (capabilities.received) {
        return false;
    }

    // send requests once per second until received
    if (now_ms - capabilities.last_request_ms < 1000) {
        return false;
    }
    capabilities.last_request_ms = now_ms;

    // record start time
    if (capabilities.first_request_ms == 0) {
        capabilities.first_request_ms = now_ms;
    }

    // timeout after 10 seconds
    if (now_ms - capabilities.first_request_ms > 10000) {
        capabilities.optical_zoom = Capability::False;
        capabilities.received = true;
        return false;
    }

    // optical zoom: try setting optical zoom to 1x
    // return is handled in handle_param_get_set_response_int
    return set_param_int32(Param::OpticalZoomMagnification, 100);
}

// set date and time.  now_ms is current system time
bool AP_Mount_Xacti::set_datetime(uint32_t now_ms)
{
    // return immediately if gimbal's date/time has been set
    if (_datetime.set) {
        return false;
    }

    // attempt to set datetime once per second until received
    if (now_ms - _datetime.last_request_ms < 1000) {
        return false;
    }
    _datetime.last_request_ms = now_ms;

    // get date and time
    uint16_t year, ms;
    uint8_t month, day, hour, min, sec;
#if AP_RTC_ENABLED
    if (!AP::rtc().get_date_and_time_utc(year, month, day, hour, min, sec, ms)) {
        return false;
    }
#else
    (void)ms;
    return false;
#endif

    // date time is of the format YYYYMMDDHHMMSS (14 bytes)
    // convert month from 0~11 to 1~12 range
    AP_DroneCAN::string datetime_string {};
    const int num_bytes = snprintf((char *)datetime_string.data, sizeof(AP_DroneCAN::string::data), "%04u%02u%02u%02u%02u%02u",
                             (unsigned)year, (unsigned)month+1, (unsigned)day, (unsigned)hour, (unsigned)min, (unsigned)sec);
    // sanity check bytes to be sent
    if (num_bytes != 14) {
        INTERNAL_ERROR(AP_InternalError::error_t::invalid_arg_or_result);
        return false;
    }
    datetime_string.len = num_bytes;
    _datetime.set = set_param_string(Param::DateTime, datetime_string);
    if (!_datetime.set) {
        GCS_SEND_TEXT(MAV_SEVERITY_ERROR, "%s failed to set date/time", send_text_prefix);
    }

    return _datetime.set;
}

// request status. now_ms should be current system time (reduces calls to AP_HAL::millis)
// returns true if sent so that we avoid immediately trying to also send other messages
bool AP_Mount_Xacti::request_status(uint32_t now_ms)
{
    // return immediately if 3 seconds has not passed
    if (now_ms - _status_report.last_request_ms < XACTI_STATUS_REQ_INTERVAL_MS) {
        return false;
    }

    _status_report.last_request_ms = now_ms;
    return get_param_string(Param::Status);
}

// check if safe to send message (if messages sent too often camera will not respond)
// now_ms should be current system time (reduces calls to AP_HAL::millis)
bool AP_Mount_Xacti::is_safe_to_send(uint32_t now_ms) const
{
    // check time since last attitude sent
    if (now_ms - last_send_copter_att_status_ms < XACTI_MSG_SEND_MIN_MS) {
        return false;
    }

    // check time since last angle target sent
    if (now_ms - last_send_gimbal_control_ms < XACTI_MSG_SEND_MIN_MS) {
        return false;
    }

    // check time since last set param message sent
    if (now_ms - last_send_getset_param_ms < XACTI_MSG_SEND_MIN_MS) {
        return false;
    }

    return true;
}

#endif // HAL_MOUNT_XACTI_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         /*
  DroneCAN gimbal driver

  Implements gimbal control and attitude feedback using the DroneCAN / DSDL / com / xacti messages
  see https://github.com/dronecan/DSDL/tree/master/com/xacti

 */

#pragma once

#include "AP_Mount_Backend.h"

#if HAL_MOUNT_XACTI_ENABLED

#include <AP_HAL/AP_HAL.h>
#include <AP_Math/AP_Math.h>
#include <AP_Common/AP_Common.h>
#include <AP_DroneCAN/AP_DroneCAN.h>
#include <AP_HAL/utility/RingBuffer.h>
#include "AP_Mount.h"

class AP_Mount_Xacti : public AP_Mount_Backend
{

public:
    // Constructor
    AP_Mount_Xacti(class AP_Mount &frontend, class AP_Mount_Params &params, uint8_t instance);

    /* Do not allow copies */
    CLASS_NO_COPY(AP_Mount_Xacti);

    // init - performs any required initialisation for this instance
    void init() override;

    // update mount position - should be called periodically
    void update() override;

    // return true if healthy
    bool healthy() const override;

    // has_pan_control - returns true if this mount can control its pan (required for multicopters)
    bool has_pan_control() const override { return yaw_range_valid(); };

    //
    // camera controls
    //

    // take a picture.  returns true on success
    bool take_picture() override;

    // start or stop video recording
    // set start_recording = true to start record, false to stop recording
    bool record_video(bool start_recording) override;

    // set zoom specified as a rate or percentage
    bool set_zoom(ZoomType zoom_type, float zoom_value) override;

    // set focus specified as rate, percentage or auto
    // focus in = -1, focus hold = 0, focus out = 1
    SetFocusResult set_focus(FocusType focus_type, float focus_value) override;

    // set camera lens as a value from 0 to 5
    bool set_lens(uint8_t lens) override;

    // set_camera_source is functionally the same as set_lens except primary and secondary lenses are specified by type
    // primary and secondary sources use the AP_Camera::CameraSource enum cast to uint8_t
    bool set_camera_source(uint8_t primary_source, uint8_t secondary_source) override;

    // send camera information message to GCS
    void send_camera_information(mavlink_channel_t chan) const override;

    // send camera settings message to GCS
    void send_camera_settings(mavlink_channel_t chan) const override;

    // subscribe to Xacti DroneCAN messages
    static void subscribe_msgs(AP_DroneCAN* ap_dronecan);

    // xacti specific message handlers
    static void handle_gimbal_attitude_status(AP_DroneCAN* ap_dronecan, const CanardRxTransfer& transfer, const com_xacti_GimbalAttitudeStatus &msg);
    static void handle_gnss_status_req(AP_DroneCAN* ap_dronecan, const CanardRxTransfer& transfer, const com_xacti_GnssStatusReq &msg);

protected:

    // get attitude as a quaternion.  returns true on success
    bool get_attitude_quaternion(Quaternion& att_quat) override;

private:

    // send text prefix string to reduce flash cost
    static const char* send_text_prefix;

    // Sensor mode enumeration (aka lens)
    enum class SensorsMode : uint8_t {
        RGB = 0,    // RGB (aka "visible)")
        IR = 1,     // Infrared, aka thermal
        PIP = 2,    // RGB with IR PIP
        NDVI = 3,   // NDVI (vegetation greenness)
    };
    // array of sensor mode enumeration strings for display to user
    // if enum above is updated, also update sensor_mode_str definition in cpp
    static const char* sensor_mode_str[];

    // send target pitch and yaw rates to gimbal
    // yaw_is_ef should be true if yaw_rads target is an earth frame rate, false if body_frame
    void send_target_rates(float pitch_rads, float yaw_rads, bool yaw_is_ef);

    // send target pitch and yaw angles to gimbal
    // yaw_is_ef should be true if yaw_rad target is an earth frame angle, false if body_frame
    void send_target_angles(float pitch_rad, float yaw_rad, bool yaw_is_ef);

    // register backend in detected modules array used to map DroneCAN port and node id to backend
    void register_backend();

    // find backend associated with the given dronecan port and node_id.  also associates backends with zero node ids
    // returns pointer to backend on success, nullptr on failure
    static AP_Mount_Xacti* get_dronecan_backend(AP_DroneCAN* ap_dronecan, uint8_t node_id);

    // DroneCAN parameter handling methods
    FUNCTOR_DECLARE(param_int_cb, bool, AP_DroneCAN*, const uint8_t, const char*, int32_t &);
    FUNCTOR_DECLARE(param_string_cb, bool, AP_DroneCAN*, const uint8_t, const char*, AP_DroneCAN::string &);
    FUNCTOR_DECLARE(param_save_cb, void, AP_DroneCAN*, const uint8_t, bool);
    bool handle_param_get_set_response_int(AP_DroneCAN* ap_dronecan, const uint8_t node_id, const char* name, int32_t &value);
    bool handle_param_get_set_response_string(AP_DroneCAN* ap_dronecan, const uint8_t node_id, const char* name, AP_DroneCAN::string &value);
    void handle_param_save_response(AP_DroneCAN* ap_dronecan, const uint8_t node_id, bool success);

    // param enum.  If enum is updated also update _param_names definition in cpp
    enum class Param : uint8_t {
        SingleShot = 0,
        Recording,
        FocusMode,
        SensorMode,
        DigitalZoomMagnification,
        FirmwareVersion,
        Status,
        DateTime,
        OpticalZoomMagnification,
        LAST = OpticalZoomMagnification,            // this should be equal to the final parameter enum
    };
    static const char* _param_names[];              // array of Xacti parameter strings

    // get parameter name for a particular param enum value
    // returns an empty string if not found (which should never happen)
    const char* get_param_name_str(Param param) const;

    // helper function to get and set parameters
    bool set_param_int32(Param param, int32_t param_value);
    bool set_param_string(Param param, const AP_DroneCAN::string& param_value);
    bool get_param_string(Param param);

    // process queue of set parameter items. returns true if set-parameter message was sent
    bool process_set_param_int32_queue();

    // send gimbal control message via DroneCAN
    // mode is 2:angle control or 3:rate control
    // pitch_cd is pitch angle in centi-degrees or pitch rate in cds
    // yaw_cd is angle in centi-degrees or yaw rate in cds
    void send_gimbal_control(uint8_t mode, int16_t pitch_cd, int16_t yaw_cd);

    // send vehicle attitude to gimbal via DroneCAN.  now_ms is current system time
    // returns true if sent so that we avoid immediately trying to also send other messages
    bool send_copter_att_status(uint32_t now_ms);

    // update zoom rate controller.  now_ms is current system time
    // returns true if sent so that we avoid immediately trying to also send other messages
    bool update_zoom_rate_control(uint32_t now_ms);

    // request firmware version.  now_ms is current system time
    // returns true if sent so that we avoid immediately trying to also send other messages
    bool request_firmware_version(uint32_t now_ms);

    // request parameters used to determine camera capabilities.  now_ms is current system time
    // returns true if a param get/set was sent so that we avoid sending other messages
    bool request_capabilities(uint32_t now_ms);

    // set date and time.  now_ms is current system time
    bool set_datetime(uint32_t now_ms);

    // request status.  now_ms is current system time
    // returns true if sent so that we avoid immediately trying to also send other messages
    bool request_status(uint32_t now_ms);

    // check if safe to send message (if messages sent too often camera will not respond)
    // now_ms is current system time
    bool is_safe_to_send(uint32_t now_ms) const;

    // internal variables
    bool _initialised;                              // true once the driver has been initialised

    // attitude received from gimbal
    Quaternion _current_attitude_quat;              // current attitude as a quaternion
    uint32_t _last_current_attitude_quat_ms;        // system time _current_angle_rad was updated
    bool _recording_video;                          // true if recording video
    uint16_t _last_digital_zoom_param_value = 100;  // last digital zoom parameter value sent to camera.  100 ~ 1000 (interval 100)
    uint16_t _last_optical_zoom_param_value = 100;  // last optical zoom parameter value sent to camera.  100 ~ 250 (interval 10)
    struct {
        bool enabled;                               // true if zoom rate control is enabled
        int8_t dir;                                 // zoom direction (-1 to zoom out, +1 to zoom in)
        uint32_t last_update_ms;                    // system time that zoom rate control last updated zoom
    } _zoom_rate_control;

    // firmware version received from gimbal
    struct {
        uint32_t last_request_ms;                   // system time of last request for firmware version
        bool received;                              // true once firmware version has been received
        char str[12] {};                            // firmware version string (11 bytes + 1 null byte)
        uint32_t mav_ver;                           // version formatted for reporting to GCS via CAMERA_INFORMATION message
    } _firmware_version;

    // date and time handling
    struct {
        uint32_t last_request_ms;                   // system time that date/time was last requested
        bool set;                                   // true once date/time has been set
    } _datetime;

    // capability handling
    enum class Capability : uint8_t {
        False = 0,
        True = 1,
        Unknown = 2,
    };
    struct {
        bool received;                              // true if we have determined cameras capabilities
        uint32_t first_request_ms;                  // system time of first request for capabilities (used to timeout)
        uint32_t last_request_ms;                   // system time of last capability related parameter check
        Capability optical_zoom;                    // Yes if camera has optical zoom
    } capabilities = {false, 0, 0, Capability::Unknown};

    // gimbal status handling
    enum class ErrorStatus : uint32_t {
        TAKING_PICTURE = 0x04,                      // currently taking a picture
        RECORDING_VIDEO = 0x08,                     // currently recording video
        CANNOT_TAKE_PIC = 0x20,
        TIME_NOT_SET = 0x10000,
        MEDIA_ERROR = 0x20000,
        LENS_ERROR = 0x40000,
        MOTOR_INIT_ERROR = 0x100000,
        MOTOR_OPERATION_ERROR = 0x200000,
        GIMBAL_CONTROL_ERROR = 0x400000,
        TEMP_WARNING = 0x1000000
    };
    struct {
        uint32_t error_status;                      // see ErrorStatus enum
        uint32_t video_remain_time;                 // max seconds of video that may be recorded before SD card is full
        uint32_t photo_remain_count;                // max number of pics before SD card is full
        uint32_t sd_card_size_mb;                   // SD card size in MB
        uint32_t sd_card_free_mb;                   // SD card remaining size in MB
        uint16_t body;                              // body type
        uint16_t cmos;                              // cmos type
        uint16_t gimbal_pitch;                      // gimbal pitch angle
        uint16_t gimbal_roll;                       // gimbal roll angle
        uint16_t gimbal_yaw;                        // gimbal yaw angle
        uint16_t reserved1;
        uint8_t date_time[7];                       // camera's date and time
        uint8_t reserved2;
        uint32_t exposure_time_us;                  // camera's exposure time in us
        uint16_t apeture;                           // cameras' aperture * 100
        uint16_t iso_sensitivity;                   // camera's iso sensitivity
    } _status;                                      // latest status received
    static_assert(sizeof(_status) == 48, "status must be 48 bytes");           // status should be 48 bytes
    struct {
        uint32_t last_request_ms;                   // system time that status was last requested
        uint32_t last_error_status;                 // last error status reported to user
    } _status_report;
    bool _motor_error;                              // true if status reports motor or control error (used for health reporting)
    bool _camera_error;                             // true if status reports camera error

    // DroneCAN related variables
    static bool _subscribed;                        // true once subscribed to receive DroneCAN messages
    static struct DetectedModules {
        AP_Mount_Xacti *driver;                     // pointer to Xacti backends
        AP_DroneCAN* ap_dronecan;                   // DroneCAN interface used by this backend
        uint8_t node_id;                            // DroneCAN node id associated by this backend
    } _detected_modules[AP_MOUNT_MAX_INSTANCES];
    static HAL_Semaphore _sem_registry;             // semaphore protecting access to _detected_modules table
    uint32_t last_send_gimbal_control_ms;           // system time that send_gimbal_control was last called (used to slow down sends to 5hz)
    uint32_t last_send_copter_att_status_ms;        // system time that send_copter_att_status was last called (used to slow down sends to 10hz)
    uint32_t last_send_getset_param_ms;             // system time that a get or set parameter message was sent

    // queue of set parameter int32 items.  set-parameter requests to camera are throttled to improve reliability
    struct SetParamQueueItem {
        Param param;                                // parameter (name)
        int32_t value;                              // parameter value
    };
    ObjectArray<SetParamQueueItem> *_set_param_int32_queue; // queue of set-parameter items
};

#endif // HAL_MOUNT_XACTI_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              #pragma once

#include <AP_HAL/AP_HAL_Boards.h>
#include <AP_Terrain/AP_Terrain.h>

#ifndef HAL_MOUNT_ENABLED
#define HAL_MOUNT_ENABLED 1
#endif

#ifndef AP_MOUNT_BACKEND_DEFAULT_ENABLED
#define AP_MOUNT_BACKEND_DEFAULT_ENABLED HAL_MOUNT_ENABLED
#endif

#ifndef HAL_MOUNT_ALEXMOS_ENABLED
#define HAL_MOUNT_ALEXMOS_ENABLED AP_MOUNT_BACKEND_DEFAULT_ENABLED
#endif

#ifndef HAL_MOUNT_GREMSY_ENABLED
#define HAL_MOUNT_GREMSY_ENABLED AP_MOUNT_BACKEND_DEFAULT_ENABLED && HAL_GCS_ENABLED && BOARD_FLASH_SIZE > 1024
#endif

#ifndef HAL_MOUNT_SCRIPTING_ENABLED
#define HAL_MOUNT_SCRIPTING_ENABLED AP_MOUNT_BACKEND_DEFAULT_ENABLED && AP_SCRIPTING_ENABLED
#endif

#ifndef HAL_MOUNT_SERVO_ENABLED
#define HAL_MOUNT_SERVO_ENABLED AP_MOUNT_BACKEND_DEFAULT_ENABLED
#endif

#ifndef HAL_MOUNT_SIYI_ENABLED
#define HAL_MOUNT_SIYI_ENABLED AP_MOUNT_BACKEND_DEFAULT_ENABLED
#endif

// solo gimbal is enabled explicitly in hwdefs on some Cubes:
#ifndef HAL_SOLO_GIMBAL_ENABLED
#define HAL_SOLO_GIMBAL_ENABLED 0
#endif

#ifndef HAL_MOUNT_STORM32MAVLINK_ENABLED
#define HAL_MOUNT_STORM32MAVLINK_ENABLED AP_MOUNT_BACKEND_DEFAULT_ENABLED && HAL_GCS_ENABLED
#endif

#ifndef HAL_MOUNT_STORM32SERIAL_ENABLED
#define HAL_MOUNT_STORM32SERIAL_ENABLED AP_MOUNT_BACKEND_DEFAULT_ENABLED
#endif

#ifndef HAL_MOUNT_XACTI_ENABLED
#define HAL_MOUNT_XACTI_ENABLED AP_MOUNT_BACKEND_DEFAULT_ENABLED && HAL_ENABLE_DRONECAN_DRIVERS && BOARD_FLASH_SIZE > 1024
#endif

#ifndef HAL_MOUNT_VIEWPRO_ENABLED
#define HAL_MOUNT_VIEWPRO_ENABLED AP_MOUNT_BACKEND_DEFAULT_ENABLED && BOARD_FLASH_SIZE > 1024
#endif

#ifndef AP_MOUNT_POI_TO_LATLONALT_ENABLED
#define AP_MOUNT_POI_TO_LATLONALT_ENABLED HAL_MOUNT_ENABLED && AP_TERRAIN_AVAILABLE && BOARD_FLASH_SIZE > 1024
#endif

#ifndef HAL_MOUNT_TOPOTEK_ENABLED
#define HAL_MOUNT_TOPOTEK_ENABLED AP_MOUNT_BACKEND_DEFAULT_ENABLED
#endif

// set camera source is supported on gimbals that may have more than one lens
#ifndef HAL_MOUNT_SET_CAMERA_SOURCE_ENABLED
#define HAL_MOUNT_SET_CAMERA_SOURCE_ENABLED HAL_MOUNT_SIYI_ENABLED || HAL_MOUNT_XACTI_ENABLED || HAL_MOUNT_VIEWPRO_ENABLED
#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               #pragma once

#include <AP_Logger/LogStructure.h>

#define LOG_IDS_FROM_MOUNT \
    LOG_MOUNT_MSG

// @LoggerMessage: MNT
// @Description: Mount's desired and actual roll, pitch and yaw angles
// @Field: TimeUS: Time since system startup
// @Field: I: Instance number
// @Field: DRoll: Desired roll
// @Field: Roll: Actual roll
// @Field: DPitch: Desired pitch
// @Field: Pitch: Actual pitch
// @Field: DYawB: Desired yaw in body frame
// @Field: YawB: Actual yaw in body frame
// @Field: DYawE: Desired yaw in earth frame
// @Field: YawE: Actual yaw in earth frame
// @Field: Dist: Rangefinder distance

struct PACKED log_Mount {
    LOG_PACKET_HEADER;
    uint64_t time_us;
    uint8_t  instance;
    float    desired_roll;
    float    actual_roll;
    float    desired_pitch;
    float    actual_pitch;
    float    desired_yaw_bf;
    float    actual_yaw_bf;
    float    desired_yaw_ef;
    float    actual_yaw_ef;
    float    rangefinder_dist;
};

#define LOG_STRUCTURE_FROM_MOUNT \
    { LOG_MOUNT_MSG, sizeof(log_Mount), \
      "MNT", "QBfffffffff","TimeUS,I,DRoll,Roll,DPitch,Pitch,DYawB,YawB,DYawE,YawE,Dist", "s#ddddddddm", "F---------0" },

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            #include <AP_HAL/AP_HAL.h>
#include <AP_AHRS/AP_AHRS.h>
#include "SoloGimbal.h"

#if HAL_SOLO_GIMBAL_ENABLED

#include <stdio.h>
#include <GCS_MAVLink/GCS.h>
#include <AP_Logger/AP_Logger.h>

extern const AP_HAL::HAL& hal;

bool SoloGimbal::present()
{
    if (_state != GIMBAL_STATE_NOT_PRESENT && AP_HAL::millis()-_last_report_msg_ms > 3000) {
        // gimbal went away
        _state = GIMBAL_STATE_NOT_PRESENT;
        return false;
    }

    return _state != GIMBAL_STATE_NOT_PRESENT;
}

bool SoloGimbal::aligned()
{
    return present() && _state == GIMBAL_STATE_PRESENT_RUNNING;
}

gimbal_mode_t SoloGimbal::get_mode()
{
    const auto &_ahrs = AP::ahrs();

    if ((_gimbalParams.initialized() && is_zero(_gimbalParams.get_K_rate())) || (_ahrs.get_rotation_body_to_ned().c.z < 0 && !(_lockedToBody || _calibrator.running()))) {
        return GIMBAL_MODE_IDLE;
    } else if (!_ekf.getStatus()) {
        return GIMBAL_MODE_POS_HOLD;
    } else if (_calibrator.running() || _lockedToBody) {
        return GIMBAL_MODE_POS_HOLD_FF;
    } else {
        return GIMBAL_MODE_STABILIZE;
    }
}

void SoloGimbal::receive_feedback(mavlink_channel_t chan, const mavlink_message_t &msg)
{
    mavlink_gimbal_report_t report_msg;
    mavlink_msg_gimbal_report_decode(&msg, &report_msg);
    uint32_t tnow_ms = AP_HAL::millis();
    _last_report_msg_ms = tnow_ms;

    _gimbalParams.set_channel(chan);

    if (report_msg.target_system != 1) {
        _state = GIMBAL_STATE_NOT_PRESENT;
    } else {
        GCS_MAVLINK::set_channel_private(chan);
    }

    switch(_state) {
        case GIMBAL_STATE_NOT_PRESENT:
            // gimbal was just connected or we just rebooted, transition to PRESENT_INITIALIZING
            _gimbalParams.reset();
            _gimbalParams.set_param(GMB_PARAM_GMB_SYSID, 1);
            _state = GIMBAL_STATE_PRESENT_INITIALIZING;
            break;

        case GIMBAL_STATE_PRESENT_INITIALIZING:
            _gimbalParams.update();
            if (_gimbalParams.initialized()) {
                // parameters done initializing, finalize initialization and transition to aligning
                extract_feedback(report_msg);
                _ang_vel_mag_filt = 20;
                _filtered_joint_angles = _measurement.joint_angles;
                _vehicle_to_gimbal_quat_filt.from_vector312(_filtered_joint_angles.x,_filtered_joint_angles.y,_filtered_joint_angles.z);
                _ekf.reset();
                _state = GIMBAL_STATE_PRESENT_ALIGNING;
            }
            break;

        case GIMBAL_STATE_PRESENT_ALIGNING:
            _gimbalParams.update();
            extract_feedback(report_msg);
            update_estimators();
            if (_ekf.getStatus()) {
                // EKF done aligning, transition to running
                _state = GIMBAL_STATE_PRESENT_RUNNING;
            }
            break;

        case GIMBAL_STATE_PRESENT_RUNNING:
            _gimbalParams.update();
            extract_feedback(report_msg);
            update_estimators();
            break;
    }

    send_controls(chan);
}

void SoloGimbal::send_controls(mavlink_channel_t chan)
{
    if (_state == GIMBAL_STATE_PRESENT_RUNNING) {
        // get the gimbal quaternion estimate
        Quaternion quatEst;
        _ekf.getQuat(quatEst);

        // run rate controller
        _ang_vel_dem_rads.zero();
        switch(get_mode()) {
            case GIMBAL_MODE_POS_HOLD_FF: {
                _ang_vel_dem_rads += get_ang_vel_dem_body_lock();
                _ang_vel_dem_rads += get_ang_vel_dem_gyro_bias();
                float _ang_vel_dem_radsLen = _ang_vel_dem_rads.length();
                if (_ang_vel_dem_radsLen > radians(400)) {
                    _ang_vel_dem_rads *= radians(400)/_ang_vel_dem_radsLen;
                }
                if (HAVE_PAYLOAD_SPACE(chan, GIMBAL_CONTROL)) {
                    mavlink_msg_gimbal_control_send(chan, mavlink_system.sysid, _compid,
                                                    _ang_vel_dem_rads.x, _ang_vel_dem_rads.y, _ang_vel_dem_rads.z);
                }
                break;
            }
            case GIMBAL_MODE_STABILIZE: {
                _ang_vel_dem_rads += get_ang_vel_dem_yaw(quatEst);
                _ang_vel_dem_rads += get_ang_vel_dem_roll_tilt(quatEst);
                _ang_vel_dem_rads += get_ang_vel_dem_feedforward(quatEst);
                _ang_vel_dem_rads += get_ang_vel_dem_gyro_bias();
                float ang_vel_dem_norm = _ang_vel_dem_rads.length();
                if (ang_vel_dem_norm > radians(400)) {
                    _ang_vel_dem_rads *= radians(400)/ang_vel_dem_norm;
                }
                if (HAVE_PAYLOAD_SPACE(chan, GIMBAL_CONTROL)) {
                    mavlink_msg_gimbal_control_send(chan, mavlink_system.sysid, _compid,
                                                    _ang_vel_dem_rads.x, _ang_vel_dem_rads.y, _ang_vel_dem_rads.z);
                }
                break;
            }
            default:
            case GIMBAL_MODE_IDLE:
            case GIMBAL_MODE_POS_HOLD:
                break;
        }
    }

    // set GMB_POS_HOLD
    if (get_mode() == GIMBAL_MODE_POS_HOLD) {
        _gimbalParams.set_param(GMB_PARAM_GMB_POS_HOLD, 1);
    } else {
        _gimbalParams.set_param(GMB_PARAM_GMB_POS_HOLD, 0);
    }

    // set GMB_MAX_TORQUE
    float max_torque;
    _gimbalParams.get_param(GMB_PARAM_GMB_MAX_TORQUE, max_torque, 0);
    if (!is_equal(max_torque,_max_torque) && !is_zero(max_torque)) {
        _max_torque = max_torque;
    }

    if (!hal.util->get_soft_armed() || joints_near_limits()) {
        _gimbalParams.set_param(GMB_PARAM_GMB_MAX_TORQUE, _max_torque);
    } else {
        _gimbalParams.set_param(GMB_PARAM_GMB_MAX_TORQUE, 0);
    }
}

void SoloGimbal::extract_feedback(const mavlink_gimbal_report_t& report_msg)
{
    _measurement.delta_time = report_msg.delta_time;
    _measurement.delta_angles.x = report_msg.delta_angle_x;
    _measurement.delta_angles.y = report_msg.delta_angle_y;
    _measurement.delta_angles.z = report_msg.delta_angle_z;
    _measurement.delta_velocity.x = report_msg.delta_velocity_x,
    _measurement.delta_velocity.y = report_msg.delta_velocity_y;
    _measurement.delta_velocity.z = report_msg.delta_velocity_z;
    _measurement.joint_angles.x = report_msg.joint_roll;
    _measurement.joint_angles.y = report_msg.joint_el;
    _measurement.joint_angles.z = report_msg.joint_az;

    if (_calibrator.get_status() == ACCEL_CAL_COLLECTING_SAMPLE) {
        _calibrator.new_sample(_measurement.delta_velocity,_measurement.delta_time);
    }

    _measurement.delta_angles -= _gimbalParams.get_gyro_bias() * _measurement.delta_time;
    _measurement.joint_angles -= _gimbalParams.get_joint_bias();
    _measurement.delta_velocity -= _gimbalParams.get_accel_bias() * _measurement.delta_time;
    Vector3f accel_gain = _gimbalParams.get_accel_gain();
    _measurement.delta_velocity.x *= (is_zero(accel_gain.x) ? 1.0f : accel_gain.x);
    _measurement.delta_velocity.y *= (is_zero(accel_gain.y) ? 1.0f : accel_gain.y);
    _measurement.delta_velocity.z *= (is_zero(accel_gain.z) ? 1.0f : accel_gain.z);

    // update _ang_vel_mag_filt, used for accel sample readiness
    Vector3f ang_vel = _measurement.delta_angles / _measurement.delta_time;
    Vector3f ekf_gyro_bias;
    _ekf.getGyroBias(ekf_gyro_bias);
    ang_vel -= ekf_gyro_bias;
    float alpha = constrain_float(_measurement.delta_time/(_measurement.delta_time+0.5f),0.0f,1.0f);
    _ang_vel_mag_filt += (ang_vel.length()-_ang_vel_mag_filt)*alpha;
    _ang_vel_mag_filt = MIN(_ang_vel_mag_filt,20.0f);

    // get complementary filter inputs
    _vehicle_to_gimbal_quat.from_vector312(_measurement.joint_angles.x,_measurement.joint_angles.y,_measurement.joint_angles.z);

    // update log deltas
    _log_dt += _measurement.delta_time;
    _log_del_ang += _measurement.delta_angles;
    _log_del_vel += _measurement.delta_velocity;
}

void SoloGimbal::update_estimators()
{
    if (_state == GIMBAL_STATE_NOT_PRESENT || _state == GIMBAL_STATE_PRESENT_INITIALIZING) {
        return;
    }

    // Run the gimbal attitude and gyro bias estimator
    _ekf.RunEKF(_measurement.delta_time, _measurement.delta_angles, _measurement.delta_velocity, _measurement.joint_angles);
    update_joint_angle_est();
}

void SoloGimbal::readVehicleDeltaAngle(uint8_t ins_index, Vector3f &dAng) {
    const AP_InertialSensor &ins = AP::ins();

    if (ins_index < ins.get_gyro_count()) {
        float dAng_dt;
        if (!ins.get_delta_angle(ins_index,dAng, dAng_dt)) {
            dAng = ins.get_gyro(ins_index) / ins.get_loop_rate_hz();
        }
    }
}

void SoloGimbal::update_fast() {
    const AP_InertialSensor &ins = AP::ins();

#if INS_MAX_INSTANCES > 1
    if (ins.use_gyro(0) && ins.use_gyro(1)) {
        // dual gyro mode - average first two gyros
        Vector3f dAng;
        readVehicleDeltaAngle(0, dAng);
        _vehicle_delta_angles += dAng*0.5f;
        readVehicleDeltaAngle(1, dAng);
        _vehicle_delta_angles += dAng*0.5f;
    } else
#endif
    {
        // single gyro mode - one of the first two gyros are unhealthy or don't exist
        // just read primary gyro
        Vector3f dAng;
        readVehicleDeltaAngle(ins.get_first_usable_gyro(), dAng);
        _vehicle_delta_angles += dAng;
    }
}

void SoloGimbal::update_joint_angle_est()
{
    static const float tc = 1.0f;
    float dt = _measurement.delta_time;
    float alpha = constrain_float(dt/(dt+tc),0.0f,1.0f);

    Matrix3f Tvg; // vehicle frame to gimbal frame
    _vehicle_to_gimbal_quat.inverse().rotation_matrix(Tvg);

    Vector3f delta_angle_bias;
    _ekf.getGyroBias(delta_angle_bias);
    delta_angle_bias *= dt;

    Vector3f joint_del_ang;
    gimbal_ang_vel_to_joint_rates((_measurement.delta_angles-delta_angle_bias) - Tvg*_vehicle_delta_angles, joint_del_ang);

    _filtered_joint_angles += joint_del_ang;
    _filtered_joint_angles += (_measurement.joint_angles-_filtered_joint_angles)*alpha;

    _vehicle_to_gimbal_quat_filt.from_vector312(_filtered_joint_angles.x,_filtered_joint_angles.y,_filtered_joint_angles.z);

    _vehicle_delta_angles.zero();
}

Vector3f SoloGimbal::get_ang_vel_dem_yaw(const Quaternion &quatEst)
{
    static const float tc = 0.1f;
    static const float yawErrorLimit = radians(5.7f);
    float dt = _measurement.delta_time;
    float alpha = dt/(dt+tc);

    const auto &_ahrs = AP::ahrs();
    Matrix3f Tve = _ahrs.get_rotation_body_to_ned();
    Matrix3f Teg;
    quatEst.inverse().rotation_matrix(Teg);


    //_vehicle_yaw_rate_ef_filt = _ahrs.get_yaw_rate_earth();

    // filter the vehicle yaw rate to remove noise
    _vehicle_yaw_rate_ef_filt += (_ahrs.get_yaw_rate_earth() - _vehicle_yaw_rate_ef_filt) * alpha;

    float yaw_rate_ff = 0;

    // calculate an earth-frame yaw rate feed-forward that prevents gimbal from exceeding the maximum yaw error
    if (_vehicle_yaw_rate_ef_filt > _gimbalParams.get_K_rate()*yawErrorLimit) {
        yaw_rate_ff = _vehicle_yaw_rate_ef_filt-_gimbalParams.get_K_rate()*yawErrorLimit;
    } else if (_vehicle_yaw_rate_ef_filt < -_gimbalParams.get_K_rate()*yawErrorLimit) {
        yaw_rate_ff = _vehicle_yaw_rate_ef_filt+_gimbalParams.get_K_rate()*yawErrorLimit;
    }

    // filter the feed-forward to remove noise
    //_yaw_rate_ff_ef_filt += (yaw_rate_ff - _yaw_rate_ff_ef_filt) * alpha;

    Vector3f gimbalRateDemVecYaw;
    gimbalRateDemVecYaw.z = yaw_rate_ff - _gimbalParams.get_K_rate() * _filtered_joint_angles.z / constrain_float(Tve.c.z,0.5f,1.0f);
    gimbalRateDemVecYaw.z /= constrain_float(Tve.c.z,0.5f,1.0f);

    // rotate the rate demand into gimbal frame
    gimbalRateDemVecYaw = Teg * gimbalRateDemVecYaw;

    return gimbalRateDemVecYaw;
}

Vector3f SoloGimbal::get_ang_vel_dem_roll_tilt(const Quaternion &quatEst)
{
    // Calculate the gimbal 321 Euler angle estimates relative to earth frame
    Vector3f eulerEst = quatEst.to_vector312();

    // Calculate a demanded quaternion using the demanded roll and pitch and estimated yaw (yaw is slaved to the vehicle)
    Quaternion quatDem;
    quatDem.from_vector312( _att_target_euler_rad.x,
                            _att_target_euler_rad.y,
                            eulerEst.z);

    //divide the demanded quaternion by the estimated to get the error
    Quaternion quatErr = quatDem / quatEst;

    // Convert to a delta rotation
    quatErr.normalize();
    Vector3f deltaAngErr;
    quatErr.to_axis_angle(deltaAngErr);

    // multiply the angle error vector by a gain to calculate a demanded gimbal rate required to control tilt
    Vector3f gimbalRateDemVecTilt = deltaAngErr * _gimbalParams.get_K_rate();
    return gimbalRateDemVecTilt;
}

Vector3f SoloGimbal::get_ang_vel_dem_feedforward(const Quaternion &quatEst) const
{
    // quaternion demanded at the previous time step
    static float lastDemY;

    // calculate the delta rotation from the last to the current demand where the demand does not incorporate the copters yaw rotation
    float deltaY = _att_target_euler_rad.y - lastDemY;
    lastDemY = _att_target_euler_rad.y;

    // quaternion demanded at the previous time step
    static float lastDemX;

    // calculate the delta rotation from the last to the current demand where the demand does not incorporate the copters yaw rotation
    float deltaX = _att_target_euler_rad.x - lastDemX;
    lastDemX = _att_target_euler_rad.x;

    Vector3f gimbalRateDemVecForward;
    gimbalRateDemVecForward.x = deltaX / _measurement.delta_time;
    gimbalRateDemVecForward.y = deltaY / _measurement.delta_time;
    return gimbalRateDemVecForward;
}

Vector3f SoloGimbal::get_ang_vel_dem_gyro_bias()
{
    Vector3f gyroBias;
    _ekf.getGyroBias(gyroBias);
    return gyroBias + _gimbalParams.get_gyro_bias();
}

Vector3f SoloGimbal::get_ang_vel_dem_body_lock()
{
    // Define rotation from vehicle to gimbal using a 312 rotation sequence
    Matrix3f Tvg;
    _vehicle_to_gimbal_quat_filt.inverse().rotation_matrix(Tvg);

    // multiply the joint angles by a gain to calculate a rate vector required to keep the joints centred
    Vector3f gimbalRateDemVecBodyLock;
    gimbalRateDemVecBodyLock = _filtered_joint_angles * -_gimbalParams.get_K_rate();

    joint_rates_to_gimbal_ang_vel(gimbalRateDemVecBodyLock, gimbalRateDemVecBodyLock);

    // Add a feedforward term from vehicle gyros
    const auto &_ahrs = AP::ahrs();
    gimbalRateDemVecBodyLock += Tvg * _ahrs.get_gyro();

    return gimbalRateDemVecBodyLock;
}

void SoloGimbal::update_target(const Vector3f &newTarget)
{
    // Low-pass filter
    _att_target_euler_rad.y = _att_target_euler_rad.y + 0.02f*(newTarget.y - _att_target_euler_rad.y);
    // Update tilt
    _att_target_euler_rad.y = constrain_float(_att_target_euler_rad.y,radians(-90),radians(0));

    // For roll angle
    // Low-pass filter
    _att_target_euler_rad.x = _att_target_euler_rad.x + 0.02f*(newTarget.x - _att_target_euler_rad.x);
    // Update roll
    _att_target_euler_rad.x = constrain_float(_att_target_euler_rad.x,radians(-30),radians(30));
}

#if HAL_LOGGING_ENABLED
void SoloGimbal::write_logs()
{
    AP_Logger &logger = AP::logger();

    const uint64_t tstamp = AP_HAL::micros64();

    // @LoggerMessage: GMB1
    // @Vehicles: Copter
    // @Description: Solo Gimbal measurements
    // @Field: TimeUS: Time since system startup
    // @Field: dt: sum of time across measurements in this packet
    // @Field: dax: delta-angle sum, x-axis
    // @Field: day: delta-angle sum, y-axis
    // @Field: daz: delta-angle sum, z-axis
    // @Field: dvx: delta-velocity sum, x-axis
    // @Field: dvy: delta-velocity sum, y-axis
    // @Field: dvz: delta-velocity sum, z-axis
    // @Field: jx: joint angle, x
    // @Field: jy: joint angle, y
    // @Field: jz: joint angle, z
    logger.Write(
        "GMB1",
        "TimeUS,dt,dax,day,daz,dvx,dvy,dvz,jx,jy,jz",
        "ssrrrEEELLL",
        "FC000000000",
        "Qffffffffff",
        tstamp,
        _log_dt,
        _log_del_ang.x,
        _log_del_ang.y,
        _log_del_ang.z,
        _log_del_vel.x,
        _log_del_vel.y,
        _log_del_vel.z,
        _measurement.joint_angles.x,
        _measurement.joint_angles.y,
        _measurement.joint_angles.z
        );

    Quaternion quatEst;
    _ekf.getQuat(quatEst);
    Vector3f eulerEst;
    quatEst.to_euler(eulerEst.x, eulerEst.y, eulerEst.z);

    // @LoggerMessage: GMB2
    // @Vehicles: Copter
    // @Description: Solo Gimbal estimation and demands
    // @Field: TimeUS: Time since system startup
    // @Field: es: Solo Gimbal EKF status bits
    // @Field: ex: Solo Gimbal EKF estimate of gimbal angle, x-axis
    // @Field: ey: Solo Gimbal EKF estimate of gimbal angle, y-axis
    // @Field: ez: Solo Gimbal EKF estimate of gimbal angle, y-axis
    // @Field: rx: Angular velocity demand around x-axis
    // @Field: ry: Angular velocity demand around y-axis
    // @Field: rz: Angular velocity demand around z-axis
    // @Field: tx: Angular position target around x-axis
    // @Field: ty: Angular position target around y-axis
    // @Field: tz: Angular position target around z-axis
    logger.Write(
        "GMB2",
        "TimeUS,es,ex,ey,ez,rx,ry,rz,tx,ty,tz",
        "s-rrrEEELLL",
        "F-000000000",
        "QBfffffffff",
        tstamp,
        (uint8_t) _ekf.getStatus(),
        eulerEst.x,
        eulerEst.y,
        eulerEst.z,
        _ang_vel_dem_rads.x,
        _ang_vel_dem_rads.y,
        _ang_vel_dem_rads.z,
        _att_target_euler_rad.x,
        _att_target_euler_rad.y,
        _att_target_euler_rad.z
        );

    _log_dt = 0;
    _log_del_ang.zero();
    _log_del_vel.zero();
}
#endif

bool SoloGimbal::joints_near_limits() const
{
    return fabsf(_measurement.joint_angles.x) > radians(40) || _measurement.joint_angles.y > radians(45) || _measurement.joint_angles.y < -radians(135);
}

AccelCalibrator* SoloGimbal::_acal_get_calibrator(uint8_t instance)
{
    if(instance==0 && (present() || _calibrator.get_status() == ACCEL_CAL_SUCCESS)) {
        return &_calibrator;
    } else {
        return nullptr;
    }
}

bool SoloGimbal::_acal_get_ready_to_sample()
{
    return _ang_vel_mag_filt < radians(10);
}

bool SoloGimbal::_acal_get_saving()
{
    return _gimbalParams.flashing();
}

void SoloGimbal::_acal_save_calibrations()
{
    if (_calibrator.get_status() != ACCEL_CAL_SUCCESS) {
        return;
    }
    Vector3f bias;
    Vector3f gain;
    _calibrator.get_calibration(bias,gain);
    _gimbalParams.set_accel_bias(bias);
    _gimbalParams.set_accel_gain(gain);
    _gimbalParams.flash();
}

void SoloGimbal::gimbal_ang_vel_to_joint_rates(const Vector3f& ang_vel, Vector3f& joint_rates) const
{
    float sin_theta = sinf(_measurement.joint_angles.y);
    float cos_theta = cosf(_measurement.joint_angles.y);

    float sin_phi = sinf(_measurement.joint_angles.x);
    float cos_phi = cosf(_measurement.joint_angles.x);
    float sec_phi = 1.0f/cos_phi;
    float tan_phi = sin_phi/cos_phi;

    joint_rates.x = ang_vel.x*cos_theta+ang_vel.z*sin_theta;
    joint_rates.y = ang_vel.x*sin_theta*tan_phi-ang_vel.z*cos_theta*tan_phi+ang_vel.y;
    joint_rates.z = sec_phi*(ang_vel.z*cos_theta-ang_vel.x*sin_theta);
}

void SoloGimbal::joint_rates_to_gimbal_ang_vel(const Vector3f& joint_rates, Vector3f& ang_vel) const
{
    float sin_theta = sinf(_measurement.joint_angles.y);
    float cos_theta = cosf(_measurement.joint_angles.y);

    float sin_phi = sinf(_measurement.joint_angles.x);
    float cos_phi = cosf(_measurement.joint_angles.x);

    ang_vel.x = cos_theta*joint_rates.x-sin_theta*cos_phi*joint_rates.z;
    ang_vel.y = joint_rates.y + sin_phi*joint_rates.z;
    ang_vel.z = sin_theta*joint_rates.x+cos_theta*cos_phi*joint_rates.z;
}

#endif // HAL_SOLO_GIMBAL_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         function Q = calcQ(daxNoise,dayNoise,dazNoise,dvxNoise,dvyNoise,dvzNoise,q0,q1,q2,q3)
%CALCQ
%    Q = CALCQ(DAXNOISE,DAYNOISE,DAZNOISE,DVXNOISE,DVYNOISE,DVZNOISE,Q0,Q1,Q2,Q3)

%    This function was generated by the Symbolic Math Toolbox version 5.8.
%    27-Dec-2014 13:59:04

t3 = q0.^2;
t4 = q1.^2;
t5 = q2.^2;
t6 = q3.^2;
t2 = t3+t4+t5+t6;
t7 = t2.^2;
t11 = q0.*q3.*2.0;
t12 = q1.*q2.*2.0;
t8 = t11-t12;
t13 = q0.*q2.*2.0;
t14 = q1.*q3.*2.0;
t9 = t13+t14;
t10 = t3+t4-t5-t6;
t15 = q0.*q1.*2.0;
t16 = t11+t12;
t17 = dvxNoise.*t10.*t16;
t18 = t3-t4+t5-t6;
t19 = q2.*q3.*2.0;
t20 = t15-t19;
t21 = t15+t19;
t22 = t3-t4-t5+t6;
t23 = t13-t14;
t24 = dvzNoise.*t9.*t22;
t25 = t24-dvxNoise.*t10.*t23-dvyNoise.*t8.*t21;
t26 = dvyNoise.*t18.*t21;
t27 = t26-dvxNoise.*t16.*t23-dvzNoise.*t20.*t22;
Q = reshape([daxNoise.*t7,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,dayNoise.*t7,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,dazNoise.*t7,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,dvxNoise.*t10.^2+dvyNoise.*t8.^2+dvzNoise.*t9.^2,t17-dvyNoise.*t8.*t18-dvzNoise.*t9.*t20,t25,0.0,0.0,0.0,0.0,0.0,0.0,t17-dvzNoise.*t9.*(t15-q2.*q3.*2.0)-dvyNoise.*t8.*t18,dvxNoise.*t16.^2+dvyNoise.*t18.^2+dvzNoise.*t20.^2,t27,0.0,0.0,0.0,0.0,0.0,0.0,t25,t27,dvxNoise.*t23.^2+dvyNoise.*t21.^2+dvzNoise.*t22.^2,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0],[9, 9]);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    MATLAB 5.0 MAT-file, Platform: GLNXA64, Created on: Sat Feb 28 15:08:55 2015                                              IM    xYMlE~k;)"
h8nR9`l^f[	N*$rAP$c	qH	3?x7^*e};f a>5NqeWhmjk"-^<_nm+#tR	r[u],H[UZ=;r!vOV|Emv?`)@[X{t
SAt2!P*ZxGX>6^}X?LoqX{sm|k4icxX{L0+jkftm7 -@T1#q6^wejQ;x7Z)??O%qAz}
qf, Ey)=N[??+~{?af~O?Y)xNeWcR}kw`u+M6dLBk+E]9wk7^~|2<7;E\gj*
!:uA|qp8H l*[!sF2;zYGdh	(,)?k5sJ,\Kn!:e0~%;8B^i~}C|K/mEAR2FjDaO#F={xEYm#pn|7#p:!(DaR3]4A-=|egKq9q;C|{~U/?>k&iNsP0>oZ^=	0W7s/xt{x=yWE1_K(&&;x?5lNuw  
,#n'wRyjKUX}b
	[No9oxs#6;;A{'^>~BLnmEv71a%[ g{_59? W?+9,m}>M=rT     Om7       w     Om7       w     Om7       w     Om7       w  Wu7jEd`\.mGty@`_9*hh	EqLEK@213$HKNL 0x?/;|y=g<'N8q'N8q'N8qK-^I^gmuT|.c.LwSNwZ;wtn]}\.=ehui9,GKqd`Otf1F%=Qd;BsMw%Ggu?O~+4`n_{<np-7}	.r|(W-c!9qR3	4$>4*xG3z"u^H}0#7fq-U~d>8;Z4|@{OAlFav=
=,&?xdI#iWY?\!Y-y_uF~``Q!r-a@'Da(B?F"O.]*//c5+,b#8,Q3;O{DX	/`L:F+ISZ,<$)HLHqQlGKHN!H[yk+cWo`!WY*_(MCrEE^4_
))E^M>RoNuZ:sRk0HQ:Xl8PPXQHDLBlX>c.^k?+He{,l$<G8 Tk$*(<>;x&
Js7E*-~4!qyZ`)8O\Yu,#5'"L2IL3)!b_Y]J,Lk1xD;73C9cv?x%w7K9\|}&ru,m@*pa@U}'
[mP`@=JYFX6&Jh5m;JdJdZI[^s%]0w%D6%>"Uh*=(P/_5UQT`7HTO}PTZNu
NquWTQ?LX`+Qy73R_uq+`@a`}AAiMM6P]:@'5guxzFa@j7/L0Bzn74ipGHC4jUmR{GpltP/p@(  ,y\Kl9BJ(8
t>s(ZhQmCUV$c,f#GyQw>|`C_5<JvUp#;}xO;-}aM/j_bp_|s^=,E]WkK;}1kI~;_?;,%g]d9g~wi]~9}Z'ajw?5Z)gF%OXBx_WJFWMxN8gPONHfz%}e20Um7 zi~Mx63 G/Hk9:zNM Q?4%b.Y@-}2o4bZav#=k
 `E.q;`1$ L;eo\s2[4@D \`c;
X9!2_S'Oy*a\~vS0G,Eo]!v OY}+rKC!a}!>+goR2uMj
s7<[S7, Gy;orgaAq?X{ X4e%|)zL j-sxxU#`vOWk{,H3o>`c[je5Nl.Fvby7?1`~(6F*:/?i`?g?Y_K6Z_FF6r6tdolTO8W]cm&6Z::F-B17b;;"xO
pRyWP-PrZxMy]6QqHEB(*6_!Ny>wWE>{1}ODPB13N
O5"=a;o]mm{'Zi^ax6"R	a0H_ To\fm0h_V+w16@pVex.pE0<	<3=F5a){n~vNoHfg}
G1 m~8v?q?&vUp!<9$#Lbr~^ca8_0p,Z\.dpOm0cA-#K{#EN:"]UWZNk~?N%T<w'DAcTo4*#	^9;u1%a/1k]"gM)S^.bN9#`1 x'DWfq7pgs9nYC-	?&fp?Xgf]!juBS8<qF]2q>do}[=WyXrq\\-;Y\t-_5^b\Lhil!.tdrT\.6_3rQJ,[qss&.zb.[dHxD$P/^"Bq$6^;\wHvhql!ct$> 2#1f*=$s;.	uPC6S$%s<y8Dy=6.
3s=
4g:fGks4;
dGaPQ%>
Z(,$s?
k-7
OSeB(pe(<@iS.,s>FB`7h	'Dc:+?K%;n/!Y=oh4f!&9h:pD4,'h'1ihFh!|4E(|s4Ncxn<<o./xk<6_,<Aot+4p	\
b	F3C:{WxRQ}6b3 Jh,;dn2vV0\Sgcp'obdQ1w'91<_XnL{c!=W O?q;k?:b`5cP#dx?hG{(E||c:$>9^#q_|pz01|4v3)7)>(U|L+$!H %@XexKp Xj2Kne`D.?m 		_ Be?|48NU
L}~b8MS^6p)Xmk!>V,	b;b|v:	Ezp],scQX\p8&bL"fKx}jsR_k!N`8PPO8q5A!Y[hp-m BK=/\!/
BxnTG\B	?
5?$p${nii'0%D:J!lvHy/p	~zFBx4keB|`xSB4/aS]Dh"ebv!z0*D~	aKxTpCW
MTA7DX#*Bkfz"t}q"2	`_/BXXoErE <+B@;"GHEwaV!u"v1|+ByI"te8WNO969dHW`Ep'+BVD`qF2dEh;"ZD"bDH'|,}FG8Y[`$,gs^PCYu7{EhcYj==e8Zsgbd.[81l	WQw@n(Ipuvbo*?9wT=n1}=[o1"M#ph@JOTYbT.#2|1	!pk> p~+1blp9wjp$.FELnpUlb4Zm3Rz1#w& A}	\+'pq]/{HPK_oN	H@I)W;C*AdF/l	lHPp6rAcn$(gA$;$%x-@OA%0Med~%("^!	*_H	gH H.oxoJ`ECE[KH<D)HQ]vMD[=?)HaoW	Y$"x.50:n#~h&>#Ey ^#EvR`;eRt#Rx.RHJ)v){lXK)Ia`R?7Z
I2RSR2_AH_W27|!C7'R/_=/U?d	6qep$>%C/2j)q2_H'I2gF/i2$W>Kt]2E:_<_2X\,x6?-TUdzg6ALeD-2O!vl'1&CA|2o32xN>pD<qr,uCO|Ni]]0n9a yZ/G<9XO4rT#cTz}r|'c$M<Pa9.%B9J6Ir?sb9h}2rb0'Atr<G<R80$y)G-J984|k:g*a{(A
dTgO
TVW~xuUG|TZ
*6nf
@6T)PD|UV7
 @ }-WTY
*kUgH]n{sVU ~p$=YmIU
IgV/^) #@e[
$U~SlD:`%lj#>0@W%qh4{c+L<Y	j\%:/+Y&Ux_Sm%
gHn\(j)M	o5j%ZWWBOZW\-V@<[JdVUj%w+2\5(QA[[V(QO<\	a+a">D%o_)M\zZ
9Up43BqPtxhrU7*41M*5wH<^

UT<*XbT0W~|N*WB3}e@gx
)'nW
m*3@$.*
kUwTN~
</P5rcNBWvp+I7P>*~@q=B@
rW
&(+}4
/PH6J?+(l:v,#SP()w0B_TqdA=X)f2B[}4
dA5Bt%(9}5B\Lb
F)(xJBRS%>TSh&@	RB2}hpo`k`z=^Qp{t
~M)j`ek5xmLP>jEys]0`}~1MlQ>k>5HQew#W
CL=NQO70>E-a^jtNFjkrez9Zz`fXt5Jno.;Q;fDb-LGQM>jG6v5j$3]Esuj}6^oQ#o	Yp)$a$E97_QK4T(<!Fr2i\hP@4p;J?}28@o?hP"WCijCRSnAW/]40}"d]=uJ?4 ]GjkPOK ,D:kMz*tr1c4(9rEAi^L}/4em 0Z+L'*yds\02H7iZ~gYa -IGzy\-EJH!]IL3ubSid-En5Zx=ugit'-ZVk';--kaXt(-h}kMzZ{FLuZT}cyc['Jav-LWi1o+-I"xZX50Jt[cP570=KwgL\u`d4@OAF:u>uyR\QUyy#>Xq:Qvua:ALzYtxB)>^12|{/NCt:gz%E5:x1L:)=:~S|zpt4lc` {O~+/2]M{C:}/lW dOp]0M7=R?3@BsH=GIzoaU9=  iXMoQD(ED""""='?"""(""J%~?u[c\B|*g	} 9q7:oAn(tKuU}-G}Lw9cki>FfyfutL}}]-;[?>=#g>%(yv{8}IG~?j5o/Lie-u8N%3iXd{yo9Zv!IfOIPh?f@$|g)]M,-(5%pkFM	F2C@lm2m-;gv6_^	z9}~~.+g)'`z8;VygOy:o-vg0>'9|	j%8R ')Hj[ck'+[draygN U~$`;*=6;g!@?WpMT<S?M D`H&cpIWK'tjeXu>1%k, @[y\?Y^e
K1}j!9'X`L1ReTx[*tYv!0aW:	\>#@'R	LWTE?]|B^u<,5g	QdU>j$(5]tu$:$C$l}uHl{.Sj@#QV5!Q1	$0Af$jN"Q'$kfn-g2g-fG(vk+P!b3;]+,78yi>O"3x=9aD`O4t/<+!H|2@!1&vPO"`ceDrkK?"n% My@:DA3Ip$n"q#vpC#H*+3#IMen~iN,s6B<NwO O"Wk2CSH.+tG}wEusIT~
!{\6UmPICyr^!7>R1	>J{l"=[I^u$=Rs'1o2FG+Dka3	qc[3mm%q=Itjmk(4u
Bm*I^qSo
3B]
VWmruUBt#?Pp:1v(lrBgK
G8[S8|G0XdC"L:gV] &>
mC(|{1"g
68Bax+]Iu0"DxR(2ZEAWe+&Q{=x
u)_"$
#gUKaE}22t:$b 
en\mUOQ;=5+BU7")/~CJCV1q,vxps7&Q#JO=)8v=!*SR(RNAY*FMvPx+7s)/}GR>	OwQV1ug,-7QWsIF-5tFeVGaI#z
@F
gJAQlona&*vB4nzF3:1 5h7&!~1y/M~B{Q?B?=jDco&4L3sA{Re|{B,i_|faMwh<?s0jaL#"\iXZ3nOc-i\f>=h;)E^4+NxzCOcI34^.w%]8g MMzLc|IM4jFFNi"hl84Fv3.F`bixhS[8{m;&kDf>FFpSh8|I*Y=;eDY,?it=Hq7=WN4<@-b!s+~)oAi1w.aM%U:JRKWh#]L^@PZaGqO!24u#X4xv%}b3#w?MU>X+3{.lkGc;n PJZw4t8wBte=j3Qwy/}u5pw)6a0,.f
S+=~19Y1k2&l[qA1ZRAST4|3=t	y J;7o30_K$Ob+W9*{Ah{<;?)15=l*i0Sge1<Q:A@AS.S#L#wpf0-blS-g9
z:bD.k5(|:Tg\5kYUjd3OcOy8=xZ[^X[wJ~y>#.cpTSJVmb`:)uJ5UU/+uF]ZLA|(JU#}ufjFeV]jg4};81uu5k`Ug1z5TY5,.^GGER3?g>ei,ZVkW:,14aqWMYT<g,Y8`Y,maauy[kiXtTcf9pR0;ve]Xqeg%n,gwQ}C<X:/!3=EjInl7S3%E?z,,bVb,"\{!EyYe}(0	onR"X|rhj}$kffLuXSFggex#Ld}t\$sbfU]{bI2Xe8Y}s6qrXX(!j:Yd{v[5_n)d
({gPBkin,Kbq0j/G,8H1=jk=/o<bS7S#uGnb`^EGNZXx6J+~jgp@2t.+a97PwAi&V#u8U}Sl!xn[|	[l70{8[C!V(1;l8]-'
8qxPG+[!~ipjas 7ysq_y
]_&/OOjFr0tsb	z.Cu^7$sra2E(o1yAMp=CC9<X?3!?CkH/?*ahRc8#[8M1?9\kD"8ptb7S8\*]GGfp(|,=dscYVjY>Ezp]qaO!8LOj)0YQe6[xWr(Ztn&AnWspyt*FrxWa
@slvfn!0&u"9Rn_K_kOv#0spw?*Ft,Pn[5yz?B3'S7V`Bwy>\ 2r)k53f?<?Ziyh':`o\<<~ xyGMa:
?*r&{xq
x96'.jx@%yD]I2<*<n<Sr%H;n8J0aP ?D N5Pv(>Gq7y1Y2$-E0Q<J8!=cyL$Y=nv<N[rz|"I<\L$XxuNWS-,,q_
.Ky'm/(Tcfko4Ox|]~<Havh}.q./ytRZJ,xrX=]+xWHwciIM<mZx]G	x8^WM$OsR!VxnZy2	_# z	T/@Rx0XLzTh;BEvVZbVZpWFaJp{=OuH$TOiZ"`3=
pMieVh=!J'~;{78Y^p*`s]^TP}SSV_p[rWpAL"@1T@0Lg,B
F	{c 56w"36u'|IQ(`Fk$9,R|RO&`E2d8mmy)|>"G4wb.Ur}-'C^	_LD EV}prg4hyU-"54KgQ+ C_?_
p3A~PDy=$@KA;u EAkZ< _A:iEpzzWrKHS}ZOKgjzKtlR U_Dws?COove,B99m%oH7LDq;-D4J)Z?Jl[g+b"68']f8=zsET~VMH )C{^QN-bTWsH+zz^I"76_!bA_DUM"zxdkKh}NxPMCDPfH5yR}F9/ZW^w7q"yQWE<HL$B;Ad""yB4/1tVX!{-"nCaf|A%
D(6rqD1D32e[3V*a%j|;7yJ1gmu"|+"2oklsRJg,lqwf:z9-"]PU2+b;Jx2|
^US$A~]/`~]Gi]p6%{5 fbc	avHigk*A7LmC-$?ka%YV5V4&>z/q06Nw-,i7	4+a:7	;:;rP@!Co<^]<[jHvy<^wIBZRXWH7|s#$lxX(! 	]|1b,TBL:+*LB;%m=GCch	|`X	~Ghpv{~=9<Q]`$	~fJp~	$J?}dt'SdK0_%G)N</I	c%%~WR.nXS&aj{+%l[6NVK}P)/%OHJ8Tzt_KA~%/$GfeL-f*p:-udGM&cg"UQicd,vqT/+cP}ei(#}6*iSLe8n&V_,-dUJYKFt=sFme/}b(kA'zwYxi\dOqiD;&5!w+xK2w-gC8`sG1/Rdi+d~'2N2 i@VoXWBe|x8LjiSGc;2?x$FxhY2L_pT8(#I2E2&evV4yz)CZ,/i(u2@FGeh-r_JdSU&#sX]+dL8MMz)2I14z	eTD~1V&xgb""!~nm2,8Wj_GEzWSOG*8^|
[LRip
(QG*|@K3U0^ub
\r[$RyWUQ*,[(j
3UU5
3vB!{{Lw^c1
K:>uV!UM0WvSAn4Z{];W<PydLw"B0wa5M'
]OIUhIKVa>+T0`TY
<ZB?SCT8jM
  w<Up$U!Y$mMTGZ%KMVJB{Hw>s=~egYN; AA6!a\@fa	2#A]q99Qk$]tR[Q3H0pzRS%H=k;"C/Z,%d=`G;}<2
$(U.k)`+,rm&AH{o<y[6Q=2>H2*	dJeojgMs4%;vI<.kg`@OC&}&A<m?%zf!W]A
IQu4IvR"7v)tD/V`u
rGS}1
~YU
K^j{_35J-Oo(_ULEBJW,i>GA`j[FX*m	J) 3`!MW{gCah\&.wpxo)&K&H{SMPh&uq:
t7Pk/
~c)\-UW V`>#5PP7QOWMavpKA^kb
JP_wa
4v`t~^Ga#s>%RS~c/;`g,
Q)j|?R3A=8%DJ7|.OqvG\Qf~`&m
)%_*(hbeO(8LyBFi-W=_)kDaCw\
Q<[g
5 r)cQW:(P5Qpco&MF6,fih=yKr%/dA.eip
UW!q&k:4Gv}i4V2g8y1~PllJ7{rK U4r&XHurKs~?ciou\J4bORXAno54]n^Gch^M4N5C{0)aMp_9x"~4z1d@KOuF%!4W/&`0+	14u+]4f}u'i\xv
WSiXo`l#NGccdbNBCghlm~9Yn{F)wT[m>'4w$6!{Zg%Y9Ajj*CrhI{Cmi}w4&i{~AkcJ]Lzh	Ih;e.	5e'7Wem3TQ8?\W&3TL{(wk<a~g&byeus,<:t>We6Mc`i>`Y~P53M#n6gt6AzeRy1Ug{@Q]]I[1+ovl&?br.-NumArkJ9>{^Tr)dX^}_dpHf'e`upja06c8ko&18>1'df3
mU)
<1'wd329v*AECy~u;+a 
k\\N`05xFk <|sz`ANW1UAKY7ib1nax64a0`2 $g26:u3^2l*UR,R/nad@YAVOn"%'vjg?Qd18HUOe4q0<$z8kF,z;p4S,e,2Va1,`gzZ2'rj,|=cs JP2tXL'yZ'GnU3E_5	SY4T6`?SktCl!aq1|#'E|InwN&X3iWY`lV,MKLlXh-\g*z2c-agi:g?T2.,FTNbNn,V3]bdq<u{f5kY2<v,tl8'OA^,"d"wB3o5b*Km,*yz+JXPNX<xaoPxG*,>}b<Os?!M;<;xWw=,),Jo%h><=qA,:>Z*|0NcCXz";ES!,:=/dB(SBkfs>EaH*ZYD
=X(.$:vy18sc/`!gN(~ %i54.g7,RYX>1f~!yLrOSXT8xa/7PN"0TbuBb<j*aqk*JWY(TLK+cO,,r7;Jw,*X#rsH'g.GsIdq,?=x{5Ca}mXGvz+G-9UF'6jTgf}ZYgo_p0[1&j~[M?.z`Jgb;C>{o_H e	.I(j"xW_;4#:sC2~XvY[[YY0f__VCzf7{;Y?nC$p,+Z2rS@2iUq"C8YdjRZs0]s$^Fs_f:kY/pRue8Jmdsprd0]ZUkFphAm8rz]S8L2=Co,Urm6C':w06:el&$gKCyR=CYPeS"p5lp048m~veKIcts8zgph.B+[Rr5qv:+2g	L;qPCvL=.^?W59nT6_eWrpW?$CD-?wgd]B%>"o	8/6n $ysHxfkqh_"WiFAS`:}]l/!lXgCy*jl8lzC8;:fs7p:t}n(qx;qsH8m8!.kk#948oTw4z\=jlKB^,!]6]6/}`sElQw[rOs-g,nR8H<<r[.ya2Yc988;.3bGA9
l{^|%3U8_Uo+(Q<W[(|K`)Trxhgqao	SOp9nA79,?`!v;kyopPq~=Z|xJq>W1qm8)q8?N8~87?8'<>>'[Do$_5wsn%GG}zIog+Rn\f:>} pqn1|<r|yW9Z8H|w;J~["-"&f%/z58?_]KqO/2<*k4=O@w\yV-eyR/it5P5F,yu^<Hl:86y|F2w.S.b1<h@^55fP~jc~!Z<G~z<dK$KLap|
<?x0?GBoy<:Gu<?yKMi|a4&kbrA<O?<lyjh-KGfn6<NO?av<>xWWor'%r?yp
\x-27/_gVJGZU#mw^3&.[#d_yWZ><y1M<95cwzCxcyRGm5DrIpgyL{xe8l]C]mG_?}[owx<3 }^b5%"Gx<5<=sVNn{(YD|#xQx+o[+GWX'z<;VNA*#<lwGOn>>C@S4=Gj^
OqV_|<Vh1#7x&9\G:UI<ZgD(!K~V*C?/tG$Yo;GLnKXNtwxKzGmQZM[s`8I[5q>Ze(yfos #8?azsOVPyCW$[S~yut} D!D7JhN)0A~N!N8Yt7qs]qn}88HnCKc[O_GJB_q
|wh(P#(5YX=PS=	8Mbni)-m3` k**P\Ftqj1PPB]@CM'0`Ai:HAO@Po7mnMcD#?mQ$`(`ev6)iBMy	#<pcih*3g m)@]}+XFY=z'	H#nQ/E"lt0|ZfY1O\,0UN"no}qzW
hSW]~ kx^ Ez=) u/u3tgyyPq"|m<3$_#pah;}/B/@v:U}-
'^$Pv
G@k]#26u	Udu4H3$`doPO^:c0YL~)`QHHiTcTL;+NxCI`}
pK28. In~|B@2S>#@]cYgFl/
r9.QL9Ov%Gq!2y(=/ `%uNRc*X+]_
0xzU^, [$uP2-Z;4V\z}<}qO*e#Q]mxyvNT!/$<#esnF|dB3qGV\	m#|E<b8Y87-1yO}Hr98BJ;8WlO|sv.w^q>y]o*"I_8o'/qN^n87l1y/SsJFc cYZ"b}&JE`2HD {"ld<Dzsf&"'?=RDeGx8^VY dUDf1KSF8D,S.5Ee6o?%Bzv"h=3&w!M{lZg [LPIV!6i3Ex2-busD\ q1q c_E(051[33fze~d,d?)-L-EdY/3;&vbd8g'3^>[""0$kTDgs."Z'0[\&b]
WHZDcvkE!c[/D(x] 12&]}[DJ M[HDX.uL^r0'"*D_P6'xS{Ywi`[;d >	h<i p@3"R~B_Nuh\8$iTD)B3Na)3ScE'"	"*DdzT2iC"-<.b"s).W:#wlYoHL weCynK   _mpzRJJK*IVBRR%-7+i$$!I%!jhkIVs]{aR$)@@,gg"u?.=T%j\D	w;n
0}520y 
0bIvO32KHo %K5&=mJ >qZV V{ K4Q;Qg[/x!W_
s{&|zJ7et- 5NX/gZ?&K
bkm8Mz:'s5.'L&Z ?@}`t,M'=b?zz q4T*]="Ko&jrPV$S Mklo-@_l ;BB$w~0IV'Qpl==R`ifQH
-p.NZ	
-*yR0CN)g]M3`*n(<_)RMDAs3)nUiJ!yA99s(Tb<
 1M$%H+y
9r4)P2iS8ceCV`=
{0Xb
sc_Jak6
~QhaLQNVr+)(>:VUnShB@k|j
U!k)t3)7-)hkY[ZQ*nMa_mV-D6{
'@]|KG
Dvl%W
;FlF!Y)d;Ph IaxYh5`P,eQo~vvpn
.|:4:K!Sj%o :y6?0\k"GAunm^R`
%muPF)D1B}kiYGR.j`lw@mb)Sn+`}B]G)k ]P:AA@`%>n@!uBmQ&+d}7/m6TSY{i
>@KJ!C;M +kRVIa_;YQ8r-)$;%%P|E( la6v;,w)OyB$r
(U|TJ(Je6OkWN!"+ivoUTk7vu2:8<8H9uqN~%q.q18"@}CIG[l8O.j!?JwlF:?@"5^/q.8Bo&/t9fc?cq<y's D^4FD_&Pp#J(\l1t=jHQFI_ bhtH{@shQWBD5E$>Y<Tv3q&?Yb*4Ta^d>C#}<>?Nch<@>M4J"qN^Qv	-XLRm:{8M#F4Wl.0p,V4gSZk_hN|z_'6ZYSQO9[UaC4\6
iNFIM4ku;Q{?En4o4vq@m>I#/]||oMG|hY]v@6h8>;s
cT\u7Zi;@CDaA %S+pr'P@JHvQ3zzx%]i:B2h(l0qK[$zF!]zheoGX7;'vF48G4V<8cs7#h8jp49TuYI6'hF<;]1_K4mV:wsC|B&Jy\4F?8fP%5I7q:)7nSNE#me4>t;y;4$\fKC*Wqju-4$,z>ZH!i_if		]Jimn)f
~)h."8Z8w488m<@[Ji5gSn?#yz xIGDL+{\F~|q]\8)88'q'<EX|q%D87\K.;G\{4~8g+Cc	a\q]o2sa'I9[9Fa	O%5A`K*!	N/tMb\'2WQG?_-WT1.dI1NWA(JrdO]p%CS
\UdXAJcL%I Ra0u)U"hH.~<rgl~qJAePSWk2Gq:S2Q+>=}Q{3 nR0h@<,#KnScisVmSN1(2h*&w3>XXjA?@=A/k,*HFZ1x?~Yz8}{.:2:gUgTCA_n$*6msgY=g<03{3H%9At|-kg8,c{[5w38zJ_7?d0N^o00Q5@3/YAXdA%zA%?3:a?qgPzH
c|>##Mf0fIqR*2eCR5;0XSM<OVj8}.ZzA%QO4N\#LLdp2p_)$A]A(Afsts.W:522/<t/$_e8iLZhbl{g@<6R[v|i.XM~yWFeg{O00|(S)bb3*70(2A;LNqdIJ$<j<bY:\{Rs7Rdp B8lJi"7F/o&>/}8	i87?q~0Z[dI]i.F=yn^|}]V~#!|iGwu"A9_a8v}|8?No 8q/q.r9x"%VbV5/"*"(h8-8EKP%G;Xfq|wKcR\Yp<+UrA
E?^*ZKL}'biL*jLXE\x9sXyJl@TuIR4YzHhh~9KLoz,[=]b9WYo)FX<H!M[ibt2&cLXTf"lkhU,r6,E/kXH\||2m-7s,L6Y^bqlY]3g1ksIqd_83"2rf,r6vcHv;U%<X(OF_Yj5]$f/YT<YfEJ'3?w)bo7)$FC 4c,OOf4/2,,bG7<ir`sH!:j(aR?VM8C!Hn92,B~aXebSpdc,b,\|"6XWTLd,q~7,To{\Hv13/.3}TGgi,dhJgaM _eDm&X(,J|Z7X'Y,\X^",{ESk,H<e
X.b+YZERL9){+Y]b!%8ye|r8?]V	q~Zqn0|u#qqB6}AMyE]Zq^Rsiu3q>m]s8	.8-B[J'/Fu[v]}kzsu9{s&)GW.'Ia }[3D8q8
7Gs{nQRzkf_?;?v 9
qPT2${[#!Ltp:1iNds"';>G^Qc98mm@p@a6P~	&1:anaHxy0*Y8>C9862})79-x^{59W:Wr.W78t .]n*,OXq|F=!&V0vc-3#8XH9XFaf o|Zu[6 !?C[qpsa!\[VnPffL}rynn#<p3t Mp+Z8$(e	ugBC\Og9:`-oi9Xd8!Dk?mu7:wr8lO#:}u =3rH)4: P"QO)7{c8\zfq9X'3CJ9w~M(pc/ErPV9MSf!JzC2'P{1<qj{98eOX83C;97{g9.A|Ajz3_mE%r$"K9y6*29"s'W+">oT%tv8FzrT&E |W{3}I^{p(L#8|?jw9O/}R?i,p4J7\5}5qG!sq^.8j}{5/GF|lXq>V+;S~qnhRLG?88G|_s8/UX8zF{DDw7$z}E|=8?K/qGJO6Y`8!\;0q~u!Q%}88c"?F7w!S*=KEU;Nq3~!oK5jEyXx/$cG<bJ9t$Y}xO^yn4y2<z8(mk<BVGo*Pq1a"%Wz19Aj,ZE<lfvR<8GBy<^c.RPN<TyGj0Y|Hsuyt8^#>_|pR},-a Qh, E!c)(<SxLsYC#ehh<Lg_#<\hx>lcyu6<@-m.<\;>#C#Ow\CzxU1?x8W8kGG<CvZoPS`;{/=q;y^}B=<~Q S1Qn<L;$GD	uGzSGl8}Gx1TSqKvFI(&ys_O'}Qh5X$|F.1<dvW*qGxX|ie1*s[<E&j$`^zGm	<Rb4Goq<zMH!qDcx8heFi<<*h^U%|%Y<Nx65f9<.7qxxk[<rVsy4?q"Hk|
z0ofq{}c<Bg(kZE<*(/-QCR:fNUc_*FE<w~K}2Ogf% F?Y?u/s We&<kf|,|3$yh|eq<vW+q<8u=dq :9Weq^C"K&u	9U-dJ~FgGbo9s	g1=K=1A'	!eLSA(q	Be\x,}amxN|:%zA?   ;}q$=PI(*dvYIBY=KH2B2B0B&%OpeP(eQxk0fS@ozi
'R9atytSrbWS`_L!i*j}J%oX%SP2<|)yQ:o>M
bc+(o\WB[Jj
\f>0Wg}:O1oA>krcPEe]c)L;|"fI&
?2l}-BuFj|OkP=?\-#v%oUN\BLkZ\]]wRU6<S`7Yd{
h9Pp
G5:Q^pz>
_wiRZ2Nnk?E!h*O|)HdSY0@
&WQ0]!BdBa
o]+)
+G\Si
C!V[4pt`^A(w18)n0
wF)AAIH
kNQN]nU4gc(${Pqb
i[NT8HfJ!b4
#)4
rk:O3)(3eSeCrkjD!
:Sy~.dtQro{[p	x?.=?`g%y#q*
WSps_sB?Ok)r*=oSx0}borE0{VU<OaW=j(_9L:^=HA$(jHUR='AB\-W'q_%M2xNOmyAq/h%{NI&-od!SuFs@O?JT<HoJ-Z8i#:Hk"Ku~B&m}FyQqn6N
0T[ 6#,a!EhhQn+Nc]Z\Q{YR44ObRCO}H1*g3^va&44=NKXaA|..]lb0Favy-ha+DC6@B#Qi8-pPq4X_Fvq:<i|<!cT{h,S>IZ4.~FGW6:4)Z>ix|*NzFhDt4#1!Q&4;Mi[Px4}&X*ZkEi	!}_jor^[v47tnq4`'
'M10:
4(waQ1[I{iD>3F_pxq4-4f+M}]6YC|6F:F]4^!`]`VR&YdF|cie#4:bz9
W?%&.,y}fi*u01Dv[aS4fL+2y	:M?yU_q;-(O
szi>Jz$xj*grh.l5JXyb43itR|9?JsiO=h8z_lZb~xV1/d"ZEJh1G&o(6'E9ZEC4*JL!,fZWMCe{g4,r<{kixz6Xu4(CUhk1hzs`#\~,%1qkn@(6Rs7Mh!:'\m%xc/;)G:w7gt{]}N5}Au%z:G)|Mvq>Mi?qx}E;iXgOa q~nlq>8S'$;M/"y	M+Ff%]^%K4#'y'm@kLpZ\GR+Q/hidLw]b0+|203=}R82fp7kiz1$6KepJ(FAQZFAESnyyE?Pfp7*'-\2p/kVcgZ O_YGx,`kehk/R0mfj3X=0,qb}b&Z2PsZXv-2gnqiFk4a90>^#|#*[\bEAr{m<-Zvo.qK2q}!61X%\;[;PYfO=0](r9{X2{K1}=A\[=2Nn'?bz1Q~.e?>as\Xu=q|Y(}0iq0fs)vN38cevS{A3Wegh"e59x'L`^Hg|N1h[4:p[1.BN30|*wcx!8Y1A}7!RLl<f~IxAR"kQny6^69[~`_a`&o~OWmSPX5-[*1ed~	R|1pThJKWW1Tfe[m718(T]zGt#oYc\+~Fays|Fo-y/8,I/sA7q|so/so?=g^kxCO+[}yG/@nSD mB;JNT$7WW5Do8#7qpb8?%(%G%*]'6jG~Vq~WjabeBFv",&UVq*$YZEyvYt6hi,-Wb=Z3ggYME,[p.ok,}>UU2b/o.dq_veo&B$Q**?TqSKY},:7a"-d!7Rc5lCsS:,B?[,OPiKkYLS^ZBue#vw,kYEASE2g'pVy#a,Yc/Yxna{Ly	Wome$a.;Kmg1FEN2TvptuEH],r&
aQ5A!M*{YLBs&,rcde:=Y	n{}8a!*,ymgaV8YDr,Z~/9I*B6aS4n,fXsE TWdB&W8eS^jFu8\5uX$&/EFbXT%f!q%gX(gar@XxtNd8jTwa%BzYp?^pu;,:JqVzx~`|j{
XI"^U7EL{nVwKYHp9m/UpNQb1*pE=7Y4H-/_Jbu,(x#}^g*+%GD_ 82qF|8L3qnFqP{8k8_8	0$[&&.N/uzAKO|-8w os$%2g?-Dl>`8?8x+q"rw<(iA5{7&>!%ELGc%am 'pZ0Gj{E8|9"2(i9h_.F!MS8n\8C_H>AHm,j^9*QCWzs9s o>ad1ys~%*p0T(iB!^	(sX8~XdO*I+8LIT~AfR[WY/|$M)-A+8(.zCrjBksX4df{{Wq,xXC@}WCrhIMNN^G53-#7=6a}W[8U9(b!;HHk#w<qd7+RnVXsXVbbV-|d+`7;U_	c@c+wsPl`u0ZCCQT')VPM3wW69<9pC8dp(}i$4mjVp_{6rn<8#C|zCSsVW^Mqmm9	`9(s092(73!"SsW6e	?0rNqu@lh	2j;nO6S9AmSp4?kr8,V3C36*oB39Xs{b}\fxpa82+|32=8&vib!kS/@EkpH-~ZW7)"D<_AuNK-|+4z'z-v*9t\|SP;q>_ifuyT|~hq#>L^m!o	%7NYTn<I9q.qz<y}ya[7v~x{|ZVq+O[mZ/iiYOs![v-/oKGY<f.o&>.c+.B<7_3ay|LJ6>tG5<b6Q?N.O	.!r\(#)qSR+j'd]k1-85+uf(2vL&5OI;B5F:<"wS~:sy86X1riGxHOm`<'<Bj_K"n*"ydYFjf,q\23uUxYLR	Ui{7UQ[@TuW>AN9Ky2x$*Jz+i	<,6ty=[XWSJc.1Qx(\G~]m5kxm%ucH.9zz<>!#{h}+lcFF1Yo-1bR>tV~[:9"a>yh/m3QMf1]6\</}LxL317,FQki~,s[fZx[;Gp`%1q6a6PhkQ56R_9Y6<<7mcwVe2fNYxt-)9
'<vi'?8NWdn-gy[0Nxs!C2y;e>wUCy|7P11}y~c[;iv._~bn7bh;qo AJ%] o7V'xS$s<R=C0~>yA_1U8'A"8S?@My]ROlA|qaL;	K"#;H;
JN!)\EVG&7;O}FZ.!n]C8-3x8<8{hBeJ'?#
J6#md'HA5?p8ZI6IH"]e_=#vE_=M!J;I4}x8d#/8=C?'YtV*%H &rg47.'8B/5T.Tq4t^9G?vvH'tp8s}'gxmN&qEyl\<^,9rs><KM']&emH~9/t8?KlGqmX0)8?EZWd*qFve`q.Wr5\+B|.c/ysu%R|/]fw/]'~+&nRs\$Wm   [odoI'BBIhgH{Iz$IF2$s~zs]io=XuL{OJ?C
Z[N~X:Js4V`hi=Z<%CkV?CY]w+;b+5fHdQ*)Wo?juJQe%s^=SCp">U^]])[%._PSuc4='kJ9CJBQ+cbWgjD5_u>0f]rX-C
&:uX)LgH.Ur!}`o!%;~bHjjF=gJRu[+dO?{V?t3jT.ot{6-y.BkUCyZ]1AL7C!>:Y"$^CQcehjyeo;!|&>dHQI.;v3tI:lZCsu>N]!pY'W'^bp!]q&'Jf?MREOC!z%#X7%	8,^x(zcX&a=},K5QQ>nz8<qb<K+J5s&T1}"KJ>X:sZd&GuMaFvSYZ]3#;#vK[EX:e-$2qqXQT4OdKbaIC_bg4E,]/4rd)}'p8)j%OJ`/@e\,KC]P9!NYv/W`,JLD%>]?8%Ew5`.K,}$8e,jOg]om;{,H#s%n!KKsN-b)UvYxFc]t&P,EZ3cK9uQ6[Yj?c9KfB+X}jfd)ob#\Pv}Y2epKDfu,{hPQBZ,9f6]7a.KRJ7|F%X"m}JX~ jRG&qQOX[1KT%gi&,OLR[gZM,M*i-]Q5g	Yrma3~2Me]	X%v6`)^;Y2}	m&],qf7Ke5F{X*4l|d{&jM6234IK^H<C3,%k[=[4vF~m`3p!ylJ_P)=p\#[=4vs2N$wAE+l$@pke#~A_2CpBrpb3c8S(y>~2JRv	8FIxt7wkY:/TZ%G&gpn3s?_Qd,M\Hz>uM.|EeN8%{u-p'nmefLh:pnp{6yp^7-Y^*RApnfCVohLP83gg9I vPu)<gs	?h\#|ay7l+p~WmO(8UUr0p(mu8] ~%
{jSnXd/pwsO;SRw	;pt]8(~: 
c||Rqpl	p~_jH<V|G{bS\g@{8w_*
5jSm&7f^[L87hFM{[,8/z1^xF^p~H[{W{6fbp,ubw6-W$n^EMp~^[X%5iyp>(sE$qk8?;jwU{Z
|[8_e8(^>wpfS1W|'~sMK|\%m*kpmm?^3*pVZ
KUb4773kCZ8
3s
z8,=<a+o$?y~Up['8`hs[^37mR_lj(=+,<To]J*&/=pg)`t+W|oA3~ysmp1eo8+t$Ee3o[[ph	::1rs7UI#iGyf/KR}|g8x5[9Nlf8Uv(B@LT1QCza&Q{5#NRxHb{+Z#8dGQARRd&r$uY`hGbLe
G2S90OnE]z4#X9WEU38*hErv(y^;E9:egqt9`/Tmj:/}[$8j>%+>_JeYRELhR-2edrdz>x5>K#}	m]]< s-K#c_s8KLZu.G.}r8,RHnS=%apmCnGyIP_}/gn"|nUH_n1G2VmFK8*M#qWY2P9sCFg9G+^Km[Q/lC[5to?^S>9Tyn(hI7+\xG[hpum+O]7Ff-T7hstvr66jr^7z($q4"RWe~o3Hi+yC%_n?3&9}=Go+M8
)H:Ddw#GN;o,LWU#hWceyM5h[8z3Ja+Gkh]OqdQw;G]P[;tGvsDsv~	|`QM`gQ4cG9)nGzI%G;8}A]/'O*g7=ol|rP;8WrPZPgp_p~hEg8WrVW<sp~$*Sg|eNpJu8t>A*P18Wy7Q:GEd[\Sp39b)zQ5 3p[dvzyCyf,o ]<GWU+W_^p.bpskIs|< _43q/G]p>?EkN o>7uU`8o=6'7C4S@@
s.yC%E8_8oM2{|A*H8[*k9shk@kpw%0?}Tr2hv7lJQ-8o fm8/;=7;tss]Awf]8OI{;CI{.scq|K	x8 %~u{**:'	/:^J)R|R'<{{'8r29Z[-Xs{yO<B.vy~E|y|oN8;s| EF%+vufpBnk8*OK[ +k~$B8Q~	PA"8r~5/O.**)_VkO9ep.GB-VJ8O

kW@~T[Cj _tmc_6p)cG8I	mQTu/.xFg8Yso"R
7Cyw8ojuw^s;3-p'=h|aMRho=hp?pO[_8yjk.tsj	a]piE75(Ps=yp~V~SXqRUs2s>lkvp<~4m)O32F4yA<b@%l^4Q<m}6t\f(rXE#]C^IRlx>7_L;eCg^Mi<]C^*_9%S\oti3x
<Jg=~19/Ne ?'<)/%yZ|-Z)_'#Cs.Hi0_'EHBYDZjbi
xR_<OPiE<$4U!J<M	09
vYc<rDQkC<54xya>O!W4zFExX`*[9^S_ZE<$P<	G^/)Ta<)pT)zZe<%Um~yrzr\T<I:GS^].kxT	U]SY uJu<r~sQ{i7-5yZg*T8t