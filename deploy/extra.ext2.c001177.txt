               // If the last ACK showed an OFF state, turn off all rfSelect bits.
                    _frontend.out_state.cfg.rfSelect.set_and_notify(0);
                } else if (mxs_state.ack.opMode == modeStby) {
                    _frontend.out_state.ctrl.modeAEnabled = false;
                    _frontend.out_state.ctrl.modeCEnabled = false;
                    _frontend.out_state.ctrl.modeSEnabled = false;
                    _frontend.out_state.ctrl.es1090TxEnabled = false;
                } else if (mxs_state.ack.opMode == modeOn) {
                    _frontend.out_state.ctrl.modeAEnabled = true;
                    _frontend.out_state.ctrl.modeCEnabled = false;
                    _frontend.out_state.ctrl.modeSEnabled = true;
                    _frontend.out_state.ctrl.es1090TxEnabled = true;
                } else if (mxs_state.ack.opMode == modeAlt) {
                    _frontend.out_state.ctrl.modeAEnabled = true;
                    _frontend.out_state.ctrl.modeCEnabled = true;
                    _frontend.out_state.ctrl.modeSEnabled = true;
                    _frontend.out_state.ctrl.es1090TxEnabled = true;
                }
                _frontend.out_state.cfg.ICAO_id_param.set_and_notify(mxs_state.inst.icao);
                _frontend.out_state.cfg.lengthWidth.set_and_notify(mxs_state.inst.size);
                _frontend.out_state.cfg.emitterType.set_and_notify(convert_sg_emitter_type_to_adsb(mxs_state.inst.emitter));

                _frontend.out_state.cfg.rf_capable.set_and_notify(rf_capable_flags_default);      // Set the RF Capability to UAT and 1090ES TX and RX 

                mxs_state.init = true;
            }
            break;

        case MsgType::FlightID_Response: {
            sg_flightid_t flightId {};
            if (sgDecodeFlightId((uint8_t*) &msg, &flightId)) {
                _frontend.set_callsign(flightId.flightId, false);
            }
            break;
        }

        // ADSB Messages
        case MsgType::ADSB_StateVector_Report: {
            sg_svr_t svr {};
            if (sgDecodeSVR((uint8_t*) &msg, &svr)) {
                handle_svr(svr);
            }
            break;
        }

        case MsgType::ADSB_ModeStatus_Report: {
            sg_msr_t msr {};
            if (sgDecodeMSR((uint8_t*) &msg, &msr)) {
                handle_msr(msr);
            }
            break;
        }

        case MsgType::Data_Request:
        case MsgType::Target_Request:
        case MsgType::Mode:
        case MsgType::Installation:
        case MsgType::FlightID:
        case MsgType::Operating:
        case MsgType::GPS_Data:
        case MsgType::Status_Response:
        case MsgType::Version_Response:
        case MsgType::Serial_Number_Response:
        case MsgType::Mode_Settings:
        case MsgType::Target_Summary_Report:
        case MsgType::RESERVED_0x84:
        case MsgType::RESERVED_0x85:
        case MsgType::RESERVED_0x8D:
        case MsgType::ADSB_Target_State_Report:
        case MsgType::ADSB_Air_Ref_Vel_Report:
            // unhandled or intended for out-bound only
            break;
    }
#endif // SAGETECH_USE_MXS_SDK
}

bool AP_ADSB_Sagetech_MXS::parse_byte(const uint8_t data) 
{
    switch (message_in.state) {
        default:
        case ParseState::WaitingFor_Start:
            if (data == START_BYTE) {
                message_in.checksum = data; // initialize checksum here
                message_in.state = ParseState::WaitingFor_MsgType;
            }
            break;
        case ParseState::WaitingFor_MsgType:
            message_in.checksum += data;
            message_in.packet.type = static_cast<MsgType>(data);
            message_in.state = ParseState::WaitingFor_MsgId;
            break;
        case ParseState::WaitingFor_MsgId:
            message_in.checksum += data;
            message_in.packet.id = data;
            message_in.state = ParseState::WaitingFor_PayloadLen;
            break;
        case ParseState::WaitingFor_PayloadLen: 
            message_in.checksum += data;
            message_in.packet.payload_length = data;
            message_in.index = 0;
            message_in.state = (data == 0) ? ParseState::WaitingFor_Checksum : ParseState::WaitingFor_PayloadContents;
            break;
        case ParseState::WaitingFor_PayloadContents:
            message_in.checksum += data;
            message_in.packet.payload[message_in.index++] = data;
            if (message_in.index >= message_in.packet.payload_length) {
                message_in.state = ParseState::WaitingFor_Checksum;
            }
            break;
        case ParseState::WaitingFor_Checksum:
            message_in.state = ParseState::WaitingFor_Start;
            if (message_in.checksum == data) {
                // append the checksum to the payload and zero out the payload index
                message_in.packet.payload[message_in.index] = data;
                message_in.index = 0;
                handle_packet(message_in.packet);
            }
            break;
    }
    return false;
}

void AP_ADSB_Sagetech_MXS::msg_write(const uint8_t *data, const uint16_t len) const
{
    if (_port != nullptr) {
        _port->write(data, len);
    }
}

void AP_ADSB_Sagetech_MXS::auto_config_operating()
{
    // Configure the Default Operation Message Data
    mxs_state.op.squawk = AP_ADSB::convert_base_to_decimal(8, _frontend.out_state.cfg.squawk_octal);
    mxs_state.op.opMode = sg_op_mode_t::modeOff;                                      // MXS needs to start in OFF mode to accept installation message
    mxs_state.op.savePowerUp = true;                                                  // Save power-up state in non-volatile
    mxs_state.op.enableSqt = true;                                                    // Enable extended squitters
    mxs_state.op.enableXBit = false;                                                  // Enable the x-bit
    mxs_state.op.milEmergency = false;                                                // Broadcast a military emergency
    mxs_state.op.emergcType = (sg_emergc_t)_frontend.out_state.ctrl.emergencyState;  // Enumerated civilian emergency type

    mxs_state.op.altUseIntrnl = true;                                                 // True = Report altitude from internal pressure sensor (will ignore other bits in the field)
    mxs_state.op.altHostAvlbl = false;
    mxs_state.op.altRes25 = !mxs_state.inst.altRes100;               // Host Altitude Resolution from install

    mxs_state.op.identOn = false;

    const auto &my_loc = _frontend._my_loc;

    populate_op_altitude(my_loc);
    populate_op_climbrate(my_loc);
    populate_op_airspeed_and_heading(my_loc);

    last.msg.type = SG_MSG_TYPE_HOST_OPMSG;

#if SAGETECH_USE_MXS_SDK
    uint8_t txComBuffer[SG_MSG_LEN_OPMSG] {};
    sgEncodeOperating(txComBuffer, &mxs_state.op, ++last.msg.id);
    msg_write(txComBuffer, SG_MSG_LEN_OPMSG);
#endif
}

void AP_ADSB_Sagetech_MXS::auto_config_installation()
{
    // Configure the Default Installation Message Data
    mxs_state.inst.icao = (uint32_t) _frontend.out_state.cfg.ICAO_id_param;
    snprintf(mxs_state.inst.reg, 8, "%-7s", "TEST01Z");

    mxs_state.inst.com0 = sg_baud_t::baud230400;
    mxs_state.inst.com1 = sg_baud_t::baud57600;

    mxs_state.inst.eth.ipAddress = 0;
    mxs_state.inst.eth.subnetMask = 0;
    mxs_state.inst.eth.portNumber = 0;

    mxs_state.inst.sil = sg_sil_t::silUnknown;
    mxs_state.inst.sda = sg_sda_t::sdaUnknown;
    mxs_state.inst.emitter = convert_emitter_type_to_sg(_frontend.out_state.cfg.emitterType.get());
    mxs_state.inst.size = (sg_size_t)_frontend.out_state.cfg.lengthWidth.get();
    mxs_state.inst.maxSpeed = convert_airspeed_knots_to_sg(_frontend.out_state.cfg.maxAircraftSpeed_knots);
    mxs_state.inst.altOffset = 0;         // Alt encoder offset is legacy field that should always be 0.
    mxs_state.inst.antenna = sg_antenna_t::antBottom;

    mxs_state.inst.altRes100 = true;
    mxs_state.inst.hdgTrueNorth = false;
    mxs_state.inst.airspeedTrue = false;
    mxs_state.inst.heater = true;         // Heater should always be connected.
    mxs_state.inst.wowConnected = true;

    last.msg.type = SG_MSG_TYPE_HOST_INSTALL;

#if SAGETECH_USE_MXS_SDK
    uint8_t txComBuffer[SG_MSG_LEN_INSTALL] {};
    sgEncodeInstall(txComBuffer, &mxs_state.inst, ++last.msg.id);
    msg_write(txComBuffer, SG_MSG_LEN_INSTALL);
#endif
}

void AP_ADSB_Sagetech_MXS::auto_config_flightid()
{
    if (!strlen(_frontend.out_state.cfg.callsign)) {
        snprintf(mxs_state.fid.flightId, sizeof(mxs_state.fid.flightId), "%-8s", "TESTMXS0");
    } else {
        snprintf(mxs_state.fid.flightId, sizeof(mxs_state.fid.flightId), "%-8s", _frontend.out_state.cfg.callsign);
    }
    last.msg.type = SG_MSG_TYPE_HOST_FLIGHT;

#if SAGETECH_USE_MXS_SDK
    uint8_t txComBuffer[SG_MSG_LEN_FLIGHT] {};
    sgEncodeFlightId(txComBuffer, &mxs_state.fid, ++last.msg.id);
    msg_write(txComBuffer, SG_MSG_LEN_FLIGHT);
#endif
}

void AP_ADSB_Sagetech_MXS::handle_ack(const sg_ack_t ack)
{
    if ((ack.ackId != last.msg.id) || (ack.ackType != last.msg.type)) {
        // GCS_SEND_TEXT(MAV_SEVERITY_WARNING, "ADSB Sagetech MXS: ACK: Message %d of type %02x not acknowledged.", last.msg.id, last.msg.type);
    }
    // System health
    if (ack.failXpdr && !last.failXpdr) {
        GCS_SEND_TEXT(MAV_SEVERITY_WARNING, "ADSB Sagetech MXS: Transponder Failure");
        _frontend.out_state.tx_status.fault |= UAVIONIX_ADSB_OUT_STATUS_FAULT_TX_SYSTEM_FAIL;
    }
    if (ack.failSystem && !last.failSystem) {
        GCS_SEND_TEXT(MAV_SEVERITY_WARNING, "ADSB Sagetech MXS: System Failure");
        _frontend.out_state.tx_status.fault |= UAVIONIX_ADSB_OUT_STATUS_FAULT_TX_SYSTEM_FAIL;
    }
    last.failXpdr = ack.failXpdr;
    last.failSystem = ack.failSystem;
}

void AP_ADSB_Sagetech_MXS::handle_svr(const sg_svr_t svr) 
{
    if (svr.addrType != svrAdrIcaoUnknown && svr.addrType != svrAdrIcao && svr.addrType != svrAdrIcaoSurface) {
        // invalid icao
        return;
    }

    AP_ADSB::adsb_vehicle_t vehicle;
    if (!_frontend.get_vehicle_by_ICAO(svr.addr, vehicle)) {
        // new vehicle
        memset(&vehicle, 0, sizeof(vehicle));
        vehicle.info.ICAO_address = svr.addr;
    }

    vehicle.info.flags &= ~ADSB_FLAGS_VALID_SQUAWK;

    if (svr.validity.position) {
        vehicle.info.lat = (int32_t) (svr.lat * 1e7);
        vehicle.info.lon = (int32_t) (svr.lon * 1e7);
        vehicle.info.flags |= ADSB_FLAGS_VALID_COORDS;
    }
    if (svr.validity.geoAlt) {
        vehicle.info.altitude_type = ADSB_ALTITUDE_TYPE_GEOMETRIC;
        vehicle.info.altitude = svr.airborne.geoAlt * SAGETECH_SCALE_FEET_TO_MM;    // Convert from feet to mm
        vehicle.info.flags |= ADSB_FLAGS_VALID_ALTITUDE;
    }
    if (svr.validity.baroAlt) {
        vehicle.info.altitude_type = ADSB_ALTITUDE_TYPE_PRESSURE_QNH;
        vehicle.info.altitude = svr.airborne.baroAlt * SAGETECH_SCALE_FEET_TO_MM;    // Convert from feet to mm
        vehicle.info.flags |= ADSB_FLAGS_VALID_ALTITUDE;
    }
    if (svr.validity.surfSpeed) {
        vehicle.info.hor_velocity = svr.surface.speed * SAGETECH_SCALE_KNOTS_TO_CM_PER_SEC;   // Convert from knots to cm/s
        vehicle.info.flags |= ADSB_FLAGS_VALID_VELOCITY;
    }
    if (svr.validity.surfHeading) {
        vehicle.info.heading = svr.surface.heading * 100;
        vehicle.info.flags |= ADSB_FLAGS_VALID_HEADING;
    }
    if (svr.validity.airSpeed) {
        vehicle.info.hor_velocity = svr.airborne.speed * SAGETECH_SCALE_KNOTS_TO_CM_PER_SEC;   // Convert from knots to cm/s
        vehicle.info.heading = svr.airborne.heading * 100;
        vehicle.info.flags |= ADSB_FLAGS_VALID_VELOCITY;
        vehicle.info.flags |= ADSB_FLAGS_VALID_HEADING;
    }
    if (svr.validity.geoVRate || svr.validity.baroVRate) {
        vehicle.info.ver_velocity = svr.airborne.vrate * SAGETECH_SCALE_FT_PER_MIN_TO_CM_PER_SEC; // Convert from ft/min to cm/s
        vehicle.info.flags |= ADSB_FLAGS_VERTICAL_VELOCITY_VALID;
    }

    vehicle.last_update_ms = AP_HAL::millis();
    _frontend.handle_adsb_vehicle(vehicle);
}

void AP_ADSB_Sagetech_MXS::handle_msr(const sg_msr_t msr) 
{
    AP_ADSB::adsb_vehicle_t vehicle;
    if (!_frontend.get_vehicle_by_ICAO(msr.addr, vehicle)) {
        // new vehicle is not allowed here because we don't know the lat/lng
        // yet and we don't allow lat/lng of (0,0) so it will get rejected anyway
        return;
    }

    if (strlen(msr.callsign)) {
        snprintf(vehicle.info.callsign, sizeof(vehicle.info.callsign), "%-8s", msr.callsign);
        vehicle.info.flags |= ADSB_FLAGS_VALID_CALLSIGN;
    } else {
        vehicle.info.flags &= ~ADSB_FLAGS_VALID_CALLSIGN;
    }

    vehicle.last_update_ms = AP_HAL::millis();
    _frontend.handle_adsb_vehicle(vehicle);
}

void AP_ADSB_Sagetech_MXS::send_data_req(const sg_datatype_t dataReqType) 
{
    sg_datareq_t dataReq {};
    dataReq.reqType = dataReqType;
    last.msg.type = SG_MSG_TYPE_HOST_DATAREQ;

#if SAGETECH_USE_MXS_SDK
    uint8_t txComBuffer[SG_MSG_LEN_DATAREQ] {};
    sgEncodeDataReq(txComBuffer, &dataReq, ++last.msg.id);
    msg_write(txComBuffer, SG_MSG_LEN_DATAREQ);
#else
    (void)dataReq;
#endif
}

void AP_ADSB_Sagetech_MXS::send_install_msg()
{
    // MXS must be in OFF mode to change ICAO or Registration
    if (mxs_state.op.opMode != modeOff) {
        // GCS_SEND_TEXT(MAV_SEVERITY_WARNING, "ADSB Sagetech MXS: unable to send installation data while not in OFF mode.");
        return;
    }

    mxs_state.inst.icao = (uint32_t)_frontend.out_state.cfg.ICAO_id_param.get();
    mxs_state.inst.emitter = convert_emitter_type_to_sg(_frontend.out_state.cfg.emitterType.get());
    mxs_state.inst.size = (sg_size_t)_frontend.out_state.cfg.lengthWidth.get();
    mxs_state.inst.maxSpeed = convert_airspeed_knots_to_sg(_frontend.out_state.cfg.maxAircraftSpeed_knots);
    mxs_state.inst.antenna = sg_antenna_t::antBottom;

    last.msg.type = SG_MSG_TYPE_HOST_INSTALL;

#if SAGETECH_USE_MXS_SDK
    uint8_t txComBuffer[SG_MSG_LEN_INSTALL] {};
    sgEncodeInstall(txComBuffer, &mxs_state.inst, ++last.msg.id);
    msg_write(txComBuffer, SG_MSG_LEN_INSTALL);
#endif
}

void AP_ADSB_Sagetech_MXS::send_flight_id_msg()
{
    if (!strlen((char*) _frontend.out_state.ctrl.callsign)) {
        return;
    }
    snprintf(mxs_state.fid.flightId, sizeof(mxs_state.fid.flightId), "%-8s", (char*) _frontend.out_state.ctrl.callsign);

    last.msg.type = SG_MSG_TYPE_HOST_FLIGHT;

#if SAGETECH_USE_MXS_SDK
    uint8_t txComBuffer[SG_MSG_LEN_FLIGHT] {};
    sgEncodeFlightId(txComBuffer, &mxs_state.fid, ++last.msg.id);
    msg_write(txComBuffer, SG_MSG_LEN_FLIGHT);
#endif
}

void AP_ADSB_Sagetech_MXS::send_operating_msg()
{
    if (!_frontend.out_state.ctrl.modeAEnabled && !_frontend.out_state.ctrl.modeCEnabled && 
            !_frontend.out_state.ctrl.modeSEnabled && !_frontend.out_state.ctrl.es1090TxEnabled) {
        mxs_state.op.opMode = modeStby;
    }
    if (_frontend.out_state.ctrl.modeAEnabled && !_frontend.out_state.ctrl.modeCEnabled && 
            _frontend.out_state.ctrl.modeSEnabled && _frontend.out_state.ctrl.es1090TxEnabled) {
        mxs_state.op.opMode = modeOn;
    }
    if (_frontend.out_state.ctrl.modeAEnabled && _frontend.out_state.ctrl.modeCEnabled && 
            _frontend.out_state.ctrl.modeSEnabled && _frontend.out_state.ctrl.es1090TxEnabled) {
        mxs_state.op.opMode = modeAlt;
    }
    if ((_frontend.out_state.cfg.rfSelect & 1) == 0) {
        mxs_state.op.opMode = modeOff;
    }

    mxs_state.op.squawk = AP_ADSB::convert_base_to_decimal(8, last.operating_squawk);
    mxs_state.op.emergcType = (sg_emergc_t) _frontend.out_state.ctrl.emergencyState;

    const auto &my_loc = _frontend._my_loc;

    populate_op_altitude(my_loc);
    populate_op_climbrate(my_loc);
    populate_op_airspeed_and_heading(my_loc);

    mxs_state.op.identOn = _frontend.out_state.ctrl.identActive;
    _frontend.out_state.ctrl.identActive = false;                           // only send identButtonActive once per request

    last.msg.type = SG_MSG_TYPE_HOST_OPMSG;

#if SAGETECH_USE_MXS_SDK
    uint8_t txComBuffer[SG_MSG_LEN_OPMSG] {};
    sgEncodeOperating(txComBuffer, &mxs_state.op, ++last.msg.id);
    msg_write(txComBuffer, SG_MSG_LEN_OPMSG);
#endif
}

void AP_ADSB_Sagetech_MXS::send_gps_msg()
{
    sg_gps_t gps {};
    const AP_ADSB::Loc &ap_gps { _frontend._my_loc };
    float hAcc, vAcc, velAcc;

    gps.hpl = SAGETECH_HPL_UNKNOWN;                                                     // HPL over 37,040m means unknown
    gps.hfom = ap_gps.horizontal_accuracy(hAcc) ? hAcc : SAGETECH_HFOM_UNKNOWN;         // HFOM over 18,520 specifies unknown
    gps.vfom = ap_gps.vertical_accuracy(vAcc) ? vAcc : SAGETECH_VFOM_UNKNOWN;           // VFOM over 150 specifies unknown
    gps.nacv = sg_nacv_t::nacvUnknown;
    if (ap_gps.speed_accuracy(velAcc)) {
        if (velAcc >= 10.0 || velAcc < 0) {
            gps.nacv = sg_nacv_t::nacvUnknown;
        }
        else if (velAcc >= 3.0) {
            gps.nacv = sg_nacv_t::nacv10dot0;
        }
        else if (velAcc >= 1.0) {
            gps.nacv = sg_nacv_t::nacv3dot0;
        }
        else if (velAcc >= 0.3) {
            gps.nacv = sg_nacv_t::nacv1dot0;
        }
        else { //if (velAcc >= 0.0)
            gps.nacv = sg_nacv_t::nacv0dot3;
        }
    }

    // Get Vehicle Longitude and Latitude and Convert to string
    const int32_t longitude = _frontend._my_loc.lng;
    const int32_t latitude =  _frontend._my_loc.lat;
    const double lon_deg = longitude * (double)1.0e-7 * (longitude < 0 ? -1 : 1);
    const double lon_minutes = (lon_deg - int(lon_deg)) * 60;
    snprintf((char*)&gps.longitude, 12, "%03u%02u.%05u", (unsigned)lon_deg, (unsigned)lon_minutes, unsigned((lon_minutes - (int)lon_minutes) * 1.0E5));

    const double lat_deg = latitude * (double)1.0e-7 * (latitude < 0 ? -1 : 1);
    const double lat_minutes = (lat_deg - int(lat_deg)) * 60;
    snprintf((char*)&gps.latitude, 11, "%02u%02u.%05u", (unsigned)lat_deg, (unsigned)lat_minutes, unsigned((lat_minutes - (int)lat_minutes) * 1.0E5));

    const Vector2f speed = _frontend._my_loc.groundspeed_vector();
    const float speed_knots = speed.length() * M_PER_SEC_TO_KNOTS;
    snprintf((char*)&gps.grdSpeed, 7, "%03u.%02u", (unsigned)speed_knots, unsigned((speed_knots - (int)speed_knots) * 1.0E2));

    if (!is_zero(speed_knots)) {
        cog = wrap_360(degrees(speed.angle()));
    }
    snprintf((char*)&gps.grdTrack, 9, "%03u.%04u", unsigned(cog), unsigned((cog - (int)cog) * 1.0E4));


    gps.latNorth = (latitude >= 0 ? true: false);
    gps.lngEast = (longitude >= 0 ? true: false);

    gps.gpsValid = ap_gps.status() >=  AP_GPS_FixType::FIX_2D;

    uint64_t time_usec = ap_gps.epoch_from_rtc_us;
    if (ap_gps.have_epoch_from_rtc_us) {
        const time_t time_sec = time_usec * 1E-6;
        struct tm tmd {};
        struct tm* tm = gmtime_r(&time_sec, &tmd);

        snprintf((char*)&gps.timeOfFix, 11, "%02u%02u%06.3f", tm->tm_hour, tm->tm_min, tm->tm_sec + (time_usec % 1000000) * 1.0e-6);
    } else {
        strncpy(gps.timeOfFix, "      .   ", 11);
    }

    int32_t height;
    if (_frontend._my_loc.initialised() && _frontend._my_loc.get_alt_cm(Location::AltFrame::ABSOLUTE, height)) {
        gps.height = height * 0.01;
    } else {
        gps.height = 0.0;
    }

    last.msg.type = SG_MSG_TYPE_HOST_GPS;

#if SAGETECH_USE_MXS_SDK
    uint8_t txComBuffer[SG_MSG_LEN_GPS] {};
    sgEncodeGPS(txComBuffer, &gps, ++last.msg.id);
    msg_write(txComBuffer, SG_MSG_LEN_GPS);
#else
    (void)gps;
#endif
}

void AP_ADSB_Sagetech_MXS::send_targetreq_msg() 
{
    mxs_state.treq.reqType = sg_reporttype_t::reportAuto;
    mxs_state.treq.transmitPort = sg_transmitport_t::transmitCom1;
    mxs_state.treq.maxTargets = _frontend.in_state.list_size_param;
    mxs_state.treq.icao = _frontend._special_ICAO_target.get();
    mxs_state.treq.stateVector = true;
    mxs_state.treq.modeStatus = true;
    mxs_state.treq.targetState = false;
    mxs_state.treq.airRefVel = false;
    mxs_state.treq.tisb = false;
    mxs_state.treq.military = false;
    mxs_state.treq.commA = false;
    mxs_state.treq.ownship = true;

    last.msg.type = SG_MSG_TYPE_HOST_TARGETREQ;

#if SAGETECH_USE_MXS_SDK
    uint8_t txComBuffer[SG_MSG_LEN_TARGETREQ] {};
    sgEncodeTargetReq(txComBuffer, &mxs_state.treq, ++last.msg.id);
    msg_write(txComBuffer, SG_MSG_LEN_TARGETREQ);
#endif
}

sg_emitter_t AP_ADSB_Sagetech_MXS::convert_emitter_type_to_sg(const uint8_t emitterType) const
{
    uint8_t result = SG_EMIT_OFFSET_D;

    if (emitterType < 8) {
        result = emitterType;
    } else if (emitterType < 13 && emitterType >= 8) {
        result = (emitterType - 8) + SG_EMIT_OFFSET_B;
    } else if (emitterType < 16 && emitterType >= 14) {
        result = (emitterType - 14) + (SG_EMIT_OFFSET_B + 6);      // Subtracting 14 because SG emitter types don't include the reserved state at value 13.
    } else if (emitterType < 21 && emitterType >= 16) {
        result = (emitterType - 16) + SG_EMIT_OFFSET_C;
    }
    return (sg_emitter_t)result;
}

uint8_t AP_ADSB_Sagetech_MXS::convert_sg_emitter_type_to_adsb(const sg_emitter_t sgEmitterType) const
{
    if (sgEmitterType < SG_EMIT_OFFSET_B) {
        return sgEmitterType;
    } else if ((sgEmitterType < (SG_EMIT_OFFSET_B + 6)) && (sgEmitterType >= SG_EMIT_OFFSET_B)) {
        return (sgEmitterType - SG_EMIT_OFFSET_B) + 8;
    } else if ((sgEmitterType < SG_EMIT_OFFSET_C) && (sgEmitterType >= SG_EMIT_OFFSET_B + 6)) {
        return (sgEmitterType - (SG_EMIT_OFFSET_B + 6)) + 14;   // Starts at UAV = 14
    } else if ((sgEmitterType < SG_EMIT_OFFSET_D) && (sgEmitterType >= SG_EMIT_OFFSET_C)) {
        return (sgEmitterType - SG_EMIT_OFFSET_C) + 16;
    } else {
        return 0;
    }
}

sg_airspeed_t AP_ADSB_Sagetech_MXS::convert_airspeed_knots_to_sg(const float maxAirSpeed) const
{
    const int32_t airspeed = (int) maxAirSpeed;

    if (airspeed < 0) {
        return sg_airspeed_t::speedUnknown;
    } else if (airspeed < 75) {
        return sg_airspeed_t::speed75kt;
    } else if (airspeed < 150) {
        return sg_airspeed_t::speed150kt;
    } else if (airspeed < 300) {
        return sg_airspeed_t::speed300kt;
    } else if (airspeed < 600) {
        return sg_airspeed_t::speed600kt;
    } else if (airspeed < 1200) {
        return sg_airspeed_t::speed1200kt;
    } else { //if (airspeed >= 1200)
        return sg_airspeed_t::speedGreater;
    }
}

void AP_ADSB_Sagetech_MXS::populate_op_altitude(const AP_ADSB::Loc &loc)
{
    int32_t height;
    if (loc.initialised() && loc.get_alt_cm(Location::AltFrame::ABSOLUTE, height)) {
        mxs_state.op.altitude = height * SAGETECH_SCALE_CM_TO_FEET;         // Height above sealevel in feet
    } else {
        mxs_state.op.altitude = 0;
    }
}

void AP_ADSB_Sagetech_MXS::populate_op_climbrate(const AP_ADSB::Loc &my_loc)
{
    float vertRateD;
    if (my_loc.get_vert_pos_rate_D(vertRateD)) {
        // convert from down to up, and scale appropriately:
        mxs_state.op.climbRate = -1 * vertRateD * SAGETECH_SCALE_M_PER_SEC_TO_FT_PER_MIN;
        mxs_state.op.climbValid = true;
    } else {
        mxs_state.op.climbValid = false;
        mxs_state.op.climbRate = -CLIMB_RATE_LIMIT;
    }
}

void AP_ADSB_Sagetech_MXS::populate_op_airspeed_and_heading(const AP_ADSB::Loc &my_loc)
{
    const Vector2f speed = my_loc.groundspeed_vector();
    if (!speed.is_nan() && !speed.is_zero()) {
        mxs_state.op.headingValid = true;
        mxs_state.op.airspdValid = true;
    } else {
        mxs_state.op.headingValid = false;
        mxs_state.op.airspdValid = false;
    }
    const uint16_t speed_knots = speed.length() * M_PER_SEC_TO_KNOTS;
    double heading = wrap_360(degrees(speed.angle()));
    mxs_state.op.airspd = speed_knots;
    mxs_state.op.heading = heading;
}

#endif // HAL_ADSB_SAGETECH_MXS_ENABLED

  /*
 * Copyright (C)  2022 Sagetech Avionics Inc. All rights reserved.
 *
 * This file is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This file is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * SDK specification
 * https://github.com/Sagetech-Avionics/sagetech-mxs-sdk/blob/main/doc/pdf/ICD02373_MXS_Host_ICD.pdf
 * 
 * Authors: Chuck Faber, Tom Pittenger
*/

#pragma once

#include "AP_ADSB_Backend.h"

#if HAL_ADSB_SAGETECH_MXS_ENABLED

#include "sagetech-sdk/sagetech_mxs.h"

class AP_ADSB_Sagetech_MXS : public AP_ADSB_Backend {
public:
    using AP_ADSB_Backend::AP_ADSB_Backend;

    /**
     * @brief Performs required initialization for this instance
     * 
     * @return true if initialization successful
     */
    bool init() override;

    /**
     * @brief The main callback function (Called with freq of 10Hz) that sends 
     * appropriate message types at specific times.
     * 
     * Read Byte from Serial Port Buffer (10Hz)
     * Send installation message (every 5 seconds)
     * Send Flight ID (every 8.2 s)
     * Send Operating Message (every second)
     * Send GPS data (flying: 5Hz, not flying: 1Hz)
     * 
     */
    void update() override;

    /**
     * @brief Detect if a port is configured as Sagetech
     * 
     * @return true 
     * @return false 
     */
    static bool detect();

private:

    static const uint32_t PAYLOAD_MXS_MAX_SIZE  = 255;
    static const uint8_t  START_BYTE = 0xAA;
    static const uint8_t rf_capable_flags_default =
                    ADSB_BITBASK_RF_CAPABILITIES_1090ES_IN |
                    ADSB_BITBASK_RF_CAPABILITIES_1090ES_OUT;


    enum class MsgType : uint8_t {
        Installation            = SG_MSG_TYPE_HOST_INSTALL,
        FlightID                = SG_MSG_TYPE_HOST_FLIGHT,
        Operating               = SG_MSG_TYPE_HOST_OPMSG,
        GPS_Data                = SG_MSG_TYPE_HOST_GPS,
        Data_Request            = SG_MSG_TYPE_HOST_DATAREQ,
        // RESERVED 0x06 - 0x0A
        Target_Request          = SG_MSG_TYPE_HOST_TARGETREQ,
        Mode                    = SG_MSG_TYPE_HOST_MODE,
        // RESERVED 0x0D - 0xC1
        ACK                     = SG_MSG_TYPE_XPNDR_ACK,
        Installation_Response   = SG_MSG_TYPE_XPNDR_INSTALL,
        FlightID_Response       = SG_MSG_TYPE_XPNDR_FLIGHT,
        Status_Response         = SG_MSG_TYPE_XPNDR_STATUS,
        RESERVED_0x84           = 0x84,
        RESERVED_0x85           = 0x85,
        Mode_Settings           = SG_MSG_TYPE_XPNDR_MODE,
        RESERVED_0x8D           = 0x8D,
        Version_Response        = SG_MSG_TYPE_XPNDR_VERSION,
        Serial_Number_Response  = SG_MSG_TYPE_XPNDR_SERIALNUM,
        Target_Summary_Report   = SG_MSG_TYPE_ADSB_TSUMMARY,

        ADSB_StateVector_Report = SG_MSG_TYPE_ADSB_SVR,
        ADSB_ModeStatus_Report  = SG_MSG_TYPE_ADSB_MSR,
        ADSB_Target_State_Report= SG_MSG_TYPE_ADSB_TSTATE,
        ADSB_Air_Ref_Vel_Report = SG_MSG_TYPE_ADSB_ARVR,
    };

    enum class ParseState {
        WaitingFor_Start,
        WaitingFor_MsgType,
        WaitingFor_MsgId,
        WaitingFor_PayloadLen,
        WaitingFor_PayloadContents,
        WaitingFor_Checksum,
    };

    struct __attribute__((packed)) Packet {
        const uint8_t   start = SG_MSG_START_BYTE;
        MsgType         type;
        uint8_t         id;
        uint8_t         payload_length;
        uint8_t         payload[PAYLOAD_MXS_MAX_SIZE];
    };

    struct {
        ParseState      state;
        uint8_t         index;
        Packet          packet;
        uint8_t         checksum;
    } message_in;

    /**
     * @brief Given the dataReqType, send the appropriate data request message
     * 
     * @param dataReqType 
     */
    void send_data_req(const sg_datatype_t dataReqType);

    /**
     * @brief Takes incoming packets, gets their message type, and 
     * appropriately handles them with the correct callbacks.
     * 
     * @param msg Message packet received, cast into Packet type.
     */
    void handle_packet(const Packet &msg);

    /**
     * @brief Sends data received from ADSB State Vector Report to AutoPilot
     * 
     * @param svr 
     */
    void handle_svr(const sg_svr_t svr);

    /**
     * @brief Handle a received ADSB mode status report and updates the vehicle list
     * 
     * @param msr Sagetech SDK Mode Status Report type
     */
    void handle_msr(const sg_msr_t msr);


    /**
     * @brief Handles an incoming byte and processes it through the state
     * machine to determine if end of message is reached.
     * 
     * @param data : incoming byte
     * @return false : if not yet reached packet termination
     */
    bool parse_byte(const uint8_t data);

    /**
     * @brief Takes a raw buffer and writes it out to the device port.
     * 
     * @param data : pointer to data buffer
     * @param len : number of bytes to write
     */
    void msg_write(const uint8_t *data, const uint16_t len) const;


    /**
     * @brief Callback for sending an installation message.
     * 
     */
    void send_install_msg();

    /**
     * @brief Callback for sending a FlightID message
     * 
     */
    void send_flight_id_msg();

    /**
     * @brief Callback for sending an operating message.
     * 
     */
    void send_operating_msg();

    /**
     * @brief Callback for sending a GPS data message
     * 
     */
    void send_gps_msg();

    /**
     * @brief Callback for sending a Target Request message
     * 
     */
    void send_targetreq_msg();

    /**
     * @brief Convert the AP_ADSB uint8_t Emitter Type to the Sagetech Emitter Type definition
     * 
     * @param emitterType 
     * @return sg_emitter_t 
     */
    sg_emitter_t convert_emitter_type_to_sg(const uint8_t emitterType) const;

    /**
     * @brief Convert the float maxAirSpeed value to the Sagetech Max Airspeed Type
     * 
     * @param maxAirSpeed 
     * @return sg_airspeed_t 
     */
    sg_airspeed_t convert_airspeed_knots_to_sg(const float maxAirSpeed) const;

    /**
     * @brief Converts a Sagetech Emitter type value to the values used by ADSB.
     * 
     * @return uint8_t 
     */
    uint8_t convert_sg_emitter_type_to_adsb(const sg_emitter_t sgEmitterType) const;

    void auto_config_operating();
    void auto_config_installation();
    void auto_config_flightid();
    void handle_ack(const sg_ack_t ack);

    struct {
        // timers for each out-bound packet
        uint32_t        packet_initialize_ms;
        uint32_t        packet_PreFlight_ms;
        uint32_t        packet_GPS_ms;
        uint32_t        packet_Operating_ms;
        uint32_t        packet_targetReq;

        // cached variables to compare against params so we can send msg on param change.
        uint16_t        operating_squawk;
        int32_t         operating_alt;
        uint8_t         operating_rf_select;
        bool            modeAEnabled;
        bool            modeCEnabled;
        bool            modeSEnabled;
        bool            failXpdr;
        bool            failSystem;
        uint8_t         callsign[8];
        struct {
            uint8_t     id;
            uint8_t     type;
        } msg;
    } last;

    struct {
        bool init;
        bool init_failed;
        sg_operating_t op;
        sg_install_t inst;
        sg_targetreq_t treq;
        sg_flightid_t fid;
        sg_ack_t ack;
    } mxs_state;

    // helper functions for populating the operating message:
    void populate_op_altitude(const struct AP_ADSB::Loc &loc);
    void populate_op_climbrate(const struct AP_ADSB::Loc &loc);
    void populate_op_airspeed_and_heading(const struct AP_ADSB::Loc &loc);

    // last course-over-ground calculated from groundspeed vector.
    // This is cached so we don't flip to a COG of 90-degrees when
    // we stop moving.
    float cog;
};
#endif // HAL_ADSB_SAGETECH_MXS_ENABLED

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         #pragma once

#include <AP_HAL/AP_HAL_Boards.h>

#include <GCS_MAVLink/GCS_config.h>

#ifndef HAL_ADSB_ENABLED
#define HAL_ADSB_ENABLED BOARD_FLASH_SIZE > 1024
#endif

#ifndef HAL_ADSB_BACKEND_DEFAULT_ENABLED
#define HAL_ADSB_BACKEND_DEFAULT_ENABLED HAL_ADSB_ENABLED
#endif

#ifndef HAL_ADSB_UAVIONIX_MAVLINK_ENABLED
#define HAL_ADSB_UAVIONIX_MAVLINK_ENABLED HAL_ADSB_BACKEND_DEFAULT_ENABLED && HAL_GCS_ENABLED
#endif

#ifndef HAL_ADSB_SAGETECH_ENABLED
#define HAL_ADSB_SAGETECH_ENABLED HAL_ADSB_BACKEND_DEFAULT_ENABLED
#endif

#ifndef HAL_ADSB_UCP_ENABLED
#define HAL_ADSB_UCP_ENABLED HAL_ADSB_BACKEND_DEFAULT_ENABLED
#endif

#ifndef HAL_ADSB_SAGETECH_MXS_ENABLED
    // this feature is only enabled by default by select hardware
    #define HAL_ADSB_SAGETECH_MXS_ENABLED HAL_ADSB_BACKEND_DEFAULT_ENABLED && CONFIG_HAL_BOARD == HAL_BOARD_SITL
#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             /*
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include "AP_ADSB_uAvionix_MAVLink.h"

#if HAL_ADSB_UAVIONIX_MAVLINK_ENABLED
#include <stdio.h>  // for sprintf
#include <limits.h>
#include <GCS_MAVLink/GCS.h>

#define ADSB_CHAN_TIMEOUT_MS            15000


extern const AP_HAL::HAL& hal;

// detect if an port is configured as MAVLink
bool AP_ADSB_uAvionix_MAVLink::detect()
{
    // this actually requires SerialProtocol_MAVLink or SerialProtocol_MAVLink2 but
    // we can't have a running system with that, so its safe to assume it's already defined
    return true;
}

void AP_ADSB_uAvionix_MAVLink::update()
{
    const uint32_t now = AP_HAL::millis();

    // send static configuration data to transceiver, every 5s
    if (_frontend.out_state.chan_last_ms > 0 && now - _frontend.out_state.chan_last_ms > ADSB_CHAN_TIMEOUT_MS) {
        // haven't gotten a heartbeat health status packet in a while, assume hardware failure
        _frontend.out_state.chan = -1;
        _frontend.out_state.chan_last_ms = 0; // if the time isn't reset we spam the message
        GCS_SEND_TEXT(MAV_SEVERITY_ERROR, "ADSB: Transceiver heartbeat timed out");
    } else if (_frontend.out_state.chan >= 0 && !_frontend._my_loc.is_zero() && _frontend.out_state.chan < MAVLINK_COMM_NUM_BUFFERS) {
        const mavlink_channel_t chan = (mavlink_channel_t)(MAVLINK_COMM_0 + _frontend.out_state.chan);
        if (now - _frontend.out_state.last_config_ms >= 5000 && HAVE_PAYLOAD_SPACE(chan, UAVIONIX_ADSB_OUT_CFG)) {
            _frontend.out_state.last_config_ms = now;
            send_configure(chan);
        } // last_config_ms

        // send dynamic data to transceiver at 5Hz
        if (now - _frontend.out_state.last_report_ms >= 200 && HAVE_PAYLOAD_SPACE(chan, UAVIONIX_ADSB_OUT_DYNAMIC)) {
            _frontend.out_state.last_report_ms = now;
            send_dynamic_out(chan);
        } // last_report_ms
    } // chan_last_ms
}

void AP_ADSB_uAvionix_MAVLink::send_dynamic_out(const mavlink_channel_t chan) const
{
    const auto &_my_loc = _frontend._my_loc;
    const auto &gps = _my_loc;  // avoid churn

    const Vector3f &gps_velocity = gps.velocity();

    const int32_t latitude = _frontend._my_loc.lat;
    const int32_t longitude = _frontend._my_loc.lng;
    const int32_t altGNSS = _frontend._my_loc.alt * 10; // convert cm to mm
    const int16_t velVert = -1.0f * gps_velocity.z * 1E2; // convert m/s to cm/s
    const int16_t nsVog = gps_velocity.x * 1E2; // convert m/s to cm/s
    const int16_t ewVog = gps_velocity.y * 1E2; // convert m/s to cm/s
    const AP_GPS_FixType fixType = gps.status(); // this lines up perfectly with our enum
    const uint8_t emStatus = 0; // TODO: implement this ENUM. no emergency = 0
    const uint8_t numSats = gps.num_sats();
    const uint16_t squawk = _frontend.out_state.cfg.squawk_octal;

    uint32_t accHoriz = UINT_MAX;
    float accHoriz_f;
    if (gps.horizontal_accuracy(accHoriz_f)) {
        accHoriz = accHoriz_f * 1E3; // convert m to mm
    }

    uint16_t accVert = USHRT_MAX;
    float accVert_f;
    if (gps.vertical_accuracy(accVert_f)) {
        accVert = accVert_f * 1E2; // convert m to cm
    }

    uint16_t accVel = USHRT_MAX;
    float accVel_f;
    if (gps.speed_accuracy(accVel_f)) {
        accVel = accVel_f * 1E3; // convert m/s to mm/s
    }

    uint16_t state = 0;
    if (_frontend.out_state.is_in_auto_mode) {
        state |= UAVIONIX_ADSB_OUT_DYNAMIC_STATE_AUTOPILOT_ENABLED;
    }
    if (!_frontend.out_state.is_flying) {
        state |= UAVIONIX_ADSB_OUT_DYNAMIC_STATE_ON_GROUND;
    }

    // TODO: confirm this sets utcTime correctly
    const uint64_t gps_time = gps.time_epoch_usec();
    const uint32_t utcTime = gps_time / 1000000ULL;

    int32_t altPres = INT_MAX;
    if (_my_loc.baro_is_healthy) {
        // Altitude difference between sea level pressure and current pressure. Result in millimeters
        altPres = _my_loc.baro_alt_press_diff_sea_level * 1E3; // convert m to mm;
    }



    mavlink_msg_uavionix_adsb_out_dynamic_send(
            chan,
            utcTime,
            latitude,
            longitude,
            altGNSS,
            uint8_t(fixType),
            numSats,
            altPres,
            accHoriz,
            accVert,
            accVel,
            velVert,
            nsVog,
            ewVog,
            emStatus,
            state,
            squawk);
}


/*
 * To expand functionality in their HW, uAvionix has extended a few of the unused MAVLink bits to pack in more new features
 * This function will override the MSB byte of the 24bit ICAO address. To ensure an invalid >24bit ICAO is never broadcasted,
 * this function is used to create the encoded version without ever writing to the actual ICAO number. It's created on-demand
 */
uint32_t AP_ADSB_uAvionix_MAVLink::encode_icao(const uint32_t icao_id) const
{
    // utilize the upper unused 8bits of the icao with special flags.
    // This encoding is required for uAvionix devices that break the MAVLink spec.

    // ensure the user assignable icao is 24 bits
    uint32_t encoded_icao = icao_id & 0x00FFFFFF;

    encoded_icao &= ~0x20000000;    // useGnssAltitude should always be FALSE
    encoded_icao |=  0x10000000;    // csidLogic       should always be TRUE

    //SIL/SDA are special fields that should be set to 0 with only expert user adjustment
    encoded_icao &= ~0x03000000;    // SDA should always be FALSE
    encoded_icao &= ~0x0C000000;    // SIL should always be FALSE

    return encoded_icao;
}

/*
 * To expand functionality in their HW, uAvionix has extended a few of the unused MAVLink bits to pack in more new features
 * This function will override the usually-null ending char of the callsign. It always encodes the last byte [8], even if
 * the callsign string is less than 9 chars and there are other zero-padded nulls.
 */
uint8_t AP_ADSB_uAvionix_MAVLink::get_encoded_callsign_null_char()
{
//  Encoding of the 8bit null char
//  (LSB) - knots
//  bit.1 - knots
//  bit.2 - knots
//  bit.3 - (unused)
//  bit.4 - flag - ADSB_BITBASK_RF_CAPABILITIES_1090ES_IN
//  bit.5 - flag - ADSB_BITBASK_RF_CAPABILITIES_UAT_IN
//  bit.6 - flag - 0 = callsign is treated as callsign, 1 = callsign is treated as flightPlanID/Squawk
//  (MSB) - (unused)

    uint8_t encoded_null = 0;

    if (_frontend.out_state.cfg.maxAircraftSpeed_knots <= 0) {
        // not set or unknown. no bits set
    } else if (_frontend.out_state.cfg.maxAircraftSpeed_knots <= 75) {
        encoded_null |= 0x01;
    } else if (_frontend.out_state.cfg.maxAircraftSpeed_knots <= 150) {
        encoded_null |= 0x02;
    } else if (_frontend.out_state.cfg.maxAircraftSpeed_knots <= 300) {
        encoded_null |= 0x03;
    } else if (_frontend.out_state.cfg.maxAircraftSpeed_knots <= 600) {
        encoded_null |= 0x04;
    } else if (_frontend.out_state.cfg.maxAircraftSpeed_knots <= 1200) {
        encoded_null |= 0x05;
    } else {
        encoded_null |= 0x06;
    }


    if (_frontend.out_state.cfg.rf_capable & ADSB_BITBASK_RF_CAPABILITIES_1090ES_IN) {
        encoded_null |= 0x10;
    }
    if (_frontend.out_state.cfg.rf_capable & ADSB_BITBASK_RF_CAPABILITIES_UAT_IN) {
        encoded_null |= 0x20;
    }


    /*
    If the user has an 8 digit flightPlanID assigned from a filed flight plan, this should be assigned to FlightPlanID, (assigned by remote app)
    else if the user has an assigned squawk code from ATC this should be converted from 4 digit octal to 4 character alpha string and assigned to FlightPlanID,
    else if a tail number is known it should be set to the tail number of the aircraft, (assigned by remote app)
    else it should be left blank (all 0's)
     */

    // using the above logic, we must always assign the squawk. once we get configured
    // externally then get_encoded_callsign_null_char() stops getting called
    snprintf(_frontend.out_state.cfg.callsign, 5, "%04d", unsigned(_frontend.out_state.cfg.squawk_octal) & 0x1FFF);
    memset(&_frontend.out_state.cfg.callsign[4], 0, 5); // clear remaining 5 chars
    encoded_null |= 0x40;

    return encoded_null;
}

/*
 * populate and send MAVLINK_MSG_UAVIONIX_ADSB_OUT_CFG
 */
void AP_ADSB_uAvionix_MAVLink::send_configure(const mavlink_channel_t chan)
{
    // MAVLink spec says the 9 byte callsign field is 8 byte string with 9th byte as null.
    // Here we temporarily set some flags in that null char to signify the callsign
    // may be a flightplanID instead
    int8_t callsign[sizeof(_frontend.out_state.cfg.callsign)];
    uint32_t icao;

    memcpy(callsign, _frontend.out_state.cfg.callsign, sizeof(_frontend.out_state.cfg.callsign));

    if (_frontend.out_state.cfg.was_set_externally) {
        // take values as-is
        icao = _frontend.out_state.cfg.ICAO_id;
    } else {
        callsign[MAVLINK_MSG_UAVIONIX_ADSB_OUT_CFG_FIELD_CALLSIGN_LEN-1] = (int8_t)get_encoded_callsign_null_char();
        icao = encode_icao((uint32_t)_frontend.out_state.cfg.ICAO_id);
    }

    mavlink_msg_uavionix_adsb_out_cfg_send(
            chan,
            icao,
            (const char*)callsign,
            (uint8_t)_frontend.out_state.cfg.emitterType,
            (uint8_t)_frontend.out_state.cfg.lengthWidth,
            (uint8_t)_frontend.out_state.cfg.gpsOffsetLat,
            (uint8_t)_frontend.out_state.cfg.gpsOffsetLon,
            _frontend.out_state.cfg.stall_speed_cm,
            (uint8_t)_frontend.out_state.cfg.rfSelect);
}

#endif // HAL_ADSB_UAVIONIX_MAVLINK_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          #pragma once

/*
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include "AP_ADSB_Backend.h"

#if HAL_ADSB_UAVIONIX_MAVLINK_ENABLED
class AP_ADSB_uAvionix_MAVLink : public AP_ADSB_Backend {
public:
    using AP_ADSB_Backend::AP_ADSB_Backend;

    void update() override;

    // static detection function
    static bool detect();

private:
    // send static and dynamic data to ADSB transceiver
    void send_configure(const mavlink_channel_t chan);
    void send_dynamic_out(const mavlink_channel_t chan) const;

    // special helpers for uAvionix workarounds
    uint32_t encode_icao(const uint32_t icao_id) const;
    uint8_t get_encoded_callsign_null_char(void);
};
#endif // HAL_ADSB_ENABLED

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           /*
   Copyright (C) 2021  Kraus Hamdani Aerospace Inc. All rights reserved.

   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.

   Author: Tom Pittenger
 */

#include "AP_ADSB_uAvionix_UCP.h"

// This driver implements the UCP protocol from uAvionix which is a variant of the GDL90 protocol by Garmin
// https://uavionix.com/downloads/ping200X/uAvionix-UCP-Transponder-ICD-Rev-Q.pdf

#if HAL_ADSB_UCP_ENABLED

#include <AP_SerialManager/AP_SerialManager.h>
#include <GCS_MAVLink/GCS.h>
#include <AP_HAL/AP_HAL.h>
#include <AP_Math/AP_Math.h>
#include <AP_Math/crc.h>
#include <ctype.h>
#include <AP_Notify/AP_Notify.h>

extern const AP_HAL::HAL &hal;

#define AP_ADSB_UAVIONIX_HEALTH_TIMEOUT_MS                     (5000UL)

#define AP_ADSB_UAVIONIX_GCS_LOST_COMMS_LONG_TIMEOUT_MINUTES    (15UL)
#define AP_ADSB_UAVIONIX_GCS_LOST_COMMS_LONG_TIMEOUT_MS         (1000UL * 60UL * AP_ADSB_UAVIONIX_GCS_LOST_COMMS_LONG_TIMEOUT_MINUTES)

#define AP_ADSB_UAVIONIX_DETECT_GROUNDSTATE                     0
#define AP_ADSB_UAVIONIX_EMERGENCY_STATUS_ON_LOST_LINK          0

// detect if any port is configured as uAvionix_UCP
bool AP_ADSB_uAvionix_UCP::detect()
{
    return AP::serialmanager().have_serial(AP_SerialManager::SerialProtocol_ADSB, 0);
}


// Init, called once after class is constructed
bool AP_ADSB_uAvionix_UCP::init()
{
    _port = AP::serialmanager().find_serial(AP_SerialManager::SerialProtocol_ADSB, 0);
    if (_port == nullptr) {
        return false;
    }

    request_msg(GDL90_ID_IDENTIFICATION);
    request_msg(GDL90_ID_TRANSPONDER_CONFIG);
    return true;
}


void AP_ADSB_uAvionix_UCP::update()
{
    if (_port == nullptr) {
        return;
    }

    const uint32_t now_ms = AP_HAL::millis();

    // -----------------------------
    // read any available data on serial port
    // -----------------------------
    uint32_t nbytes = MIN(_port->available(), 10UL * GDL90_RX_MAX_PACKET_LENGTH);
    while (nbytes-- > 0) {
        uint8_t data;
        if (!_port->read(data)) {
            break;
        }
        if (parseByte(data, rx.msg, rx.status)) {
            rx.last_msg_ms = now_ms;
            handle_msg(rx.msg);
        }
    } // while nbytes

   if (now_ms - run_state.last_packet_Transponder_Control_ms >= 1000) {
        run_state.last_packet_Transponder_Control_ms = now_ms;
        send_Transponder_Control();
    }

    if ((now_ms - run_state.last_packet_GPS_ms >= 200) && (_frontend._options & uint32_t(AP_ADSB::AdsbOption::Ping200X_Send_GPS)) != 0) {
        run_state.last_packet_GPS_ms = now_ms;
        send_GPS_Data();
    }

    // if the transponder has stopped giving us the data needed to 
    // fill the transponder status mavlink message, reset that data.
    if ((now_ms - run_state.last_packet_Transponder_Status_ms >= 10000 && run_state.last_packet_Transponder_Status_ms != 0)
        && (now_ms - run_state.last_packet_Transponder_Heartbeat_ms >= 10000 && run_state.last_packet_Transponder_Heartbeat_ms != 0)
        && (now_ms - run_state.last_packet_Transponder_Ownship_ms >= 10000 && run_state.last_packet_Transponder_Ownship_ms != 0))
    {
        _frontend.out_state.tx_status.fault |= UAVIONIX_ADSB_OUT_STATUS_FAULT_STATUS_MESSAGE_UNAVAIL;
    }
}


void AP_ADSB_uAvionix_UCP::handle_msg(const GDL90_RX_MESSAGE &msg)
{
    switch(msg.messageId) {
    case GDL90_ID_HEARTBEAT: {
        // The Heartbeat message provides real-time indications of the status and operation of the
        // transponder. The message will be transmitted with a period of one second for the UCP
        // protocol.
        memcpy(&rx.decoded.heartbeat, msg.raw, sizeof(rx.decoded.heartbeat));
        run_state.last_packet_Transponder_Heartbeat_ms = AP_HAL::millis();

        // this is always true. The "ground/air bit place" is set meaning we're always in the air
        _frontend.out_state.tx_status.state |= UAVIONIX_ADSB_OUT_STATUS_STATE_ON_GROUND;

        if (rx.decoded.heartbeat.status.one.maintenanceRequired) {
            _frontend.out_state.tx_status.fault |= UAVIONIX_ADSB_OUT_STATUS_FAULT_MAINT_REQ;
        } else {
            _frontend.out_state.tx_status.fault &= ~UAVIONIX_ADSB_OUT_STATUS_FAULT_MAINT_REQ;
        }

        if (rx.decoded.heartbeat.status.two.functionFailureGnssUnavailable) {
            _frontend.out_state.tx_status.fault |= UAVIONIX_ADSB_OUT_STATUS_FAULT_GPS_UNAVAIL;
        } else {
            _frontend.out_state.tx_status.fault &= ~UAVIONIX_ADSB_OUT_STATUS_FAULT_GPS_UNAVAIL;
        }

        if (rx.decoded.heartbeat.status.two.functionFailureGnssNo3dFix) {
            _frontend.out_state.tx_status.fault |= UAVIONIX_ADSB_OUT_STATUS_FAULT_GPS_NO_POS;
        } else {
            _frontend.out_state.tx_status.fault &= ~UAVIONIX_ADSB_OUT_STATUS_FAULT_GPS_NO_POS;
        }

        if (rx.decoded.heartbeat.status.two.functionFailureTransmitSystem) {
            _frontend.out_state.tx_status.fault |= UAVIONIX_ADSB_OUT_STATUS_FAULT_TX_SYSTEM_FAIL;
        } else {
            _frontend.out_state.tx_status.fault &= ~UAVIONIX_ADSB_OUT_STATUS_FAULT_TX_SYSTEM_FAIL;
        }

        _frontend.out_state.tx_status.fault &= ~UAVIONIX_ADSB_OUT_STATUS_FAULT_STATUS_MESSAGE_UNAVAIL;

        }
        break;

    case GDL90_ID_IDENTIFICATION:
        // The Identification message contains information used to identify the connected device. The
        // Identification message will be transmitted with a period of one second regardless of data status
        // or update for the UCP protocol and will be transmitted upon request for the UCP-HD protocol.
        if (memcmp(&rx.decoded.identification, msg.raw, sizeof(rx.decoded.identification)) != 0) {
            memcpy(&rx.decoded.identification, msg.raw, sizeof(rx.decoded.identification));

            // Firmware Part Number (not null terminated, but null padded if part number is less than 15 characters).
            // Copy into a temporary string that is 1 char longer so we ensure it's null terminated
            const uint8_t str_len = sizeof(rx.decoded.identification.primaryFwPartNumber);
            char primaryFwPartNumber[str_len+1];
            memcpy(&primaryFwPartNumber, rx.decoded.identification.primaryFwPartNumber, str_len);
            primaryFwPartNumber[str_len] = 0;
            
            GCS_SEND_TEXT(MAV_SEVERITY_DEBUG,"ADSB:Detected %s v%u.%u.%u SN:%u %s",
                get_hardware_name(rx.decoded.identification.primary.hwId),
                (unsigned)rx.decoded.identification.primary.fwMajorVersion,
                (unsigned)rx.decoded.identification.primary.fwMinorVersion,
                (unsigned)rx.decoded.identification.primary.fwBuildVersion,
                (unsigned)rx.decoded.identification.primary.serialNumber,
                primaryFwPartNumber);
        }
        break;

    case GDL90_ID_TRANSPONDER_CONFIG:
        memcpy(&rx.decoded.transponder_config, msg.raw, sizeof(rx.decoded.transponder_config));
        break;

#if AP_ADSB_UAVIONIX_UCP_CAPTURE_ALL_RX_PACKETS
    case GDL90_ID_OWNSHIP_REPORT:
        // The Ownship message contains information on the GNSS position. If the Ownship GNSS
        // position fix is invalid, the Latitude, Longitude, and NIC fields will all have the ZERO value. The
        // Ownship message will be transmitted with a period of one second regardless of data status or
        // update for the UCP protocol. All fields in the ownship message are transmitted MSB first
        memcpy(&rx.decoded.ownship_report, msg.raw, sizeof(rx.decoded.ownship_report));
        run_state.last_packet_Transponder_Ownship_ms = AP_HAL::millis();
        _frontend.out_state.tx_status.NIC_NACp = rx.decoded.ownship_report.report.NIC | (rx.decoded.ownship_report.report.NACp << 4);
        memcpy(_frontend.out_state.tx_status.flight_id, rx.decoded.ownship_report.report.callsign, sizeof(_frontend.out_state.tx_status.flight_id));
        //_frontend.out_state.tx_status.temperature = rx.decoded.ownship_report.report.temperature; // there is no message in the vocabulary of the 200x that has board temperature
        break;

    case GDL90_ID_OWNSHIP_GEOMETRIC_ALTITUDE:
        // An Ownship Geometric Altitude message will be transmitted with a period of one second when
        // the GNSS fix is valid for the UCP protocol. All fields in the Geometric Ownship Altitude
        // message are transmitted MSB first.
        memcpy(&rx.decoded.ownship_geometric_altitude, msg.raw, sizeof(rx.decoded.ownship_geometric_altitude));
        break;

    case GDL90_ID_SENSOR_MESSAGE:
        memcpy(&rx.decoded.sensor_message, msg.raw, sizeof(rx.decoded.sensor_message));
        break;

    case GDL90_ID_TRANSPONDER_STATUS:
        memcpy(&rx.decoded.transponder_status, msg.raw, sizeof(rx.decoded.transponder_status));
        if (rx.decoded.transponder_status.identActive) {
            _frontend.out_state.tx_status.state |= UAVIONIX_ADSB_OUT_STATUS_STATE_IDENT_ACTIVE;
        } else {
            _frontend.out_state.tx_status.state &= ~UAVIONIX_ADSB_OUT_STATUS_STATE_IDENT_ACTIVE;
        }
        
        if (rx.decoded.transponder_status.modeAEnabled) {
            _frontend.out_state.tx_status.state |= UAVIONIX_ADSB_OUT_STATUS_STATE_MODE_A_ENABLED;
        } else {
            _frontend.out_state.tx_status.state &= ~UAVIONIX_ADSB_OUT_STATUS_STATE_MODE_A_ENABLED;
        }

        if (rx.decoded.transponder_status.modeCEnabled) {
            _frontend.out_state.tx_status.state |= UAVIONIX_ADSB_OUT_STATUS_STATE_MODE_C_ENABLED;
        } else {
            _frontend.out_state.tx_status.state &= ~UAVIONIX_ADSB_OUT_STATUS_STATE_MODE_C_ENABLED;
        }

        if (rx.decoded.transponder_status.modeSEnabled) {
            _frontend.out_state.tx_status.state |= UAVIONIX_ADSB_OUT_STATUS_STATE_MODE_S_ENABLED;
        } else {
            _frontend.out_state.tx_status.state &= ~UAVIONIX_ADSB_OUT_STATUS_STATE_MODE_S_ENABLED;
        }

        if (rx.decoded.transponder_status.es1090TxEnabled) {
            _frontend.out_state.tx_status.state |= UAVIONIX_ADSB_OUT_STATUS_STATE_1090ES_TX_ENABLED;
        } else {
            _frontend.out_state.tx_status.state &= ~UAVIONIX_ADSB_OUT_STATUS_STATE_1090ES_TX_ENABLED;
        }

        if (rx.decoded.transponder_status.x_bit) {
            _frontend.out_state.tx_status.state |= UAVIONIX_ADSB_OUT_STATUS_STATE_XBIT_ENABLED;
        } else {
            _frontend.out_state.tx_status.state &= ~UAVIONIX_ADSB_OUT_STATUS_STATE_XBIT_ENABLED;
        }

        _frontend.out_state.tx_status.squawk = rx.decoded.transponder_status.squawkCode;

        _frontend.out_state.tx_status.fault &= ~UAVIONIX_ADSB_OUT_STATUS_FAULT_STATUS_MESSAGE_UNAVAIL;

        if (run_state.last_packet_Transponder_Status_ms == 0) {
            // set initial control message contents to transponder defaults
            _frontend.out_state.ctrl.modeAEnabled = rx.decoded.transponder_status.modeAEnabled;
            _frontend.out_state.ctrl.modeCEnabled = rx.decoded.transponder_status.modeCEnabled;
            _frontend.out_state.ctrl.modeSEnabled = rx.decoded.transponder_status.modeSEnabled;
            _frontend.out_state.ctrl.es1090TxEnabled = rx.decoded.transponder_status.es1090TxEnabled;
            _frontend.out_state.ctrl.squawkCode = rx.decoded.transponder_status.squawkCode;
            _frontend.out_state.ctrl.x_bit = rx.decoded.transponder_status.x_bit;
        }
        run_state.last_packet_Transponder_Status_ms = AP_HAL::millis();
#if AP_MAVLINK_MSG_UAVIONIX_ADSB_OUT_STATUS_ENABLED
        GCS_SEND_MESSAGE(MSG_UAVIONIX_ADSB_OUT_STATUS);
#endif
        break;
#endif // AP_ADSB_UAVIONIX_UCP_CAPTURE_ALL_RX_PACKETS

    case GDL90_ID_TRANSPONDER_CONTROL:
    case GDL90_ID_GPS_DATA:
    case GDL90_ID_MESSAGE_REQUEST:
        // not handled, outbound only
        break;
    default:
        //GCS_SEND_TEXT(MAV_SEVERITY_DEBUG,"ADSB:Unknown msg %d", (int)msg.messageId);
        break;
    }
}


const char* AP_ADSB_uAvionix_UCP::get_hardware_name(const uint8_t hwId)
{
    switch(hwId) {
        case 0x09: return "Ping200s";
        case 0x0A: return "Ping20s";
        case 0x18: return "Ping200C";
        case 0x27: return "Ping20Z";
        case 0x2D: return "SkyBeaconX";             // (certified)
        case 0x26: //return "Ping200Z/Ping200X";    // (uncertified). Let's fallthrough and use Ping200X
        case 0x2F: return "Ping200X";               // (certified)
        case 0x30: return "TailBeaconX";            // (certified)
    } // switch hwId
    return "Unknown HW";
}

void AP_ADSB_uAvionix_UCP::send_Transponder_Control()
{
    GDL90_TRANSPONDER_CONTROL_MSG msg {};
    msg.messageId = GDL90_ID_TRANSPONDER_CONTROL;
    msg.version = GDL90_TRANSPONDER_CONTROL_VERSION;

#if CONFIG_HAL_BOARD == HAL_BOARD_SITL
    // when using the simulator, always declare we're on the ground to help
    // inhibit chaos if this ias actually being broadcasted on real hardware
    msg.airGroundState =  ADSB_ON_GROUND;
#elif AP_ADSB_UAVIONIX_DETECT_GROUNDSTATE
    msg.airGroundState =  _frontend.out_state.is_flying ? ADSB_AIRBORNE_SUBSONIC : ADSB_ON_GROUND;
#else
    msg.airGroundState = ADSB_AIRBORNE_SUBSONIC;
#endif

    msg.baroCrossChecked = ADSB_NIC_BARO_UNVERIFIED;
    msg.identActive = _frontend.out_state.ctrl.identActive;
    _frontend.out_state.ctrl.identActive = false; // only send identButtonActive once per request
    msg.modeAEnabled = _frontend.out_state.ctrl.modeAEnabled;
    msg.modeCEnabled = _frontend.out_state.ctrl.modeCEnabled;
    msg.modeSEnabled = _frontend.out_state.ctrl.modeSEnabled;
    msg.es1090TxEnabled = _frontend.out_state.ctrl.es1090TxEnabled;

    // if enabled via param ADSB_OPTIONS, use squawk 7400 while in any Loss-Comms related failsafe
    // https://www.faa.gov/documentLibrary/media/Notice/N_JO_7110.724_5-2-9_UAS_Lost_Link_2.pdf
    const AP_Notify& notify = AP::notify();
    if (((_frontend._options & uint32_t(AP_ADSB::AdsbOption::Squawk_7400_FS_RC)) && notify.flags.failsafe_radio) ||
        ((_frontend._options & uint32_t(AP_ADSB::AdsbOption::Squawk_7400_FS_GCS)) && notify.flags.failsafe_gcs)) {
        msg.squawkCode = 7400;
    } else {
        msg.squawkCode = _frontend.out_state.ctrl.squawkCode;
    }

#if AP_ADSB_UAVIONIX_EMERGENCY_STATUS_ON_LOST_LINK
    const uint32_t last_gcs_ms = gcs().sysid_myggcs_last_seen_time_ms();
    const bool gcs_lost_comms = (last_gcs_ms != 0) && (AP_HAL::millis() - last_gcs_ms > AP_ADSB_UAVIONIX_GCS_LOST_COMMS_LONG_TIMEOUT_MS);
    msg.emergencyState = gcs_lost_comms ? ADSB_EMERGENCY_STATUS::ADSB_EMERGENCY_UAS_LOST_LINK : ADSB_EMERGENCY_STATUS::ADSB_EMERGENCY_NONE;
#else
    msg.emergencyState = ADSB_EMERGENCY_STATUS::ADSB_EMERGENCY_NONE;
#endif

#if GDL90_TRANSPONDER_CONTROL_VERSION == 2
    msg.x_bit = 0;
#endif

    memcpy(msg.callsign, _frontend.out_state.ctrl.callsign, sizeof(msg.callsign));

    gdl90Transmit((GDL90_TX_MESSAGE&)msg, sizeof(msg));
}


void AP_ADSB_uAvionix_UCP::send_GPS_Data()
{
    GDL90_GPS_DATA_V2 msg {};
    msg.messageId = GDL90_ID_GPS_DATA;
    msg.version = 2;

    const AP_ADSB::Loc &gps { _frontend._my_loc };

    const GPS_FIX fix = (GPS_FIX)gps.status();
    const bool fix_is_good = (fix >= GPS_FIX_3D);
    const Vector3f velocity = fix_is_good ? gps.velocity() : Vector3f();

    msg.utcTime_s = gps.time_epoch_usec() * 1E-6;
    msg.latitude_ddE7 = fix_is_good ? _frontend._my_loc.lat : INT32_MAX;
    msg.longitude_ddE7 = fix_is_good ? _frontend._my_loc.lng : INT32_MAX;
    msg.altitudeGnss_mm = fix_is_good ? (_frontend._my_loc.alt * 10): INT32_MAX;

    // Protection Limits. FD or SBAS-based depending on state bits
    msg.HPL_mm = UINT32_MAX;
    msg.VPL_cm = UINT32_MAX;

    // Figure of Merits
    float accHoriz;
    msg.horizontalFOM_mm = gps.horizontal_accuracy(accHoriz) ? accHoriz * 1E3 : UINT32_MAX;
    float accVert;
    msg.verticalFOM_cm = gps.vertical_accuracy(accVert) ? accVert * 1E2 : UINT16_MAX;
    float accVel;
    msg.horizontalVelocityFOM_mmps = gps.speed_accuracy(accVel) ? accVel * 1E3 : UINT16_MAX;
    msg.verticalVelocityFOM_mmps = msg.horizontalVelocityFOM_mmps;

    // Velocities
    msg.verticalVelocity_cmps = fix_is_good ? -1.0f * velocity.z * 1E2 : INT16_MAX;
    msg.northVelocity_mmps = fix_is_good ? velocity.x * 1E3 : INT32_MAX;
    msg.eastVelocity_mmps = fix_is_good ? velocity.y * 1E3 : INT32_MAX;

    // State
    msg.fixType = fix;

    GDL90_GPS_NAV_STATE nav_state {};
    nav_state.HPLfdeActive = 1;
    nav_state.fault = 0;
    nav_state.HrdMagNorth = 0;  // 1 means "north" is magnetic north

    msg.navState = nav_state;
    msg.satsUsed = gps.num_sats();

    gdl90Transmit((GDL90_TX_MESSAGE&)msg, sizeof(msg));
}


bool AP_ADSB_uAvionix_UCP::hostTransmit(uint8_t *buffer, uint16_t length)
{
    if (_port == nullptr || _port->txspace() < length) {
      return false;
    }
    _port->write(buffer, length);
    return true;
}


bool AP_ADSB_uAvionix_UCP::request_msg(const GDL90_MESSAGE_ID msg_id)
{
    const GDL90_TRANSPONDER_MESSAGE_REQUEST_V2 msg = {
      messageId : GDL90_ID_MESSAGE_REQUEST,
      version   : 2,
      reqMsgId  : msg_id
    };
    return gdl90Transmit((GDL90_TX_MESSAGE&)msg, sizeof(msg)) != 0;
}


uint16_t AP_ADSB_uAvionix_UCP::gdl90Transmit(GDL90_TX_MESSAGE &message, const uint16_t length)
{
    uint8_t gdl90FrameBuffer[GDL90_TX_MAX_FRAME_LENGTH] {};

    const uint16_t frameCrc = crc16_ccitt_GDL90((uint8_t*)&message.raw, length, 0);

    // Set flag byte in frame buffer
    gdl90FrameBuffer[0] = GDL90_FLAG_BYTE;
    uint16_t frameIndex = 1;
    
    // Copy and stuff all payload bytes into frame buffer
    for (uint16_t i = 0; i < length+2; i++) {
        // Check for overflow of frame buffer
        if (frameIndex >= GDL90_TX_MAX_FRAME_LENGTH) {
            return 0;
        }
        
        uint8_t data;
        // Append CRC to payload
        if (i == length) {
            data = LOWBYTE(frameCrc);
        } else if (i == length+1) {
            data = HIGHBYTE(frameCrc);
        } else {
            data = message.raw[i];    
        }

        if (data == GDL90_FLAG_BYTE || data == GDL90_CONTROL_ESCAPE_BYTE) {
            // Check for frame buffer overflow on stuffed byte
            if (frameIndex + 2 > GDL90_TX_MAX_FRAME_LENGTH) {
              return 0;
            }
            
            // Set control break and stuff this byte
            gdl90FrameBuffer[frameIndex++] = GDL90_CONTROL_ESCAPE_BYTE;
            gdl90FrameBuffer[frameIndex++] = data ^ GDL90_STUFF_BYTE;
        } else {
            gdl90FrameBuffer[frameIndex++] = data;
        }
    }
    
    // Add end of frame indication
    gdl90FrameBuffer[frameIndex++] = GDL90_FLAG_BYTE;

    // Push packet to UART
    if (hostTransmit(gdl90FrameBuffer, frameIndex)) {
        return frameIndex;
    }
    
    return 0;
}


bool AP_ADSB_uAvionix_UCP::parseByte(const uint8_t data, GDL90_RX_MESSAGE &msg, GDL90_RX_STATUS &status)
{
    switch (status.state)
    {
    case GDL90_RX_IDLE:
        if (data == GDL90_FLAG_BYTE && status.prev_data == GDL90_FLAG_BYTE) {
            status.length = 0;
            status.state = GDL90_RX_IN_PACKET;
        }
        break;

    case GDL90_RX_IN_PACKET:
        if (data == GDL90_CONTROL_ESCAPE_BYTE) {
            status.state = GDL90_RX_UNSTUFF;

        } else if (data == GDL90_FLAG_BYTE) {
            // packet complete! Check CRC and restart packet cycle on all pass or fail scenarios
            status.state = GDL90_RX_IDLE;

            if (status.length < GDL90_OVERHEAD_LENGTH) {
                // something is wrong, there's no actual data
                return false;
            }

            const uint8_t crc_LSB = msg.raw[status.length - 2];
            const uint8_t crc_MSB = msg.raw[status.length - 1];

            // NOTE: status.length contains messageId, payload and CRC16. So status.length-3 is effective payload length
            msg.crc = (uint16_t)crc_LSB | ((uint16_t)crc_MSB << 8);
            const uint16_t crc = crc16_ccitt_GDL90((uint8_t*)&msg.raw, status.length-2, 0);
            if (crc == msg.crc) {
                status.prev_data = data;
                // NOTE: this is the only path that returns true
                return true;
            }

        } else if (status.length < GDL90_RX_MAX_PACKET_LENGTH) {
            msg.raw[status.length++] = data;

        } else {
            status.state = GDL90_RX_IDLE;
        }
        break;

    case GDL90_RX_UNSTUFF:
        msg.raw[status.length++] = data ^ GDL90_STUFF_BYTE;
        status.state = GDL90_RX_IN_PACKET;
        break;
    }
    status.prev_data = data;
    return false;
}

#endif // HAL_ADSB_UCP_ENABLED

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       /*
   Copyright (C) 2021  Kraus Hamdani Aerospace Inc. All rights reserved.

   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.

   Author: Tom Pittenger
 */

#pragma once
#include "AP_ADSB_Backend.h"

#if HAL_ADSB_UCP_ENABLED

#define AP_ADSB_UAVIONIX_UCP_CAPTURE_ALL_RX_PACKETS         1


#include <AP_GPS/AP_GPS.h>
#include <AP_Baro/AP_Baro.h>
#include <AP_AHRS/AP_AHRS.h>

#include "GDL90_protocol/GDL90_Message_Structs.h"
#include "GDL90_protocol/hostGDL90Support.h"

class AP_ADSB_uAvionix_UCP : public AP_ADSB_Backend {
public:
    using AP_ADSB_Backend::AP_ADSB_Backend;

    // init - performs any required initialisation for this instance
    bool init() override;

    // update - should be called periodically
    void update() override;

    // static detection function
    static bool detect();

private:

    void handle_msg(const GDL90_RX_MESSAGE &msg);
    bool request_msg(const GDL90_MESSAGE_ID msg_id);

    void send_GPS_Data();
    void send_Transponder_Control();
    const char* get_hardware_name(const uint8_t hwId);

    bool hostTransmit(uint8_t *buffer, uint16_t length);
    uint16_t gdl90Transmit(GDL90_TX_MESSAGE &message, const uint16_t length);
    static bool parseByte(const uint8_t data, GDL90_RX_MESSAGE &msg, GDL90_RX_STATUS &status);

    struct {
        uint32_t last_msg_ms;
        GDL90_RX_MESSAGE msg;
        GDL90_RX_STATUS status;

        // cache local copies so we always have the latest info of everything.
        struct {
            GDL90_IDENTIFICATION_V3 identification;
            GDL90_TRANSPONDER_CONFIG_MSG_V4_V5 transponder_config;
            GDL90_HEARTBEAT heartbeat;
            GDL90_TRANSPONDER_STATUS_MSG transponder_status;
#if AP_ADSB_UAVIONIX_UCP_CAPTURE_ALL_RX_PACKETS
            GDL90_OWNSHIP_REPORT ownship_report;
            GDL90_OWNSHIP_GEO_ALTITUDE ownship_geometric_altitude;
            GDL90_SENSOR_BARO_MESSAGE sensor_message;
#endif
        } decoded;
    } rx;

    struct {
        uint32_t last_packet_GPS_ms;
        uint32_t last_packet_Transponder_Control_ms;
        uint32_t last_packet_Transponder_Status_ms;
        uint32_t last_packet_Transponder_Heartbeat_ms;
        uint32_t last_packet_Transponder_Ownship_ms;
    } run_state;

};
#endif // HAL_ADSB_UCP_ENABLED

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     /*
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/*
 *  NavEKF based AHRS (Attitude Heading Reference System) interface for
 *  ArduPilot
 *
 */

#include "AP_AHRS_config.h"

#if AP_AHRS_ENABLED

#include <AP_HAL/AP_HAL.h>
#include "AP_AHRS.h"
#include "AP_AHRS_View.h"
#include <AP_BoardConfig/AP_BoardConfig.h>
#include <AP_ExternalAHRS/AP_ExternalAHRS.h>
#include <AP_Module/AP_Module.h>
#include <AP_GPS/AP_GPS.h>
#include <AP_Baro/AP_Baro.h>
#include <AP_Compass/AP_Compass.h>
#include <AP_InternalError/AP_InternalError.h>
#include <AP_Logger/AP_Logger.h>
#include <AP_Notify/AP_Notify.h>
#include <AP_Vehicle/AP_Vehicle_Type.h>
#include <GCS_MAVLink/GCS.h>
#include <AP_InertialSensor/AP_InertialSensor.h>
#include <AP_CustomRotations/AP_CustomRotations.h>
#if CONFIG_HAL_BOARD == HAL_BOARD_SITL
#include <SITL/SITL.h>
#endif

#define ATTITUDE_CHECK_THRESH_ROLL_PITCH_RAD radians(10)
#define ATTITUDE_CHECK_THRESH_YAW_RAD radians(20)

#ifndef HAL_AHRS_EKF_TYPE_DEFAULT
#define HAL_AHRS_EKF_TYPE_DEFAULT 3
#endif

// table of user settable parameters
const AP_Param::GroupInfo AP_AHRS::var_info[] = {
    // index 0 and 1 are for old parameters that are no longer not used

    // @Param: GPS_GAIN
    // @DisplayName: AHRS GPS gain
    // @Description: This controls how much to use the GPS to correct the attitude. This should never be set to zero for a plane as it would result in the plane losing control in turns. For a plane please use the default value of 1.0.
    // @Range: 0.0 1.0
    // @Increment: .01
    // @User: Advanced
    AP_GROUPINFO("GPS_GAIN",  2, AP_AHRS, gps_gain, 1.0f),

    // @Param: GPS_USE
    // @DisplayName: AHRS use GPS for DCM navigation and position-down
    // @Description: This controls whether to use dead-reckoning or GPS based navigation. If set to 0 then the GPS won't be used for navigation, and only dead reckoning will be used. A value of zero should never be used for normal flight. Currently this affects only the DCM-based AHRS: the EKF uses GPS according to its own parameters. A value of 2 means to use GPS for height as well as position - both in DCM estimation and when determining altitude-above-home.
    // @Values: 0:Disabled,1:Use GPS for DCM position,2:Use GPS for DCM position and height
    // @User: Advanced
    AP_GROUPINFO("GPS_USE",  3, AP_AHRS, _gps_use, float(GPSUse::Enable)),

    // @Param: YAW_P
    // @DisplayName: Yaw P
    // @Description: This controls the weight the compass or GPS has on the heading. A higher value means the heading will track the yaw source (GPS or compass) more rapidly.
    // @Range: 0.1 0.4
    // @Increment: .01
    // @User: Advanced
    AP_GROUPINFO("YAW_P", 4,    AP_AHRS, _kp_yaw, 0.2f),

    // @Param: RP_P
    // @DisplayName: AHRS RP_P
    // @Description: This controls how fast the accelerometers correct the attitude
    // @Range: 0.1 0.4
    // @Increment: .01
    // @User: Advanced
    AP_GROUPINFO("RP_P",  5,    AP_AHRS, _kp, 0.2f),

    // @Param: WIND_MAX
    // @DisplayName: Maximum wind
    // @Description: This sets the maximum allowable difference between ground speed and airspeed. A value of zero means to use the airspeed as is. This allows the plane to cope with a failing airspeed sensor by clipping it to groundspeed plus/minus this limit. See ARSPD_OPTIONS and ARSPD_WIND_MAX to disable airspeed sensors.
    // @Range: 0 127
    // @Units: m/s
    // @Increment: 1
    // @User: Advanced
    AP_GROUPINFO("WIND_MAX",  6,    AP_AHRS, _wind_max, 0.0f),

    // NOTE: 7 was BARO_USE

    // @Param: TRIM_X
    // @DisplayName: AHRS Trim Roll
    // @Description: Compensates for the roll angle difference between the control board and the frame. Positive values make the vehicle roll right.
    // @Units: rad
    // @Range: -0.1745 +0.1745
    // @Increment: 0.01
    // @User: Standard

    // @Param: TRIM_Y
    // @DisplayName: AHRS Trim Pitch
    // @Description: Compensates for the pitch angle difference between the control board and the frame. Positive values make the vehicle pitch up/back.
    // @Units: rad
    // @Range: -0.1745 +0.1745
    // @Increment: 0.01
    // @User: Standard

    // @Param: TRIM_Z
    // @DisplayName: AHRS Trim Yaw
    // @Description: Not Used
    // @Units: rad
    // @Range: -0.1745 +0.1745
    // @Increment: 0.01
    // @User: Advanced
    AP_GROUPINFO("TRIM", 8, AP_AHRS, _trim, 0),

    // @Param: ORIENTATION
    // @DisplayName: Board Orientation
    // @Description: Overall board orientation relative to the standard orientation for the board type. This rotates the IMU and compass readings to allow the board to be oriented in your vehicle at any 90 or 45 degree angle. The label for each option is specified in the order of rotations for that orientation. This option takes affect on next boot. After changing you will need to re-level your vehicle. Firmware versions 4.2 and prior can use a CUSTOM (100) rotation to set the AHRS_CUSTOM_ROLL/PIT/YAW angles for AHRS orientation. Later versions provide two general custom rotations which can be used, Custom 1 and Custom 2, with CUST_ROT1_ROLL/PIT/YAW or CUST_ROT2_ROLL/PIT/YAW angles.
    // @Values: 0:None,1:Yaw45,2:Yaw90,3:Yaw135,4:Yaw180,5:Yaw225,6:Yaw270,7:Yaw315,8:Roll180,9:Yaw45Roll180,10:Yaw90Roll180,11:Yaw135Roll180,12:Pitch180,13:Yaw225Roll180,14:Yaw270Roll180,15:Yaw315Roll180,16:Roll90,17:Yaw45Roll90,18:Yaw90Roll90,19:Yaw135Roll90,20:Roll270,21:Yaw45Roll270,22:Yaw90Roll270,23:Yaw135Roll270,24:Pitch90,25:Pitch270,26:Yaw90Pitch180,27:Yaw270Pitch180,28:Pitch90Roll90,29:Pitch90Roll180,30:Pitch90Roll270,31:Pitch180Roll90,32:Pitch180Roll270,33:Pitch270Roll90,34:Pitch270Roll180,35:Pitch270Roll270,36:Yaw90Pitch180Roll90,37:Yaw270Roll90,38:Yaw293Pitch68Roll180,39:Pitch315,40:Pitch315Roll90,42:Roll45,43:Roll315,100:Custom 4.1 and older,101:Custom 1,102:Custom 2
    // @User: Advanced
    AP_GROUPINFO("ORIENTATION", 9, AP_AHRS, _board_orientation, 0),

    // @Param: COMP_BETA
    // @DisplayName: AHRS Velocity Complementary Filter Beta Coefficient
    // @Description: This controls the time constant for the cross-over frequency used to fuse AHRS (airspeed and heading) and GPS data to estimate ground velocity. Time constant is 0.1/beta. A larger time constant will use GPS data less and a small time constant will use air data less.
    // @Range: 0.001 0.5
    // @Increment: .01
    // @User: Advanced
    AP_GROUPINFO("COMP_BETA",  10, AP_AHRS, beta, 0.1f),

    // @Param: GPS_MINSATS
    // @DisplayName: AHRS GPS Minimum satellites
    // @Description: Minimum number of satellites visible to use GPS for velocity based corrections attitude correction. This defaults to 6, which is about the point at which the velocity numbers from a GPS become too unreliable for accurate correction of the accelerometers.
    // @Range: 0 10
    // @Increment: 1
    // @User: Advanced
    AP_GROUPINFO("GPS_MINSATS", 11, AP_AHRS, _gps_minsats, 6),

    // NOTE: index 12 was for GPS_DELAY, but now removed, fixed delay
    // of 1 was found to be the best choice

    // 13 was the old EKF_USE

    // @Param: EKF_TYPE
    // @DisplayName: Use NavEKF Kalman filter for attitude and position estimation
    // @Description: This controls which NavEKF Kalman filter version is used for attitude and position estimation
    // @Values: 0:Disabled,2:Enable EKF2,3:Enable EKF3,11:ExternalAHRS
    // @User: Advanced
    AP_GROUPINFO("EKF_TYPE",  14, AP_AHRS, _ekf_type, HAL_AHRS_EKF_TYPE_DEFAULT),

    // @Param: CUSTOM_ROLL
    // @DisplayName: Board orientation roll offset
    // @Description: Autopilot mounting position roll offset. Positive values = roll right, negative values = roll left. This parameter is only used when AHRS_ORIENTATION is set to CUSTOM.
    // @Range: -180 180
    // @Units: deg
    // @Increment: 1
    // @User: Advanced

    // index 15

    // @Param: CUSTOM_PIT
    // @DisplayName: Board orientation pitch offset
    // @Description: Autopilot mounting position pitch offset. Positive values = pitch up, negative values = pitch down. This parameter is only used when AHRS_ORIENTATION is set to CUSTOM.
    // @Range: -180 180
    // @Units: deg
    // @Increment: 1
    // @User: Advanced

    // index 16

    // @Param: CUSTOM_YAW
    // @DisplayName: Board orientation yaw offset
    // @Description: Autopilot mounting position yaw offset. Positive values = yaw right, negative values = yaw left. This parameter is only used when AHRS_ORIENTATION is set to CUSTOM.
    // @Range: -180 180
    // @Units: deg
    // @Increment: 1
    // @User: Advanced

    // index 17

    // @Param: OPTIONS
    // @DisplayName: Optional AHRS behaviour
    // @Description: This controls optional AHRS behaviour. Setting DisableDCMFallbackFW will change the AHRS behaviour for fixed wing aircraft in fly-forward flight to not fall back to DCM when the EKF stops navigating. Setting DisableDCMFallbackVTOL will change the AHRS behaviour for fixed wing aircraft in non fly-forward (VTOL) flight to not fall back to DCM when the EKF stops navigating. 
    // @Bitmask: 0:DisableDCMFallbackFW, 1:DisableDCMFallbackVTOL
    // @User: Advanced
    AP_GROUPINFO("OPTIONS",  18, AP_AHRS, _options, 0),
    
    AP_GROUPEND
};

extern const AP_HAL::HAL& hal;

// constructor
AP_AHRS::AP_AHRS(uint8_t flags) :
    _ekf_flags(flags)
{
    _singleton = this;

    // load default values from var_info table
    AP_Param::setup_object_defaults(this, var_info);

#if APM_BUILD_COPTER_OR_HELI || APM_BUILD_TYPE(APM_BUILD_ArduSub)
    // Copter and Sub force the use of EKF
    _ekf_flags |= AP_AHRS::FLAG_ALWAYS_USE_EKF;
#endif
    state.dcm_matrix.identity();

    // initialise the controller-to-autopilot-body trim state:
    _last_trim = _trim.get();
    _rotation_autopilot_body_to_vehicle_body.from_euler(_last_trim.x, _last_trim.y, _last_trim.z);
    _rotation_vehicle_body_to_autopilot_body = _rotation_autopilot_body_to_vehicle_body.transposed();
}

// init sets up INS board orientation
void AP_AHRS::init()
{
    // EKF1 is no longer supported - handle case where it is selected
    if (_ekf_type.get() == 1) {
        AP_BoardConfig::config_error("EKF1 not available");
    }
#if !HAL_NAVEKF2_AVAILABLE && HAL_NAVEKF3_AVAILABLE
    if (_ekf_type.get() == 2) {
        _ekf_type.set(EKFType::THREE);
        EKF3.set_enable(true);
    }
#elif !HAL_NAVEKF3_AVAILABLE && HAL_NAVEKF2_AVAILABLE
    if (_ekf_type.get() == 3) {
        _ekf_type.set(EKFType::TWO);
        EKF2.set_enable(true);
    }
#endif

#if HAL_NAVEKF2_AVAILABLE && HAL_NAVEKF3_AVAILABLE
    // a special case to catch users who had AHRS_EKF_TYPE=2 saved and
    // updated to a version where EK2_ENABLE=0
    if (_ekf_type.get() == 2 && !EKF2.get_enable() && EKF3.get_enable()) {
        _ekf_type.set(EKFType::THREE);
    }
#endif

    last_active_ekf_type = (EKFType)_ekf_type.get();

    // init backends
#if AP_AHRS_DCM_ENABLED
    dcm.init();
#endif
#if AP_AHRS_EXTERNAL_ENABLED
    external.init();
#endif

#if AP_CUSTOMROTATIONS_ENABLED
    // convert to new custom rotation
    // PARAMETER_CONVERSION - Added: Nov-2021
    if (_board_orientation == ROTATION_CUSTOM_OLD) {
        _board_orientation.set_and_save(ROTATION_CUSTOM_1);
        AP_Param::ConversionInfo info;
        if (AP_Param::find_top_level_key_by_pointer(this, info.old_key)) {
            info.type = AP_PARAM_FLOAT;
            float rpy[3] = {};
            AP_Float rpy_param;
            for (info.old_group_element=15; info.old_group_element<=17; info.old_group_element++) {
                if (AP_Param::find_old_parameter(&info, &rpy_param)) {
                    rpy[info.old_group_element-15] = rpy_param.get();
                }
            }
            AP::custom_rotations().convert(ROTATION_CUSTOM_1, rpy[0], rpy[1], rpy[2]);
        }
    }
#endif  // AP_CUSTOMROTATIONS_ENABLED
}

// updates matrices responsible for rotating vectors from vehicle body
// frame to autopilot body frame from _trim variables
void AP_AHRS::update_trim_rotation_matrices()
{
    if (_last_trim == _trim.get()) {
        // nothing to do
        return;
    }

    _last_trim = _trim.get();
    _rotation_autopilot_body_to_vehicle_body.from_euler(_last_trim.x, _last_trim.y, _last_trim.z);
    _rotation_vehicle_body_to_autopilot_body = _rotation_autopilot_body_to_vehicle_body.transposed();
}

// return a Quaternion representing our current attitude in NED frame
void AP_AHRS::get_quat_body_to_ned(Quaternion &quat) const
{
    quat.from_rotation_matrix(get_rotation_body_to_ned());
}

// convert a vector from body to earth frame
Vector3f AP_AHRS::body_to_earth(const Vector3f &v) const
{
    return get_rotation_body_to_ned() * v;
}

// convert a vector from earth to body frame
Vector3f AP_AHRS::earth_to_body(const Vector3f &v) const
{
    return get_rotation_body_to_ned().mul_transpose(v);
}


// reset the current gyro drift estimate
//  should be called if gyro offsets are recalculated
void AP_AHRS::reset_gyro_drift(void)
{
    // support locked access functions to AHRS data
    WITH_SEMAPHORE(_rsem);
    
    // update DCM
#if AP_AHRS_DCM_ENABLED
    dcm.reset_gyro_drift();
#endif
#if AP_AHRS_EXTERNAL_ENABLED
    external.reset_gyro_drift();
#endif

    // reset the EKF gyro bias states
#if HAL_NAVEKF2_AVAILABLE
    EKF2.resetGyroBias();
#endif
#if HAL_NAVEKF3_AVAILABLE
    EKF3.resetGyroBias();
#endif
}

/*
  update state structure after each update()
 */
void AP_AHRS::update_state(void)
{
    state.primary_IMU = _get_primary_IMU_index();
    state.primary_gyro = _get_primary_gyro_index();
    state.primary_accel = _get_primary_accel_index();
    state.primary_core = _get_primary_core_index();
    state.wind_estimate_ok = _wind_estimate(state.wind_estimate);
    state.EAS2TAS = AP_AHRS_Backend::get_EAS2TAS();
    state.airspeed_ok = _airspeed_estimate(state.airspeed, state.airspeed_estimate_type);
    state.airspeed_true_ok = _airspeed_estimate_true(state.airspeed_true);
    state.airspeed_vec_ok = _airspeed_vector_true(state.airspeed_vec);
    state.quat_ok = _get_quaternion(state.quat);
    state.secondary_attitude_ok = _get_secondary_attitude(state.secondary_attitude);
    state.secondary_quat_ok = _get_secondary_quaternion(state.secondary_quat);
    state.location_ok = _get_location(state.location);
    state.secondary_pos_ok = _get_secondary_position(state.secondary_pos);
    state.ground_speed_vec = _groundspeed_vector();
    state.ground_speed = _groundspeed();
    _getCorrectedDeltaVelocityNED(state.corrected_dv, state.corrected_dv_dt);
    state.origin_ok = _get_origin(state.origin);
    state.velocity_NED_ok = _get_velocity_NED(state.velocity_NED);
}

void AP_AHRS::update(bool skip_ins_update)
{
    // periodically checks to see if we should update the AHRS
    // orientation (e.g. based on the AHRS_ORIENTATION parameter)
    // allow for runtime change of orientation
    // this makes initial config easier
    update_orientation();

    if (!skip_ins_update) {
        // tell the IMU to grab some data
        AP::ins().update();
    }

    // support locked access functions to AHRS data
    WITH_SEMAPHORE(_rsem);

    // see if we have to restore home after a watchdog reset:
    if (!_checked_watchdog_home) {
        load_watchdog_home();
        _checked_watchdog_home = true;
    }

    // drop back to normal priority if we were boosted by the INS
    // calling delay_microseconds_boost()
    hal.scheduler->boost_end();

    // update autopilot-body-to-vehicle-body from _trim parameters:
    update_trim_rotation_matrices();

#if AP_AHRS_DCM_ENABLED
    update_DCM();
#endif

    // update takeoff/touchdown flags
    update_flags();

#if AP_AHRS_SIM_ENABLED
    update_SITL();
#endif

#if AP_AHRS_EXTERNAL_ENABLED
    update_external();
#endif
    
    if (_ekf_type == 2) {
        // if EK2 is primary then run EKF2 first to give it CPU
        // priority
#if HAL_NAVEKF2_AVAILABLE
        update_EKF2();
#endif
#if HAL_NAVEKF3_AVAILABLE
        update_EKF3();
#endif
    } else {
        // otherwise run EKF3 first
#if HAL_NAVEKF3_AVAILABLE
        update_EKF3();
#endif
#if HAL_NAVEKF2_AVAILABLE
        update_EKF2();
#endif
    }

#if AP_MODULE_SUPPORTED
    // call AHRS_update hook if any
    AP_Module::call_hook_AHRS_update(*this);
#endif

    // push gyros if optical flow present
    if (hal.opticalflow) {
        const Vector3f &exported_gyro_bias = get_gyro_drift();
        hal.opticalflow->push_gyro_bias(exported_gyro_bias.x, exported_gyro_bias.y);
    }

    if (_view != nullptr) {
        // update optional alternative attitude view
        _view->update();
    }

    // update AOA and SSA
    update_AOA_SSA();

#if HAL_GCS_ENABLED
    state.active_EKF = _active_EKF_type();
    if (state.active_EKF != last_active_ekf_type) {
        last_active_ekf_type = state.active_EKF;
        const char *shortname = "???";
        switch ((EKFType)state.active_EKF) {
#if AP_AHRS_DCM_ENABLED
        case EKFType::DCM:
            shortname = "DCM";
            break;
#endif
#if AP_AHRS_SIM_ENABLED
        case EKFType::SIM:
            shortname = "SIM";
            break;
#endif
#if AP_AHRS_EXTERNAL_ENABLED
        case EKFType::EXTERNAL:
            shortname = "External";
            break;
#endif
#if HAL_NAVEKF3_AVAILABLE
        case EKFType::THREE:
            shortname = "EKF3";
            break;
#endif
#if HAL_NAVEKF2_AVAILABLE
        case EKFType::TWO:
            shortname = "EKF2";
            break;
#endif
        }
        GCS_SEND_TEXT(MAV_SEVERITY_INFO, "AHRS: %s active", shortname);
    }
#endif // HAL_GCS_ENABLED

    // update published state
    update_state();

#if CONFIG_HAL_BOARD == HAL_BOARD_SITL
    /*
      add timing jitter to simulate slow EKF response
     */
    const auto *sitl = AP::sitl();
    if (sitl->loop_time_jitter_us > 0) {
        hal.scheduler->delay_microseconds(random() % sitl->loop_time_jitter_us);
    }
#endif
}

/*
 * copy results from a backend over AP_AHRS canonical results.
 * This updates member variables like roll and pitch, as well as
 * updating derived values like sin_roll and sin_pitch.
 */
void AP_AHRS::copy_estimates_from_backend_estimates(const AP_AHRS_Backend::Estimates &results)
{
    roll = results.roll_rad;
    pitch = results.pitch_rad;
    yaw = results.yaw_rad;

    state.dcm_matrix = results.dcm_matrix;

    state.gyro_estimate = results.gyro_estimate;
    state.gyro_drift = results.gyro_drift;

    state.accel_ef = results.accel_ef;
    state.accel_bias = results.accel_bias;

    update_cd_values();
    update_trig();
}

#if AP_AHRS_DCM_ENABLED
void AP_AHRS::update_DCM()
{
    dcm.update();
    dcm.get_results(dcm_estimates);

    // we always update the vehicle's canonical roll/pitch/yaw from
    // DCM.  In normal operation this will usually be over-written by
    // an EKF or external AHRS.  This is long-held behaviour, but this
    // really shouldn't be doing this.

    // if (active_EKF_type() == EKFType::DCM) {
        copy_estimates_from_backend_estimates(dcm_estimates);
    // }
}
#endif

#if AP_AHRS_SIM_ENABLED
void AP_AHRS::update_SITL(void)
{
    sim.update();
    sim.get_results(sim_estimates);

    if (_active_EKF_type() == EKFType::SIM) {
        copy_estimates_from_backend_estimates(sim_estimates);
    }
}
#endif

void AP_AHRS::update_notify_from_filter_status(const nav_filter_status &status)
{
    AP_Notify::flags.gps_fusion = status.flags.using_gps; // Drives AP_Notify flag for usable GPS.
    AP_Notify::flags.gps_glitching = status.flags.gps_glitching;
    AP_Notify::flags.have_pos_abs = status.flags.horiz_pos_abs;
}

#if HAL_NAVEKF2_AVAILABLE
void AP_AHRS::update_EKF2(void)
{
    if (!_ekf2_started) {
        // wait 1 second for DCM to output a valid tilt error estimate
        if (start_time_ms == 0) {
            start_time_ms = AP_HAL::millis();
        }
#if HAL_LOGGING_ENABLED
        // if we're doing Replay logging then don't allow any data
        // into the EKF yet.  Don't allow it to block us for long.
        if (!hal.util->was_watchdog_reset()) {
            if (AP_HAL::millis() - start_time_ms < 5000) {
                if (!AP::logger().allow_start_ekf()) {
                    return;
                }
            }
        }
#endif

        if (AP_HAL::millis() - start_time_ms > startup_delay_ms) {
            _ekf2_started = EKF2.InitialiseFilter();
        }
    }
    if (_ekf2_started) {
        EKF2.UpdateFilter();
        if (_active_EKF_type() == EKFType::TWO) {
            Vector3f eulers;
            EKF2.getRotationBodyToNED(state.dcm_matrix);
            EKF2.getEulerAngles(eulers);
            roll  = eulers.x;
            pitch = eulers.y;
            yaw   = eulers.z;

            update_cd_values();
            update_trig();

            // Use the primary EKF to select the primary gyro
            const AP_InertialSensor &_ins = AP::ins();
            const int8_t primary_imu = EKF2.getPrimaryCoreIMUIndex();
            const uint8_t primary_gyro = primary_imu>=0?primary_imu:_ins.get_first_usable_gyro();
            const uint8_t primary_accel = primary_imu>=0?primary_imu:_ins.get_first_usable_accel();

            // get gyro bias for primary EKF and change sign to give gyro drift
            // Note sign convention used by EKF is bias = measurement - truth
            Vector3f drift;
            EKF2.getGyroBias(drift);
            state.gyro_drift = -drift;

            // use the same IMU as the primary EKF and correct for gyro drift
            state.gyro_estimate = _ins.get_gyro(primary_gyro) + state.gyro_drift;

            // get z accel bias estimate from active EKF (this is usually for the primary IMU)
            float &abias = state.accel_bias.z;
            EKF2.getAccelZBias(abias);

            // This EKF is currently using primary_imu, and a bias applies to only that IMU
            Vector3f accel = _ins.get_accel(primary_accel);
            accel.z -= abias;
            state.accel_ef = state.dcm_matrix * get_rotation_autopilot_body_to_vehicle_body() * accel;

            nav_filter_status filt_state;
            EKF2.getFilterStatus(filt_state);
            update_notify_from_filter_status(filt_state);
        }
    }
}
#endif

#if HAL_NAVEKF3_AVAILABLE
void AP_AHRS::update_EKF3(void)
{
    if (!_ekf3_started) {
        // wait 1 second for DCM to output a valid tilt error estimate
        if (start_time_ms == 0) {
            start_time_ms = AP_HAL::millis();
        }
#if HAL_LOGGING_ENABLED
        // if we're doing Replay logging then don't allow any data
        // into the EKF yet.  Don't allow it to block us for long.
        if (!hal.util->was_watchdog_reset()) {
            if (AP_HAL::millis() - start_time_ms < 5000) {
                if (!AP::logger().allow_start_ekf()) {
                    return;
                }
            }
        }
#endif
        if (AP_HAL::millis() - start_time_ms > startup_delay_ms) {
            _ekf3_started = EKF3.InitialiseFilter();
        }
    }
    if (_ekf3_started) {
        EKF3.UpdateFilter();
        if (_active_EKF_type() == EKFType::THREE) {
            Vector3f eulers;
            EKF3.getRotationBodyToNED(state.dcm_matrix);
            EKF3.getEulerAngles(eulers);
            roll  = eulers.x;
            pitch = eulers.y;
            yaw   = eulers.z;

            update_cd_values();
            update_trig();

            const AP_InertialSensor &_ins = AP::ins();

            // Use the primary EKF to select the primary gyro
            const int8_t primary_imu = EKF3.getPrimaryCoreIMUIndex();
            const uint8_t primary_gyro = primary_imu>=0?primary_imu:_ins.get_first_usable_gyro();
            const uint8_t primary_accel = primary_imu>=0?primary_imu:_ins.get_first_usable_accel();

            // get gyro bias for primary EKF and change sign to give gyro drift
            // Note sign convention used by EKF is bias = measurement - truth
            Vector3f drift;
            EKF3.getGyroBias(-1, drift);
            state.gyro_drift = -drift;

            // use the same IMU as the primary EKF and correct for gyro drift
            state.gyro_estimate = _ins.get_gyro(primary_gyro) + state.gyro_drift;

            // get 3-axis accel bias estimates for active EKF (this is usually for the primary IMU)
            Vector3f &abias = state.accel_bias;
            EKF3.getAccelBias(-1,abias);

            // use the primary IMU for accel earth frame
            Vector3f accel = _ins.get_accel(primary_accel);
            accel -= abias;
            state.accel_ef = state.dcm_matrix * get_rotation_autopilot_body_to_vehicle_body() * accel;

            nav_filter_status filt_state;
            EKF3.getFilterStatus(filt_state);
            update_notify_from_filter_status(filt_state);
        }
    }
}
#endif

#if AP_AHRS_EXTERNAL_ENABLED
void AP_AHRS::update_external(void)
{
    external.update();
    external.get_results(external_estimates);

    if (_active_EKF_type() == EKFType::EXTERNAL) {
        copy_estimates_from_backend_estimates(external_estimates);
    }
}
#endif // AP_AHRS_EXTERNAL_ENABLED

void AP_AHRS::reset()
{
    // support locked access functions to AHRS data
    WITH_SEMAPHORE(_rsem);

#if AP_AHRS_DCM_ENABLED
    dcm.reset();
#endif
#if AP_AHRS_SIM_ENABLED
    sim.reset();
#endif

#if AP_AHRS_EXTERNAL_ENABLED
    external.reset();
#endif

#if HAL_NAVEKF2_AVAILABLE
    if (_ekf2_started) {
        _ekf2_started = EKF2.InitialiseFilter();
    }
#endif
#if HAL_NAVEKF3_AVAILABLE
    if (_ekf3_started) {
        _ekf3_started = EKF3.InitialiseFilter();
    }
#endif
}

// dead-reckoning support
bool AP_AHRS::_get_location(Location &loc) const
{
    switch (active_EKF_type()) {
#if AP_AHRS_DCM_ENABLED
    case EKFType::DCM:
        return dcm_estimates.get_location(loc);
#endif
#if HAL_NAVEKF2_AVAILABLE
    case EKFType::TWO:
        if (EKF2.getLLH(loc)) {
            return true;
        }
        break;
#endif

#if HAL_NAVEKF3_AVAILABLE
    case EKFType::THREE:
        if (EKF3.getLLH(loc)) {
            return true;
        }
        break;
#endif

#if AP_AHRS_SIM_ENABLED
    case EKFType::SIM:
        return sim_estimates.get_location(loc);
#endif

#if AP_AHRS_EXTERNAL_ENABLED
    case EKFType::EXTERNAL:
        return external_estimates.get_location(loc);
#endif
    }

#if AP_AHRS_DCM_ENABLED
    // fall back to position from DCM
    if (!always_use_EKF()) {
        return dcm_estimates.get_location(loc);
    }
#endif

    return false;
}

// status reporting of estimated errors
float AP_AHRS::get_error_rp(void) const
{
#if AP_AHRS_DCM_ENABLED
    return dcm.get_error_rp();
#endif
    return 0;
}

float AP_AHRS::get_error_yaw(void) const
{
#if AP_AHRS_DCM_ENABLED
    return dcm.get_error_yaw();
#endif
    return 0;
}

// return a wind estimation vector, in m/s
bool AP_AHRS::_wind_estimate(Vector3f &wind) const
{
    switch (active_EKF_type()) {
#if AP_AHRS_DCM_ENABLED
    case EKFType::DCM:
        return dcm.wind_estimate(wind);
#endif

#if AP_AHRS_SIM_ENABLED
    case EKFType::SIM:
        return sim.wind_estimate(wind);
#endif

#if HAL_NAVEKF2_AVAILABLE
    case EKFType::TWO:
        EKF2.getWind(wind);
        return true;
#endif

#if HAL_NAVEKF3_AVAILABLE
    case EKFType::THREE:
        return EKF3.getWind(wind);
#endif

#if AP_AHRS_EXTERNAL_ENABLED
    case EKFType::EXTERNAL:
        return external.wind_estimate(wind);
#endif
    }
    return false;
}


/*
 * Determine how aligned heading_deg is with the wind. Return result
 * is 1.0 when perfectly aligned heading into wind, -1 when perfectly
 * aligned with-wind, and zero when perfect cross-wind. There is no
 * distinction between a left or right cross-wind. Wind speed is ignored
 */
float AP_AHRS::wind_alignment(const float heading_deg) const
{
    Vector3f wind;
    if (!wind_estimate(wind)) {
        return 0;
    }
    const float wind_heading_rad = atan2f(-wind.y, -wind.x);
    return cosf(wind_heading_rad - radians(heading_deg));
}

/*
 * returns forward head-wind component in m/s. Negative means tail-wind.
 */
float AP_AHRS::head_wind(void) const
{
    const float alignment = wind_alignment(yaw_sensor*0.01f);
    return alignment * wind_estimate().xy().length();
}

/*
  return true if the current AHRS airspeed estimate is directly derived from an airspeed sensor
 */
bool AP_AHRS::using_airspeed_sensor() const
{
    return state.airspeed_estimate_type == AirspeedEstimateType::AIRSPEED_SENSOR;
}

/*
    Return true if a airspeed sensor should be used for the AHRS airspeed estimate
 */
bool AP_AHRS::_should_use_airspeed_sensor(uint8_t airspeed_index) const
{
    if (!airspeed_sensor_enabled(airspeed_index)) {
        return false;
    }
    nav_filter_status filter_status;
    if (fly_forward &&
        hal.util->get_soft_armed() &&
        get_filter_status(filter_status) &&
        (filter_status.flags.rejecting_airspeed && !filter_status.flags.dead_reckoning)) {
        // special case for when backend is rejecting airspeed data in
        // an armed fly_forward state and not dead reckoning. Then the
        // airspeed data is highly suspect and will be rejected. We
        // will use the synthetic airspeed instead
        return false;
    }
    return true;
}

// return an airspeed estimate if available. return true
// if we have an estimate
bool AP_AHRS::_airspeed_estimate(float &airspeed_ret, AirspeedEstimateType &airspeed_estimate_type) const
{
#if AP_AHRS_DCM_ENABLED || (AP_AIRSPEED_ENABLED && AP_GPS_ENABLED)
    const uint8_t idx = get_active_airspeed_index();
#endif
#if AP_AIRSPEED_ENABLED && AP_GPS_ENABLED
    if (_should_use_airspeed_sensor(idx)) {
        airspeed_ret = AP::airspeed()->get_airspeed(idx);

        if (_wind_max > 0 && AP::gps().status() >= AP_GPS::GPS_OK_FIX_2D) {
            // constrain the airspeed by the ground speed
            // and AHRS_WIND_MAX
            const float gnd_speed = AP::gps().ground_speed();
            float true_airspeed = airspeed_ret * get_EAS2TAS();
            true_airspeed = constrain_float(true_airspeed,
                                            gnd_speed - _wind_max,
                                            gnd_speed + _wind_max);
            airspeed_ret = true_airspeed / get_EAS2TAS();
        }
        airspeed_estimate_type = AirspeedEstimateType::AIRSPEED_SENSOR;
        return true;
    }
#endif

    if (!get_wind_estimation_enabled()) {
        airspeed_estimate_type = AirspeedEstimateType::NO_NEW_ESTIMATE;
        return false;
    }

    // estimate it via nav velocity and wind estimates

    // get wind estimates
    Vector3f wind_vel;
    bool have_wind = false;

    switch (active_EKF_type()) {
#if AP_AHRS_DCM_ENABLED
    case EKFType::DCM:
        airspeed_estimate_type = AirspeedEstimateType::DCM_SYNTHETIC;
        return dcm.airspeed_estimate(idx, airspeed_ret);
#endif

#if AP_AHRS_SIM_ENABLED
    case EKFType::SIM:
        airspeed_estimate_type = AirspeedEstimateType::SIM;
        return sim.airspeed_estimate(airspeed_ret);
#endif

#if HAL_NAVEKF2_AVAILABLE
    case EKFType::TWO:
#if AP_AHRS_DCM_ENABLED
        airspeed_estimate_type = AirspeedEstimateType::DCM_SYNTHETIC;
        return dcm.airspeed_estimate(idx, airspeed_ret);
#else
        return false;
#endif
#endif

#if HAL_NAVEKF3_AVAILABLE
    case EKFType::THREE:
        have_wind = EKF3.getWind(wind_vel);
        break;
#endif

#if AP_AHRS_EXTERNAL_ENABLED
    case EKFType::EXTERNAL:
#if AP_AHRS_DCM_ENABLED
        airspeed_estimate_type = AirspeedEstimateType::DCM_SYNTHETIC;
        return dcm.airspeed_estimate(idx, airspeed_ret);
#else
        return false;
#endif
#endif
    }

    // estimate it via nav velocity and wind estimates
    Vector3f nav_vel;
    if (have_wind && have_inertial_nav() && get_velocity_NED(nav_vel)) {
        Vector3f true_airspeed_vec = nav_vel - wind_vel;
        float true_airspeed = true_airspeed_vec.length();
        float gnd_speed = nav_vel.length();
        if (_wind_max > 0) {
            float tas_lim_lower = MAX(0.0f, (gnd_speed - _wind_max));
            float tas_lim_upper = MAX(tas_lim_lower, (gnd_speed + _wind_max));
            true_airspeed = constrain_float(true_airspeed, tas_lim_lower, tas_lim_upper);
        } else {
            true_airspeed = MAX(0.0f, true_airspeed);
        }
        airspeed_ret = true_airspeed / get_EAS2TAS();
        airspeed_estimate_type = AirspeedEstimateType::EKF3_SYNTHETIC;
        return true;
    }

#if AP_AHRS_DCM_ENABLED
    // fallback to DCM
    airspeed_estimate_type = AirspeedEstimateType::DCM_SYNTHETIC;
    return dcm.airspeed_estimate(idx, airspeed_ret);
#endif

    return false;
}

bool AP_AHRS::_airspeed_estimate_true(float &airspeed_ret) const
{
    switch (active_EKF_type()) {
#if AP_AHRS_DCM_ENABLED
    case EKFType::DCM:
        return dcm.airspeed_estimate_true(airspeed_ret);
#endif
#if HAL_NAVEKF2_AVAILABLE
    case EKFType::TWO:
#endif
#if HAL_NAVEKF3_AVAILABLE
    case EKFType::THREE:
#endif
#if AP_AHRS_SIM_ENABLED
    case EKFType::SIM:
#endif
#if AP_AHRS_EXTERNAL_ENABLED
    case EKFType::EXTERNAL:
#endif
        break;
    }

    if (!airspeed_estimate(airspeed_ret)) {
        return false;
    }
    airspeed_ret *= get_EAS2TAS();
    return true;
}

// return estimate of true airspeed vector in body frame in m/s
// returns false if estimate is unavailable
bool AP_AHRS::_airspeed_vector_true(Vector3f &vec) const
{
    switch (active_EKF_type()) {
#if AP_AHRS_DCM_ENABLED
    case EKFType::DCM:
        break;
#endif
#if HAL_NAVEKF2_AVAILABLE
    case EKFType::TWO:
        return EKF2.getAirSpdVec(vec);
#endif

#if HAL_NAVEKF3_AVAILABLE
    case EKFType::THREE:
        return EKF3.getAirSpdVec(vec);
#endif

#if AP_AHRS_SIM_ENABLED
    case EKFType::SIM:
        break;
#endif

#if AP_AHRS_EXTERNAL_ENABLED
    case EKFType::EXTERNAL:
        break;
#endif
    }
    return false;
}

// return the innovation in m/s, innovation variance in (m/s)^2 and age in msec of the last TAS measurement processed
// returns false if the data is unavailable
bool AP_AHRS::airspeed_health_data(float &innovation, float &innovationVariance, uint32_t &age_ms) const
{
    switch (active_EKF_type()) {
#if AP_AHRS_DCM_ENABLED
    case EKFType::DCM:
        break;
#endif
#if HAL_NAVEKF2_AVAILABLE
    case EKFType::TWO:
        break;
#endif

#if HAL_NAVEKF3_AVAILABLE
    case EKFType::THREE:
        return EKF3.getAirSpdHealthData(innovation, innovationVariance, age_ms);
#endif

#if AP_AHRS_SIM_ENABLED
    case EKFType::SIM:
        break;
#endif

#if AP_AHRS_EXTERNAL_ENABLED
    case EKFType::EXTERNAL:
        break;
#endif
    }
    return false;
}

// return a synthetic airspeed estimate (one derived from sensors
// other than an actual airspeed sensor), if available. return
// true if we have a synthetic airspeed.  ret will not be modified
// on failure.
bool AP_AHRS::synthetic_airspeed(float &ret) const
{
#if AP_AHRS_DCM_ENABLED
    return dcm.synthetic_airspeed(ret);
#endif
    return false;
}

// true if compass is being used
bool AP_AHRS::use_compass(void)
{
    switch (active_EKF_type()) {
#if AP_AHRS_DCM_ENABLED
    case EKFType::DCM:
        break;
#endif
#if HAL_NAVEKF2_AVAILABLE
    case EKFType::TWO:
        return EKF2.use_compass();
#endif

#if HAL_NAVEKF3_AVAILABLE
    case EKFType::THREE:
        return EKF3.use_compass();
#endif

#if AP_AHRS_SIM_ENABLED
    case EKFType::SIM:
        return sim.use_compass();
#endif

#if AP_AHRS_EXTERNAL_ENABLED
    case EKFType::EXTERNAL:
        break;
#endif
    }
#if AP_AHRS_DCM_ENABLED
    return dcm.use_compass();
#endif
    return false;
}

// return the quaternion defining the rotation from NED to XYZ (body) axes
bool AP_AHRS::_get_quaternion(Quaternion &quat) const
{
    // backends always return in autopilot XYZ frame; rotate result
    // according to trim
    switch (active_EKF_type()) {
#if AP_AHRS_DCM_ENABLED
    case EKFType::DCM:
        if (!dcm.get_quaternion(quat)) {
            return false;
        }
        break;
#endif
#if HAL_NAVEKF2_AVAILABLE
    case EKFType::TWO:
        if (!_ekf2_started) {
            return false;
        }
        EKF2.getQuaternion(quat);
        break;
#endif
#if HAL_NAVEKF3_AVAILABLE
    case EKFType::THREE:
        if (!_ekf3_started) {
            return false;
        }
        EKF3.getQuaternion(quat);
        break;
#endif
#if AP_AHRS_SIM_ENABLED
    case EKFType::SIM:
        if (!sim.get_quaternion(quat)) {
            return false;
        }
        break;
#endif
#if AP_AHRS_EXTERNAL_ENABLED
    case EKFType::EXTERNAL:
        // we assume the external AHRS isn't trimmed with the autopilot!
        return external.get_quaternion(quat);
#endif
    }

    quat.rotate(-_trim.get());

    return true;
}

// return secondary attitude solution if available, as eulers in radians
bool AP_AHRS::_get_secondary_attitude(Vector3f &eulers) const
{
    EKFType secondary_ekf_type;
    if (!_get_secondary_EKF_type(secondary_ekf_type)) {
        return false;
    }

    switch (secondary_ekf_type) {

#if AP_AHRS_DCM_ENABLED
    case EKFType::DCM:
        // DCM is secondary
        eulers[0] = dcm_estimates.roll_rad;
        eulers[1] = dcm_estimates.pitch_rad;
        eulers[2] = dcm_estimates.yaw_rad;
        return true;
#endif

#if HAL_NAVEKF2_AVAILABLE
    case EKFType::TWO:
        // EKF2 is secondary
        EKF2.getEulerAngles(eulers);
        return _ekf2_started;
#endif

#if HAL_NAVEKF3_AVAILABLE
    case EKFType::THREE:
        // EKF3 is secondary
        EKF3.getEulerAngles(eulers);
        return _ekf3_started;
#endif

#if AP_AHRS_SIM_ENABLED
    case EKFType::SIM:
        // SITL is secondary (should never happen)
        return false;
#endif

#if AP_AHRS_EXTERNAL_ENABLED
    case EKFType::EXTERNAL: {
        // External is secondary
        eulers[0] = external_estimates.roll_rad;
        eulers[1] = external_estimates.pitch_rad;
        eulers[2] = external_estimates.yaw_rad;
        return true;
    }
#endif
    }

    // since there is no default case above, this is unreachable
    return false;
}


// return secondary attitude solution if available, as quaternion
bool AP_AHRS::_get_secondary_quaternion(Quaternion &quat) const
{
    EKFType secondary_ekf_type;
    if (!_get_secondary_EKF_type(secondary_ekf_type)) {
        return false;
    }

    switch (secondary_ekf_type) {

#if AP_AHRS_DCM_ENABLED
    case EKFType::DCM:
        // DCM is secondary
        if (!dcm.get_quaternion(quat)) {
            return false;
        }
        break;
#endif

#if HAL_NAVEKF2_AVAILABLE
    case EKFType::TWO:
        // EKF2 is secondary
        if (!_ekf2_started) {
            return false;
        }
        EKF2.getQuaternion(quat);
        break;
#endif

#if HAL_NAVEKF3_AVAILABLE
    case EKFType::THREE:
        // EKF3 is secondary
        if (!_ekf3_started) {
            return false;
        }
        EKF3.getQuaternion(quat);
        break;
#endif

#if AP_AHRS_SIM_ENABLED
    case EKFType::SIM:
        // SITL is secondary (should never happen)
        return false;
#endif

#if AP_AHRS_EXTERNAL_ENABLED
    case EKFType::EXTERNAL:
        // External is secondary
        return external.get_quaternion(quat);
#endif
    }

    quat.rotate(-_trim.get());

    return true;
}

// return secondary position solution if available
bool AP_AHRS::_get_secondary_position(Location &loc) const
{
    EKFType secondary_ekf_type;
    if (!_get_secondary_EKF_type(secondary_ekf_type)) {
        return false;
    }

    switch (secondary_ekf_type) {

#if AP_AHRS_DCM_ENABLED
    case EKFType::DCM:
        // return DCM position
        loc = dcm_estimates.location;
        // FIXME: we intentionally do not return whether location is
        // actually valid here so we continue to send mavlink messages
        // and log data:
        return true;
#endif

#if HAL_NAVEKF2_AVAILABLE
    case EKFType::TWO:
        // EKF2 is secondary
        EKF2.getLLH(loc);
        return _ekf2_started;
#endif

#if HAL_NAVEKF3_AVAILABLE
    case EKFType::THREE:
        // EKF3 is secondary
        EKF3.getLLH(loc);
        return _ekf3_started;
#endif

#if AP_AHRS_SIM_ENABLED
    case EKFType::SIM:
        // SITL is secondary (should never happen)
        return false;
#endif

#if AP_AHRS_EXTERNAL_ENABLED
    case EKFType::EXTERNAL:
        // External is secondary
        return external_estimates.get_location(loc);
#endif
    }

    // since there is no default case above, this is unreachable
    return false;
}

// EKF has a better ground speed vector estimate
Vector2f AP_AHRS::_groundspeed_vector(void)
{
    switch (active_EKF_type()) {
#if AP_AHRS_DCM_ENABLED
    case EKFType::DCM:
        return dcm.groundspeed_vector();
#endif

#if HAL_NAVEKF2_AVAILABLE
    case EKFType::TWO: {
        Vector3f vec;
        EKF2.getVelNED(vec);
        return vec.xy();
    }
#endif

#if HAL_NAVEKF3_AVAILABLE
    case EKFType::THREE: {
        Vector3f vec;
        EKF3.getVelNED(vec);
        return vec.xy();
    }
#endif

#if AP_AHRS_SIM_ENABLED
    case EKFType::SIM:
        return sim.groundspeed_vector();
#endif
#if AP_AHRS_EXTERNAL_ENABLED
    case EKFType::EXTERNAL: {
        return external.groundspeed_vector();
    }
#endif
    }
    return Vector2f();
}

float AP_AHRS::_groundspeed(void)
{
    switch (active_EKF_type()) {
#if AP_AHRS_DCM_ENABLED
    case EKFType::DCM:
        return dcm.groundspeed();
#endif
#if HAL_NAVEKF2_AVAILABLE
    case EKFType::TWO:
#endif

#if HAL_NAVEKF3_AVAILABLE
    case EKFType::THREE:
#endif

#if AP_AHRS_EXTERNAL_ENABLED
    case EKFType::EXTERNAL:
#endif

#if AP_AHRS_SIM_ENABLED
    case EKFType::SIM:
#endif
        break;
    }
    return groundspeed_vector().length();
}

// set the EKF's origin location in 10e7 degrees.  This should only
// be called when the EKF has no absolute position reference (i.e. GPS)
// from which to decide the origin on its own
bool AP_AHRS::set_origin(const Location &loc)
{
    WITH_SEMAPHORE(_rsem);
#if HAL_NAVEKF2_AVAILABLE
    const bool ret2 = EKF2.setOriginLLH(loc);
#endif
#if HAL_NAVEKF3_AVAILABLE
    const bool ret3 = EKF3.setOriginLLH(loc);
#endif

    // return success if active EKF's origin was set
    bool success = false;
    switch (active_EKF_type()) {
#if AP_AHRS_DCM_ENABLED
    case EKFType::DCM:
        break;
#endif

#if HAL_NAVEKF2_AVAILABLE
    case EKFType::TWO:
        success = ret2;
        break;
#endif

#if HAL_NAVEKF3_AVAILABLE
    case EKFType::THREE:
        success = ret3;
        break;
#endif

#if AP_AHRS_SIM_ENABLED
    case EKFType::SIM:
        // never allow origin set in SITL. The origin is set by the
        // simulation backend
        break;
#endif
#if AP_AHRS_EXTERNAL_ENABLED
    case EKFType::EXTERNAL:
        // don't allow origin set with external AHRS
        break;
#endif
    }

    if (success) {
        state.origin_ok = _get_origin(state.origin);
#if HAL_LOGGING_ENABLED
        Log_Write_Home_And_Origin();
#endif
    }
    return success;
}

#if AP_AHRS_POSITION_RESET_ENABLED
bool AP_AHRS::handle_external_position_estimate(const Location &loc, float pos_accuracy, uint32_t timestamp_ms)
{
#if HAL_NAVEKF3_AVAILABLE
    return EKF3.setLatLng(loc, pos_accuracy, timestamp_ms);
#endif
    return false;
}
#endif

// return true if inertial navigation is active
bool AP_AHRS::have_inertial_nav(void) const
{
#if AP_AHRS_DCM_ENABLED
    return active_EKF_type() != EKFType::DCM;
#endif
    return true;
}

// return a ground velocity in meters/second, North/East/Down
// order. Must only be called if have_inertial_nav() is true
bool AP_AHRS::_get_velocity_NED(Vector3f &vec) const
{
    switch (active_EKF_type()) {
#if AP_AHRS_DCM_ENABLED
    case EKFType::DCM:
        break;
#endif
#if HAL_NAVEKF2_AVAILABLE
    case EKFType::TWO:
        EKF2.getVelNED(vec);
        return true;
#endif

#if HAL_NAVEKF3_AVAILABLE
    case EKFType::THREE:
        EKF3.getVelNED(vec);
        return true;
#endif

#if AP_AHRS_SIM_ENABLED
    case EKFType::SIM:
        return sim.get_velocity_NED(vec);
#endif
#if AP_AHRS_EXTERNAL_ENABLED
    case EKFType::EXTERNAL:
        return external.get_velocity_NED(vec);
#endif
    }
#if AP_AHRS_DCM_ENABLED
    return dcm.get_velocity_NED(vec);
#endif
    return false;
}

// returns the expected NED magnetic field
bool AP_AHRS::get_mag_field_NED(Vector3f &vec) const
{
    switch (active_EKF_type()) {
#if AP_AHRS_DCM_ENABLED
    case EKFType::DCM:
        return false;
#endif
#if HAL_NAVEKF2_AVAILABLE
    case EKFType::TWO:
        EKF2.