_DISABLE_CAUSE_OVERSPEED:
        return "ESC_DISABLE_CAUSE_OVERSPEED";
    case ESC_DISABLE_CAUSE_OVERTEMP:
        return "ESC_DISABLE_CAUSE_OVERTEMP";
    case ESC_DISABLE_CAUSE_UNDERVOLTAGE:
        return "ESC_DISABLE_CAUSE_UNDERVOLTAGE";
    case ESC_DISABLE_CAUSE_FAILED_START:
        return "ESC_DISABLE_CAUSE_FAILED_START";
    case ESC_DISABLE_CAUSE_COMMUTATION_ERROR:
        return "ESC_DISABLE_CAUSE_COMMUTATION_ERROR";
    case ESC_DISABLE_CAUSE_PHASE_VOLTAGE:
        return "ESC_DISABLE_CAUSE_PHASE_VOLTAGE";
    case ESC_DISABLE_CAUSE_REGEN_CURRENT:
        return "ESC_DISABLE_CAUSE_REGEN_CURRENT";
    case ESC_DISABLE_CAUSE_INVALID_STATE:
        return "ESC_DISABLE_CAUSE_INVALID_STATE";
    case ESC_DISABLE_CAUSE_RESET:
        return "ESC_DISABLE_CAUSE_RESET";
    }
}


/*!
 * \brief Lookup label for 'ESCMotorOffCause' enum entry
 * 
 * \param value is the integer value of the enum entry
 * \return string label of the given entry
 */
const char* ESCMotorOffCause_EnumLabel(int value)
{
    switch (value)
    {
    default:
        return "";
    case ESC_MOTOR_OFF_STANDBY:
        return "ESC_MOTOR_OFF_STANDBY";
    case ESC_MOTOR_OFF_BEEP:
        return "ESC_MOTOR_OFF_BEEP";
    case ESC_MOTOR_OFF_INITIALISE:
        return "ESC_MOTOR_OFF_INITIALISE";
    case ESC_MOTOR_OFF_INHIBITED:
        return "ESC_MOTOR_OFF_INHIBITED";
    case ESC_MOTOR_OFF_THROTTLE_MIN:
        return "ESC_MOTOR_OFF_THROTTLE_MIN";
    case ESC_MOTOR_OFF_NOT_RUNNING:
        return "ESC_MOTOR_OFF_NOT_RUNNING";
    case ESC_MOTOR_OFF_FAILED_START:
        return "ESC_MOTOR_OFF_FAILED_START";
    case ESC_MOTOR_OFF_INVALID:
        return "ESC_MOTOR_OFF_INVALID";
    }
}


/*!
 * \brief Lookup label for 'ESCFailedStartCause' enum entry
 * 
 * \param value is the integer value of the enum entry
 * \return string label of the given entry
 */
const char* ESCFailedStartCause_EnumLabel(int value)
{
    switch (value)
    {
    default:
        return "";
    case ESC_FAILED_START_CAUSE_RESET:
        return "ESC_FAILED_START_CAUSE_RESET";
    case ESC_FAILED_START_CAUSE_TIMEOUT:
        return "ESC_FAILED_START_CAUSE_TIMEOUT";
    case ESC_FAILED_START_CAUSE_OVERSPEED:
        return "ESC_FAILED_START_CAUSE_OVERSPEED";
    case ESC_FAILED_START_CAUSE_OVERCURRENT:
        return "ESC_FAILED_START_CAUSE_OVERCURRENT";
    case ESC_FAILED_START_CAUSE_SPIN_REVERSED:
        return "ESC_FAILED_START_CAUSE_SPIN_REVERSED";
    case ESC_FAILED_START_CAUSE_SPIN_TOO_FAST:
        return "ESC_FAILED_START_CAUSE_SPIN_TOO_FAST";
    case ESC_FAILED_START_CAUSE_INVALID:
        return "ESC_FAILED_START_CAUSE_INVALID";
    }
}


/*!
 * \brief Lookup label for 'ESCMultiCommandPackets' enum entry
 * 
 * \param value is the integer value of the enum entry
 * \return string label of the given entry
 */
const char* ESCMultiCommandPackets_EnumLabel(int value)
{
    switch (value)
    {
    default:
        return "";
    case PKT_ESC_SETPOINT_1:
        return "PKT_ESC_SETPOINT_1";
    case PKT_ESC_SETPOINT_2:
        return "PKT_ESC_SETPOINT_2";
    case PKT_ESC_SETPOINT_3:
        return "PKT_ESC_SETPOINT_3";
    case PKT_ESC_SETPOINT_4:
        return "PKT_ESC_SETPOINT_4";
    case PKT_ESC_SETPOINT_5:
        return "PKT_ESC_SETPOINT_5";
    case PKT_ESC_SETPOINT_6:
        return "PKT_ESC_SETPOINT_6";
    case PKT_ESC_SETPOINT_7:
        return "PKT_ESC_SETPOINT_7";
    case PKT_ESC_SETPOINT_8:
        return "PKT_ESC_SETPOINT_8";
    case PKT_ESC_SETPOINT_9:
        return "PKT_ESC_SETPOINT_9";
    case PKT_ESC_SETPOINT_10:
        return "PKT_ESC_SETPOINT_10";
    case PKT_ESC_SETPOINT_11:
        return "PKT_ESC_SETPOINT_11";
    case PKT_ESC_SETPOINT_12:
        return "PKT_ESC_SETPOINT_12";
    case PKT_ESC_SETPOINT_13:
        return "PKT_ESC_SETPOINT_13";
    case PKT_ESC_SETPOINT_14:
        return "PKT_ESC_SETPOINT_14";
    case PKT_ESC_SETPOINT_15:
        return "PKT_ESC_SETPOINT_15";
    case PKT_ESC_SETPOINT_16:
        return "PKT_ESC_SETPOINT_16";
    }
}


/*!
 * \brief Lookup label for 'ESCCommandPackets' enum entry
 * 
 * \param value is the integer value of the enum entry
 * \return string label of the given entry
 */
const char* ESCCommandPackets_EnumLabel(int value)
{
    switch (value)
    {
    default:
        return "";
    case PKT_ESC_PWM_CMD:
        return "PKT_ESC_PWM_CMD";
    case PKT_ESC_RPM_CMD:
        return "PKT_ESC_RPM_CMD";
    case PKT_ESC_VOLT_CMD:
        return "PKT_ESC_VOLT_CMD";
    case PKT_ESC_DISABLE:
        return "PKT_ESC_DISABLE";
    case PKT_ESC_STANDBY:
        return "PKT_ESC_STANDBY";
    }
}


/*!
 * \brief Lookup label for 'ESCStatusPackets' enum entry
 * 
 * \param value is the integer value of the enum entry
 * \return string label of the given entry
 */
const char* ESCStatusPackets_EnumLabel(int value)
{
    switch (value)
    {
    default:
        return "";
    case PKT_ESC_STATUS_A:
        return "PKT_ESC_STATUS_A";
    case PKT_ESC_STATUS_B:
        return "PKT_ESC_STATUS_B";
    case PKT_ESC_STATUS_C:
        return "PKT_ESC_STATUS_C";
    case PKT_ESC_STATUS_D:
        return "PKT_ESC_STATUS_D";
    case PKT_ESC_ACCELEROMETER:
        return "PKT_ESC_ACCELEROMETER";
    }
}


/*!
 * \brief Lookup label for 'ESCPackets' enum entry
 * 
 * \param value is the integer value of the enum entry
 * \return string label of the given entry
 */
const char* ESCPackets_EnumLabel(int value)
{
    switch (value)
    {
    default:
        return "";
    case PKT_ESC_SYSTEM_CMD:
        return "PKT_ESC_SYSTEM_CMD";
    case PKT_ESC_SET_TITLE:
        return "PKT_ESC_SET_TITLE";
    case PKT_ESC_CONTROL_LOOP_DATA:
        return "PKT_ESC_CONTROL_LOOP_DATA";
    case PKT_ESC_HALL_SENSOR_INFO:
        return "PKT_ESC_HALL_SENSOR_INFO";
    case PKT_ESC_WARNINGS_ERRORS:
        return "PKT_ESC_WARNINGS_ERRORS";
    case PKT_ESC_MOTOR_FLAGS:
        return "PKT_ESC_MOTOR_FLAGS";
    case PKT_ESC_EVENT:
        return "PKT_ESC_EVENT";
    case PKT_ESC_SERIAL_NUMBER:
        return "PKT_ESC_SERIAL_NUMBER";
    case PKT_ESC_TITLE:
        return "PKT_ESC_TITLE";
    case PKT_ESC_FIRMWARE:
        return "PKT_ESC_FIRMWARE";
    case PKT_ESC_SYSTEM_INFO:
        return "PKT_ESC_SYSTEM_INFO";
    case PKT_ESC_TELEMETRY_SETTINGS:
        return "PKT_ESC_TELEMETRY_SETTINGS";
    case PKT_ESC_EEPROM:
        return "PKT_ESC_EEPROM";
    case PKT_ESC_EXTRA:
        return "PKT_ESC_EXTRA";
    case PKT_ESC_MOTOR_TEMP_SENSOR:
        return "PKT_ESC_MOTOR_TEMP_SENSOR";
    case PKT_ESC_COMMISSIONING:
        return "PKT_ESC_COMMISSIONING";
    case PKT_ESC_TELLTALES:
        return "PKT_ESC_TELLTALES";
    case PKT_ESC_GIT_HASH:
        return "PKT_ESC_GIT_HASH";
    case PKT_ESC_LEGACY_MOTOR_STATUS:
        return "PKT_ESC_LEGACY_MOTOR_STATUS";
    case PKT_ESC_LEGACY_MOTOR_SETTINGS:
        return "PKT_ESC_LEGACY_MOTOR_SETTINGS";
    case PKT_ESC_LEGACY_MOTOR_SETTINGS_2:
        return "PKT_ESC_LEGACY_MOTOR_SETTINGS_2";
    case PKT_ESC_LEGACY_MOTOR_FIRMWARE:
        return "PKT_ESC_LEGACY_MOTOR_FIRMWARE";
    case PKT_ESC_MOTOR_SETTINGS:
        return "PKT_ESC_MOTOR_SETTINGS";
    case PKT_ESC_MOTOR_STARTING:
        return "PKT_ESC_MOTOR_STARTING";
    case PKT_ESC_MOTOR_PARAMETERS:
        return "PKT_ESC_MOTOR_PARAMETERS";
    case PKT_ESC_MOTOR_HALL_CONFIG:
        return "PKT_ESC_MOTOR_HALL_CONFIG";
    case PKT_ESC_CONFIG:
        return "PKT_ESC_CONFIG";
    case PKT_ESC_WARNINGS:
        return "PKT_ESC_WARNINGS";
    case PKT_ESC_PROTECTION_LEVELS:
        return "PKT_ESC_PROTECTION_LEVELS";
    case PKT_ESC_PROTECTION_ACTIONS:
        return "PKT_ESC_PROTECTION_ACTIONS";
    case PKT_ESC_VOLT_LOOP_SETTINGS:
        return "PKT_ESC_VOLT_LOOP_SETTINGS";
    case PKT_ESC_RPM_LOOP_SETTINGS:
        return "PKT_ESC_RPM_LOOP_SETTINGS";
    case PKT_ESC_STARTING_SETTINGS:
        return "PKT_ESC_STARTING_SETTINGS";
    case PKT_ESC_CURRENT_CALIBRATION:
        return "PKT_ESC_CURRENT_CALIBRATION";
    case PKT_ESC_IO_TABLE_SETTINGS:
        return "PKT_ESC_IO_TABLE_SETTINGS";
    case PKT_ESC_IO_TABLE_ELEMENT:
        return "PKT_ESC_IO_TABLE_ELEMENT";
    case PKT_ESC_THROTTLE_CURVE:
        return "PKT_ESC_THROTTLE_CURVE";
    case PKT_ESC_PWM_INPUT_CALIBRATION:
        return "PKT_ESC_PWM_INPUT_CALIBRATION";
    case PKT_ESC_BULK_TRANSFER:
        return "PKT_ESC_BULK_TRANSFER";
    case PKT_ESC_DRONECAN_SETTINGS:
        return "PKT_ESC_DRONECAN_SETTINGS";
    }
}


/*!
 * \brief Lookup label for 'ESCSystemCommands' enum entry
 * 
 * \param value is the integer value of the enum entry
 * \return string label of the given entry
 */
const char* ESCSystemCommands_EnumLabel(int value)
{
    switch (value)
    {
    default:
        return "";
    case CMD_ESC_SET_NODE_ID:
        return "CMD_ESC_SET_NODE_ID";
    case CMD_ESC_SET_USER_ID_A:
        return "CMD_ESC_SET_USER_ID_A";
    case CMD_ESC_SET_USER_ID_B:
        return "CMD_ESC_SET_USER_ID_B";
    case CMD_ESC_TARE_CURRENT:
        return "CMD_ESC_TARE_CURRENT";
    case CMD_ESC_IDENTIFY:
        return "CMD_ESC_IDENTIFY";
    case CMD_ESC_SET_MOTOR_DIRECTION:
        return "CMD_ESC_SET_MOTOR_DIRECTION";
    case CMD_ESC_REQUEST_HF_DATA:
        return "CMD_ESC_REQUEST_HF_DATA";
    case CMD_ESC_CONFIGURE_IO_MAP:
        return "CMD_ESC_CONFIGURE_IO_MAP";
    case CMD_ESC_CONFIGURE_IO_ELEMENT:
        return "CMD_ESC_CONFIGURE_IO_ELEMENT";
    case CMD_ESC_RESET_SETTINGS:
        return "CMD_ESC_RESET_SETTINGS";
    case CMD_ESC_ENTER_DEBUG:
        return "CMD_ESC_ENTER_DEBUG";
    case CMD_ESC_EXIT_DEBUG:
        return "CMD_ESC_EXIT_DEBUG";
    case CMD_ESC_UNLOCK_SETTINGS:
        return "CMD_ESC_UNLOCK_SETTINGS";
    case CMD_ESC_LOCK_SETTINGS:
        return "CMD_ESC_LOCK_SETTINGS";
    case CMD_ESC_VALIDATE_SETTINGS:
        return "CMD_ESC_VALIDATE_SETTINGS";
    case CMD_ESC_RESET_MOTOR_RUN_TIME:
        return "CMD_ESC_RESET_MOTOR_RUN_TIME";
    case CMD_ESC_ENTER_BOOTLOADER:
        return "CMD_ESC_ENTER_BOOTLOADER";
    case CMD_ESC_RESET:
        return "CMD_ESC_RESET";
    }
}


/*!
 * \brief Lookup label for 'CANProtocols' enum entry
 * 
 * \param value is the integer value of the enum entry
 * \return string label of the given entry
 */
const char* CANProtocols_EnumLabel(int value)
{
    switch (value)
    {
    default:
        return "";
    case CAN_PROTOCOL_PICCOLO:
        return "CAN_PROTOCOL_PICCOLO";
    case CAN_PROTOCOL_DRONECAN:
        return "CAN_PROTOCOL_DRONECAN";
    case CAN_PROTOCOL_NONE:
        return "CAN_PROTOCOL_NONE";
    }
}


/*!
 * \brief Lookup label for 'CANBaudRates' enum entry
 * 
 * \param value is the integer value of the enum entry
 * \return string label of the given entry
 */
const char* CANBaudRates_EnumLabel(int value)
{
    switch (value)
    {
    default:
        return "";
    case CAN_BAUD_RATES_INVALID:
        return "CAN_BAUD_RATES_INVALID";
    case CAN_BAUD_RATES_1000K:
        return "CAN_BAUD_RATES_1000K";
    case CAN_BAUD_RATES_500K:
        return "CAN_BAUD_RATES_500K";
    case CAN_BAUD_RATES_250K:
        return "CAN_BAUD_RATES_250K";
    case CAN_BAUD_RATES_125K:
        return "CAN_BAUD_RATES_125K";
    case CAN_BAUD_RATES_100K:
        return "CAN_BAUD_RATES_100K";
    case CAN_BAUD_RATES_50K:
        return "CAN_BAUD_RATES_50K";
    }
}

// end of ESCVelocityProtocol.c
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 // ESCVelocityProtocol.h was generated by ProtoGen version 3.5.c

/*
 * This file is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This file is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Author: Oliver Walters / Currawong Engineering Pty Ltd
 */

#ifndef _ESCVELOCITYPROTOCOL_H
#define _ESCVELOCITYPROTOCOL_H

// Language target is C, C++ compilers: don't mangle us
#ifdef __cplusplus
extern "C" {
#endif

/*!
 * \file
 * \mainpage ESCVelocity protocol stack
 * 
 * This is the ICD for the Gen-2 Currawong Engineering Electronic Speed
 * Controller (ESCVelocity). This document details the ESCVelocity command and
 * packet structure for communication with and configuration of the ESC. Note
 * that there may be some differences between this ICD and the ICD for the
 * Gen-1 ESCVelocity. Please refer to the old ICD for the Gen-1 device.
 * 
 * The protocol API enumeration is incremented anytime the protocol is changed
 * in a way that affects compatibility with earlier versions of the protocol.
 * The protocol enumeration for this version is: 88
 * 
 * The protocol version is 3.70
 */

#include <stdint.h>
#include <stdbool.h>
#include <string.h>	// C string manipulation function header

//! \return the protocol API enumeration
#define getESCVelocityApi() 88

//! \return the protocol version string
#define getESCVelocityVersion() "3.70"

/*!
 * Constant values required for sending a disable (inhibit) command
 */
typedef enum
{
    ESC_DISABLE_A = 0xAA, //!< Constant value required for disabling the ESC
    ESC_DISABLE_B = 0xC3  //!< Constant value required for disabling the ESC
} ESCDisableSequence;

/*!
 * Constant values required for sending an enable command
 */
typedef enum
{
    ESC_ENABLE_A = 0xAA, //!< Constant value required for enabling the ESC
    ESC_ENABLE_B = 0x3C  //!< Constant value required for enabling the ESC
} ESCEnableSequence;

/*!
 * ESC Operational Modes
 */
typedef enum
{
    ESC_MODE_STANDBY = 0x00, //!< ESC is in standby mode - the motor is OFF but the ESC is ready to accept motor commands
    ESC_MODE_PWM,            //!< ESC is controlling motor in open-loop mode based on a 'PWM' (Pulse Width) input
    ESC_MODE_RPM,            //!< ESC is controlling motor speed based on an RPM setpoint
    ESC_MODE_VOLT,           //!< ESC is controlling DC voltage based on a provided setpoint
    ESC_VALID_MODES          //!< ESC mode counter
} ESCOperatingModes;

//! \return the label of a 'ESCOperatingModes' enum entry, based on its value
const char* ESCOperatingModes_EnumLabel(int value);

/*!
 * ESC Command Sources
 */
typedef enum
{
    ESC_COMMAND_SOURCE_NONE = 0x00, //!< No valid command has been received
    ESC_COMMAND_SOURCE_CAN,         //!< Most recent command from CAN
    ESC_COMMAND_SOURCE_PWM          //!< Most recent command from PWM
} ESCCommandSources;

//! \return the label of a 'ESCCommandSources' enum entry, based on its value
const char* ESCCommandSources_EnumLabel(int value);

/*!
 * ESC motor temperature sensor options
 */
typedef enum
{
    ESC_MOTOR_TEMP_SENSOR_OFF = 0x00, //!< No temperature sensor selected
    ESC_MOTOR_TEMP_SENSOR_KTY84,      //!< KTY84 or equivalent
    ESC_MOTOR_TEMP_SENSOR_KTY83,      //!< KTY83 or equivalent
    ESC_MOTOR_TEMP_SENSOR_NTC_SH,     //!< NTC sensor (Steinhart–Hart equation)
    ESC_MOTOR_TEMP_SENSOR_NTC_BETA    //!< NTC sensor (Beta equation)
} ESCMotorTemperatureSensor;

//! \return the label of a 'ESCMotorTemperatureSensor' enum entry, based on its value
const char* ESCMotorTemperatureSensor_EnumLabel(int value);

/*!
 * Motor direction
 */
typedef enum
{
    ESC_MOTOR_DIR_ABC = 0,   //!< Motor phase sequence A / B / C
    ESC_MOTOR_DIR_ACB = 1,   //!< Motor phase sequence A / C / B
    ESC_MOTOR_DIR_OTHER = 3  //!< Unknown / unsupported direction
} ESCMotorDirection;

//! \return the label of a 'ESCMotorDirection' enum entry, based on its value
const char* ESCMotorDirection_EnumLabel(int value);

/*!
 * Hall sensor modes
 */
typedef enum
{
    ESC_HALL_MODE_SENSORLESS = 0, //!< Sensorless control only
    ESC_HALL_MODE_SENSORED = 1,   //!< Sensored control only
    ESC_HALL_MODE_HYBRID = 2      //!< Sensored starting, running below RPM threshold and where sensorless control is unreliable.
} ESCHallSensorMode;

//! \return the label of a 'ESCHallSensorMode' enum entry, based on its value
const char* ESCHallSensorMode_EnumLabel(int value);

/*!
 * AFW operation modes
 */
typedef enum
{
    ESC_AFW_MODE_OFF = 0,     //!< AFW always off (during this motor running state)
    ESC_AFW_MODE_ON = 1,      //!< AFW always on (during this motor running state)
    ESC_AFW_MODE_DYNAMIC = 2, //!< AFW may change state
    ESC_AFW_MODE_OTHER = 3    //!< Future expansion
} ESCAFWModes;

//! \return the label of a 'ESCAFWModes' enum entry, based on its value
const char* ESCAFWModes_EnumLabel(int value);

/*!
 * PWM operation modes
 */
typedef enum
{
    ESC_PWM_FREQ_FIXED = 0, //!< PWM frequency is the specified value
    ESC_PWM_FREQ_RAMP = 1,  
    ESC_PWM_FREQ_OTHER = 3  //!< Future expansion
} ESCPWMFreqModes;

//! \return the label of a 'ESCPWMFreqModes' enum entry, based on its value
const char* ESCPWMFreqModes_EnumLabel(int value);

/*!
 * PWM operation modes
 */
typedef enum
{
    ESC_TIMING_ADVANCE_MODE_FIXED = 0, //!< Timing advance is the specified value
    ESC_TIMING_ADVANCE_MODE_RAMP = 1,  
    ESC_TIMING_ADVANCE_MODE_OTHER = 3  //!< Future expansion
} ESCTimingAdvanceModes;

//! \return the label of a 'ESCTimingAdvanceModes' enum entry, based on its value
const char* ESCTimingAdvanceModes_EnumLabel(int value);

/*!
 * ESC protection actions
 */
typedef enum
{
    ESC_PROTECTION_WARNING = 0,  //!< Warning bit is set
    ESC_PROTECTION_FOLDBACK = 1, //!< Motor duty cycle is limited
    ESC_PROTECTION_DISABLE = 2,  //!< ESC is disabled
    ESC_PROTECTION_INVALID = 7   //!< Invalid protection action
} ESCProtectionActions;

//! \return the label of a 'ESCProtectionActions' enum entry, based on its value
const char* ESCProtectionActions_EnumLabel(int value);

/*!
 * Motor beep modes enumeration
 */
typedef enum
{
    ESC_BEEP_NONE = 0b00,   
    ESC_BEEP_STATUS = 0b01, //!< Motor status beeps only
    ESC_BEEP_ERROR = 0b10,  //!< Motor error beeps only
    ESC_BEEP_ALL = 0b11     //!< All motor beeps
} ESCBeepModes;

//! \return the label of a 'ESCBeepModes' enum entry, based on its value
const char* ESCBeepModes_EnumLabel(int value);

/*!
 * ESC standby cause flags
 */
typedef enum
{
    ESC_STANDBY_CAUSE_CMD = 0x0001,               //!< ESC was put into *STANDBY* mode by a command
    ESC_STANDBY_CAUSE_INHIBIT = 0x0002,           //!< ESC was put into *STANDBY* mode by SW or HW inhibit
    ESC_STANDBY_CAUSE_TIMEOUT = 0x0004,           //!< ESC was put into *STANDBY* mode due to keepalive timeout
    ESC_STANDBY_CAUSE_HALL_SENSOR_ERROR = 0x0008, //!< ESC was put into *STANDBY* mode due to a hall sensor error
    ESC_STANDBY_CAUSE_INVALID_CMD = 0x0010,       //!< ESC was put into *STANDBY* mode due to a command being invalid
    ESC_STANDBY_CAUSE_PWM_ARM = 0x0020,           //!< PWM arming signal detected
    ESC_STANDBY_CAUSE_FAILED_START = 0x0040,      //!< ESC was put into *STANDBY* mode due to failed starting routine
    ESC_STANDBY_CAUSE_MIN_CMD = 0x0080,           //!< ESC was put into *STANDBY* mode due to the received command below minimum threshold
    ESC_STANDBY_CAUSE_FAILED_RESYNC = 0x0100,     //!< ESC was put into *STANDBY* mode due to failed resync routine
    ESC_STANDBY_CAUSE_UNEXPECTED = 0x0200,        //!< ESC was put intot *STANDBY* mode due to an unexpected internal state
    ESC_STANDBY_CAUSE_RESET = 0x8000              
} ESCStandbyCause;

//! \return the label of a 'ESCStandbyCause' enum entry, based on its value
const char* ESCStandbyCause_EnumLabel(int value);

/*!
 * ESC disable cause flags
 */
typedef enum
{
    ESC_DISABLE_CAUSE_NONE = 0x0000,              //!< Unused / blank value
    ESC_DISABLE_CAUSE_CAN_CMD = 0x0001,           //!< ESC is disabled by a CAN command
    ESC_DISABLE_CAUSE_PWM_TIMEOUT = 0x0002,       //!< PWM signal lost
    ESC_DISABLE_CAUSE_HARDWARE = 0x0004,          //!< Hardware enable signal deasserted
    ESC_DISABLE_CAUSE_OVERCURRENT = 0x0008,       //!< ESC disabled due to overcurrent
    ESC_DISABLE_CAUSE_OVERSPEED = 0x0010,         //!< ESC disabled due to overspeed
    ESC_DISABLE_CAUSE_OVERTEMP = 0x0020,          //!< ESC disabled due to overtemperature
    ESC_DISABLE_CAUSE_UNDERVOLTAGE = 0x0040,      //!< ESC disabled due to undervoltage
    ESC_DISABLE_CAUSE_FAILED_START = 0x0080,      //!< ESC disabled due to starting failure (see ESCFailedStartCause for details)
    ESC_DISABLE_CAUSE_COMMUTATION_ERROR = 0x0100, //!< ESC disabled due to commutation failure
    ESC_DISABLE_CAUSE_PHASE_VOLTAGE = 0x0200,     //!< Phase voltage issues detected
    ESC_DISABLE_CAUSE_REGEN_CURRENT = 0x0400,     //!< Regen current exceeded threshold
    ESC_DISABLE_CAUSE_INVALID_STATE = 0x2000,     //!< ESC disabled due to invalid commutation state
    ESC_DISABLE_CAUSE_RESET = 0x8000              //!< ESC is disabled by processor reset
} ESCDisableCause;

//! \return the label of a 'ESCDisableCause' enum entry, based on its value
const char* ESCDisableCause_EnumLabel(int value);

/*!
 * ESC motor OFF cause
 */
typedef enum
{
    ESC_MOTOR_OFF_STANDBY = 0x0001,      //!< Motor turned off due to system standby
    ESC_MOTOR_OFF_BEEP = 0x0002,         //!< Motor turned off due to beeping routine
    ESC_MOTOR_OFF_INITIALISE = 0x0004,   //!< Motor turned off at system initialisation
    ESC_MOTOR_OFF_INHIBITED = 0x0010,    //!< Motor turned off due to ESC being inhibited
    ESC_MOTOR_OFF_THROTTLE_MIN = 0x0020, //!< Throttle below minimum value
    ESC_MOTOR_OFF_NOT_RUNNING = 0x0040,  //!< Motor does not have valid commutation
    ESC_MOTOR_OFF_FAILED_START = 0x0080, //!< Starting routine failed
    ESC_MOTOR_OFF_INVALID = 0x8000       
} ESCMotorOffCause;

//! \return the label of a 'ESCMotorOffCause' enum entry, based on its value
const char* ESCMotorOffCause_EnumLabel(int value);

/*!
 * Failed start cause flags
 */
typedef enum
{
    ESC_FAILED_START_CAUSE_RESET = 0x0000,         //!< No failed start has been recorded
    ESC_FAILED_START_CAUSE_TIMEOUT = 0x0001,       //!< Starting procedure timed out
    ESC_FAILED_START_CAUSE_OVERSPEED = 0x0002,     //!< Commutation speed too high
    ESC_FAILED_START_CAUSE_OVERCURRENT = 0x0004,   //!< Starting current exceeded
    ESC_FAILED_START_CAUSE_SPIN_REVERSED = 0x0010, //!< Motor is already spinning, in reverse direction
    ESC_FAILED_START_CAUSE_SPIN_TOO_FAST = 0x0020, //!< Motor is already spinning, above maximum catch speed
    ESC_FAILED_START_CAUSE_INVALID = 0x8000        
} ESCFailedStartCause;

//! \return the label of a 'ESCFailedStartCause' enum entry, based on its value
const char* ESCFailedStartCause_EnumLabel(int value);

/*!
 * ESC Multi Command Packets
 */
typedef enum
{
    PKT_ESC_SETPOINT_1 = 0, //!< This packet is used to send commands to multiple ESCs with sequential CAN IDs 1 - 4
    PKT_ESC_SETPOINT_2,     //!< This packet is used to send commands to multiple ESCs with sequential CAN IDs 5 - 8
    PKT_ESC_SETPOINT_3,     //!< This packet is used to send commands to multiple ESCs with sequential CAN IDs 9 - 12
    PKT_ESC_SETPOINT_4,     //!< This packet is used to send commands to multiple ESCs with sequential CAN IDs 13 - 16
    PKT_ESC_SETPOINT_5,     //!< This packet is used to send commands to multiple ESCs with sequential CAN IDs 17 - 20
    PKT_ESC_SETPOINT_6,     //!< This packet is used to send commands to multiple ESCs with sequential CAN IDs 21 - 24
    PKT_ESC_SETPOINT_7,     //!< This packet is used to send commands to multiple ESCs with sequential CAN IDs 25 - 28
    PKT_ESC_SETPOINT_8,     //!< This packet is used to send commands to multiple ESCs with sequential CAN IDs 29 - 32
    PKT_ESC_SETPOINT_9,     //!< This packet is used to send commands to multiple ESCs with sequential CAN IDs 33 - 36
    PKT_ESC_SETPOINT_10,    //!< This packet is used to send commands to multiple ESCs with sequential CAN IDs 37 - 40
    PKT_ESC_SETPOINT_11,    //!< This packet is used to send commands to multiple ESCs with sequential CAN IDs 41 - 44
    PKT_ESC_SETPOINT_12,    //!< This packet is used to send commands to multiple ESCs with sequential CAN IDs 45 - 48
    PKT_ESC_SETPOINT_13,    //!< This packet is used to send commands to multiple ESCs with sequential CAN IDs 49 - 52
    PKT_ESC_SETPOINT_14,    //!< This packet is used to send commands to multiple ESCs with sequential CAN IDs 53 - 56
    PKT_ESC_SETPOINT_15,    //!< This packet is used to send commands to multiple ESCs with sequential CAN IDs 57 - 60
    PKT_ESC_SETPOINT_16     //!< This packet is used to send commands to multiple ESCs with sequential CAN IDs 61 - 64
} ESCMultiCommandPackets;

//! \return the label of a 'ESCMultiCommandPackets' enum entry, based on its value
const char* ESCMultiCommandPackets_EnumLabel(int value);

/*!
 * ESC Command Packets
 */
typedef enum
{
    PKT_ESC_PWM_CMD = 0x10, //!< Send a PWM (Pulse width) command to a particular ESC
    PKT_ESC_RPM_CMD,        //!< Send an RPM (Speed) command to a particular ESC
    PKT_ESC_VOLT_CMD,       //!< Send a voltage loop command to a particular ESC
    PKT_ESC_DISABLE = 0x20, //!< Send this packet to an ESC to disable the ESC
    PKT_ESC_STANDBY         //!< Send this packet to an ESC to enable the ESC and place it in Standby mode
} ESCCommandPackets;

//! \return the label of a 'ESCCommandPackets' enum entry, based on its value
const char* ESCCommandPackets_EnumLabel(int value);

/*!
 * ESC Status Packets
 */
typedef enum
{
    PKT_ESC_STATUS_A = 0x80,      //!< ESC Status A telemetry packet transmitted by the ESC at regular intervals
    PKT_ESC_STATUS_B,             //!< ESC Status B telemetry packet transmitted by the ESC at regular intervals
    PKT_ESC_STATUS_C,             //!< ESC Status C telemetry packet transmitted by the ESC at regular intervals
    PKT_ESC_STATUS_D,             //!< ECC Status D telemetry packet transmitted by the ESC at regular intervals
    PKT_ESC_ACCELEROMETER = 0x88  //!< Raw accelerometer data
} ESCStatusPackets;

//! \return the label of a 'ESCStatusPackets' enum entry, based on its value
const char* ESCStatusPackets_EnumLabel(int value);

/*!
 * ESC Packets Definitions
 */
typedef enum
{
    PKT_ESC_SYSTEM_CMD = 0x50,              //!< Send a configuration command to the ESC (followed by optional command data bytes)
    PKT_ESC_SET_TITLE = 0x51,               //!< Set the ESC descriptor title
    PKT_ESC_CONTROL_LOOP_DATA = 0x8A,       //!< Control loop output data - varies depending on the operational mode of the ESC
    PKT_ESC_HALL_SENSOR_INFO = 0x8C,        //!< Hall sensor information - detected pattern, advance, validity
    PKT_ESC_WARNINGS_ERRORS = 0x86,         //!< ESC warning / error status information.
    PKT_ESC_MOTOR_FLAGS = 0x87,             //!< Motor status flags
    PKT_ESC_EVENT = 0x8D,                   //!< Event description packet
    PKT_ESC_SERIAL_NUMBER = 0x90,           //!< ESC Serial Number and User ID information
    PKT_ESC_TITLE = 0x91,                   //!< Human-readable string descriptor (max 8 chars) of the particular ESC
    PKT_ESC_FIRMWARE = 0x92,                //!< ESC Firmware information
    PKT_ESC_SYSTEM_INFO = 0x93,             //!< ESC system information packet
    PKT_ESC_TELEMETRY_SETTINGS = 0x94,      //!< Telemetry packet configuration
    PKT_ESC_EEPROM = 0x95,                  //!< ESC non-volatile data information and settings
    PKT_ESC_EXTRA = 0x96,                   //!< Extra settings
    PKT_ESC_MOTOR_TEMP_SENSOR = 0x97,       //!< Motor temperature sensor settings
    PKT_ESC_COMMISSIONING = 0x99,           //!< ESC commissioning data (factory only)
    PKT_ESC_TELLTALES = 0x9A,               //!< ESC telltales
    PKT_ESC_GIT_HASH = 0x9B,                //!< ESC firmware git hash
    PKT_ESC_LEGACY_MOTOR_STATUS = 0xA0,     //!< ESC motor status information
    PKT_ESC_LEGACY_MOTOR_SETTINGS = 0xA5,   //!< ESC motor configuration
    PKT_ESC_LEGACY_MOTOR_SETTINGS_2 = 0xA6, //!< ESC Motor settings information
    PKT_ESC_LEGACY_MOTOR_FIRMWARE = 0xAA,   //!< ESC motor control firmware information
    PKT_ESC_MOTOR_SETTINGS = 0xA7,          //!< Motor control settings packet
    PKT_ESC_MOTOR_STARTING = 0xA8,          //!< Motor starting settings packet
    PKT_ESC_MOTOR_PARAMETERS = 0xA9,        //!< Motor and system parameters
    PKT_ESC_MOTOR_HALL_CONFIG = 0xAB,       //!< Motor hall sensor configuration
    PKT_ESC_CONFIG = 0xB0,                  //!< ESC Configuration parameters
    PKT_ESC_WARNINGS = 0xB1,                //!< Warning level values for various ESC parameters (legacy)
    PKT_ESC_PROTECTION_LEVELS = 0xB2,       //!< ESC protection values
    PKT_ESC_PROTECTION_ACTIONS = 0xB3,      //!< ESC protection actions
    PKT_ESC_VOLT_LOOP_SETTINGS = 0xB4,      //!< Voltage Control Loop Settings
    PKT_ESC_RPM_LOOP_SETTINGS = 0xB5,       //!< RPM Control Loop Settings
    PKT_ESC_STARTING_SETTINGS = 0xB6,       //!< ESC auto-starting configuration for RPM mode
    PKT_ESC_CURRENT_CALIBRATION = 0xB7,     //!< ESC current sense calibration settings
    PKT_ESC_IO_TABLE_SETTINGS = 0xC0,       //!< Configuration of the Input/Output mapping
    PKT_ESC_IO_TABLE_ELEMENT = 0xC1,        //!< A single element of the Input/Output mapping table
    PKT_ESC_THROTTLE_CURVE = 0xC2,          //!< Throttle curve calibration
    PKT_ESC_PWM_INPUT_CALIBRATION = 0xC3,   //!< PWM input calibration
    PKT_ESC_BULK_TRANSFER = 0xF0,           //!< Bulk data transfer (long packets)
    PKT_ESC_DRONECAN_SETTINGS = 0xFA        //!< DroneCAN specific settings
} ESCPackets;

//! \return the label of a 'ESCPackets' enum entry, based on its value
const char* ESCPackets_EnumLabel(int value);

/*!
 * ESC System Commands
 */
typedef enum
{
    CMD_ESC_SET_NODE_ID = 0x50,          //!< Set the CAN Node ID for the target ESC
    CMD_ESC_SET_USER_ID_A,               //!< Set user ID A value
    CMD_ESC_SET_USER_ID_B,               //!< Set user ID B value
    CMD_ESC_TARE_CURRENT = 0x60,         //!< Tare the current measurement
    CMD_ESC_IDENTIFY = 0x70,             //!< Identify the ESC with a sequence of LED flashes / beeps
    CMD_ESC_SET_MOTOR_DIRECTION = 0x90,  //!< Set the motor direction
    CMD_ESC_REQUEST_HF_DATA = 0xB0,      //!< Request high-frequency telemetry data
    CMD_ESC_CONFIGURE_IO_MAP = 0xC0,     //!< Configure the Input/Output map for the ESC
    CMD_ESC_CONFIGURE_IO_ELEMENT,        //!< Configure (or request) a particular element of the I/O map
    CMD_ESC_RESET_SETTINGS = 0xD0,       //!< Reset ESC settings to default parameters
    CMD_ESC_ENTER_DEBUG = 0xDE,          //!< Enter debug mode
    CMD_ESC_EXIT_DEBUG,                  //!< Exit debug mode
    CMD_ESC_UNLOCK_SETTINGS = 0xF5,      //!< Unlock ESC nonvolatile settings
    CMD_ESC_LOCK_SETTINGS = 0xF6,        //!< Lock ESC nonvolatile settings
    CMD_ESC_VALIDATE_SETTINGS = 0xF7,    //!< Mark the current settings as valid
    CMD_ESC_RESET_MOTOR_RUN_TIME = 0xFA, //!< Reset motor run time
    CMD_ESC_ENTER_BOOTLOADER = 0xFB,     //!< Enter bootloader mode
    CMD_ESC_RESET                        //!< Reset ESC
} ESCSystemCommands;

//! \return the label of a 'ESCSystemCommands' enum entry, based on its value
const char* ESCSystemCommands_EnumLabel(int value);

/*!
 * ESC CAN Protocols
 */
typedef enum
{
    CAN_PROTOCOL_PICCOLO = 0x00,  //!< Piccolo CAN protocol
    CAN_PROTOCOL_DRONECAN = 0x01, //!< DroneCAN CAN protocol
    CAN_PROTOCOL_NONE = 0xFF      //!< No protocol specified
} CANProtocols;

//! \return the label of a 'CANProtocols' enum entry, based on its value
const char* CANProtocols_EnumLabel(int value);

/*!
 * ESC CAN Baud rates
 */
typedef enum
{
    CAN_BAUD_RATES_INVALID = 0x00, 
    CAN_BAUD_RATES_1000K,          
    CAN_BAUD_RATES_500K,           
    CAN_BAUD_RATES_250K,           
    CAN_BAUD_RATES_125K,           
    CAN_BAUD_RATES_100K,           
    CAN_BAUD_RATES_50K             
} CANBaudRates;

//! \return the label of a 'CANBaudRates' enum entry, based on its value
const char* CANBaudRates_EnumLabel(int value);


// The prototypes below provide an interface to the packets.
// They are not auto-generated functions, but must be hand-written

//! \return the packet data pointer from the packet
uint8_t* getESCVelocityPacketData(void* pkt);

//! \return the packet data pointer from the packet, const
const uint8_t* getESCVelocityPacketDataConst(const void* pkt);

//! Complete a packet after the data have been encoded
void finishESCVelocityPacket(void* pkt, int size, uint32_t packetID);

//! \return the size of a packet from the packet header
int getESCVelocityPacketSize(const void* pkt);

//! \return the ID of a packet from the packet header
uint32_t getESCVelocityPacketID(const void* pkt);

#ifdef __cplusplus
}
#endif
#endif // _ESCVELOCITYPROTOCOL_H
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   <Protocol api="62" comment="This is the ICD for the Gen-2 Currawong Engineering Electronic Speed Controller (ESCVelocity). This document details the ESCVelocity command and packet structure for communication with and configuration of the ESC. Note that there may be some differences between this ICD and the ICD for the Gen-1 ESCVelocity. Please refer to the old ICD for the Gen-1 device." endian="big" file="ESCPackets" mapfile="ESC_SettingsMap" name="ESCVelocity" prefix="ESC_" supportBool="true" supportFloat64="false" supportInt64="false" supportSpecialFloat="false" verifyfile="ESC_SettingsVerify" version="3.41"><Include comment="C string manipulation function header" global="true" name="string.h" />

    
    <Structure comment="Status bits associated with the legacy (gen-1) ESC" file="LegacyESCDefines" name="LegacyStatusBits">
        <Data comment="1 = Hardware inhibit is active (ESC is disabled)" inMemoryType="bitfield1" name="hwInhibit" />
        <Data comment="1 = Software inhibit is active (ESC is disabled)" inMemoryType="bitfield1" name="swInhibit" />
        <Data comment="0 = Active Freewheeling is not enabled, 1 = Active Freewheeling is enabled" inMemoryType="bitfield1" name="afwEnabled" />
        <Data comment="0 = Motor direction is FORWARDS, 1= Motor direction is REVERSE" inMemoryType="bitfield1" name="direction" />
        <Data comment="Set if the ESC command timeout period has elapsed (and the ESC is in STANDBY mode)" inMemoryType="bitfield1" name="timeout" />
        <Data comment="1 = in starting mode (0 = stopped or running)" inMemoryType="bitfield1" name="starting" />
        <Data comment="0 = most recent command from CAN, 1 = most recent command from PWM" inMemoryType="bitfield1" name="commandSource" />
        <Data comment="ESC is running" inMemoryType="bitfield1" name="running" />
    </Structure>
    
    <Structure comment="Warning bits associated with the legacy (gen-1) ESC" file="LegacyESCDefines" name="LegacyWarningBits">    
        <Data comment="Set if RPM signal is not detected" inMemoryType="bitfield1" name="noRPMSignal" />
        <Data comment="Set if the ESC motor speed exceeds the configured warning threshold" inMemoryType="bitfield1" name="overspeed" />
        <Data comment="Set if the ESC motor current (positive or negative) exceeds the configured warning threshold" inMemoryType="bitfield1" name="overcurrent" />
        <Data comment="Set if the internal ESC temperature is above the warning threshold" inMemoryType="bitfield1" name="escTemperature" />
        <Data comment="Set if the motor temperature is above the warning threshold" inMemoryType="bitfield1" name="motorTemperature" />
        <Data comment="Set if the input voltage is below the minimum threshold" inMemoryType="bitfield1" name="undervoltage" />
        <Data comment="Set if the input voltage is above the maximum threshold" inMemoryType="bitfield1" name="overvoltage" />    
        <Data comment="Set if hardware PWM input is enabled but invalid" inMemoryType="bitfield1" name="invalidPWMsignal" />
    </Structure>
    
    <Structure comment="Error bits associated with the legacy (gen-1) ESC" file="LegacyESCDefines" name="LegacyErrorBits">
        <Data comment="Set if communication link to the motor controller is lost" inMemoryType="bitfield1" name="linkError" />
        <Data comment="Set if the ESC has detected an overcurrent event and is actively folding back duty cycle" inMemoryType="bitfield1" name="foldback" />
        <Data comment="Set if the settings checksum does not match the programmed values" inMemoryType="bitfield1" name="settingsChecksum" />
        <Data comment="Set if the motor settings are invalid" inMemoryType="bitfield1" name="motorSettings" />
        <Data comment="Reserved for future use" inMemoryType="bitfield1" name="reservedD" />
        <Data comment="Reserved for future use" inMemoryType="bitfield1" name="reservedE" />
        <Data comment="Reserved for future use" inMemoryType="bitfield1" name="reservedF" />
        <Data comment="Reserved for future use" inMemoryType="bitfield1" name="reservedG" />
    </Structure>

    
    <Packet ID="PKT_ESC_STATUS_A" comment="Legacy (gen-1) definition for the STATUS_A packet" file="LegacyESCPackets" name="LegacyStatusA" parameterInterface="true">
        <Data checkConstant="true" comment="Set to 0 to indicate a Gen-2 ESC" constant="0" encodedType="bitfield1" inMemoryType="null" name="version" />
        <Data comment="ESC operating mode. The lower four bits indicate the operational mode of the ESC, in accordance with the ESCOperatingModes enumeration. The upper 3 bits are used for debugging and should be ignored for general use." encodedType="bitfield7" inMemoryType="unsigned8" name="mode" />
        <Data comment="ESC status bits" name="status" struct="LegacyStatusBits" />
        <Data comment="ESC warning bits" name="warnings" struct="LegacyWarningBits" />
        <Data comment="ESC *error* bits" name="errors" struct="LegacyErrorBits" />
        <Data comment="ESC operational command - value depends on 'mode' available in this packet. If the ESC is disabled, data reads 0x0000. If the ESC is in open-loop PWM mode, this value is the PWM command in units of 1us, in the range 1000us to 2000us. If the ESC is in closed-loop RPM mode, this value is the RPM command in units of 1RPM" inMemoryType="unsigned16" name="command" />
        <Data comment="Motor speed" inMemoryType="unsigned16" name="rpm" units="1RPM per bit" />
    </Packet>

    <Enum comment="Constant values required for sending a disable (inhibit) command" description="These values are required for the DISABLE command" name="ESCDisableSequence">
        <Value comment="Constant value required for disabling the ESC" name="ESC_DISABLE_A" value="0xAA" />
        <Value comment="Constant value required for disabling the ESC" name="ESC_DISABLE_B" value="0xC3" />
    </Enum>
    
    <Enum comment="Constant values required for sending an enable command" description="These values are required for the ENABLE command" name="ESCEnableSequence">
        <Value comment="Constant value required for enabling the ESC" name="ESC_ENABLE_A" value="0xAA" />
        <Value comment="Constant value required for enabling the ESC" name="ESC_ENABLE_B" value="0x3C" />
    </Enum>
    
    <Enum comment="ESC Operational Modes" description="These values define the various modes of operation of the ESC" lookup="true" name="ESCOperatingModes" prefix="ESC_MODE_">
        <Value comment="ESC is in standby mode - the motor is OFF but the ESC is ready to accept motor commands" name="STANDBY" value="0x00" />
        <Value comment="ESC is controlling motor in open-loop mode based on a 'PWM' (Pulse Width) input" name="PWM" />
        <Value comment="ESC is controlling motor speed based on an RPM setpoint" name="RPM" />
        <Value comment="ESC mode counter" ignorePrefix="true" name="ESC_VALID_MODES" />
    </Enum>
    
    <Enum comment="ESC Command Sources" description="These values define the source that the ESC has received its most recent valid command from" lookup="true" name="ESCCommandSources" prefix="ESC_COMMAND_SOURCE_">
        <Value comment="No valid command has been received" name="NONE" value="0x00" />
        <Value comment="Most recent command from CAN" name="CAN" />
        <Value comment="Most recent command from PWM" name="PWM" />
    </Enum>
	
	<Enum comment="ESC motor temperature sensor options" description="These values define the supported motor temperature sensors" lookup="true" name="ESCMotorTemperatureSensor" prefix="ESC_MOTOR_TEMP_SENSOR_">
		<Value comment="No temperature sensor selected" name="OFF" value="0x00" />
		<Value comment="KTY84 or equivalent" name="KTY84" />
		<Value comment="KTY83 or equivalent" name="KTY83" />
        <Value comment="Use a custom temperature lookup table" name="CUSTOM" />
	</Enum>
    
    <Enum comment="ESC Command Priorities" lookup="true" name="ESCCommandPriorities" prefix="ESC_COMMAND_PRIORITY_">
        <Value comment="Commands only from CAN, PWM hardware input is disabled" name="CAN_ONLY" value="0x00" />
        <Value comment="Commands from CAN or PWM hardware input, CAN takes priority" name="CAN_PRIORITY" />
        <Value comment="Commands from CAN or PWM hardware input, PWM takes priority" name="PWM_PRIORITY" />
    </Enum>
    
    <Enum comment="Motor direction" lookup="true" name="ESCMotorDirection" prefix="ESC_MOTOR_DIR_">
        <Value comment="Motor phase sequence A / B / C" name="ABC" value="0" />
        <Value comment="Motor phase sequence A / C / B" name="ACB" value="1" />
        
        <Value comment="Unknown / unsupported direction" name="OTHER" value="3" />
    </Enum>
    
    <Enum comment="Hall sensor modes" lookup="true" name="ESCHallSensorMode" prefix="ESC_HALL_MODE_">
        <Value comment="Sensorless control only" name="SENSORLESS" value="0" />
        <Value comment="Sensored control only" name="SENSORED" value="1" />
        <Value comment="Sensored starting transitioning to sensorless running" name="SENSORED_STARTING" value="2" />
    </Enum>
    
    <Enum comment="AFW operation modes" lookup="true" name="ESCAFWModes" prefix="ESC_AFW_MODE_">
        <Value comment="AFW always off (during this motor running state)" name="OFF" value="0" />
        <Value comment="AFW always on (during this motor running state)" name="ON" value="1" />
        <Value comment="AFW may change state" name="DYNAMIC" value="2" />
        <Value comment="Future expansion" name="OTHER" value="3" />
    </Enum>
    
    <Enum comment="PWM operation modes" lookup="true" name="ESCPWMFreqModes" prefix="ESC_PWM_FREQ_">
        <Value comment="PWM frequency is the specified value" name="FIXED" value="0" />
        <Value comment="" name="RAMP" value="1" />

        <Value comment="Future expansion" name="OTHER" value="3" />
    </Enum>
    
    <Enum comment="PWM operation modes" lookup="true" name="ESCTimingAdvanceModes" prefix="ESC_TIMING_ADVANCE_MODE_">
        <Value comment="Timing advance is the specified value" name="FIXED" value="0" />
        <Value comment="" name="RAMP" value="1" />
        <Value comment="Future expansion" name="OTHER" value="3" />
    </Enum>
    
    <Enum comment="ESC protection actions" lookup="true" name="ESCProtectionActions" prefix="ESC_PROTECTION_">
        <Value comment="Warning bit is set" name="WARNING" value="0" />
        <Value comment="Motor duty cycle is limited" name="FOLDBACK" value="1" />
        <Value comment="ESC is disabled" name="DISABLE" value="2" />
        
        <Value comment="Invalid protection action" name="INVALID" value="7" />
    </Enum>
    
    <Enum comment="Motor beep modes enumeration" lookup="true" name="ESCBeepModes" prefix="ESC_BEEP_">
        <Value name="NONE" value="0b00" />
        <Value comment="Motor status beeps only" name="STATUS" value="0b01" />
        <Value comment="Motor error beeps only" name="ERROR" value="0b10" />
        <Value comment="All motor beeps" name="ALL" value="0b11" />
    </Enum>
    
    <Enum comment="ESC standby cause flags" description="These flags indicate the cause(s) of an ESC standby event." lookup="true" name="ESCStandbyCause" prefix="ESC_STANDBY_CAUSE_">
        <Value comment="ESC was put into *STANDBY* mode by a command" name="CMD" value="0x0001" />
        <Value comment="ESC was put into *STANDBY* mode by SW or HW inhibit" name="INHIBIT" value="0x0002" />
        <Value comment="ESC was put into *STANDBY* mode due to keepalive timeout" name="TIMEOUT" value="0x0004" />
        <Value comment="ESC was put into *STANDBY* mode due to a hall sensor error" name="HALL_SENSOR_ERROR" value="0x0008" />
        <Value comment="ESC was put into *STANDBY* mode due to a command being invalid" name="INVALID_CMD" value="0x0010" />
        <Value comment="PWM arming signal detected" name="PWM_ARM" value="0x0020" />
        <Value comment="ESC was put into *STANDBY* mode due to failed starting routine" name="FAILED_START" value="0x0040" />
        <Value comment="ESC was put into *STANDBY* mode due to the received command below minimum threshold" name="MIN_CMD" value="0x0080" />
        <Value comment="ESC was put into *STANDBY* mode due to failed resync routine" name="FAILED_RESYNC" value="0x0100" />
        
        <Value comment="" name="RESET" value="0x8000" />
    </Enum>
   
    <Enum comment="ESC disable cause flags" description="These flags indicate the cause(s) of an ESC disable event." lookup="true" name="ESCDisableCause" prefix="ESC_DISABLE_CAUSE_">
        <Value comment="Unused / blank value" name="NONE" value="0x0000" />
        <Value comment="ESC is disabled by a CAN command" name="CAN_CMD" value="0x0001" />
        <Value comment="PWM signal lost" name="PWM_TIMEOUT" value="0x0002" />
        <Value comment="Hardware enable signal deasserted" name="HARDWARE" value="0x0004" />
        <Value comment="ESC disabled due to overcurrent" name="OVERCURRENT" value="0x0008" />
        <Value comment="ESC disabled due to overspeed" name="OVERSPEED" value="0x0010" />
        <Value comment="ESC disabled due to overtemperature" name="OVERTEMP" value="0x0020" />
        <Value comment="ESC disabled due to undervoltage" name="UNDERVOLTAGE" value="0x0040" />
        <Value comment="ESC disabled due to starting failure (see ESCFailedStartCause for details)" name="FAILED_START" value="0x0080" />
        <Value comment="ESC disabled due to commutation failure" name="COMMUTATION_ERROR" value="0x0100" />
        <Value comment="ESC disabled due to invalid commutation state" name="INVALID_STATE" value="0x2000" />
        <Value comment="ESC is disabled by processor reset" name="RESET" value="0x8000" />
    </Enum>
    
    <Enum comment="ESC motor OFF cause" description="These flags indicate the cause(s) of an ESC motor off event" lookup="true" name="ESCMotorOffCause" prefix="ESC_MOTOR_OFF_">
    
        <Value comment="Motor turned off due to system standby" name="STANDBY" value="0x0001" />
        <Value comment="Motor turned off due to beeping routine" name="BEEP" value="0x0002" />
        <Value comment="Motor turned off at system initialisation" name="INITIALISE" value="0x0004" />
        
        <Value comment="Motor turned off due to ESC being inhibited" name="INHIBITED" value="0x0010" />
        <Value comment="Throttle below minimum value" name="THROTTLE_MIN" value="0x0020" />
        <Value comment="Motor does not have valid commutation" name="NOT_RUNNING" value="0x0040" />
        <Value comment="Starting routine failed" name="FAILED_START" value="0x0080" />
        
        <Value comment="" name="INVALID" value="0x8000" />
        
    </Enum>
    
    <Enum comment="Failed start cause flags" description="These flags indicate the cause(s) of an ESC motor starting failure" lookup="true" name="ESCFailedStartCause" prefix="ESC_FAILED_START_CAUSE_">
        <Value comment="No failed start has been recorded" name="RESET" value="0x0000" />
        <Value comment="Starting procedure timed out" name="TIMEOUT" value="0x0001" />
        <Value comment="Commutation speed too high" name="OVERSPEED" value="0x0002" />
        <Value comment="Starting current exceeded" name="OVERCURRENT" value="0x0004" />
        <Value comment="Motor is already spinning, in reverse direction" name="SPIN_REVERSED" value="0x0010" />
        <Value comment="Motor is already spinning, above maximum catch speed" name="SPIN_TOO_FAST" value="0x0020" />
        
        <Value comment="" name="INVALID" value="0x8000" />
    </Enum>
    
    <Enum comment="ESC Multi Command Packets" description="These packets can be used to send commands to 4 (four) ESCs with sequential CAN address identifiers, using a single CAN message. When sending these messages, they must be broadcast (using the special ESC broadcast address) so that each of the four target ESCs accept the CAN message." lookup="true" name="ESCMultiCommandPackets" prefix="PKT_ESC_">
        <Value comment="This packet is used to send commands to multiple ESCs with sequential CAN IDs 1 - 4" name="SETPOINT_1" value="0" />
        <Value comment="This packet is used to send commands to multiple ESCs with sequential CAN IDs 5 - 8" name="SETPOINT_2" />
        <Value comment="This packet is used to send commands to multiple ESCs with sequential CAN IDs 9 - 12" name="SETPOINT_3" />
        <Value comment="This packet is used to send commands to multiple ESCs with sequential CAN IDs 13 - 16" name="SETPOINT_4" />
        <Value comment="This packet is used to send commands to multiple ESCs with sequential CAN IDs 17 - 20" name="SETPOINT_5" />
        <Value comment="This packet is used to send commands to multiple ESCs with sequential CAN IDs 21 - 24" name="SETPOINT_6" />
        <Value comment="This packet is used to send commands to multiple ESCs with sequential CAN IDs 25 - 28" name="SETPOINT_7" />
        <Value comment="This packet is used to send commands to multiple ESCs with sequential CAN IDs 29 - 32" name="SETPOINT_8" />
        <Value comment="This packet is used to send commands to multiple ESCs with sequential CAN IDs 33 - 36" name="SETPOINT_9" />
        <Value comment="This packet is used to send commands to multiple ESCs with sequential CAN IDs 37 - 40" name="SETPOINT_10" />
        <Value comment="This packet is used to send commands to multiple ESCs with sequential CAN IDs 41 - 44" name="SETPOINT_11" />
        <Value comment="This packet is used to send commands to multiple ESCs with sequential CAN IDs 45 - 48" name="SETPOINT_12" />
        <Value comment="This packet is used to send commands to multiple ESCs with sequential CAN IDs 49 - 52" name="SETPOINT_13" />
        <Value comment="This packet is used to send commands to multiple ESCs with sequential CAN IDs 53 - 56" name="SETPOINT_14" />
        <Value comment="This packet is used to send commands to multiple ESCs with sequential CAN IDs 57 - 60" name="SETPOINT_15" />
        <Value comment="This packet is used to send commands to multiple ESCs with sequential CAN IDs 61 - 64" name="SETPOINT_16" />
    </Enum>
    
    <Enum comment="ESC Command Packets" description="Command packets are sent to the ESC to change its operational mode. These packets **must** be fully implemented in the connected avionics system for complete operation of the PCU" lookup="true" name="ESCCommandPackets" prefix="PKT_ESC_">
        <Value comment="Send a PWM (Pulse width) command to a particular ESC" name="PWM_CMD" value="0x10" />
        <Value comment="Send an RPM (Speed) command to a particular ESC" name="RPM_CMD" />
        
        <Value comment="Send this packet to an ESC to disable the ESC" name="DISABLE" value="0x20" />
        <Value comment="Send this packet to an ESC to enable the ESC and place it in Standby mode" name="STANDBY" />
    </Enum>
    
    <Enum comment="ESC Status Packets" description="Status packets are transmitted by the ESC at (user-configurable) intervals. These packets contain vital system information and should be fully implemented by the connected avionics device(s)." lookup="true" name="ESCStatusPackets" prefix="PKT_ESC_">
        
        <Value comment="ESC Status A telemetry packet transmitted by the ESC at regular intervals" name="STATUS_A" value="0x80" />
        <Value comment="ESC Status B telemetry packet transmitted by the ESC at regular intervals" name="STATUS_B" />
        <Value comment="ESC Status C telemetry packet transmitted by the ESC at regular intervals (reserved for future use)" name="STATUS_C" />
        <Value comment="Raw accelerometer data" name="ACCELEROMETER" value="0x88" />
    </Enum>
    
    <Enum comment="ESC Packets Definitions" description="ESC configuration packets. Each packet can be requested from the ESC by sending a zero-length packet of the same type." lookup="true" name="ESCPackets" prefix="PKT_ESC_">
                
        <Value comment="Send a configuration command to the ESC (followed by optional command data bytes)" name="SYSTEM_CMD" value="0x50" />
        <Value comment="Control loop output data - varies depending on the operational mode of the ESC" name="CONTROL_LOOP_DATA" value="0x8A" />
        
        <Value comment="ESC warning / error status information." name="WARNINGS_ERRORS" value="0x86" />
        <Value comment="Motor status flags" name="MOTOR_FLAGS" />
        
        <Value comment="Event description packet" name="EVENT" value="0x8D" />
        
        
        <Value comment="ESC Serial Number and User ID information" name="SERIAL_NUMBER" value="0x90" />
        <Value comment="Human-readable string descriptor (max 8 chars) of the particular ESC" name="TITLE" />
        <Value comment="ESC Firmware information" name="FIRMWARE" />
        <Value comment="ESC system information packet" name="SYSTEM_INFO" />
        <Value comment="Telemetry packet configuration" name="TELEMETRY_SETTINGS" />
        <Value comment="ESC non-volatile data information and settings" name="EEPROM" />
        
        <Value comment="ESC commissioning data (factory only)" hidden="true" name="COMMISSIONING" value="0x99" />
        <Value comment="ESC telltales" name="TELLTALES" />
        <Value comment="ESC firmware git hash" name="GIT_HASH" />
        
        
        
        <Value comment="ESC motor configuration" hidden="true" name="LEGACY_MOTOR_SETTINGS" value="0xA5" />
        <Value comment="ESC motor control firmware information" hidden="true" name="LEGACY_MOTOR_FIRMWARE" value="0xAA" />
        
        <Value comment="Motor control settings packet" name="MOTOR_SETTINGS" value="0xA7" />
        <Value comment="Motor starting settings packet" name="MOTOR_STARTING" value="0xA8" />
        <Value comment="Motor and system parameters" name="MOTOR_PARAMETERS" value="0xA9" />
        
        
        <Value comment="ESC Configuration parameters" name="CONFIG" value="0xB0" />
        <Value comment="ESC protection values" name="PROTECTION_LEVELS" value="0xB2" />
        <Value comment="ESC protection actions" name="PROTECTION_ACTIONS" value="0xB3" />
        
        <Value comment="RPM Control Loop Settings" name="RPM_LOOP_SETTINGS" value="0xB5" />
        
        
        <Value comment="ESC current sense calibration settings" hidden="true" name="CURRENT_CALIBRATION" />
        
        
        <Value comment="A single element of the Input/Output mapping table" hidden="true" name="IO_TABLE_ELEMENT" />
        
        <Value comment="Throttle curve calibration" name="THROTTLE_CURVE" value="0xC2" />
        <Value comment="PWM input calibration" name="PWM_INPUT_CALIBRATION" value="0xC3" />
        
        
		
		</Enum>
        
    <Enum comment="ESC System Commands" description="These commands can be sent using the ESC_SYSTEM_CMD packet. Read further in this document for information on individual command packets." lookup="true" name="ESCSystemCommands" prefix="CMD_ESC_">
    
        <Value comment="Set the CAN Node ID for the target ESC" name="SET_NODE_ID" value="0x50" />
        <Value comment="Set user ID A value" name="SET_USER_ID_A" />
        <Value comment="Set user ID B value" name="SET_USER_ID_B" />
        
        <Value comment="Tare the current measurement" name="TARE_CURRENT" value="0x60" />
        
        <Value comment="Identify the ESC with a sequence of LED flashes / beeps" name="IDENTIFY" value="0x70" />
        
        <Value comment="Request high-frequency telemetry data" name="REQUEST_HF_DATA" value="0xB0" />
        
        <Value comment="Configure the Input/Output map for the ESC" name="CONFIGURE_IO_MAP" value="0xC0" />
        <Value comment="Configure (or request) a particular element of the I/O map" name="CONFIGURE_IO_ELEMENT" />
        
        <Value comment="Reset ESC settings to default parameters" name="RESET_SETTINGS" value="0xD0" />
        
        <Value comment="Exit debug mode" hidden="true" name="EXIT_DEBUG" />
         
        <Value comment="Unlock ESC nonvolatile settings" name="UNLOCK_SETTINGS" value="0xF5" />
        <Value comment="Lock ESC nonvolatile settings" name="LOCK_SETTINGS" value="0xF6" />
        <value comment="Mark the current settings as valid" name="VALIDATE_SETTINGS" value="0xF7" />
        
        <Value comment="Reset motor run time" name="RESET_MOTOR_RUN_TIME" value="0xFA" />
 
        <Value comment="Enter bootloader mode" name="ENTER_BOOTLOADER" value="0xFB" />
        <Value comment="Reset ESC" name="RESET" />
 
    </Enum>            

    
       
    <Structure comment="The *status* of the ESC is represented using these status bits. ESC system functionality can be quickly determined using these bits" file="ESCDefines" map="false" name="StatusBits">
        <Data comment="Set if hardware inhibit is active (ESC is disabled)" encodedType="bitfield1" inMemoryType="bool" name="hwInhibit" />
        <Data comment="Set if software inhibit is active (ESC is disabled)" encodedType="bitfield1" inMemoryType="bool" name="swInhibit" />
        <Data comment="Set if Active Freewheeling is currently active" encodedType="bitfield1" inMemoryType="bool" name="afwEnabled" />
        <Data comment="0 = Motor direction is FORWARDS, 1= Motor direction is REVERSE" encodedType="bitfield1" inMemoryType="unsigned8" name="direction" />
        <Data comment="Set if the ESC command timeout period has elapsed (and the ESC is in STANDBY mode)" encodedType="bitfield1" inMemoryType="bool" name="timeout" />
        <Data comment="Set if ESC is in starting mode (Cleared if ESC is stopped or running)" encodedType="bitfield1" inMemoryType="bool" name="starting" />
        <Data comment="0 = most recent command from CAN, 1 = most recent command from PWM" encodedType="bitfield1" inMemoryType="unsigned8" name="commandSource" />
        <Data comment="Set if ESC is running" encodedType="bitfield1" inMemoryType="bool" name="running" />
        <Data comment="Warning active - refer to the PKT_ESC_WARNINGS_ERRORS packet" encodedType="bitfield1" inMemoryType="bool" name="anyWarnings" />
        <Data comment="Error active - refer to the PKT_ESC_WARNINGS_ERRORS packet" encodedType="bitfield1" inMemoryType="bool" name="anyErrors" />
		<Data comment="Reserved bits for future use" constant="0" encodedType="bitfield5" inMemoryType="null" name="reservedBitsA" />
        <Data comment="Set if the motor is spinning (even if it is not being driven)" encodedType="bitfield1" inMemoryType="bool" name="spinning" />
        <Data comment="Set if motor is spinning opposite to configured rotation direction" encodedType="bitfield1" inMemoryType="bool" name="spinningReversed" />
        <Data comment="Set if motor duty cycle is being limited due to ESC protection settings" encodedType="bitfield1" inMemoryType="bool" name="foldback" />
        <Data comment="Set if the ESC is attempting to sync with the motor" encodedType="bitfield1" inMemoryType="bool" name="syncing" />
        <Data comment="Reserved bits for future use" constant="0" encodedType="bitfield4" inMemoryType="null" name="reservedBitsC" />
        <Data comment="Set if the ESC is in debug mode (factory use only)" encodedType="bitfield1" inMemoryType="bool" name="debug" />
    </Structure>
    
    <Structure comment="The *warning* bits enumerate various system warnings/errors of which the user (or user software) should be made aware. These *warning* bits are transmitted in the telemetry packets such that user software is aware of any these *warning* conditions and can poll the ESC for particular packets if any further information is needed. The ESC will continue to function in the case of a *warning* state" file="ESCDefines" map="false" name="WarningBits">
        <Data comment="Reserved for future use" constant="0" encodedType="bitfield1" inMemoryType="null" name="reserved" />
        <Data comment="Set if the ESC motor speed exceeds the configured warning threshold" encodedType="bitfield1" inMemoryType="bool" name="overspeed" />
        <Data comment="Set if the ESC motor current (positive or negative) exceeds the configured warning threshold" encodedType="bitfield1" inMemoryType="bool" name="overcurrent" />
        <Data comment="Set if the internal ESC temperature is above the warning threshold" encodedType="bitfield1" inMemoryType="bool" name="escTemperature" />
        <Data comment="Set if the motor temperature is above the warning threshold" encodedType="bitfield1" inMemoryType="bool" name="motorTemperature" />
        <Data comment="Set if the input voltage is below the minimum threshold" encodedType="bitfield1" inMemoryType="bool" name="undervoltage" />
        <Data comment="Set if the input voltage is above the maximum threshold" encodedType="bitfield1" inMemoryType="bool" name="overvoltage" />    
        <Data comment="Set if hardware PWM input is enabled but invalid" encodedType="bitfield1" inMemoryType="bool" name="invalidPWMsignal" />
        <Data comment="Set if the motor demag angle exceeds the maximum threshold" encodedType="bitfield1" inMemoryType="bool" name="demagAngle" />
        <Data comment="Set if the auto-advance exceeds 25 degrees" encodedType="bitfield1" inMemoryType="bool" name="advanceLimit" />
        <Data comment="Set if the measured demag pulse is exceptionally long" encodedType="bitfield1" inMemoryType="bool" name="longDemag" />
        <Data comment="Set if a zero-crossing measurement was missed" encodedType="bitfield1" inMemoryType="bool" name="missedZeroCrossing" />
        <Data comment="Motor is spinning in the wrong direction" encodedType="bitfield1" inMemoryType="bool" name="spinningReversed" />
        <Data comment="Motor has reached maximum allowable commutation speed" encodedType="bitfield1" inMemoryType="bool" name="commSpeedLimit" />
        <Data comment="Settings checksum does not match programmed value" encodedType="bitfield1" inMemoryType="bool" name="settingsChecksum" />
        <Data comment="Reserved for future use" constant="0" encodedType="bitfield1" inMemoryType="null" name="reservedBits" />
    </Structure>
    
    <Structure comment="The *error* bits enumerate critical system errors that will cause the ESC to stop functioning until the error cases are alleviated" file="ESCDefines" map="false" name="ErrorBits">
        <Data comment="Set if the ESC failed to start the motor" encodedType="bitfield1" inMemoryType="bool" name="failedStart" />
        <Data comment="Lost commutation" encodedType="bitfield1" inMemoryType="bool" name="commutation" />
        <Data comment="Set if hall sensor error detected" encodedType="bitfield1" inMemoryType="bool" name="hallSensor" />
        <Data comment="Current exceeded hard-limit" encodedType="bitfield1" inMemoryType="bool" name="overcurrent" />
        <Data comment="Temperature exceeded hard-limit" encodedType="bitfield1" inMemoryType="bool" name="overtemperature" />
        <Data comment="Motor commutation speed exceeded hard-limit" encodedType="bitfield1" inMemoryType="bool" name="overspeed" />
        <Data comment="Motor stopped due to high demag angle" encodedType="bitfield1" inMemoryType="bool" name="demag" />
        <Data comment="Reserved for future use" constant="0" encodedType="bitfield8" inMemoryType="null" name="reservedA" />
        <Data comment="Reserved for future use" constant="0" encodedType="bitfield1" inMemoryType="null" name="reservedB" />
    </Structure>
    
    
    <Structure comment="These bits are used to determine which packets are automatically transmitted as telemetry data by the ESC. Only the packets described here can be configured as telemetry packets" file="ESCDefines" map="true" name="TelemetryPackets">
        <Data comment="If this bit is set, the STATUS_A packet will be transmitted at the configured rate" encodedType="bitfield1" inMemoryType="bool" initialValue="1" name="statusA" />
        <Data comment="If this bit is set, the STATUS_B packet will be transmitted at the configured rate" encodedType="bitfield1" inMemoryType="bool" initialValue="1" name="statusB" />
        <Data comment="If this bit is set, the STATUS_C packet will be transmitted at the configured rate" encodedType="bitfield1" inMemoryType="bool" initialValue="1" name="statusC" />
        <Data comment="If this bit is set, the ACCELEROMETER packet will be transmitted at the configured rate" encodedType="bitfield1" inMemoryType="bool" initialValue="0" name="accelerometer" />
        
        <Data comment="If this bit is set, the STATUS_D packet will be transmitted at the configured rate" encodedType="bitfield1" inMemoryType="bool" name="statusD" />
        <Data comment="Reserved for future use" encodedType="bitfield1" inMemoryType="bool" name="reservedTelemA" />
        <Data comment="If this bit is set, any STATUS_x packets selected for telemetry will be mirrored on the Piccolo Downlink packet group (0x14)" encodedType="bitfield1" inMemoryType="bool" name="piccoloDownlink" />
        <Data comment="Reserved for future use" encodedType="bitfield1" inMemoryType="bool" name="reservedTelemC" />
    </Structure>
    
    <Structure comment="These bits are used to select which debug packets are transmitted at high-frequency by the ESC" file="ESCDefines" name="DebugPackets">
        <Data comment="Control loop terms" default="0" encodedType="bitfield1" inMemoryType="bool" name="ctrlLoopOutputs" />
        <Data comment="Hall sensor debug information" default="0" encodedType="bitfield1" inMemoryType="bool" name="hallSensors" />
        <Data comment="Commutation debug information" default="0" encodedType="bitfield1" inMemoryType="bool" name="commutation" />
        <Data comment="Demag debug information" default="0" encodedType="bitfield1" inMemoryType="bool" name="demag" />
        <Data comment="PWM input debug information" default="0" encodedType="bitfield1" inMemoryType="bool" name="pwmInput" />
        <Data comment="Reserved for future use" constant="0" default="0" encodedType="bitfield3" inMemoryType="null" name="reservedA" />
        <Data comment="Reserved for future use" constant="0" default="0" encodedType="unsigned8" inMemoryType="null" name="reservedB" />
    </Structure>
    
    
    
    <Packet ID="PKT_ESC_SETPOINT_1 PKT_ESC_SETPOINT_2 PKT_ESC_SETPOINT_3 PKT_ESC_SETPOINT_4 PKT_ESC_SETPOINT_5 PKT_ESC_SETPOINT_6 PKT_ESC_SETPOINT_7 PKT_ESC_SETPOINT_8 PKT_ESC_SETPOINT_9 PKT_ESC_SETPOINT_10 PKT_ESC_SETPOINT_11 PKT_ESC_SETPOINT_12 PKT_ESC_SETPOINT_13 PKT_ESC_SETPOINT_14 PKT_ESC_SETPOINT_15 PKT_ESC_SETPOINT_16" comment="Send this packet to command ESCs which have CAN ID values in the range {1,4} (inclusive). This packet must be sent as a broadcast packet (address = 0xFF) such that all ESCs can receive it. Similiar commands are available for commanding ESCs with ID values up to 64, using different ESC_SETPOINT_x packet ID values." name="CommandMultipleESCs" parameterInterface="true">
        <Data comment="The PWM (pulse width) command for ESC with CAN ID 1" inMemoryType="unsigned16" name="pwmValueA" units="1us per bit" />
        <Data comment="The PWM (pulse width) command for ESC with CAN ID 2" inMemoryType="unsigned16" name="pwmValueB" units="1us per bit" />
        <Data comment="The PWM (pulse width) command for ESC with CAN ID 3" inMemoryType="unsigned16" name="pwmValueC" units="1us per bit" />
        <Data comment="The PWM (pulse width) command for ESC with CAN ID 4" inMemoryType="unsigned16" name="pwmValueD" units="1us per bit" />
    </Packet>
    
    <Packet ID="PKT_ESC_DISABLE" comment="Send this packet to the ESC to disable it. The ESC will not accept PWM/RPM commands until it is re-enabled." name="Disable" parameterInterface="true">
        <Data checkConstant="true" comment="This value must be set for the command to be accepted" constant="ESC_DISABLE_A" encodedType="unsigned8" inMemoryType="null" name="disableSequenceA" />
        <Data checkConstant="true" comment="This value must be set for the command to be accepted" constant="ESC_DISABLE_B" encodedType="unsigned8" inMemoryType="null" name="disableSequenceB" />
    </Packet>
    
    <Packet ID="PKT_ESC_STANDBY" comment="Send this packet to the ESC to enable it. The ESC will be placed in Standby mode." name="Enable" parameterInterface="true">
        <Data checkConstant="true" comment="This value must be set for the command to be accepted" constant="ESC_ENABLE_A" encodedType="unsigned8" inMemoryType="null" name="enableSequenceA" />
        <Data checkConstant="true" comment="This value must be set for the command to be included" constant="ESC_ENABLE_B" encodedType="unsigned8" inMemoryType="null" name="enableSequenceB" />
    </Packet>
    
    <Packet ID="PKT_ESC_PWM_CMD" comment="Send a PWM (pulse width) command to an individual ESC. The pulse width value in specified in microseconds for compatibility with standard ESC interface. Use the broadcast ID (0xFF) to send this command to all ESCs on the CAN bus." name="PWMCommand" parameterInterface="true">
        <Data comment="PWM command" inMemoryType="unsigned16" name="pwmCommand" units="1us per bit" />
    </Packet>
    
    <Packet ID="PKT_ESC_RPM_CMD" comment="Send an RPM (speed) command to an individual ESC. Use the broadcast ID (0xFF) to send this command to all ESCs on the CAN bus" name="RPMCommand" parameterInterface="true">
        <Data comment="RPM Command" inMemoryType="unsigned16" name="rpmCommand" units="RPM" />
    </Packet>
    
     
    
    <Packet ID="PKT_ESC_STATUS_A" comment="The ESC_STATUS_A packet contains high-priority ESC status information. This packet is transmitted by the ESC at regular (user-configurable) intervals. It can also be requested (polled) from the ESC by sending a zero-length packet of the same type." map="false" name="StatusA" parameterInterface="true">
        <Data checkConstant="true" comment="Set to 1 to indicate a Gen-2 ESC" constant="1" encodedType="bitfield1" inMemoryType="null" name="version" />
        <Data comment="Reserved for future use" constant="0" encodedType="bitfield3" inMemoryType="null" name="reservedA" />
        <Data comment="ESC operating mode. The lower four bits indicate the operational mode of the ESC, in accordance with the ESCOperatingModes enumeration. The upper three bits are used for debugging and should be ignored for general use." encodedType="bitfield4" inMemoryType="unsigned8" name="mode" />
        <Data comment="ESC status bits" name="status" struct="StatusBits" />
        <Data comment="ESC operational command - value depends on 'mode' available in this packet. If the ESC is disabled, data reads 0x0000. If the ESC is in open-loop PWM mode, this value is the PWM command in units of 1us, in the range 1000us to 2000us. If the ESC is in closed-loop RPM mode, this value is the RPM command in units of 1RPM" inMemoryType="unsigned16" name="command" />
        <Data comment="Motor speed" inMemoryType="unsigned16" name="rpm" units="1RPM per bit" />
    </Packet>
    
    <Packet ID="PKT_ESC_STATUS_B" comment="The ESC_STATUS_B packet contains ESC operational information. This packet is transmitted by the ESC at regular (user-configurable) intervals. It can also be requested (polled) from the ESC by sending a zero-length packet of the same type." map="false" name="StatusB" parameterInterface="true">
        <Data comment="ESC Rail Voltage" inMemoryType="unsigned16" name="voltage" units="0.1V per bit" />
        <Data comment="ESC Current. Current IN to the ESC is positive. Current OUT of the ESC is negative" inMemoryType="signed16" name="current" units="0.1A per bit" />
        <Data comment="ESC Motor Duty Cycle" inMemoryType="unsigned16" name="dutyCycle" units="0.1% per bit" />
        <Data comment="ESC Logic Board Temperature" inMemoryType="signed8" name="escTemperature" range="-128C to +127C" units="1 degree C per bit" />
        <Data comment="ESC Motor Temperature" inMemoryType="unsigned8" name="motorTemperature" range="-50 to +205 (0 = -50C)" units="1 degree C per bit" />
    </Packet>
    
    
    
    <Packet ID="PKT_ESC_STATUS_C" map="false" name="StatusC" parameterInterface="true">
        
        <Data comment="Reserved for future use" constant="0" encodedType="signed16" inMemoryType="null" name="reserved" />
        <Data comment="ESC Phase Board Temperature" encodedType="unsigned8" inMemoryType="float" max="205" min="-50" name="fetTemperature" />
        <Data comment="Current motor PWM frequency (10 Hz per bit)" inMemoryType="unsigned16" name="pwmFrequency" />
        <Data comment="Current timing advance (0.1 degree per bit)" inMemoryType="unsigned16" name="timingAdvance" />
    </Packet>
    
    
    <Packet ID="PKT_ESC_ACCELEROMETER" comment="This packet contains raw accelerometer data from the ESC. It can be requested (polled) from the ESC by sending a zero-length packet of the same type. It can also be transmitted by the ESC at high-frequency using the high-frequency streaming functionality of the ESC" map="false" name="Accelerometer" parameterInterface="true">
        <Data comment="X axis acceleration value" inMemoryType="signed16" name="xAcc" notes="Multiply by (0.5 * fullscale / 2^resolution) to get acceleration value in 'g' units" range="-0x7FFF to +0x7FFF" />
        <Data comment="Y axis acceleration value" inMemoryType="signed16" name="yAcc" notes="Multiply by (0.5 * fullscale / 2^resolution) to get acceleration value in 'g' units" range="-0x7FFF to +0x7FFF" />
        <Data comment="Z axis acceleration value" inMemoryType="signed16" name="zAcc" notes="Multiply by (0.5 * fullscale / 2^resolution) to get acceleration value in 'g' units" range="-0x7FFF to +0x7FFF" />
        <Data comment="Accelerometer full-scale range" inMemoryType="unsigned8" name="fullscale" />
        <Data comment="Accelerometer measurement resolution, in 'bits'." inMemoryType="unsigned8" name="resolution" />
    </Packet>
    
    <Packet ID="PKT_ESC_WARNINGS_ERRORS" comment="Warning and error status information" map="false" name="WarningErrorStatus" parameterInterface="true" structureInterface="true">
        <Data name="warnings" struct="WarningBits" />
        <Data name="errors" struct="ErrorBits" />
    </Packet>
    
    
    
    <Packet ID="PKT_ESC_SYSTEM_CMD" comment="Set the CAN Node ID of the target ESC" file="ESCCommands" map="false" name="SetNodeID" parameterInterface="true">
        <Data checkConstant="true" constant="CMD_ESC_SET_NODE_ID" encodedType="unsigned8" inMemoryType="null" name="command" />
        <Data comment="The serial number must match that of the target ESC for the command to be accepted" inMemoryType="unsigned32" name="serialNumber" />
        <Data comment="The new Node ID of the ESC" inMemoryType="unsigned8" name="nodeID" notes="An ESC with a Node ID of zero (0) will be disabled" range="0 to 254" />
    </Packet>
    
    <Packet ID="PKT_ESC_SYSTEM_CMD" comment="Set User ID A" file="ESCCommands" map="false" name="SetUserIDA" parameterInterface="true">
        <Data checkConstant="true" constant="CMD_ESC_SET_USER_ID_A" encodedType="unsigned8" inMemoryType="null" name="command" />
        <Data comment="" inMemoryType="unsigned16" name="id" units="" />
    </Packet>
    
    <Packet ID="PKT_ESC_SYSTEM_CMD" comment="Set User ID B" file="ESCCommands" map="false" name="SetUserIDB" parameterInterface="true">
        <Data checkConstant="true" constant="CMD_ESC_SET_USER_ID_B" encodedType="unsigned8" inMemoryType="null" name="command" />
        <Data comment="" inMemoryType="unsigned16" name="id" units="" />
    </Packet>
    
    <Packet ID="PKT_ESC_SYSTEM_CMD" file="ESCCommands" map="false" name="UnlockSettings">
        <Data checkConstant="true" constant="CMD_ESC_UNLOCK_SETTINGS" encodedType="unsigned8" inMemoryType="null" name="command" />
        <Data checkConstant="true" constant="0xA0" encodedType="unsigned8" inMemoryType="null" name="unlockSeqA" />
        <Data checkConstant="true" constant="0xB0" encodedType="unsigned8" inMemoryType="null" name="unlockSeqB" />
        <Data checkConstant="true" constant="0xC0" encodedType="unsigned8" inMemoryType="null" name="unlockSeqC" />
    </Packet>
    
    <Packet ID="PKT_ESC_SYSTEM_CMD" file="ESCCommands" map="false" name="LockSettings">
        <Data checkConstant="true" constant="CMD_ESC_LOCK_SETTINGS" encodedType="unsigned8" inMemoryType="null" name="command" />
        <Data checkConstant="true" constant="0x0A" encodedType="unsigned8" inMemoryType="null" name="lockSeqA" />
        <Data checkConstant="true" constant="0x0B" encodedType="unsigned8" inMemoryType="null" name="lockSeqB" />
        <Data checkConstant="true" constant="0x0C" encodedType="unsigned8" inMemoryType="null" name="lockSeqC" />
    </Packet>
    
    <Packet ID="PKT_ESC_SYSTEM_CMD" file="ESCCommands" map="false" name="ValidateSettings">
        <Data checkConstant="true" constant="CMD_ESC_VALIDATE_SETTINGS" encodedType="unsigned8" inMemoryType="null" name="command" />
        <Data checkConstant="true" constant="0x1A" encodedType="unsigned8" inMemoryType="null" name="validateSeqA" />
        <Data checkConstant="true" constant="0x2B" encodedType="unsigned8" inMemoryType="null" name="validateSeqB" />
        <Data checkConstant="true" constant="0x3C" encodedType="unsigned8" inMemoryType="null" name="validateSeqC" />
    </Packet>
    
   <Packet ID="PKT_ESC_SYSTEM_CMD" file="ESCCommands" map="false" name="ResetMotorRunTime">
        <Data checkConstant="true" constant="CMD_ESC_RESET_MOTOR_RUN_TIME" encodedType="unsigned8" inMemoryType="null" name="command" />
        <Data checkConstant="true" comment="This byte is required for the command to be accepted" constant="0xAB" encodedType="unsigned8" inMemoryType="null" name="resetSeqA" />
        <Data checkConstant="true" comment="This byte is required for the command to be accepted" constant="0xCD" encodedType="unsigned8" inMemoryType="null" name="resetSeqA" />
        <Data comment="Serial number must match ESC" inMemoryType="unsigned16" name="serialNumber" />
    </Packet>
    
    <Packet ID="PKT_ESC_SYSTEM_CMD" file="ESCCommands" map="false" name="EnterBootloader">
        <Data checkConstant="true" constant="CMD_ESC_ENTER_BOOTLOADER" encodedType="unsigned8" inMemoryType="null" name="command" />
        <Data checkConstant="true" comment="This byte is required for the command to be accepted" constant="0xAA" encodedType="unsigned8" inMemoryType="null" name="bootSeqA" />
        <Data checkConstant="true" comment="This byte is required for the command to be accepted" constant="0x55" encodedType="unsigned8" inMemoryType="null" name="bootSeqB" />
    </Packet>
    
    <Packet ID="PKT_ESC_SYSTEM_CMD" file="ESCCommands" map="false" name="ResetESC">
        <Data checkConstant="true" constant="CMD_ESC_RESET" encodedType="unsigned8" inMemoryType="null" name="command" />
        <Data checkConstant="true" comment="This byte is required for the command to be accepted" constant="0xAA" encodedType="unsigned8" inMemoryType="null" name="resetSeqA" />
        <Data checkConstant="true" comment="This byte is required for the command to be accepted" constant="0xCC" encodedType="unsigned8" inMemoryType="null" name="resetSeqB" />
    </Packet>
      
    
    <Packet ID="PKT_ESC_MOTOR_FLAGS" comment="Motor status flags" name="MotorStatusFlags" parameterInterface="true" structureInterface="true">
        <Data comment="Cause of most recent standby event" enum="ESCStandbyCause" inMemoryType="unsigned16" name="standbyCause" />
        <Data comment="Cause of most recent disable event" enum="ESCDisableCause" inMemoryType="unsigned16" name="disableCause" />
        <Data comment="Cause of most recent motor-stop event" enum="ESCMotorOffCause" inMemoryType="unsigned16" name="offCause" />
        <Data comment="Cause of most recent failed-start" enum="ESCFailedStartCause" inMemoryType="unsigned16" name="failedStartCause" />
    </Packet>
    
    <Packet ID="PKT_ESC_CONFIG" comment="General ESC configuration parameters" map="true" name="Config" parameterInterface="true" structureInterface="true" useInOtherPackets="true">
        <Data comment="1 = ESC is inhibited (disabled) on startup" encodedType="bitfield1" inMemoryType="bool" initialValue="1" name="swInhibit" />
        <Data comment="1 = ESC will respond to PICCOLO autopilot commands" encodedType="bitfield1" inMemoryType="bool" initialValue="1" name="piccoloCommands" />
        <Data comment="1 = ESC will accept broadcast command messages" encodedType="bitfield1" inMemoryType="bool" initialValue="1" name="broadcastCommands" />
        <Data comment="Command input source priority, refer to enumeration ESCCommandPriorities" encodedType="bitfield2" inMemoryType="unsigned8" initialValue="ESC_COMMAND_PRIORITY_CAN_PRIORITY" name="commandInputPriority" />
        <Data comment="Reserved for future use" constant="0" encodedType="bitfield1" inMemoryType="null" name="reserved" /> 
        <Data comment="External motor temperature sensor configuration" encodedType="bitfield2" inMemoryType="unsigned8" name="motorTempSensor" />
        <Data comment="ESC keepalive timeout - If this is non-zero, the ESC will automatically revert to *STANDBY* mode if it does not receive a valid command for the alloted period" inMemoryType="unsigned8" initialValue="100" name="keepalive" notes="0 = No timeout" range="0 to 250 (0.0s to 25.0s)" units="100ms per bit" verifyMaxValue="250" />
        <Data comment="Reserved for future use" encodedType="unsigned8" inMemoryType="null" name="reservedA" />
        <Data comment="Reserved for future use" encodedType="unsigned8" inMemoryType="null" name="reservedB" />
        <Data comment="Reserved for future use" encodedType="unsigned8" inMemoryType="null" name="reservedC" />
        <Data comment="Reserved for future use" encodedType="unsigned16" inMemoryType="null" name="reservedD" />
        <Data encodedType="bitfield3" inMemoryType="unsigned8" initialValue="ESC_BEEP_ALL" name="motorBeepMode" />
        <Data comment="Motor beep volume" encodedType="bitfield5" inMemoryType="unsigned8" initialValue="20" name="motorBeepVolume" units="5% per bit" verifyMaxValue="30" verifyMinValue="1" />
    </Packet>
    
    <Packet ID="PKT_ESC_SERIAL_NUMBER" comment="This packet contains the serial number for the ESC. Additionally there are two extra values (each 16-bit) which can be programmed by the user for any purpose." name="Address" packetType="config" parameterInterface="true" structureInterface="true">
		
		<Data comment="ESC hardware revision (OTP - not configurable by user)" inMemoryType="unsigned8" name="HardwareRevision" />
        <Data comment="ESC model (OTP - not configurable by user)" inMemoryType="unsigned8" name="Model" />
        <Data comment="ESC Serial Number (OTP - not configurable by user)" inMemoryType="unsigned16" name="SerialNumber" />
        <Data comment="User ID Value A - user can set this value to any value" inMemoryType="unsigned16" name="UserIDA" />
        <Data comment="User ID Value B - user can set this value to any value" inMemoryType="unsigned16" name="UserIDB" />
    </Packet>
    
    <Packet ID="PKT_ESC_TITLE" comment="This packet contains a zero-terminated string (max-length 8) used to identify the particular ESC." name="Title" parameterInterface="true">
        <Data array="8" comment="Description of this ESC" inMemoryType="unsigned8" name="ESCTitle" />
    </Packet>
    
    <Packet ID="PKT_ESC_FIRMWARE" comment="This packet contains the firmware version of the ESC" name="Firmware" packetType="config" parameterInterface="true" structureInterface="true">
        <Data comment="Major firmware version number" inMemoryType="unsigned8" name="versionMajor" />
        <Data comment="Minor firmware version numner" inMemoryType="unsigned8" name="versionMinor" />
        <Data comment="Firmware release date, day-of-month" inMemoryType="unsigned8" name="versionDay" range="1-31" />
        <Data comment="Firmware release data, month-of-year" inMemoryType="unsigned8" name="versionMonth" range="1-12" />
        <Data comment="Firmware release date, year" inMemoryType="unsigned16" name="versionYear" />
        <Data comment="Firmware checksum" inMemoryType="unsigned16" name="firmwareChecksum" />
    </Packet>
    
    <Packet ID="PKT_ESC_SYSTEM_INFO" comment="This packet contains system runtime information" name="SystemInfo" parameterInterface="true" structureInterface="true">
        <Data comment="Number of milliseconds since the ESC last experienced a reset/power-on event" inMemoryType="unsigned32" name="millisecondsSinceReset" />
        <Data comment="Number of power cycle events that the ESC has experienced" inMemoryType="unsigned16" name="powerCycles" />
        <Data comment="Processor RESET code for debug purposes" inMemoryType="unsigned8" name="resetCode" />
        <Data comment="Processor usage" inMemoryType="unsigned8" name="cpuOccupancy" units="1% per bit" />
    </Packet>
    
    <Packet ID="PKT_ESC_TELEMETRY_SETTINGS" comment="Telemetry settings (storage class)" name="TelemetryConfig" parameterInterface="true" structureInterface="true" useInOtherPackets="true">
        
        <Data comment="Telemetry period code (maps indirectly to a telemetry period value)" inMemoryType="unsigned8" initialValue="74" name="period" notes="0 = Telemetry disabled" />
        <Data comment="Telemetry silence period (delay after RESET before telemetry data is sent)" inMemoryType="unsigned8" initialValue="20" name="silence" range="0 - 250 (0.0s to 25.0s)" units="50ms per bit" verifyMaxValue="250" />
        <Data comment="Bitfield describing which telemetry packets are enabled" name="packets" struct="TelemetryPackets" />
    </Packet>
    
    <Packet ID="PKT_ESC_TELEMETRY_SETTINGS" comment="This packet contains the telemetry packet configuration" name="TelemetrySettings" parameterInterface="true">
        <Data comment="Telemetry settings" name="settings" struct="TelemetryConfig" />
        <Data array="5" comment="The API version of the ESC" constant="getESCVelocityVersion()" inMemoryType="string" name="apiVersion" />
    </Packet>
    
    <Packet ID="PKT_ESC_EEPROM" comment="This packet contains information on the non-volatile ESC settings" name="EEPROMSettings" parameterInterface="true" structureInterface="true">
        <Data comment="Set if the ESC settings are locked" encodedType="bitfield1" inMemoryType="bool" name="settingsLocked" />
        <Data comment="Version of EEPROM data" encodedType="bitfield7" inMemoryType="unsigned8" name="version" range="1 to 127" />
        <Data comment="Size of settings data" inMemoryType="unsigned16" name="size" />
        <Data comment="Settings checksum" inMemoryType="unsigned16" name="checksum" />
        <Data comment="Validated settings checksum" default="0" inMemoryType="unsigned16" name="validatedChecksum" />
    </Packet>
    
    <Packet ID="PKT_ESC_TELLTALES" name="TelltaleValues" parameterInterface="true" structureInterface="true">
        <Data comment="Maximum recorded internal temperature" inMemoryType="unsigned8" initialValue="0" name="maxTemperature" />
        <Data comment="Maximum recorded MOSFET temperature" inMemoryType="unsigned8" initialValue="0" name="maxFetTemperature" />
        <Data comment="Maximum recorded motor temperature" inMemoryType="unsigned8" initialValue="0" name="maxMotorTemperature" />
        <Data comment="Maximum recorded battery voltage" default="0" inMemoryType="unsigned8" initialValue="0" name="maxRippleVoltage" />
        <Data comment="Maximum recorded battery current" default="0" encodedType="signed16" inMemoryType="float" initialValue="0" name="maxBatteryCurrent" scaler="10" />
        <Data comment="Maximum recorded regen current" default="0" encodedType="signed16" inMemoryType="float" initialValue="0" name="maxRegenCurrent" scaler="10" /> 
        <Data comment="Number of successful motor start events" default="0" inMemoryType="unsigned16" initialValue="0" name="totalStarts" />
        <Data comment="Number of failed motor start events" default="0" inMemoryType="unsigned16" initialValue="0" name="failedStarts" />
        <Data comment="ESC run time" default="0" inMemoryType="unsigned32" initialValue="0" name="escRunTime" />
        <Data comment="Motor run time" default="0" inMemoryType="unsigned32" initialValue="0" name="motorRunTime" />
        <Data comment="Number of recorded motor desync events" default="0" inMemoryType="unsigned32" initialValue="0" name="desyncEvents" />
    </Packet>
    
    <Packet ID="PKT_ESC_GIT_HASH" comment="Git commit hash for the ESC firmware" name="GitHash">
        <Data array="8" comment="git commit hash" inMemoryType="string" name="hash" />
    </Packet>

    <Packet ID="PKT_ESC_PWM_INPUT_CALIBRATION" file="ESCPackets" name="PWMInputCalibration" parameterInterface="true" structureInterface="true">
        <Data comment="Protocol version (reserved for future use)" constant="0" inMemoryType="unsigned8" initialValue="0" name="protocol" />
        <Data comment="PWM offset compensation value" inMemoryType="signed8" initialValue="0" name="pwmOffset" units="us" verifyMaxValue="125" verifyMinValue="-125" />
        <Data comment="PWM value corresponding with 0% throttle" inMemoryType="unsigned16" initialValue="1000" name="inputMin" units="us" verifyMaxValue="2500" verifyMinValue="250" />
        <Data comment="PWM value corresponding with 1000% throttle" inMemoryType="unsigned16" initialValue="2000" name="inputMax" units="us" verifyMaxValue="2500" verifyMinValue="250" />
        <Data comment="PWM arming threshold" inMemoryType="unsigned16" initialValue="900" name="armThreshold" units="us" verifyMaxValue="2500" verifyMinValue="250" />
    </Packet>
   
</Protocol>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             # Piccolo Protocol Generation

The Piccolo CAN protocol messages are generated using the [ProtoGen](https://github.com/billvaglienti/ProtoGen) protocol generation tool.

The raw protocol definition for each device type is provided in a `.xml` file (e.g. `protocol_esc_velocity.xml`).

To regenerate the protocol, run the following command:

`protogen.exe protocol_esc_velocity.xml --license license.txt`
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            // ServoCommands.c was generated by ProtoGen version 3.2.a

/*
 * This file is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This file is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Author: Oliver Walters / Currawong Engineering Pty Ltd
 */

#include "ServoCommands.h"
#include "fielddecode.h"
#include "fieldencode.h"
#include "scaleddecode.h"
#include "scaledencode.h"

/*!
 * \brief Create the Servo_RequestHighFrequencyData packet
 *
 * Select packets for high-frequency transmission. Selected packets will be
 * transmitted at 500Hz for one second. Sending this command again resets the
 * timer, allowing continuous data as long as this packet is received
 * \param _pg_pkt points to the packet which will be created by this function
 * \param packets is Select which telemetry packets are transmitted at high-speed by the servo
 */
void encodeServo_RequestHighFrequencyDataPacket(void* _pg_pkt, const Servo_TelemetryPackets_t* packets)
{
    uint8_t* _pg_data = getServoPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    uint8ToBytes((uint8_t)(CMD_SERVO_REQUEST_HF_DATA), _pg_data, &_pg_byteindex);

    // Select which telemetry packets are transmitted at high-speed by the servo
    encodeServo_TelemetryPackets_t(_pg_data, &_pg_byteindex, packets);

    // complete the process of creating the packet
    finishServoPacket(_pg_pkt, _pg_byteindex, getServo_RequestHighFrequencyDataPacketID());

}// encodeServo_RequestHighFrequencyDataPacket

/*!
 * \brief Decode the Servo_RequestHighFrequencyData packet
 *
 * Select packets for high-frequency transmission. Selected packets will be
 * transmitted at 500Hz for one second. Sending this command again resets the
 * timer, allowing continuous data as long as this packet is received
 * \param _pg_pkt points to the packet being decoded by this function
 * \param packets receives Select which telemetry packets are transmitted at high-speed by the servo
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeServo_RequestHighFrequencyDataPacket(const void* _pg_pkt, Servo_TelemetryPackets_t* packets)
{
    int _pg_byteindex = 0;
    const uint8_t* _pg_data = getServoPacketDataConst(_pg_pkt);
    int _pg_numbytes = getServoPacketSize(_pg_pkt);

    // Verify the packet identifier
    if(getServoPacketID(_pg_pkt) != getServo_RequestHighFrequencyDataPacketID())
        return 0;

    if(_pg_numbytes < getServo_RequestHighFrequencyDataMinDataLength())
        return 0;

    if (uint8FromBytes(_pg_data, &_pg_byteindex) != (uint8_t) CMD_SERVO_REQUEST_HF_DATA)
        return 0;

    // Select which telemetry packets are transmitted at high-speed by the servo
    if(decodeServo_TelemetryPackets_t(_pg_data, &_pg_byteindex, packets) == 0)
        return 0;

    return 1;

}// decodeServo_RequestHighFrequencyDataPacket

/*!
 * \brief Create the Servo_SetNodeID packet
 *
 * Set the Node ID (CAN Address) for the servo
 * \param _pg_pkt points to the packet which will be created by this function
 * \param serialNumber is The serial number must match that of the servo for the command to be accepted
 * \param nodeID is Set the CAN Node ID of the target servo
 */
void encodeServo_SetNodeIDPacket(void* _pg_pkt, uint32_t serialNumber, uint8_t nodeID)
{
    uint8_t* _pg_data = getServoPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    uint8ToBytes((uint8_t)(CMD_SERVO_SET_NODE_ID), _pg_data, &_pg_byteindex);

    // The serial number must match that of the servo for the command to be accepted
    // Range of serialNumber is 0 to 4294967295.
    uint32ToBeBytes(serialNumber, _pg_data, &_pg_byteindex);

    // Set the CAN Node ID of the target servo
    // Range of nodeID is 0 to 255.
    uint8ToBytes(nodeID, _pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finishServoPacket(_pg_pkt, _pg_byteindex, getServo_SetNodeIDPacketID());

}// encodeServo_SetNodeIDPacket

/*!
 * \brief Decode the Servo_SetNodeID packet
 *
 * Set the Node ID (CAN Address) for the servo
 * \param _pg_pkt points to the packet being decoded by this function
 * \param serialNumber receives The serial number must match that of the servo for the command to be accepted
 * \param nodeID receives Set the CAN Node ID of the target servo
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeServo_SetNodeIDPacket(const void* _pg_pkt, uint32_t* serialNumber, uint8_t* nodeID)
{
    int _pg_byteindex = 0;
    const uint8_t* _pg_data = getServoPacketDataConst(_pg_pkt);
    int _pg_numbytes = getServoPacketSize(_pg_pkt);

    // Verify the packet identifier
    if(getServoPacketID(_pg_pkt) != getServo_SetNodeIDPacketID())
        return 0;

    if(_pg_numbytes < getServo_SetNodeIDMinDataLength())
        return 0;

    if (uint8FromBytes(_pg_data, &_pg_byteindex) != (uint8_t) CMD_SERVO_SET_NODE_ID)
        return 0;

    // The serial number must match that of the servo for the command to be accepted
    // Range of serialNumber is 0 to 4294967295.
    (*serialNumber) = uint32FromBeBytes(_pg_data, &_pg_byteindex);

    // Set the CAN Node ID of the target servo
    // Range of nodeID is 0 to 255.
    (*nodeID) = uint8FromBytes(_pg_data, &_pg_byteindex);

    return 1;

}// decodeServo_SetNodeIDPacket

/*!
 * \brief Create the Servo_SetUserIdA packet
 *
 * Set user programmable ID value
 * \param _pg_pkt points to the packet which will be created by this function
 * \param id is User configurable value, 16-bit
 */
void encodeServo_SetUserIdAPacket(void* _pg_pkt, uint16_t id)
{
    uint8_t* _pg_data = getServoPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    uint8ToBytes((uint8_t)(CMD_SERVO_SET_USER_ID_A), _pg_data, &_pg_byteindex);

    // User configurable value, 16-bit
    // Range of id is 0 to 65535.
    uint16ToBeBytes(id, _pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finishServoPacket(_pg_pkt, _pg_byteindex, getServo_SetUserIdAPacketID());

}// encodeServo_SetUserIdAPacket

/*!
 * \brief Decode the Servo_SetUserIdA packet
 *
 * Set user programmable ID value
 * \param _pg_pkt points to the packet being decoded by this function
 * \param id receives User configurable value, 16-bit
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeServo_SetUserIdAPacket(const void* _pg_pkt, uint16_t* id)
{
    int _pg_byteindex = 0;
    const uint8_t* _pg_data = getServoPacketDataConst(_pg_pkt);
    int _pg_numbytes = getServoPacketSize(_pg_pkt);

    // Verify the packet identifier
    if(getServoPacketID(_pg_pkt) != getServo_SetUserIdAPacketID())
        return 0;

    if(_pg_numbytes < getServo_SetUserIdAMinDataLength())
        return 0;

    if (uint8FromBytes(_pg_data, &_pg_byteindex) != (uint8_t) CMD_SERVO_SET_USER_ID_A)
        return 0;

    // User configurable value, 16-bit
    // Range of id is 0 to 65535.
    (*id) = uint16FromBeBytes(_pg_data, &_pg_byteindex);

    return 1;

}// decodeServo_SetUserIdAPacket

/*!
 * \brief Create the Servo_SetUserIdB packet
 *
 * Set user programmable ID value
 * \param _pg_pkt points to the packet which will be created by this function
 * \param id is User configurable value, 16-bit
 */
void encodeServo_SetUserIdBPacket(void* _pg_pkt, uint16_t id)
{
    uint8_t* _pg_data = getServoPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    uint8ToBytes((uint8_t)(CMD_SERVO_SET_USER_ID_B), _pg_data, &_pg_byteindex);

    // User configurable value, 16-bit
    // Range of id is 0 to 65535.
    uint16ToBeBytes(id, _pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finishServoPacket(_pg_pkt, _pg_byteindex, getServo_SetUserIdBPacketID());

}// encodeServo_SetUserIdBPacket

/*!
 * \brief Decode the Servo_SetUserIdB packet
 *
 * Set user programmable ID value
 * \param _pg_pkt points to the packet being decoded by this function
 * \param id receives User configurable value, 16-bit
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeServo_SetUserIdBPacket(const void* _pg_pkt, uint16_t* id)
{
    int _pg_byteindex = 0;
    const uint8_t* _pg_data = getServoPacketDataConst(_pg_pkt);
    int _pg_numbytes = getServoPacketSize(_pg_pkt);

    // Verify the packet identifier
    if(getServoPacketID(_pg_pkt) != getServo_SetUserIdBPacketID())
        return 0;

    if(_pg_numbytes < getServo_SetUserIdBMinDataLength())
        return 0;

    if (uint8FromBytes(_pg_data, &_pg_byteindex) != (uint8_t) CMD_SERVO_SET_USER_ID_B)
        return 0;

    // User configurable value, 16-bit
    // Range of id is 0 to 65535.
    (*id) = uint16FromBeBytes(_pg_data, &_pg_byteindex);

    return 1;

}// decodeServo_SetUserIdBPacket

/*!
 * \brief Create the Servo_ResetDefaultSettings packet
 *
 * Reset servo settings to default values
 * \param _pg_pkt points to the packet which will be created by this function
 */
void encodeServo_ResetDefaultSettingsPacket(void* _pg_pkt)
{
    uint8_t* _pg_data = getServoPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    uint8ToBytes((uint8_t)(CMD_SERVO_RESET_DEFAULT_SETTINGS), _pg_data, &_pg_byteindex);

    uint8ToBytes((uint8_t)(0xAA), _pg_data, &_pg_byteindex);

    uint8ToBytes((uint8_t)(0x55), _pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finishServoPacket(_pg_pkt, _pg_byteindex, getServo_ResetDefaultSettingsPacketID());

}// encodeServo_ResetDefaultSettingsPacket

/*!
 * \brief Decode the Servo_ResetDefaultSettings packet
 *
 * Reset servo settings to default values
 * \param _pg_pkt points to the packet being decoded by this function
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeServo_ResetDefaultSettingsPacket(const void* _pg_pkt)
{
    int _pg_byteindex = 0;
    const uint8_t* _pg_data = getServoPacketDataConst(_pg_pkt);
    int _pg_numbytes = getServoPacketSize(_pg_pkt);

    // Verify the packet identifier
    if(getServoPacketID(_pg_pkt) != getServo_ResetDefaultSettingsPacketID())
        return 0;

    if(_pg_numbytes < getServo_ResetDefaultSettingsMinDataLength())
        return 0;

    if (uint8FromBytes(_pg_data, &_pg_byteindex) != (uint8_t) CMD_SERVO_RESET_DEFAULT_SETTINGS)
        return 0;

    if (uint8FromBytes(_pg_data, &_pg_byteindex) != (uint8_t) 0xAA)
        return 0;

    if (uint8FromBytes(_pg_data, &_pg_byteindex) != (uint8_t) 0x55)
        return 0;

    return 1;

}// decodeServo_ResetDefaultSettingsPacket

/*!
 * \brief Create the Servo_UnlockSettings packet
 *
 * Servo system command
 * \param _pg_pkt points to the packet which will be created by this function
 */
void encodeServo_UnlockSettingsPacket(void* _pg_pkt)
{
    uint8_t* _pg_data = getServoPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    uint8ToBytes((uint8_t)(CMD_SERVO_UNLOCK_SETTINGS), _pg_data, &_pg_byteindex);

    uint8ToBytes((uint8_t)(0xA0), _pg_data, &_pg_byteindex);

    uint8ToBytes((uint8_t)(0xB0), _pg_data, &_pg_byteindex);

    uint8ToBytes((uint8_t)(0xC0), _pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finishServoPacket(_pg_pkt, _pg_byteindex, getServo_UnlockSettingsPacketID());

}// encodeServo_UnlockSettingsPacket

/*!
 * \brief Decode the Servo_UnlockSettings packet
 *
 * Servo system command
 * \param _pg_pkt points to the packet being decoded by this function
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeServo_UnlockSettingsPacket(const void* _pg_pkt)
{
    int _pg_byteindex = 0;
    const uint8_t* _pg_data = getServoPacketDataConst(_pg_pkt);
    int _pg_numbytes = getServoPacketSize(_pg_pkt);

    // Verify the packet identifier
    if(getServoPacketID(_pg_pkt) != getServo_UnlockSettingsPacketID())
        return 0;

    if(_pg_numbytes < getServo_UnlockSettingsMinDataLength())
        return 0;

    if (uint8FromBytes(_pg_data, &_pg_byteindex) != (uint8_t) CMD_SERVO_UNLOCK_SETTINGS)
        return 0;

    if (uint8FromBytes(_pg_data, &_pg_byteindex) != (uint8_t) 0xA0)
        return 0;

    if (uint8FromBytes(_pg_data, &_pg_byteindex) != (uint8_t) 0xB0)
        return 0;

    if (uint8FromBytes(_pg_data, &_pg_byteindex) != (uint8_t) 0xC0)
        return 0;

    return 1;

}// decodeServo_UnlockSettingsPacket

/*!
 * \brief Create the Servo_LockSettings packet
 *
 * Servo system command
 * \param _pg_pkt points to the packet which will be created by this function
 */
void encodeServo_LockSettingsPacket(void* _pg_pkt)
{
    uint8_t* _pg_data = getServoPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    uint8ToBytes((uint8_t)(CMD_SERVO_LOCK_SETTINGS), _pg_data, &_pg_byteindex);

    uint8ToBytes((uint8_t)(0x0A), _pg_data, &_pg_byteindex);

    uint8ToBytes((uint8_t)(0x0B), _pg_data, &_pg_byteindex);

    uint8ToBytes((uint8_t)(0x0C), _pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finishServoPacket(_pg_pkt, _pg_byteindex, getServo_LockSettingsPacketID());

}// encodeServo_LockSettingsPacket

/*!
 * \brief Decode the Servo_LockSettings packet
 *
 * Servo system command
 * \param _pg_pkt points to the packet being decoded by this function
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeServo_LockSettingsPacket(const void* _pg_pkt)
{
    int _pg_byteindex = 0;
    const uint8_t* _pg_data = getServoPacketDataConst(_pg_pkt);
    int _pg_numbytes = getServoPacketSize(_pg_pkt);

    // Verify the packet identifier
    if(getServoPacketID(_pg_pkt) != getServo_LockSettingsPacketID())
        return 0;

    if(_pg_numbytes < getServo_LockSettingsMinDataLength())
        return 0;

    if (uint8FromBytes(_pg_data, &_pg_byteindex) != (uint8_t) CMD_SERVO_LOCK_SETTINGS)
        return 0;

    if (uint8FromBytes(_pg_data, &_pg_byteindex) != (uint8_t) 0x0A)
        return 0;

    if (uint8FromBytes(_pg_data, &_pg_byteindex) != (uint8_t) 0x0B)
        return 0;

    if (uint8FromBytes(_pg_data, &_pg_byteindex) != (uint8_t) 0x0C)
        return 0;

    return 1;

}// decodeServo_LockSettingsPacket

/*!
 * \brief Create the Servo_EnterBootloader packet
 *
 * Servo system command
 * \param _pg_pkt points to the packet which will be created by this function
 */
void encodeServo_EnterBootloaderPacket(void* _pg_pkt)
{
    uint8_t* _pg_data = getServoPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    uint8ToBytes((uint8_t)(CMD_SERVO_ENTER_BOOTLOADER), _pg_data, &_pg_byteindex);

    // This byte is required for the command to be accepted
    uint8ToBytes((uint8_t)(0xAA), _pg_data, &_pg_byteindex);

    // This byte is required for the command to be accepted
    uint8ToBytes((uint8_t)(0x55), _pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finishServoPacket(_pg_pkt, _pg_byteindex, getServo_EnterBootloaderPacketID());

}// encodeServo_EnterBootloaderPacket

/*!
 * \brief Decode the Servo_EnterBootloader packet
 *
 * Servo system command
 * \param _pg_pkt points to the packet being decoded by this function
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeServo_EnterBootloaderPacket(const void* _pg_pkt)
{
    int _pg_byteindex = 0;
    const uint8_t* _pg_data = getServoPacketDataConst(_pg_pkt);
    int _pg_numbytes = getServoPacketSize(_pg_pkt);

    // Verify the packet identifier
    if(getServoPacketID(_pg_pkt) != getServo_EnterBootloaderPacketID())
        return 0;

    if(_pg_numbytes < getServo_EnterBootloaderMinDataLength())
        return 0;

    if (uint8FromBytes(_pg_data, &_pg_byteindex) != (uint8_t) CMD_SERVO_ENTER_BOOTLOADER)
        return 0;

    // This byte is required for the command to be accepted
    if (uint8FromBytes(_pg_data, &_pg_byteindex) != (uint8_t) 0xAA)
        return 0;

    // This byte is required for the command to be accepted
    if (uint8FromBytes(_pg_data, &_pg_byteindex) != (uint8_t) 0x55)
        return 0;

    return 1;

}// decodeServo_Enter    if(pBus->master)
        {
            // Keep track of baud rates supported
            pBus->baudSupported &= pHandshake->baudSupported;

            // Make sure the state machine is set to poll -- this will eventually reach broadcast address (0xFF)
            pBus->state = SrxlState_SendHandshake;
        }
        // Broadcast handshake sets the agreed upon baud rate for this bus
        else if(pHandshake->destDevID == 0xFF)
        {
            // Get bus master receiver entry (if it's a flight controller, add it now as a receiver on this bus)
            if(newDev.deviceID >= 0x30 && newDev.deviceID < 0x40)
            {
                pBus->pMasterRcvr = srxlAddReceiverEntry(pBus, newDev);
            }
            else
            {
                pBus->pMasterRcvr = srxlGetReceiverEntry(busIndex, newDev.deviceID);
            }

            // Set baud rate and advance to run state
            pBus->baudRate = pHandshake->baudSupported;
            if(pBus->baudRate & SRXL_BAUD_400000)
            {
                srxlChangeBaudRate(pBus->uart, 400000);  // Only alternate rate supported for now...
            }
            pBus->state = SrxlState_Running;
        }
        // Normal Handshake destined for this device should be replied to -- else ignore
        else
        {
            if(pHandshake->destDevID == pBus->fullID.deviceID && pBus->state != SrxlState_SendHandshake)
            {
                pBus->requestID = pHandshake->srcDevID;
                pBus->state = SrxlState_SendHandshake;
            }
            else
            {
                pBus->state = SrxlState_ListenForHandshake;
            }
        }

        break;
    }
    case SRXL_PARAM_ID:  // 0x50
    {
        // TODO: Add later
        break;
    }
    case SRXL_RSSI_ID:  // 0x55
    {
        // TODO: Add later
        break;
    }
    case SRXL_BIND_ID:  // 0x41
    {
        if(length < sizeof(SrxlBindPacket))
            return false;

        SrxlBindPacket* pBindInfo = &(pRx->bind);

        // If this is a bound data report
        if(pBindInfo->request == SRXL_BIND_REQ_BOUND_DATA)
        {
            // Call the user-defined callback -- if returns true, bind all other receivers
            SrxlFullID boundID;
            boundID.deviceID = pBindInfo->deviceID;
            boundID.busIndex = busIndex;
            if(srxlOnBind(boundID, pBindInfo->data))
            {
                // Update the bind info
                srxlBindInfo.type = pBindInfo->data.type;
                if(pBindInfo->data.options & SRXL_BIND_OPT_TELEM_TX_ENABLE)
                {
                    SrxlRcvrEntry* pNewTelem = srxlGetReceiverEntry(busIndex, pBindInfo->deviceID);
                    if(pNewTelem || !srxlRx.pTelemRcvr)
                        srxlRx.pTelemRcvr = pNewTelem;
                }
                srxlBindInfo.options = 0;  // Disable telemetry and Discovery reply when setting other receivers
                srxlBindInfo.guid = pBindInfo->data.guid;
                srxlBindInfo.uid = pBindInfo->data.uid;

                // Try to set bind info for all other receivers on other buses to match it
                uint8_t b;
                for(b = 0; b < SRXL_NUM_OF_BUSES; ++b)
                {
                    if(b == busIndex)
                        continue;
                    srxlBus[b].txFlags.broadcastBindInfo = 1;
                }
            }
        }
        // If this bind packet is directed at us
        else if(pBindInfo->deviceID == pBus->fullID.deviceID || pBindInfo->deviceID == 0xFF)
        {
            // Check for Enter Bind Mode (only valid if sent to a specific receiver)
            if(pBindInfo->request == SRXL_BIND_REQ_ENTER)
            {
#ifdef SRXL_INCLUDE_MASTER_CODE
                srxlBindInfo.type = pBindInfo->data.type;
                srxlBindInfo.options = pBindInfo->data.options;
                srxlBindInfo.guid = 0;
                srxlBindInfo.uid = 0;
                srxlTryToBind(srxlBindInfo);
#endif
            }
            else if(pBindInfo->request == SRXL_BIND_REQ_STATUS && srxlThisDev.pRcvr)
            {
                // TODO: Fill in data if we didn't just bind?
                pBus->txFlags.reportBindInfo = 1;
            }
            // Handle set bind info request
            else if(pBindInfo->request == SRXL_BIND_REQ_SET_BIND)
            {
                srxlBindInfo = pBindInfo->data;
#ifdef SRXL_INCLUDE_MASTER_CODE
                if(pBus->fullID.deviceID < 0x30)
                    srxlTryToBind(srxlBindInfo);
#endif
            }
        }

        break;
    }
    case SRXL_TELEM_ID:  // 0x80
    {
        if(length < sizeof(SrxlTelemetryPacket))
            return false;

        // NOTE: This data should be sent by exactly one telemetry device in response to a bus master request,
        //       so it is safe to update the global pTelemRcvr here even though this is a bus-specific function.

        SrxlTelemetryPacket* pTelem = &(pRx->telemetry);
        memcpy(&srxlTelemData, &pTelem->payload, sizeof(srxlTelemData));
        // If the telemetry destination is set to broadcast, that indicates a request to re-handshake
        if(pBus->master && pTelem->destDevID == 0xFF)
        {
            // If the master only found one device, don't poll again -- just tell the requesting device who we are
            pBus->requestID = pBus->rxDevCount > 1 ? pBus->fullID.deviceID : 0xFF;
            pBus->state = SrxlState_SendHandshake;
        }
        // If the incoming telemetry is destined for us, then we need to figure out who should send it over RF
        else if(pTelem->destDevID == pBus->fullID.deviceID)
        {
            // This needs different logic for hubs versus endpoints
#ifdef SRXL_IS_HUB
            if(srxlRx.pTelemRcvr == 0)
            {
                srxlRx.pTelemRcvr = srxlChooseTelemRcvr();
            }
#else
            srxlRx.pTelemRcvr = srxlThisDev.pRcvr;
#endif
            // Enable this device's telemetry tx based on whether we are the chosen telemetry receiver
#ifdef SRXL_INCLUDE_MASTER_CODE
            srxlSetTelemetryTxEnable(srxlRx.pTelemRcvr && (srxlRx.pTelemRcvr == srxlThisDev.pRcvr));
#endif
        }
        // Else turn off our telemetry and that of any receivers we might reply to via our own telemetry
        else
        {
            srxlRx.pTelemRcvr = 0;
#ifdef SRXL_INCLUDE_MASTER_CODE
            srxlSetTelemetryTxEnable(false);
#endif
        }

        srxlTelemSuppressCount = 0;
#ifdef SRXL_INCLUDE_MASTER_CODE
        srxlSuppressInternalTelemetry(&pTelem->payload);
#endif
        break;
    }
    default:
    {
        break;
    }
    }

    // Run state machine for slave devices after each received packet
    if(!pBus->master)
    {
        srxlRun(busIndex, 0);
    }

    return true;
}

/**
    @brief  Run the SRXL state machine after each receive or rx timeout

    @param  busIndex:           Index of SRXL bus state information entry in the srxlBus array
    @param  timeoutDelta_ms:    Number of milliseconds to increment receive timeout if a timeout
                                occured, or <= 0 to clear timeout count upon packet receive.
*/
void srxlRun(uint8_t busIndex, int16_t timeoutDelta_ms)
{
    SrxlBus* pBus = &srxlBus[busIndex];
    if(busIndex >= SRXL_NUM_OF_BUSES || !pBus->initialized || pBus->state == SrxlState_Disabled)
        return;

    // Check receive timeout and advance state if needed
    if(timeoutDelta_ms > 0)
    {
        pBus->timeoutCount_ms += timeoutDelta_ms;
        if(pBus->timeoutCount_ms >= 30000)
            pBus->timeoutCount_ms = 30000;

        if(pBus->timeoutCount_ms >= 50)
        {
            // After startup delay of 50ms, switch to handshake send or listen based on device unit ID
            if(pBus->state == SrxlState_ListenOnStartup)
            {
                pBus->state = (pBus->fullID.deviceID & 0x0F) ? SrxlState_ListenForHandshake : SrxlState_SendHandshake;
            }
            // Reset non-master device back to startup conditions if 50ms elapses with no communications
            else if(!pBus->master && pBus->state >= SrxlState_Running)
            {
                srxlChangeBaudRate(pBus->uart, 115200);
                pBus->baudRate = SRXL_BAUD_115200;
                pBus->timeoutCount_ms = 0;
                pBus->requestID = 0;  // Change back to 0 to indicate unprompted handshake from slave device
                if(pBus->pMasterRcvr)
                {
                    pBus->pMasterRcvr->channelMask = 0;
                    pBus->pMasterRcvr->fades = 0xFFFF;
                    pBus->pMasterRcvr->rssi_Pct = 0;
                    pBus->pMasterRcvr->rssi_dBm = -1;
                }
                pBus->state = SrxlState_ListenOnStartup;
            }
        }
    }
    else
    {
        pBus->timeoutCount_ms = 0;
    }

    if(!pBus->master)
    {
        // Non-master actions for the given state
        switch(pBus->state)
        {
        case SrxlState_SendHandshake:
        {
            srxlSend(pBus, SRXL_CMD_HANDSHAKE, pBus->requestID);
            break;
        }
        case SrxlState_SendTelemetry:
        {
            srxlSend(pBus, SRXL_CMD_TELEMETRY, pBus->requestID);
            pBus->state = SrxlState_Running;
            break;
        }
        case SrxlState_SendVTX:
        {
            srxlSend(pBus, SRXL_CMD_VTX, pBus->requestID);
            pBus->state = SrxlState_Running;
            break;
        }
        case SrxlState_SendEnterBind:
        {
            if(srxlRx.pBindRcvr && (srxlRx.pBindRcvr != srxlThisDev.pRcvr))
            {
                srxlSend(pBus, SRXL_CMD_ENTER_BIND, srxlRx.pBindRcvr->deviceID);
            }
            else
            {
                srxlBindInfo.options = 0;
                srxlSend(pBus, SRXL_CMD_ENTER_BIND, 0xFF);
            }
            pBus->state = SrxlState_Running;
            break;
        }
        case SrxlState_SendSetBindInfo:
        {
            srxlSend(pBus, SRXL_CMD_SET_BIND, pBus->requestID);
            pBus->state = SrxlState_Running;
            break;
        }
        case SrxlState_SendBoundDataReport:
        {
            srxlSend(pBus, SRXL_CMD_BIND_INFO, pBus->fullID.deviceID);
            pBus->state = SrxlState_Running;
            break;
        }
        case SrxlState_Running:
        default:
        {
            return;
        }
        }
    }
#ifdef SRXL_INCLUDE_MASTER_CODE
    else
    {
        srxlRunMaster(pBus);
    }
#endif  // SRXL_INCLUDE_MASTER_CODE
}

/**
    @brief  Tell the "best" receiver to enter bind mode, either locally or via SRXL command

    @param  bindType: One of the possible bind status types to use when binding -- NOTE: The transmitter may ignore this
    @param  broadcast: True if this is a local request that should tell all connected receivers to enter bind
    @return bool: True if a receiver was told to enter bind mode; else false
*/
bool srxlEnterBind(uint8_t bindType, bool broadcast)
{
    srxlRx.pBindRcvr = 0;
    if(broadcast && srxlThisDev.pRcvr)
    {
        srxlRx.pBindRcvr = srxlThisDev.pRcvr;
    }
    else if(srxlRx.pTelemRcvr)
    {
        srxlRx.pBindRcvr = srxlRx.pTelemRcvr;
    }
    else if(srxlRx.rcvrCount > 0 && srxlRx.rcvrSorted[0]->deviceID < 0x30)
    {
        srxlRx.pBindRcvr = srxlRx.rcvrSorted[0];
    }

    if(srxlRx.pBindRcvr)
    {
#ifdef SRXL_INCLUDE_MASTER_CODE
        // Local bind
        if(srxlRx.pBindRcvr == srxlThisDev.pRcvr)
        {
            srxlBindInfo.type = bindType;
            srxlBindInfo.options = SRXL_BIND_OPT_BIND_TX_ENABLE;
            srxlBindInfo.guid = 0;
            srxlBindInfo.uid = 0;
            if(srxlRx.pBindRcvr == srxlRx.pTelemRcvr)
                srxlBindInfo.options |= SRXL_BIND_OPT_TELEM_TX_ENABLE;
            srxlTryToBind(srxlBindInfo);
            if(broadcast)
            {
                uint8_t b;
                for(b = 0; b < SRXL_NUM_OF_BUSES; ++b)
                {
                    srxlBus[b].txFlags.enterBind = 1;
                }
            }
            return true;
        }
#endif // SRXL_INCLUDE_MASTER_CODE

        // Remote bind
        uint8_t i;
        for(i = 0; i < SRXL_NUM_OF_BUSES; ++i)
        {
            if(