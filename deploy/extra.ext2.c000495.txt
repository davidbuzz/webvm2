      "SIM_GPS_VERR_X": self.get_parameter("SIM_GPS_VERR_X") + 2,
                "SIM_GPS_VERR_Y": self.get_parameter("SIM_GPS_VERR_Y") + 2,
                "SIM_GPS_VERR_Z": self.get_parameter("SIM_GPS_VERR_Z") + 2,
            })
        self.wait_statustext(text="EKF3 lane switch", timeout=30, the_function=sim_gps_verr, check_context=True)
        if self.lane_switches != [1, 0, 1]:
            raise NotAchievedException("Expected lane switch 1, got %s" % str(self.lane_switches[-1]))
        # Cleanup
        self.context_pop()
        self.context_clear_collection("STATUSTEXT")
        self.wait_heading(0, accuracy=10, timeout=60)
        self.wait_heading(180, accuracy=10, timeout=60)
        ###################################################################
        self.start_subtest("MAGNETOMETER: Change X-Axis Offset")
        self.context_collect("STATUSTEXT")
        # create a magnetometer error by changing the X-axis offset
        old_parameter = self.get_parameter("SIM_MAG2_OFS_X")
        self.wait_statustext(
            text="EKF3 lane switch",
            timeout=30,
            the_function=self.set_parameter("SIM_MAG2_OFS_X", old_parameter + 150),
            check_context=True)
        if self.lane_switches != [1, 0, 1, 0]:
            raise NotAchievedException("Expected lane switch 0, got %s" % str(self.lane_switches[-1]))
        # Cleanup
        self.set_parameter("SIM_MAG2_OFS_X", old_parameter)
        self.context_clear_collection("STATUSTEXT")
        self.wait_heading(0, accuracy=10, timeout=60)
        self.wait_heading(180, accuracy=10, timeout=60)
        ###################################################################
        self.start_subtest("AIRSPEED: Fail to constant value")
        self.context_push()
        self.context_collect("STATUSTEXT")

        old_parameter = self.get_parameter("SIM_ARSPD_FAIL")

        def fail_speed():
            self.change_mode("GUIDED")
            loc = self.mav.location()
            self.run_cmd_int(
                mavutil.mavlink.MAV_CMD_DO_REPOSITION,
                p5=int(loc.lat * 1e7),
                p6=int(loc.lng * 1e7),
                p7=50,    # alt
            )
            self.delay_sim_time(5)
            # create an airspeed sensor error by freezing to the
            # current airspeed then changing the airspeed demand
            # to a higher value and waiting for the TECS speed
            # loop to diverge
            m = self.mav.recv_match(type='VFR_HUD', blocking=True)
            self.set_parameter("SIM_ARSPD_FAIL", m.airspeed)
            self.run_cmd(
                mavutil.mavlink.MAV_CMD_DO_CHANGE_SPEED,
                p1=0, # airspeed
                p2=30,
                p3=-1, # throttle / no change
                p4=0, # absolute values
            )
        self.wait_statustext(text="EKF3 lane switch", timeout=30, the_function=fail_speed, check_context=True)
        if self.lane_switches != [1, 0, 1, 0, 1]:
            raise NotAchievedException("Expected lane switch 1, got %s" % str(self.lane_switches[-1]))
        # Cleanup
        self.set_parameter("SIM_ARSPD_FAIL", old_parameter)
        self.change_mode('CIRCLE')
        self.context_pop()
        self.context_clear_collection("STATUSTEXT")
        self.wait_heading(0, accuracy=10, timeout=60)
        self.wait_heading(180, accuracy=10, timeout=60)
        ###################################################################
        self.progress("GYROSCOPE: Change Y-Axis Offset")
        self.context_collect("STATUSTEXT")
        # create a gyroscope error by changing the Y-axis offset
        old_parameter = self.get_parameter("INS_GYR2OFFS_Y")
        self.wait_statustext(
            text="EKF3 lane switch",
            timeout=30,
            the_function=self.set_parameter("INS_GYR2OFFS_Y", old_parameter + 1),
            check_context=True)
        if self.lane_switches != [1, 0, 1, 0, 1, 0]:
            raise NotAchievedException("Expected lane switch 0, got %s" % str(self.lane_switches[-1]))
        # Cleanup
        self.set_parameter("INS_GYR2OFFS_Y", old_parameter)
        self.context_clear_collection("STATUSTEXT")
        ###################################################################

        self.disarm_vehicle(force=True)

    def FenceAltCeilFloor(self):
        '''Tests the fence ceiling and floor'''
        self.set_parameters({
            "FENCE_TYPE": 9,     # Set fence type to max and min alt
            "FENCE_ACTION": 0,   # Set action to report
            "FENCE_ALT_MAX": 200,
            "FENCE_ALT_MIN": 100,
        })

        # Grab Home Position
        self.wait_ready_to_arm()
        startpos = self.mav.location()

        cruise_alt = 150
        self.takeoff(cruise_alt)

        # note that while we enable the fence here, since the action
        # is set to report-only the fence continues to show as
        # not-enabled in the assert calls below
        self.do_fence_enable()

        self.progress("Fly above ceiling and check for breach")
        self.change_altitude(startpos.alt + cruise_alt + 80)
        self.assert_fence_sys_status(True, False, False)

        self.progress("Return to cruise alt")
        self.change_altitude(startpos.alt + cruise_alt)

        self.progress("Ensure breach has clearned")
        self.assert_fence_sys_status(True, False, True)

        self.progress("Fly below floor and check for breach")
        self.change_altitude(startpos.alt + cruise_alt - 80)

        self.progress("Ensure breach has clearned")
        self.assert_fence_sys_status(True, False, False)

        self.do_fence_disable()

        self.fly_home_land_and_disarm(timeout=150)

    def FenceMinAltAutoEnable(self):
        '''Tests autoenablement of the alt min fence and fences on arming'''
        self.set_parameters({
            "FENCE_TYPE": 9,     # Set fence type to min alt and max alt
            "FENCE_ACTION": 1,   # Set action to RTL
            "FENCE_ALT_MIN": 25,
            "FENCE_ALT_MAX": 100,
            "FENCE_AUTOENABLE": 3,
            "FENCE_ENABLE" : 0,
            "RTL_AUTOLAND" : 2,
        })

        # check we can takeoff again
        for i in [1, 2]:
            # Grab Home Position
            self.wait_ready_to_arm()
            self.arm_vehicle()
            # max alt fence should now be enabled
            if i == 1:
                self.assert_fence_enabled()

            self.takeoff(alt=50, mode='TAKEOFF')
            self.change_mode("FBWA")
            self.set_rc(3, 1100)    # lower throttle

            self.progress("Waiting for RTL")
            tstart = self.get_sim_time()
            mode = "RTL"
            while not self.mode_is(mode, drain_mav=False):
                self.mav.messages['HEARTBEAT'].custom_mode
                self.progress("mav.flightmode=%s Want=%s Alt=%f" % (
                    self.mav.flightmode, mode, self.get_altitude(relative=True)))
                if (self.get_sim_time_cached() > tstart + 120):
                    raise WaitModeTimeout("Did not change mode")
            self.progress("Got mode %s" % mode)
            self.fly_home_land_and_disarm()
            self.change_mode("FBWA")
            self.clear_mission(mavutil.mavlink.MAV_MISSION_TYPE_ALL)
            self.set_current_waypoint(0, check_afterwards=False)
            self.set_rc(3, 1000)    # lower throttle

    def FenceMinAltEnableAutoland(self):
        '''Tests autolanding when alt min fence is enabled'''
        self.set_parameters({
            "FENCE_TYPE": 12,     # Set fence type to min alt and max alt
            "FENCE_ACTION": 1,   # Set action to RTL
            "FENCE_ALT_MIN": 20,
            "FENCE_AUTOENABLE": 0,
            "FENCE_ENABLE" : 1,
            "RTL_AUTOLAND" : 2,
        })

        # Grab Home Position
        self.wait_ready_to_arm()
        self.arm_vehicle()

        self.takeoff(alt=50, mode='TAKEOFF')
        self.change_mode("FBWA")
        self.set_rc(3, 1100)    # lower throttle

        self.progress("Waiting for RTL")
        tstart = self.get_sim_time()
        mode = "RTL"
        while not self.mode_is(mode, drain_mav=False):
            self.mav.messages['HEARTBEAT'].custom_mode
            self.progress("mav.flightmode=%s Want=%s Alt=%f" % (
                self.mav.flightmode, mode, self.get_altitude(relative=True)))
            if (self.get_sim_time_cached() > tstart + 120):
                raise WaitModeTimeout("Did not change mode")
        self.progress("Got mode %s" % mode)
        # switch to FBWA
        self.change_mode("FBWA")
        self.set_rc(3, 1500)    # raise throttle
        self.wait_altitude(25, 35, timeout=50, relative=True)
        self.set_rc(3, 1000)    # lower throttle
        # Now check we can land
        self.fly_home_land_and_disarm()

    def FenceMinAltAutoEnableAbort(self):
        '''Tests autoenablement of the alt min fence and fences on arming'''
        self.set_parameters({
            "FENCE_TYPE": 8,     # Set fence type to min alt
            "FENCE_ACTION": 1,   # Set action to RTL
            "FENCE_ALT_MIN": 25,
            "FENCE_ALT_MAX": 100,
            "FENCE_AUTOENABLE": 3,
            "FENCE_ENABLE" : 0,
            "RTL_AUTOLAND" : 2,
        })

        self.wait_ready_to_arm()
        self.arm_vehicle()

        self.takeoff(alt=50, mode='TAKEOFF')
        self.change_mode("FBWA")
        # min alt fence should now be enabled
        self.assert_fence_enabled()
        self.set_rc(3, 1100)    # lower throttle

        self.progress("Waiting for RTL")
        tstart = self.get_sim_time()
        mode = "RTL"
        while not self.mode_is(mode, drain_mav=False):
            self.mav.messages['HEARTBEAT'].custom_mode
            self.progress("mav.flightmode=%s Want=%s Alt=%f" % (
                self.mav.flightmode, mode, self.get_altitude(relative=True)))
            if (self.get_sim_time_cached() > tstart + 120):
                raise WaitModeTimeout("Did not change mode")
        self.progress("Got mode %s" % mode)

        self.load_generic_mission("flaps.txt")
        self.change_mode("AUTO")
        self.wait_distance_to_waypoint(8, 100, 10000000)
        self.set_current_waypoint(8)
        # abort the landing
        self.wait_altitude(10, 20, timeout=200, relative=True)
        self.change_mode("CRUISE")
        self.set_rc(2, 1200)
        # self.set_rc(3, 1600)    # raise throttle
        self.wait_altitude(30, 40, timeout=200, relative=True)
        # min alt fence should now be re-enabled
        self.assert_fence_enabled()

        self.change_mode("AUTO")
        self.clear_mission(mavutil.mavlink.MAV_MISSION_TYPE_ALL)
        self.fly_home_land_and_disarm(timeout=150)

    def FenceAutoEnableDisableSwitch(self):
        '''Tests autoenablement of regular fences and manual disablement'''
        self.set_parameters({
            "FENCE_TYPE": 11,     # Set fence type to min alt
            "FENCE_ACTION": 1,   # Set action to RTL
            "FENCE_ALT_MIN": 50,
            "FENCE_ALT_MAX": 100,
            "FENCE_AUTOENABLE": 2,
            "FENCE_OPTIONS" : 1,
            "FENCE_ENABLE" : 1,
            "FENCE_RADIUS" : 300,
            "FENCE_RET_ALT" : 0,
            "FENCE_RET_RALLY" : 0,
            "FENCE_TOTAL" : 0,
            "TKOFF_ALT" : 75,
            "RC7_OPTION" : 11,   # AC_Fence uses Aux switch functionality
        })
        fence_bit = mavutil.mavlink.MAV_SYS_STATUS_GEOFENCE
        # Grab Home Position
        self.mav.recv_match(type='HOME_POSITION', blocking=True)
        self.set_rc_from_map({7: 1000}) # Turn fence off with aux function

        self.wait_ready_to_arm()
        cruise_alt = 75
        self.takeoff(cruise_alt, mode='TAKEOFF')

        self.progress("Fly above ceiling and check there is no breach")
        self.set_rc(3, 2000)
        self.change_altitude(cruise_alt + 80, relative=True)
        m = self.mav.recv_match(type='SYS_STATUS', blocking=True)
        self.progress("Got (%s)" % str(m))
        if (not (m.onboard_control_sensors_health & fence_bit)):
            raise NotAchievedException("Fence Ceiling breached")

        self.progress("Return to cruise alt")
        self.set_rc(3, 1500)
        self.change_altitude(cruise_alt, relative=True)

        self.progress("Fly below floor and check for no breach")
        self.change_altitude(25, relative=True)
        m = self.mav.recv_match(type='SYS_STATUS', blocking=True)
        self.progress("Got (%s)" % str(m))
        if (not (m.onboard_control_sensors_health & fence_bit)):
            raise NotAchievedException("Fence Ceiling breached")

        self.progress("Fly above floor and check fence is not re-enabled")
        self.set_rc(3, 2000)
        self.change_altitude(75, relative=True)
        m = self.mav.recv_match(type='SYS_STATUS', blocking=True)
        self.progress("Got (%s)" % str(m))
        if (m.onboard_control_sensors_enabled & fence_bit):
            raise NotAchievedException("Fence Ceiling re-enabled")

        self.progress("Return to cruise alt")
        self.set_rc(3, 1500)
        self.change_altitude(cruise_alt, relative=True)
        self.fly_home_land_and_disarm(timeout=250)

    def FenceCircleExclusionAutoEnable(self):
        '''Tests autolanding when alt min fence is enabled'''
        self.set_parameters({
            "FENCE_TYPE": 2,     # Set fence type to circle
            "FENCE_ACTION": 1,   # Set action to RTL
            "FENCE_AUTOENABLE": 2,
            "FENCE_ENABLE" : 0,
            "RTL_AUTOLAND" : 2,
        })

        fence_loc = self.home_position_as_mav_location()
        self.location_offset_ne(fence_loc, 300, 0)

        self.upload_fences_from_locations([(
            mavutil.mavlink.MAV_CMD_NAV_FENCE_CIRCLE_EXCLUSION, {
                "radius" : 100,
                "loc" : fence_loc
            }
        )])

        self.takeoff(alt=50, mode='TAKEOFF')
        self.change_mode("FBWA")
        self.set_rc(3, 1100)    # lower throttle

        self.progress("Waiting for RTL")
        self.wait_mode('RTL')
        # Now check we can land
        self.fly_home_land_and_disarm()

    def FenceEnableDisableSwitch(self):
        '''Tests enablement and disablement of fences on a switch'''
        fence_bit = mavutil.mavlink.MAV_SYS_STATUS_GEOFENCE

        self.set_parameters({
            "FENCE_TYPE": 4,     # Set fence type to polyfence
            "FENCE_ACTION": 6,   # Set action to GUIDED
            "FENCE_ALT_MIN": 10,
            "FENCE_ENABLE" : 0,
            "RC7_OPTION" : 11,   # AC_Fence uses Aux switch functionality
        })

        self.progress("Checking fence is not present before being configured")
        m = self.mav.recv_match(type='SYS_STATUS', blocking=True)
        self.progress("Got (%s)" % str(m))
        if (m.onboard_control_sensors_enabled & fence_bit):
            raise NotAchievedException("Fence enabled before being configured")

        self.wait_ready_to_arm()
        # takeoff at a lower altitude to avoid immediately breaching polyfence
        self.takeoff(alt=25)
        self.change_mode("FBWA")

        self.load_fence("CMAC-fence.txt")

        self.set_rc_from_map({
            3: 1500,
            7: 2000,
        }) # Turn fence on with aux function

        m = self.mav.recv_match(type='FENCE_STATUS', blocking=True, timeout=2)
        self.progress("Got (%s)" % str(m))
        if m is None:
            raise NotAchievedException("Got FENCE_STATUS unexpectedly")

        self.progress("Checking fence is initially OK")
        self.wait_sensor_state(mavutil.mavlink.MAV_SYS_STATUS_GEOFENCE,
                               present=True,
                               enabled=True,
                               healthy=True,
                               verbose=False,
                               timeout=30)

        self.progress("Waiting for GUIDED")
        tstart = self.get_sim_time()
        mode = "GUIDED"
        while not self.mode_is(mode, drain_mav=False):
            self.mav.messages['HEARTBEAT'].custom_mode
            self.progress("mav.flightmode=%s Want=%s Alt=%f" % (
                self.mav.flightmode, mode, self.get_altitude(relative=True)))
            if (self.get_sim_time_cached() > tstart + 120):
                raise WaitModeTimeout("Did not change mode")
        self.progress("Got mode %s" % mode)
        # check we are in breach
        self.assert_fence_enabled()

        self.set_rc_from_map({
            7: 1000,
        }) # Turn fence off with aux function

        # wait to no longer be in breach
        self.delay_sim_time(5)
        self.assert_fence_disabled()

        self.fly_home_land_and_disarm(timeout=250)
        self.do_fence_disable() # Ensure the fence is disabled after test

    def FenceEnableDisableAux(self):
        '''Tests enablement and disablement of fences via aux command'''
        fence_bit = mavutil.mavlink.MAV_SYS_STATUS_GEOFENCE

        enable = 0
        self.set_parameters({
            "FENCE_TYPE": 12,     # Set fence type to polyfence + AltMin
            "FENCE_ALT_MIN": 10,
            "FENCE_ENABLE" : enable,
        })

        if not enable:
            self.progress("Checking fence is not present before being configured")
            m = self.mav.recv_match(type='SYS_STATUS', blocking=True)
            self.progress("Got (%s)" % str(m))
            if (m.onboard_control_sensors_enabled & fence_bit):
                raise NotAchievedException("Fence enabled before being configured")

        self.load_fence("CMAC-fence.txt")

        self.wait_ready_to_arm()
        # takeoff at a lower altitude to avoid immediately breaching polyfence
        self.takeoff(alt=25)
        self.change_mode("CRUISE")
        self.wait_distance(150, accuracy=20)

        self.run_auxfunc(
            11,
            2,
            want_result=mavutil.mavlink.MAV_RESULT_ACCEPTED
        )

        m = self.mav.recv_match(type='FENCE_STATUS', blocking=True, timeout=2)
        self.progress("Got (%s)" % str(m))
        if m is None:
            raise NotAchievedException("Got FENCE_STATUS unexpectedly")

        self.progress("Checking fence is initially OK")
        self.wait_sensor_state(mavutil.mavlink.MAV_SYS_STATUS_GEOFENCE,
                               present=True,
                               enabled=True,
                               healthy=True,
                               verbose=False,
                               timeout=30)

        self.progress("Waiting for RTL")
        tstart = self.get_sim_time()
        mode = "RTL"
        while not self.mode_is(mode, drain_mav=False):
            self.mav.messages['HEARTBEAT'].custom_mode
            self.progress("mav.flightmode=%s Want=%s Alt=%f" % (
                self.mav.flightmode, mode, self.get_altitude(relative=True)))
            if (self.get_sim_time_cached() > tstart + 120):
                raise WaitModeTimeout("Did not change mode")
        self.progress("Got mode %s" % mode)
        # check we are in breach
        self.assert_fence_enabled()
        self.assert_fence_sys_status(True, True, False)

        # wait until we get home
        self.wait_distance_to_home(50, 100, timeout=200)
        # now check we are now not in breach
        self.assert_fence_sys_status(True, True, True)
        # Turn fence off with aux function
        self.run_auxfunc(
            11,
            0,
            want_result=mavutil.mavlink.MAV_RESULT_ACCEPTED
        )
        # switch back to cruise
        self.change_mode("CRUISE")
        self.wait_distance(150, accuracy=20)

        # re-enable the fences
        self.run_auxfunc(
            11,
            2,
            want_result=mavutil.mavlink.MAV_RESULT_ACCEPTED
        )

        m = self.mav.recv_match(type='FENCE_STATUS', blocking=True, timeout=2)
        self.progress("Got (%s)" % str(m))
        if m is None:
            raise NotAchievedException("Got FENCE_STATUS unexpectedly")

        self.progress("Waiting for RTL")
        tstart = self.get_sim_time()
        mode = "RTL"
        while not self.mode_is(mode, drain_mav=False):
            self.mav.messages['HEARTBEAT'].custom_mode
            self.progress("mav.flightmode=%s Want=%s Alt=%f" % (
                self.mav.flightmode, mode, self.get_altitude(relative=True)))
            if (self.get_sim_time_cached() > tstart + 120):
                raise WaitModeTimeout("Did not change mode")
        self.progress("Got mode %s" % mode)

        # wait to no longer be in breach
        self.wait_distance_to_home(50, 100, timeout=200)
        self.assert_fence_sys_status(True, True, True)

        # fly home and land with fences still enabled
        self.fly_home_land_and_disarm(timeout=250)
        self.do_fence_disable() # Ensure the fence is disabled after test

    def FenceBreachedChangeMode(self):
        '''Tests manual mode change after fence breach, as set with FENCE_OPTIONS'''
        """ Attempts to change mode while a fence is breached.
            mode should change should fail if fence option bit is set"""
        self.set_parameters({
            "FENCE_ACTION": 1,
            "FENCE_TYPE": 4,
        })
        home_loc = self.mav.location()
        locs = [
            mavutil.location(home_loc.lat - 0.001, home_loc.lng - 0.001, 0, 0),
            mavutil.location(home_loc.lat - 0.001, home_loc.lng + 0.001, 0, 0),
            mavutil.location(home_loc.lat + 0.001, home_loc.lng + 0.001, 0, 0),
            mavutil.location(home_loc.lat + 0.001, home_loc.lng - 0.001, 0, 0),
        ]
        self.upload_fences_from_locations([
            (mavutil.mavlink.MAV_CMD_NAV_FENCE_POLYGON_VERTEX_INCLUSION, locs),
        ])
        self.delay_sim_time(1)
        self.wait_ready_to_arm()
        self.takeoff(alt=50)
        self.change_mode("CRUISE")
        self.wait_distance(250, accuracy=15)

        self.progress("Enable fence and initiate fence action")
        self.do_fence_enable()
        self.assert_fence_enabled()
        self.wait_mode("RTL") # We should RTL because of fence breach

        self.progress("User mode change to cruise should retrigger fence action")
        try:
            # mode change should time out, 'WaitModeTimeout' exception is the desired resut
            # cant wait too long or the vehicle will be inside fence and allow the mode change
            self.change_mode("CRUISE", timeout=10)
            raise NotAchievedException("Should not change mode in fence breach")
        except WaitModeTimeout:
            pass
        except Exception as e:
            raise e

        # enable mode change
        self.set_parameter("FENCE_OPTIONS", 0)
        self.progress("Check user mode change to LOITER is allowed")
        self.change_mode("LOITER")

        # Fly for 20 seconds and make sure still in LOITER mode
        self.delay_sim_time(20)
        if not self.mode_is("LOITER"):
            raise NotAchievedException("Fence should not re-trigger")

        # reset options parameter
        self.set_parameter("FENCE_OPTIONS", 1)

        self.progress("Test complete, disable fence and come home")
        self.do_fence_disable()
        self.fly_home_land_and_disarm()

    def FenceNoFenceReturnPoint(self):
        '''Tests calculated return point during fence breach when no fence return point present'''
        """ Attempts to change mode while a fence is breached.
            This should revert to the mode specified by the fence action. """
        want_radius = 100 # Fence Return Radius
        self.set_parameters({
            "FENCE_ACTION": 6,
            "FENCE_TYPE": 4,
            "RTL_RADIUS": want_radius,
            "NAVL1_LIM_BANK": 60,
        })
        home_loc = self.mav.location()
        locs = [
            mavutil.location(home_loc.lat - 0.003, home_loc.lng - 0.001, 0, 0),
            mavutil.location(home_loc.lat - 0.003, home_loc.lng + 0.003, 0, 0),
            mavutil.location(home_loc.lat + 0.001, home_loc.lng + 0.003, 0, 0),
            mavutil.location(home_loc.lat + 0.001, home_loc.lng - 0.001, 0, 0),
        ]
        self.upload_fences_from_locations([
            (mavutil.mavlink.MAV_CMD_NAV_FENCE_POLYGON_VERTEX_INCLUSION, locs),
        ])
        self.delay_sim_time(1)
        self.wait_ready_to_arm()
        self.takeoff(alt=50)
        self.change_mode("CRUISE")
        self.wait_distance(150, accuracy=20)

        self.progress("Enable fence and initiate fence action")
        self.do_fence_enable()
        self.assert_fence_enabled()
        self.wait_mode("GUIDED", timeout=120) # We should RTL because of fence breach
        self.delay_sim_time(60)

        items = self.download_using_mission_protocol(mavutil.mavlink.MAV_MISSION_TYPE_FENCE)
        if len(items) != 4:
            raise NotAchievedException("Unexpected fencepoint count (want=%u got=%u)" % (4, len(items)))

        # Check there are no fence return points specified still
        for fence_loc in items:
            if fence_loc.command == mavutil.mavlink.MAV_CMD_NAV_FENCE_RETURN_POINT:
                raise NotAchievedException(
                    "Unexpected fence return point found (%u) got %u" %
                    (fence_loc.command,
                     mavutil.mavlink.MAV_CMD_NAV_FENCE_RETURN_POINT))

        # Work out the approximate return point when no fence return point present
        # Logic taken from AC_PolyFence_loader.cpp
        min_loc = self.mav.location()
        max_loc = self.mav.location()
        for new_loc in locs:
            if new_loc.lat < min_loc.lat:
                min_loc.lat = new_loc.lat
            if new_loc.lng < min_loc.lng:
                min_loc.lng = new_loc.lng
            if new_loc.lat > max_loc.lat:
                max_loc.lat = new_loc.lat
            if new_loc.lng > max_loc.lng:
                max_loc.lng = new_loc.lng

        # Generate the return location based on min and max locs
        ret_lat = (min_loc.lat + max_loc.lat) / 2
        ret_lng = (min_loc.lng + max_loc.lng) / 2
        ret_loc = mavutil.location(ret_lat, ret_lng, 0, 0)
        self.progress("Return loc: (%s)" % str(ret_loc))

        # Wait for guided return to vehicle calculated fence return location
        self.wait_distance_to_location(ret_loc, 90, 110)
        self.wait_circling_point_with_radius(ret_loc, 92)

        self.progress("Test complete, disable fence and come home")
        self.do_fence_disable()
        self.fly_home_land_and_disarm()

    def FenceNoFenceReturnPointInclusion(self):
        '''Tests using home as fence return point when none is present, and no inclusion fence is uploaded'''
        """ Test result when a breach occurs and No fence return point is present and
            no inclusion fence is present and exclusion fence is present """
        want_radius = 100 # Fence Return Radius

        self.set_parameters({
            "FENCE_ACTION": 6,
            "FENCE_TYPE": 2,
            "FENCE_RADIUS": 300,
            "RTL_RADIUS": want_radius,
            "NAVL1_LIM_BANK": 60,
        })

        self.clear_fence()

        self.delay_sim_time(1)
        self.wait_ready_to_arm()
        home_loc = self.mav.location()
        self.takeoff(alt=50)
        self.change_mode("CRUISE")
        self.wait_distance(150, accuracy=20)

        self.progress("Enable fence and initiate fence action")
        self.do_fence_enable()
        self.assert_fence_enabled()
        self.wait_mode("GUIDED") # We should RTL because of fence breach
        self.delay_sim_time(30)

        items = self.download_using_mission_protocol(mavutil.mavlink.MAV_MISSION_TYPE_FENCE)
        if len(items) != 0:
            raise NotAchievedException("Unexpected fencepoint count (want=%u got=%u)" % (0, len(items)))

        # Check there are no fence return points specified still
        for fence_loc in items:
            if fence_loc.command == mavutil.mavlink.MAV_CMD_NAV_FENCE_RETURN_POINT:
                raise NotAchievedException(
                    "Unexpected fence return point found (%u) got %u" %
                    (fence_loc.command,
                     mavutil.mavlink.MAV_CMD_NAV_FENCE_RETURN_POINT))

        # Wait for guided return to vehicle calculated fence return location
        self.wait_distance_to_location(home_loc, 90, 110)
        self.wait_circling_point_with_radius(home_loc, 92)

        self.progress("Test complete, disable fence and come home")
        self.do_fence_disable()
        self.fly_home_land_and_disarm()

    def FenceDisableUnderAction(self):
        '''Tests Disabling fence while undergoing action caused by breach'''
        """ Fence breach will cause the vehicle to enter guided mode.
            Upon breach clear, check the vehicle is in the expected mode"""
        self.set_parameters({
            "FENCE_ALT_MIN": 50, # Sets the fence floor
            "FENCE_TYPE": 8,     # Only use fence floor for breaches
        })
        self.wait_ready_to_arm()

        def attempt_fence_breached_disable(start_mode, end_mode, expected_mode, action):
            self.set_parameter("FENCE_ACTION", action)   # Set Fence Action to Guided
            self.change_mode(start_mode)
            self.arm_vehicle()
            self.do_fence_enable()
            self.assert_fence_enabled()
            self.wait_mode(expected_mode)
            self.do_fence_disable()
            self.assert_fence_disabled()
            self.wait_mode(end_mode)
            self.disarm_vehicle(force=True)

        attempt_fence_breached_disable(start_mode="FBWA", end_mode="RTL", expected_mode="RTL", action=1)
        attempt_fence_breached_disable(start_mode="FBWA", end_mode="FBWA", expected_mode="GUIDED", action=6)
        attempt_fence_breached_disable(start_mode="FBWA", end_mode="FBWA", expected_mode="GUIDED", action=7)

    def _MAV_CMD_DO_AUX_FUNCTION(self, run_cmd):
        '''Test triggering Auxiliary Functions via mavlink'''
        self.context_collect('STATUSTEXT')
        self.run_auxfunc(64, 2, run_cmd=run_cmd)  # 64 == reverse throttle
        self.wait_statustext("RevThrottle: ENABLE", check_context=True)
        self.run_auxfunc(64, 0, run_cmd=run_cmd)
        self.wait_statustext("RevThrottle: DISABLE", check_context=True)
        self.run_auxfunc(65, 2, run_cmd=run_cmd)  # 65 == GPS_DISABLE

        self.start_subtest("Bad auxfunc")
        self.run_auxfunc(
            65231,
            2,
            want_result=mavutil.mavlink.MAV_RESULT_FAILED,
            run_cmd=run_cmd,
        )

        self.start_subtest("Bad switchpos")
        self.run_auxfunc(
            62,
            17,
            want_result=mavutil.mavlink.MAV_RESULT_DENIED,
            run_cmd=run_cmd,
        )

    def MAV_CMD_DO_AUX_FUNCTION(self):
        '''Test triggering Auxiliary Functions via mavlink'''
        self._MAV_CMD_DO_AUX_FUNCTION(run_cmd=self.run_cmd)
        self._MAV_CMD_DO_AUX_FUNCTION(run_cmd=self.run_cmd_int)

    def FlyEachFrame(self):
        '''Fly each supported internal frame'''
        vinfo = vehicleinfo.VehicleInfo()
        vinfo_options = vinfo.options[self.vehicleinfo_key()]
        known_broken_frames = {
            "plane-tailsitter": "does not take off; immediately emits 'AP: Transition VTOL done' while on ground",
            "plane-ice" : "needs ICE control channel for ignition",
            "quadplane-ice" : "needs ICE control channel for ignition",
            "quadplane-can" : "needs CAN periph",
            "stratoblimp" : "not expected to fly normally",
            "glider" : "needs balloon lift",
        }
        for frame in sorted(vinfo_options["frames"].keys()):
            self.start_subtest("Testing frame (%s)" % str(frame))
            if frame in known_broken_frames:
                self.progress("Actually, no I'm not - it is known-broken (%s)" %
                              (known_broken_frames[frame]))
                continue
            frame_bits = vinfo_options["frames"][frame]
            print("frame_bits: %s" % str(frame_bits))
            if frame_bits.get("external", False):
                self.progress("Actually, no I'm not - it is an external simulation")
                continue
            model = frame_bits.get("model", frame)
            # the model string for Callisto has crap in it.... we
            # should really have another entry in the vehicleinfo data
            # to carry the path to the JSON.
            actual_model = model.split(":")[0]
            defaults = self.model_defaults_filepath(actual_model)
            if not isinstance(defaults, list):
                defaults = [defaults]
            self.customise_SITL_commandline(
                [],
                defaults_filepath=defaults,
                model=model,
                wipe=True,
            )
            mission_file = "basic.txt"
            quadplane = self.get_parameter('Q_ENABLE')
            if quadplane:
                mission_file = "basic-quadplane.txt"
            tailsitter = self.get_parameter('Q_TAILSIT_ENABLE')
            if tailsitter:
                # tailsitter needs extra re-boot to pick up the rotated AHRS view
                self.reboot_sitl()
            self.wait_ready_to_arm()
            self.arm_vehicle()
            self.fly_mission(mission_file, strict=False, quadplane=quadplane, mission_timeout=400.0)
            self.wait_disarmed()

    def RCDisableAirspeedUse(self):
        '''Test RC DisableAirspeedUse option'''
        self.set_parameter("RC9_OPTION", 106)
        self.delay_sim_time(5)
        self.set_rc(9, 1000)
        self.wait_sensor_state(
            mavutil.mavlink.MAV_SYS_STATUS_SENSOR_DIFFERENTIAL_PRESSURE,
            True,
            True,
            True)
        self.set_rc(9, 2000)
        self.wait_sensor_state(
            mavutil.mavlink.MAV_SYS_STATUS_SENSOR_DIFFERENTIAL_PRESSURE,
            True,
            False,
            True)
        self.set_rc(9, 1000)
        self.wait_sensor_state(
            mavutil.mavlink.MAV_SYS_STATUS_SENSOR_DIFFERENTIAL_PRESSURE,
            True,
            True,
            True)

    def WatchdogHome(self):
        '''Ensure home is restored after watchdog reset'''
        if self.gdb:
            # we end up signalling the wrong process.  I think.
            # Probably need to have a "sitl_pid()" method to get the
            # ardupilot process's PID.
            self.progress("######## Skipping WatchdogHome test under GDB")
            return

        ex = None
        try:
            self.progress("Enabling watchdog")
            self.set_parameter("BRD_OPTIONS", 1 << 0)
            self.reboot_sitl()
            self.wait_ready_to_arm()
            self.progress("Explicitly setting home to a known location")
            orig_home = self.poll_home_position()
            new_home = orig_home
            new_home.latitude = new_home.latitude + 1000
            new_home.longitude = new_home.longitude + 2000
            new_home.altitude = new_home.altitude + 300000 # 300 metres
            self.run_cmd_int(
                mavutil.mavlink.MAV_CMD_DO_SET_HOME,
                p5=new_home.latitude,
                p6=new_home.longitude,
                p7=new_home.altitude/1000.0, # mm => m
            )
            old_bootcount = self.get_parameter('STAT_BOOTCNT')
            self.progress("Forcing watchdog reset")
            os.kill(self.sitl.pid, signal.SIGALRM)
            self.detect_and_handle_reboot(old_bootcount)
            self.wait_statustext("WDG:")
            self.wait_statustext("IMU1 is using GPS")  # won't be come armable
            self.progress("Verifying home position")
            post_reboot_home = self.poll_home_position()
            delta = self.get_distance_int(new_home, post_reboot_home)
            max_delta = 1
            if delta > max_delta:
                raise NotAchievedException(
                    "New home not where it should be (dist=%f) (want=%s) (got=%s)" %
                    (delta, str(new_home), str(post_reboot_home)))
        except Exception as e:
            self.print_exception_caught(e)
            ex = e

        self.reboot_sitl()

        if ex is not None:
            raise ex

    def AUTOTUNE(self):
        '''Test AutoTune mode'''
        self.takeoff(100)
        self.change_mode('AUTOTUNE')
        self.context_collect('STATUSTEXT')
        tstart = self.get_sim_time()
        axis = "Roll"
        rc_value = 1000
        while True:
            timeout = 600
            if self.get_sim_time() - tstart > timeout:
                raise NotAchievedException("Did not complete within %u seconds" % timeout)
            try:
                m = self.wait_statustext("%s: Finished" % axis, check_context=True, timeout=0.1)
                self.progress("Got %s" % str(m))
                if axis == "Roll":
                    axis = "Pitch"
                elif axis == "Pitch":
                    break
                else:
                    raise ValueError("Bug: %s" % axis)
            except AutoTestTimeoutException:
                pass
            self.delay_sim_time(1)

            if rc_value == 1000:
                rc_value = 2000
            elif rc_value == 2000:
                rc_value = 1000
            elif rc_value == 1000:
                rc_value = 2000
            else:
                raise ValueError("Bug")

            if axis == "Roll":
                self.set_rc(1, rc_value)
                self.set_rc(2, 1500)
            elif axis == "Pitch":
                self.set_rc(1, 1500)
                self.set_rc(2, rc_value)
            else:
                raise ValueError("Bug")

        tdelta = self.get_sim_time() - tstart
        self.progress("Finished in %0.1f seconds" % (tdelta,))

        self.set_rc(1, 1500)
        self.set_rc(2, 1500)

        self.change_mode('FBWA')
        self.fly_home_land_and_disarm(timeout=tdelta+240)

    def AutotuneFiltering(self):
        '''Test AutoTune mode with filter updates disabled'''
        self.set_parameters({
            "AUTOTUNE_OPTIONS": 3,
            # some filtering is required for autotune to complete
            "RLL_RATE_FLTD": 10,
            "PTCH_RATE_FLTD": 10,
            "RLL_RATE_FLTT": 20,
            "PTCH_RATE_FLTT": 20,
        })
        self.AUTOTUNE()

    def LandingDrift(self):
        '''Circuit with baro drift'''
        self.customise_SITL_commandline([], wipe=True)

        self.set_analog_rangefinder_parameters()

        self.set_parameters({
            "SIM_BARO_DRIFT": -0.02,
            "SIM_TERRAIN": 0,
            "RNGFND_LANDING": 1,
            "LAND_SLOPE_RCALC": 2,
            "LAND_ABORT_DEG": 1,
        })

        self.reboot_sitl()

        self.wait_ready_to_arm()
        self.arm_vehicle()

        # Load and start mission
        self.load_mission("ap-circuit.txt", strict=True)
        self.set_current_waypoint(1, check_afterwards=True)
        self.change_mode('AUTO')
        self.wait_current_waypoint(1, timeout=5)
        self.wait_groundspeed(0, 10, timeout=5)

        # Wait for landing waypoint
        self.wait_current_waypoint(9, timeout=1200)

        # Wait for landing restart
        self.wait_current_waypoint(5, timeout=60)

        # Wait for landing waypoint (second attempt)
        self.wait_current_waypoint(9, timeout=1200)

        self.wait_disarmed(timeout=180)

    def TakeoffAuto1(self):
        '''Test the behaviour of an AUTO takeoff, pt1.

        Conditions:
        - ARSPD_USE=1
        - TKOFF_OPTIONS[0]=0
        - TKOFF_THR_MAX < THR_MAX
        '''

        self.customise_SITL_commandline(
            [],
            model='plane-catapult',
            defaults_filepath=self.model_defaults_filepath("plane")
        )
        self.set_parameters({
            "ARSPD_USE": 1.0,
            "THR_MAX": 100.0,
            "TKOFF_THR_MAX": 80.0,
            "TKOFF_THR_MINACC": 3.0,
            "TECS_PITCH_MAX": 35.0,
            "PTCH_LIM_MAX_DEG": 35.0,
            "RTL_AUTOLAND": 2, # The mission contains a DO_LAND_START item.
        })

        # Load and start mission. It contains a MAV_CMD_NAV_TAKEOFF item at 100m.
        self.load_mission("catapult.txt", strict=True)
        self.change_mode('AUTO')

        self.wait_ready_to_arm()
        self.arm_vehicle()

        # Throw the catapult.
        self.set_servo(7, 2000)

        # Wait until we're midway through the climb.
        test_alt = 50
        self.wait_altitude(test_alt, test_alt+2, relative=True)

        # Ensure that by then the aircraft still goes at max allowed throttle.
        self.assert_servo_channel_value(3, 1000+10*self.get_parameter("TKOFF_THR_MAX"))

        # Wait for landing waypoint.
        self.wait_current_waypoint(11, timeout=1200)
        self.wait_disarmed(120)

    def TakeoffAuto2(self):
        '''Test the behaviour of an AUTO takeoff, pt2.

        Conditions:
        - ARSPD_USE=1
        - TKOFF_OPTIONS[0]=0
        - TKOFF_THR_MAX > THR_MAX
        '''

        self.customise_SITL_commandline(
            [],
            model='plane-catapult',
            defaults_filepath=self.model_defaults_filepath("plane")
        )
        self.set_parameters({
            "ARSPD_USE": 0.0,
            "THR_MAX": 80.0,
            "TKOFF_THR_MAX": 100.0,
            "TKOFF_THR_MINACC": 3.0,
            "TECS_PITCH_MAX": 35.0,
            "PTCH_LIM_MAX_DEG": 35.0,
            "RTL_AUTOLAND": 2, # The mission contains a DO_LAND_START item.
        })

        # Load and start mission. It contains a MAV_CMD_NAV_TAKEOFF item at 100m.
        self.load_mission("catapult.txt", strict=True)
        self.change_mode('AUTO')

        self.wait_ready_to_arm()
        self.arm_vehicle()

        # Throw the catapult.
        self.set_servo(7, 2000)

        # Wait until we're midway through the climb.
        test_alt = 50
        self.wait_altitude(test_alt, test_alt+2, relative=True)

        # Ensure that by then the aircraft still goes at max allowed throttle.
        self.assert_servo_channel_value(3, 1000+10*self.get_parameter("TKOFF_THR_MAX"))

        # Wait for landing waypoint.
        self.wait_current_waypoint(11, timeout=1200)
        self.wait_disarmed(120)

    def TakeoffAuto3(self):
        '''Test the behaviour of an AUTO takeoff, pt3.

        Conditions:
        - ARSPD_USE=1
        - TKOFF_OPTIONS[0]=1
        '''

        self.customise_SITL_commandline(
            [],
            model='plane-catapult',
            defaults_filepath=self.model_defaults_filepath("plane")
        )
        self.set_parameters({
            "ARSPD_USE": 1.0,
            "THR_MAX": 80.0,
            "THR_MIN": 0.0,
            "TKOFF_OPTIONS": 1.0,
            "TKOFF_THR_MAX": 100.0,
            "TKOFF_THR_MINACC": 3.0,
            "TECS_PITCH_MAX": 35.0,
            "TKOFF_THR_MAX_T": 3.0,
            "PTCH_LIM_MAX_DEG": 35.0,
            "RTL_AUTOLAND": 2, # The mission contains a DO_LAND_START item.
        })

        # Load and start mission. It contains a MAV_CMD_NAV_TAKEOFF item at 100m.
        self.load_mission("catapult.txt", strict=True)
        self.change_mode('AUTO')

        self.wait_ready_to_arm()
        self.arm_vehicle()

        # Throw the catapult.
        self.set_servo(7, 2000)

        # Ensure that TKOFF_THR_MAX_T is respected.
        self.delay_sim_time(self.get_parameter("TKOFF_THR_MAX_T")-1)
        self.assert_servo_channel_value(3, 1000+10*(self.get_parameter("TKOFF_THR_MAX")-1))

        # Ensure that after that the aircraft does not go full throttle anymore.
        test_alt = 50
        self.wait_altitude(test_alt, test_alt+2, relative=True)
        self.assert_servo_channel_value(3, 1000+10*self.get_parameter("TKOFF_THR_MAX")-10, operator.lt)

        # Wait for landing waypoint.
        self.wait_current_waypoint(11, timeout=1200)
        self.wait_disarmed(120)

    def TakeoffAuto4(self):
        '''Test the behaviour of an AUTO takeoff, pt4.

        Conditions:
        - ARSPD_USE=0
        - TKOFF_OPTIONS[0]=1
        '''

        self.customise_SITL_commandline(
            [],
            model='plane-catapult',
            defaults_filepath=self.model_defaults_filepath("plane")
        )
        self.set_parameters({
            "ARSPD_USE": 0.0,
            "THR_MAX": 80.0,
            "THR_MIN": 0.0,
            "TKOFF_OPTIONS": 1.0,
            "TKOFF_THR_MAX": 100.0,
            "TKOFF_THR_MINACC": 3.0,
            "TECS_PITCH_MAX": 35.0,
            "TKOFF_THR_MAX_T": 3.0,
            "PTCH_LIM_MAX_DEG": 35.0,
            "RTL_AUTOLAND": 2, # The mission contains a DO_LAND_START item.
        })

        # Load and start mission. It contains a MAV_CMD_NAV_TAKEOFF item at 100m.
        self.load_mission("catapult.txt", strict=True)
        self.change_mode('AUTO')

        self.wait_ready_to_arm()
        self.arm_vehicle()

        # Throw the catapult.
        self.set_servo(7, 2000)

        # Ensure that TKOFF_THR_MAX_T is respected.
        self.delay_sim_time(self.get_parameter("TKOFF_THR_MAX_T")-1)
        self.assert_servo_channel_value(3, 1000+10*(self.get_parameter("TKOFF_THR_MAX")), operator.le)
        self.assert_servo_channel_value(3, 1000+10*(self.get_parameter("TKOFF_THR_MAX"))-10, operator.ge)

        # Ensure that after that the aircraft still goes to maximum throttle.
        test_alt = 50
        self.wait_altitude(test_alt, test_alt+2, relative=True)
        self.assert_servo_channel_value(3, 1000+10*(self.get_parameter("TKOFF_THR_MAX")), operator.le)
        self.assert_servo_channel_value(3, 1000+10*(self.get_parameter("TKOFF_THR_MAX"))-10, operator.ge)

        # Wait for landing waypoint.
        self.wait_current_waypoint(11, timeout=1200)
        self.wait_disarmed(120)

    def TakeoffTakeoff1(self):
        '''Test the behaviour of a takeoff in TAKEOFF mode, pt1.

        Conditions:
        - ARSPD_USE=1
        - TKOFF_OPTIONS[0]=0
        - TKOFF_THR_MAX < THR_MAX
        '''

        self.customise_SITL_commandline(
            [],
            model='plane-catapult',
            defaults_filepath=self.model_defaults_filepath("plane")
        )
        self.set_parameters({
            "ARSPD_USE": 1.0,
            "THR_MAX": 100.0,
            "TKOFF_LVL_ALT": 30.0,
            "TKOFF_ALT": 100.0,
            "TKOFF_OPTIONS": 0.0,
            "TKOFF_THR_MINACC": 3.0,
            "TKOFF_THR_MAX": 80.0,
            "TECS_PITCH_MAX": 35.0,
            "PTCH_LIM_MAX_DEG": 35.0,
        })
        self.change_mode("TAKEOFF")

        self.wait_ready_to_arm()
        self.arm_vehicle()

        # Throw the catapult.
        self.set_servo(7, 2000)

        # Check whether we're at max throttle below TKOFF_LVL_ALT.
        test_alt = self.get_parameter("TKOFF_LVL_ALT")-10
        self.wait_altitude(test_alt, test_alt+2, relative=True)
        self.assert_servo_channel_value(3, 1000+10*self.get_parameter("TKOFF_THR_MAX"))

        # Check whether we're still at max throttle past TKOFF_LVL_ALT.
        test_alt = self.get_parameter("TKOFF_LVL_ALT")+10
        self.wait_altitude(test_alt, test_alt+2, relative=True)
        self.assert_servo_channel_value(3, 1000+10*(self.get_parameter("TKOFF_THR_MAX")), operator.le)
        self.assert_servo_channel_value(3, 1000+10*(self.get_parameter("TKOFF_THR_MAX"))-1, operator.ge)

        # Wait for the takeoff to complete.
        target_alt = self.get_parameter("TKOFF_ALT")
        self.wait_altitude(target_alt-5, target_alt, relative=True)

        self.fly_home_land_and_disarm()

    def TakeoffTakeoff2(self):
        '''Test the behaviour of a takeoff in TAKEOFF mode, pt2.

        Conditions:
        - ARSPD_USE=1
        - TKOFF_OPTIONS[0]=1
        - TKOFF_THR_MAX < THR_MAX
        '''

        self.customise_SITL_commandline(
            [],
            model='plane-catapult',
            defaults_filepath=self.model_defaults_filepath("plane")
        )
        self.set_parameters({
            "ARSPD_USE": 1.0,
            "THR_MAX": 100.0,
            "TKOFF_LVL_ALT": 80.0,
            "TKOFF_ALT": 150.0,
            "TKOFF_OPTIONS": 1.0,
            "TKOFF_THR_MINACC": 3.0,
            "TKOFF_THR_MAX": 80.0,
            "TECS_PITCH_MAX": 35.0,
            "PTCH_LIM_MAX_DEG": 35.0,
        })
        self.change_mode("TAKEOFF")

        self.wait_ready_to_arm()
        self.arm_vehicle()

        # Throw the catapult.
        self.set_servo(7, 2000)

        # Check whether we're at max throttle below TKOFF_LVL_ALT.
        test_alt = self.get_parameter("TKOFF_LVL_ALT")-10
        self.wait_altitude(test_alt, test_alt+2, relative=True)
        self.assert_servo_channel_value(3, 1000+10*(self.get_parameter("TKOFF_THR_MAX")), operator.le)
        self.assert_servo_channel_value(3, 1000+10*(self.get_parameter("TKOFF_THR_MAX"))-1, operator.ge)

        # Check whether we've receded from max throttle past TKOFF_LVL_ALT.
        test_alt = self.get_parameter("TKOFF_LVL_ALT")+10
        self.wait_altitude(test_alt, test_alt+2, relative=True)
        self.assert_servo_channel_value(3, 1000+10*(self.get_parameter("TKOFF_THR_MAX")), operator.le)
        self.assert_servo_channel_value(3, 1000+10*(self.get_parameter("TKOFF_THR_MIN"))-1, operator.ge)

        # Wait for the takeoff to complete.
        target_alt = self.get_parameter("TKOFF_ALT")
        self.wait_altitude(target_alt-5, target_alt, relative=True)

        self.fly_home_land_and_disarm()

    def TakeoffTakeoff3(self):
        '''Test the behaviour of a takeoff in TAKEOFF mode, pt3.

        This is the same as case #1, but with disabled airspeed sensor.

        Conditions:
        - ARSPD_USE=0
        - TKOFF_OPTIONS[0]=0
        - TKOFF_THR_MAX < THR_MAX
        '''

        self.customise_SITL_commandline(
            [],
            model='plane-catapult',
            defaults_filepath=self.model_defaults_filepath("plane")
        )
        self.set_parameters({
            "ARSPD_USE": 0.0,
            "THR_MAX": 100.0,
            "TKOFF_LVL_ALT": 30.0,
            "TKOFF_ALT": 100.0,
            "TKOFF_OPTIONS": 0.0,
            "TKOFF_THR_MINACC": 3.0,
            "TKOFF_THR_MAX": 80.0,
            "TECS_PITCH_MAX": 35.0,
            "PTCH_LIM_MAX_DEG": 35.0,
        })
        self.change_mode("TAKEOFF")

        self.wait_ready_to_arm()
        self.arm_vehicle()

        # Throw the catapult.
        self.set_servo(7, 2000)

        # Check whether we're at max throttle below TKOFF_LVL_ALT.
        test_alt = self.get_parameter("TKOFF_LVL_ALT")-10
        self.wait_altitude(test_alt, test_alt+2, relative=True)
        self.assert_servo_channel_value(3, 1000+10*self.get_parameter("TKOFF_THR_MAX"))

        # Check whether we're still at max throttle past TKOFF_LVL_ALT.
        test_alt = self.get_parameter("TKOFF_LVL_ALT")+10
        self.wait_altitude(test_alt, test_alt+2, relative=True)
        self.assert_servo_channel_value(3, 1000+10*(self.get_parameter("TKOFF_THR_MAX")), operator.le)
        self.assert_servo_channel_value(3, 1000+10*(self.get_parameter("TKOFF_THR_MAX"))-1, operator.ge)

        # Wait for the takeoff to complete.
        target_alt = self.get_parameter("TKOFF_ALT")
        self.wait_altitude(target_alt-5, target_alt, relative=True)

        self.fly_home_land_and_disarm()

    def TakeoffTakeoff4(self):
        '''Test the behaviour of a takeoff in TAKEOFF mode, pt4.

        This is the same as case #3, but with almost stock parameters and without a catapult.

        Conditions:
        - ARSPD_USE=0
        '''

        self.customise_SITL_commandline(
            [],
            model='plane-catapult',
            defaults_filepath=self.model_defaults_filepath("plane")
        )
        self.set_parameters({
            "ARSPD_USE": 0.0,
        })
        self.change_mode("TAKEOFF")

        self.wait_ready_to_arm()
        self.arm_vehicle()

        # Check whether we're at max throttle below TKOFF_LVL_ALT.
        test_alt = self.get_parameter("TKOFF_LVL_ALT")-10
        self.wait_altitude(test_alt, test_alt+2, relative=True)
        self.assert_servo_channel_value(3, 1000+10*(self.get_parameter("THR_MAX")), operator.le)
        self.assert_servo_channel_value(3, 1000+10*(self.get_parameter("THR_MAX"))-10, operator.ge)

        # Check whether we're still at max throttle past TKOFF_LVL_ALT.
        test_alt = self.get_parameter("TKOFF_LVL_ALT")+10
        self.wait_altitude(test_alt, test_alt+2, relative=True)
        self.assert_servo_channel_value(3, 1000+10*(self.get_parameter("THR_MAX")), operator.le)
        self.assert_servo_channel_value(3, 1000+10*(self.get_parameter("THR_MAX"))-10, operator.ge)

        # Wait for the takeoff to complete.
        target_alt = self.get_parameter("TKOFF_ALT")
        self.wait_altitude(target_alt-5, target_alt, relative=True)

        self.fly_home_land_and_disarm()

    def DCMFallback(self):
        '''Really annoy the EKF and force fallback'''
        self.reboot_sitl()
        self.delay_sim_time(30)

        self.takeoff(50)
        self.change_mode('CIRCLE')
        self.context_push()
        self.context_collect('STATUSTEXT')
        self.set_parameters({
            "EK3_POS_I_GATE": 0,
            "SIM_GPS_HZ": 1,
            "SIM_GPS_LAG_MS": 1000,
        })
        self.wait_statustext("DCM Active", check_context=True, timeout=60)
        self.wait_statustext("EKF3 Active", check_context=True)
        self.wait_statustext("DCM Active", check_context=True)
        self.wait_statustext("EKF3 Active", check_context=True)
        self.wait_statustext("DCM Active", check_context=True)
        self.wait_statustext("EKF3 Active", check_context=True)
        self.context_stop_collecting('STATUSTEXT')

        self.fly_home_land_and_disarm()
        self.context_pop()
        self.reboot_sitl()

    def ForcedDCM(self):
        '''Switch to DCM mid-flight'''
        self.wait_ready_to_arm()
        self.arm_vehicle()

        self.takeoff(50)
        self.context_collect('STATUSTEXT')
        self.set_parameter("AHRS_EKF_TYPE", 0)
        self.wait_statustext("DCM Active", check_context=True)
        self.context_stop_collecting('STATUSTEXT')

        self.fly_home_land_and_disarm()

    def EFITest(self, efi_type, name, sim_name, check_fuel_flow=True):
        '''method to be called by EFI tests'''
        self.start_subtest("EFI Test for (%s)" % name)
        self.assert_not_receiving_message('EFI_STATUS')
        self.set_parameters({
            'SIM_EFI_TYPE': efi_type,
            'EFI_TYPE': efi_type,
            'SERIAL5_PROTOCOL': 24,
            'RPM1_TYPE': 10,
        })

        self.customise_SITL_commandline(
            ["--serial5=sim:%s" % sim_name,
             ],
        )
        self.wait_ready_to_arm()

        baro_m = self.assert_receive_message("SCALED_PRESSURE")
        self.progress(self.dump_message_verbose(baro_m))
        baro_temperature = baro_m.temperature / 100.0  # cDeg->deg
        m = self.assert_received_message_field_values("EFI_STATUS", {
            "throttle_out": 0,
            "health": 1,
        }, very_verbose=1)

        if abs(baro_temperature - m.intake_manifold_temperature) > 1:
            raise NotAchievedException(
                "Bad intake manifold temperature (want=%f got=%f)" %
                (baro_temperature, m.intake_manifold_temperature))

        self.arm_vehicle()

        self.set_rc(3, 1300)

        tstart = self.get_sim_time()
        while True:
            now = self.get_sim_time_cached()
            if now - tstart > 10:
                raise NotAchievedException("RPM1 and EFI_STATUS.rpm did not match")
            rpm_m = self.assert_receive_message("RPM", verbose=1)
            want_rpm = 1000
            if rpm_m.rpm1 < want_rpm:
                continue

            m = self.assert_receive_message("EFI_STATUS", verbose=1)
            if abs(m.rpm - rpm_m.rpm1) > 100:
                continue

            break

        self.progress("now we're started, check a few more values")
        # note that megasquirt drver doesn't send throttle, so throttle_out is zero!
        m = self.assert_received_message_field_values("EFI_STATUS", {
            "health": 1,
        }, very_verbose=1)
        m = self.wait_message_field_values("EFI_STATUS", {
            "throttle_position": 31,
            "intake_manifold_temperature": 28,
        }, very_verbose=1, epsilon=2)

        if check_fuel_flow:
            if abs(m.fuel_flow - 0.2) < 0.0001:
                raise NotAchievedException("Expected fuel flow")

        self.set_rc(3, 1000)

        # need to force disarm as the is_flying flag can trigger with the engine running
        self.disarm_vehicle(force=True)

    def MegaSquirt(self):
        '''test MegaSquirt driver'''
        self.EFITest(
            1, "MegaSquirt", "megasquirt",
            check_fuel_flow=False,
        )

    def Hirth(self):
        '''Test Hirth EFI'''
        self.EFITest(8, "Hirth", "hirth")

    def GlideSlopeThresh(self):
        '''Test rebuild glide slope if above and climbing'''

        # Test that GLIDE_SLOPE_THRESHOLD correctly controls re-planning glide slope
        # in the scenario that aircraft is above planned slope and slope is positive (climbing).
        #
        #
        #  Behaviour with GLIDE_SLOPE_THRESH = 0 (no slope replanning)
        #       (2)..      __(4)
        #         |  \..__/
        #         |  __/
        #         (3)
        #
        # Behaviour with GLIDE_SLOPE_THRESH = 5 (slope replanning when >5m error)
        #       (2)........__(4)
        #         |     __/
        #         |  __/
        #         (3)
        # Solid is plan, dots are actual flightpath.

        self.load_mission('rapid-descent-then-climb.txt', strict=False)

        self.set_current_waypoint(1)
        self.change_mode('AUTO')
        self.wait_ready_to_arm()
        self.arm_vehicle()

        #
        # Initial run with GLIDE_SLOPE_THR = 5 (default).
        #
        self.set_parameter("GLIDE_SLOPE_THR", 5)

        # Wait for waypoint commanding rapid descent, followed by climb.
        self.wait_current_waypoint(5, timeout=1200)

        # Altitude should not descend significantly below the initial altitude
        init_altitude = self.get_altitude(relative=True, timeout=2)
        timeout = 600
        wpnum = 7
        tstart = self.get_sim_time()
        while True:
            if self.get_sim_time() - tstart > timeout:
                raise AutoTestTimeoutException("Did not get wanted current waypoint")

            if (self.get_altitude(relative=True, timeout=2) - init_altitude) < -10:
                raise NotAchievedException("Descended >10m before reaching desired waypoint,\
  indicating slope was not replanned")

            seq = self.mav.waypoint_current()
            self.progress("Waiting for wp=%u current=%u" % (wpnum, seq))
            if seq == wpnum:
                break

        self.set_current_waypoint(2)

        #
        # Second run with GLIDE_SLOPE_THR = 0 (no re-plan).
        #
        self.set_parameter("GLIDE_SLOPE_THR", 0)

        # Wait for waypoint commanding rapid descent, followed by climb.
        self.wait_current_waypoint(5, timeout=1200)

        # This time altitude should descend significantly below the initial altitude
        init_altitude = self.get_altitude(relative=True, timeout=2)
        timeout = 600
        wpnum = 7
        tstart = self.get_sim_time()
        while True:
            if self.get_sim_time() - tstart > timeout:
                raise AutoTestTimeoutException("Did not get wanted altitude")

            seq = self.mav.waypoint_current()
            self.progress("Waiting for wp=%u current=%u" % (wpnum, seq))
            if seq == wpnum:
                raise NotAchievedException("Reached desired waypoint without first decending 10m,\
 indicating slope was replanned unexpectedly")

            if (self.get_altitude(relative=True, timeout=2) - init_altitude) < -10:
                break

        # Disarm
        self.wait_disarmed(timeout=600)

        self.progress("Mission OK")

    def MAV_CMD_NAV_LOITER_TURNS(self, target_system=1, target_component=1):
        '''test MAV_CMD_NAV_LOITER_TURNS mission item'''
        alt = 100
        seq = 0
        items = []
        tests = [
            (self.home_relative_loc_ne(50, -50), 100, 0.3),
            (self.home_relative_loc_ne(100, 50), 1005, 3),
        ]
        # add a home position:
        items.append(self.mav.mav.mission_item_int_encode(
            target_system,
            target_component,
            seq, # seq
            mavutil.mavlink.MAV_FRAME_GLOBAL,
            mavutil.mavlink.MAV_CMD_NAV_WAYPOINT,
            0, # current
            0, # autocontinue
            0, # p1
            0, # p2
            0, # p3
            0, # p4
            0, # latitude
            0, # longitude
            0, # altitude
            mavutil.mavlink.MAV_MISSION_TYPE_MISSION))
        seq += 1

        # add takeoff
        items.append(self.mav.mav.mission_item_int_encode(
            target_system,
            target_component,
            seq, # seq
            mavutil.mavlink.MAV_FRAME_GLOBAL_RELATIVE_ALT,
            mavutil.mavlink.MAV_CMD_NAV_TAKEOFF,
            0, # current
            0, # autocontinue
            0, # p1
            0, # p2
            0, # p3
            0, # p4
            0, # latitude
            0, # longitude
            alt, # altitude
            mavutil.mavlink.MAV_MISSION_TYPE_MISSION))
        seq += 1

        # add circles
        for (loc, radius, turn) in tests:
            items.append(self.mav.mav.mission_item_int_encode(
                target_system,
                target_component,
                seq, # seq
                mavutil.mavlink.MAV_FRAME_GLOBAL_RELATIVE_ALT,
                mavutil.mavlink.MAV_CMD_NAV_LOITER_TURNS,
                0, # current
                0, # autocontinue
                turn, # p1
                0, # p2
                radius, # p3
                0, # p4
                int(loc.lat*1e7), # latitude
                int(loc.lng*1e7), # longitude
                alt, # altitude
                mavutil.mavlink.MAV_MISSION_TYPE_MISSION))
            seq += 1

        # add an RTL
        items.append(self.mav.mav.mission_item_int_encode(
            target_system,
            target_component,
            seq, # seq
            mavutil.mavlink.MAV_FRAME_GLOBAL,
            mavutil.mavlink.MAV_CMD_NAV_RETURN_TO_LAUNCH,
            0, # current
            0, # autocontinue
            0, # p1
            0, # p2
            0, # p3
            0, # p4
            0, # latitude
            0, # longitude
            0, # altitude
            mavutil.mavlink.MAV_MISSION_TYPE_MISSION))
        seq += 1

        self.upload_using_mission_protocol(mavutil.mavlink.MAV_MISSION_TYPE_MISSION, items)
        downloaded_items = self.download_using_mission_protocol(mavutil.mavlink.MAV_MISSION_TYPE_MISSION)
        ofs = 2
        self.progress("Checking downloaded mission is as expected")
        for (loc, radius, turn) in tests:
            downloaded = downloaded_items[ofs]
            if radius > 255:
                # ArduPilot only stores % 10
                radius = radius - radius % 10
            if downloaded.param3 != radius:
                raise NotAchievedException(
                    "Did not get expected radius for item %u; want=%f got=%f" %
                    (ofs, radius, downloaded.param3))
            if turn > 0 and turn < 1:
                # ArduPilot stores fractions in 8 bits (*256) and unpacks it (/256)
                turn = int(turn*256) / 256.0
            if downloaded.param1 != turn:
                raise NotAchievedException(
                    "Did not get expected turn for item %u; want=%f got=%f" %
                    (ofs, turn, downloaded.param1))
            ofs += 1

        self.change_mode('AUTO')
        self.wait_ready_to_arm()
        self.arm_vehicle()
        self.set_parameter("NAVL1_LIM_BANK", 50)

        self.wait_current_waypoint(2)

        for (loc, expected_radius, _) in tests:
            self.wait_circling_point_with_radius(
                loc,
                expected_radius,
                epsilon=20.0,
                timeout=240,
            )
            self.set_current_waypoint(self.current_waypoint()+1)

        self.fly_home_land_and_disarm(timeout=180)

    def MidAirDisarmDisallowed(self):
        '''Ensure mid-air disarm is not possible'''
        self.takeoff(50)
        disarmed = False
        try:
            self.disarm_vehicle()
            disarmed = True
        except ValueError as e:
            self.progress("Got %s" % repr(e))
            if "Expected MAV_RESULT_ACCEPTED got MAV_RESULT_FAILED" not in str(e):
                raise e
        if disarmed:
            raise NotAchievedException("Disarmed when we shouldn't have")
        # should still be able to force-disarm:
        self.disarm_vehicle(force=True)
        self.reboot_sitl()

    def AerobaticsScripting(self):
        '''Fixed Wing Aerobatics'''
        applet_script = "Aerobatics/FixedWing/plane_aerobatics.lua"
        airshow = "Aerobatics/FixedWing/Schedules/AirShow.txt"
        trick72 = "trick72.txt"

        model = "plane-3d"

        self.customise_SITL_commandline(
            [],
            model=model,
            defaults_filepath="Tools/autotest/models/plane-3d.parm",
            wipe=True)

        self.context_push()
        self.install_applet_script_context(applet_script)
        self.install_applet_script_context(airshow, install_name=trick72)
        self.context_collect('STATUSTEXT')
        self.reboot_sitl()

        self.set_parameter("TRIK_ENABLE", 1)
        self.set_rc(7, 1000) # disable tricks

        self.scripting_restart()
        self.wait_text("Enabled 3 aerobatic tricks", check_context=True)
        self.set_parameters({
            "TRIK1_ID": 72,
            "RC7_OPTION" : 300, # activation switch
            "RC9_OPTION" : 301, # selection switch
            "SIM_SPEEDUP": 5, # need to give some cycles to lua
        })

        self.wait_ready_to_arm()
        self.change_mode("TAKEOFF")
        self.arm_vehicle()
        self.wait_altitude(30, 40, timeout=30, relative=True)
        self.change_mode("CRUISE")

        self.set_rc(9, 1000) # select first trick
        self.delay_sim_time(1)
        self.set_rc(7, 1500) # show selected trick

        self.wait_text("Trick 1 selected (SuperAirShow)", check_context=True)
        self.set_rc(7, 2000) # activate trick
        self.wait_text("Trick 1 started (SuperAirShow)", check_context=True)

        highest_error = 0
        while True:
            m = self.mav.recv_match(type='NAMED_VALUE_FLOAT', blocking=True, timeout=2)
            if not m:
                break
            if m.name != 'PERR':
                continue
            highest_error = max(highest_error, m.value)
            if highest_error > 15:
                raise NotAchievedException("path error %.1f" % highest_error)

        if highest_error == 0:
            raise NotAchievedException("path error not reported")
        self.progress("Finished trick, max error=%.1fm" % highest_error)
        self.disarm_vehicle(force=True)

        messages = self.context_collection('STATUSTEXT')
        self.context_pop()
        self.reboot_sitl()

        # check all messages to see if we got all tricks
        tricks = ["Loop", "HalfReverseCubanEight", "ScaleFigureEight", "Immelmann",
                  "Split-S", "RollingCircle", "HumptyBump", "HalfCubanEight",
                  "BarrelRoll", "CrossBoxTopHat", "TriangularLoop",
                  "Finishing SuperAirShow!"]
        texts = [m.text for m in messages]
        for t in tricks:
            if t in texts:
                self.progress("Completed trick %s" % t)
            else:
                raise NotAchievedException("Missing trick %s" % t)

    def SDCardWPTest(self):
        '''test BRD_SD_MISSION support'''
        spiral_script = "mission_spiral.lua"

        self.context_push()
        self.install_example_script(spiral_script)
        self.context_collect('STATUSTEXT')
        self.set_parameters({
            "BRD_SD_MISSION" : 64,
            "SCR_ENABLE" : 1,
            "SCR_VM_I_COUNT" : 1000000
            })

        self.wait_ready_to_arm()
        self.reboot_sitl()

        self.wait_text("Loaded spiral mission creator", check_context=True)
        self.set_parameters({
            "SCR_USER2": 19, # radius
            "SCR_USER3": -35.36322, # lat
            "SCR_USER4": 149.16525, # lon
            "SCR_USER5": 684.13, # alt
        })

        count = (65536 // 15) - 1

        self.progress("Creating spiral mission of size %s" % count)
        self.set_parameter("SCR_USER1", count)

        self.wait_text("Created spiral of size %u" % count, check_context=True)

        self.progress("Checking spiral before reboot")
        self.set_parameter("SCR_USER6", count)
        self.wait_text("Compared spiral of size %u OK" % count, check_context=True)
        self.set_parameter("SCR_USER6", 0)

        self.wait_ready_to_arm()
        self.reboot_sitl()
        self.progress("Checking spiral after reboot")
        self.set_parameter("SCR_USER6", count)
        self.wait_text("Compared spiral of size %u OK" % count, check_context=True)

        self.remove_installed_script(spiral_script)

        self.context_pop()
        self.wait_ready_to_arm()
        self.reboot_sitl()

    def MANUAL_CONTROL(self):
        '''test MANUAL_CONTROL mavlink message'''
        self.set_parameter("SYSID_MYGCS", self.mav.source_system)

        self.progress("Takeoff")
        self.takeoff(alt=50)

        self.change_mode('FBWA')

        tstart = self.get_sim_time_cached()
        roll_input = -500
        want_roll_degrees = -12
        while True:
            if self.get_sim_time_cached() - tstart > 10:
                raise AutoTestTimeoutException("Did not reach roll")
            self.progress("Sending roll-left")
            self.mav.mav.manual_control_send(
                1, # target system
                32767, # x (pitch)
                roll_input, # y (roll)
                32767, # z (thrust)
                32767, # r (yaw)
                0) # button mask
            m = self.mav.recv_match(type='ATTITUDE', blocking=True, timeout=1)
            print("m=%s" % str(m))
            if m is None:
                continue
            p = math.degrees(m.roll)
            self.progress("roll=%f want<=%f" % (p, want_roll_degrees))
            if p <= want_roll_degrees:
                break
        self.mav.mav.manual_control_send(
            1, # target system
            32767, # x (pitch)
            32767, # y (roll)
            32767, # z (thrust)
            32767, # r (yaw)
            0) # button mask
        self.fly_home_land_and_disarm()

    def mission_home_point(self, target_system=1, target_component=1):
        '''just an empty-ish item-int to store home'''
        return self.mav.mav.mission_item_int_encode(
            target_system,
            target_component,
            0, # seq
            mavutil.mavlink.MAV_FRAME_GLOBAL,
            mavutil.mavlink.MAV_CMD_NAV_WAYPOINT,
            0, # current
            0, # autocontinue
            0, # p1
            0, # p2
            0, # p3
            0, # p4
            0, # latitude
            0, # longitude
            0, # altitude
            mavutil.mavlink.MAV_MISSION_TYPE_MISSION)

    def mission_jump_tag(self, tag, target_system=1, target_component=1):
        '''create a jump tag mission item'''
        return self.mav.mav.mission_item_int_encode(
            target_system,
            target_component,
            0, # seq
            mavutil.mavlink.MAV_FRAME_GLOBAL,
            mavutil.mavlink.MAV_CMD_JUMP_TAG,
            0, # current
            0, # autocontinue
            tag, # p1
            0, # p2
            0, # p3
            0, # p4
            0, # latitude
            0, # longitude
            0, # altitude
            mavutil.mavlink.MAV_MISSION_TYPE_MISSION)

    def mission_do_jump_tag(self, tag, target_system=1, target_component=1):
        '''create a jump tag mission item'''
        return self.mav.mav.mission_item_int_encode(
            target_system,
            target_component,
            0, # seq
            mavutil.mavlink.MAV_FRAME_GLOBAL,
            mavutil.mavlink.MAV_CMD_DO_JUMP_TAG,
            0, # current
            0, # autocontinue
            tag, # p1
            0, # p2
            0, # p3
            0, # p4
            0, # latitude
            0, # longitude
            0, # altitude
            mavutil.mavlink.MAV_MISSION_TYPE_MISSION)

    def mission_anonymous_waypoint(self, target_system=1, target_component=1):
        '''just a boring waypoint'''
        return self.mav.mav.mission_item_int_encode(
            target_system,
            target_component,
            0, # seq
            mavutil.mavlink.MAV_FRAME_GLOBAL,
            mavutil.mavlink.MAV_CMD_NAV_WAYPOINT,
            0, # current
            0, # autocontinue
            0, # p1
            0, # p2
            0, # p3
            0, # p4
            1, # latitude
            1, # longitude
            1, # altitude
            mavutil.mavlink.MAV_MISSION_TYPE_MISSION)

    def renumber_mission_items(self, mission):
        count = 0
        for item in mission:
            item.seq = count
            count += 1

    def MissionJumpTags_missing_jump_target(self, target_system=1, target_component=1):
        self.start_subtest("Check missing-jump-tag behaviour")
        jump_target = 2
        mission = [
            self.mission_home_point(),
            self.mission_anonymous_waypoint(),
            self.mission_anonymous_waypoint(),
            self.mission_jump_tag(jump_target),
            self.mission_anonymous_waypoint(),
            self.mission_anonymous_waypoint(),
        ]
        self.renumber_mission_items(mission)
        self.check_mission_upload_download(mission)
        self.progress("Checking incorrect tag behaviour")
        self.run_cmd(
            mavutil.mavlink.MAV_CMD_DO_JUMP_TAG,
            p1=jump_target + 1,
            want_result=mavutil.mavlink.MAV_RESULT_FAILED
        )
        self.progress("Checking correct tag behaviour")
        self.run_cmd(
            mavutil.mavlink.MAV_CMD_DO_JUMP_TAG,
            p1=jump_target,
        )
        self.assert_current_waypoint(4)

    def MissionJumpTags_do_jump_to_bad_tag(self, target_system=1, target_component=1):
        mission = [
            self.mission_home_point(),
            self.mission_anonymous_waypoint(),
            self.mission_do_jump_tag(17),
            self.mission_anonymous_waypoint(),
        ]
        self.renumber_mission_items(mission)
        self.check_mission_upload_download(mission)
        self.change_mode('AUTO')
        self.arm_vehicle()
        self.set_current_waypoint(2, check_afterwards=False)
        self.assert_mode('RTL')
        self.disarm_vehicle()

    def MissionJumpTags_jump_tag_at_end_of_mission(self, target_system=1, target_component=1):
        mission = [
            self.mission_home_point(),
            self.mission_anonymous_waypoint(),
            self.mission_jump_tag(17),
        ]
        # Jumping to an end of a mission, either DO_JUMP or DO_JUMP_TAG will result in a failed attempt.
        # The failure is from mission::set_current_cmd() returning false if it can not find any NAV
        # commands on or after the index. Two scenarios:
        # 1) AUTO mission triggered: The the set_command will fail and it will cause an RTL event
        #       (Harder to test, need vehicle to actually reach the waypoint)
        # 2) GCS/MAVLink: It will return MAV_RESULT_FAILED and there's on change to the mission. (Easy to test)
        self.renumber_mission_items(mission)
        self.check_mission_upload_download(mission)
        self.progress("Checking correct tag behaviour")
        self.change_mode('AUTO')
        self.arm_vehicle()
        self.run_cmd(
            mavutil.mavlink.MAV_CMD_DO_JUMP_TAG,
            p1=17,
            want_result=mavutil.mavlink.MAV_RESULT_FAILED
        )
        self.disarm_vehicle()

    def MissionJumpTags(self):
        '''test MAV_CMD_JUMP_TAG'''
        self.wait_ready_to_arm()
        self.MissionJumpTags_missing_jump_target()
        self.MissionJumpTags_do_jump_to_bad_tag()
        self.MissionJumpTags_jump_tag_at_end_of_mission()

    def AltResetBadGPS(self):
        '''Tests the handling of poor GPS lock pre-arm alt resets'''
        self.set_parameters({
            "SIM_GPS_GLITCH_Z": 0,
            "SIM_GPS_ACC": 0.3,
        })
        self.wait_ready_to_arm()

        m = self.assert_receive_message('GLOBAL_POSITION_INT')
        relalt = m.relative_alt*0.001
        if abs(relalt) > 3:
            raise NotAchievedException("Bad relative alt %.1f" % relalt)

        self.progress("Setting low accuracy, glitching GPS")
        self.set_parameter("SIM_GPS_ACC", 40)
        self.set_parameter("SIM_GPS_GLITCH_Z", -47)

        self.progress("Waiting 10s for height update")
        self.delay_sim_time(10)

        self.wait_ready_to_arm()
        self.arm_vehicle()

        m = self.assert_receive_message('GLOBAL_POSITION_INT')
        relalt = m.relative_alt*0.001
        if abs(relalt) > 3:
            raise NotAchievedException("Bad glitching relative alt %.1f" % relalt)

        self.disarm_vehicle()
        # reboot to clear potentially bad state

    def trigger_airspeed_cal(self):
        self.run_cmd(
            mavutil.mavlink.MAV_CMD_PREFLIGHT_CALIBRATION,
            p3=1,
        )

    def AirspeedCal(self):
        '''test Airspeed calibration'''

        self.start_subtest('1 airspeed sensor')
        self.context_push()
        self.context_collect('STATUSTEXT')
        self.trigger_airspeed_cal()
        self.wait_statustext('Airspeed 1 calibrated', check_context=True)
        self.context_pop()

        self.context_push()
        self.context_collect('STATUSTEXT')
        self.start_subtest('0 airspeed sensors')
        self.set_parameter('ARSPD_TYPE', 0)
        self.reboot_sitl()
        self.wait_statustext('No airspeed sensor', check_context=True)
        self.trigger_airspeed_cal()
        self.delay_sim_time(5)
        if self.statustext_in_collections('Airspeed 1 calibrated'):
            raise NotAchievedException("Did not disable airspeed sensor?!")
        self.context_pop()

        self.start_subtest('2 airspeed sensors')
        self.set_parameter('ARSPD_TYPE', 100)
        self.set_parameter('ARSPD2_TYPE', 100)
        self.reboot_sitl()
        self.context_push()
        self.context_collect('STATUSTEXT')
        self.trigger_airspeed_cal()
        self.wait_statustext('Airspeed 1 calibrated', check_context=True)
        self.wait_statustext('Airspeed 2 calibrated', check_context=True)
        self.context_pop()

        self.reboot_sitl()

    def RunMissionScript(self):
        '''Test run_mission.py script'''
        script = os.path.join('Tools', 'autotest', 'run_mission.py')
        self.stop_SITL()
        util.run_cmd([
            util.reltopdir(script),
            self.binary,
            'plane',
            self.generic_mission_filepath_for_filename("flaps.txt"),
        ])
        self.start_SITL()

    def MAV_CMD_GUIDED_CHANGE_ALTITUDE(self):
        '''test handling of MAV_CMD_GUIDED_CHANGE_ALTITUDE'''
        self.takeoff(30, relative=True)
        self.change_mode('GUIDED')
        for alt in 50, 70:
            self.run_cmd_int(
                mavutil.mavlink.MAV_CMD_GUIDED_CHANGE_ALTITUDE,
                p7=alt,
                frame=mavutil.mavlink.MAV_FRAME_GLOBAL_RELATIVE_ALT,
            )
            self.wait_altitude(alt-1, alt+1, timeout=30, relative=True)

        # test for #24535
        self.change_mode('LOITER')
        self.delay_sim_time(5)
        self.change_mode('GUIDED')
        self.wait_altitude(
            alt-3,  # NOTE: reuse of alt from above loop!
            alt+3,
            minimum_duration=10,
            timeout=30,
            relative=True,
        )
        self.fly_home_land_and_disarm()

    def _MAV_CMD_PREFLIGHT_CALIBRATION(self, command):
        self.context_push()
        self.start_subtest("Denied when armed")
        self.wait_ready_to_arm()
        self.arm_vehicle()
        command(
            mavutil.mavlink.MAV_CMD_PREFLIGHT_CALIBRATION,
            p1=1,
            want_result=mavutil.mavlink.MAV_RESULT_FAILED,
        )
        self.disarm_vehicle()

        self.context_collect('STATUSTEXT')

        self.start_subtest("gyro cal")
        command(
            mavutil.mavlink.MAV_CMD_PREFLIGHT_CALIBRATION,
            p1=1,
        )

        self.start_subtest("baro cal")
        command(
            mavutil.mavlink.MAV_CMD_PREFLIGHT_CALIBRATION,
            p3=1,
        )
        self.wait_statustext('Barometer calibration complete', check_context=True)

        # accelcal skipped here, it is checked elsewhere

        self.start_subtest("ins trim")
        command(
            mavutil.mavlink.MAV_CMD_PREFLIGHT_CALIBRATION,
            p5=2,
        )

        # enforced delay between cals:
        self.delay_sim_time(5)

        self.start_subtest("simple accel cal")
        command(
            mavutil.mavlink.MAV_CMD_PREFLIGHT_CALIBRATION,
            p5=4,
        )
        # simple gyro cal makes the GPS units go unhealthy as they are
        # not maintaining their update rate (gyro cal is synchronous
        # in the main loop).  Usually ~30 seconds to recover...
        self.wait_gps_sys_status_not_present_or_enabled_and_healthy(timeout=60)

        self.start_subtest("force save accels")
        command(
            mavutil.mavlink.MAV_CMD_PREFLIGHT_CALIBRATION,
            p5=76,
        )

        self.start_subtest("force save compasses")
        command(
            mavutil.mavlink.MAV_CMD_PREFLIGHT_CALIBRATION,
            p2=76,
        )

        self.context_pop()

    def MAV_CMD_PREFLIGHT_CALIBRATION(self):
        '''test MAV_CMD_PREFLIGHT_CALIBRATION mavlink handling'''
        self._MAV_CMD_PREFLIGHT_CALIBRATION(self.run_cmd)
        self._MAV_CMD_PREFLIGHT_CALIBRATION(self.run_cmd_int)

    def MAV_CMD_DO_INVERTED_FLIGHT(self):
        '''fly upside-down mission item'''
        alt = 30
        wps = self.create_simple_relhome_mission([
            (mavutil.mavlink.MAV_CMD_NAV_TAKEOFF, 0, 0, alt),
            (mavutil.mavlink.MAV_CMD_NAV_WAYPOINT, 400, 0, alt),
            self.create_MISSION_ITEM_INT(
                mavutil.mavlink.MAV_CMD_DO_INVERTED_FLIGHT,
                p1=1,
            ),
            (mavutil.mavlink.MAV_CMD_NAV_WAYPOINT, 800, 0, alt),
            self.create_MISSION_ITEM_INT(
                mavutil.mavlink.MAV_CMD_DO_INVERTED_FLIGHT,
                p1=0,
            ),
            (mavutil.mavlink.MAV_CMD_NAV_WAYPOINT, 1200, 0, alt),
            (mavutil.mavlink.MAV_CMD_NAV_RETURN_TO_LAUNCH, 0, 0, 0),
        ])
        self.check_mission_upload_download(wps)

        self.change_mode('AUTO')
        self.wait_ready_to_arm()

        self.arm_vehicle()

        self.wait_current_waypoint(2)  # upright flight
        self.wait_message_field_values("NAV_CONTROLLER_OUTPUT", {
            "nav_roll": 0,
            "nav_pitch": 0,
        }, epsilon=10)

        def check_altitude(mav, m):
            global initial_airspeed_threshold_reached
            m_type = m.get_type()
            if m_type != 'GLOBAL_POSITION_INT':
                return
            if abs(30 - m.relative_alt * 0.001) > 15:
                raise NotAchievedException("Bad altitude while flying inverted")

        self.context_push()
        self.install_message_hook_context(check_altitude)

        self.wait_current_waypoint(4)  # inverted flight
        self.wait_message_field_values("NAV_CONTROLLER_OUTPUT", {
            "nav_roll": 180,
            "nav_pitch": 9,
        }, epsilon=10,)

        self.wait_current_waypoint(6)  # upright flight
        self.wait_message_field_values("NAV_CONTROLLER_OUTPUT", {
            "nav_roll": 0,
            "nav_pitch": 0,
        }, epsilon=10)

        self.context_pop()  # remove the check_altitude call

        self.wait_current_waypoint(7)

        self.fly_home_land_and_disarm()

    def MAV_CMD_DO_AUTOTUNE_ENABLE(self):
        '''test enabling autotune via mavlink'''
        self.context_collect('STATUSTEXT')
        self.run_cmd(mavutil.mavlink.MAV_CMD_DO_AUTOTUNE_ENABLE, p1=1)
        self.wait_statustext('Started autotune', check_context=True)
        self.run_cmd_int(mavutil.mavlink.MAV_CMD_DO_AUTOTUNE_ENABLE, p1=0)
        self.wait_statustext('Stopped autotune', check_context=True)

    def DO_PARACHUTE(self):
        '''test triggering parachute via mavlink'''
        self.set_parameters({
            "CHUTE_ENABLED": 1,
            "CHUTE_TYPE": 10,
            "SERVO9_FUNCTION": 27,
            "SIM_PARA_ENABLE": 1,
            "SIM_PARA_PIN": 9,
            "FS_LONG_ACTN": 3,
        })
        for command in self.run_cmd, self.run_cmd_int:
            self.wait_servo_channel_value(9, 1100)
            self.wait_ready_to_arm()
            self.arm_vehicle()
            command(
                mavutil.mavlink.MAV_CMD_DO_PARACHUTE,
                p1=mavutil.mavlink.PARACHUTE_RELEASE,
            )
            self.wait_servo_channel_value(9, 1300)
            self.disarm_vehicle()
            self.reboot_sitl()

    def _MAV_CMD_DO_GO_AROUND(self, command):
        self.load_mission("mission.txt")
        self.set_parameter("RTL_AUTOLAND", 3)
        self.change_mode('AUTO')
        self.wait_ready_to_arm()
        self.arm_vehicle()
        self.wait_current_waypoint(6)
        command(mavutil.mavlink.MAV_CMD_DO_GO_AROUND, p1=150)
        self.wait_current_waypoint(5)
        self.wait_altitude(135, 165, relative=True)
        self.wait_disarmed(timeout=300)

    def MAV_CMD_DO_GO_AROUND(self):
        '''test MAV_CMD_DO_GO_AROUND as a mavlink command'''
        self._MAV_CMD_DO_GO_AROUND(self.run_cmd)
        self._MAV_CMD_DO_GO_AROUND(self.run_cmd_int)

    def _MAV_CMD_DO_FLIGHTTERMINATION(self, command):
        self.set_parameters({
            "AFS_ENABLE": 1,
            "SYSID_MYGCS": self.mav.source_system,
            "AFS_TERM_ACTION": 42,
        })
        self.wait_ready_to_arm()
        self.arm_vehicle()
        self.context_collect('STATUSTEXT')
        command(mavutil.mavlink.MAV_CMD_DO_FLIGHTTERMINATION, p1=1)
        self.wait_disarmed()
        self.wait_text('Terminating due to GCS request', check_context=True)
        self.reboot_sitl()

    def MAV_CMD_DO_FLIGHTTERMINATION(self):
        '''test MAV_CMD_DO_FLIGHTTERMINATION works on Plane'''
        self._MAV_CMD_DO_FLIGHTTERMINATION(self.run_cmd)
        self._MAV_CMD_DO_FLIGHTTERMINATION(self.run_cmd_int)

    def MAV_CMD_DO_LAND_START(self):
        '''test MAV_CMD_DO_LAND_START as mavlink command'''
        self.set_parameters({
            "RTL_AUTOLAND": 3,
        })
        self.upload_simple_relhome_mission([
            (mavutil.mavlink.MAV_CMD_NAV_TAKEOFF, 0, 0, 30),
            (mavutil.mavlink.MAV_CMD_NAV_LOITER_UNLIM, 0, 0, 30),
            self.create_MISSION_ITEM_INT(
                mavutil.mavlink.MAV_CMD_DO_LAND_START,
            ),
            (mavutil.mavlink.MAV_CMD_NAV_WAYPOINT, 800, 0, 0),
        ])

        self.change_mode('AUTO')
        self.wait_ready_to_arm()

        self.arm_vehicle()

        self.start_subtest("DO_LAND_START as COMMAND_LONG")
        self.wait_current_waypoint(2)
        self.run_cmd(mavutil.mavlink.MAV_CMD_DO_LAND_START)
        self.wait_current_waypoint(4)

        self.start_subtest("DO_LAND_START as COMMAND_INT")
        self.set_current_waypoint(2)
        self.run_cmd_int(mavutil.mavlink.MAV_CMD_DO_LAND_START)
        self.wait_current_waypoint(4)

        self.fly_home_land_and_disarm()

    def MAV_CMD_NAV_ALTITUDE_WAIT(self):
        '''test MAV_CMD_NAV_ALTITUDE_WAIT mission item, wiggling only'''

        # Load a single waypoint
        self.upload_simple_relhome_mission([
            self.create_MISSION_ITEM_INT(
                mavutil.mavlink.MAV_CMD_NAV_ALTITUDE_WAIT,
                p1=1000, # 1000m alt threshold, this should not trigger
                p2=10, # 10m/s descent rate, this should not trigger
                p3=10 # servo wiggle every 10 seconds
            )
        ])

        def look_for_wiggle(mav, m):
            if m.get_type() == 'SERVO_OUTPUT_RAW':
                # Throttle must be zero
                if m.servo3_raw != 1000:
                    raise NotAchievedException(
                        "Throttle must be 0 in altitude wait, got %f" % m.servo3_raw)
                # Aileron, elevator and rudder must all be the same
                # However, aileron is revered, so we must un-reverse it
                value = 1500 - (m.servo1_raw - 1500)
                if (m.servo2_raw != value) or (m.servo4_raw != value):
                    raise NotAchievedException(
                        "Aileron, elevator and rudder must be the same")

        # Start mission
        self.change_mode('AUTO')
        self.wait_ready_to_arm()
        self.arm_vehicle()

        # Check outputs
        self.context_push()
        self.install_message_hook_context(look_for_wiggle)

        # Wait for a bit to let message hook sample
        self.delay_sim_time(60)

        self.context_pop()

        # If the mission item completes as there is no other waypoints we will end up in RTL
        if not self.mode_is('AUTO'):
            raise NotAchievedException("Must still be in AUTO")

        self.disarm_vehicle()

    def start_flying_simple_rehome_mission(self, items):
        '''uploads items, changes mode to auto, waits ready to arm and arms
        vehicle.  If the first item it a takeoff you can expect the
        vehicle to fly after this method returns
        '''

        self.upload_simple_relhome_mission(items)

        self.change_mode('AUTO')
        self.wait_ready_to_arm()

        self.arm_vehicle()

    def InteractTest(self):
        '''just takeoff'''

        if self.mavproxy is None:
            raise NotAchievedException("Must be started with --map")

        self.start_flying_simple_rehome_mission([
            (mavutil.mavlink.MAV_CMD_NAV_TAKEOFF, 0, 0, 30),
            (mavutil.mavlink.MAV_CMD_NAV_WAYPOINT, 800, 0, 0),
            (mavutil.mavlink.MAV_CMD_NAV_WAYPOINT, 800, 800, 0),
            (mavutil.mavlink.MAV_CMD_NAV_WAYPOINT, 0, 400, 0),
        ])

        self.wait_current_waypoint(4)

        self.set_parameter('SIM_SPEEDUP', 1)

        self.mavproxy.interact()

    def MAV_CMD_MISSION_START(self):
        '''test MAV_CMD_MISSION_START starts AUTO'''
        self.upload_simple_relhome_mission([
            (mavutil.mavlink.MAV_CMD_NAV_WAYPOINT, 800, 0, 0),
        ])
        for run_cmd in self.run_cmd, self.run_cmd_int:
            self.change_mode('LOITER')
            run_cmd(mavutil.mavlink.MAV_CMD_MISSION_START)
            self.wait_mode('AUTO')

    def MAV_CMD_NAV_LOITER_UNLIM(self):
        '''test receiving MAV_CMD_NAV_LOITER_UNLIM from GCS'''
        self.takeoff(10)
        self.run_cmd(mavutil.mavlink.MAV_CMD_NAV_LOITER_UNLIM)
        self.wait_mode('LOITER')
        self.change_mode('GUIDED')
        self.run_cmd_int(mavutil.mavlink.MAV_CMD_NAV_LOITER_UNLIM)
        self.wait_mode('LOITER')
        self.fly_home_land_and_disarm()

    def MAV_CMD_NAV_RETURN_TO_LAUNCH(self):
        '''test receiving MAV_CMD_NAV_RETURN_TO_LAUNCH from GCS'''
        self.set_parameter('RTL_AUTOLAND', 1)
        self.start_flying_simple_rehome_mission([
            (mavutil.mavlink.MAV_CMD_NAV_TAKEOFF, 0, 0, 30),
            (mavutil.mavlink.MAV_CMD_NAV_LOITER_UNLIM, 0, 0, 30),
            self.create_MISSION_ITEM_INT(
                mavutil.mavlink.MAV_CMD_DO_LAND_START,
            ),
            (mavutil.mavlink.MAV_CMD_NAV_WAYPOINT, 800, 0, 0),
        ])

        for i in self.run_cmd, self.run_cmd_int:
            self.wait_current_waypoint(2)
            self.run_cmd(mavutil.mavlink.MAV_CMD_NAV_RETURN_TO_LAUNCH)
            self.wait_current_waypoint(4)
            self.set_current_waypoint(2)
        self.fly_home_land_and_disarm()

    def location_from_ADSB_VEHICLE(self, m):
        '''return a mavutil.location extracted from an ADSB_VEHICLE mavlink
        message'''
        if m.altitude_type != mavutil.mavlink.ADSB_ALTITUDE_TYPE_GEOMETRIC:
            raise ValueError("Expected geometric alt")
        return mavutil.location(
            m.lat*1e-7,
            m.lon*1e-7,
            m.altitude/1000.0585,  # mm -> m
            m.heading * 0.01  # centidegrees -> degrees
        )

    def SagetechMXS(self):
        '''test Sagetech MXS ADSB device driver'''
        sim_name = "sagetech_mxs"
        self.set_parameters({
            "SERIAL5_PROTOCOL": 35,
            "ADSB_TYPE": 4,  # Sagetech-MXS
            "SIM_ADSB_TYPES": 8,  # Sagetech-MXS
            "SIM_ADSB_COUNT": 5,
        })
        self.customise_SITL_commandline(["--serial5=sim:%s" % sim_name])
        m = self.assert_receive_message("ADSB_VEHICLE")
        adsb_vehicle_loc = self.location_from_ADSB_VEHICLE(m)
        self.progress("ADSB Vehicle at loc %s" % str(adsb_vehicle_loc))
        home = self.home_position_as_mav_location()
        self.assert_distance(home, adsb_vehicle_loc, 0, 10000)

    def MinThrottle(self):
        '''Make sure min throttle does not apply in manual mode and does in FBWA'''

        servo_min = self.get_parameter("RC3_MIN")
        servo_max = self.get_parameter("RC3_MAX")
        min_throttle = 10
        servo_min_throttle = servo_min + (servo_max - servo_min) * (min_throttle / 100)

        # Set min throttle
        self.set_parameter('THR_MIN', min_throttle)

        # Should be 0 throttle while disarmed
        self.change_mode("MANUAL")
        self.drain_mav() # make sure we have the latest data before checking throttle output
        self.assert_servo_channel_value(3, servo_min)

        # Arm and check throttle is still 0 in manual
        self.wait_ready_to_arm()
        self.arm_vehicle()
        self.drain_mav()
        self.assert_servo_channel_value(3, servo_min)

        # FBWA should apply throttle min
        self.change_mode("FBWA")
        self.drain_mav()
        self.assert_servo_channel_value(3, servo_min_throttle)

        # But not when disarmed
        self.disarm_vehicle()
        self.drain_mav()
        self.assert_servo_channel_value(3, servo_min)

    def ClimbThrottleSaturation(self):
        '''check what happens when throttle is saturated in GUIDED'''
        self.set_parameters({
            "TECS_CLMB_MAX": 30,
            "TKOFF_ALT": 1000,
        })

        self.change_mode("TAKEOFF")
        self.wait_ready_to_arm()
        self.arm_vehicle()
        self.wait_message_field_values('VFR_HUD', {
            "throttle": 100,
        }, minimum_duration=30, timeout=90)
        self.disarm_vehicle(force=True)
        self.reboot_sitl()

    def GuidedAttitudeNoGPS(self):
        '''test that guided-attitude still works with no GPS'''
        self.takeoff(50)
        self.change_mode('GUIDED')
        self.context_push()
        self.set_parameter('SIM_GPS_DISABLE', 1)
        self.delay_sim_time(30)
        self.set_attitude_target()
        self.context_pop()
        self.fly_home_land_and_disarm()

    def ScriptStats(self):
        '''test script stats logging'''
        self.context_push()
        self.set_parameters({
            'SCR_ENABLE': 1,
            'SCR_DEBUG_OPTS': 8,  # runtime memory usage and time
        })
        self.install_test_scripts_context([
            "math.lua",
            "strings.lua",
        ])
        self.install_example_script_context('simple_loop.lua')
        self.context_collect('STATUSTEXT')

        self.reboot_sitl()

        self.wait_statustext('hello, world')
        delay = 20
        self.delay_sim_time(delay, reason='gather some stats')
        self.wait_statustext("math.lua exceeded time limit", check_context=True, timeout=0)

        dfreader = self.dfreader_for_current_onboard_log()
        seen_hello_world = False
#        runtime = None
        while True:
            m = dfreader.recv_match(type=['SCR'])
            if m is None:
                break
            if m.Name == "simple_loop.lua":
                seen_hello_world = True
#            if m.Name == "math.lua":
#                runtime = m.Runtime

        if not seen_hello_world:
            raise NotAchievedException("Did not see simple_loop.lua script")

#        self.progress(f"math took {runtime} seconds to run over {delay} seconds")
#        if runtime == 0:
#            raise NotAchievedException("Expected non-zero runtime for math")

        self.context_pop()
        self.reboot_sitl()

    def GPSPreArms(self):
        '''ensure GPS prearm checks work'''
        self.wait_ready_to_arm()
        self.start_subtest('DroneCAN sanity checks')
        self.set_parameter('GPS1_TYPE', 9)
        self.set_parameter('GPS2_TYPE', 9)
        self.set_parameter('GPS1_CAN_OVRIDE', 130)
        self.set_parameter('GPS2_CAN_OVRIDE', 130)
        self.assert_prearm_failure(
            "set for multiple GPS",
            other_prearm_failures_fatal=False,
        )

    def SetHomeAltChange(self):
        '''check modes retain altitude when home alt changed'''
        for mode in 'FBWB', 'CRUISE', 'LOITER':
            self.wait_ready_to_arm()
            home = self.home_position_as_mav_location()
            self.takeoff(20)
            higher_home = home
            higher_home.alt += 40
            self.set_home(higher_home)
            self.wait_altitude(15, 25, relative=True, minimum_duration=10)
            self.disarm_vehicle(force=True)
            self.reboot_sitl()

    def ForceArm(self):
        '''check force-arming functionality'''
        self.set_parameter("SIM_GPS_DISABLE", 1)
        # 21196 is the mavlink standard, 2989 is legacy
        for magic_value in 21196, 2989:
            self.wait_sensor_state(mavutil.mavlink.MAV_SYS_STATUS_PREARM_CHECK,
                                   present=True,
                                   enabled=True,
                                   healthy=False,
                                   )
            self.run_cmd(
                mavutil.mavlink.MAV_CMD_COMPONENT_ARM_DISARM,
                p1=1,  # ARM
                p2=0,
                want_result=mavutil.mavlink.MAV_RESULT_FAILED,
            )
            self.run_cmd(
                mavutil.mavlink.MAV_CMD_COMPONENT_ARM_DISARM,
                p1=1,  # ARM
                p2=magic_value,
                want_result=mavutil.mavlink.MAV_RESULT_ACCEPTED,
            )
            self.disarm_vehicle()

    def tests(self):
        '''return list of all tests'''
        ret = super(AutoTestPlane, self).tests()
        ret.extend([
            self.AuxModeSwitch,
            self.TestRCCamera,
            self.TestRCRelay,
            self.ThrottleFailsafe,
            self.NeedEKFToArm,
            self.ThrottleFailsafeFence,
            self.TestFlaps,
            self.DO_CHANGE_SPEED,
            self.DO_REPOSITION,
            self.GuidedRequest,
            self.MainFlight,
            self.TestGripperMission,
            self.Parachute,
            self.ParachuteSinkRate,
            self.DO_PARACHUTE,
            self.PitotBlockage,
            self.AIRSPEED_AUTOCAL,
            self.RangeFinder,
            self.FenceStatic,
            self.FenceRTL,
            self.FenceRTLRally,
            self.FenceRetRally,
            self.FenceAltCeilFloor,
            self.FenceMinAltAutoEnable,
            self.FenceMinAltEnableAutoland,
            self.FenceMinAltAutoEnableAbort,
            self.FenceAutoEnableDisableSwitch,
            Test(self.FenceCircleExclusionAutoEnable, speedup=20),
            self.FenceEnableDisableSwitch,
            self.FenceEnableDisableAux,
            self.FenceBreachedChangeMode,
            self.FenceNoFenceReturnPoint,
            self.FenceNoFenceReturnPointInclusion,
            self.FenceDisableUnderAction,
            self.ADSBFailActionRTL,
            self.ADSBResumeActionResumeLoiter,
            self.SimADSB,
            self.Button,
            self.FRSkySPort,
            self.FRSkyPassThroughStatustext,
            self.FRSkyPassThroughSensorIDs,
            self.FRSkyMAVlite,
            self.FRSkyD,
            self.LTM,
            self.DEVO,
            self.AdvancedFailsafe,
            self.LOITER,
            self.MAV_CMD_NAV_LOITER_TURNS,
            self.DeepStall,
            self.WatchdogHome,
            self.LargeMissions,
            self.Soaring,
            self.Terrain,
            self.TerrainMission,
            self.TerrainLoiter,
            self.VectorNavEAHRS,
            self.MicroStrainEAHRS5,
            self.MicroStrainEAHRS7,
            self.InertialLabsEAHRS,
            self.GpsSensorPreArmEAHRS,
            self.Deadreckoning,
            self.DeadreckoningNoAirSpeed,
            self.EKFlaneswitch,
            self.AirspeedDrivers,
            self.RTL_CLIMB_MIN,
            self.ClimbBeforeTurn,
            self.IMUTempCal,
            self.MAV_CMD_DO_AUX_FUNCTION,
            self.SmartBattery,
            self.FlyEachFrame,
            self.RCDisableAirspeedUse,
            self.AHRS_ORIENTATION,
            self.AHRSTrim,
            self.LandingDrift,
            self.TakeoffAuto1,
            self.TakeoffAuto2,
            self.TakeoffAuto3,
            self.TakeoffAuto4,
            self.TakeoffTakeoff1,
            self.TakeoffTakeoff2,
            self.TakeoffTakeoff3,
            self.TakeoffTakeoff4,
            self.ForcedDCM,
            self.DCMFallback,
            self.MAVFTP,
            self.AUTOTUNE,
            self.AutotuneFiltering,
            self.MegaSquirt,
            self.Hirth,
            self.MSP_DJI,
            self.SpeedToFly,
            self.GlideSlopeThresh,
            self.HIGH_LATENCY2,
            self.MidAirDisarmDisallowed,
            self.AerobaticsScripting,
            self.MANUAL_CONTROL,
            self.RunMissionScript,
            self.WindEstimates,
            self.AltResetBadGPS,
            self.AirspeedCal,
            self.MissionJumpTags,
            Test(self.GCSFailsafe, speedup=8),
            self.SDCardWPTest,
            self.NoArmWithoutMissionItems,
            self.MODE_SWITCH_RESET,
            self.ExternalPositionEstimate,
            self.SagetechMXS,
            self.MAV_CMD_GUIDED_CHANGE_ALTITUDE,
            self.MAV_CMD_PREFLIGHT_CALIBRATION,
            self.MAV_CMD_DO_INVERTED_FLIGHT,
            self.MAV_CMD_DO_AUTOTUNE_ENABLE,
            self.MAV_CMD_DO_GO_AROUND,
            self.MAV_CMD_DO_FLIGHTTERMINATION,
            self.MAV_CMD_DO_LAND_START,
            self.MAV_CMD_NAV_ALTITUDE_WAIT,
            self.InteractTest,
            self.MAV_CMD_MISSION_START,
            self.TerrainRally,
            self.MAV_CMD_NAV_LOITER_UNLIM,
            self.MAV_CMD_NAV_RETURN_TO_LAUNCH,
            self.MinThrottle,
            self.ClimbThrottleSaturation,
            self.GuidedAttitudeNoGPS,
            self.ScriptStats,
            self.GPSPreArms,
            self.SetHomeAltChange,
            self.ForceArm,
        ])
        return ret

    def disabled_tests(self):
        return {
            "LandingDrift": "Flapping test. See https://github.com/ArduPilot/ardupilot/issues/20054",
            "InteractTest": "requires user interaction",
            "ClimbThrottleSaturation": "requires https://github.com/ArduPilot/ardupilot/pull/27106 to pass",
            "SetHomeAltChange": "https://github.com/ArduPilot/ardupilot/issues/5672",
        }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     