#!/usr/bin/env bash

# Advanced geotagging tool by André Kjellstrup
######################################################################  VARIABLES ########################

version="v1.1"
mode=1 # 0=geotag, 1=jpg distance(s) , 2=CAM distance in sec
loglinenum=1 # last read log line number
loglinenummatched=0 # last read log line number used - reverting to this +1 when looking back
logline="start" #current line, placeholder for start
logtimemsprev=0
logended=0 #true if log ended.
logtarget=0 #true if we got log type we wanted
logmatch=1 # true if we accepted lo line as matching
loggotpos=0 #true if log contains pos messages (enables fallback)
typical_offset="notset" #contains time offset of first picture vs log. 
jpgtot=0  #number of jpg files in folder
jpgtagged=0 #number of correctly tagged photos
jpgmiss=0 #number of missing photos
jpgnotinlog=0 #counting jpg's with timestamp outside log
camindex=0 #number of last CAM message used.
camtot=0  #number of CAM lines found
trigtot=0 #number of TRIG lines found
logmiss=0 #missed CAM messages
revjumps=0 #count how many time we have backed up
difflimit=10 # POS message difflimit 10 gives 0.06sec , 20 has proved useful 
running=1
cmdarg=$* #save command line parameters
FILE=jpglist
ML="false"
logsdone=0 #counts processed logs
SKIPIMG=0



###########################

while [[ $# > 0 ]]
do
key="$1"

case $key in
    -w|--write)
    WRITE="true"
    ;;
    -r|--readonly)
    WRITE="false"
    ;;
    -f|--find)
    WRITE="false"
    FIND="true"
    ;;
    -p|--pos)
    MODE="POS"
    typical_offset="$2"   
    shift # get past argument
    ;; 
    -dl|--difflimit)
    difflimit="$2"
    shift # get past argument
    ;;
    -c|--cam)
    MODE="CAM"
    ;;      
    -t|--trig)
    MODE="TRIG"
    ;;
    -ns|--nosubsec)
    NS="true"
    ;;
    -ml|--multilog)
    ML="true"
    ;;
    -del|--delorg)
    DELORG="true"
    ;;   
    -sp|--skipphoto)
    SKIPIMG="$2"
    shift # get past argument
    ;;
    -sc|--skipcam)
    SKIPCAM="$2"
    shift # get past argument
    ;;
    -st|--skiptrig)
    SKIPTRIG="$2"
    shift # get past argument
    ;;
    -sl|--skiplog)
    SKIPLOG="$2"
    shift # get past argument
    ;;

    -h|--help)
    HELP="true"
    ;;
    *)
	# unknown option
    ;;
esac
shift # past argument or value
done

#echo FILE EXTENSION  = "${EXTENSION}"
#echo SEARCH PATH     = "${SEARCHPATH}"
#echo LIBRARY PATH    = "${LIBPATH}"

if [[ "$HELP" == "true" ]] || [[ "$WRITE" == "" ]] #|| [[ "$MODE" == "" ]] 
then
echo "Geotagging script by André Kjellstrup.  $version"
echo "execute inside a folder containing .JPG and .BIN"
echo "example: geotag.sh -c -sp 2 -r"
echo ""
echo "-w or --write Enables photo processing"
echo "-r or --readonly Enables photo processing"
echo "-f or --readonly, finds CAM to exif spacing for +/- 10 skipped photos, and +/- 10 skipped CAM messages"
echo "-sp x or --skipphoto x Skips x photos counting from the start"
echo "-sc x or --skipcam x Skips x CAM entrys from the start"
echo "-sl x or --skiplog x Skips x POS entrys from the start"
echo "-st x or --skiptrig x Skips x TRIG entrys from the start"
echo "-p x or --pos x Use POS log only (if camera was independendly trigged) x=offset in seconds"
echo "-dl x or --difflimit x Acceptable limit in 10ms steps for POS-log vs photo differance 10=0.1s (default)"
echo "-c or --cam Use CAM log only (do not fall back to POS pessages)"
echo "-t or --trig Use TRIG log only (if camera shutter is sensed)"
echo "-ns or --nosubsec Do not look for subsecond EXIF tag."
echo "-ml or --multilog Grab and combine all .BIN files (for processing photos from more then one flight."
echo "-del or --delorg : Delete JPG_original (backups)."
echo "EXAMPLE:"
echo "Multiple flights dataset from S100; geotag.sh -p 0 -ns -dl 30 -w -ml -del"
echo "simgle CAM flight; geotag.sh -c -w -del"
exit 1
fi

##ADD DEPENDENCIES HERE
command -v mavlogdump.py >/dev/null 2>&1 || { echo >&2 "I require mavlogdump.py but it's not installed.  Aborting."; exit 1; }
command -v exiftool >/dev/null 2>&1 || { echo >&2 "I require exiftool but it's not installed.  Aborting."; exit 1; }
##command -v foo >/dev/null 2>&1 || { echo >&2 "I require foo but it's not installed.  Aborting."; exit 1; }

if [[ "$WRITE" == "true" ]]
then
echo "INFO: will backup and modify photos" | tee geotag.log
fi

if [[ "$WRITE" == "false" ]]
then
echo "INFO: dry run only, no photos will be modified" | tee geotag.log
fi

if [[ "$MODE" == "POS" ]]
then
echo "INFO: use POS records only, expected offset of $typical_offset , poslimit (time of photo vs log is $poslimit)"   | tee geotag.log
fi

if [[ "$MODE" == "CAM" ]]
then
echo "INFO: use CAM records only" | tee geotag.log
fi


if [[ "$MODE" == "TRIG" ]]
then
echo "INFO: use TRIG records only" | tee geotag.log
fi

if [[ "$NS" == "true" ]]
then
echo "INFO: Do not look for subsecond-time in EXIF" | tee geotag.log
fi


if [[ "$SKIPIMG" -gt "0" ]]
then
echo "INFO: will skip first $SKIPIMG photos" | tee geotag.log
fi

if [[ "$SKIPCAM" -gt "0" ]]
then
echo "INFO: will skip first $SKIPCAM CAM logs" | tee geotag.log
fi

if [[ "$SKIPTRIG" -gt "0" ]]
then
echo "INFO: will skip first $SKIPTRIG TRIG logs" | tee geotag.log
fi


if [[ "$SKIPLOG" -gt "0" ]]
then
echo "INFO: will skip first $SKIPLOG POS logs" | tee geotag.log
loglinenum=$SKIPLOG
fi

if [ "$difflimit" != 10 ]
then
echo "INFO: Difflimit is changed to $difflimit (10=0.1s)" | tee geotag.log
fi


echo "INFO: using arguments $cmdarg " | tee geotag.log

jpglistindex=$(( 1 + $SKIPIMG)) #which file to read from jpg list


#=========================  FUNCTION readexif ======================================================
# get exif data for filename in $jpgname,
# return: $jpgdate 20-12-2010 ,$jpgtime 14:10:20.22 ,$jpgtimems 0.22 (220ms)
function readexif   
{
	if [[ "$NS" == "true" ]]
	then
	  jpgdatetime=$(exiftool -ee -p '$datetimeoriginal' "$jpgname" -n)
	  jpgdatetime="$jpgdatetime.50"
	else
	  jpgdatetime=$(exiftool -ee -p '$subsecdatetimeoriginal' "$jpgname" -n)
	fi


  jpgdate=$(echo -n "$jpgdatetime" | head -c10)
  jpgdate=$(echo "$jpgdate" | tr : -)   #replace : with -
  jpgtime=$(echo -n "$jpgdatetime" | tail -c-11)
  jpgtimems=$(echo -n "$jpgtime" | tail -c-2)
  jpgtimems=$(echo "scale=2; ($jpgtimems /100)" | bc -l) 
#echo "DEBUG $jpgname date $jpgdate time $jpgtime " 
##read -p "Press any key to continue... " -n1 -s
######browse log until we find CAM message
}

#=========================  FUNCTION readlog ======================================================
# extract needed date from logline string $logline
# return: $logdate 20-12-2010 ,$logtime 14:10:20.22 ,$logtimems 0.22 (220ms)
# return: $lat $lon $alt(m AMSL) 
#
###### We Prefer TRIG , then CAM, then fallback to POS
# in log they look alike:
#1970-01-01 01:01:12.55: CAM {TimeUS : 72553489, GPSTime : 0, GPSWeek : 0, Lat : 0.0, Lng : 0.0, Alt : -0.01, RelAlt : -0.01, GPSAlt : 0.0, Roll : 1.4, Pitch : 0.41, Yaw : 82.49}
#1970-01-01 01:01:15.80: TRIG {TimeUS : 75803571, GPSTime : 0, GPSWeek : 0, Lat : 0.0, Lng : 0.0, Alt : -0.01, RelAlt : -0.01, GPSAlt : 0.0, Roll : 1.43, Pitch : 0.43, Yaw : 82.62}

function readlog
{
logdate=$(echo "$logline"| grep -o '^\S*')   #till first space
logtime=$(echo "$logline"| awk -F" " '{print $2}')
logtime=$(echo -n "$logtime" | head -c-1) #remove trailing :
logtimems=$(echo -n "$logtime" | tail -c-2) 
logtimems=$(echo "scale=2; ($logtimems /100)" | bc -l) 

if [[ "$logline" == *POS* ]] 
    then
    lat=$(echo "$logline"| grep -o -P '(?<=Lat : ).*(?=, Lng)')
    lon=$(echo "$logline"| grep -o -P '(?<=Lng : ).*(?=, Alt)')
    alt=$(echo "$logline"| grep -o -P '(?<= Alt : ).*(?=, RelHomeAlt)')
fi
 

if [[ "$logline" == *CAM* ]] 
    then 
    lat=$(echo "$logline"| grep -o -P '(?<=Lat : ).*(?=, Lng)')
    lon=$(echo "$logline"| grep -o -P '(?<=Lng : ).*(?=, Alt)')
    alt=$(echo "$logline"| grep -o -P '(?<=Alt : ).*(?=, RelAlt)')
    fi


#rol=$(echo "$logline"| grep -o -P '(?<=Roll : ).*(?=, Pitch)') 
#pit=$(echo "$logline"| grep -o -P '(?<=Pitch : ).*(?=, Yaw)') 
#yaw=$(echo "$logline"| grep -o -P '(?<=Yaw : ).*(?=})')  
#echo "$logdate $logtime  CAM=$cam Lat=$lat	Lng=$lng  Alt= $alt"

}

#=========================  FUNCTION geotag ======================================================
# converts to WGS84  and tags photos with data found in lat,lon,alt.
function geotag

{
#jpgname="test.JPG"
#lat=69.6041115
#lon=23.2757452
#alt=122.8374

posWGS84=( $(echo "$lon $lat $alt" | cs2cs +proj=latlong +datum=WGS84))   # returns position as 22d16'32.683"E 69d36'14.801"N 123.837 in {posWGS84[0...2]}
lonWGS84ref=$(echo -n "${posWGS84[0]}" | tail -c-1) 
lonWGS84pos=$(echo -n "${posWGS84[0]}" | head -c-1) 
latWGS84ref=$(echo -n "${posWGS84[1]}" | tail -c-1) 
latWGS84pos=$(echo -n "${posWGS84[1]}" | head -c-1) 

#echo $lonWGS84pos
#echo $lonWGS84ref
#echo $latWGS84pos
#echo $latWGS84ref
#echo "original:"
#echo ${posWGS84[0]}
#echo ${posWGS84[1]}
#echo ${posWGS84[2]}

if [[ "$WRITE" == "true" ]]
then
exiftool -exif:gpsmapdatum="WGS-84" -exif:gpsaltitude="$alt" -exif:gpsaltituderef="Above Sea Level" -exif:gpslongitude="$lonWGS84pos" -exif:gpslongituderef="$lonWGS84ref" -exif:gpslatitude="$latWGS84pos"  -exif:gpslatituderef="$latWGS84ref" "$jpgname"  >/dev/null &
fi 
let "jpgtagged++"
echo "ALT= "$alt" LON= "$lonWGS84pos" LATref= "$lonWGS84ref" LAT= "$latWGS84pos" LATref= "$latWGS84ref""
}


#=========================  FUNCTION report ======================================================
function report   
{
echo "Report:" | tee -a geotag.log
echo "Found $jpgtot photos" | tee -a geotag.log
echo "Found $camtot CAM log lines" | tee -a geotag.log
echo "Found $trigtot TRIG log lines" | tee -a geotag.log
echo "Time between first photo and log was ""$typical_offset""s" | tee -a geotag.log

if [[ "$WRITE" == "true" ]]
then
	echo "Tagged $jpgtagged photos" | tee -a geotag.log
else
	echo "Could have tagged $jpgtagged photos" | tee -a geotag.log
fi 

if [[ "$MODE" != "POS" ]]
then
	echo "Detected $jpgmiss missing photos" | tee -a geotag.log
	echo "Detected $logmiss missing $MODE messages" | tee -a geotag.log
else
	echo "(Unable to detect and report missing pictures and CAM messages in POS mode)" | tee -a geotag.log
fi
if [[ "$jpgnotinlog" -gt 0 ]]
then
	echo "FAILED: to tag $jpgnotinlog jpg file(s) where no POS log matched (maybe increase difflimit?)" | tee -a geotag.log
fi


if [[ "$DELORG" == "true" ]]
then
	echo "INFO: Deleting original .JPG that were cloned by EXIF" | tee -a geotag.log
    sleep 1s
	rm *.JPG_original
fi
	
if [[ "$WRITE" == "true" ]]
then
	mv geotag.log geotagwrite.log
fi

}


#=========================  FUNCTION load log to memory ======================================================
function loadlogdump
{
echo "INFO: Loading logdump into memory..." | tee -a geotag.log
OLDIFS=$IFS
IFS=$'\012'  # \012 is a linefeed
logarray=( $(<logdump) )
IFS=$OLDIFS
logarraysize=${#logarray[@]}
echo "INFO: done, loaded $logarraysize lines." | tee -a geotag.log
}

#=========================  FUNCTION load camdump to memory ======================================================
function loadcamdump
{
echo "INFO: Loading camdump into memory..." | tee -a geotag.log
OLDIFS=$IFS
IFS=$'\012'  # \012 is a linefeed
logarray=( $(<camdump) )
IFS=$OLDIFS
logarraysize=${#logarray[@]}
echo "INFO: done, loaded $logarraysize lines." | tee -a geotag.log
}


##############################################################################################################
##############################################################################################################
##############################################################################################################
##############################################################################################################
##############################################################################################################
##############################################################################################################
#=========================  FUNCTION CAM only loop ======================================================
function posloop
{
echo "INFO: Searching within POS log..." | tee -a geotag.log
loggotpos=0


###############get JPG file#########
while [[ "$running" == 1 ]]
do

	if [ "$logmatch" == 1 ]  
		then  #read next picture only if log line accepted 
		jpgname=$(awk 'NR=="'"$jpglistindex"'"{print;exit}' jpglist)

	if [ "$jpgname" == "" ] 
		then
		echo "END: Last photo processed" | tee -a geotag.log
		running=0
		report
		exit 1
	fi
	readexif
fi

###############lookup LOG#########
logtarget=0 #reset, for new search
if [[ "$loglinereverse" -eq 1 || "$camindex" -eq "$camtot" || "$MODE" == "POS" ]] 
then 
POSONLY="true"
else
POSONLY="false"
fi

while [ "$logtarget" -eq 0 ]
do
let "loglinenum++"

#### check if we are out of log messages.
if [[ "$loglinenum" -gt "$logarraysize" ]]
then
echo "ERROR: Log ended at $loglinenum of $logarraysize while looking for $MODE message for filename $jpgname , maybe this photo is not a part of dataset, or in log, ignoring." | tee -a geotag.log
	
	#read next picture only if log line accepted
	jpgname=$(awk 'NR=="'"$jpglistindex"'"{print;exit}' jpglist)
	let "loglinenum = loglinenummatched" # revert to last known good position in log - or to START, to mach photos in random order..
	let "jpglistindex++" #move on to next
		if [ "$jpgname" == "" ] 
		then
		echo "END: Last photo processed" | tee -a geotag.log
		running=0
		report
		exit 1
		fi
	readexif
fi

logline=${logarray["$loglinenum"]}


    if [[ "$logline" == *CAM* ]] 
    then 
        logtype="CAM"
        let "camindex++"
        logtarget=1
        readlog    
        #	echo "DEBUG: at $loglinenum $logline" 
    fi
    if [[ "$logline" == *POS* ]] && [[ "$POSONLY" == "true" || "$loglinereverse" -eq 1 ]]
    then
        loggotpos=1
        logtype="POS"
        logtarget=1
        readlog  
        #echo "DEBUG: at $loglinenum $logline"  
    fi 

if [[ "$SKIPCAM" -gt 0 ]] && [[ "$logtarget" -eq 1 ]] 
    then
    let "SKIPCAM--"
    logtarget=0
fi



done

#### check if we are out of suitable log messages.
if [[ "$loglinenum" -gt "$logarraysize" ]]
then
echo "ERROR: Log ended at $loglinenum of $logarraysize while looking for CAM message for filename $jpgname maybe there are too many photos" | tee -a geotag.log
running=0
report
exit 1
fi

#echo "DEBUG relevant logline found loglinenumber=$loglinenum  logline=$logline "
######process log line 

######## Calculate offset
diff=$(( ( $(date -ud "$jpgdate $jpgtime" +'%s') - $(date -ud "$logdate $logtime" +'%s') ) )) #get differance in seconds (integer)
difftot=$(echo "scale=2; ($diff+($jpgtimems - $logtimems))" | bc -l) # return floting point
######## Calculate time since last trigger command
differr=$(( ( $(date -ud "$logdate $logtime" +'%s') - $(date -ud "$logdateprev $logtimeprev" +'%s') ) )) #get differance in seconds (integer)
difftoterr=$(echo "scale=2; ($differr+($logtimems - $logtimemsprev))" | bc -l) # return floting point
difftotoff=$(echo "scale=2; ($difftot - $typical_offset)" | bc -l) 
difftoterroff=$(echo "scale=2; ($differr - $typical_offset)" | bc -l) # return floting point 
 if [ "$typical_offset" == "notset" ]
 then
	 typical_offset=$difftot
     echo "INFO: Expected time offset between camera and log is ""$typical_offset""s (positive = camera is ahead)" | tee -a geotag.log
 fi
 

 
###############compare offset to previous offset to detect skipped photos
   
   diffeee=$(echo "(($difftot - $typical_offset)*100)" | bc -l | cut -f1 -d"." ) #keep integer
    if [[ "$diffeee" -gt "$difflimit" ]] || [[ "$diffeee" -lt -"$difflimit" ]]
		
		then    
		    if [[ "$MODE" == "POS" ]]  #Do fail analysis ONLY in CAM mode
            then  ##Speed up POS mode
			logmatch=0
                if [[ "$diffeee" -gt 50 ]]   # are we more than 1 sec behind ?
                then
                let "loglinenum=loglinenum+25"
                #echo "DEBUG: > 1 sec behind, jumping ahead"
                fi
                if [[ "$diffeee" -lt -25 ]]   # are we more than 0.5 sec ahead ?
                then
                let "loglinenum=loglinenum-30"
                let "revjumps++"
                #echo "DEBUG: > 0.5 sec ahead, jumping back"
                
					if [[ "$revjumps" -gt 30 ]]  ## we have backed up too many times, the image must be invalid for this log !
					then
					echo "ERROR: Failed to find log time for image $jpgname, it's not in log or does not belong to this dataset.( maybe try higher difflimit ?)" | tee -a geotag.log
					let "jpgnotinlog++"
					let "jpglistindex++" #move on to next
					let "revjumps=0"
					logmatch=1 #trigger lookup of next picture
								
					fi
				fi
                    
              ##do CAM mode analysis
                
            fi
            #logmatch=1 ###############################################################ACCEPT ANYTHING
            #let "jpglistindex=jpglistindex+1"  ###############################################################ACCEPT ANYTHING

		else  ## PHOTO AND LOG MATCHING
            
            percent=$(echo "scale=2; (($jpglistindex/$jpgtot)*100)" | bc -l | cut -f1 -d".") 
			echo "MATCHED: ""$percent""% Done, time diff.: ""$difftotoff""s between $jpgname $jpgdate $jpgtime & $logtype log $loglinenum $logdate $logtime"  | tee -a geotag.log
			let "revjumps=0"
            geotag
            logmatch=1
            #logmatcgfailinrow=0
            let "jpglistindex++"
            let "loglinenummatched = loglinenum + 1"  # if we need to go back for POS message, go here
            #loglinereverse=0
    fi    #save first image camera vs log offset

logdateprev=$logdate  #for calculation of picture spacing
logtimeprev=$logtime  #for calculation of picture spacing
logtimemsprev=$logtimems #for calculation of picture spacing
logtarget=0 #reset so we are looking for next logline next time

done  #running
}

##### END POS loop ###########################################################################################
##############################################################################################################
##############################################################################################################
##############################################################################################################
##############################################################################################################
##############################################################################################################

##############################################################################################################
##############################################################################################################
##############################################################################################################
##############################################################################################################
##############################################################################################################
##############################################################################################################
#=========================  FUNCTION CAM only loop ======================================================
# In case of missing photo: try next log entry
# in case of missing log entry:  do not tag photo
function camloop
{
echo "INFO: Searching for CAM only..." | tee -a geotag.log
loggotpos=0


###############get JPG file#########
while [[ "$running" == 1 ]] ; do
	if [ "$logmatch" == 1 ]  
		then  #read next picture only if log line accepted
		jpgname=$(awk 'NR=="'"$jpglistindex"'"{print;exit}' jpglist)
		if [ "$jpgname" == "" ] ; then
			echo "END: Last photo processed" | tee -a geotag.log
			running=0
			report
			exit 1
		fi
	readexif
	fi

###############lookup LOG#########
logtarget=0 #reset, for new search

while [ "$logtarget" -eq 0 ] ; do
let "loglinenum++"
logline=${logarray["$loglinenum"]}

    if [[ "$logline" == *"$MODE"* ]] ; then
		logtype="$MODE"
        logtarget=1
        readlog    
        #echo "DEBUG: at $loglinenum $logline" 
    fi

#skip CAM lines if needded
if [[ "$MODE" == "CAM"  && "$SKIPCAM" -gt 0 ]] && [[ "$logtarget" -eq 1 ]] ; then
    let "SKIPCAM--"
    echo "INFO: Skipped a CAM log line." | tee -a geotag.log
    logtarget=0
fi

#skip TRIG lines if needded
if [[ "$MODE" == "TRIG"  && "$SKIPTRIG" -gt 0 ]] && [[ "$logtarget" -eq 1 ]] ; then
    let "SKIPTRIG--"
    logtarget=0
fi

done

#### check if we are out of suitable log messages.
if [[ "$loglinenum" -gt "$logarraysize" ]] ; then
	echo "ERROR: Log ended at $loglinenum of $logarraysize while looking for $MODE message for filename $jpgname maybe there are too many photos" | tee -a geotag.log
	running=0
	report
	exit 1
fi

######## Calculate offset
diff=$(( ( $(date -ud "$jpgdate $jpgtime" +'%s') - $(date -ud "$logdate $logtime" +'%s') ) )) #get differance in seconds (integer)
difftot=$(echo "scale=2; ($diff+($jpgtimems - $logtimems))" | bc -l) # return floting point
######## Calculate time since last trigger command
differr=$(( ( $(date -ud "$logdate $logtime" +'%s') - $(date -ud "$logdateprev $logtimeprev" +'%s') ) )) #get differance in seconds (integer)
difftoterr=$(echo "scale=2; ($differr+($logtimems - $logtimemsprev))" | bc -l) # return floting point
difftotoff=$(echo "scale=2; ($difftot - $typical_offset)" | bc -l) 
difftoterroff=$(echo "scale=2; ($differr - $typical_offset)" | bc -l) # return floting point 
 if [ "$typical_offset" == "notset" ] ; then
	typical_offset=$difftot
    echo "INFO: Expected time offset between camera and log is ""$typical_offset""s (positive = camera is ahead)" | tee -a geotag.log
 fi
 
difflimit=100 # CAM difflimit 1sec variation between command and exif


###############compare offset to previous offset to detect skipped photos
    diffeee=$(echo "(($difftot - $typical_offset)*100)" | bc -l | cut -f1 -d"." ) #keep integer
    if [[ "$diffeee" -gt "$difflimit" ]] || [[ "$diffeee" -lt -"$difflimit" ]]
		then    ##TOO MUCH DIFFERENCE
        logmatch=0 
            if [[ "$diffeee" -lt -100 ]] ; then  # are we more than 1 sec ahead ?
                #let "loglinenum=loglinenum-10"
                echo "WARNING: Found extra photo for which there is no $MODE event. I am at logline $loglinenum (Details below)"
                echo "WARNING: Big Time diff.: ""$difftotoff""s between $jpgname date $jpgtime and $logtype logline $loglinenum $logdate $logtime Time since last $MODE event was ""$difftoterr""s"  | tee -a geotag.log
                logmatch=1  #make the log-fetcher get next picture 
                let "loglinenum=loglinenummatched"  #make log-fetcher keep the log line for next picture
                let "jpglistindex++" #move on to next picture
                let "logmiss++"  #count missing log items
                
            fi
        
        
		else  ## PHOTO AND LOG MATCHING
            
            if [[ $logmatch -eq 0 ]] && [[ "$logmatcgfailinrow" -lt 5 ]] ; then
                let "jpgmiss++"
                echo "ERROR: MISSING PHOTO #$jpgmiss detected, matched current photo with next logged $logtype logline" | tee -a geotag.log
			fi
            if [[ $logmatch -eq 0 ]] && [[ "$logmatcgfailinrow" -gt 4 ]] ; then
                let "logmiss++"
                echo "ERROR: MISSING $MODE log entry detected, matched current photo with logged $logtype logline" | tee -a geotag.log
			fi

            percent=$(echo "scale=2; (($jpglistindex/$jpgtot)*100)" | bc -l | cut -f1 -d".") 
			echo "MATCHED: ""$percent""% Done, time diff.: ""$difftotoff""s between $jpgname $jpgdate $jpgtime & $logtype log $loglinenum $logdate $logtime Time since last $MODE command ""$difftoterr""s"  | tee -a geotag.log
            geotag
            logmatch=1
            logmatcgfailinrow=0
            let "jpglistindex++"
            let "loglinenummatched = loglinenum + 1"  # if we need to go back for POS message, go here
            loglinereverse=0
    fi    #save first image camera vs log offset

logdateprev=$logdate  #for calculation of picture spacing
logtimeprev=$logtime  #for calculation of picture spacing
logtimemsprev=$logtimems #for calculation of picture spacing
logtarget=0 #reset so we are looking for next logline next time

done  #running
}

##### END CAM only loop ######################################################################################
##############################################################################################################
##############################################################################################################
##############################################################################################################
##############################################################################################################
##############################################################################################################


######################################################################  List JPG's
find . -maxdepth 1 -name "*.[Jj][Pp][Gg]" | sort >jpglist
jpgtot=$(wc -l < jpglist)
echo "INFO: Found $jpgtot photos" | tee -a geotag.log



######################################################################  look for logdump, create if needed
if [ -f ./logdump ]; then
    echo "INFO: found logdump"
else
    binname=$(find . -maxdepth 1 -name "*.[Bb][Ii][Nn]")
    if [[ "$binname" == "" ]]; then
        echo "ERROR: .BIN log not found, make sure directory contain a .BIN or .bin log or logdump file." | tee -a geotag.log
        exit 1
    fi
    for binname in $(find . -maxdepth 1 -name "*.[Bb][Ii][Nn]"); do
        if [[ "$ML" == "true" ]]; then
            echo "INFO: adding $binname to logdump..." | tee -a geotag.log
            mavlogdump.py --types POS,CAM,TRIG --format standard "$binname" >> logdump
        else
            if [[ "$logsdone" < 1 ]]; then 
                echo "INFO: dumping $binname to logdump..." | tee -a geotag.log
                mavlogdump.py --types POS,CAM,TRIG --format standard "$binname" > logdump
            fi
        fi
        let "logsdone ++"
    done
fi
echo "INFO: done" | tee -a geotag.log

######################################################################  DUMP camdump
if [ ! -f ./camdump ] && [[ "$MODE" != "POS" ]]; then
    echo "INFO: no camdump found, exporting loglines from .bin to camdump..." | tee -a geotag.log
    mavlogdump.py --types CAM,TRIG --format standard "$binname" > camdump
    echo "INFO: done" | tee -a geotag.log
else
    echo "INFO: camdump found" | tee -a geotag.log
fi


######################################################################  DUMP exiflog
#if [ ! -f ./exifdump ]; then
#    echo "INFO: no exifdump found, exporting exif names and timestamps exifdump..." | tee -a geotag.log
#    #mavlogdump.py --types POS,CAM,TRIG --format standard "$binname" > logdump
#    echo "INFO: done" | tee -a geotag.log
#else
#    echo "INFO: exifdump found" | tee -a geotag.log
#fi


######################################################################  Count CAM events
camtot=$(grep CAM logdump | wc -l)
echo "INFO: Found $camtot CAM log lines (camera shutter sensed)" | tee -a geotag.log

######################################################################  Count TRIG events
trigtot=$(grep TRIG logdump | wc -l)
echo "INFO: Found $trigtot TRIG log lines (commands to shoot)" | tee -a geotag.log



######################################################################  LOAD exifs to memory
#echo "INFO: Loading Photo data into memory..." | tee -a geotag.log
#OLDIFS=$IFS
#IFS=$'\012'  # \012 is a linefeed
#logarray=( $(<exifdump) )
#IFS=$OLDIFS
#logarraysize=${#exifarray[@]}
#echo "INFO: done, loaded $exifarraysize lines." | tee -a geotag.log



######################################################################  Are we searching or processing ?
#if [ "$FIND" == "true" ]
#then
#    loadcamdump
#    camloop
#else
  loadlogdump
    if [[ "$MODE" == "POS" ]]; then
        posloop
    else   
        camloop
    fi
#fi

                                                                                                                                                                                                                                                                                                                                                                                                                                                                          #!/usr/bin/env bash

SCRIPT_DIR=$(dirname $(realpath ${BASH_SOURCE[0]}))
GIT_DIR=$(git rev-parse --git-dir)
GIT_ROOT=$(git rev-parse --show-toplevel)

usage() {
    cat >&$1 <<EOF
Usage: git commit-subsystems [OPTIONS]

Ardupilot's git extension.

Create a different commit for each ardupilot's subsystem (vehicles, libraries
and folders in the project's root). The items in OPTIONS are passed down to the
original git commit command with exception of options --message and --file (and
their short versions). Boths are related to the commit message:
commit-subsystems will treat the commit message from one of those two options
as a template such that occurrences of \$subsystem are replaced with the
subsystem being currently committed.

If neither --message or --file are passed, then the first commit's message will
be used as a template for the other messages and option --edit will be used for
the next commits. To avoid that behavior use --naive.

Another custom option is --raw: don't use commit message as a template.
EOF
}

MSG_FILE="$GIT_DIR/COMMIT_SUBSYSTEM_MSG"
extra_options=

process_msg() {
    local subsystem=$1
    local prev_subsystem=$2
    if [[ -n "$option_m" || -n "$option_F" ]]; then
        if [[ $option_F == - ]]; then
            echo "Please, type the commits message template:"
            option_F="$GIT_DIR/COMMIT_SUBSYSTEM_TEMPLATE"
            cat - > "$option_F"
        fi

        if [[ -n "$option_m" ]]; then
            echo "$option_m"
        else
            cat "$option_F"
        fi | if $option_raw; then
                cat
             else
                sed "s,\$subsystem,$cur_subsystem,g"
             fi > "$MSG_FILE"


        extra_options=(-F "$MSG_FILE")
    elif [[ -n $prev_subsystem ]] && ! $option_naive; then # try to be "smart"
        cat $GIT_DIR/COMMIT_EDITMSG \
            | sed -e "/^\s*#/d" \
                  -e "s/.*\<$prev_subsystem\>.*/\0\n#\0/" \
            | sed "/^[^#]/ s/\<$prev_subsystem\>/$subsystem/g" > "$MSG_FILE"
        echo >> "$MSG_FILE"
        echo "# This commit message was adapted by commit-subsystems" >> "$MSG_FILE"
        extra_options=(-F "$MSG_FILE" --edit)
    fi
}

commit_subsystem() {
    local subsystem=$1
    local prev_subsystem=$2
    shift 2
    process_msg $subsystem $prev_subsystem
    if ! git commit ${extra_options[*]} "$@"; then
        echo "Couldn't commit subsystem $subsystem, aborting..." >&2
        exit 1
    fi
}

args=()

option_m=
option_F=
option_naive=false
option_raw=false

while [[ -n "$1" ]]; do
    opt="$1"
    case "$opt" in
    -h|--help)
        usage 1
        exit 0
        ;;
    -m|--message)
        shift
        if [[ -z "$1" ]]; then
            echo "Option $opt requires a commit message." >&2
            exit 1
        fi
        option_m="$1"
        ;;
    -F|--file)
        shift
        if [[ -z "$1" ]]; then
            echo "Option $opt requires a file name." >&2
            exit 1
        fi
        option_F="$1"
        ;;
    --naive)
        option_naive=true
        ;;
    --raw)
        option_raw=true
        ;;
    *)
        args+=("$1")
        ;;
    esac
    shift
done

if [[ -n $option_m && -n $option_F ]]; then
    echo "Options -m and -F can't be combined." >&2
    exit 1
fi

set -- "${args[@]}"

LIST=$GIT_DIR/COMMIT_SUBSYSTEMS_LIST

git diff --name-only --staged | $SCRIPT_DIR/path-libraries.sh -p > $LIST
git diff --name-only --staged | $SCRIPT_DIR/path-nonlibraries.sh -p >> $LIST

if [[ $(cat "$LIST" | wc -l) -eq 0 ]]; then
    echo "Nothing to commit." >&2
    exit 1
fi

echo "Reseting changes in order to add files separately..."
git reset >/dev/null

# head before commits - for recovery
RECOVERY_HEAD=$(git log -n 1 --format=%H)
exit_hook() {
    local last_error=$?

    set +e

    [[ -a /dev/fd/3 ]] && exec 3<&-

    [[ $last_error -eq 0 ]] && return 0

    echo
    echo "Program interrupted or finished with error(s), reseting head..." >&2
    git reset $RECOVERY_HEAD >/dev/null
    echo "Trying to re-add files..." >&2
    if [[ ! -f $LIST ]]; then
        echo "File with list of added files not found..." >&2
    else
        error=false
        cat $LIST | while read subsystem path; do
            if ! git add -- "$GIT_ROOT/$path"; then
                echo "Couldn't add \"$path\"..." >&2
                error=true
            fi
        done

        if $error; then
            echo "This is embarrassing, couldn't re-add all files. Sorry." >&2
        else
            echo "Files re-added." >&2
        fi
    fi

    return 1
}

set -e
trap "exit 1" SIGINT
trap exit_hook EXIT

echo "Adding and committing subsystems..."
exec 3< $LIST
cur_subsystem=
prev_subsystem=
empty=true
while read -u 3 subsystem path; do
    empty=false
    if [[ $cur_subsystem != $subsystem ]]; then
        if [[ -n $cur_subsystem ]]; then
            commit_subsystem "$cur_subsystem" "$prev_subsystem" "$@"
            echo
        fi
        prev_subsystem=$cur_subsystem
        cur_subsystem=$subsystem
    fi
    if ! git add -- "$GIT_ROOT/$path"; then
        echo "Couldn't add \"$path\", aborting..." >&2
        exit 1
    fi
done

# the last one
commit_subsystem "$cur_subsystem" "$prev_subsystem" "$@"
echo
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   #!/usr/bin/env bash

SCRIPT_DIR=$(dirname $(realpath ${BASH_SOURCE[0]}))
GIT_DIR=$(git rev-parse --git-dir)
GIT_ROOT=$(git rev-parse --show-toplevel)

MSG_FILE="$GIT_DIR/SUBSYSTEMS_SPLIT_MSG"

usage() {
    cat >&$1 <<EOF
git subsystems-split [OPTIONS]

Ardupilot's git extension.

Split HEAD commit into commits separated by subsystems (vehicles, libraries and
folders in the project's root). Basically, reset and call commit-subsystems.

If neither --copy or --edit is passed, then subsystems-split will try to make
the original commit's message into a template for commit-subsystems.

Options:
    --copy
    Make all commits have exactly the same message as the HEAD commit.

    --edit
    Edit the commit message as a template for commit-subsystems.
EOF
}

option_copy=false
option_edit=false

while [[ -n "$1" ]]; do
    opt="$1"
    case "$opt" in
    -h|--help)
        usage 1
        exit 0
        ;;
    --copy)
        option_copy=true
        ;;
    --edit)
        option_edit=true
        ;;
    *)
        usage 2
        exit 1
        ;;
    esac
    shift
done

if $option_copy && $option_edit; then
    echo "Options --copy and --edit can't be combined." >&2
    exit 1
fi

author_name=$(git log -n 1 --format=%an)
author_email=$(git log -n 1 --format=%ae)
author="$author_name <$author_email>"
git log -n 1 --format=%B > "$MSG_FILE"

if $option_edit; then
    if [[ -z $EDITOR ]]; then
        echo "Environment variable EDITOR is required for option --edit." >&2
        exit 1
    fi
    ($EDITOR "$MSG_FILE")
elif ! $option_copy; then
    if head -n 1 "$MSG_FILE" | grep "^[^: ]\+\s*:" -q; then
        sed '1 s,^[^: ]\+\s*,$subsystem,' -i "$MSG_FILE"
    else
        buff_file="$(mktemp)"
        awk '
            NR == 1 {
                l=sub(/^\s\+/, "", $line);
                print "$subsystem: " \
                      tolower(substr($l, 1, 1)) \
                      substr($l, 2);
            }
            NR != 1
            ' "$MSG_FILE" > "$buff_file"
        mv "$buff_file" "$MSG_FILE"
        rm "$buff_file"
    fi
fi

HEAD=$(git rev-parse HEAD)
git reset HEAD~1 --soft
if ! "$SCRIPT_DIR/git-commit-subsystems" -F "$MSG_FILE" --author="$author"; then
    echo "Error on calling git-commit-subsystems." >&2
    git reset $HEAD
    exit 1
fi
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               #!/usr/bin/env bash

usage() {
    cat >&$1 <<EOF
Usage: $0 [OPTIONS]

Read a list of files relative to ardupilot's root directory and output the
libraries they belong to.

Options:
    --show-paths, -p    Print also file paths after the library name.
    --help, -h          Show this help message.
EOF
}

show_paths=false

while [[ -n $1 ]]; do
    case "$1" in
    --show-paths|-p)
        show_paths=true
        ;;
    --help|-h)
        usage 1
        exit 0
        ;;
    *)
        usage 2
        exit 1
        ;;
    esac

    shift
done

if $show_paths; then
    sedcmd="s,libraries/\([^/]\+\).*,\1\t\0,"
else
    sedcmd="s,libraries/\([^/]\+\).*,\1,"
fi

grep "^libraries/[^\/]\+" | \
    sed $sedcmd | \
    sort | \
    uniq
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          #!/usr/bin/env bash

usage() {
    cat >&$1 <<EOF
Usage: $0 [OPTIONS]

Read a list of files relative to ardupilot's root directory and output the
non-libraries subsystems they belong to.

Options:
    --show-paths, -p    Print also file paths after the library name.
    --help, -h          Show this help message.
EOF
}

show_paths=false

while [[ -n $1 ]]; do
    case "$1" in
    --show-paths|-p)
        show_paths=true
        ;;
    --help|-h)
        usage 1
        exit 0
        ;;
    *)
        usage 2
        exit 1
        ;;
    esac

    shift
done

SCRIPT_DIR=$(dirname $(realpath ${BASH_SOURCE[0]}))
ROOT=$(dirname $(git -C $SCRIPT_DIR rev-parse --git-dir))

if $show_paths; then
    sedcmd="s,\([^/]\+\).*,\1\t\0,"
else
    sedcmd="s,\([^/]\+\).*,\1,"
fi

grep -v "^libraries" | \
    sed $sedcmd | \
    sort | \
    uniq | \
    if $show_paths; then
        while read d f; do
            [[ -d "$ROOT/$d" ]] && printf "%s\t%s\n" "$d" "$f"
        done
    else
        while read d; do
            [[ -d "$ROOT/$d" ]] && echo "$d"
        done
    fi
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              #!/usr/bin/env python

'''
A script suitable for use as a git pre-commit hook to ensure your
files are flake8-compliant before committing them.

Use this by copying it to a file called $ARDUPILOT_ROOT/.git/hooks/pre-commit

 AP_FLAKE8_CLEAN
'''

import os
import re
import sys
import subprocess


class AP_PreCommit(object):

    @staticmethod
    def progress(message):
        print(f"***** {message}")

    @staticmethod
    def has_flake8_tag(filepath):
        with open(filepath) as fp:
            return "AP_FLAKE8_CLEAN" in fp.read()

    def files_are_flake8_clean(self, files_to_check):
        if files_to_check:
            for path in files_to_check:
                self.progress("Checking (%s)" % path)
            try:
                subprocess.check_output(["flake8"] + files_to_check, stderr=subprocess.STDOUT)
            except subprocess.CalledProcessError as e:
                self.progress(f"Flake8 check failed: ({e.output})")
                return False
        return True

    @staticmethod
    def split_git_diff_output(output):
        '''split output from git-diff into a list of (status, filepath) tuples'''
        ret = []
        if isinstance(output, bytes):
            output = output.decode('utf-8')
        for line in output.split("\n"):
            if len(line) == 0:
                continue
            ret.append(re.split(r"\s+", line))
        return ret

    def run(self):
        # generate a list of files which have changes not marked for commit
        output = subprocess.check_output([
            "git", "diff", "--name-status"])
        dirty_list = self.split_git_diff_output(output)
        dirty = set()
        for (status, dirty_filepath) in dirty_list:
            dirty.add(dirty_filepath)

        # check files marked for commit:
        output = subprocess.check_output([
            "git", "diff", "--cached", "--name-status"])
        output_tuples = self.split_git_diff_output(output)
        files_to_check_flake8 = []
        for output_tuple in output_tuples:
            if len(output_tuple) > 2:
                if output_tuple[0].startswith('R'):
                    # rename, check destination
                    (status, filepath) = (output_tuple[0], output_tuple[2])
                else:
                    raise ValueError(f"Unknown status {output_tuple[0]}")
            else:
                (status, filepath) = output_tuple
            if filepath in dirty:
                self.progress("WARNING: (%s) has unstaged changes" % filepath)
            if status == 'D':
                # don't check deleted files
                continue
            (base, extension) = os.path.splitext(filepath)
            if extension == ".py" and self.has_flake8_tag(filepath):
                files_to_check_flake8.append(filepath)
        if not self.files_are_flake8_clean(files_to_check_flake8):
            return 1
        return 0


if __name__ == '__main__':
    precommit = AP_PreCommit()
    sys.exit(precommit.run())
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     #pragma once

#include <AP_Common/AP_Common.h>
#include <AP_HAL/SPIDevice.h>
#include "AP_BattMonitor_Backend.h"
#include <utility>

#if AP_BATTERY_INA239_ENABLED

class AP_BattMonitor_INA239 : public AP_BattMonitor_Backend
{
public:
    /// Constructor
    AP_BattMonitor_INA239(AP_BattMonitor &mon,
                          AP_BattMonitor::BattMonitor_State &mon_state,
                          AP_BattMonitor_Params &params);

    bool has_cell_voltages() const override { return false; }
    bool has_temperature() const override { return false; }
    bool has_current() const override { return true; }
    bool get_cycle_count(uint16_t &cycles) const override { return false; }

    void init(void) override;
    void read() override;

    static const struct AP_Param::GroupInfo var_info[];

protected:
    AP_HAL::OwnPtr<AP_HAL::Device> dev;

    void configure(void);
    bool read_word(const uint8_t reg, int16_t& data) const;
    bool write_word(const uint8_t reg, const uint16_t data) const;
    void timer(void);

    bool configured;
    bool callback_registered;
    uint32_t failed_reads;
    uint32_t last_configure_ms;

    struct {
        uint16_t count;
        float volt_sum;
        float current_sum;
        HAL_Semaphore sem;
    } accumulate;
    float current_LSB;
    float voltage_LSB;

    AP_Float max_amps;
    AP_Float rShunt;
};

#endif // AP_BATTERY_INA239_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     #include "AP_BattMonitor_config.h"

#if AP_BATTERY_INA2XX_ENABLED

/*
  supports INA226, INA228 and INA238 I2C battery monitors
 */

#include <AP_HAL/utility/sparse-endian.h>

#include "AP_BattMonitor_INA2xx.h"

extern const AP_HAL::HAL& hal;


// INA226 specific registers
#define REG_226_CONFIG        0x00
#define  REG_226_CONFIG_DEFAULT 0x4127
#define  REG_226_CONFIG_RESET   0x8000
#define REG_226_BUS_VOLTAGE   0x02
#define REG_226_CURRENT       0x04
#define REG_226_CALIBRATION   0x05
#define REG_226_MANUFACT_ID   0xfe

// INA228 specific registers
#define REG_228_CONFIG        0x00
#define  REG_228_CONFIG_RESET   0x8000
#define REG_228_ADC_CONFIG    0x01
#define REG_228_SHUNT_CAL     0x02
#define REG_228_VBUS          0x05
#define REG_228_CURRENT       0x07
#define REG_228_MANUFACT_ID   0x3e
#define REG_228_DEVICE_ID     0x3f
#define REG_228_DIETEMP       0x06
#define INA_228_TEMP_C_LSB    7.8125e-3

// INA237/INA238 specific registers
#define REG_238_CONFIG        0x00
#define  REG_238_CONFIG_RESET   0x8000
#define REG_238_ADC_CONFIG    0x01
#define REG_238_SHUNT_CAL     0x02
#define REG_238_VBUS          0x05
#define REG_238_CURRENT       0x07
#define REG_238_MANUFACT_ID   0x3e
#define REG_238_DEVICE_ID     0x3f
#define REG_238_DIETEMP       0x06
#define INA_238_TEMP_C_LSB    7.8125e-3 // need to mask bottom 4 bits

// INA231 specific registers
#define REG_231_CONFIG        0x00
#define REG_231_SHUNT_VOLTAGE 0x01
#define REG_231_BUS_VOLTAGE   0x02
#define REG_231_POWER         0x03
#define REG_231_CURRENT       0x04
#define REG_231_CALIBRATION   0x05
#define REG_231_MASK          0x06
#define REG_231_ALERT         0x07


#ifndef DEFAULT_BATTMON_INA2XX_MAX_AMPS
#define DEFAULT_BATTMON_INA2XX_MAX_AMPS 90.0
#endif

#ifndef DEFAULT_BATTMON_INA2XX_SHUNT
#define DEFAULT_BATTMON_INA2XX_SHUNT 0.0005
#endif

#ifndef HAL_BATTMON_INA2XX_BUS
#define HAL_BATTMON_INA2XX_BUS 0
#endif
#ifndef HAL_BATTMON_INA2XX_ADDR
#define HAL_BATTMON_INA2XX_ADDR 0
#endif

// list of addresses to probe if I2C_ADDR is zero
const uint8_t AP_BattMonitor_INA2XX::i2c_probe_addresses[] { 0x41, 0x44, 0x45 };

const AP_Param::GroupInfo AP_BattMonitor_INA2XX::var_info[] = {

    // @Param: I2C_BUS
    // @DisplayName: Battery monitor I2C bus number
    // @Description: Battery monitor I2C bus number
    // @Range: 0 3
    // @User: Advanced
    // @RebootRequired: True
    AP_GROUPINFO("I2C_BUS", 25, AP_BattMonitor_INA2XX, i2c_bus, HAL_BATTMON_INA2XX_BUS),

    // @Param: I2C_ADDR
    // @DisplayName: Battery monitor I2C address
    // @Description: Battery monitor I2C address. If this is zero then probe list of supported addresses
    // @Range: 0 127
    // @User: Advanced
    // @RebootRequired: True
    AP_GROUPINFO("I2C_ADDR", 26, AP_BattMonitor_INA2XX, i2c_address, HAL_BATTMON_INA2XX_ADDR),

    // @Param: MAX_AMPS
    // @DisplayName: Battery monitor max current
    // @Description: This controls the maximum current the INS2XX sensor will work with.
    // @Range: 1 400
    // @Units: A
    // @User: Advanced
    AP_GROUPINFO("MAX_AMPS", 27, AP_BattMonitor_INA2XX, max_amps, DEFAULT_BATTMON_INA2XX_MAX_AMPS),

    // @Param: SHUNT
    // @DisplayName: Battery monitor shunt resistor
    // @Description: This sets the shunt resistor used in the device
    // @Range: 0.0001 0.01
    // @Units: Ohm
    // @User: Advanced
    AP_GROUPINFO("SHUNT", 28, AP_BattMonitor_INA2XX, rShunt, DEFAULT_BATTMON_INA2XX_SHUNT),
    
    AP_GROUPEND
};

AP_BattMonitor_INA2XX::AP_BattMonitor_INA2XX(AP_BattMonitor &mon,
                                             AP_BattMonitor::BattMonitor_State &mon_state,
                                             AP_BattMonitor_Params &params)
        : AP_BattMonitor_Backend(mon, mon_state, params)
{
    AP_Param::setup_object_defaults(this, var_info);
    _state.var_info = var_info;
}

void AP_BattMonitor_INA2XX::init(void)
{
    dev = hal.i2c_mgr->get_device(i2c_bus, i2c_address, 100000, false, 20);
    if (!dev) {
        return;
    }
    // register now and configure in the timer callbacks
    dev->register_periodic_callback(25000, FUNCTOR_BIND_MEMBER(&AP_BattMonitor_INA2XX::timer, void));
}

bool AP_BattMonitor_INA2XX::configure(DevType dtype)
{
    switch (dtype) {
    case DevType::UNKNOWN:
        return false;

    case DevType::INA226: {
        // configure for MAX_AMPS
        const uint16_t conf = (0x2<<9) | (0x5<<6) | (0x5<<3) | 0x7; // 2ms conv time, 16x sampling
        current_LSB = max_amps / 32768.0;
        voltage_LSB = 0.00125; // 1.25mV/bit
        const uint16_t cal = uint16_t(0.00512 / (current_LSB * rShunt));
        if (write_word(REG_226_CONFIG, REG_226_CONFIG_RESET) && // reset
            write_word(REG_226_CONFIG, conf) &&
            write_word(REG_226_CALIBRATION, cal)) {
            dev_type = dtype;
            return true;
        }
        break;
    }

    case DevType::INA228: {
        // configure for MAX_AMPS
        voltage_LSB = 195.3125e-6; // 195.3125 uV/LSB
        current_LSB = max_amps / (1U<<19);
        const uint16_t shunt_cal = uint16_t(13107.2e6 * current_LSB * rShunt) & 0x7FFF;
        if (write_word(REG_228_CONFIG, REG_228_CONFIG_RESET) && // reset
            write_word(REG_228_CONFIG, 0) &&
            write_word(REG_228_SHUNT_CAL, shunt_cal)) {
            dev_type = dtype;
            return true;
        }
        break;
    }

    case DevType::INA238: {
        // configure for MAX_AMPS
        voltage_LSB = 3.125e-3; // 3.125mV/LSB
        current_LSB = max_amps / (1U<<15);
        const uint16_t shunt_cal = uint16_t(819.2e6 * current_LSB * rShunt) & 0x7FFF;
        if (write_word(REG_238_CONFIG, REG_238_CONFIG_RESET) && // reset
            write_word(REG_238_CONFIG, 0) &&
            write_word(REG_238_SHUNT_CAL, shunt_cal)) {
            dev_type = dtype;
            return true;
        }
        break;
    }

    case DevType::INA231: {
        // no configuration needed
        voltage_LSB = 1.25e-3;
        current_LSB = max_amps / (1U<<15);
        const uint16_t cal = 0.00512 / (current_LSB * rShunt);
        if (write_word(REG_231_CALIBRATION, cal)) {
            return true;
        }
    }
        
    }
    return false;
}

/// read the battery_voltage and current, should be called at 10hz
void AP_BattMonitor_INA2XX::read(void)
{
    WITH_SEMAPHORE(accumulate.sem);
    _state.healthy = accumulate.count > 0;
    if (!_state.healthy) {
        return;
    }

    _state.voltage = accumulate.volt_sum / accumulate.count;
    _state.current_amps = accumulate.current_sum / accumulate.count;
    accumulate.volt_sum = 0;
    accumulate.current_sum = 0;
    accumulate.count = 0;

    const uint32_t tnow = AP_HAL::micros();
    const uint32_t dt_us = tnow - _state.last_time_micros;
    
    // update total current drawn since startup
    update_consumed(_state, dt_us);

    _state.last_time_micros = tnow;
}

/*
  read 16 bit word from register
  returns true if read was successful, false if failed
*/
bool AP_BattMonitor_INA2XX::read_word16(const uint8_t reg, int16_t& data) const
{
    // read the appropriate register from the device
    if (!dev->read_registers(reg, (uint8_t *)&data, sizeof(data))) {
        return false;
    }

    // convert byte order
    data = int16_t(be16toh(uint16_t(data)));

    return true;
}

/*
  read 24 bit signed value from register
  returns true if read was successful, false if failed
*/
bool AP_BattMonitor_INA2XX::read_word24(const uint8_t reg, int32_t& data) const
{
    // read the appropriate register from the device
    uint8_t d[3];
    if (!dev->read_registers(reg, d, sizeof(d))) {
        return false;
    }
    // 24 bit 2s complement data. Shift into upper 24 bits of int32_t then divide by 256
    // to cope with negative numbers properly
    data = d[0]<<24 | d[1]<<16 | d[2] << 8;
    data = data / 256;

    return true;
}

/*
  write word to a register, byte swapped
  returns true if write was successful, false if failed
*/
bool AP_BattMonitor_INA2XX::write_word(const uint8_t reg, const uint16_t data) const
{
    const uint8_t b[3] { reg, uint8_t(data >> 8), uint8_t(data&0xff) };
    return dev->transfer(b, sizeof(b), nullptr, 0);
}

/*
  detect device type. This may happen well after power on if battery is
  not plugged in yet
*/
bool AP_BattMonitor_INA2XX::detect_device(void)
{
    uint32_t now = AP_HAL::millis();
    if (now - last_detect_ms < 200) {
        // don't flood the bus
        return false;
    }
    last_detect_ms = now;
    int16_t id;

    WITH_SEMAPHORE(dev->get_semaphore());

    if (i2c_address.get() == 0) {
        dev->set_address(i2c_probe_addresses[i2c_probe_next]);
        i2c_probe_next = (i2c_probe_next+1) % sizeof(i2c_probe_addresses);
    }

    if (read_word16(REG_228_MANUFACT_ID, id) && id == 0x5449 &&
        read_word16(REG_228_DEVICE_ID, id) && (id&0xFFF0) == 0x2280) {
        has_temp = true;
        return configure(DevType::INA228);
    }
    if (read_word16(REG_238_MANUFACT_ID, id) && id == 0x5449 &&
        read_word16(REG_238_DEVICE_ID, id) && (id&0xFFF0) == 0x2380) {
        has_temp = true;
        return configure(DevType::INA238);
    }
    if (read_word16(REG_226_MANUFACT_ID, id) && id == 0x5449 &&
        write_word(REG_226_CONFIG, REG_226_CONFIG_RESET) &&
        write_word(REG_226_CONFIG, REG_226_CONFIG_DEFAULT) &&
        read_word16(REG_226_CONFIG, id) &&
        id == REG_226_CONFIG_DEFAULT) {
        return configure(DevType::INA226);
    }
    if (read_word16(REG_231_CONFIG, id) && id == 0x4127) {
        // no manufacturer ID for 231
        return configure(DevType::INA231);
    }

    return false;
}


void AP_BattMonitor_INA2XX::timer(void)
{
    if (dev_type == DevType::UNKNOWN) {
        if (!detect_device()) {
            return;
        }
    }

    float voltage = 0, current = 0;

    switch (dev_type) {
    case DevType::UNKNOWN:
        return;

    case DevType::INA226: {
        int16_t bus_voltage16, current16;
        if (!read_word16(REG_226_BUS_VOLTAGE, bus_voltage16) ||
            !read_word16(REG_226_CURRENT, current16)) {
            failed_reads++;
            if (failed_reads > 10) {
                // device has disconnected, we need to reconfigure it
                dev_type = DevType::UNKNOWN;
            }
            return;
        }
        voltage = bus_voltage16 * voltage_LSB;
        current = current16 * current_LSB;
        break;
    }

    case DevType::INA228: {
        int32_t bus_voltage24, current24;
        int16_t temp16;
        if (!read_word24(REG_228_VBUS, bus_voltage24) ||
            !read_word24(REG_228_CURRENT, current24) ||
            !read_word16(REG_228_DIETEMP, temp16)) {
            failed_reads++;
            if (failed_reads > 10) {
                // device has disconnected, we need to reconfigure it
                dev_type = DevType::UNKNOWN;
            }
            return;
        }
        voltage = (bus_voltage24>>4) * voltage_LSB;
        current = (current24>>4) * current_LSB;
        temperature = temp16 * INA_228_TEMP_C_LSB;
        break;
    }

    case DevType::INA238: {
        int16_t bus_voltage16, current16, temp16;
        if (!read_word16(REG_238_VBUS, bus_voltage16) ||
            !read_word16(REG_238_CURRENT, current16) ||
            !read_word16(REG_238_DIETEMP, temp16)) {
            failed_reads++;
            if (failed_reads > 10) {
                // device has disconnected, we need to reconfigure it
                dev_type = DevType::UNKNOWN;
            }
            return;
        }
        voltage = bus_voltage16 * voltage_LSB;
        current = current16 * current_LSB;
        temperature = (temp16&0xFFF0) * INA_238_TEMP_C_LSB;
        break;
    }

    case DevType::INA231: {
        int16_t bus_voltage16, current16;
        if (!read_word16(REG_231_SHUNT_VOLTAGE, bus_voltage16) ||
            !read_word16(REG_231_CURRENT, current16)) {
            failed_reads++;
            if (failed_reads > 10) {
                // device has disconnected, we need to reconfigure it
                dev_type = DevType::UNKNOWN;
            }
            return;
        }
        voltage = bus_voltage16 * voltage_LSB;
        current = current16 * current_LSB;
        break;
    }
    }

    failed_reads = 0;

    WITH_SEMAPHORE(accumulate.sem);
    accumulate.volt_sum += voltage;
    accumulate.current_sum += current;
    accumulate.count++;
}

/*
  get last temperature
 */
bool AP_BattMonitor_INA2XX::get_temperature(float &temp) const
{
    temp = temperature;
    return has_temp;
}

#endif // AP_BATTERY_INA2XX_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 #pragma once

#include <AP_Common/AP_Common.h>
#include <AP_HAL/I2CDevice.h>
#include "AP_BattMonitor_Backend.h"
#include <AP_Param/AP_Param.h>
#include <utility>

#if AP_BATTERY_INA2XX_ENABLED

class AP_BattMonitor_INA2XX : public AP_BattMonitor_Backend
{
public:
    /// Constructor
    AP_BattMonitor_INA2XX(AP_BattMonitor &mon,
                          AP_BattMonitor::BattMonitor_State &mon_state,
                          AP_BattMonitor_Params &params);

    bool has_cell_voltages() const override { return false; }
    bool has_temperature() const override { return has_temp; }
    bool has_current() const override { return true; }
    bool get_cycle_count(uint16_t &cycles) const override { return false; }
    bool get_temperature(float &temperature) const override;

    void init(void) override;
    void read() override;

    static const struct AP_Param::GroupInfo var_info[];

private:
    AP_HAL::OwnPtr<AP_HAL::I2CDevice> dev;

    enum class DevType : uint8_t {
        UNKNOWN = 0,
        INA226,
        INA228,
        INA238,
        INA231,
    };

    static const uint8_t i2c_probe_addresses[];
    uint8_t i2c_probe_next;

    bool configure(DevType dtype);
    bool read_word16(const uint8_t reg, int16_t& data) const;
    bool read_word24(const uint8_t reg, int32_t& data) const;
    bool write_word(const uint8_t reg, const uint16_t data) const;
    void timer(void);
    bool detect_device(void);

    DevType dev_type;
    uint32_t last_detect_ms;

    AP_Int8 i2c_bus;
    AP_Int8 i2c_address;
    AP_Float max_amps;
    AP_Float rShunt;
    uint32_t failed_reads;

    struct {
        uint16_t count;
        float volt_sum;
        float current_sum;
        HAL_Semaphore sem;
    } accumulate;
    float current_LSB;
    float voltage_LSB;

    float temperature;

    bool has_temp;
};

#endif // AP_BATTERY_INA2XX_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       #include "AP_BattMonitor_config.h"

#if AP_BATTERY_LTC2946_ENABLED

#include <GCS_MAVLink/GCS.h>
#include <AP_HAL/utility/sparse-endian.h>

#include "AP_BattMonitor_LTC2946.h"

extern const AP_HAL::HAL& hal;

#define REG_CTRLA 0x00
#define REG_CTRLB 0x01
#define REG_STATUS 0x80
#define REG_MFR_ID 0xe7

// first byte of 16 bit ID is stable
#define ID_LTC2946 0x60

#define REG_DELTA 0x14 // 16 bits
#define REG_VIN   0x1e // 16 bits

#define REGA_CONF 0x18 // sense, alternate
#define REGB_CONF 0x01 // auto-reset

void AP_BattMonitor_LTC2946::init(void)
{
    dev = hal.i2c_mgr->get_device(HAL_BATTMON_LTC2946_BUS, HAL_BATTMON_LTC2946_ADDR, 100000, false, 20);
    if (!dev) {
        return;
    }

    uint8_t id = 0;
    WITH_SEMAPHORE(dev->get_semaphore());
    if (!dev->read_registers(REG_MFR_ID, &id, 1) || id != ID_LTC2946) {
        GCS_SEND_TEXT(MAV_SEVERITY_WARNING, "LTC2946: Failed to find device 0x%04x", unsigned(id));
        return;
    }

    if (!dev->write_register(REG_CTRLA, REGA_CONF) ||
        !dev->write_register(REG_CTRLB, REGB_CONF)) {
        GCS_SEND_TEXT(MAV_SEVERITY_WARNING, "LTC2946: Failed to configure device");
        return;
    }

    // use datasheet typical values
    voltage_LSB = 102.4 / 4095.0;
    current_LSB = (0.1024/0.0005) / 4095.0;

    GCS_SEND_TEXT(MAV_SEVERITY_WARNING, "LTC2946: found monitor on bus %u", HAL_BATTMON_LTC2946_BUS);

    if (dev) {
        dev->register_periodic_callback(25000, FUNCTOR_BIND_MEMBER(&AP_BattMonitor_LTC2946::timer, void));
    }
}

/// read the battery_voltage and current, should be called at 10hz
void AP_BattMonitor_LTC2946::read(void)
{
    WITH_SEMAPHORE(accumulate.sem);
    _state.healthy = accumulate.count > 0;
    if (!_state.healthy) {
        return;
    }

    _state.voltage = accumulate.volt_sum / accumulate.count;
    _state.current_amps = accumulate.current_sum / accumulate.count;
    accumulate.volt_sum = 0;
    accumulate.current_sum = 0;
    accumulate.count = 0;

    const uint32_t tnow = AP_HAL::micros();
    const uint32_t dt_us = tnow - _state.last_time_micros;
    
    // update total current drawn since startup
    update_consumed(_state, dt_us);

    _state.last_time_micros = tnow;
}

/*
 read word from register
 returns true if read was successful, false if failed
*/
bool AP_BattMonitor_LTC2946::read_word(const uint8_t reg, uint16_t& data) const
{
    // read the appropriate register from the device
    if (!dev->read_registers(reg, (uint8_t *)&data, sizeof(data))) {
        return false;
    }

    // convert byte order
    data = uint16_t(be16toh(uint16_t(data)));

    // return success
    return true;
}

void AP_BattMonitor_LTC2946::timer(void)
{
    uint16_t amps, volts;
    if (!read_word(REG_DELTA, amps) ||
        !read_word(REG_VIN, volts)) {
        return;
    }
    WITH_SEMAPHORE(accumulate.sem);
    // convert 12 bit ADC data
    accumulate.volt_sum += (volts>>4) * voltage_LSB;
    accumulate.current_sum += (amps>>4) * current_LSB;
    accumulate.count++;
}

#endif // AP_BATTERY_LTC2946_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     #pragma once

#include <AP_Common/AP_Common.h>
#include <AP_HAL/I2CDevice.h>
#include "AP_BattMonitor_Backend.h"
#include <utility>

#if AP_BATTERY_LTC2946_ENABLED

class AP_BattMonitor_LTC2946 : public AP_BattMonitor_Backend
{
public:
    // inherit constructor
    using AP_BattMonitor_Backend::AP_BattMonitor_Backend;

    bool has_cell_voltages() const override { return false; }
    bool has_temperature() const override { return false; }
    bool has_current() const override { return true; }
    bool get_cycle_count(uint16_t &cycles) const override { return false; }

    virtual void init(void) override;
    virtual void read() override;
    
private:
    AP_HAL::OwnPtr<AP_HAL::I2CDevice> dev;

    bool read_word(const uint8_t reg, uint16_t& data) const;
    void timer(void);

    struct {
        uint16_t count;
        float volt_sum;
        float current_sum;
        HAL_Semaphore sem;
    } accumulate;
    float current_LSB;
    float voltage_LSB;
};

#endif // AP_BATTERY_LTC2946_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              #include "AP_BattMonitor_config.h"
#include <AP_Logger/AP_Logger_config.h>

#if AP_BATTERY_ENABLED && HAL_LOGGING_ENABLED

#include "AP_BattMonitor_Backend.h"
#include <AP_Logger/AP_Logger.h>

extern const AP_HAL::HAL& hal;

// Write BAT data packet(s)
void AP_BattMonitor_Backend::Log_Write_BAT(const uint8_t instance, const uint64_t time_us) const
{
    bool has_curr = has_current();
    uint8_t percent = -1;
    IGNORE_RETURN(capacity_remaining_pct(percent));

    float temperature;
    int16_t temperature_cd = 0;
    if (get_temperature(temperature)) {
        temperature_cd = temperature * 100.0;
    }

    uint8_t soh_pct = 0;
    IGNORE_RETURN(get_state_of_health_pct(soh_pct));

    const struct log_BAT pkt{
        LOG_PACKET_HEADER_INIT(LOG_BAT_MSG),
        time_us             : time_us,
        instance            : instance,
        voltage             : _state.voltage,
        voltage_resting     : _state.voltage_resting_estimate,
        current_amps        : has_curr ? _state.current_amps : AP::logger().quiet_nanf(),
        current_total       : has_curr ? _state.consumed_mah : AP::logger().quiet_nanf(),
        consumed_wh         : has_curr ? _state.consumed_wh : AP::logger().quiet_nanf(),
        temperature         : temperature_cd,
        resistance          : _state.resistance,
        rem_percent         : percent,
        health              : _state.healthy,
        state_of_health_pct : soh_pct
    };
    AP::logger().WriteBlock(&pkt, sizeof(pkt));
}

// Write BCL data packet if has_cell_voltages
void AP_BattMonitor_Backend::Log_Write_BCL(const uint8_t instance, const uint64_t time_us) const
{
    if (!has_cell_voltages()) {
        return;
    }

    struct log_BCL cell_pkt{
        LOG_PACKET_HEADER_INIT(LOG_BCL_MSG),
        time_us             : time_us,
        instance            : instance,
        voltage             : _state.voltage
    };

    // we pack the entire BCL message - we must have at least that
    // many supported cells or the loop below will over-read
    static_assert(ARRAY_SIZE(_state.cell_voltages.cells) >= ARRAY_SIZE(cell_pkt.cell_voltages), "must have at least ARRAY_SIZE(log_BCL.cell_voltages) cells");

    for (uint8_t i = 0; i < ARRAY_SIZE(cell_pkt.cell_voltages); i++) {
        cell_pkt.cell_voltages[i] = _state.cell_voltages.cells[i] + 1; // add 1mv
    }
    AP::logger().WriteBlock(&cell_pkt, sizeof(cell_pkt));

#if AP_BATT_MONITOR_CELLS_MAX > 12
    if (_state.cell_voltages.cells[12] != UINT16_MAX || _state.cell_voltages.cells[13] != UINT16_MAX)
    {
// @LoggerMessage: BCL2
// @Description: Battery cell voltage information
// @Field: TimeUS: Time since system startup
// @Field: Instance: battery instance number
// @Field: V13: thirteenth cell voltage
// @Field: V14: fourteenth cell voltage
        AP::logger().WriteStreaming(
            "BCL2",
            "TimeUS,Instance,V13,V14",
            "s#vv",
            "F-CC",
            "QBHH",
            time_us,
            instance,
            _state.cell_voltages.cells[ARRAY_SIZE(cell_pkt.cell_voltages)+0] + 1, // add 1mv
            _state.cell_voltages.cells[ARRAY_SIZE(cell_pkt.cell_voltages)+1] + 1  // add 1mv
            );
    }
#endif
}

#endif  // AP_BATTERY_ENABLED && HAL_LOGGING_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           #include "AP_BattMonitor_config.h"

#if AP_BATTERY_ENABLED

#include <AP_Common/AP_Common.h>
#include <AP_Vehicle/AP_Vehicle_Type.h>
#include "AP_BattMonitor_Params.h"
#include "AP_BattMonitor.h"

#if APM_BUILD_COPTER_OR_HELI
  #define DEFAULT_LOW_BATTERY_VOLTAGE 10.5f
#else
  #define DEFAULT_LOW_BATTERY_VOLTAGE 0.0f
#endif // APM_BUILD_COPTER_OR_HELI

#ifndef AP_BATT_MONITOR_BATTERY_CAPACITY
    #define AP_BATT_MONITOR_BATTERY_CAPACITY 3300
#endif

const AP_Param::GroupInfo AP_BattMonitor_Params::var_info[] = {
    // @Param: MONITOR
    // @DisplayName: Battery monitoring
    // @Description: Controls enabling monitoring of the battery's voltage and current
    // @Values: 0:Disabled,3:Analog Voltage Only,4:Analog Voltage and Current,5:Solo,6:Bebop,7:SMBus-Generic,8:DroneCAN-BatteryInfo,9:ESC,10:Sum Of Selected Monitors,11:FuelFlow,12:FuelLevelPWM,13:SMBUS-SUI3,14:SMBUS-SUI6,15:NeoDesign,16:SMBus-Maxell,17:Generator-Elec,18:Generator-Fuel,19:Rotoye,20:MPPT,21:INA2XX,22:LTC2946,23:Torqeedo,24:FuelLevelAnalog,25:Synthetic Current and Analog Voltage,26:INA239_SPI,27:EFI,28:AD7091R5,29:Scripting
    // @User: Standard
    // @RebootRequired: True
    AP_GROUPINFO_FLAGS("MONITOR", 1, AP_BattMonitor_Params, _type, int8_t(AP_BattMonitor::Type::NONE), AP_PARAM_FLAG_ENABLE),
    
    // 2 was VOLT_PIN

    // 3 was CURR_PIN

    // 4 was VOLT_MULT

    // 5 was AMP_PERVLT

    // 6 was AMP_OFFSET

    // @Param: CAPACITY
    // @DisplayName: Battery capacity
    // @Description: Capacity of the battery in mAh when full
    // @Units: mAh
    // @Increment: 50
    // @User: Standard
    AP_GROUPINFO("CAPACITY", 7, AP_BattMonitor_Params, _pack_capacity, AP_BATT_MONITOR_BATTERY_CAPACITY),

#if AP_BATTERY_WATT_MAX_ENABLED
    // @Param{Plane}: WATT_MAX
    // @DisplayName: Maximum allowed power (Watts)
    // @Description: If battery wattage (voltage * current) exceeds this value then the system will reduce max throttle (THR_MAX, TKOFF_THR_MAX and THR_MIN for reverse thrust) to satisfy this limit. This helps limit high current to low C rated batteries regardless of battery voltage. The max throttle will slowly grow back to THR_MAX (or TKOFF_THR_MAX ) and THR_MIN if demanding the current max and under the watt max. Use 0 to disable.
    // @Units: W
    // @Increment: 1
    // @User: Advanced
    AP_GROUPINFO_FRAME("WATT_MAX", 8, AP_BattMonitor_Params, _watt_max, 0, AP_PARAM_FRAME_PLANE),
#endif

    // @Param: SERIAL_NUM
    // @DisplayName: Battery serial number
    // @Description: Battery serial number, automatically filled in for SMBus batteries, otherwise will be -1. With DroneCan it is the battery_id.
    // @User: Advanced
    AP_GROUPINFO("SERIAL_NUM", 9, AP_BattMonitor_Params, _serial_number, AP_BATT_SERIAL_NUMBER_DEFAULT),

#ifndef HAL_BUILD_AP_PERIPH
    // @Param: LOW_TIMER
    // @DisplayName: Low voltage timeout
    // @Description: This is the timeout in seconds before a low voltage event will be triggered. For aircraft with low C batteries it may be necessary to raise this in order to cope with low voltage on long takeoffs. A value of zero disables low voltage errors.
    // @Units: s
    // @Increment: 1
    // @Range: 0 120
    // @User: Advanced
    AP_GROUPINFO("LOW_TIMER", 10, AP_BattMonitor_Params, _low_voltage_timeout, 10),

    // @Param: FS_VOLTSRC
    // @DisplayName: Failsafe voltage source
    // @Description: Voltage type used for detection of low voltage event
    // @Values: 0:Raw Voltage, 1:Sag Compensated Voltage
    // @User: Advanced
    AP_GROUPINFO("FS_VOLTSRC", 11, AP_BattMonitor_Params, _failsafe_voltage_source, BattMonitor_LowVoltageSource_Raw),

    // @Param: LOW_VOLT
    // @DisplayName: Low battery voltage
    // @Description: Battery voltage that triggers a low battery failsafe. Set to 0 to disable. If the battery voltage drops below this voltage continuously for more then the period specified by the @PREFIX@LOW_TIMER parameter then the vehicle will perform the failsafe specified by the @PREFIX@FS_LOW_ACT parameter.
    // @Units: V
    // @Increment: 0.1
    // @User: Standard
    AP_GROUPINFO("LOW_VOLT", 12, AP_BattMonitor_Params, _low_voltage, DEFAULT_LOW_BATTERY_VOLTAGE),

    // @Param: LOW_MAH
    // @DisplayName: Low battery capacity
    // @Description: Battery capacity at which the low battery failsafe is triggered. Set to 0 to disable battery remaining failsafe. If the battery capacity drops below this level the vehicle will perform the failsafe specified by the @PREFIX@FS_LOW_ACT parameter.
    // @Units: mAh
    // @Increment: 50
    // @User: Standard
    AP_GROUPINFO("LOW_MAH", 13, AP_BattMonitor_Params, _low_capacity, 0),

    // @Param: CRT_VOLT
    // @DisplayName: Critical battery voltage
    // @Description: Battery voltage that triggers a critical battery failsafe. Set to 0 to disable. If the battery voltage drops below this voltage continuously for more then the period specified by the @PREFIX@LOW_TIMER parameter then the vehicle will perform the failsafe specified by the @PREFIX@FS_CRT_ACT parameter.
    // @Units: V
    // @Increment: 0.1
    // @User: Standard
    AP_GROUPINFO("CRT_VOLT", 14, AP_BattMonitor_Params, _critical_voltage, 0),

    // @Param: CRT_MAH
    // @DisplayName: Battery critical capacity
    // @Description: Battery capacity at which the critical battery failsafe is triggered. Set to 0 to disable battery remaining failsafe. If the battery capacity drops below this level the vehicle will perform the failsafe specified by the @PREFIX@FS_CRT_ACT parameter.
    // @Units: mAh
    // @Increment: 50
    // @User: Standard
    AP_GROUPINFO("CRT_MAH", 15, AP_BattMonitor_Params, _critical_capacity, 0),

    // @Param: FS_LOW_ACT
    // @DisplayName: Low battery failsafe action
    // @Description: What action the vehicle should perform if it hits a low battery failsafe
    // @Values{Plane}: 0:None,1:RTL,2:Land,3:Terminate,4:QLand,6:Loiter to QLand
    // @Values{Copter}: 0:None,1:Land,2:RTL,3:SmartRTL or RTL,4:SmartRTL or Land,5:Terminate,6:Auto DO_LAND_START or RTL
    // @Values{Sub}: 0:None,2:Disarm,3:Enter surface mode
    // @Values{Rover}: 0:None,1:RTL,2:Hold,3:SmartRTL,4:SmartRTL or Hold,5:Terminate
    // @Values{Tracker}: 0:None
    // @Values{Blimp}: 0:None,1:Land
    // @User: Standard
    AP_GROUPINFO("FS_LOW_ACT", 16, AP_BattMonitor_Params, _failsafe_low_action, 0),

    // @Param: FS_CRT_ACT
    // @DisplayName: Critical battery failsafe action
    // @Description: What action the vehicle should perform if it hits a critical battery failsafe
    // @Values{Plane}: 0:None,1:RTL,2:Land,3:Terminate,4:QLand,5:Parachute,6:Loiter to QLand
    // @Values{Copter}: 0:None,1:Land,2:RTL,3:SmartRTL or RTL,4:SmartRTL or Land,5:Terminate,6:Auto DO_LAND_START or RTL
    // @Values{Sub}: 0:None,2:Disarm,3:Enter surface mode
    // @Values{Rover}: 0:None,1:RTL,2:Hold,3:SmartRTL,4:SmartRTL or Hold,5:Terminate
    // @Values{Tracker}: 0:None
    // @Values{Blimp}: 0:None,1:Land
    // @User: Standard
    AP_GROUPINFO("FS_CRT_ACT", 17, AP_BattMonitor_Params, _failsafe_critical_action, 0),

    // @Param: ARM_VOLT
    // @DisplayName: Required arming voltage
    // @Description: Battery voltage level which is required to arm the aircraft. Set to 0 to allow arming at any voltage.
    // @Units: V
    // @Increment: 0.1
    // @User: Advanced
    AP_GROUPINFO("ARM_VOLT", 18, AP_BattMonitor_Params, _arming_minimum_voltage, 0),

    // @Param: ARM_MAH
    // @DisplayName: Required arming remaining capacity
    // @Description: Battery capacity remaining which is required to arm the aircraft. Set to 0 to allow arming at any capacity. Note that execept for smart batteries rebooting the vehicle will always reset the remaining capacity estimate, which can lead to this check not providing sufficent protection, it is recommended to always use this in conjunction with the @PREFIX@_ARM_VOLT parameter.
    // @Units: mAh
    // @Increment: 50
    // @User: Advanced
    AP_GROUPINFO("ARM_MAH", 19, AP_BattMonitor_Params, _arming_minimum_capacity, 0),

    // 20 was BUS

    // @Param: OPTIONS
    // @DisplayName: Battery monitor options
    // @Description: This sets options to change the behaviour of the battery monitor
    // @Bitmask: 0:Ignore DroneCAN SoC, 1:MPPT reports input voltage and current, 2:MPPT Powered off when disarmed, 3:MPPT Powered on when armed, 4:MPPT Powered off at boot, 5:MPPT Powered on at boot, 6:Send resistance compensated voltage to GCS, 7:Allow DroneCAN InfoAux to be from a different CAN node
    // @User: Advanced
    AP_GROUPINFO("OPTIONS", 21, AP_BattMonitor_Params, _options, 0),
#endif // HAL_BUILD_AP_PERIPH

#if AP_BATTERY_ESC_TELEM_OUTBOUND_ENABLED
    // @Param: ESC_INDEX
    // @DisplayName: ESC Telemetry Index to write to
    // @Description: ESC Telemetry Index to write voltage, current, consumption and temperature data to. Use 0 to disable.
    // @Range: 0 10
    // @Increment: 1
    // @User: Advanced
    AP_GROUPINFO("ESC_INDEX", 22, AP_BattMonitor_Params, _esc_telem_outbound_index, 0),
#endif

    AP_GROUPEND

};

AP_BattMonitor_Params::AP_BattMonitor_Params(void) {
    AP_Param::setup_object_defaults(this, var_info);
}

#endif  // AP_BATTERY_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 #pragma once

#include <AP_Param/AP_Param.h>
#include "AP_BattMonitor_config.h"

class AP_BattMonitor_Params {
public:
    static const struct AP_Param::GroupInfo var_info[];

    AP_BattMonitor_Params(void);

    /* Do not allow copies */
    CLASS_NO_COPY(AP_BattMonitor_Params);

    // low voltage sources (used for BATT_LOW_TYPE parameter)
    enum BattMonitor_LowVoltage_Source {
        BattMonitor_LowVoltageSource_Raw            = 0,
        BattMonitor_LowVoltageSource_SagCompensated = 1
    };
    enum class Options : uint16_t {
        Ignore_UAVCAN_SoC                   = (1U<<0),  // Ignore UAVCAN State-of-Charge (charge %) supplied value from the device and use the internally calculated one
        MPPT_Use_Input_Value                = (1U<<1),  // MPPT reports voltage and current from Input (usually solar panel) instead of the output
        MPPT_Power_Off_At_Disarm            = (1U<<2),  // MPPT Disabled when vehicle is disarmed, if HW supports it
        MPPT_Power_On_At_Arm                = (1U<<3),  // MPPT Enabled when vehicle is armed, if HW supports it
        MPPT_Power_Off_At_Boot              = (1U<<4),  // MPPT Disabled at startup (aka boot), if HW supports it
        MPPT_Power_On_At_Boot               = (1U<<5),  // MPPT Enabled at startup (aka boot), if HW supports it. If Power_Off_at_Boot is also set, the behavior is Power_Off_at_Boot
        GCS_Resting_Voltage                 = (1U<<6),  // send resistance resting voltage to GCS
        AllowSplitAuxInfo                   = (1U<<7),  // allow different node to provide aux info for DroneCAN
        InternalUseOnly                     = (1U<<8),  // for use internally to ArduPilot, not to be (eg.) sent via MAVLink BATTERY_STATUS
    };

    BattMonitor_LowVoltage_Source failsafe_voltage_source(void) const { return (enum BattMonitor_LowVoltage_Source)_failsafe_voltage_source.get(); }

    AP_Int32 _pack_capacity;            /// battery pack capacity less reserve in mAh
    AP_Int32 _serial_number;            /// battery serial number, automatically filled in on SMBus batteries
    AP_Float _low_voltage;              /// voltage level used to trigger a low battery failsafe
    AP_Float _low_capacity;             /// capacity level used to trigger a low battery failsafe
    AP_Float _critical_voltage;         /// voltage level used to trigger a critical battery failsafe
    AP_Float _critical_capacity;        /// capacity level used to trigger a critical battery failsafe
    AP_Int32 _arming_minimum_capacity;  /// capacity level required to arm
    AP_Float _arming_minimum_voltage;   /// voltage level required to arm
    AP_Int32 _options;                  /// Options
#if AP_BATTERY_WATT_MAX_ENABLED
    AP_Int16 _watt_max;                 /// max battery power allowed. Reduce max throttle to reduce current to satisfy t    his limit
#endif
    AP_Int8  _type;                     /// 0=disabled, 3=voltage only, 4=voltage and current
    AP_Int8  _low_voltage_timeout;      /// timeout in seconds before a low voltage event will be triggered
    AP_Int8  _failsafe_voltage_source;  /// voltage type used for detection of low voltage event
    AP_Int8  _failsafe_low_action;      /// action to preform on a low battery failsafe
    AP_Int8  _failsafe_critical_action; /// action to preform on a critical battery failsafe
#if AP_BATTERY_ESC_TELEM_OUTBOUND_ENABLED
    AP_Int8  _esc_telem_outbound_index; /// bitmask of ESCs to forward voltage, current, consumption and temperature to.
#endif
};
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   #include "AP_BattMonitor_config.h"

#if AP_BATTERY_SMBUS_ENABLED

#include "AP_BattMonitor_SMBus.h"

#define AP_BATTMONITOR_SMBUS_PEC_POLYNOME 0x07 // Polynome for CRC generation

extern const AP_HAL::HAL& hal;

const AP_Param::GroupInfo AP_BattMonitor_SMBus::var_info[] = {

    // Param indexes must be between 10 and 19 to avoid conflict with other battery monitor param tables loaded by pointer

    // @Param: I2C_BUS
    // @DisplayName: Battery monitor I2C bus number
    // @Description: Battery monitor I2C bus number
    // @Range: 0 3
    // @User: Advanced
    // @RebootRequired: True
    AP_GROUPINFO("I2C_BUS", 10, AP_BattMonitor_SMBus, _bus, 0),

    // @Param: I2C_ADDR
    // @DisplayName: Battery monitor I2C address
    // @Description: Battery monitor I2C address
    // @Range: 0 127
    // @User: Advanced
    // @RebootRequired: True
    AP_GROUPINFO("I2C_ADDR", 11, AP_BattMonitor_SMBus, _address, AP_BATTMONITOR_SMBUS_I2C_ADDR),

    // Param indexes must be between 10 and 19 to avoid conflict with other battery monitor param tables loaded by pointer

    AP_GROUPEND
};

AP_BattMonitor_SMBus::AP_BattMonitor_SMBus(AP_BattMonitor &mon,
                                           AP_BattMonitor::BattMonitor_State &mon_state,
                                           AP_BattMonitor_Params &params,
                                           uint8_t i2c_bus)
        : AP_BattMonitor_Backend(mon, mon_state, params)
{
    AP_Param::setup_object_defaults(this, var_info);
    _state.var_info = var_info;

    _bus.set_default(i2c_bus);
    _params._serial_number.set(AP_BATT_SERIAL_NUMBER_DEFAULT);
    _params._pack_capacity.set(0);
}

void AP_BattMonitor_SMBus::init(void)
{
    _dev = hal.i2c_mgr->get_device(_bus, _address, 100000, true, 20);
    
    if (_dev) {
        timer_handle = _dev->register_periodic_callback(100000, FUNCTOR_BIND_MEMBER(&AP_BattMonitor_SMBus::timer, void));
    }
}

// return true if cycle count can be provided and fills in cycles argument
bool AP_BattMonitor_SMBus::get_cycle_count(uint16_t &cycles) const
{
    if (!_has_cycle_count) {
        return false;
    }
    cycles = _cycle_count;
    return true;
}

/// read the battery_voltage and current, should be called at 10hz
void AP_BattMonitor_SMBus::read(void)
{
    // nothing to be done here for actually interacting with the battery
    // however we can use this to set any parameters that need to be set

    if (_serial_number != _params._serial_number) {
        _params._serial_number.set_and_notify(_serial_number);
    }

    if (_full_charge_capacity != _params._pack_capacity) {
        _params._pack_capacity.set_and_notify(_full_charge_capacity);
    }
}

// reads the pack full charge capacity
// returns if we already knew the pack capacity
void AP_BattMonitor_SMBus::read_full_charge_capacity(void)
{
    if (_full_charge_capacity != 0) {
        return;
    }

    if (read_word(BATTMONITOR_SMBUS_FULL_CHARGE_CAPACITY, _full_charge_capacity)) {
        _full_charge_capacity *= get_capacity_scaler();
    }
}

// reads the remaining capacity
// which will only be read if we know the full charge capacity (accounting for battery degradation)
void AP_BattMonitor_SMBus::read_remaining_capacity(void)
{
    int32_t capacity = _params._pack_capacity;

    if (capacity <= 0) {
        return;
    }

    uint16_t data;
    if (read_word(BATTMONITOR_SMBUS_REMAINING_CAPACITY, data)) {
        _state.consumed_mah = MAX(0, capacity - (data * get_capacity_scaler()));
    }
}

// reads the temperature word from the battery
void AP_BattMonitor_SMBus::read_temp(void)
{
    uint16_t data;
    if (!read_word(BATTMONITOR_SMBUS_TEMP, data)) {
        _has_temperature = (AP_HAL::millis() - _state.temperature_time) <= AP_BATT_MONITOR_TIMEOUT;
        return;
    }
    _has_temperature = true;

    _state.temperature_time = AP_HAL::millis();
    _state.temperature = KELVIN_TO_C(0.1f * data);
}

// reads the serial number if it's not already known
// returns if the serial number was already known
void AP_BattMonitor_SMBus::read_serial_number(void)
{
    // don't recheck the serial number if we already have it
    if (_serial_number != -1) {
        return;
    }

    uint16_t data;
    if (read_word(BATTMONITOR_SMBUS_SERIAL, data)) {
        _serial_number = data;
    }
}

// reads the battery's cycle count
void AP_BattMonitor_SMBus::read_cycle_count()
{
    // only read cycle count once
    if (_has_cycle_count) {
        return;
    }
    _has_cycle_count = read_word(BATTMONITOR_SMBUS_CYCLE_COUNT, _cycle_count);
}

// read word from register
// returns true if read was successful, false if failed
bool AP_BattMonitor_SMBus::read_word(uint8_t reg, uint16_t& data) const
{
    // buffer to hold results (1 extra byte returned holding PEC)
    const uint8_t read_size = 2 + (_pec_supported ? 1 : 0);
    uint8_t buff[read_size];    // buffer to hold results

    // read the appropriate register from the device
    if (!_dev->read_registers(reg, buff, sizeof(buff))) {
        return false;
    }

    // check PEC
    if (_pec_supported) {
        const uint8_t pec = get_PEC(_address, reg, true, buff, 2);
        if (pec != buff[2]) {
            return false;
        }
    }

    // convert buffer to word
    data = (uint16_t)buff[1]<<8 | (uint16_t)buff[0];

    // return success
    return true;
}

// read_block - returns number of characters read if successful, zero if unsuccessful
uint8_t AP_BattMonitor_SMBus::read_block(uint8_t reg, uint8_t* data, uint8_t len) const
{
    // get length
    uint8_t bufflen;
    // read byte (first byte indicates the number of bytes in the block)
    if (!_dev->read_registers(reg, &bufflen, 1)) {
        return 0;
    }

    // sanity check length returned by smbus
    if (bufflen == 0 || bufflen > len) {
        return 0;
    }

    // buffer to hold results (2 extra byte returned holding length and PEC)
    const uint8_t read_size = bufflen + 1 + (_pec_supported ? 1 : 0);
    uint8_t buff[read_size];

    // read bytes
    if (!_dev->read_registers(reg, buff, read_size)) {
        return 0;
    }

    // check PEC
    if (_pec_supported) {
        const uint8_t pec = get_PEC(_address, reg, true, buff, bufflen+1);
        if (pec != buff[bufflen+1]) {
            return 0;
        }
    }

    // copy data (excluding length & PEC)
    memcpy(data, &buff[1], bufflen);

    // return success
    return bufflen;
}

/// get_PEC - calculate packet error correction code of buffer
uint8_t AP_BattMonitor_SMBus::get_PEC(const uint8_t i2c_addr, uint8_t cmd, bool reading, const uint8_t buff[], uint8_t len) const
{
    // exit immediately if no data
    if (len == 0) {
        return 0;
    }

    // prepare temp buffer for calculating crc
    uint8_t tmp_buff[len+3];
    tmp_buff[0] = i2c_addr << 1;
    tmp_buff[1] = cmd;
    tmp_buff[2] = tmp_buff[0] | (uint8_t)reading;
    memcpy(&tmp_buff[3],buff,len);

    // initialise crc to zero
    uint8_t crc = 0;
    uint8_t shift_reg = 0;
    bool do_invert;

    // for each byte in the stream
    for (uint8_t i=0; i<sizeof(tmp_buff); i++) {
        // load next data byte into the shift register
        shift_reg = tmp_buff[i];
        // for each bit in the current byte
        for (uint8_t j=0; j<8; j++) {
            do_invert = (crc ^ shift_reg) & 0x80;
            crc <<= 1;
            shift_reg <<= 1;
            if(do_invert) {
                crc ^= AP_BATTMONITOR_SMBUS_PEC_POLYNOME;
            }
        }
    }

    // return result
    return crc;
}

#endif  // AP_BATTERY_SMBUS_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        #pragma once

#include "AP_BattMonitor_Backend.h"

#if AP_BATTERY_SMBUS_ENABLED

#include <AP_Common/AP_Common.h>
#include <AP_Param/AP_Param.h>
#include <AP_Math/AP_Math.h>
#include <AP_HAL/I2CDevice.h>
#include <utility>

#define AP_BATTMONITOR_SMBUS_BUS_INTERNAL           0
#define AP_BATTMONITOR_SMBUS_BUS_EXTERNAL           1
#define AP_BATTMONITOR_SMBUS_I2C_ADDR               0x0B
#define AP_BATTMONITOR_SMBUS_TIMEOUT_MICROS         5000000         // sensor becomes unhealthy if no successful readings for 5 seconds
#define AP_BATTMONITOR_SMBUS_READ_BLOCK_MAXIMUM_TRANSFER 0x20       // A Block Read or Write is allowed to transfer a maximum of 32 data bytes.

class AP_BattMonitor_SMBus : public AP_BattMonitor_Backend
{
public:

    // Smart Battery Data Specification Revision 1.1
    enum BATTMONITOR_SMBUS {
        BATTMONITOR_SMBUS_TEMP = 0x08,                 // Temperature
        BATTMONITOR_SMBUS_VOLTAGE = 0x09,              // Voltage
        BATTMONITOR_SMBUS_CURRENT = 0x0A,              // Current
        BATTMONITOR_SMBUS_REMAINING_CAPACITY = 0x0F,   // Remaining Capacity
        BATTMONITOR_SMBUS_FULL_CHARGE_CAPACITY = 0x10, // Full Charge Capacity
        BATTMONITOR_SMBUS_CYCLE_COUNT = 0x17,          // Cycle Count
        BATTMONITOR_SMBUS_SPECIFICATION_INFO = 0x1A,   // Specification Info
        BATTMONITOR_SMBUS_SERIAL = 0x1C,               // Serial Number
        BATTMONITOR_SMBUS_MANUFACTURE_NAME = 0x20,     // Manufacture Name
        BATTMONITOR_SMBUS_MANUFACTURE_DATA = 0x23,     // Manufacture Data
    };

    /// Constructor
    AP_BattMonitor_SMBus(AP_BattMonitor &mon,
                    AP_BattMonitor::BattMonitor_State &mon_state,
                    AP_BattMonitor_Params &params,
                    uint8_t i2c_bus);

    // virtual destructor to reduce compiler warnings
    virtual ~AP_BattMonitor_SMBus() {}

    bool has_cell_voltages() const override { return _has_cell_voltages; }

    bool has_temperature() const override { return _has_temperature; }

    // all smart batteries are expected to provide current
    bool has_current() const override { return true; }

    // don't allow reset of remaining capacity for SMBus
    bool reset_remaining(float percentage) override { return false; }

    // return true if cycle count can be provided and fills in cycles argument
    bool get_cycle_count(uint16_t &cycles) const override;

    virtual void init(void) override;

    static const struct AP_Param::GroupInfo var_info[];

protected:

    void read(void) override;

    // reads the pack full charge capacity
    void read_full_charge_capacity(void);

    // reads the remaining capacity
    // which will only be read if we know the full charge capacity (accounting for battery degradation)
    void read_remaining_capacity(void);

    // return a scaler that should be multiplied by the battery's reported capacity numbers to arrive at the actual capacity in mAh
    virtual uint16_t get_capacity_scaler() const { return 1; }

    // reads the temperature word from the battery
    virtual void read_temp(void);

    // reads the serial number if it's not already known
    // returns if the serial number was already known
    void read_serial_number(void);

    // reads the battery's cycle count
    void read_cycle_count();

     // read word from register
     // returns true if read was successful, false if failed
    bool read_word(uint8_t reg, uint16_t& data) const;

    // read_block - returns number of characters read if successful, zero if unsuccessful
    uint8_t read_block(uint8_t reg, uint8_t* data, uint8_t len) const;

    // get_PEC - calculate PEC for a read or write from the battery
    // buff is the data that was read or will be written
    uint8_t get_PEC(const uint8_t i2c_addr, uint8_t cmd, bool reading, const uint8_t buff[], uint8_t len) const;

    AP_HAL::OwnPtr<AP_HAL::I2CDevice> _dev;
    bool _pec_supported; // true if PEC is supported

    int32_t _serial_number = -1;    // battery serial number
    uint16_t _full_charge_capacity; // full charge capacity, used to stash the value before setting the parameter
    bool _has_cell_voltages;        // smbus backends flag this as true once they have received a valid cell voltage report
    uint16_t _cycle_count = 0;      // number of cycles the battery has experienced. An amount of discharge approximately equal to the value of DesignCapacity.
    bool _has_cycle_count;          // true if cycle count has been retrieved from the battery
    bool _has_temperature;

    virtual void timer(void) = 0;   // timer function to read from the battery

    AP_HAL::Device::PeriodicHandle timer_handle;

    // Parameters
    AP_Int8  _bus;          // I2C bus number
    AP_Int8  _address;      // I2C address

};

#endif  // AP_BATTERY_SMBUS_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 #include "AP_BattMonitor_config.h"

#if AP_BATTERY_SMBUS_GENERIC_ENABLED

#include <AP_HAL/AP_HAL.h>
#include <AP_Common/AP_Common.h>
#include <AP_Math/AP_Math.h>
#include "AP_BattMonitor.h"

#include "AP_BattMonitor_SMBus_Generic.h"

uint8_t smbus_cell_ids[] = { 0x3f,  // cell 1
                             0x3e,  // cell 2
                             0x3d,  // cell 3
                             0x3c,  // cell 4
                             0x3b,  // cell 5
                             0x3a,  // cell 6
                             0x39,  // cell 7
                             0x38,  // cell 8
                             0x37,  // cell 9
                             0x36,  // cell 10
                             0x35,  // cell 11
                             0x34,  // cell 12
#if CONFIG_HAL_BOARD == HAL_BOARD_SITL
                             0x33,  // cell 13
                             0x32   // cell 14
#endif
};

#define SMBUS_CELL_COUNT_CHECK_TIMEOUT       15     // check cell count for up to 15 seconds

/*
 * Other potentially useful registers, listed here for future use
 * #define BATTMONITOR_SMBUS_MAXELL_CHARGE_STATUS         0x0d    // relative state of charge
 * #define BATTMONITOR_SMBUS_MAXELL_BATTERY_STATUS        0x16    // battery status register including alarms
 * #define BATTMONITOR_SMBUS_MAXELL_BATTERY_CYCLE_COUNT   0x17    // cycle count
 * #define BATTMONITOR_SMBUS_MAXELL_DESIGN_VOLTAGE        0x19    // design voltage register
 * #define BATTMONITOR_SMBUS_MAXELL_MANUFACTURE_DATE      0x1b    // manufacturer date
 * #define BATTMONITOR_SMBUS_MAXELL_SERIALNUM             0x1c    // serial number register
 * #define BATTMONITOR_SMBUS_MAXELL_HEALTH_STATUS         0x4f    // state of health
 * #define BATTMONITOR_SMBUS_MAXELL_SAFETY_ALERT          0x50    // safety alert
 * #define BATTMONITOR_SMBUS_MAXELL_SAFETY_STATUS         0x51    // safety status
 * #define BATTMONITOR_SMBUS_MAXELL_PF_ALERT              0x52    // safety status
 * #define BATTMONITOR_SMBUS_MAXELL_PF_STATUS             0x53    // safety status
*/

// Constructor
AP_BattMonitor_SMBus_Generic::AP_BattMonitor_SMBus_Generic(AP_BattMonitor &mon,
                                                   AP_BattMonitor::BattMonitor_State &mon_state,
                                                   AP_BattMonitor_Params &params)
    : AP_BattMonitor_SMBus(mon, mon_state, params, AP_BATTMONITOR_SMBUS_BUS_EXTERNAL)
{}

void AP_BattMonitor_SMBus_Generic::timer()
{
	// check if PEC is supported
    if (!check_pec_support()) {
        return;
    }

    uint16_t data;
    uint32_t tnow = AP_HAL::micros();

    // read voltage (V)
    if (read_word(BATTMONITOR_SMBUS_VOLTAGE, data)) {
        _state.voltage = (float)data * 0.001f;
        _state.last_time_micros = tnow;
        _state.healthy = true;
    }

    // assert that BATTMONITOR_SMBUS_NUM_CELLS_MAX must be no more than smbus_cell_ids
    static_assert(BATTMONITOR_SMBUS_NUM_CELLS_MAX <= ARRAY_SIZE(smbus_cell_ids), "BATTMONITOR_SMBUS_NUM_CELLS_MAX must be no more than smbus_cell_ids");

    // check cell count
    if (!_cell_count_fixed) {
        if (_state.healthy) {
            // when battery first becomes healthy, start check of cell count
            if (_cell_count_check_start_us == 0) {
                _cell_count_check_start_us = tnow;
            }
            if (tnow - _cell_count_check_start_us > (SMBUS_CELL_COUNT_CHECK_TIMEOUT * 1e6)) {
                // give up checking cell count after 15sec of continuous healthy battery reads
                _cell_count_fixed = true;
            }
        } else {
            // if battery becomes unhealthy restart cell count check
            _cell_count_check_start_us = 0;
        }
    }

    // we loop over something limited by
    // BATTMONITOR_SMBUS_NUM_CELLS_MAX but assign into something
    // limited by AP_BATT_MONITOR_CELLS_MAX - so make sure we won't
    // over-write:
    static_assert(BATTMONITOR_SMBUS_NUM_CELLS_MAX <= ARRAY_SIZE(_state.cell_voltages.cells), "BATTMONITOR_SMBUS_NUM_CELLS_MAX must be <= number of cells in state voltages");

    // read cell voltages
    for (uint8_t i = 0; i < (_cell_count_fixed ? _cell_count : BATTMONITOR_SMBUS_NUM_CELLS_MAX); i++) {
        if (read_word(smbus_cell_ids[i], data) && (data > 0) && (data < UINT16_MAX)) {
            _has_cell_voltages = true;
            _state.cell_voltages.cells[i] = data;
            _last_cell_update_us[i] = tnow;
            if (!_cell_count_fixed) {
                _cell_count = MAX(_cell_count, i + 1);
            }
        } else if ((tnow - _last_cell_update_us[i]) > AP_BATTMONITOR_SMBUS_TIMEOUT_MICROS) {
            _state.cell_voltages.cells[i] = UINT16_MAX;
        }
    }

    // timeout after 5 seconds
    if ((tnow - _state.last_time_micros) > AP_BATTMONITOR_SMBUS_TIMEOUT_MICROS) {
        _state.healthy = false;
        return;
    }

    // read current (A)
    if (read_word(BATTMONITOR_SMBUS_CURRENT, data)) {
        _state.current_amps = -(float)((int16_t)data) * 0.001f;
        _state.last_time_micros = tnow;
    }

    read_full_charge_capacity();

    // FIXME: Perform current integration if the remaining capacity can't be requested
    read_remaining_capacity();

    read_temp();

    read_serial_number();

    read_cycle_count();
}

// check if PEC supported with the version value in SpecificationInfo() function
// returns true once PEC is confirmed as working or not working
bool AP_BattMonitor_SMBus_Generic::check_pec_support()
{
    // exit immediately if we have already confirmed pec support
    if (_pec_confirmed) {
        return true;
    }

    // specification info
    uint16_t data;
    if (!read_word(BATTMONITOR_SMBUS_SPECIFICATION_INFO, data)) {
        return false;
    }

    // extract version
    uint8_t version = (data & 0xF0) >> 4;

    // version less than 0011b (i.e. 3) do not support PEC
    if (version < 3) {
        _pec_supported = false;
        _pec_confirmed = true;
        return true;
    }

    // check manufacturer name
    uint8_t buff[AP_BATTMONITOR_SMBUS_READ_BLOCK_MAXIMUM_TRANSFER + 1] {};
    if (read_block(BATTMONITOR_SMBUS_MANUFACTURE_NAME, buff, sizeof(buff))) {
        // Hitachi maxell batteries do not support PEC
        if (strcmp((char*)buff, "Hitachi maxell") == 0) {
            _pec_supported = false;
            _pec_confirmed = true;
            return true;
        }
    }

    // assume all other batteries support PEC
	_pec_supported = true;
	_pec_confirmed = true;
	return true;
}

#endif  // AP_BATTERY_SMBUS_GENERIC_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               