       // a nested group
            const struct GroupInfo *ginfo = get_group_info(group_info[i]);
            if (ginfo == nullptr) {
                continue;
            }
            AP_Param *ap;
            ptrdiff_t new_offset = group_offset;

            if (!adjust_group_offset(vindex, group_info[i], new_offset)) {
                continue;
            }

            ap = next_group(vindex, ginfo, found_current, group_id(group_info, group_base, i, group_shift),
                            group_shift + _group_level_shift, new_offset, token, ptype, skip_disabled, default_val);
            if (ap != nullptr) {
                return ap;
            }
        } else {
            if (*found_current) {
                // got a new one
                token->key = vindex;
                token->group_element = group_id(group_info, group_base, i, group_shift);
                token->idx = 0;
                if (ptype != nullptr) {
                    *ptype = type;
                }
                ptrdiff_t base;
                if (!get_base(var_info(vindex), base)) {
                    continue;
                }

                AP_Param *ret = (AP_Param*)(base + group_info[i].offset + group_offset);

                if (skip_disabled &&
                    _hide_disabled_groups &&
                    group_info[i].type == AP_PARAM_INT8 &&
                    (group_info[i].flags & AP_PARAM_FLAG_ENABLE) &&
                    ((AP_Int8 *)ret)->get() == 0) {
                    token->last_disabled = 1;
                }
#if AP_PARAM_DEFAULTS_ENABLED
                if (default_val != nullptr) {
                    *default_val = get_default_value(ret, group_info[i]);
                }
#endif
                return ret;
            }
            if (group_id(group_info, group_base, i, group_shift) == token->group_element) {
                *found_current = true;
                if (token->last_disabled) {
                    token->last_disabled = 0;
                    return nullptr;
                }
                if (type == AP_PARAM_VECTOR3F && token->idx < 3) {
                    // return the next element of the vector as a
                    // float
                    token->idx++;
                    if (ptype != nullptr) {
                        *ptype = AP_PARAM_FLOAT;
                    }
                    ptrdiff_t base;
                    if (!get_base(var_info(vindex), base)) {
                        continue;
                    }
                    ptrdiff_t ofs = base + group_info[i].offset + group_offset;
                    ofs += sizeof(float)*(token->idx - 1u);
#if AP_PARAM_DEFAULTS_ENABLED
                    if (default_val != nullptr) {
                        *default_val = get_default_value((AP_Param *)ofs, group_info[i]);
                    }
#endif
                    return (AP_Param *)ofs;
                }
            }
        }
    }
    return nullptr;
}

/// Returns the next variable in _var_info, recursing into groups
/// as needed
AP_Param *AP_Param::next(ParamToken *token, enum ap_var_type *ptype, bool skip_disabled, float *default_val)
{
    uint16_t i = token->key;
    bool found_current = false;
    if (i >= _num_vars) {
        // illegal token
        return nullptr;
    }
    enum ap_var_type type = (enum ap_var_type)var_info(i).type;

    // allow Vector3f to be seen as 3 variables. First as a vector,
    // then as 3 separate floats
    if (type == AP_PARAM_VECTOR3F && token->idx < 3) {
        token->idx++;
        if (ptype != nullptr) {
            *ptype = AP_PARAM_FLOAT;
        }
        AP_Param *ret = (AP_Param *)(((token->idx - 1u)*sizeof(float))+(ptrdiff_t)var_info(i).ptr);
#if AP_PARAM_DEFAULTS_ENABLED
        if (default_val != nullptr) {
            *default_val = get_default_value(ret, var_info(i));
        }
#endif
        return ret;
    }

    if (type != AP_PARAM_GROUP) {
        i++;
        found_current = true;
    }
    for (; i<_num_vars; i++) {
        const auto &info = var_info(i);
        if (!check_frame_type(info.flags)) {
            continue;
        }
        type = (enum ap_var_type)info.type;
        if (type == AP_PARAM_GROUP) {
            const struct GroupInfo *group_info = get_group_info(info);
            if (group_info == nullptr) {
                continue;
            }
            AP_Param *ap = next_group(i, group_info, &found_current, 0, 0, 0, token, ptype, skip_disabled, default_val);
            if (ap != nullptr) {
                return ap;
            }
        } else {
            // found the next one
            token->key = i;
            token->group_element = 0;
            token->idx = 0;
            if (ptype != nullptr) {
                *ptype = type;
            }
#if AP_PARAM_DEFAULTS_ENABLED
            if (default_val != nullptr) {
                *default_val = get_default_value((AP_Param *)info.ptr, info);
            }
#endif
            return (AP_Param *)(info.ptr);
        }
    }
    return nullptr;
}

/// Returns the next scalar in _var_info, recursing into groups
/// as needed
AP_Param *AP_Param::next_scalar(ParamToken *token, enum ap_var_type *ptype, float *default_val)
{
    AP_Param *ap;
    enum ap_var_type type;
    while ((ap = next(token, &type, true, default_val)) != nullptr && type > AP_PARAM_FLOAT) ;

    if (ap != nullptr) {
        if (ptype != nullptr) {
            *ptype = type;
        }
    }
#if AP_PARAM_DEFAULTS_ENABLED
    check_default(ap, default_val);
#endif
    return ap;
}


/// cast a variable to a float given its type
float AP_Param::cast_to_float(enum ap_var_type type) const
{
    switch (type) {
    case AP_PARAM_INT8:
        return ((AP_Int8 *)this)->cast_to_float();
    case AP_PARAM_INT16:
        return ((AP_Int16 *)this)->cast_to_float();
    case AP_PARAM_INT32:
        return ((AP_Int32 *)this)->cast_to_float();
    case AP_PARAM_FLOAT:
        return ((AP_Float *)this)->cast_to_float();
    default:
        return NAN;
    }
}

/*
  find an old parameter and return it.
 */
bool AP_Param::find_old_parameter(const struct ConversionInfo *info, AP_Param *value)
{
    // find the old value in EEPROM.
    uint16_t pofs;
    AP_Param::Param_header header;
    header.type = info->type;
    set_key(header, info->old_key);
    header.group_element = info->old_group_element;
    if (!scan(&header, &pofs)) {
        // the old parameter isn't saved in the EEPROM.
        return false;
    }

    // load the old value from EEPROM
    _storage.read_block(value, pofs+sizeof(header), type_size((enum ap_var_type)header.type));
    return true;
}

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wformat"
// convert one old vehicle parameter to new object parameter
void AP_Param::convert_old_parameter(const struct ConversionInfo *info, float scaler, uint8_t flags)
{
    uint8_t old_value[type_size(info->type)];
    AP_Param *ap = (AP_Param *)&old_value[0];

    if (!find_old_parameter(info, ap)) {
        // the old parameter isn't saved in the EEPROM. It was
        // probably still set to the default value, which isn't stored
        // no need to convert
        return;
    }

    // find the new variable in the variable structures
    enum ap_var_type ptype;
    AP_Param *ap2 = find(&info->new_name[0], &ptype);
    if (ap2 == nullptr) {
        DEV_PRINTF("Unknown conversion '%s'\n", info->new_name);
        return;
    }

    // see if we can load it from EEPROM
    if (!(flags & CONVERT_FLAG_FORCE) && ap2->configured_in_storage()) {
        // the new parameter already has a value set by the user, or
        // has already been converted
        return;
    }

    // see if they are the same type and no scaling applied
    if (ptype == info->type && is_equal(scaler, 1.0f) && flags == 0) {
        // copy the value over only if the new parameter does not already
        // have the old value (via a default).
        if (memcmp(ap2, ap, sizeof(old_value)) != 0) {
            memcpy(ap2, ap, sizeof(old_value));
            // and save
            ap2->save();
        }
    } else if (ptype <= AP_PARAM_FLOAT && info->type <= AP_PARAM_FLOAT) {
        // perform s#include "AP_Proximity_config.h"

#if AP_PROXIMITY_CYGBOT_ENABLED

#include "AP_Proximity_Cygbot_D1.h"

// update the state of the sensor
void AP_Proximity_Cygbot_D1::update()
{
    if (!_initialized) {
        send_sensor_start();
        _temp_boundary.reset();
        _initialized = true;
        _last_init_ms = AP_HAL::millis();
    }

    if ((AP_HAL::millis() - _last_init_ms) < CYGBOT_INIT_TIMEOUT_MS) {
        // just initialized
        set_status(AP_Proximity::Status::NoData);
        return;
    }

    // read data
    read_sensor_data();

    if (AP_HAL::millis() - _last_distance_received_ms < CYGBOT_TIMEOUT_MS) {
        set_status(AP_Proximity::Status::Good);
    } else {
        // long time since we received any valid sensor data
        // try sending the sensor the "send data" message
        _initialized = false;
        set_status(AP_Proximity::Status::NoData);
    }
}

// send message to the sensor to start streaming 2-D data
void AP_Proximity_Cygbot_D1::send_sensor_start()
{
    // this message corresponds to "start message"
    const uint8_t packet_start_2d[8] = { CYGBOT_PACKET_HEADER_0, CYGBOT_PACKET_HEADER_1, CYGBOT_PACKET_HEADER_2, 0x02, 0x00, 0x01, 0x00, 0x03 };
    _uart->write(packet_start_2d, 8);
}

void AP_Proximity_Cygbot_D1::read_sensor_data()
{
    uint32_t nbytes = _uart->available();
    while (nbytes-- > 0) {
        int16_t byte = _uart->read();
        if (!parse_byte(byte)) {
            // reset
            reset();
        }
    }
}

// parse one byte from the sensor. Return false on error.
// Message format is: header1 + header2 + header3 + length1 + length2 + PayloadCommand + checksum
bool AP_Proximity_Cygbot_D1::parse_byte(uint8_t data)
{
    switch (_parse_state) {
    case Header1:
        if (data == CYGBOT_PACKET_HEADER_0) {
            _parse_state = Header2;
            return true;
        }

        return false;

    case Header2:
        if (data == CYGBOT_PACKET_HEADER_1) {
            _parse_state = Header3;
            return true;
        }
        return false;

    case Header3:
        if (data == CYGBOT_PACKET_HEADER_2) {
            _parse_state = Length1;
            return true;
        }
        return false;

    case Length1:
        _msg.payload_len_flags_low = data;
        _parse_state = Length2;
        return true;

    case Length2:
        _msg.payload_len_flags_high = data;
        _msg.payload_len = UINT16_VALUE(data, _msg.payload_len_flags_low);
        if (_msg.payload_len > CYGBOT_MAX_MSG_SIZE) {
            return false;
        }
        _parse_state = Payload_Header;
        return true;

    case Payload_Header:
        if (data == CYGBOT_PAYLOAD_HEADER) {
            _parse_state = Payload_Data;
            _msg.payload_counter = 1;
            _msg.payload[_msg.payload_counter] = data;
            return true;
        }
        return false;

    case Payload_Data:
        if (_msg.payload_counter < (_msg.payload_len)) {
            _msg.payload_counter++;
            _msg.payload[_msg.payload_counter] = data;
            return true;
        }
        _parse_state = CheckSum;
        FALLTHROUGH;

    case CheckSum: {
        const uint8_t checksum_num = calc_checksum(_msg.payload, _msg.payload_len);
        if (data != checksum_num) {
            return false;
        }
        // checksum is valid, parse payload
        _last_distance_received_ms = AP_HAL::millis();
        parse_payload();
        _temp_boundary.update_3D_boundary(state.instance, frontend.boundary);
        reset();
        return true;
    }
    break;

    default:
        return false;
    }

    return false;
}

// parse payload, to pick out distances, and feed them to the correct faces
void AP_Proximity_Cygbot_D1::parse_payload()
{
    // current horizontal angle in the payload
    float sampled_angle = CYGBOT_2D_START_ANGLE;

    // start from second byte as first byte is part of the header
    for (uint16_t i = 2; i < _msg.payload_len; i += 2) {
        const float corrected_angle = correct_angle_for_orientation(sampled_angle);
        const uint16_t distance_mm = UINT16_VALUE(_msg.payload[i], _msg.payload[i+1]);
        float distance_m = distance_mm * 0.001f;
        if (distance_m > distance_min() && distance_m < distance_max()) {
            if (ignore_reading(corrected_angle, distance_m)) {
                // ignore this angle
                sampled_angle += CYGBOT_2D_ANGLE_STEP;
                continue;
            }
            // convert angle to face
            const AP_Proximity_Boundary_3D::Face face = frontend.boundary.get_face(corrected_angle);

            // push face to temp boundary
            _temp_boundary.add_distance(face, corrected_angle, distance_m);
            // push to OA_DB
            database_push(corrected_angle, distance_m);
        }
        // increment sampled angle
        sampled_angle += CYGBOT_2D_ANGLE_STEP;
    }
}

// Checksum
uint8_t AP_Proximity_Cygbot_D1::calc_checksum(uint8_t *buff, int buffSize)
{
    uint8_t check_sum_num = 0;
    check_sum_num ^= _msg.payload_len_flags_high;
    check_sum_num ^= _msg.payload_len_flags_low;
    for (uint16_t i = 0; i <= buffSize; i++) {
        check_sum_num ^= buff[i];
    }
    return check_sum_num;
}

// reset all variables and flags
void AP_Proximity_Cygbot_D1::reset()
{
    _parse_state = Header1;
    _msg.payload_counter = 0;
    _msg.payload_len = 0;
    _temp_boundary.reset();
}

#endif // AP_PROXIMITY_CYGBOT_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               #pragma once

#include "AP_Proximity_config.h"

#if AP_PROXIMITY_DRONECAN_ENABLED

#include "AP_Proximity_Backend.h"

#include <AP_DroneCAN/AP_DroneCAN.h>

class AP_Proximity_DroneCAN : public AP_Proximity_Backend
{
public:
    // constructor
    using AP_Proximity_Backend::AP_Proximity_Backend;

    // update state
    void update(void) override;

    // get maximum and minimum distances (in meters) of sensor
    float distance_max() const override;
    float distance_min() const override;


   static AP_Proximity_DroneCAN* get_dronecan_backend(AP_DroneCAN* ap_dronecan, uint8_t node_id, uint8_t address, bool create_new);


    static void subscribe_msgs(AP_DroneCAN* ap_dronecan);

    static void handle_measurement(AP_DroneCAN *ap_dronecan, const CanardRxTransfer& transfer, const ardupilot_equipment_proximity_sensor_Proximity &msg);

private:

    uint32_t _last_update_ms;   // system time of last message received

    AP_DroneCAN* _ap_dronecan;
    uint8_t _node_id;

    struct ObstacleItem {
        float yaw_deg;
        float pitch_deg;
        float distance_m;
    };

    static ObjectBuffer_TS<ObstacleItem> items;

    AP_Proximity::Status _status;
};

#endif // AP_PROXIMITY_DRONECAN_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             /*
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/*
 * ArduPilot device driver for Inno-Maker LD06 LiDAR
 *
 * ALL INFORMATION REGARDING PROTOCOL WAS DERIVED FROM InnoMaker DATASHEET:
 *
 * http://wiki.inno-maker.com/display/HOMEPAGE/LD06?preview=/6949506/6949511/LDROBOT_LD06_Development%20manual_v1.0_en.pdf
 *
 * Author: Adithya Patil, Georgia Institute of Technology
 * Based on the SLAMTEC RPLiDAR code written by Steven Josefs, IAV GmbH and CYGBOT D1 LiDAR code
 *
 */

#include "AP_Proximity_config.h"

#if AP_PROXIMITY_LD06_ENABLED
#include "AP_Proximity_LD06.h"

#define LD_START_CHAR       0x54
#define PROXIMITY_LD06_TIMEOUT_MS 50

// Indices in data array where each value starts being recorded
// See comment below about data payload for more info about formatting
#define START_BEGIN_CHARACTER       0
#define START_DATA_LENGTH           1
#define START_RADAR_SPEED           2
#define START_BEGIN_ANGLE           4
#define START_PAYLOAD               6
#define START_END_ANGLE             42
#define START_CHECK_SUM             46
#define MEASUREMENT_PAYLOAD_LENGTH  3
#define PAYLOAD_COUNT               12

 /* ------------------------------------------
    Data Packet Structure:
    Start Character : 1 Byte
    Data Length : 1 Byte
    Radar Speed : 2 Bytes
    Start Angle : 2 Bytes
    Data Measurements : 36 Bytes
        Contains 12 measurements of 3 Bytes each
        Each measurement has 2 Bytes for distance to closest object
        Each measurement has the 3rd Byte as measurement Confidence
    End Angle : 2 Bytes
    Timestamp : 2 Bytes
    Checksum : 1 Byte
    ------------------------------------------ */
// ----> 47 data bytes in total for one packet

// Update the sensor readings
void AP_Proximity_LD06::update(void)
{
    // Escape if no connection detected/supported while running
    if (_uart == nullptr) {
        return;
    }

    // Begin getting sensor readings
    // Calls method that repeatedly reads through UART channel
    get_readings();

    // Check if the data is being received correctly and sets Proximity Status
    if (_last_distance_received_ms == 0 || (AP_HAL::millis() - _last_distance_received_ms > PROXIMITY_LD06_TIMEOUT_MS)) {
        set_status(AP_Proximity::Status::NoData);
    } else {
        set_status(AP_Proximity::Status::Good);
    }
}

// Called repeatedly to get the readings at the current instant
void AP_Proximity_LD06::get_readings()
{
    if (_uart == nullptr) {
        return;
    }

    // Store the number of bytes available on the UART input
    uint32_t nbytes = MIN((uint16_t) 4000,  _uart->available());

    // Loops through all bytes that were received
    while (nbytes-- > 0) {

        // Gets and logs the current byte being read
        const uint8_t c = _uart->read();

        // Stores the byte in an array if the byte is a start byte or we have already read a start byte
        if (c == LD_START_CHAR || _response_data) {

            // Sets to true if a start byte has been read, default false otherwise
            _response_data = true;

            // Stores the next byte in an array
            _response[_byte_count] = c;
            _byte_count++;

            if (_byte_count == _response[START_DATA_LENGTH] + 3) {
                
                const uint32_t current_ms = AP_HAL::millis();

                // Stores the last distance taken, used to reduce number of readings taken
                if (_last_distance_received_ms != current_ms) {
                    _last_distance_received_ms =  current_ms;
                }

                // Updates the temporary boundary and passes off the completed data
                parse_response_data();
                _temp_boundary.update_3D_boundary(state.instance, frontend.boundary);
                _temp_boundary.reset();

                // Resets the bytes read and whether or not we are reading data to accept a new payload
                _byte_count = 0;
                _response_data = false;
            }
        }
    }
}

// Parses the data packet received from the LiDAR
void AP_Proximity_LD06::parse_response_data()
{

    // Data interpretation based on:
    // http://wiki.inno-maker.com/display/HOMEPAGE/LD06?preview=/6949506/6949511/LDROBOT_LD06_Development%20manual_v1.0_en.pdf

    // Second byte in array stores length of data - not used but stored for debugging
    // const uint8_t data_length = _response[START_DATA_LENGTH];

    // Respective bits store the radar speed, start/end angles
    // Use bitwise operations to correctly obtain correct angles
    // Divide angles by 100 as per manual
    const float start_angle = float(UINT16_VALUE(_response[START_BEGIN_ANGLE + 1], _response[START_BEGIN_ANGLE])) * 0.01;
    const float end_angle = float(UINT16_VALUE(_response[START_END_ANGLE + 1], _response[START_END_ANGLE])) * 0.01;

    // Verify the checksum that is stored in the last element of the response array
    // Return if checksum is incorrect - i.e. bad data, bad readings, etc.
    const uint8_t check_sum = _response[START_CHECK_SUM];
    if (check_sum != crc8_generic(&_response[0], sizeof(_response) / sizeof(_response[0]) - 1, 0x4D)) {
        return;
    }

    // Calculates the angle that this point was sampled at
    float sampled_counts = 0;
    const float angle_step = (end_angle - start_angle) /  (PAYLOAD_COUNT - 1);
    float uncorrected_angle = start_angle + (end_angle - start_angle) * 0.5;

    // Handles the case that the angles read went from 360 to 0 (jumped)
    if (angle_step < 0) {
        uncorrected_angle = wrap_360(start_angle + (end_angle + 360 - start_angle) * 0.5);
    }

    // Takes the angle in the middle of the readings to be pushed to the database
    const float push_angle = correct_angle_for_orientation(uncorrected_angle);

    float distance_avg = 0.0;

    // Each recording point is three bytes long, goes through all of that and updates database
    for (uint16_t i = START_PAYLOAD; i < START_PAYLOAD + MEASUREMENT_PAYLOAD_LENGTH * PAYLOAD_COUNT; i += MEASUREMENT_PAYLOAD_LENGTH) {

        // Gets the distance recorded and converts to meters
        const float distance_meas = UINT16_VALUE(_response[i + 1], _response[i]) * 0.001;

        // Validates data and checks if it should be included
        if (distance_meas > distance_min() && distance_meas < distance_max()) {
            if (ignore_reading(push_angle, distance_meas)) {
                continue;
            }

            sampled_counts ++;
            distance_avg += distance_meas;
        }
    }

    // Convert angle to appropriate face and adds to database
    // Since angle increments are only about 3 degrees, ignore readings if there were only 1 or 2 measurements
    //    (likely outliers) recorded in the range
    if (sampled_counts > 2) {
        // Gets the average distance read
        distance_avg /= sampled_counts;

        // Pushes the average distance and angle to the obstacle avoidance database
        const AP_Proximity_Boundary_3D::Face face = frontend.boundary.get_face(push_angle);
        _temp_boundary.add_distance(face, push_angle, distance_avg);
        database_push(push_angle, distance_avg);
    }
}
#endif // AP_PROXIMITY_LD06_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                    /*
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/*
 * ArduPilot device driver for Inno-Maker LD06 LiDAR
 *
 * ALL INFORMATION REGARDING PROTOCOL WAS DERIVED FROM LD06 DATASHEET:
 *
 * http://wiki.inno-maker.com/display/HOMEPAGE/LD06?preview=/6949506/6949511/LDROBOT_LD06_Development%20manual_v1.0_en.pdf
 *
 * Author: Adithya Patil, Georgia Institute of Technology
 * Based on the SLAMTEC RPLiDAR code written by Steven Josefs, IAV GmbH
 *
 */

#pragma once
#include "AP_Proximity_config.h"

#if AP_PROXIMITY_LD06_ENABLED

#include "AP_Proximity_Backend_Serial.h"

#define MESSAGE_LENGTH_LD06         47

// Minimum and maximum distance that the sensor can read in meters
#define MAX_READ_DISTANCE_LD06          12.0f
#define MIN_READ_DISTANCE_LD06           0.02f

class AP_Proximity_LD06 : public AP_Proximity_Backend_Serial
{
public:

    using AP_Proximity_Backend_Serial::AP_Proximity_Backend_Serial;

    // Update the state of the sensor
    void update(void) override;

    // Get the max and min distances for the sensor being used
    float distance_max() const override { return MAX_READ_DISTANCE_LD06; }
    float distance_min() const override { return MIN_READ_DISTANCE_LD06; }

private:

    // Get and parse the sensor data
    void parse_response_data();
    void get_readings();

    // Store and keep track of the bytes being read from the sensor
    uint8_t _response[MESSAGE_LENGTH_LD06];
    bool _response_data;
    uint16_t _byte_count;

    // Store for error-tracking purposes
    uint32_t  _last_distance_received_ms;

    // Boundary to store the measurements
    AP_Proximity_Temp_Boundary _temp_boundary;
};
#endif // AP_PROXIMITY_LD06_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               /*
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include "AP_Proximity_config.h"

#if AP_PROXIMITY_LIGHTWARE_SF40C_ENABLED

#include "AP_Proximity_LightWareSF40C.h"

#include <AP_Common/AP_Common.h>
#include <AP_HAL/AP_HAL.h>
#include <AP_HAL/utility/sparse-endian.h>
#include <AP_Math/crc.h>

extern const AP_HAL::HAL& hal;

#define PROXIMITY_SF40C_HEADER                  0xAA
#define PROXIMITY_SF40C_DESIRED_OUTPUT_RATE     3

// update the state of the sensor
void AP_Proximity_LightWareSF40C::update(void)
{
    if (_uart == nullptr) {
        return;
    }

    // initialise sensor if necessary
    initialise();

    // process incoming messages
    process_replies();

    // check for timeout and set health status
    if ((_last_distance_received_ms == 0) || ((AP_HAL::millis() - _last_distance_received_ms) > PROXIMITY_SF40C_TIMEOUT_MS)) {
        set_status(AP_Proximity::Status::NoData);
    } else {
        set_status(AP_Proximity::Status::Good);
    }
}

// initialise sensor
void AP_Proximity_LightWareSF40C::initialise()
{
    // exit immediately if we've sent initialisation requests in the last second
    uint32_t now_ms = AP_HAL::millis();
    if ((now_ms - _last_request_ms) < 1000) {
        return;
    }
    _last_request_ms = now_ms;

    // re-fetch motor state
    request_motor_state();

    // get token from sensor (required for reseting)
    if (!got_token()) {
        request_token();
        return;
    }

    // if no replies in last 15 seconds reboot sensor
    if ((now_ms > 30000) && (now_ms - _last_reply_ms > 15000)) {
        restart_sensor();
        return;
    }

    // if motor is starting up give more time to succeed or fail
    if ((_sensor_state.motor_state != MotorState::RUNNING_NORMALLY) &&
        (_sensor_state.motor_state != MotorState::FAILED_TO_COMMUNICATE)) {
        return;
    }

    // if motor fails, reset sensor and re-try everything
    if (_sensor_state.motor_state == MotorState::FAILED_TO_COMMUNICATE) {
        restart_sensor();
        return;
    }

    // motor is running correctly (motor_state is RUNNING_NORMALLY) so request start of streaming
    if (!_sensor_state.streaming || (_sensor_state.output_rate != PROXIMITY_SF40C_DESIRED_OUTPUT_RATE)) {
        request_stream_start();
        return;
    }
}

// restart sensor and re-init our state
void AP_Proximity_LightWareSF40C::restart_sensor()
{
    // return immediately if no token or a restart has been requested within the last 30sec
    uint32_t now_ms = AP_HAL::millis();
    if ((_last_restart_ms != 0) && ((now_ms - _last_restart_ms) < 30000)) {
        return;
    }

    // restart sensor and re-initialise sensor state
    request_reset();
    clear_token();
    _last_restart_ms = now_ms;
    _sensor_state.motor_state = MotorState::UNKNOWN;
    _sensor_state.streaming = false;
    _sensor_state.output_rate = 0;
}

// send message to sensor
void AP_Proximity_LightWareSF40C::send_message(MessageID msgid, bool write, const uint8_t *payload, uint16_t payload_len)
{
    if ((_uart == nullptr) || (payload_len > PROXIMITY_SF40C_PAYLOAD_LEN_MAX)) {
        return;
    }

    // check for sufficient space in outgoing buffer
    if (_uart->txspace() < payload_len + 6U) {
        return;
    }

    // write header
    _uart->write((uint8_t)PROXIMITY_SF40C_HEADER);
    uint16_t crc = crc_xmodem_update(0, PROXIMITY_SF40C_HEADER);

    // write flags including payload length
    const uint16_t flags = ((payload_len+1) << 6) | (write ? 0x01 : 0);
    _uart->write(LOWBYTE(flags));
    crc = crc_xmodem_update(crc, LOWBYTE(flags));
    _uart->write(HIGHBYTE(flags));
    crc = crc_xmodem_update(crc, HIGHBYTE(flags));

    // msgid
    _uart->write((uint8_t)msgid);
    crc = crc_xmodem_update(crc, (uint8_t)msgid);

    // payload
    if ((payload_len > 0) && (payload != nullptr)) {
        for (uint16_t i = 0; i < payload_len; i++) {
            _uart->write(payload[i]);
            crc = crc_xmodem_update(crc, payload[i]);
        }
    }

    // checksum
    _uart->write(LOWBYTE(crc));
    _uart->write(HIGHBYTE(crc));
}

// request motor state
void AP_Proximity_LightWareSF40C::request_motor_state()
{
    send_message(MessageID::MOTOR_STATE, false, (const uint8_t *)nullptr, 0);
}

// request start of streaming of distances
void AP_Proximity_LightWareSF40C::request_stream_start()
{
    // request output rate
    const uint8_t desired_rate = PROXIMITY_SF40C_DESIRED_OUTPUT_RATE; // 0 = 20010, 1 = 10005, 2 = 6670, 3 = 2001
    send_message(MessageID::OUTPUT_RATE, true, &desired_rate, sizeof(desired_rate));

    // request streaming to start
    const le32_t val = htole32(3);
    send_message(MessageID::STREAM, true, (const uint8_t*)&val, sizeof(val));
}

// request token of sensor
void AP_Proximity_LightWareSF40C::request_token()
{
    // request token
    send_message(MessageID::TOKEN, false, nullptr, 0);
}

// request reset of sensor
void AP_Proximity_LightWareSF40C::request_reset()
{
    // send reset request
    send_message(MessageID::RESET, true, _sensor_state.token, ARRAY_SIZE(_sensor_state.token));
}

// check for replies from sensor
void AP_Proximity_LightWareSF40C::process_replies()
{
    if (_uart == nullptr) {
        return;
    }

    int16_t nbytes = _uart->available();
    while (nbytes-- > 0) {
        const int16_t r = _uart->read();
        if ((r < 0) || (r > 0xFF)) {
            continue;
        }
        parse_byte((uint8_t)r);
    }
}

// process one byte received on serial port
// state is stored in _msg structure
void AP_Proximity_LightWareSF40C::parse_byte(uint8_t b)
{
    // check that payload buffer is large enough
    static_assert(ARRAY_SIZE(_msg.payload) == PROXIMITY_SF40C_PAYLOAD_LEN_MAX, "AP_Proximity_LightWareSF40C: check _msg.payload array size");

    // process byte depending upon current state
    switch (_msg.state) {

    case ParseState::HEADER:
        if (b == PROXIMITY_SF40C_HEADER) {
            _msg.crc_expected = crc_xmodem_update(0, b);
            _msg.state = ParseState::FLAGS_L;
        }
        break;

    case ParseState::FLAGS_L:
        _msg.flags_low = b;
        _msg.crc_expected = crc_xmodem_update(_msg.crc_expected, b);
        _msg.state = ParseState::FLAGS_H;
        break;

    case ParseState::FLAGS_H:
        _msg.flags_high = b;
        _msg.crc_expected = crc_xmodem_update(_msg.crc_expected, b);
        _msg.payload_len = UINT16_VALUE(_msg.flags_high, _msg.flags_low) >> 6;
        if ((_msg.payload_len == 0) || (_msg.payload_len > PROXIMITY_SF40C_PAYLOAD_LEN_MAX)) {
            // invalid payload length, abandon message
            _msg.state = ParseState::HEADER;
        } else {
            _msg.state = ParseState::MSG_ID;
        }
        break;

    case ParseState::MSG_ID:
        _msg.msgid = (MessageID)b;
        _msg.crc_expected = crc_xmodem_update(_msg.crc_expected, b);
        if (_msg.payload_len > 1) {
            _msg.state = ParseState::PAYLOAD;
        } else {
            _msg.state = ParseState::CRC_L;
        }
        _msg.payload_recv = 0;
        break;

    case ParseState::PAYLOAD:
        if (_msg.payload_recv < (_msg.payload_len - 1)) {
            _msg.payload[_msg.payload_recv] = b;
            _msg.payload_recv++;
            _msg.crc_expected = crc_xmodem_update(_msg.crc_expected, b);
        }
        if (_msg.payload_recv >= (_msg.payload_len - 1)) {
            _msg.state = ParseState::CRC_L;
        }
        break;

    case ParseState::CRC_L:
        _msg.crc_low = b;
        _msg.state = ParseState::CRC_H;
        break;

    case ParseState::CRC_H:
        _msg.crc_high = b;
        if (_msg.crc_expected == UINT16_VALUE(_msg.crc_high, _msg.crc_low)) {
            process_message();
            _last_reply_ms = AP_HAL::millis();
        }
        _msg.state = ParseState::HEADER;
        break;
    }
}

// process the latest message held in the _msg structure
void AP_Proximity_LightWareSF40C::process_message()
{
    // process payload
    switch (_msg.msgid) {
    case MessageID::TOKEN:
        // copy token into _sensor_state.token variable
        if (_msg.payload_recv == ARRAY_SIZE(_sensor_state.token)) {
            memcpy(_sensor_state.token, _msg.payload, ARRAY_SIZE(_sensor_state.token));
        }
        break;
    case MessageID::RESET:
        // no need to do anything
        break;
    case MessageID::STREAM:
        if (_msg.payload_recv == sizeof(uint32_t)) {
            _sensor_state.streaming = (buff_to_uint32(_msg.payload[0], _msg.payload[1], _msg.payload[2], _msg.payload[3]) == 3);
        }
        break;
    case MessageID::DISTANCE_OUTPUT: {
        _last_distance_received_ms = AP_HAL::millis();
        const uint16_t point_total = buff_to_uint16(_msg.payload[8], _msg.payload[9]);
        const uint16_t point_count = buff_to_uint16(_msg.payload[10], _msg.payload[11]);
        const uint16_t point_start_index = buff_to_uint16(_msg.payload[12], _msg.payload[13]);
        // sanity check point_total
        if (point_total == 0) {
            break;
        }

        // prepare to push to object database
        Vector3f current_pos;
        Matrix3f body_to_ned;
        const bool database_ready = database_prepare_for_push(current_pos, body_to_ned);

        // process each point
        const float angle_inc_deg = (1.0f / point_total) * 360.0f;
        const float angle_sign = (params.orientation == 1) ? -1.0f : 1.0f;
        const float angle_correction = params.yaw_correction;
        const uint16_t dist_min_cm = distance_min() * 100;
        const uint16_t dist_max_cm = distance_max() * 100;

        // mini sectors are used to combine several readings together
        uint8_t combined_count = 0;
        float combined_angle_deg = 0;
        float combined_dist_m = INT16_MAX;
        for (uint16_t i = 0; i < point_count; i++) {
            const uint16_t idx = 14 + (i * 2);
            const int16_t dist_cm = (int16_t)buff_to_uint16(_msg.payload[idx], _msg.payload[idx+1]);
            const float angle_deg = wrap_360((point_start_index + i) * angle_inc_deg * angle_sign + angle_correction);
            const AP_Proximity_Boundary_3D::Face face = frontend.boundary.get_face(angle_deg);

            // if point is on a new face then finish off previous face
            if (face != _face) {
                // update boundary used for avoidance
                if (_face_distance_valid) {
                    frontend.boundary.set_face_attributes(_face, _face_yaw_deg, _face_distance, state.instance);
                } else {
                    // mark previous face invalid
                    frontend.boundary.reset_face(_face, state.instance);
                }
                // init for new face
                _face = face;
                _face_distance_valid = false;
            }

            // check reading is not within an ignore zone
            const float dist_m = dist_cm * 0.01f;
            if (!ignore_reading(angle_deg, dist_m)) {
                // check distance reading is valid
                if ((dist_cm >= dist_min_cm) && (dist_cm <= dist_max_cm)) {
                    // update shortest distance for this face
                    if (!_face_distance_valid || dist_m < _face_distance) {
                        _face_distance = dist_m;
                        _face_distance_valid = true;
                    }

                    // calculate shortest of last few readings
                    if (dist_m < combined_dist_m) {
                        combined_dist_m = dist_m;
                        combined_angle_deg = angle_deg;
                    }
                    combined_count++;
                }
            }

            // send combined distance to object database
            if ((i+1 >= point_count) || (combined_count >= PROXIMITY_SF40C_COMBINE_READINGS)) {
                if ((combined_dist_m < INT16_MAX) && database_ready) {
                    database_push(combined_angle_deg, combined_dist_m, _last_distance_received_ms, current_pos,body_to_ned);
                }
                combined_count = 0;
                combined_dist_m = INT16_MAX;
            }
        }
        break;
    }
    case MessageID::MOTOR_STATE:
        if (_msg.payload_recv == 1) {
            _sensor_state.motor_state = (MotorState)_msg.payload[0];
        }
        break;
    case MessageID::OUTPUT_RATE:
        if (_msg.payload_recv == 1) {
            _sensor_state.output_rate = _msg.payload[0];
        }
        break;

    // unsupported messages
    case MessageID::PRODUCT_NAME:
    case MessageID::HARDWARE_VERSION:
    case MessageID::FIRMWARE_VERSION:
    case MessageID::SERIAL_NUMBER:
    case MessageID::TEXT_MESSAGE:
    case MessageID::USER_DATA:
    case MessageID::SAVE_PARAMETERS:
    case MessageID::STAGE_FIRMWARE:
    case MessageID::COMMIT_FIRMWARE:
    case MessageID::INCOMING_VOLTAGE:
    case MessageID::LASER_FIRING:
    case MessageID::TEMPERATURE:
    case MessageID::BAUD_RATE:
    case MessageID::DISTANCE:
    case MessageID::MOTOR_VOLTAGE:
    case MessageID::FORWARD_OFFSET:
    case MessageID::REVOLUTIONS:
    case MessageID::ALARM_STATE:
    case MessageID::ALARM1:
    case MessageID::ALARM2:
    case MessageID::ALARM3:
    case MessageID::ALARM4:
    case MessageID::ALARM5:
    case MessageID::ALARM6:
    case MessageID::ALARM7:
        break;
    }
}

// convert buffer to uint32, uint16
uint32_t AP_Proximity_LightWareSF40C::buff_to_uint32(uint8_t b0, uint8_t b1, uint8_t b2, uint8_t b3) const
{
    uint32_t leval = (uint32_t)b0 | (uint32_t)b1 << 8 | (uint32_t)b2 << 16 | (uint32_t)b3 << 24;
    return leval;
}

uint16_t AP_Proximity_LightWareSF40C::buff_to_uint16(uint8_t b0, uint8_t b1) const
{
    uint16_t leval = (uint16_t)b0 | (uint16_t)b1 << 8;
    return leval;
}

#endif // AP_PROXIMITY_LIGHTWARE_SF40C_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   #pragma once

#include "AP_Proximity_config.h"

#if AP_PROXIMITY_LIGHTWARE_SF40C_ENABLED

#include "AP_Proximity_Backend_Serial.h"

#define PROXIMITY_SF40C_TIMEOUT_MS            200   // requests timeout after 0.2 seconds
#define PROXIMITY_SF40C_PAYLOAD_LEN_MAX       256   // maximum payload size we can accept (in some configurations sensor may send as large as 1023)
#define PROXIMITY_SF40C_COMBINE_READINGS        7   // combine this many readings together to improve efficiency

class AP_Proximity_LightWareSF40C : public AP_Proximity_Backend_Serial
{

public:
    // constructor
    using AP_Proximity_Backend_Serial::AP_Proximity_Backend_Serial;

    uint16_t rxspace() const override {
        return 1280;
    };

    // update state
    void update(void) override;

    // get maximum and minimum distances (in meters) of sensor
    float distance_max() const override { return 100.0f; }
    float distance_min() const override { return 0.20f; }

private:

    // initialise sensor
    void initialise();

    // restart sensor and re-init our state
    void restart_sensor();

    // message ids
    enum class MessageID : uint8_t {
        PRODUCT_NAME = 0,
        HARDWARE_VERSION = 1,
        FIRMWARE_VERSION = 2,
        SERIAL_NUMBER = 3,
        TEXT_MESSAGE = 7,
        USER_DATA = 9,
        TOKEN = 10,
        SAVE_PARAMETERS = 12,
        RESET = 14,
        STAGE_FIRMWARE = 16,
        COMMIT_FIRMWARE = 17,
        INCOMING_VOLTAGE = 20,
        STREAM = 30,
        DISTANCE_OUTPUT = 48,
        LASER_FIRING = 50,
        TEMPERATURE = 55,
        BAUD_RATE = 90,
        DISTANCE = 105,
        MOTOR_STATE = 106,
        MOTOR_VOLTAGE = 107,
        OUTPUT_RATE = 108,
        FORWARD_OFFSET = 109,
        REVOLUTIONS = 110,
        ALARM_STATE = 111,
        ALARM1 = 112,
        ALARM2 = 113,
        ALARM3 = 114,
        ALARM4 = 115,
        ALARM5 = 116,
        ALARM6 = 117,
        ALARM7 = 118
    };

    // motor states
    enum class MotorState : uint8_t {
        UNKNOWN = 0,
        PREPARING_FOR_STARTUP = 1,
        WAITING_FOR_FIVE_REVS = 2,
        RUNNING_NORMALLY = 3,
        FAILED_TO_COMMUNICATE = 4
    };

    // send message to sensor
    void send_message(MessageID msgid, bool write, const uint8_t *payload, uint16_t payload_len);

    // request motor state
    void request_motor_state();

    // request start of streaming of distances
    void request_stream_start();

    // request token of sensor (required for reset)
    void request_token();
    bool got_token() const { return (_sensor_state.token[0] != 0 || _sensor_state.token[1] != 0); }
    void clear_token() { memset(_sensor_state.token, 0, ARRAY_SIZE(_sensor_state.token)); }

    // request reset of sensor
    void request_reset();

    // check and process replies from sensor
    void process_replies();

    // process one byte received on serial port
    // state is stored in msg structure.  when a full package is received process_message is called
    void parse_byte(uint8_t b);

    // process the latest message held in the msg structure
    void process_message();

    // internal variables
    uint32_t _last_request_ms;              // system time of last request
    uint32_t _last_reply_ms;                // system time of last valid reply
    uint32_t _last_restart_ms;              // system time we restarted the sensor
    uint32_t _last_distance_received_ms;    // system time of last distance measurement received from sensor
    AP_Proximity_Boundary_3D::Face _face;   // face of _face_distance
    float _face_distance;                   // shortest distance (in meters) on face
    float _face_yaw_deg;                    // yaw angle (in degrees) of shortest distance on face
    bool _face_distance_valid;              // true if face has at least one valid distance

    // state of sensor
    struct {
        MotorState motor_state; // motor state (1=starting-up,2=waiting for first 5 revs, 3=normal, 4=comm failure)
        uint8_t output_rate;    // output rate number (0 = 20010, 1 = 10005, 2 = 6670, 3 = 2001)
        bool streaming;         // true if distance messages are being streamed
        uint8_t token[2];       // token (supplied by sensor) required for reset
    } _sensor_state;

    enum class ParseState {
        HEADER = 0,
        FLAGS_L,
        FLAGS_H,
        MSG_ID,
        PAYLOAD,
        CRC_L,
        CRC_H
    };

    // structure holding latest message contents
    struct {
        ParseState state;       // state of incoming message processing
        uint8_t flags_low;      // flags low byte
        uint8_t flags_high;     // flags high byte
        uint16_t payload_len;   // latest message payload length (1+ bytes in payload)
        uint8_t payload[PROXIMITY_SF40C_PAYLOAD_LEN_MAX];   // payload
        MessageID msgid;        // latest message's message id
        uint16_t payload_recv;  // number of message's payload bytes received so far
        uint8_t crc_low;        // crc low byte
        uint8_t crc_high;       // crc high byte
        uint16_t crc_expected;  // latest message's expected crc
    } _msg;

    // convert buffer to uint32, uint16
    uint32_t buff_to_uint32(uint8_t b0, uint8_t b1, uint8_t b2, uint8_t b3) const;
    uint16_t buff_to_uint16(uint8_t b0, uint8_t b1) const;
};

#endif // AP_PROXIMITY_LIGHTWARE_SF40C_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              /*
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.

   The Lightware SF45B serial interface is described on this wiki page
   http://support.lightware.co.za/sf45/#/commands
 */

#include "AP_Proximity_config.h"

#if AP_PROXIMITY_LIGHTWARE_SF45B_ENABLED

#include "AP_Proximity_LightWareSF45B.h"

#include <AP_Common/AP_Common.h>
#include <AP_HAL/AP_HAL.h>
#include <AP_HAL/utility/sparse-endian.h>

extern const AP_HAL::HAL& hal;

static const uint32_t PROXIMITY_SF45B_TIMEOUT_MS = 200;
static const uint32_t PROXIMITY_SF45B_REINIT_INTERVAL_MS = 5000;    // re-initialise sensor after this many milliseconds
static const float PROXIMITY_SF45B_COMBINE_READINGS_DEG = 5.0f;     // combine readings from within this many degrees to improve efficiency
static const uint32_t PROXIMITY_SF45B_STREAM_DISTANCE_DATA_CM = 5;
static const uint8_t PROXIMITY_SF45B_DESIRED_UPDATE_RATE = 6;       // 1:48hz, 2:55hz, 3:64hz, 4:77hz, 5:97hz, 6:129hz, 7:194hz, 8:388hz
static const uint32_t PROXIMITY_SF45B_DESIRED_FIELDS = ((uint32_t)1 << 0 | (uint32_t)1 << 8);   // first return (unfiltered), yaw angle
static const uint16_t PROXIMITY_SF45B_DESIRED_FIELD_COUNT = 2;      // DISTANCE_DATA_CM message should contain two fields

// update the state of the sensor
void AP_Proximity_LightWareSF45B::update(void)
{
    if (_uart == nullptr) {
        return;
    }

    // initialise sensor if necessary
    initialise();

    // process incoming messages
    process_replies();

    // check for timeout and set health status
    if ((_last_distance_received_ms == 0) || ((AP_HAL::millis() - _last_distance_received_ms) > PROXIMITY_SF45B_TIMEOUT_MS)) {
        set_status(AP_Proximity::Status::NoData);
    } else {
        set_status(AP_Proximity::Status::Good);
    }
}

// initialise sensor
void AP_Proximity_LightWareSF45B::initialise()
{
    // check sensor is configured correctly
    _init_complete = (_sensor_state.stream_data_type == PROXIMITY_SF45B_STREAM_DISTANCE_DATA_CM) &&
                     (_sensor_state.update_rate == PROXIMITY_SF45B_DESIRED_UPDATE_RATE) &&
                     (_sensor_state.streaming_fields == PROXIMITY_SF45B_DESIRED_FIELDS);

    // exit if initialisation requests have been sent within the last few seconds
    uint32_t now_ms = AP_HAL::millis();
    if ((now_ms - _last_init_ms) < PROXIMITY_SF45B_REINIT_INTERVAL_MS) {
        return;
    }
    _last_init_ms = now_ms;

    // request stream rate and contents
    request_stream_start();
}

// request start of streaming of distances
void AP_Proximity_LightWareSF45B::request_stream_start()
{
    // request output rate
    send_message((uint8_t)MessageID::UPDATE_RATE, true, &PROXIMITY_SF45B_DESIRED_UPDATE_RATE, sizeof(PROXIMITY_SF45B_DESIRED_UPDATE_RATE));

    // request first return (unfiltered), and yaw angle
    send_message((uint8_t)MessageID::DISTANCE_OUTPUT, true, (const uint8_t*)&PROXIMITY_SF45B_DESIRED_FIELDS, sizeof(PROXIMITY_SF45B_DESIRED_FIELDS));

    // request start streaming of DISTANCE_DATA_CM messages
    send_message((uint8_t)MessageID::STREAM, true, (const uint8_t*)&PROXIMITY_SF45B_STREAM_DISTANCE_DATA_CM, sizeof(PROXIMITY_SF45B_STREAM_DISTANCE_DATA_CM));
}

// check for replies from sensor
void AP_Proximity_LightWareSF45B::process_replies()
{
    if (_uart == nullptr) {
        return;
    }

    // process up to 1K of characters per iteration
    uint32_t nbytes = MIN(_uart->available(), 1024U);
    while (nbytes-- > 0) {
        uint8_t c;
        if (!_uart->read(c)) {
            continue;
        }
        if (parse_byte(c)) {
            process_message();
        }
    }
}

// process the latest message held in the _msg structure
void AP_Proximity_LightWareSF45B::process_message()
{
    // process payload
    switch ((MessageID)_msg.msgid) {

    case MessageID::DISTANCE_OUTPUT:
        if (_payload_recv == sizeof(uint32_t)) {
            _sensor_state.streaming_fields = UINT32_VALUE(_msg.payload[3], _msg.payload[2], _msg.payload[1], _msg.payload[0]);
        }
        break;

    case MessageID::STREAM:
        if (_payload_recv == sizeof(uint32_t)) {
            _sensor_state.stream_data_type = UINT32_VALUE(_msg.payload[3], _msg.payload[2], _msg.payload[1], _msg.payload[0]);
        }
        break;

    case MessageID::UPDATE_RATE:
        if (_payload_recv == 1) {
            _sensor_state.update_rate = _msg.payload[0];
        }
        break;

    case MessageID::DISTANCE_DATA_CM: {
        // ignore distance messages until initialisation is complete
        if (!_init_complete || (_payload_recv != (PROXIMITY_SF45B_DESIRED_FIELD_COUNT * 2))) {
            break;
        }
        _last_distance_received_ms = AP_HAL::millis();
        const float distance_m = _distance_filt.apply((int16_t)UINT16_VALUE(_msg.payload[1], _msg.payload[0])) * 0.01f;
        const float angle_deg = correct_angle_for_orientation((int16_t)UINT16_VALUE(_msg.payload[3], _msg.payload[2]) * 0.01f);

        // if distance is from a new face then update distance, angle and boundary for previous face
        // get face from 3D boundary based on yaw angle to the object
        const AP_Proximity_Boundary_3D::Face face = frontend.boundary.get_face(angle_deg);
        if (face != _face) {
            if (_face_distance_valid) {
                frontend.boundary.set_face_attributes(_face, _face_yaw_deg, _face_distance, state.instance);
            } else {
                // mark previous face invalid
                frontend.boundary.reset_face(_face, state.instance);
            }
            // record updated face
            _face = face;
            _face_yaw_deg = 0;
            _face_distance = INT16_MAX;
            _face_distance_valid = false;
        }

        // if distance is from a new minisector then update obstacle database using angle and distance from previous minisector
        const uint8_t minisector = convert_angle_to_minisector(angle_deg);
        if (minisector != _minisector) {
            if ((_minisector != UINT8_MAX) && _minisector_distance_valid) {
                database_push(_minisector_angle, _minisector_distance);
            }
            // init mini sector
            _minisector = minisector;
            _minisector_angle = 0;
            _minisector_distance = INT16_MAX;
            _minisector_distance_valid = false;
        }

        // check reading is valid
        if (!ignore_reading(angle_deg, distance_m) && (distance_m >= distance_min()) && (distance_m <= distance_max())) {
            // update shortest distance for this face
            if (!_face_distance_valid || (distance_m < _face_distance)) {
                _face_yaw_deg = angle_deg;
                _face_distance = distance_m;
                _face_distance_valid = true;
            }

            // update shortest distance for this mini sector
            if (distance_m < _minisector_distance) {
                _minisector_angle = angle_deg;
                _minisector_distance = distance_m;
                _minisector_distance_valid = true;
            }
        }
        break;
    }

    default:
        // ignore unsupported messages
        break;
    }
}

// convert an angle (in degrees) to a mini sector number
uint8_t AP_Proximity_LightWareSF45B::convert_angle_to_minisector(float angle_deg) const
{
    return wrap_360(angle_deg + (PROXIMITY_SF45B_COMBINE_READINGS_DEG * 0.5f)) / PROXIMITY_SF45B_COMBINE_READINGS_DEG;
}

#endif // AP_PROXIMITY_LIGHTWARE_SF45B_ENABLED
                                                                                                                                                      #pragma once

#include "AP_Proximity_config.h"

#if AP_PROXIMITY_LIGHTWARE_SF45B_ENABLED

#include "AP_Proximity_LightWareSerial.h"

#include <Filter/Filter.h>

class AP_Proximity_LightWareSF45B : public AP_Proximity_LightWareSerial
{

public:
    // constructor
    AP_Proximity_LightWareSF45B(AP_Proximity &_frontend,
                                AP_Proximity::Proximity_State &_state,
                                AP_Proximity_Params& _params,
                                uint8_t serial_instance) :
            AP_Proximity_LightWareSerial(_frontend, _state, _params, serial_instance) {}

    uint16_t rxspace() const override {
        return 1280;
    };

    // update state
    void update(void) override;

    // get maximum and minimum distances (in meters) of sensor
    float distance_max() const override { return 50.0f; }
    float distance_min() const override { return 0.20f; }

private:

    // message ids
    enum class MessageID : uint8_t {
        PRODUCT_NAME = 0,
        HARDWARE_VERSION = 1,
        FIRMWARE_VERSION = 2,
        SERIAL_NUMBER = 3,
        TEXT_MESSAGE = 7,
        USER_DATA = 9,
        TOKEN = 10,
        SAVE_PARAMETERS = 12,
        RESET = 14,
        STAGE_FIRMWARE = 16,
        COMMIT_FIRMWARE = 17,
        DISTANCE_OUTPUT = 27,
        STREAM = 30,
        DISTANCE_DATA_CM = 44,
        DISTANCE_DATA_MM = 45,
        LASER_FIRING = 50,
        TEMPERATURE = 57,
        UPDATE_RATE = 66,
        NOISE = 74,
        ZERO_OFFSET = 75,
        LOST_SIGNAL_COUNTER = 76,
        BAUD_RATE = 79,
        I2C_ADDRESS = 80,
        STEPPER_STATUS = 93,
        SCAN_ON_STARTUP = 94,
        SCAN_ENABLE = 96,
        SCAN_POSITION = 97,
        SCAN_LOW_ANGLE = 98,
        SCAN_HIGH_ANGLE = 99
    };

    // initialise sensor
    void initialise();

    // request start of streaming of distances
    void request_stream_start();

    // check and process replies from sensor
    void process_replies();

    // process the latest message held in the msg structure
    void process_message();

    // convert an angle (in degrees) to a mini sector number
    uint8_t convert_angle_to_minisector(float angle_deg) const;

    // internal variables
    uint32_t _last_init_ms;                 // system time of last re-initialisation
    uint32_t _last_distance_received_ms;    // system time of last distance measurement received from sensor
    bool _init_complete;                    // true once sensor initialisation is complete
    ModeFilterInt16_Size3 _distance_filt{1};// mode filter to reduce glitches

    // 3D boundary face and distance for latest readings
    AP_Proximity_Boundary_3D::Face _face;   // face of most recently received distance
    float _face_distance;                   // shortest distance (in meters) on face
    float _face_yaw_deg;                    // yaw angle (in degrees) of shortest distance on face
    bool _face_distance_valid;              // true if face has at least one valid distance

    // mini sector (5 degrees) angles and distances (used to populate obstacle database for path planning)
    uint8_t _minisector = UINT8_MAX;        // mini sector number (from 0 to 71) of most recently received distance
    float _minisector_distance;             // shortest distance (in meters) in mini sector
    float _minisector_angle;                // angle (in degrees) of shortest distance in mini sector
    bool _minisector_distance_valid;        // true if mini sector has at least one valid distance

    // state of sensor
    struct {
        uint8_t update_rate;        // sensor reported update rate enum from UPDATE_RATE message
        uint32_t streaming_fields;  // sensor reported bitmask of fields sent in DISTANCE_DATA_CM message
        uint32_t stream_data_type;  // sensor reported stream value.  5 if DISTANCE_DATA_CM messages are being streamed
    } _sensor_state;

};

#endif // AP_PROXIMITY_LIGHTWARE_SF45B_ENABLED
                                                                                                                                                           /*
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include "AP_Proximity_LightWareSerial.h"

#if HAL_PROXIMITY_ENABLED
#include <AP_Common/AP_Common.h>
#include <AP_HAL/AP_HAL.h>
#include <AP_HAL/utility/sparse-endian.h>
#include <AP_Math/crc.h>
#include <GCS_MAVLink/GCS.h>

extern const AP_HAL::HAL& hal;

#define PROXIMITY_LIGHTWARE_HEADER    0xAA

// send message to sensor
void AP_Proximity_LightWareSerial::send_message(uint8_t msgid, bool write, const uint8_t *payload, uint16_t payload_len)
{
    if ((_uart == nullptr) || (payload_len > PROXIMITY_LIGHTWARE_PAYLOAD_LEN_MAX)) {
        return;
    }

    // check for sufficient space in outgoing buffer
    if (_uart->txspace() < payload_len + 6U) {
        return;
    }

    // write header
    _uart->write((uint8_t)PROXIMITY_LIGHTWARE_HEADER);
    uint16_t crc = crc_xmodem_update(0, PROXIMITY_LIGHTWARE_HEADER);

    // write flags including payload length
    const uint16_t flags = ((payload_len+1) << 6) | (write ? 0x01 : 0);
    _uart->write(LOWBYTE(flags));
    crc = crc_xmodem_update(crc, LOWBYTE(flags));
    _uart->write(HIGHBYTE(flags));
    crc = crc_xmodem_update(crc, HIGHBYTE(flags));

    // msgid
    _uart->write(msgid);
    crc = crc_xmodem_update(crc, msgid);

    // payload
    if ((payload_len > 0) && (payload != nullptr)) {
        for (uint16_t i = 0; i < payload_len; i++) {
            _uart->write(payload[i]);
            crc = crc_xmodem_update(crc, payload[i]);
        }
    }

    // checksum
    _uart->write(LOWBYTE(crc));
    _uart->write(HIGHBYTE(crc));
}

// process one byte received on serial port
// returns true if a complete message has been received
// state is stored in _msg structure
bool AP_Proximity_LightWareSerial::parse_byte(uint8_t b)
{
    // check that payload buffer is large enough
    static_assert(ARRAY_SIZE(_msg.payload) == PROXIMITY_LIGHTWARE_PAYLOAD_LEN_MAX, "AP_Proximity_LightWareSerial: check _msg.payload array size");

    // process byte depending upon current state
    switch (_parse_state) {

    case ParseState::HEADER:
        if (b == PROXIMITY_LIGHTWARE_HEADER) {
            _crc_expected = crc_xmodem_update(0, b);
            _parse_state = ParseState::FLAGS_L;
        }
        break;

    case ParseState::FLAGS_L:
        _msg.flags_low = b;
        _crc_expected = crc_xmodem_update(_crc_expected, b);
        _parse_state = ParseState::FLAGS_H;
        break;

    case ParseState::FLAGS_H:
        _msg.flags_high = b;
        _crc_expected = crc_xmodem_update(_crc_expected, b);
        _msg.payload_len = UINT16_VALUE(_msg.flags_high, _msg.flags_low) >> 6;
        if ((_msg.payload_len == 0) || (_msg.payload_len > PROXIMITY_LIGHTWARE_PAYLOAD_LEN_MAX)) {
            // invalid payload length, abandon message
            _parse_state = ParseState::HEADER;
        } else {
            _parse_state = ParseState::MSG_ID;
        }
        break;

    case ParseState::MSG_ID:
        _msg.msgid = b;
        _crc_expected = crc_xmodem_update(_crc_expected, b);
        if (_msg.payload_len > 1) {
            _parse_state = ParseState::PAYLOAD;
        } else {
            _parse_state = ParseState::CRC_L;
        }
        _payload_recv = 0;
        break;

    case ParseState::PAYLOAD:
        if (_payload_recv < (_msg.payload_len - 1)) {
            _msg.payload[_payload_recv] = b;
            _payload_recv++;
            _crc_expected = crc_xmodem_update(_crc_expected, b);
        }
        if (_payload_recv >= (_msg.payload_len - 1)) {
            _parse_state = ParseState::CRC_L;
        }
        break;

    case ParseState::CRC_L:
        _msg.crc_low = b;
        _parse_state = ParseState::CRC_H;
        break;

    case ParseState::CRC_H:
        _parse_state = ParseState::HEADER;
        _msg.crc_high = b;
        if (_crc_expected == UINT16_VALUE(_msg.crc_high, _msg.crc_low)) {
            return true;
        }
        break;
    }

    return false;
}

#endif // HAL_PROXIMITY_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       #pragma once

#include "AP_Proximity_Backend_Serial.h"

#if HAL_PROXIMITY_ENABLED
#define PROXIMITY_LIGHTWARE_PAYLOAD_LEN_MAX 256 // maximum payload size we can accept (in some configurations sensor may send as large as 1023)

class AP_Proximity_LightWareSerial : public AP_Proximity_Backend_Serial
{

public:
    // constructor
    using AP_Proximity_Backend_Serial::AP_Proximity_Backend_Serial;

protected:

    // initialise sensor
    void initialise();

    // send message to sensor
    void send_message(uint8_t msgid, bool write, const uint8_t *payload, uint16_t payload_len);

    // process one byte received on serial port
    // returns true if a complete message has been received
    // state is stored in _msg structure
    bool parse_byte(uint8_t b);

    enum class ParseState {
        HEADER = 0,
        FLAGS_L,
        FLAGS_H,
        MSG_ID,
        PAYLOAD,
        CRC_L,
        CRC_H
    } _parse_state; // state of incoming message processing
    uint16_t _payload_recv;     // number of message's payload bytes received so far
    uint16_t _crc_expected;     // latest message's expected crc

    // structure holding latest message contents
    struct {
        uint8_t flags_low;      // flags low byte
        uint8_t flags_high;     // flags high byte
        uint16_t payload_len;   // latest message payload length (1+ bytes in payload)
        uint8_t payload[PROXIMITY_LIGHTWARE_PAYLOAD_LEN_MAX];   // payload
        uint8_t msgid;          // latest message's message id
        uint8_t crc_low;        // crc low byte
        uint8_t crc_high;       // crc high byte
    } _msg;
};

#endif // HAL_PROXIMITY_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        #pragma once

#include "AP_Proximity_config.h"

#if AP_PROXIMITY_MAV_ENABLED

#include "AP_Proximity_Backend.h"

class AP_Proximity_MAV : public AP_Proximity_Backend
{

public:
    // constructor
    using AP_Proximity_Backend::AP_Proximity_Backend;

    // update state
    void update(void) override;

    // get maximum and minimum distances (in meters) of sensor
    float distance_max() const override { return _distance_max; }
    float distance_min() const override { return _distance_min; };

    // get distance upwards in meters. returns true on success
    bool get_upward_distance(float &distance) const override;

    // handle mavlink messages
    void handle_msg(const mavlink_message_t &msg) override;

private:

    // handle mavlink DISTANCE_SENSOR messages
    void handle_distance_sensor_msg(const mavlink_message_t &msg);
    // handle mavlink OBSTACLE_DISTANCE messages
    void handle_obstacle_distance_msg(const mavlink_message_t &msg);
    // handle mavlink OBSTACLE_DISTANCE_3D messages
    void handle_obstacle_distance_3d_msg(const mavlink_message_t &msg);

   AP_Proximity_Temp_Boundary temp_boundary;

    // horizontal distance support
    uint32_t _last_update_ms;   // system time of last mavlink message received
    uint32_t _last_msg_update_timestamp_ms;   // last stored mavlink message timestamp
    float _distance_max;        // max range of sensor in meters
    float _distance_min;        // min range of sensor in meters

    // upward distance support
    uint32_t _last_upward_update_ms;    // system time of last update of upward distance
    float _distance_upward;             // upward distance in meters
};

#endif // AP_PROXIMITY_MAV_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   /*
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
#include "AP_Proximity_config.h"

#if AP_PROXIMITY_MR72_ENABLED

#include <AP_HAL/AP_HAL.h>
#include <AP_BoardConfig/AP_BoardConfig.h>
#include "AP_Proximity_MR72_CAN.h"

const AP_Param::GroupInfo AP_Proximity_MR72_CAN::var_info[] = {

    // @Param: RECV_ID
    // @DisplayName: CAN receive ID
    // @Description: The receive ID of the CAN frames. A value of zero means all IDs are accepted.
    // @Range: 0 65535
    // @User: Advanced
    AP_GROUPINFO("RECV_ID", 1, AP_Proximity_MR72_CAN, receive_id, 0),

    AP_GROUPEND
};

AP_Proximity_MR72_CAN::AP_Proximity_MR72_CAN(AP_Proximity &_frontend,
                                     AP_Proximity::Proximity_State &_state,
                                     AP_Proximity_Params& _params):
    AP_Proximity_Backend(_frontend, _state, _params)
{
    multican_MR72 = NEW_NOTHROW MultiCAN{FUNCTOR_BIND_MEMBER(&AP_Proximity_MR72_CAN::handle_frame, bool, AP_HAL::CANFrame &), AP_CAN::Protocol::NanoRadar, "MR72 MultiCAN"};
    if (multican_MR72 == nullptr) {
        AP_BoardConfig::allocation_error("Failed to create proximity multican");
    }

    AP_Param::setup_object_defaults(this, var_info);
    state.var_info = var_info;
}

// update state
void AP_Proximity_MR72_CAN::update(void)
{
    WITH_SEMAPHORE(_sem);
    const uint32_t now = AP_HAL::millis();
    if (now - last_update_ms > 500) {
        // no new data.
        set_status(AP_Proximity::Status::NoData);
    } else {
        set_status(AP_Proximity::Status::Good);
    }
}

// handler for incoming frames. These come in at 100Hz
bool AP_Proximity_MR72_CAN::handle_frame(AP_HAL::CANFrame &frame)
{
    WITH_SEMAPHORE(_sem);


    // check if message is coming from the right sensor ID
    const uint16_t id = frame.id;

    if (receive_id > 0 && (get_radar_id(frame.id) != uint32_t(receive_id))) {
        return false;
    }

    switch (id & 0xFU) {
    case 0xAU:
        // number of objects
        _object_count = frame.data[0];
        _current_object_index = 0;
        _temp_boundary.update_3D_boundary(state.instance, frontend.boundary);
        _temp_boundary.reset();
        last_update_ms = AP_HAL::millis();
        break;
    case 0xBU:
        // obstacle data
        parse_distance_message(frame);
        break;
    default:
        break;
    }

    return true;

}

// parse a distance message from CAN frame
bool AP_Proximity_MR72_CAN::parse_distance_message(AP_HAL::CANFrame &frame)
{
    if (_current_object_index >= _object_count) {
        // should never happen
        return false;
    }
    _current_object_index++;

    Vector2f obstacle_fr;
    // This parsing comes from the NanoRadar MR72 datasheet
    obstacle_fr.x = ((frame.data[2] & 0x07U) * 256 + frame.data[3]) * 0.2 - 204.6;
    obstacle_fr.y = (frame.data[1] * 32 + (frame.data[2] >> 3)) * 0.2 - 500;
    const float yaw = correct_angle_for_orientation(wrap_360(degrees(atan2f(obstacle_fr.x, obstacle_fr.y))));

    const float objects_dist = obstacle_fr.length();

    if (ignore_reading(yaw, objects_dist)) {
        // obstacle is probably near ground or out of range
        return false;
    }

    const AP_Proximity_Boundary_3D::Face face = frontend.boundary.get_face(yaw);
    _temp_boundary.add_distance(face, yaw, objects_dist);
    return true;
}

#endif // HAL_PROXIMITY_ENABLED
                                                                                                                                                #pragma once
#include "AP_Proximity_config.h"

#if AP_PROXIMITY_MR72_ENABLED

#include "AP_Proximity.h"
#include "AP_Proximity_Backend.h"
#include <AP_HAL/AP_HAL.h>
#include <AP_CANManager/AP_CANSensor.h>

#define MR72_MAX_RANGE_M             50.0f   // max range of the sensor in meters
#define MR72_MIN_RANGE_M             0.2f   // min range of the sensor in meters

class MR72_MultiCAN;

class AP_Proximity_MR72_CAN : public AP_Proximity_Backend {
public:
    friend class MR72_MultiCAN;

    AP_Proximity_MR72_CAN(AP_Proximity &_frontend, AP_Proximity::Proximity_State &_state, AP_Proximity_Params& _params);

    void update() override;

    // handler for incoming frames. Return true if consumed
    bool handle_frame(AP_HAL::CANFrame &frame);

    // parse a distance message from CAN frame
    bool parse_distance_message(AP_HAL::CANFrame &frame);

    // get maximum and minimum distances (in meters) of sensor
    float distance_max() const override { return MR72_MAX_RANGE_M; }
    float distance_min() const override { return MR72_MIN_RANGE_M; }

    static const struct AP_Param::GroupInfo var_info[];

    AP_Proximity_Temp_Boundary _temp_boundary;

private:

    uint32_t get_radar_id(uint32_t id) const { return ((id & 0xF0U) >> 4U); }

    uint32_t _object_count;             // total number of objects to read
    uint32_t _current_object_index;     // current object index
    uint32_t last_update_ms;            // last update time in ms

    AP_Int32 receive_id;                // ID of the sensor

    MultiCAN* multican_MR72;            // Allows for multiple CAN rangefinders on a single bus
};

#endif // HAL_PROXIMITY_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          #include "AP_Proximity_Params.h"

// table of user settable parameters
const AP_Param::GroupInfo AP_Proximity_Params::var_info[] = {

    // 0 should not be used

    // @Param: _TYPE
    // @DisplayName: Proximity type
    // @Description: What type of proximity sensor is connected
    // @Values: 0:None,7:LightwareSF40c,2:MAVLink,3:TeraRangerTower,4:RangeFinder,5:RPLidarA2,6:TeraRangerTowerEvo,8:LightwareSF45B,10:SITL,12:AirSimSITL,13:CygbotD1, 14:DroneCAN, 15:Scripting, 16:LD06, 17: MR72_CAN
    // @RebootRequired: True
    // @User: Standard
    AP_GROUPINFO_FLAGS("_TYPE",   1, AP_Proximity_Params, type, 0, AP_PARAM_FLAG_ENABLE),

    // @Param: _ORIENT
    // @DisplayName: Proximity sensor orientation
    // @Description: Proximity sensor orientation
    // @Values: 0:Default,1:Upside Down
    // @User: Standard
    AP_GROUPINFO("_ORIENT", 2, AP_Proximity_Params, orientation, 0),

    // @Param: _YAW_CORR
    // @DisplayName: Proximity sensor yaw correction
    // @Description: Proximity sensor yaw correction
    // @Units: deg
    // @Range: -180 180
    // @User: Standard
    AP_GROUPINFO("_YAW_CORR", 3, AP_Proximity_Params, yaw_correction, 0),

    // @Param: _IGN_ANG1
    // @DisplayName: Proximity sensor ignore angle 1
    // @Description: Proximity sensor ignore angle 1
    // @Units: deg
    // @Range: 0 360
    // @User: Standard
    AP_GROUPINFO("_IGN_ANG1", 4, AP_Proximity_Params, ignore_angle_deg[0], 0),

    // @Param: _IGN_WID1
    // @DisplayName: Proximity sensor ignore width 1
    // @Description: Proximity sensor ignore width 1
    // @Units: deg
    // @Range: 0 127
    // @User: Standard
    AP_GROUPINFO("_IGN_WID1", 5, AP_Proximity_Params, ignore_width_deg[0], 0),

    // @Param: _IGN_ANG2
    // @DisplayName: Proximity sensor ignore angle 2
    // @Description: Proximity sensor ignore angle 2
    // @Units: deg
    // @Range: 0 360
    // @User: Standard
    AP_GROUPINFO("_IGN_ANG2", 6, AP_Proximity_Params, ignore_angle_deg[1], 0),

    // @Param: _IGN_WID2
    // @DisplayName: Proximity sensor ignore width 2
    // @Description: Proximity sensor ignore width 2
    // @Units: deg
    // @Range: 0 127
    // @User: Standard
    AP_GROUPINFO("_IGN_WID2", 7, AP_Proximity_Params, ignore_width_deg[1], 0),

    // @Param: _IGN_ANG3
    // @DisplayName: Proximity sensor ignore angle 3
    // @Description: Proximity sensor ignore angle 3
    // @Units: deg
    // @Range: 0 360
    // @User: Standard
    AP_GROUPINFO("_IGN_ANG3", 8, AP_Proximity_Params, ignore_angle_deg[2], 0),

    // @Param: _IGN_WID3
    // @DisplayName: Proximity sensor ignore width 3
    // @Description: Proximity sensor ignore width 3
    // @Units: deg
    // @Range: 0 127
    // @User: Standard
    AP_GROUPINFO("_IGN_WID3", 9, AP_Proximity_Params, ignore_width_deg[2], 0),

    // @Param: _IGN_ANG4
    // @DisplayName: Proximity sensor ignore angle 4
    // @Description: Proximity sensor ignore angle 4
    // @Units: deg
    // @Range: 0 360
    // @User: Standard
    AP_GROUPINFO("_IGN_ANG4", 10, AP_Proximity_Params, ignore_angle_deg[3], 0),

    // @Param: _IGN_WID4
    // @DisplayName: Proximity sensor ignore width 4
    // @Description: Proximity sensor ignore width 4
    // @Units: deg
    // @Range: 0 127
    // @User: Standard
    AP_GROUPINFO("_IGN_WID4", 11, AP_Proximity_Params, ignore_width_deg[3], 0),

    // @Param: _MIN
    // @DisplayName: Proximity minimum range
    // @Description: Minimum expected range for Proximity Sensor. Setting this to 0 will set value to manufacturer reported range.
    // @Units: m
    // @Range: 0 500
    // @User: Advanced
    AP_GROUPINFO("_MIN", 16, AP_Proximity_Params, min_m, 0.0f),

    // @Param: _MAX
    // @DisplayName: Proximity maximum range
    // @Description: Maximum expected range for Proximity Sensor. Setting this to 0 will set value to manufacturer reported range.
    // @Units: m
    // @Range: 0 500
    // @User: Advanced
    AP_GROUPINFO("_MAX", 17, AP_Proximity_Params, max_m, 0.0f),

    // @Param: _ADDR
    // @DisplayName: Bus address of sensor
    // @Description: The bus address of the sensor, where applicable. Used for the I2C and DroneCAN sensors to allow for multiple sensors on different addresses.
    // @Range: 0 127
    // @Increment: 1
    // @User: Standard
    AP_GROUPINFO("_ADDR", 25, AP_Proximity_Params, address, 0),

    AP_GROUPEND
};

AP_Proximity_Params::AP_Proximity_Params(void) {
    AP_Param::setup_object_defaults(this, var_info);
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       #pragma once

#include <AP_Param/AP_Param.h>
#include <AP_Math/AP_Math.h>

#define PROXIMITY_MAX_IGNORE                4   // up to six areas can be ignored

class AP_Proximity_Params {

public:

    static const struct AP_Param::GroupInfo var_info[];

    AP_Proximity_Params(void);

    /* Do not allow copies */
    CLASS_NO_COPY(AP_Proximity_Params);

    AP_Int8 type;                                       // type of sensor
    AP_Int8 orientation;                                // orientation (e.g. right-side-up or upside-down)
    AP_Int16 yaw_correction;                            // yaw correction in degrees
    AP_Int16 ignore_angle_deg[PROXIMITY_MAX_IGNORE];    // angle (in degrees) of area that should be ignored by sensor (i.e. leg shows up)
    AP_Int8 ignore_width_deg[PROXIMITY_MAX_IGNORE];     // width of beam (in degrees) that should be ignored
    AP_Float max_m;                                     // maximum range in meters
    AP_Float min_m;                                     // minimum range in meters
    AP_Int8  address;                                   // proximity address (for AP_Periph CAN)
};
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                /*
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/*
 * ArduPilot device driver for SLAMTEC RPLIDAR A2 (16m range version)
 *
 * ALL INFORMATION REGARDING PROTOCOL WAS DERIVED FROM RPLIDAR DATASHEET:
 *
 * https://www.slamtec.com/en/Lidar
 * http://bucket.download.slamtec.com/63ac3f0d8c859d3a10e51c6b3285fcce25a47357/LR001_SLAMTEC_rplidar_protocol_v1.0_en.pdf
 *
 * Author: Steven Josefs, IAV GmbH
 * Based on the LightWare SF40C ArduPilot device driver from Randy Mackay
 *
 */

#include "AP_Proximity_config.h"

#if AP_PROXIMITY_RPLIDARA2_ENABLED

#include "AP_Proximity_RPLidarA2.h"

#include <AP_HAL/AP_HAL.h>
#include "AP_Proximity_RPLidarA2.h"
#include <AP_InternalError/AP_InternalError.h>

#include <ctype.h>
#include <stdio.h>

#define RP_DEBUG_LEVEL 0

#include <GCS_MAVLink/GCS.h>
#if RP_DEBUG_LEVEL
  #define Debug(level, fmt, args ...)  do { if (level <= RP_DEBUG_LEVEL) { GCS_SEND_TEXT(MAV_SEVERITY_INFO, fmt, ## args); } } while (0)
#else
  #define Debug(level, fmt, args ...)
#endif

#define COMM_ACTIVITY_TIMEOUT_MS        200

// Commands
//-----------------------------------------

// Commands without payload and response
#define RPLIDAR_PREAMBLE               0xA5
#define RPLIDAR_CMD_STOP               0x25
#define RPLIDAR_CMD_SCAN               0x20
#define RPLIDAR_CMD_FORCE_SCAN         0x21
#define RPLIDAR_CMD_RESET              0x40

// Commands without payload but have response
#define RPLIDAR_CMD_GET_DEVICE_INFO    0x50
#define RPLIDAR_CMD_GET_DEVICE_HEALTH  0x52

// Commands with payload and have response
#define RPLIDAR_CMD_EXPRESS_SCAN       0x82

extern const AP_HAL::HAL& hal;

void AP_Proximity_RPLidarA2::update(void)
{
    if (_uart == nullptr) {
        return;
    }

    // request device info 3sec after reset
    // required for S1 support that sends only 9 bytes after a reset (A1,A2 send 63)
    uint32_t now_ms = AP_HAL::millis();
    if ((_state == State::RESET) && (now_ms - _last_reset_ms > 3000)) {
        send_request_for_device_info();
        _state = State::AWAITING_RESPONSE;
        _byte_count = 0;
    }

    get_readings();

    // check for timeout and set health status
    if (AP_HAL::millis() - _last_distance_received_ms > COMM_ACTIVITY_TIMEOUT_MS) {
        set_status(AP_Proximity::Status::NoData);
        Debug(1, "LIDAR NO DATA");
        if (AP_HAL::millis() - _last_reset_ms > 10000) {
            reset_rplidar();
        }
    } else {
        set_status(AP_Proximity::Status::Good);
    }
}

// get maximum distance (in meters) of sensor
float AP_Proximity_RPLidarA2::distance_max() const
{
    switch (model) {
    case Model::UNKNOWN:
        return 0.0f;
    case Model::A1:
        return 8.0f;
    case Model::A2:
        return 16.0f;
    case Model::C1:
        return 12.0f;
    case Model::S1:
        return 40.0f;
    }
    return 0.0f;
}

// get minimum distance (in meters) of sensor
float AP_Proximity_RPLidarA2::distance_min() const
{
    switch (model) {
    case Model::UNKNOWN:
        return 0.0f;
    case Model::A1:
    case Model::A2:
    case Model::C1:
    case Model::S1:
        return 0.2f;
    }
    return 0.0f;
}

void AP_Proximity_RPLidarA2::reset_rplidar()
{
    static const uint8_t tx_buffer[2] {RPLIDAR_PREAMBLE, RPLIDAR_CMD_RESET};
    _uart->write(tx_buffer, 2);
    Debug(1, "LIDAR reset");
    // To-Do: ensure delay of 8m after sending reset request
    _last_reset_ms =  AP_HAL::millis();
    reset();
}

// set Lidar into SCAN mode
void AP_Proximity_RPLidarA2::send_scan_mode_request()
{
    static const uint8_t tx_buffer[2] {RPLIDAR_PREAMBLE, RPLIDAR_CMD_SCAN};
    _uart->write(tx_buffer, 2);
    Debug(1, "Sent scan mode request");
}

// send request for sensor health
void AP_Proximity_RPLidarA2::send_request_for_health()                                    //not called yet
{
    static const uint8_t tx_buffer[2] {RPLIDAR_PREAMBLE, RPLIDAR_CMD_GET_DEVICE_HEALTH};
    _uart->write(tx_buffer, 2);
    Debug(1, "Sent health request");
}

// send request for device information
void AP_Proximity_RPLidarA2::send_request_for_device_info()
{
    static const uint8_t tx_buffer[2] {RPLIDAR_PREAMBLE, RPLIDAR_CMD_GET_DEVICE_INFO};
    _uart->write(tx_buffer, 2);
    Debug(1, "Sent device information request");
}

void AP_Proximity_RPLidarA2::consume_bytes(uint16_t count)
{
    if (count > _byte_count) {
        INTERNAL_ERROR(AP_InternalError::error_t::flow_of_control);
        _byte_count = 0;
        return;
    }
    _byte_count -= count;
    if (_byte_count) {
        memmove((void*)&_payload[0], (void*)&_payload[count], _byte_count);
    }
}

void AP_Proximity_RPLidarA2::reset()
{
    _state = State::RESET;
    _byte_count = 0;
}

bool AP_Proximity_RPLidarA2::make_first_byte_in_payload(uint8_t desired_byte)
{
    if (_byte_count == 0) {
        return false;
    }
    if (_payload[0] == desired_byte) {
        return true;
    }
    for (auto i=1; i<_byte_count; i++) {
        if (_payload[i] == desired_byte) {
            consume_bytes(i);
            return true;
        }
    }
    // just not in our buffer.  Throw everything away:
    _byte_count = 0;
    return false;
}

void AP_Proximity_RPLidarA2::get_readings()
{
    Debug(2, "             CURRENT STATE: %u ", (unsigned)_state);
    const uint32_t nbytes = _uart->available();
    if (nbytes == 0) {
        return;
    }
    const uint32_t bytes_to_read = MIN(nbytes, sizeof(_payload)-_byte_count);
    if (bytes_to_read == 0) {
        INTERNAL_ERROR(AP_InternalError::error_t::flow_of_control);
        reset();
        return;
    }
    const uint32_t bytes_read = _uart->read(&_payload[_byte_count], bytes_to_read);
    if (bytes_read == 0) {
        // this is bad; we were told there were bytes available
        INTERNAL_ERROR(AP_InternalError::error_t::flow_of_control);
        reset();
        return;
    }
    _byte_count += bytes_read;

    uint32_t previous_loop_byte_count = UINT32_MAX;
    while (_byte_count) {
        if (_byte_count >= previous_loop_byte_count) {
            // this is a serious error, we should always consume some
            // bytes.  Avoid looping forever.
            INTERNAL_ERROR(AP_InternalError::error_t::flow_of_control);
            _uart = nullptr;
            return;
        }
        previous_loop_byte_count = _byte_count;

        switch(_state){
        case State::RESET: {
            // looking for 0x52 at start of buffer; the 62 following
            // bytes are "information"
            if (!make_first_byte_in_payload('R')) { // that's 'R' as in RPiLidar
                return;
            }
            if (_byte_count < 63) {
                return;
            }
#if RP_DEBUG_LEVEL
            // optionally spit out via mavlink the 63-bytes of cruft
            // that is spat out on device reset
            Debug(1, "Got RPLidar Information");
            char xbuffer[64]{};
            memcpy((void*)xbuffer, (void*)&_payload.information, 63);
            GCS_SEND_TEXT(MAV_SEVERITY_INFO, "RPLidar: (%s)", xbuffer);
#endif
            // 63 is the magic number of bytes in the spewed-out
            // reset data ... so now we'll just drop that stuff on
            // the floor.
            consume_bytes(63);
            send_request_for_device_info();
            _state = State::AWAITING_RESPONSE;
            continue;
        }
        case State::AWAITING_RESPONSE:
            if (_payload[0] != RPLIDAR_PREAMBLE) {
                // this is a protocol error.  Reset.
                reset();
                return;
            }

            // descriptor packet has 7 byte in total
            if (_byte_count < sizeof(_descriptor)) {
                return;
            }
            // identify the payload data after the descriptor
            static const _descriptor SCAN_DATA_DESCRIPTOR[] {
                { RPLIDAR_PREAMBLE, 0x5A, 0x05, 0x00, 0x00, 0x40, 0x81 }
            };
            static const _descriptor HEALTH_DESCRIPTOR[] {
                { RPLIDAR_PREAMBLE, 0x5A, 0x03, 0x00, 0x00, 0x00, 0x06 }
            };
            static const _descriptor DEVICE_INFO_DESCRIPTOR[] {
                { RPLIDAR_PREAMBLE, 0x5A, 0x14, 0x00, 0x00, 0x00, 0x04 }
            };
            Debug(2,"LIDAR descriptor found");
            if (memcmp((void*)&_payload[0], SCAN_DATA_DESCRIPTOR, sizeof(_descriptor)) == 0) {
                _state = State::AWAITING_SCAN_DATA;
            } else if (memcmp((void*)&_payload[0], DEVICE_INFO_DESCRIPTOR, sizeof(_descriptor)) == 0) {
                _state = State::AWAITING_DEVICE_INFO;
            } else if (memcmp((void*)&_payload[0], HEALTH_DESCRIPTOR, sizeof(_descriptor)) == 0) {
                _state = State::AWAITING_HEALTH;
            } else {
                // unknown descriptor.  Ignore it.
            }
            consume_bytes(sizeof(_descriptor));
            break;

        case State::AWAITING_DEVICE_INFO:
            if (_byte_count < sizeof(_payload.device_info)) {
                return;
            }
            parse_response_device_info();
            consume_bytes(sizeof(_payload.device_info));
            break;

        case State::AWAITING_SCAN_DATA:
            if (_byte_count < sizeof(_payload.sensor_scan)) {
                return;
            }
            parse_response_data();
            consume_bytes(sizeof(_payload.sensor_scan));
            break;

        case State::AWAITING_HEALTH:
            if (_byte_count < sizeof(_payload.sensor_health)) {
                return;
            }
            parse_response_health();
            consume_bytes(sizeof(_payload.sensor_health));
            break;
        }
    }
}

void AP_Proximity_RPLidarA2::parse_response_device_info()
{
    Debug(1, "Received DEVICE_INFO");
    const char *device_type = "UNKNOWN";
    switch (_payload.device_info.model) {
    case 0x18:
        model = Model::A1;
        device_type = "A1";
        break;
    case 0x28:
        model = Model::A2;
        device_type = "A2";
        break;
    case 0x41:
        model=Model::C1;
        device_type="C1";
        break;
    case 0x61:
        model = Model::S1;
        device_type = "S1";
        break;
    default:
        Debug(1, "Unknown device (%u)", _payload.device_info.model);
    }
    GCS_SEND_TEXT(MAV_SEVERITY_INFO, "RPLidar %s hw=%u fw=%u.%u", device_type, _payload.device_info.hardware, _payload.device_info.firmware_minor, _payload.device_info.firmware_major);
    send_scan_mode_request();
    _state = State::AWAITING_RESPONSE;
}

void AP_Proximity_RPLidarA2::parse_response_data()
{
    if (_sync_error) {
        // out of 5-byte sync mask -> catch new revolution
        Debug(1, "       OUT OF SYNC");
        // on first revolution bit 1 = 1, bit 2 = 0 of the first byte
        if ((_payload[0] & 0x03) == 0x01) {
            _sync_error = 0;
            Debug(1, "                  RESYNC");
        } else {
            return;
        }
    }
    Debug(2, "UART %02x %02x%02x %02x%02x", _payload[0], _payload[2], _payload[1], _payload[4], _payload[3]); //show HEX values
    // check if valid SCAN packet: a valid packet starts with startbits which are complementary plus a checkbit in byte+1
    if (!((_payload.sensor_scan.startbit == !_payload.sensor_scan.not_startbit) && _payload.sensor_scan.checkbit)) {
        Debug(1, "Invalid Payload");
        _sync_error++;
        return;
    }

    const float angle_sign = (params.orientation == 1) ? -1.0f : 1.0f;
    const float angle_deg = wrap_360(_payload.sensor_scan.angle_q6/64.0f * angle_sign + params.yaw_correction);
    const float distance_m = (_payload.sensor_scan.distance_q2/4000.0f);
#if RP_DEBUG_LEVEL >= 2
    const float quality = _payload.sensor_scan.quality;
    Debug(2, "   D%02.2f A%03.1f Q%0.2f", distance_m, angle_deg, quality);
#endif
    _last_distance_received_ms = AP_HAL::millis();
    if (!ignore_reading(angle_deg, distance_m)) {
        const AP_Proximity_Boundary_3D::Face face = frontend.boundary.get_face(angle_deg);

        if (face != _last_face) {
            // distance is for a new face, the previous one can be updated now
            if (_last_distance_valid) {
                frontend.boundary.set_face_attributes(_last_face, _last_angle_deg, _last_distance_m, state.instance);
            } else {
                // reset distance from last face
                frontend.boundary.reset_face(face, state.instance);
            }

            // initialize the new face
            _last_face = face;
            _last_distance_valid = false;
        }
        if (distance_m > distance_min()) {
            // update shortest distance
            if (!_last_distance_valid || (distance_m < _last_distance_m)) {
                _last_distance_m = distance_m;
                _last_distance_valid = true;
                _last_angle_deg = angle_deg;
            }
            // update OA database
            database_push(_last_angle_deg, _last_distance_m);
        }
    }
}

void AP_Proximity_RPLidarA2::parse_response_health()
{
    // health issue if status is "3" ->HW error
    if (_payload.sensor_health.status == 3) {
        Debug(1, "LIDAR Error");
    }
    Debug(1, "LIDAR Healthy");
}

#endif // AP_PROXIMITY_RPLIDARA2_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        /*
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/*
 * ArduPilot device driver for SLAMTEC RPLIDAR A2 (16m range version)
 *
 * ALL INFORMATION REGARDING PROTOCOL WAS DERIVED FROM RPLIDAR DATASHEET:
 *
 * https://www.slamtec.com/en/Lidar
 * http://bucket.download.slamtec.com/63ac3f0d8c859d3a10e51c6b3285fcce25a47357/LR001_SLAMTEC_rplidar_protocol_v1.0_en.pdf
 *
 * Author: Steven Josefs, IAV GmbH
 * Based on the LightWare SF40C ArduPilot device driver from Randy Mackay
 *
 */

/*

# to connect device to SITL:
./Tools/autotest/sim_vehicle.py -v Rover --gdb --debug -A --serial5=uart:/dev/serial/by-id/usb-Silicon_Labs_CP2102_USB_to_UART_Bridge_Controller_0001-if00-port0:115200
param set SERIAL5_PROTOCOL 11
param set SERIAL5_BAUD 115200
param set PRX1_TYPE 5
reboot

# short outer-two wires on JST plug to get it to spin

*/


#pragma once

#include "AP_Proximity_config.h"

#if AP_PROXIMITY_RPLIDARA2_ENABLED

#include "AP_Proximity_Backend_Serial.h"

class AP_Proximity_RPLidarA2 : public AP_Proximity_Backend_Serial
{

public:

    using AP_Proximity_Backend_Serial::AP_Proximity_Backend_Serial;

    // update state
    void update(void) override;

    // get maximum and minimum distances (in meters) of sensor
    float distance_max() const override;
    float distance_min() const override;

private:

    enum class State {
        RESET = 56,
        AWAITING_RESPONSE,
        AWAITING_SCAN_DATA,
        AWAITING_HEALTH,
        AWAITING_DEVICE_INFO,
    } _state = State::RESET;

    // send request for something from sensor
    void send_request_for_health();
    void send_scan_mode_request();
    void send_request_for_device_info();

    void parse_response_data();
    void parse_response_health();
    void parse_response_device_info();

    void get_readings();
    void reset_rplidar();
    void reset();

    // remove bytes from read buffer:
    void consume_bytes(uint16_t count);

    uint8_t _sync_error;
    uint16_t _byte_count;

    // request related variables
    uint32_t  _last_distance_received_ms;     ///< system time of last distance measurement received from sensor
    uint32_t  _last_reset_ms;

    // face related variables
    AP_Proximity_Boundary_3D::Face _last_face;///< last face requested
    float _last_angle_deg;                    ///< yaw angle (in degrees) of _last_distance_m
    float _last_distance_m;                   ///< shortest distance for _last_face
    bool _last_distance_valid;                ///< true if _last_distance_m is valid

    struct PACKED _device_info {
        uint8_t model;
        uint8_t firmware_minor;
        uint8_t firmware_major;
        uint8_t hardware;
        uint8_t serial[16];
   };

    struct PACKED _sensor_scan {
        uint8_t startbit      : 1;            ///< on the first revolution 1 else 0
        uint8_t not_startbit  : 1;            ///< complementary to startbit
        uint8_t quality       : 6;            ///< Related the reflected laser pulse strength
        uint8_t checkbit      : 1;            ///< always set to 1
        uint16_t angle_q6     : 15;           ///< Actual heading = angle_q6/64.0 Degree
        uint16_t distance_q2  : 16;           ///< Actual Distance = distance_q2/4.0 mm
    };

    struct PACKED _sensor_health {
        uint8_t status;                       ///< status definition: 0 good, 1 warning, 2 error
        uint16_t error_code;                  ///< the related error code
    };

    struct PACKED _descriptor {
        uint8_t bytes[7];
    };

    // we don't actually *need* to store this.  If we don't, _payload
    // can be just 7 bytes, but that doesn't make for efficient
    // reading.  It also simplifies the state machine to have the read
    // buffer at least this big.  Note that we force the buffer to a
    // larger size below anyway.
    struct PACKED _rpi_information {
        uint8_t bytes[63];
    };

    union PACKED {
        DEFINE_BYTE_ARRAY_METHODS
        _sensor_scan sensor_scan;
        _sensor_health sensor_health;
        _descriptor descriptor;
        _rpi_information information;
        _device_info device_info;
        uint8_t forced_buffer_size[256]; // just so we read(...) efficiently
    } _payload;
    static_assert(sizeof(_payload) >= 63, "Needed for parsing out reboot data");

    enum class Model {
        UNKNOWN,
        A1,
        A2,
        C1,
        S1,
    } model = Model::UNKNOWN;

    bool make_first_byte_in_payload(uint8_t desired_byte);
};

#endif // AP_PROXIMITY_RPLIDARA2_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        