(Vector3<T> v)
{
    const T theta = v.length();
    if (::is_zero(theta)) {
        q1 = 1.0f;
        q2=q3=q4=0.0f;
        return;
    }
    v /= theta;
    from_axis_angle(v,theta);
}

// create a quaternion from its axis-angle representation
// the axis vector must be length 1, theta is in radians
template <typename T>
void QuaternionT<T>::from_axis_angle(const Vector3<T> &axis, T theta)
{
    // axis must be a unit vector as there is no check for length
    if (::is_zero(theta)) {
        q1 = 1.0f;
        q2=q3=q4=0.0f;
        return;
    }
    const T st2 = sinF(0.5*theta);

    q1 = cosF(0.5*theta);
    q2 = axis.x * st2;
    q3 = axis.y * st2;
    q4 = axis.z * st2;
}

// rotate by the provided axis angle
template <typename T>
void QuaternionT<T>::rotate(const Vector3<T> &v)
{
    QuaternionT<T> r;
    r.from_axis_angle(v);
    (*this) *= r;
}

// convert this quaternion to a rotation vector where the direction of the vector represents
// the axis of rotation and the length of the vector represents the angle of rotation
template <typename T>
void QuaternionT<T>::to_axis_angle(Vector3<T> &v) const
{
    const T l = sqrtF(sq(q2)+sq(q3)+sq(q4));
    v = Vector3<T>(q2,q3,q4);
    if (!::is_zero(l)) {
        v /= l;
        v *= wrap_PI(2.0f * atan2F(l,q1));
    }
}

// create a quaternion from its axis-angle representation
// only use with small angles.  I.e. length of v should less than 0.17 radians (i.e. 10 degrees)
template <typename T>
void QuaternionT<T>::from_axis_angle_fast(Vector3<T> v)
{
    const T theta = v.length();
    if (::is_zero(theta)) {
        q1 = 1.0f;
        q2=q3=q4=0.0f;
        return;
    }
    v /= theta;
    from_axis_angle_fast(v,theta);
}

// create a quaternion from its axis-angle representation
// theta should less than 0.17 radians (i.e. 10 degrees)
template <typename T>
void QuaternionT<T>::from_axis_angle_fast(const Vector3<T> &axis, T theta)
{
    const T t2 = 0.5*theta;
    const T sqt2 = sq(t2);
    const T st2 = t2-sqt2*t2/6.0f;

    q1 = 1.0f-(0.5*sqt2)+sq(sqt2)/24.0f;
    q2 = axis.x * st2;
    q3 = axis.y * st2;
    q4 = axis.z * st2;
}

// create a quaternion by integrating an angular velocity over some time_delta, which is 
// assumed to be small
template <typename T>
void QuaternionT<T>::from_angular_velocity(const Vector3<T>& angular_velocity, float time_delta)
{
    const float half_time_delta = 0.5f*time_delta;

    q1 = 1.0;
    q2 = half_time_delta*angular_velocity.x;
    q3 = half_time_delta*angular_velocity.y;
    q4 = half_time_delta*angular_velocity.z;
    normalize();
}


// rotate by the provided axis angle
// only use with small angles.  I.e. length of v should less than 0.17 radians (i.e. 10 degrees)
template <typename T>
void QuaternionT<T>::rotate_fast(const Vector3<T> &v)
{
    const T theta = v.length();
    if (::is_zero(theta)) {
        return;
    }
    const T t2 = 0.5*theta;
    const T sqt2 = sq(t2);
    T st2 = t2-sqt2*t2/6.0f;
    st2 /= theta;

    //"rotation quaternion"
    const T w2 = 1.0f-(0.5*sqt2)+sq(sqt2)/24.0f;
    const T x2 = v.x * st2;
    const T y2 = v.y * st2;
    const T z2 = v.z * st2;

    //copy our quaternion
    const T w1 = q1;
    const T x1 = q2;
    const T y1 = q3;
    const T z1 = q4;

    //do the multiply into our quaternion
    q1 = w1*w2 - x1*x2 - y1*y2 - z1*z2;
    q2 = w1*x2 + x1*w2 + y1*z2 - z1*y2;
    q3 = w1*y2 - x1*z2 + y1*w2 + z1*x2;
    q4 = w1*z2 + x1*y2 - y1*x2 + z1*w2;
}

// get euler roll angle
template <typename T>
T QuaternionT<T>::get_euler_roll() const
{
    return (atan2F(2.0f*(q1*q2 + q3*q4), 1.0f - 2.0f*(q2*q2 + q3*q3)));
}

// get euler pitch angle
template <typename T>
T QuaternionT<T>::get_euler_pitch() const
{
    return safe_asin(2.0f*(q1*q3 - q4*q2));
}

// get euler yaw angle
template <typename T>
T QuaternionT<T>::get_euler_yaw() const
{
    return atan2F(2.0f*(q1*q4 + q2*q3), 1.0f - 2.0f*(q3*q3 + q4*q4));
}

// create eulers from a quaternion
template <typename T>
void QuaternionT<T>::to_euler(double &roll, double &pitch, double &yaw) const
{
    roll = get_euler_roll();
    pitch = get_euler_pitch();
    yaw = get_euler_yaw();
}

template <typename T>
void QuaternionT<T>::to_euler(float &roll, float &pitch, float &yaw) const
{
    roll = get_euler_roll();
    pitch = get_euler_pitch();
    yaw = get_euler_yaw();
}

// create eulers from a quaternion
template <typename T>
Vector3<T> QuaternionT<T>::to_vector312(void) const
{
    Matrix3<T> m;
    rotation_matrix(m);
    return m.to_euler312();
}

template <typename T>
T QuaternionT<T>::length(void) const
{
    return sqrtF(sq(q1) + sq(q2) + sq(q3) + sq(q4));
}

// gets the length squared of the quaternion
template <typename T>
T QuaternionT<T>::length_squared() const
{
    return (T)(q1*q1 + q2*q2 + q3*q3 + q4*q4);
}

// return the reverse rotation of this quaternion
template <typename T>
QuaternionT<T> QuaternionT<T>::inverse(void) const
{
    return QuaternionT<T>(q1, -q2, -q3, -q4);
}

// reverse the rotation of this quaternion
template <typename T>
void QuaternionT<T>::invert()
{
    q2 = -q2;
    q3 = -q3;
    q4 = -q4;
}

template <typename T>
void QuaternionT<T>::normalize(void)
{
    const T quatMag = length();
    if (!::is_zero(quatMag)) {
        const T quatMagInv = 1.0f/quatMag;
        q1 *= quatMagInv;
        q2 *= quatMagInv;
        q3 *= quatMagInv;
        q4 *= quatMagInv;
    } else {
        // The code goes here if the quaternion is [0,0,0,0]. This shouldn't happen.
        INTERNAL_ERROR(AP_InternalError::error_t::flow_of_control);
    }
}

// Checks if each element of the quaternion is zero
template <typename T>
bool QuaternionT<T>::is_zero(void) const {
    return ::is_zero(q1) && ::is_zero(q2) && ::is_zero(q3) && ::is_zero(q4);
}

// zeros the quaternion to [0, 0, 0, 0], an invalid quaternion
// See initialize() if you want the zero rotation quaternion
template <typename T>
void QuaternionT<T>::zero(void)
{
    q1 = q2 = q3 = q4 = 0.0;
}

// Checks if the quaternion is unit_length within a tolerance
// Returns True: if its magnitude is close to unit length +/- 1E-3
// This limit is somewhat greater than sqrt(FLT_EPSL)
template <typename T>
bool QuaternionT<T>::is_unit_length(void) const
{
    if (fabsF(length_squared() - 1) < 1E-3) {
        return true;
    }

    return false;
}

template <typename T>
QuaternionT<T> QuaternionT<T>::operator*(const QuaternionT<T> &v) const
{
    QuaternionT<T> ret;
    const T &w1 = q1;
    const T &x1 = q2;
    const T &y1 = q3;
    const T &z1 = q4;

    const T w2 = v.q1;
    const T x2 = v.q2;
    const T y2 = v.q3;
    const T z2 = v.q4;

    ret.q1 = w1*w2 - x1*x2 - y1*y2 - z1*z2;
    ret.q2 = w1*x2 + x1*w2 + y1*z2 - z1*y2;
    ret.q3 = w1*y2 - x1*z2 + y1*w2 + z1*x2;
    ret.q4 = w1*z2 + x1*y2 - y1*x2 + z1*w2;

    return ret;
}

// Optimized quaternion rotation operator, equivalent to converting
// (*this) to a rotation matrix then multiplying it to the argument `v`.
//
// 15 multiplies and 15 add / subtracts. Caches 3 floats
template <typename T>
Vector3<T> QuaternionT<T>::operator*(const Vector3<T> &v) const
{
    // This uses the formula
    //
    //    v2 = v1 + 2 q1 * qv x v1 + 2 qv x qv x v1
    //
    // where "x" is the cross product (explicitly inlined for performance below), 
    // "q1" is the scalar part and "qv" is the vector part of this quaternion

    Vector3<T> ret = v;

    // Compute and cache "qv x v1"
    T uv[] = {q3 * v.z - q4 * v.y, q4 * v.x - q2 * v.z, q2 * v.y - q3 * v.x};

    uv[0] += uv[0];
    uv[1] += uv[1];
    uv[2] += uv[2];
    ret.x += q1 * uv[0] + q3 * uv[2] - q4 * uv[1];
    ret.y += q1 * uv[1] + q4 * uv[0] - q2 * uv[2];
    ret.z += q1 * uv[2] + q2 * uv[1] - q3 * uv[0];
    return ret;
}

template <typename T>
QuaternionT<T> &QuaternionT<T>::operator*=(const QuaternionT<T> &v)
{
    const T w1 = q1;
    const T x1 = q2;
    const T y1 = q3;
    const T z1 = q4;

    const T w2 = v.q1;
    const T x2 = v.q2;
    const T y2 = v.q3;
    const T z2 = v.q4;

    q1 = w1*w2 - x1*x2 - y1*y2 - z1*z2;
    q2 = w1*x2 + x1*w2 + y1*z2 - z1*y2;
    q3 = w1*y2 - x1*z2 + y1*w2 + z1*x2;
    q4 = w1*z2 + x1*y2 - y1*x2 + z1*w2;

    return *this;
}

template <typename T>
QuaternionT<T> QuaternionT<T>::operator/(const QuaternionT<T> &v) const
{
    QuaternionT<T> ret;
    const T &quat0 = q1;
    const T &quat1 = q2;
    const T &quat2 = q3;
    const T &quat3 = q4;

    if (is_zero()) {
        // The code goes here if the quaternion is [0,0,0,0]. This shouldn't happen.
        INTERNAL_ERROR(AP_InternalError::error_t::flow_of_control);
    }

    const T rquat0 = v.q1;
    const T rquat1 = v.q2;
    const T rquat2 = v.q3;
    const T rquat3 = v.q4;

    ret.q1 = (rquat0*quat0 + rquat1*quat1 + rquat2*quat2 + rquat3*quat3);
    ret.q2 = (rquat0*quat1 - rquat1*quat0 - rquat2*quat3 + rquat3*quat2);
    ret.q3 = (rquat0*quat2 + rquat1*quat3 - rquat2*quat0 - rquat3*quat1);
    ret.q4 = (rquat0*quat3 - rquat1*quat2 + rquat2*quat1 - rquat3*quat0);
    return ret;
}

// angular difference in radians between quaternions
template <typename T>
QuaternionT<T> QuaternionT<T>::angular_difference(const QuaternionT<T> &v) const
{
    return v.inverse() * *this;
}

// absolute (e.g. always positive) earth-frame roll-pitch difference (in radians) between this Quaternion and another
template <typename T>
T QuaternionT<T>::roll_pitch_difference(const QuaternionT<T> &v) const
{
    // convert Quaternions to rotation matrices
    Matrix3<T> m, vm;
    rotation_matrix(m);
    v.rotation_matrix(vm);

    // rotate earth frame vertical vector by each rotation matrix
    const Vector3<T> z_unit_vec{0,0,1};
    const Vector3<T> z_unit_m = m.mul_transpose(z_unit_vec);
    const Vector3<T> z_unit_vm = vm.mul_transpose(z_unit_vec);
    const Vector3<T> vec_diff = z_unit_vm - z_unit_m;
    const T vec_len_div2 = constrain_float(vec_diff.length() * 0.5, 0.0, 1.0);

    // calculate and return angular difference
    return (2.0 * asinF(vec_len_div2));
}

// define for float and double
template class QuaternionT<float>;
template class QuaternionT<double>;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                /*
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

// Copyright 2012 Andrew Tridgell, all rights reserved.
// Refactored by Jonathan Challinger
#pragma once

#include "definitions.h"
#include "matrix3.h"
#include <cmath>
#if MATH_CHECK_INDEXES
#include <assert.h>
#endif
#include <math.h>

template <typename T>
class QuaternionT {
public:
    T        q1, q2, q3, q4;

    // constructor creates a quaternion equivalent
    // to roll=0, pitch=0, yaw=0
    QuaternionT()
    {
        q1 = 1;
        q2 = q3 = q4 = 0;
    }

    // setting constructor
    QuaternionT(const T _q1, const T _q2, const T _q3, const T _q4) :
        q1(_q1), q2(_q2), q3(_q3), q4(_q4)
    {
    }

    // setting constructor
    QuaternionT(const T _q[4]) :
        q1(_q[0]), q2(_q[1]), q3(_q[2]), q4(_q[3])
    {
    }

    // check if any elements are NAN
    bool        is_nan(void) const WARN_IF_UNUSED
    {
        return isnan(q1) || isnan(q2) || isnan(q3) || isnan(q4);
    }

    // populate the supplied rotation matrix equivalent from this quaternion
    void        rotation_matrix(Matrix3f &m) const;
    void        rotation_matrix(Matrix3d &m) const;

    // make this quaternion equivalent to the supplied matrix
    void		from_rotation_matrix(const Matrix3<T> &m);

    // create a quaternion from a given rotation
    void        from_rotation(enum Rotation rotation);

    // rotate this quaternion by the given rotation
    void        rotate(enum Rotation rotation);

    // convert a vector from earth to body frame
    void        earth_to_body(Vector3<T> &v) const;

    // create a quaternion from Euler angles using 321 euler ordering
    void        from_euler(T roll, T pitch, T yaw);
    void        from_euler(const Vector3<T> &v);

    // create a quaternion from Euler angles applied in yaw, roll, pitch order (312)
    // instead of the normal yaw, pitch, roll order
    void        from_vector312(T roll, T pitch, T yaw);

    // convert this quaternion to a rotation vector where the direction of the vector represents
    // the axis of rotation and the length of the vector represents the angle of rotation
    void        to_axis_angle(Vector3<T> &v) const;

    // create a quaternion from a rotation vector where the direction of the vector represents
    // the axis of rotation and the length of the vector represents the angle of rotation
    void        from_axis_angle(Vector3<T> v);

    // create a quaternion from its axis-angle representation
    // the axis vector must be length 1. the rotation angle theta is in radians
    void        from_axis_angle(const Vector3<T> &axis, T theta);

    // rotate by the provided rotation vector
    void        rotate(const Vector3<T> &v);

    // create a quaternion from a rotation vector
    // only use with small angles.  I.e. length of v should less than 0.17 radians (i.e. 10 degrees)
    void        from_axis_angle_fast(Vector3<T> v);

    // create a quaternion from its axis-angle representation
    // the axis vector must be length 1, theta should less than 0.17 radians (i.e. 10 degrees)
    void        from_axis_angle_fast(const Vector3<T> &axis, T theta);

    // create a quaternion by integrating an angular velocity over some time_delta, which is 
    // assumed to be small
    void        from_angular_velocity(const Vector3<T>& angular_velocity, float time_delta);

    // rotate by the provided rotation vector
    // only use with small angles.  I.e. length of v should less than 0.17 radians (i.e. 10 degrees)
    void        rotate_fast(const Vector3<T> &v);

    // get euler roll angle in radians
    T       get_euler_roll() const;

    // get euler pitch angle in radians
    T       get_euler_pitch() const;

    // get euler yaw angle in radians
    T       get_euler_yaw() const;

    // create eulers (in radians) from a quaternion, using 321 ordering
    void        to_euler(float &roll, float &pitch, float &yaw) const;
    void        to_euler(Vector3f &rpy) const {
        to_euler(rpy.x, rpy.y, rpy.z);
    }
    void        to_euler(double &roll, double &pitch, double &yaw) const;
    void        to_euler(Vector3d &rpy) const {
        to_euler(rpy.x, rpy.y, rpy.z);
    }

    // create eulers from a quaternion with 312 ordering
    Vector3<T>    to_vector312(void) const;

    T length_squared(void) const;
    T length(void) const;
    void normalize();

    // Checks if each element of the quaternion is zero
    bool is_zero(void) const;

    // zeros the quaternion to [0, 0, 0, 0], an invalid quaternion
    // See initialize() if you want the zero rotation quaternion
    void zero(void);

    // Checks if the quaternion is unit_length within a tolerance
    // Returns True: if its magnitude is close to unit length +/- 1E-3
    // This limit is somewhat greater than sqrt(FLT_EPSL)
    bool is_unit_length(void) const;

    // initialise the quaternion to no rotation
    void initialise()
    {
        q1 = 1.0f;
        q2 = q3 = q4 = 0.0f;
    }

    QuaternionT<T> inverse(void) const;

    // reverse the rotation of this quaternion
    void invert();

    // allow a quaternion to be used as an array, 0 indexed
    T & operator[](uint8_t i)
    {
        T *_v = &q1;
#if MATH_CHECK_INDEXES
        assert(i < 4);
#endif
        return _v[i];
    }

    const T & operator[](uint8_t i) const
    {
        const T *_v = &q1;
#if MATH_CHECK_INDEXES
        assert(i < 4);
#endif
        return _v[i];
    }

    QuaternionT<T> operator*(const QuaternionT<T> &v) const;
    Vector3<T> operator*(const Vector3<T> &v) const;
    QuaternionT<T> &operator*=(const QuaternionT<T> &v);
    QuaternionT<T> operator/(const QuaternionT<T> &v) const;

    // angular difference between quaternions
    QuaternionT<T> angular_difference(const QuaternionT<T> &v) const;

    // absolute (e.g. always positive) earth-frame roll-pitch difference (in radians) between this Quaternion and another
    T roll_pitch_difference(const QuaternionT<T> &v) const;

    // double/float conversion
    QuaternionT<double> todouble(void) const {
        return QuaternionT<double>(q1,q2,q3,q4);
    }
    QuaternionT<float> tofloat(void) const {
        return QuaternionT<float>(q1,q2,q3,q4);
    }
};

typedef QuaternionT<float> Quaternion;
typedef QuaternionT<double> QuaternionD;



                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              /*
 * rotations.h
 * Copyright (C) Andrew Tridgell 2012
 *
 * This file is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This file is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
#pragma once

// these rotations form a full set - every rotation in the following
// list when combined with another in the list forms an entry which is
// also in the list. This is an important property. Please run the
// rotations test suite if you add to the list.

// NOTE!! these rotation values are stored to EEPROM, so be careful not to
// change the numbering of any existing entry when adding a new entry.
enum Rotation : uint8_t {
    ROTATION_NONE                = 0,
    ROTATION_YAW_45              = 1,
    ROTATION_YAW_90              = 2,
    ROTATION_YAW_135             = 3,
    ROTATION_YAW_180             = 4,
    ROTATION_YAW_225             = 5,
    ROTATION_YAW_270             = 6,
    ROTATION_YAW_315             = 7,
    ROTATION_ROLL_180            = 8,
    ROTATION_ROLL_180_YAW_45     = 9,
    ROTATION_ROLL_180_YAW_90     = 10,
    ROTATION_ROLL_180_YAW_135    = 11,
    ROTATION_PITCH_180           = 12,
    ROTATION_ROLL_180_YAW_225    = 13,
    ROTATION_ROLL_180_YAW_270    = 14,
    ROTATION_ROLL_180_YAW_315    = 15,
    ROTATION_ROLL_90             = 16,
    ROTATION_ROLL_90_YAW_45      = 17,
    ROTATION_ROLL_90_YAW_90      = 18,
    ROTATION_ROLL_90_YAW_135     = 19,
    ROTATION_ROLL_270            = 20,
    ROTATION_ROLL_270_YAW_45     = 21,
    ROTATION_ROLL_270_YAW_90     = 22,
    ROTATION_ROLL_270_YAW_135    = 23,
    ROTATION_PITCH_90            = 24,
    ROTATION_PITCH_270           = 25,
    ROTATION_PITCH_180_YAW_90    = 26, // same as ROTATION_ROLL_180_YAW_270
    ROTATION_PITCH_180_YAW_270   = 27, // same as ROTATION_ROLL_180_YAW_90
    ROTATION_ROLL_90_PITCH_90    = 28,
    ROTATION_ROLL_180_PITCH_90   = 29,
    ROTATION_ROLL_270_PITCH_90   = 30,
    ROTATION_ROLL_90_PITCH_180   = 31,
    ROTATION_ROLL_270_PITCH_180  = 32,
    ROTATION_ROLL_90_PITCH_270   = 33,
    ROTATION_ROLL_180_PITCH_270  = 34,
    ROTATION_ROLL_270_PITCH_270  = 35,
    ROTATION_ROLL_90_PITCH_180_YAW_90 = 36,
    ROTATION_ROLL_90_YAW_270     = 37,
    ROTATION_ROLL_90_PITCH_68_YAW_293 = 38, // this is actually, roll 90, pitch 68.8, yaw 293.3
    ROTATION_PITCH_315           = 39,
    ROTATION_ROLL_90_PITCH_315   = 40,
    ROTATION_PITCH_7             = 41,
    ROTATION_ROLL_45             = 42,
    ROTATION_ROLL_315            = 43,
    ///////////////////////////////////////////////////////////////////////
    // Do not add more rotations without checking that there is not a conflict
    // with the MAVLink spec. MAV_SENSOR_ORIENTATION is expected to match our
    // list of rotations here. If a new rotation is added it needs to be added
    // to the MAVLink messages as well.
    ///////////////////////////////////////////////////////////////////////
    ROTATION_MAX,
    ROTATION_CUSTOM_OLD          = 100,
    ROTATION_CUSTOM_1            = 101,
    ROTATION_CUSTOM_2            = 102,
    ROTATION_CUSTOM_END,
};


// definitions used by quaterion and vector3f
#define HALF_SQRT_2 0.70710678118654752440084436210485

/*
Here are the same values in a form suitable for a @Values attribute in
auto documentation:

@Values: 0:None,1:Yaw45,2:Yaw90,3:Yaw135,4:Yaw180,5:Yaw225,6:Yaw270,7:Yaw315,8:Roll180,9:Yaw45Roll180,10:Yaw90Roll180,11:Yaw135Roll180,12:Pitch180,13:Yaw225Roll180,14:Yaw270Roll180,15:Yaw315Roll180,16:Roll90,17:Yaw45Roll90,18:Yaw90Roll90,19:Yaw135Roll90,20:Roll270,21:Yaw45Roll270,22:Yaw90Roll270,23:Yaw135Roll270,24:Pitch90,25:Pitch270,26:Yaw90Pitch180,27:Yaw270Pitch180,28:Pitch90Roll90,29:Pitch90Roll180,30:Pitch90Roll270,31:Pitch180Roll90,32:Pitch180Roll270,33:Pitch270Roll90,34:Pitch270Roll180,35:Pitch270Roll270,36:Yaw90Pitch180Roll90,37:Yaw270Roll90,38:Yaw293Pitch68Roll180,39:Pitch315,40:Pitch315Roll90,42:Roll45,43:Roll315,100:Custom 4.1 and older,101:Custom 1,102:Custom 2
 */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               /*
 * spline5.cpp
 *
 * Created by William Geyer and Chris Olson modified for ardupilot
 * Original work by Ryan Muller
 * https://gist.github.com/ryanthejuggler/4132103
 * released under the Creative Commons CC0 License
 * http://creativecommons.org/publicdomain/zero/1.0/
 *
 * This file is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This file is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include <stdint.h>
#include "spline5.h"

void splinterp5(const float x[5], float out[4][4])
{

    // number of spline points
    const uint8_t n = 5;

    // working variables
    float u[n] {};

    // second derivative
    // additional element in array necessary for back substitution loop.
    float z[n+1] {};

    // set the second derivative to 0 at the ends
    z[0] = u[0] = 0;
    z[n-1] = 0;

    // decomposition loop
    for (uint8_t i=1; i<n-1; i++) {
        float p = 0.5f * z[i-1] + 2.0f;
        // keep p from ever becoming zero
        if (p < 0.01f && p >= 0.0f) {
            p = 0.01f;
        } else if (p > -0.01f && p < 0.0f) {
            p = -0.01f;
        }
        const float p_inv = 1.0f / p;
        z[i] = -0.5f * p_inv;
        u[i] = x[i+1] + x[i-1] - 2.0f * x[i];
        u[i] = (3.0f * u[i] - 0.5f * u[i-1]) * p_inv;
    }

    // back-substitution loop
    for (uint8_t i=n-1; i>0; i--) {
        z[i] = z[i] * z[i+1] + u[i];
    }

    for (uint8_t i=0; i<n-1; i++) {
        out[i][0] = x[i+1];
        out[i][1] = x[i];
        out[i][2] = z[i+1];
        out[i][3] = z[i];
    }

}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               #pragma once


void splinterp5(const float x[5], float out[4][4]);


                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           /*
 * Copyright (C) 2016  Intel Corporation. All rights reserved.
 *
 * This file is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This file is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
#pragma once

#include <iostream>

#include <AP_gtest.h>
#include <AP_Math/AP_Math.h>

/*
 * Overload operator << for AP_Math types to allow nice printing for failed
 * tests.
 */

template <typename T>
::std::ostream& operator<<(::std::ostream& os, const Matrix3<T>& m)
{
    return os << "{{" << m.a.x << ", " << m.a.y << ", " << m.a.z << "}, " <<
                  "{" << m.b.x << ", " << m.b.y << ", " << m.b.z << "}, " <<
                  "{" << m.c.x << ", " << m.c.y << ", " << m.c.z << "}}";
}

template <typename T>
::std::ostream& operator<<(::std::ostream& os, const Vector3<T>& v)
{
    return os << "{" << v.x << ", " << v.y << ", " << v.z << "}";
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                #include <AP_gtest.h>

#include <AP_Math/vector2.h>
#include <AP_Math/vector3.h>
#include <AP_Math/AP_Math.h>

// check if two vector3f are equal 
#define EXPECT_VECTOR3F_EQ(v1, v2)              \
    do {                                        \
        EXPECT_FLOAT_EQ(v1[0], v2[0]);          \
        EXPECT_FLOAT_EQ(v1[1], v2[1]);          \
        EXPECT_FLOAT_EQ(v1[2], v2[2]);          \
    } while (false);


TEST(Lines3dTests, ClosestDistBetweenLinePoint)
{
    // check if the 2-d and 3-d variant of this method is same if the third-dimension is zero
    float dist_3d = Vector3f::closest_distance_between_line_and_point(Vector3f{0.0f, 1.0f, 0.0f}, Vector3f{0.0f, 10.0f, 0.0f}, Vector3f{6.0f, 5.0f, 0.0f});
    float dist_2d = Vector2f::closest_distance_between_line_and_point(Vector2f{0.0f, 1.0f}, Vector2f{0.0f, 10.0f}, Vector2f{6.0f, 5.0f});
    EXPECT_FLOAT_EQ(dist_2d, dist_3d);

    // random point test
    const Vector3f intersection = Vector3f::point_on_line_closest_to_other_point(Vector3f{}, Vector3f{0.0f, 10.0f, 10.0f}, Vector3f{0.0f, 5.0f, 5.0f});
    EXPECT_VECTOR3F_EQ((Vector3f{0.0f, 5.0f, 5.0f}), intersection);

    // check protection agains null length
    const Vector3f intersection_null = Vector3f::point_on_line_closest_to_other_point(Vector3f{1.0f, 1.0f, 1.0f}, Vector3f{1.0f, 1.0f, 1.0f}, Vector3f{0.0f, 5.0f, 5.0f});
    EXPECT_VECTOR3F_EQ((Vector3f{1.0f, 1.0f, 1.0f}), intersection_null);
}

TEST(Lines3dTests, SegmentToSegmentCloestPoint)
{
    // random segments test
    Vector3f intersection;
    Vector3f::segment_to_segment_closest_point(Vector3f{-10.0f,0.0f,0.0f}, Vector3f{10.0f,0.0f,0.0f}, Vector3f{0.0f, -5.0f, 1.0}, Vector3f{0.0f, 5.0f, 1.0f}, intersection);
    EXPECT_VECTOR3F_EQ(intersection, (Vector3f{0.0f, 0.0f, 1.0f}));

    // check for intersecting segments. Verify with the 2-d variant
    Vector3f::segment_to_segment_closest_point(Vector3f{}, Vector3f{10.0f,10.0f,0.0f}, Vector3f{2.0f, -10.0f, 0.0}, Vector3f{3.0f, 10.0f, 0.0f}, intersection);
    Vector2f intersection_2d;
    const bool result = Vector2f::segment_intersection(Vector2f{}, Vector2f{10.0f,10.0}, Vector2f{2.0f, -10.0f}, Vector2f{3.0f, 10.0f}, intersection_2d);
    EXPECT_EQ(true, result);
    EXPECT_VECTOR3F_EQ(intersection, (Vector3f(intersection_2d.x, intersection_2d.y, 0.0f)));
}

AP_GTEST_MAIN()
int hal = 0; //weirdly the build will fail without this
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         #include <AP_gtest.h>

#include <AP_Math/vector2.h>

#define TEST_DISTANCE_BOTH(line_segment_x,line_segment_y, point_x, point_y, expected_length) \
    do {                                                                \
        {                                                               \
            Vector2f line_segment = Vector2f(line_segment_x, line_segment_y); \
            Vector2f point = Vector2f(point_x, point_y);                \
            float result = Vector2<float>::closest_distance_between_radial_and_point( \
                line_segment,                                           \
                point                                                   \
                );                                                      \
            EXPECT_FLOAT_EQ(result, expected_length);                   \
        }                                                               \
    } while (false)


TEST(ThreatTests, Distance)
{

    TEST_DISTANCE_BOTH( 0, 0,  0, 0, 0);
    TEST_DISTANCE_BOTH( 0, 0,  0, 1, 1);

    TEST_DISTANCE_BOTH( 1, 1,  1, 0, sqrt(0.5));
    TEST_DISTANCE_BOTH(-1,-1, -1, 0, sqrt(0.5));

    TEST_DISTANCE_BOTH( 3, 1,  3, 0, 0.94868332);
    TEST_DISTANCE_BOTH( 1, 3,  0, 3, 0.94868332);
    TEST_DISTANCE_BOTH(-1, 3,  0, 3, 0.94868332);
    TEST_DISTANCE_BOTH( 1,-3,  0,-3, 0.94868332);
    TEST_DISTANCE_BOTH(-1,-3,  0,-3, 0.94868332);

    TEST_DISTANCE_BOTH( 2, 2,  1, 1, 0.0);
    TEST_DISTANCE_BOTH( 2, 2,  3, 3, sqrt(2));
    TEST_DISTANCE_BOTH( 2, 2,  2, 2, 0);
    TEST_DISTANCE_BOTH( 0, 0,  1, 1, sqrt(2));
    TEST_DISTANCE_BOTH( 0, 0,  1, 1, sqrt(2));

    TEST_DISTANCE_BOTH( 0, 0,  1, 1, sqrt(2));
    TEST_DISTANCE_BOTH( 1, 1,  0, 3, sqrt(5));
}

AP_GTEST_MAIN()


int hal = 0; // bizarrely, this fixes an undefined-symbol error but doesn't raise a type exception.  Yay.


                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             #include <AP_gtest.h>

#include <AP_Math/AP_Math.h>
#include <AP_Math/vector2.h>
#include <AP_Math/vector3.h>
#include <AP_Math/control.h>

TEST(Control, test_control)
{
    postype_t pos_start = 17;
    float vel_start = 20;
    float accel_start = 1.0;
    const float dt = 0.01;

    // test for update_pos_vel_accel includes update_vel_accel.
    // test unlimited behaviour
    // 1
    float vel = vel_start;
    postype_t pos = pos_start;
    float accel = accel_start;
    update_pos_vel_accel(pos, vel, accel, dt, 0.0, 0.0, 0.0);
    EXPECT_FLOAT_EQ(vel, vel_start + accel * dt);
    EXPECT_FLOAT_EQ(pos, pos_start + vel_start * dt + 0.5 * accel * sq(dt));

    // 2
    vel = vel_start;
    pos = pos_start;
    accel = -accel_start;
    update_pos_vel_accel(pos, vel, accel, dt, 0.0, 0.0, 0.0);
    EXPECT_FLOAT_EQ(vel, vel_start + accel * dt);
    EXPECT_FLOAT_EQ(pos, pos_start + vel_start * dt + 0.5 * accel * sq(dt));

    // error has no impact when not limited
    // 3
    vel = vel_start;
    pos = pos_start;
    accel = accel_start;
    update_pos_vel_accel(pos, vel, accel, dt, 0.0, 1.0, 1.0);
    EXPECT_FLOAT_EQ(vel, vel_start + accel * dt);
    EXPECT_FLOAT_EQ(pos, pos_start + vel_start * dt + 0.5 * accel * sq(dt));

    // 4
    vel = vel_start;
    pos = pos_start;
    accel = accel_start;
    update_pos_vel_accel(pos, vel, accel, dt, 0.0, -1.0, -1.0);
    EXPECT_FLOAT_EQ(vel, vel_start + accel * dt);
    EXPECT_FLOAT_EQ(pos, pos_start + vel_start * dt + 0.5 * accel * sq(dt));

    // test unlimited behaviour
    // zero error should result in normal behaviour
    // 5
    vel = vel_start;
    pos = pos_start;
    accel = accel_start;
    update_pos_vel_accel(pos, vel, accel, dt, 1.0, 0.0, 0.0);
    EXPECT_FLOAT_EQ(vel, vel_start + accel * dt);
    EXPECT_FLOAT_EQ(pos, pos_start + vel_start * dt + 0.5 * accel * sq(dt));

    // 6
    vel = vel_start;
    pos = pos_start;
    accel = -accel_start;
    update_pos_vel_accel(pos, vel, accel, dt, 1.0, 0.0, 0.0);
    EXPECT_FLOAT_EQ(vel, vel_start + accel * dt);
    EXPECT_FLOAT_EQ(pos, pos_start + vel_start * dt + 0.5 * accel * sq(dt));

    // 7
    vel = vel_start;
    pos = pos_start;
    accel = accel_start;
    update_pos_vel_accel(pos, vel, accel, dt, -1.0, 0.0, 0.0);
    EXPECT_FLOAT_EQ(vel, vel_start + accel * dt);
    EXPECT_FLOAT_EQ(pos, pos_start + vel_start * dt + 0.5 * accel * sq(dt));

    // 8
    vel = vel_start;
    pos = pos_start;
    accel = -accel_start;
    update_pos_vel_accel(pos, vel, accel, dt, -1.0, 0.0, 0.0);
    EXPECT_FLOAT_EQ(vel, vel_start + accel * dt);
    EXPECT_FLOAT_EQ(pos, pos_start + vel_start * dt + 0.5 * accel * sq(dt));
    
    // error sign opposite to limit sign should result in normal behaviour
    // 9
    vel = vel_start;
    pos = pos_start;
    accel = accel_start;
    update_pos_vel_accel(pos, vel, accel, dt, 1.0, -1.0, -1.0);
    EXPECT_FLOAT_EQ(vel, vel_start + accel * dt);
    EXPECT_FLOAT_EQ(pos, pos_start + vel_start * dt + 0.5 * accel * sq(dt));

    // 10
    vel = vel_start;
    pos = pos_start;
    accel = -accel_start;
    update_pos_vel_accel(pos, vel, accel, dt, 1.0, -1.0, -1.0);
    EXPECT_FLOAT_EQ(vel, vel_start + accel * dt);
    EXPECT_FLOAT_EQ(pos, pos_start + vel_start * dt + 0.5 * accel * sq(dt));

    // 11
    vel = vel_start;
    pos = pos_start;
    accel = accel_start;
    update_pos_vel_accel(pos, vel, accel, dt, -1.0, 1.0, 1.0);
    EXPECT_FLOAT_EQ(vel, vel_start + accel * dt);
    EXPECT_FLOAT_EQ(pos, pos_start + vel_start * dt + 0.5 * accel * sq(dt));

    // 12
    vel = vel_start;
    pos = pos_start;
    accel = -accel_start;
    update_pos_vel_accel(pos, vel, accel, dt, -1.0, 1.0, 1.0);
    EXPECT_FLOAT_EQ(vel, vel_start + accel * dt);
    EXPECT_FLOAT_EQ(pos, pos_start + vel_start * dt + 0.5 * accel * sq(dt));
    
    // error sign same as limit sign should result various limited behaviours
    // 13
    vel = vel_start;
    pos = pos_start;
    accel = accel_start;
    update_pos_vel_accel(pos, vel, accel, dt, 1.0, 1.0, 1.0);
    // vel is not increased
    EXPECT_FLOAT_EQ(vel, vel_start);
    // pos is not increased
    EXPECT_FLOAT_EQ(pos, pos_start);

    // 14
    vel = vel_start;
    pos = pos_start;
    accel = -accel_start;
    update_pos_vel_accel(pos, vel, accel, dt, 1.0, 1.0, 1.0);
    // vel is decreased
    EXPECT_FLOAT_EQ(vel, vel_start + accel * dt);
    // pos is not increased
    EXPECT_FLOAT_EQ(pos, pos_start);

    // 15
    vel = vel_start;
    pos = pos_start;
    accel = accel_start;
    update_pos_vel_accel(pos, vel, accel, dt, -1.0, -1.0, -1.0);
    // vel is increased
    EXPECT_FLOAT_EQ(vel, vel_start + accel * dt);
    // pos is increased
    EXPECT_FLOAT_EQ(pos, pos_start + vel_start * dt + 0.5 * accel * sq(dt));

    // 16
    vel = vel_start;
    pos = pos_start;
    accel = -accel_start;
    update_pos_vel_accel(pos, vel, accel, dt, -1.0, -1.0, -1.0);
    // velocity is limited but limit is not applied because velocity is reducing
    EXPECT_FLOAT_EQ(vel, vel_start + accel * dt);
    // pos is increased
    EXPECT_FLOAT_EQ(pos, pos_start + vel_start * dt + 0.5 * accel * sq(dt));

    // 17
    vel = -vel_start;
    pos = pos_start;
    accel = accel_start;
    update_pos_vel_accel(pos, vel, accel, dt, 1.0, 1.0, 1.0);
    // velocity is limited but limit is not applied because velocity is reducing
    EXPECT_FLOAT_EQ(vel, -vel_start + accel * dt);
    // pos is decreased
    EXPECT_FLOAT_EQ(pos, pos_start - vel_start * dt + 0.5 * accel * sq(dt));

    // 18
    vel_start = 0.1 * accel_start * dt;
    vel = vel_start;
    pos = pos_start;
    accel = -accel_start;
    update_pos_vel_accel(pos, vel, accel, dt, -1.0, -1.0, -1.0);
    // velocity is limited but limit is not applied because velocity is reducing
    // final result is zero because velocity would change sign during dt
    EXPECT_FLOAT_EQ(vel, 0.0);
    // pos is not changed because is_negative(vel_start * dt + 0.5 * accel * sq(t))
    EXPECT_FLOAT_EQ(pos, pos_start);

    // 19
    vel = -vel_start;
    pos = pos_start;
    accel = accel_start;
    update_pos_vel_accel(pos, vel, accel, dt, 1.0, 1.0, 1.0);
    // velocity is limited but limit is not applied because velocity is reducing
    // final result is zero because velocity would change sign during dt
    EXPECT_FLOAT_EQ(vel, 0.0);
    // pos is not changed because is_negative(vel_start * dt + 0.5 * accel * sq(t))
    EXPECT_FLOAT_EQ(pos, pos_start);


    // test for update_pos_vel_accel includes update_vel_accel.
    // test unlimited behaviour
    
    // 1
    pos_start = 17;
    vel_start = 20;
    accel_start = 1.0;
    Vector2p posxy = Vector2p(pos_start, 0.0);
    Vector2f velxy = Vector2f(vel_start, 0.0);
    Vector2f accelxy = Vector2f(accel_start, 0.0);
    Vector2f limit = Vector2f(0.0, 0.0);
    Vector2f pos_error = Vector2f(0.0, 0.0);
    Vector2f vel_error = Vector2f(0.0, 0.0);
    update_pos_vel_accel_xy(posxy, velxy, accelxy, dt, limit, pos_error, vel_error);
    EXPECT_FLOAT_EQ(velxy.x, vel_start + accelxy.x * dt);
    EXPECT_FLOAT_EQ(velxy.y, 0.0);
    EXPECT_FLOAT_EQ(posxy.x, pos_start + vel_start * dt + 0.5 * accelxy.x * sq(dt));
    EXPECT_FLOAT_EQ(velxy.y, 0.0);

    // 2
    posxy = Vector2p(pos_start, 0.0);
    velxy = Vector2f(vel_start, 0.0);
    accelxy = Vector2f(-accel_start, 0.0);
    limit = Vector2f(0.0, 0.0);
    pos_error = Vector2f(0.0, 0.0);
    vel_error = Vector2f(0.0, 0.0);
    update_pos_vel_accel_xy(posxy, velxy, accelxy, dt, limit, pos_error, vel_error);
    EXPECT_FLOAT_EQ(velxy.x, vel_start + accelxy.x * dt);
    EXPECT_FLOAT_EQ(velxy.y, 0.0);
    EXPECT_FLOAT_EQ(posxy.x, pos_start + vel_start * dt + 0.5 * accelxy.x * sq(dt));
    EXPECT_FLOAT_EQ(velxy.y, 0.0);

    // error has no impact when not limited
    // 3
    posxy = Vector2p(pos_start, 0.0);
    velxy = Vector2f(vel_start, 0.0);
    accelxy = Vector2f(accel_start, 0.0);
    limit = Vector2f(0.0, 0.0);
    pos_error = Vector2f(1.0, 0.0);
    vel_error = Vector2f(1.0, 0.0);
    update_pos_vel_accel_xy(posxy, velxy, accelxy, dt, limit, pos_error, vel_error);
    EXPECT_FLOAT_EQ(velxy.x, vel_start + accelxy.x * dt);
    EXPECT_FLOAT_EQ(velxy.y, 0.0);
    EXPECT_FLOAT_EQ(posxy.x, pos_start + vel_start * dt + 0.5 * accelxy.x * sq(dt));
    EXPECT_FLOAT_EQ(velxy.y, 0.0);

    // 4
    posxy = Vector2p(pos_start, 0.0);
    velxy = Vector2f(vel_start, 0.0);
    accelxy = Vector2f(accel_start, 0.0);
    limit = Vector2f(0.0, 0.0);
    pos_error = Vector2f(0.0, 0.0);
    vel_error = Vector2f(0.0, 0.0);
    update_pos_vel_accel_xy(posxy, velxy, accelxy, dt, limit, pos_error, vel_error);
    EXPECT_FLOAT_EQ(velxy.x, vel_start + accelxy.x * dt);
    EXPECT_FLOAT_EQ(velxy.y, 0.0);
    EXPECT_FLOAT_EQ(posxy.x, pos_start + vel_start * dt + 0.5 * accelxy.x * sq(dt));
    EXPECT_FLOAT_EQ(velxy.y, 0.0);

    // test unlimited behaviour
    // zero error should result in normal behaviour
    // 5
    posxy = Vector2p(pos_start, 0.0);
    velxy = Vector2f(vel_start, 0.0);
    accelxy = Vector2f(accel_start, 0.0);
    limit = Vector2f(1.0, 0.0);
    pos_error = Vector2f(0.0, 0.0);
    vel_error = Vector2f(0.0, 0.0);
    update_pos_vel_accel_xy(posxy, velxy, accelxy, dt, limit, pos_error, vel_error);
    EXPECT_FLOAT_EQ(velxy.x, vel_start + accelxy.x * dt);
    EXPECT_FLOAT_EQ(velxy.y, 0.0);
    EXPECT_FLOAT_EQ(posxy.x, pos_start + vel_start * dt + 0.5 * accelxy.x * sq(dt));
    EXPECT_FLOAT_EQ(velxy.y, 0.0);

    // 6
    posxy = Vector2p(pos_start, 0.0);
    velxy = Vector2f(vel_start, 0.0);
    accelxy = Vector2f(-accel_start, 0.0);
    limit = Vector2f(1.0, 0.0);
    pos_error = Vector2f(0.0, 0.0);
    vel_error = Vector2f(0.0, 0.0);
    update_pos_vel_accel_xy(posxy, velxy, accelxy, dt, limit, pos_error, vel_error);
    EXPECT_FLOAT_EQ(velxy.x, vel_start + accelxy.x * dt);
    EXPECT_FLOAT_EQ(velxy.y, 0.0);
    EXPECT_FLOAT_EQ(posxy.x, pos_start + vel_start * dt + 0.5 * accelxy.x * sq(dt));
    EXPECT_FLOAT_EQ(velxy.y, 0.0);

    // 7
    posxy = Vector2p(pos_start, 0.0);
    velxy = Vector2f(vel_start, 0.0);
    accelxy = Vector2f(accel_start, 0.0);
    limit = Vector2f(1.0, 0.0);
    pos_error = Vector2f(0.0, 0.0);
    vel_error = Vector2f(0.0, 0.0);
    update_pos_vel_accel_xy(posxy, velxy, accelxy, dt, limit, pos_error, vel_error);
    EXPECT_FLOAT_EQ(velxy.x, vel_start + accelxy.x * dt);
    EXPECT_FLOAT_EQ(velxy.y, 0.0);
    EXPECT_FLOAT_EQ(posxy.x, pos_start + vel_start * dt + 0.5 * accelxy.x * sq(dt));
    EXPECT_FLOAT_EQ(velxy.y, 0.0);

    // 8
    posxy = Vector2p(pos_start, 0.0);
    velxy = Vector2f(vel_start, 0.0);
    accelxy = Vector2f(-accel_start, 0.0);
    limit = Vector2f(1.0, 0.0);
    pos_error = Vector2f(0.0, 0.0);
    vel_error = Vector2f(0.0, 0.0);
    update_pos_vel_accel_xy(posxy, velxy, accelxy, dt, limit, pos_error, vel_error);
    EXPECT_FLOAT_EQ(velxy.x, vel_start + accelxy.x * dt);
    EXPECT_FLOAT_EQ(velxy.y, 0.0);
    EXPECT_FLOAT_EQ(posxy.x, pos_start + vel_start * dt + 0.5 * accelxy.x * sq(dt));
    EXPECT_FLOAT_EQ(velxy.y, 0.0);
    
    // error sign opposite to limit sign should result in normal behaviour
    // 9
    posxy = Vector2p(pos_start, 0.0);
    velxy = Vector2f(vel_start, 0.0);
    accelxy = Vector2f(accel_start, 0.0);
    limit = Vector2f(1.0, 0.0);
    pos_error = Vector2f(-1.0, 0.0);
    vel_error = Vector2f(-1.0, 0.0);
    update_pos_vel_accel_xy(posxy, velxy, accelxy, dt, limit, pos_error, vel_error);
    EXPECT_FLOAT_EQ(velxy.x, vel_start + accelxy.x * dt);
    EXPECT_FLOAT_EQ(velxy.y, 0.0);
    EXPECT_FLOAT_EQ(posxy.x, pos_start + vel_start * dt + 0.5 * accelxy.x * sq(dt));
    EXPECT_FLOAT_EQ(velxy.y, 0.0);

    // 10
    posxy = Vector2p(pos_start, 0.0);
    velxy = Vector2f(vel_start, 0.0);
    accelxy = Vector2f(-accel_start, 0.0);
    limit = Vector2f(1.0, 0.0);
    pos_error = Vector2f(-1.0, 0.0);
    vel_error = Vector2f(-1.0, 0.0);
    update_pos_vel_accel_xy(posxy, velxy, accelxy, dt, limit, pos_error, vel_error);
    EXPECT_FLOAT_EQ(velxy.x, vel_start + accelxy.x * dt);
    EXPECT_FLOAT_EQ(velxy.y, 0.0);
    EXPECT_FLOAT_EQ(posxy.x, pos_start + vel_start * dt + 0.5 * accelxy.x * sq(dt));
    EXPECT_FLOAT_EQ(velxy.y, 0.0);

    // 11
    posxy = Vector2p(pos_start, 0.0);
    velxy = Vector2f(vel_start, 0.0);
    accelxy = Vector2f(accel_start, 0.0);
    limit = Vector2f(-1.0, 0.0);
    pos_error = Vector2f(1.0, 0.0);
    vel_error = Vector2f(1.0, 0.0);
    update_pos_vel_accel_xy(posxy, velxy, accelxy, dt, limit, pos_error, vel_error);
    EXPECT_FLOAT_EQ(velxy.x, vel_start + accelxy.x * dt);
    EXPECT_FLOAT_EQ(velxy.y, 0.0);
    EXPECT_FLOAT_EQ(posxy.x, pos_start + vel_start * dt + 0.5 * accelxy.x * sq(dt));
    EXPECT_FLOAT_EQ(velxy.y, 0.0);

    // 12
    posxy = Vector2p(pos_start, 0.0);
    velxy = Vector2f(vel_start, 0.0);
    accelxy = Vector2f(-accel_start, 0.0);
    limit = Vector2f(-1.0, 0.0);
    pos_error = Vector2f(1.0, 0.0);
    vel_error = Vector2f(1.0, 0.0);
    update_pos_vel_accel_xy(posxy, velxy, accelxy, dt, limit, pos_error, vel_error);
    EXPECT_FLOAT_EQ(velxy.x, vel_start + accelxy.x * dt);
    EXPECT_FLOAT_EQ(velxy.y, 0.0);
    EXPECT_FLOAT_EQ(posxy.x, pos_start + vel_start * dt + 0.5 * accelxy.x * sq(dt));
    EXPECT_FLOAT_EQ(velxy.y, 0.0);
    
    // error sign same as limit sign should result various limited behaviours
    // 13
    posxy = Vector2p(pos_start, 0.0);
    velxy = Vector2f(vel_start, 0.0);
    accelxy = Vector2f(accel_start, 0.0);
    limit = Vector2f(1.0, 0.0);
    pos_error = Vector2f(1.0, 0.0);
    vel_error = Vector2f(1.0, 0.0);
    update_pos_vel_accel_xy(posxy, velxy, accelxy, dt, limit, pos_error, vel_error);
    // vel is not increased
    EXPECT_FLOAT_EQ(velxy.x, vel_start);
    EXPECT_FLOAT_EQ(velxy.y, 0.0);
    // pos is not increased
    EXPECT_FLOAT_EQ(posxy.x, pos_start);
    EXPECT_FLOAT_EQ(velxy.y, 0.0);

    // 14
    posxy = Vector2p(pos_start, 0.0);
    velxy = Vector2f(vel_start, 0.0);
    accelxy = Vector2f(-accel_start, 0.0);
    limit = Vector2f(1.0, 0.0);
    pos_error = Vector2f(1.0, 0.0);
    vel_error = Vector2f(1.0, 0.0);
    update_pos_vel_accel_xy(posxy, velxy, accelxy, dt, limit, pos_error, vel_error);
    // vel is decreased
    EXPECT_FLOAT_EQ(velxy.x, vel_start + accelxy.x * dt);
    EXPECT_FLOAT_EQ(velxy.y, 0.0);
    // pos is not increased
    EXPECT_FLOAT_EQ(posxy.x, pos_start);
    EXPECT_FLOAT_EQ(velxy.y, 0.0);

    // 15
    posxy = Vector2p(pos_start, 0.0);
    velxy = Vector2f(vel_start, 0.0);
    accelxy = Vector2f(accel_start, 0.0);
    limit = Vector2f(-1.0, 0.0);
    pos_error = Vector2f(-1.0, 0.0);
    vel_error = Vector2f(-1.0, 0.0);
    update_pos_vel_accel_xy(posxy, velxy, accelxy, dt, limit, pos_error, vel_error);
    // vel is increased
    EXPECT_FLOAT_EQ(velxy.x, vel_start + accelxy.x * dt);
    EXPECT_FLOAT_EQ(velxy.y, 0.0);
    // pos is increased
    EXPECT_FLOAT_EQ(posxy.x, pos_start + vel_start * dt + 0.5 * accelxy.x * sq(dt));
    EXPECT_FLOAT_EQ(velxy.y, 0.0);

    // 16
    posxy = Vector2p(pos_start, 0.0);
    velxy = Vector2f(vel_start, 0.0);
    accelxy = Vector2f(-accel_start, 0.0);
    limit = Vector2f(-1.0, 0.0);
    pos_error = Vector2f(-1.0, 0.0);
    vel_error = Vector2f(-1.0, 0.0);
    update_pos_vel_accel_xy(posxy, velxy, accelxy, dt, limit, pos_error, vel_error);
    // velocity is limited but limit is not applied because velocity is reducing
    EXPECT_FLOAT_EQ(velxy.x, vel_start + accelxy.x * dt);
    EXPECT_FLOAT_EQ(velxy.y, 0.0);
    // pos is increased
    EXPECT_FLOAT_EQ(posxy.x, pos_start + vel_start * dt + 0.5 * accelxy.x * sq(dt));
    EXPECT_FLOAT_EQ(velxy.y, 0.0);

    // 17
    posxy = Vector2p(pos_start, 0.0);
    velxy = Vector2f(-vel_start, 0.0);
    accelxy = Vector2f(accel_start, 0.0);
    limit = Vector2f(1.0, 0.0);
    pos_error = Vector2f(1.0, 0.0);
    vel_error = Vector2f(1.0, 0.0);
    update_pos_vel_accel_xy(posxy, velxy, accelxy, dt, limit, pos_error, vel_error);
    // velocity is limited but limit is not applied because velocity is reducing
    EXPECT_FLOAT_EQ(velxy.x, -vel_start + accelxy.x * dt);
    EXPECT_FLOAT_EQ(velxy.y, 0.0);
    // pos is decreased
    EXPECT_FLOAT_EQ(posxy.x, pos_start - vel_start * dt + 0.5 * accelxy.x * sq(dt));
    EXPECT_FLOAT_EQ(velxy.y, 0.0);

    // 18
    vel_start = 0.1 * accel_start * dt;
    posxy = Vector2p(pos_start, 0.0);
    velxy = Vector2f(vel_start, 0.0);
    accelxy = Vector2f(-accel_start, 0.0);
    limit = Vector2f(-1.0, 0.0);
    pos_error = Vector2f(-1.0, 0.0);
    vel_error = Vector2f(-1.0, 0.0);
    update_pos_vel_accel_xy(posxy, velxy, accelxy, dt, limit, pos_error, vel_error);
    // velocity is limited but limit is not applied because velocity is reducing
    // ideally this would be zero but code makes a simplification here
    EXPECT_FLOAT_EQ(velxy.x, vel_start + accelxy.x * dt);
    EXPECT_FLOAT_EQ(velxy.y, 0.0);
    // pos is not changed because is_negative(vel_start * dt + 0.5 * accel * sq(t))
    EXPECT_FLOAT_EQ(posxy.x, pos_start);
    EXPECT_FLOAT_EQ(velxy.y, 0.0);

    // 19
    posxy = Vector2p(pos_start, 0.0);
    velxy = Vector2f(-vel_start, 0.0);
    accelxy = Vector2f(accel_start, 0.0);
    limit = Vector2f(1.0, 0.0);
    pos_error = Vector2f(1.0, 0.0);
    vel_error = Vector2f(1.0, 0.0);
    update_pos_vel_accel_xy(posxy, velxy, accelxy, dt, limit, pos_error, vel_error);
    // velocity is limited but limit is not applied because velocity is reducing
    // ideally this would be zero but code makes a simplification here
    EXPECT_FLOAT_EQ(velxy.x, -vel_start + accelxy.x * dt);
    EXPECT_FLOAT_EQ(velxy.y, 0.0);
    // pos is not changed because is_negative(vel_start * dt + 0.5 * accel * sq(t))
    EXPECT_FLOAT_EQ(posxy.x, pos_start);
    EXPECT_FLOAT_EQ(velxy.y, 0.0);
}


AP_GTEST_MAIN()
int hal = 0;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     /*
 * Copyright (C) 2015-2016  Intel Corporation. All rights reserved.
 *
 * This file is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This file is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
#include <cassert>
#include <vector>

#include "math_test.h"
#include <AP_Math/AP_GeodesicGrid.h>

const AP_HAL::HAL& hal = AP_HAL::get_HAL();

class TestParam {
public:
    /**
     * Vector to be tested.
     */
    Vector3f v;
    /**
     * Expected section if when AP_GeodesicGrid::section() is called with
     * inclusive set as false.
     */
    int section;
    /**
     * Array terminated with -1. This doesn't have to be touched if #section
     * isn't negative. If #section is -1, then calling
     * AP_GeodesicGrid::section() with inclusive set as true expects a return
     * value as one of the values in #inclusive_sections.
     */
    int inclusive_sections[7];
};

class GeodesicGridTest : public ::testing::TestWithParam<TestParam> {
protected:
    /**
     * Test the functions for triangles indexes.
     *
     * @param p[in] The test parameter.
     */
    void test_triangles_indexes(const TestParam &p) {
        if (p.section >= 0) {
            int expected_triangle =
                    p.section / AP_GeodesicGrid::NUM_SUBTRIANGLES;
            int triangle = AP_GeodesicGrid::_triangle_index(p.v, false);
            ASSERT_EQ(expected_triangle, triangle);

            int expected_subtriangle =
                    p.section % AP_GeodesicGrid::NUM_SUBTRIANGLES;
            int subtriangle =
                    AP_GeodesicGrid::_subtriangle_index(triangle, p.v, false);
            ASSERT_EQ(expected_subtriangle, subtriangle);
        } else {
            int triangle = AP_GeodesicGrid::_triangle_index(p.v, false);
            if (triangle >= 0) {
                int subtriangle = AP_GeodesicGrid::_subtriangle_index(triangle,
                                                                      p.v,
                                                                      false);
                ASSERT_EQ(-1, subtriangle) << "triangle is " << triangle;
            }
        }
    }
};

static const Vector3f triangles[20][3] = {
    {{-M_GOLDEN, 1, 0}, {-1, 0,-M_GOLDEN}, {-M_GOLDEN,-1, 0}},
    {{-1, 0,-M_GOLDEN}, {-M_GOLDEN,-1, 0}, { 0,-M_GOLDEN,-1}},
    {{-M_GOLDEN,-1, 0}, { 0,-M_GOLDEN,-1}, { 0,-M_GOLDEN, 1}},
    {{-1, 0,-M_GOLDEN}, { 0,-M_GOLDEN,-1}, { 1, 0,-M_GOLDEN}},
    {{ 0,-M_GOLDEN,-1}, { 0,-M_GOLDEN, 1}, { M_GOLDEN,-1, 0}},
    {{ 0,-M_GOLDEN,-1}, { 1, 0,-M_GOLDEN}, { M_GOLDEN,-1, 0}},
    {{ M_GOLDEN,-1, 0}, { 1, 0,-M_GOLDEN}, { M_GOLDEN, 1, 0}},
    {{ 1, 0,-M_GOLDEN}, { M_GOLDEN, 1, 0}, { 0, M_GOLDEN,-1}},
    {{ 1, 0,-M_GOLDEN}, { 0, M_GOLDEN,-1}, {-1, 0,-M_GOLDEN}},
    {{ 0, M_GOLDEN,-1}, {-M_GOLDEN, 1, 0}, {-1, 0,-M_GOLDEN}},

    {{ M_GOLDEN,-1, 0}, { 1, 0, M_GOLDEN}, { M_GOLDEN, 1, 0}},
    {{ 1, 0, M_GOLDEN}, { M_GOLDEN, 1, 0}, { 0, M_GOLDEN, 1}},
    {{ M_GOLDEN, 1, 0}, { 0, M_GOLDEN, 1}, { 0, M_GOLDEN,-1}},
    {{ 1, 0, M_GOLDEN}, { 0, M_GOLDEN, 1}, {-1, 0, M_GOLDEN}},
    {{ 0, M_GOLDEN, 1}, { 0, M_GOLDEN,-1}, {-M_GOLDEN, 1, 0}},
    {{ 0, M_GOLDEN, 1}, {-1, 0, M_GOLDEN}, {-M_GOLDEN, 1, 0}},
    {{-M_GOLDEN, 1, 0}, {-1, 0, M_GOLDEN}, {-M_GOLDEN,-1, 0}},
    {{-1, 0, M_GOLDEN}, {-M_GOLDEN,-1, 0}, { 0,-M_GOLDEN, 1}},
    {{-1, 0, M_GOLDEN}, { 0,-M_GOLDEN, 1}, { 1, 0, M_GOLDEN}},
    {{ 0,-M_GOLDEN, 1}, { M_GOLDEN,-1, 0}, { 1, 0, M_GOLDEN}},
};

static bool section_triangle(unsigned int section_index,
                             Vector3f &a,
                             Vector3f &b,
                             Vector3f &c) {
    if (section_index >= 80) {
        return false;  // LCOV_EXCL_LINE
    }

    unsigned int i = section_index / 4;
    unsigned int j = section_index % 4;
    auto &t = triangles[i];
    Vector3f mt[3]{(t[0] + t[1]) / 2, (t[1] + t[2]) / 2, (t[2] + t[0]) / 2};

    switch (j) {
    case 0:
        a = mt[0];
        b = mt[1];
        c = mt[2];
        break;
    case 1:
        a = t[0];
        b = mt[0];
        c = mt[2];
        break;
    case 2:
        a = mt[0];
        b = t[1];
        c = mt[1];
        break;
    case 3:
        a = mt[2];
        b = mt[1];
        c = t[2];
        break;
    }

    return true;
}

AP_GTEST_PRINTATBLE_PARAM_MEMBER(TestParam, v);

TEST_P(GeodesicGridTest, Sections)
{
    auto p = GetParam();

    test_triangles_indexes(p);
    EXPECT_EQ(p.section, AP_GeodesicGrid::section(p.v));

    if (p.section < 0) {
        int s = AP_GeodesicGrid::section(p.v, true);
        int i;
        for (i = 0; p.inclusive_sections[i] > 0; i++) {
            assert(i < 7);
            if (s == p.inclusive_sections[i]) {
                break;
            }
        }
        if (p.inclusive_sections[i] < 0) {
            ADD_FAILURE() << "section " << s << " with inclusive=true not found in inclusive_sections";  // LCOV_EXCL_LINE
        }
    }
}

static TestParam icosahedron_vertices[] = {
    {{ M_GOLDEN,  1.0f, 0.0f}, -1, {27, 30, 43, 46, 49, -1}},
    {{ M_GOLDEN, -1.0f, 0.0f}, -1, {19, 23, 25, 41, 78, -1}},
    {{-M_GOLDEN,  1.0f, 0.0f}, -1, { 1, 38, 59, 63, 65, -1}},
    {{-M_GOLDEN, -1.0f, 0.0f}, -1, { 3,  6,  9, 67, 70, -1}},
    {{ 1.0f, 0.0f,  M_GOLDEN}, -1, {42, 45, 53, 75, 79, -1}},
    {{-1.0f, 0.0f,  M_GOLDEN}, -1, {55, 62, 66, 69, 73, -1}},
    {{ 1.0f, 0.0f, -M_GOLDEN}, -1, {15, 22, 26, 29, 33, -1}},
    {{-1.0f, 0.0f, -M_GOLDEN}, -1, { 2,  5, 13, 35, 39, -1}},
    {{0.0f,  M_GOLDEN,  1.0f}, -1, {47, 50, 54, 57, 61, -1}},
    {{0.0f,  M_GOLDEN, -1.0f}, -1, {31, 34, 37, 51, 58, -1}},
    {{0.0f, -M_GOLDEN,  1.0f}, -1, {11, 18, 71, 74, 77, -1}},
    {{0.0f, -M_GOLDEN, -1.0f}, -1, { 7, 10, 14, 17, 21, -1}},
};
INSTANTIATE_TEST_CASE_P(IcosahedronVertices,
                        GeodesicGridTest,
                        ::testing::ValuesIn(icosahedron_vertices));

/* Generate vectors for each triangle */
static std::vector<TestParam> general_vectors = []()
{
    std::vector<TestParam> params;
    for (int i = 0; i < 20 * AP_GeodesicGrid::NUM_SUBTRIANGLES; i++) {
        Vector3f a, b, c;
        TestParam p;
        section_triangle(i, a, b, c);
        p.section = i;

        /* Vector that crosses the centroid */
        p.v = a + b + c;
        params.push_back(p);

        /* Vectors that cross the triangle close to the edges */
        p.v = a + b + c * 0.001f;
        params.push_back(p);
        p.v = a + b * 0.001f + c;
        params.push_back(p);
        p.v = a * 0.001f + b + c;
        params.push_back(p);

        /* Vectors that cross the triangle close to the vertices */
        p.v = a + b * 0.001 + c * 0.001f;
        params.push_back(p);
        p.v = a * 0.001f + b + c * 0.001f;
        params.push_back(p);
        p.v = a * 0.001f + b * 0.001f + c;
        params.push_back(p);
    }
    return params;
}();
INSTANTIATE_TEST_CASE_P(GeneralVectors,
                        GeodesicGridTest,
                        ::testing::ValuesIn(general_vectors));

/* Other hardcoded vectors, so we don't rely just on the centroid vectors
 * (which are dependent on how the triangles are *defined by the
 * implementation*)
 *
 * See AP_GeodesicGrid.h for the notation on the comments below.
 */
static TestParam hardcoded_vectors[] = {
    /* a + 2 * m_a + .5 * m_c for T_4 */
    {{.25f * M_GOLDEN, -.25f * (13.0f * M_GOLDEN + 1.0f), - 1.25f}, 17},
    /* 3 * m_a + 2 * m_b 0 * m_c for T_4 */
    {{M_GOLDEN, -4.0f * M_GOLDEN -1.0f, 1.0f}, -1, {16, 18, -1}},
    /* 2 * m_c + (1 / 3) * m_b + .1 * c for T_13 */
    {{-.2667f, .1667f * M_GOLDEN, 2.2667f * M_GOLDEN + .1667f}, 55},
    /* .25 * m_a + 5 * b + 2 * m_b for T_8 */
    {{-.875f, 6.125f * M_GOLDEN, -1.125f * M_GOLDEN - 6.125f}, 34},
};
INSTANTIATE_TEST_CASE_P(HardcodedVectors,
                        GeodesicGridTest,
                        ::testing::ValuesIn(hardcoded_vectors));

AP_GTEST_MAIN()
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   
// given we are in the Math library, you're epected to know what
// you're doing when directly comparing floats:
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wfloat-equal"

#include <AP_gtest.h>

#include <AP_Math/AP_Math.h>
#include <AP_Math/div1000.h>

const AP_HAL::HAL& hal = AP_HAL::get_HAL();

#define SQRT_2 1.4142135623730950488016887242097

TEST(VectorTest, Rotations)
{
    unsigned rotation_count = 0;

#define TEST_ROTATION(rotation, _x, _y, _z) { \
    const float accuracy = 1.0e-6; \
    Vector3f v(1, 1, 1); \
    Vector3f v2 = v; \
    v.rotate(rotation); \
    Vector3f expected(_x, _y, _z); \
    EXPECT_NEAR(expected.length(), v.length(), accuracy); \
    EXPECT_FLOAT_EQ(expected.x, v.x); \
    EXPECT_FLOAT_EQ(expected.y, v.y); \
    EXPECT_FLOAT_EQ(expected.z, v.z); \
    Quaternion quat; \
    quat.from_rotation(rotation); \
    quat.earth_to_body(v2); \
    EXPECT_NEAR(expected.length(), v.length(), accuracy); \
    EXPECT_NEAR(expected.x, v2.x, accuracy); \
    EXPECT_NEAR(expected.y, v2.y, accuracy); \
    EXPECT_NEAR(expected.z, v2.z, accuracy); \
    rotation_count++; \
}

    TEST_ROTATION(ROTATION_NONE, 1, 1, 1);
    TEST_ROTATION(ROTATION_YAW_45, 0, SQRT_2, 1);
    TEST_ROTATION(ROTATION_YAW_90, -1, 1, 1);
    TEST_ROTATION(ROTATION_YAW_135, -SQRT_2, 0, 1);
    TEST_ROTATION(ROTATION_YAW_180, -1, -1, 1);
    TEST_ROTATION(ROTATION_YAW_225, 0, -SQRT_2, 1);
    TEST_ROTATION(ROTATION_YAW_270, 1, -1, 1);
    TEST_ROTATION(ROTATION_YAW_315, SQRT_2, 0, 1);
    TEST_ROTATION(ROTATION_ROLL_180, 1, -1, -1);
    TEST_ROTATION(ROTATION_ROLL_180_YAW_45, SQRT_2, 0, -1);
    TEST_ROTATION(ROTATION_ROLL_180_YAW_90, 1, 1, -1);
    TEST_ROTATION(ROTATION_ROLL_180_YAW_135, 0, SQRT_2, -1);
    TEST_ROTATION(ROTATION_PITCH_180, -1, 1, -1);
    TEST_ROTATION(ROTATION_ROLL_180_YAW_225, -SQRT_2, 0, -1);
    TEST_ROTATION(ROTATION_ROLL_180_YAW_270, -1, -1, -1);
    TEST_ROTATION(ROTATION_ROLL_180_YAW_315, 0, -SQRT_2, -1);
    TEST_ROTATION(ROTATION_ROLL_90, 1, -1, 1);
    TEST_ROTATION(ROTATION_ROLL_90_YAW_45, SQRT_2, 0, 1);
    TEST_ROTATION(ROTATION_ROLL_90_YAW_90, 1, 1, 1);
    TEST_ROTATION(ROTATION_ROLL_90_YAW_135, 0, SQRT_2, 1);
    TEST_ROTATION(ROTATION_ROLL_270, 1, 1, -1);
    TEST_ROTATION(ROTATION_ROLL_270_YAW_45, 0, SQRT_2, -1);
    TEST_ROTATION(ROTATION_ROLL_270_YAW_90, -1, 1, -1);
    TEST_ROTATION(ROTATION_ROLL_270_YAW_135, -SQRT_2, 0, -1);
    TEST_ROTATION(ROTATION_PITCH_90, 1, 1, -1);
    TEST_ROTATION(ROTATION_PITCH_270, -1, 1, 1);
    TEST_ROTATION(ROTATION_PITCH_180_YAW_90, -1, -1, -1);
    TEST_ROTATION(ROTATION_PITCH_180_YAW_270, 1, 1, -1);
    TEST_ROTATION(ROTATION_ROLL_90_PITCH_90, 1, -1, -1);
    TEST_ROTATION(ROTATION_ROLL_180_PITCH_90, -1, -1, -1);
    TEST_ROTATION(ROTATION_ROLL_270_PITCH_90, -1, 1, -1);
    TEST_ROTATION(ROTATION_ROLL_90_PITCH_180, -1, -1, -1);
    TEST_ROTATION(ROTATION_ROLL_270_PITCH_180, -1, 1, 1);
    TEST_ROTATION(ROTATION_ROLL_90_PITCH_270, -1, -1, 1);
    TEST_ROTATION(ROTATION_ROLL_180_PITCH_270, 1, -1, 1);
    TEST_ROTATION(ROTATION_ROLL_270_PITCH_270, 1, 1, 1);
    TEST_ROTATION(ROTATION_ROLL_90_PITCH_180_YAW_90, 1, -1, -1);
    TEST_ROTATION(ROTATION_ROLL_90_YAW_270, -1, -1, 1);
    TEST_ROTATION(ROTATION_ROLL_90_PITCH_68_YAW_293, -0.40663092252764576617352076937095, -1.5839677018260314156350432313047, -0.57069923113341980425161636958364);
    TEST_ROTATION(ROTATION_PITCH_315, 0, 1, SQRT_2);
    TEST_ROTATION(ROTATION_ROLL_90_PITCH_315, 0, -1, SQRT_2);
    TEST_ROTATION(ROTATION_PITCH_7, 1.1144154950464695286171945554088, 1, 0.87067680823617454866081288855639);
    TEST_ROTATION(ROTATION_ROLL_45, 1, 0, SQRT_2);
    TEST_ROTATION(ROTATION_ROLL_315, 1, SQRT_2, 0);
    EXPECT_EQ(ROTATION_MAX, rotation_count) << "All rotations are expect to be tested";

#if CONFIG_HAL_BOARD == HAL_BOARD_LINUX
    TEST_ROTATION(ROTATION_CUSTOM_OLD, 1, 1, 1);
    TEST_ROTATION(ROTATION_MAX, 1, 1, 1);
#elif CONFIG_HAL_BOARD == HAL_BOARD_SITL
    Vector3F v {1, 1, 1};
    EXPECT_EXIT(v.rotate(ROTATION_CUSTOM_OLD), testing::KilledBySignal(SIGABRT), "AP_InternalError::error_t::bad_rotation");
    EXPECT_EXIT(v.rotate(ROTATION_MAX), testing::KilledBySignal(SIGABRT), "AP_InternalError::error_t::bad_rotation");
#endif
}

TEST(MathTest, IsZero)
{
    EXPECT_FALSE(is_zero(0.1f));
    EXPECT_FALSE(is_zero(0.0001f));
    EXPECT_TRUE(is_zero(0.0f));
    EXPECT_TRUE(is_zero(FLT_MIN));
    EXPECT_TRUE(is_zero(-FLT_MIN));
    AP_Float t_float;
    t_float.set(0.1f);
    EXPECT_FALSE(is_zero(t_float));
    t_float.set(0.0f);
    EXPECT_TRUE(is_zero(t_float));
}

TEST(MathTest, IsPositive)
{
    EXPECT_TRUE(is_positive(1.0f));
    EXPECT_TRUE(is_positive(FLT_EPSILON));
    EXPECT_FALSE(is_positive(0.0f));
    EXPECT_FALSE(is_positive(-1.0f));
    AP_Float t_float;
    t_float.set(0.1f);
    EXPECT_TRUE(is_positive(t_float));
    t_float.set(-0.1f);
    EXPECT_FALSE(is_positive(t_float));
}

TEST(MathTest, IsNegative)
{
    EXPECT_TRUE(is_negative(-1.0f * FLT_EPSILON));
    EXPECT_TRUE(is_negative(-1.0f));
    EXPECT_FALSE(is_negative(0.0f));
    EXPECT_FALSE(is_negative(1.0f));
    AP_Float t_float;
    t_float.set(0.1f);
    EXPECT_FALSE(is_negative(t_float));
    t_float.set(-0.1f);
    EXPECT_TRUE(is_negative(t_float));
}

TEST(MathTest, MIN)
{
    const bool testb = true;
    EXPECT_EQ(1, MIN(testb, 2));
    const uint8_t testui8 = 1;
    EXPECT_EQ(1u, MIN(testui8, 2u));
    EXPECT_EQ(1u, MIN(testui8, testui8 + 2u));
    const signed char testcc1 = 1;
    const signed char testcc2 = 2;
    EXPECT_EQ(1, MIN(testcc1, 2));
    EXPECT_EQ(1, MIN(testcc1, testcc2));
    const unsigned char testc = 1;
    const unsigned char testc2 = 2;
    EXPECT_EQ(1u, MIN(testc, 2u));
    EXPECT_EQ(1u, MIN(testc, testc2));
    const unsigned int testuint = 1;
    EXPECT_EQ(1u, MIN(testuint, 2u));
    EXPECT_EQ(1u, MIN(testuint, testuint + 2u));
    const unsigned long testulong = 1;
    EXPECT_EQ(1u, MIN(testulong, 2u));
    EXPECT_EQ(1u, MIN(testulong, testulong + 2u));
    const unsigned short testushort = 1;
    const unsigned short testushort2 = 2;
    EXPECT_EQ(1u, MIN(testushort, 2u));
    EXPECT_EQ(1u, MIN(testushort, testushort2));
    EXPECT_EQ(1u, MIN(testc, testulong));
    EXPECT_EQ(1, MIN(2, testc));
    EXPECT_EQ(1u, MIN(testuint, 2.0f));
    EXPECT_EQ(1u, MIN(testuint, testulong));
    EXPECT_EQ(1u, MIN(testuint, testc));
    EXPECT_EQ(1u, MIN(testulong, testc));
    EXPECT_EQ(1u, MIN(testulong, testuint));
    EXPECT_EQ(1u, MIN(testulong, testushort));
    EXPECT_EQ(1, MIN(testushort, 1));
    EXPECT_EQ(1u, MIN(testushort, testulong));
    const int8_t testi8 = 1;
    EXPECT_EQ(1, MIN(testi8, 2));
    EXPECT_EQ(1, MIN(testui8, testi8 + 2));
    const uint16_t testui16 = 1;
    EXPECT_EQ(1u, MIN(testui16, 2u));
    EXPECT_EQ(1u, MIN(testui16, testui16 + 2u));
    const int16_t testi16 = 1;
    EXPECT_EQ(1, MIN(testi16, 2));
    EXPECT_EQ(1, MIN(testi16, testi16 + 2));
    const uint32_t testui32 = 1;
    EXPECT_EQ(1u, MIN(testui32, 2u));
    EXPECT_EQ(1u, MIN(testui32, testui32 + 2u));
    const int32_t testi32 = 1;
    EXPECT_EQ(1, MIN(testi32, 2));
    EXPECT_EQ(1, MIN(testi32, 2.0f));
    EXPECT_EQ(1.0f, MIN(1.0f, 2.0f));
    EXPECT_EQ(1.0f, MIN(1.0f, 2));
    EXPECT_EQ(1.0f, MIN(2.0f, 1.0f));
}

TEST(MathTest, MAX)
{
    const bool testb = true;
    EXPECT_EQ(2, MAX(testb, 2));
    const unsigned char testc = 1;
    const unsigned char testc2 = 2;
    EXPECT_EQ(2u, MAX(testc, 2u));
    EXPECT_EQ(2u, MAX(testc, testc2));
    const uint8_t testui8 = 1;
    EXPECT_EQ(2u, MAX(testui8, 2u));
    const int8_t testi8 = 1;
    EXPECT_EQ(2, MAX(testi8, 2));
    const uint16_t testui16 = 1;
    EXPECT_EQ(2u, MAX(testui16, 2u));
    const int16_t testi16 = 1;
    EXPECT_EQ(2, MAX(testi16, 2));
    const uint32_t testui32 = 1;
    EXPECT_EQ(2u, MAX(testui32, 2u));
    const int32_t testi32 = 1;
    EXPECT_EQ(2, MAX(testi32, 2));
    const unsigned long testulong = 1;
    EXPECT_EQ(2u, MAX(testulong, 2u));
    EXPECT_EQ(3u, MAX(testulong, testulong + 2u));
    const unsigned short testushort = 1;
    const unsigned short testushort2 = 2;
    EXPECT_EQ(2u, MAX(testushort, 2u));
    EXPECT_EQ(2u, MAX(testushort, testushort2));
    EXPECT_EQ(2.0f, MAX(testushort, 2.0f));
    EXPECT_EQ(2.0f, MAX(testi32, 2.0f));
    AP_Float t_float;
    t_float.set(0.1f);
    EXPECT_EQ(2.0f, MAX(t_float, 2.0f));
    EXPECT_EQ(2.0f, MAX(2.0f, t_float));
    AP_Int8 t_int8;
    t_int8.set(1);
    EXPECT_EQ(2, MAX(t_int8, 2));
    EXPECT_EQ(2, MAX(2, t_int8));
    AP_Int16 t_int16;
    t_int16.set(1);
    EXPECT_EQ(2, MAX(t_int16, 2));
    AP_Int32 t_int32;
    t_int32.set(1);
    EXPECT_EQ(2, MAX(t_int32, 2));
    EXPECT_EQ(2.0f, MAX(1.0f, 2.0f));
    EXPECT_EQ(2.0f, MAX(1.0f, 2));
    EXPECT_EQ(2.0f, MAX(2.0f, 1.0f));
}

TEST(MathTest, Convert)
{
    EXPECT_TRUE(1000000 == hz_to_nsec(1000u));
    EXPECT_TRUE(1000000 == nsec_to_hz(1000u));
    EXPECT_TRUE(1 == nsec_to_usec(1000u));
    EXPECT_TRUE(1000 == hz_to_usec(1000u));
    EXPECT_TRUE(1000 == usec_to_hz(1000u));
}

TEST(MathTest, IsEqual)
{
    EXPECT_FALSE(is_equal(1, 0));
    EXPECT_TRUE(is_equal(1, 1));
    EXPECT_FALSE(is_equal(0.1,  0.10001));
    EXPECT_FALSE(is_equal(0.1, -0.1001));
    EXPECT_TRUE(is_equal(0.f,   0.0f));
    EXPECT_FALSE(is_equal(1.f,  1.f + FLT_EPSILON));
    EXPECT_TRUE(is_equal(1.f,  1.f + FLT_EPSILON / 2.f));
    EXPECT_TRUE(is_equal(1.f, (float)(1.f - DBL_EPSILON)));

    // false because the common type is double
    EXPECT_FALSE(is_equal(double(1.), 1 + 2 * std::numeric_limits<double>::epsilon()));

    // true because the common type is float
    EXPECT_TRUE(is_equal(1.f, (float)(1. + std::numeric_limits<double>::epsilon())));

    EXPECT_TRUE(is_equal(short(1), short(1)));
    EXPECT_TRUE(is_equal(long(1), long(1)));
}

TEST(MathTest, Square)
{
    float sq_0 = sq(0);
    float sq_1 = sq(1);
    float sq_2 = sq(2);

    EXPECT_EQ(0.f, sq_0);
    EXPECT_EQ(1.f, sq_1);
    EXPECT_EQ(4.f, sq_2);
    AP_Float t_sqfloat;
    t_sqfloat.set(sq(2));
    EXPECT_EQ(4.f, t_sqfloat);

    EXPECT_FLOAT_EQ(sq(2.3), 5.289999999999999);  // uses template sq
    EXPECT_FLOAT_EQ(sq(2.3f), 5.29); // uses sq(float v)
    EXPECT_EQ(sq(4294967295), 18446744065119617025U);  // uses template sq
    EXPECT_FLOAT_EQ(sq(4294967295.0), 1.8446744e+19);  // uses template sq
    EXPECT_FLOAT_EQ(sq(pow(2,25)), pow(2,50));
}

TEST(MathTest, Norm)
{
    float norm_1 = norm(1, 4.2);
    float norm_2 = norm(1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1);
    float norm_3 = norm(0, 5.3);
    float norm_4 = norm(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);
    float norm_5 = norm(3,4);
    float norm_6 = norm(4,3,12);
    AP_Float t_float1, t_float2, t_float3;
    t_float1.set(4.0f);
    t_float2.set(3.0f);
    t_float3.set(12.f);
    float norm_7 = norm(t_float1, t_float2, t_float3);

    EXPECT_FLOAT_EQ(norm_1, 4.3174066f);
    EXPECT_EQ(norm_2, 4.f);
    EXPECT_EQ(norm_3, 5.3f);
    EXPECT_EQ(norm_4, 0.f);
    EXPECT_EQ(norm_5, 5.f);
    EXPECT_EQ(norm_6, 13.f);
    EXPECT_EQ(norm_7, 13.f);
}


TEST(MathTest, Constrain)
{
    for (int i = 0; i < 1000; i++) {
        if (i < 250) {
            EXPECT_EQ(250, constrain_float(i, 250, 500));
            EXPECT_EQ(250, constrain_int16(i, 250, 500));
            EXPECT_EQ(250, constrain_int32(i, 250, 500));
            EXPECT_EQ(250, constrain_int64(i, 250, 500));
        } else if (i > 500) {
            EXPECT_EQ(500, constrain_float(i, 250, 500));
            EXPECT_EQ(500, constrain_int16(i, 250, 500));
            EXPECT_EQ(500, constrain_int32(i, 250, 500));
            EXPECT_EQ(500, constrain_int64(i, 250, 500));
        } else {
            EXPECT_EQ(i, constrain_float(i, 250, 500));
            EXPECT_EQ(i, constrain_int16(i, 250, 500));
            EXPECT_EQ(i, constrain_int32(i, 250, 500));
            EXPECT_EQ(i, constrain_int64(i, 250, 500));
        }
    }

    for (int i = 0; i <= 1000; i++) {
        int c = i - 1000;
        if (c < -250) {
            EXPECT_EQ(-250, constrain_float(c, -250, -50));
            EXPECT_EQ(-250, constrain_int16(c, -250, -50));
            EXPECT_EQ(-250, constrain_int32(c, -250, -50));
            EXPECT_EQ(-250, constrain_int64(c, -250, -50));
        } else if(c > -50) {
            EXPECT_EQ(-50, constrain_float(c, -250, -50));
            EXPECT_EQ(-50, constrain_int16(c, -250, -50));
            EXPECT_EQ(-50, constrain_int32(c, -250, -50));
            EXPECT_EQ(-50, constrain_int64(c, -250, -50));
        } else {
            EXPECT_EQ(c, constrain_float(c, -250, -50));
            EXPECT_EQ(c, constrain_int16(c, -250, -50));
            EXPECT_EQ(c, constrain_int32(c, -250, -50));
            EXPECT_EQ(c, constrain_int64(c, -250, -50));
        }
    }

    for (int i = 0; i <= 2000; i++) {
        int c = i - 1000;
        if (c < -250) {
            EXPECT_EQ(-250, constrain_float(c, -250, 50));
            EXPECT_EQ(-250, constrain_int16(c, -250, 50));
            EXPECT_EQ(-250, constrain_int32(c, -250, 50));
            EXPECT_EQ(-250, constrain_int64(c, -250, 50));
        } else if(c > 50) {
            EXPECT_EQ(50, constrain_float(c, -250, 50));
            EXPECT_EQ(50, constrain_int16(c, -250, 50));
            EXPECT_EQ(50, constrain_int32(c, -250, 50));
            EXPECT_EQ(50, constrain_int64(c, -250, 50));
        } else {
            EXPECT_EQ(c, constrain_float(c, -250, 50));
            EXPECT_EQ(c, constrain_int16(c, -250, 50));
            EXPECT_EQ(c, constrain_int32(c, -250, 50));
            EXPECT_EQ(c, constrain_int64(c, -250, 50));
        }
    }

    EXPECT_EQ(20.0, constrain_value(20.0, 19.9, 20.1));
    EXPECT_EQ(20.0f, constrain_value(20.0f, 19.9f, 20.1f));
    EXPECT_EQ((long long int)20, constrain_value((long long int)20, (long long int)19, (long long int)20));

    EXPECT_EQ(20.1, constrain_value(21.0, 19.9, 20.1));
    EXPECT_EQ(20.1f, constrain_value(21.0f, 19.9f, 20.1f));

    EXPECT_EQ(19.9, constrain_value(19.9, 19.9, 20.1));
    EXPECT_EQ(19.9f, constrain_value(19.9f, 19.9f, 20.1f));

    EXPECT_EQ(19.9, constrain_value(19.8, 19.9, 20.1));
    EXPECT_EQ(19.9f, constrain_value(19.8f, 19.9f, 20.1f));

    // test that constrain on 32 bit integer works correctly. Note the asymmetry
    EXPECT_EQ(10,    constrain_int32( 0xFFFFFFFFU, 10U, 1200U));
    EXPECT_EQ(1200U, constrain_uint32(0xFFFFFFFFU, 10U, 1200U));

#if CONFIG_HAL_BOARD == HAL_BOARD_LINUX
    EXPECT_EQ(1.0f, constrain_float(nanf("0x4152"), 1.0f, 1.0f));
    EXPECT_EQ(1.0f, constrain_value(nanf("0x4152"), 1.0f, 1.0f));
#elif CONFIG_HAL_BOARD == HAL_BOARD_SITL
    EXPECT_EXIT(constrain_float(nanf("0x4152"), 1.0f, 1.0f), testing::KilledBySignal(SIGABRT), "AP_InternalError::error_t::cnstring_nan");
    EXPECT_EXIT(constrain_value(nanf("0x4152"), 1.0f, 1.0f), testing::KilledBySignal(SIGABRT), "AP_InternalError::error_t::cnstring_nan");
#endif
}

TEST(MathWrapTest, Angle180)
{
    // Full circle test
    for (int32_t i = 0; i < 36000; i += 100) {
        if (i < 18000) {
            // smaller pole position
            EXPECT_EQ(i, wrap_180_cd(i));
            EXPECT_EQ(-i, wrap_180_cd(-i));
            EXPECT_EQ(i, wrap_180_cd((long)i));
            EXPECT_EQ(-i, wrap_180_cd((long)-i));
        } else if (i == 18000) {
            // hit pole position -180/+180 degree
            EXPECT_EQ(i, wrap_180_cd(i));
            EXPECT_EQ(i, wrap_180_cd(-i));
            EXPECT_EQ(i, wrap_180_cd((long)i));
            EXPECT_EQ(i, wrap_180_cd((long)-i));
        } else {
            // bigger pole position
            EXPECT_EQ(-(36000 - i), wrap_180_cd(i));
            EXPECT_EQ(36000 - i, wrap_180_cd(-i));
            EXPECT_EQ(-(36000 - i), wrap_180_cd((long)i));
            EXPECT_EQ(36000 - i, wrap_180_cd((long)-i));
        }
    }

    EXPECT_EQ(4500.f,   wrap_180_cd(4500.f));
    EXPECT_EQ(9000.f,   wrap_180_cd(9000.f));
    EXPECT_EQ(18000.f,  wrap_180_cd(18000.f));
    EXPECT_EQ(-17990.f, wrap_180_cd(18010.f));
    EXPECT_EQ(-9000.f,  wrap_180_cd(27000.f));
    EXPECT_EQ(0.f,      wrap_180_cd(36000.f));
    EXPECT_EQ(0.f,      wrap_180_cd(72000.f));
    EXPECT_EQ(0.f,      wrap_180_cd(360000.f));
    EXPECT_EQ(0.f,      wrap_180_cd(720000.f));
    EXPECT_EQ(0.f,      wrap_180_cd(-3600000000.f));

    EXPECT_EQ(-4500.f, wrap_180_cd(-4500.f));
    EXPECT_EQ(-9000.f, wrap_180_cd(-9000.f));
    EXPECT_EQ(18000.f, wrap_180_cd(-18000.f));
    EXPECT_EQ(17990.f, wrap_180_cd(-18010.f));
    EXPECT_EQ(9000.f,  wrap_180_cd(-27000.f));
    EXPECT_EQ(0.f,     wrap_180_cd(-36000.f));
    EXPECT_EQ(0.f,     wrap_180_cd(-72000.f));

    EXPECT_EQ(4500, wrap_180_cd((short)4500));
    EXPECT_EQ(-4500, wrap_180_cd((short)-4500));

    EXPECT_EQ(45,   wrap_180(int16_t(45)));
    EXPECT_EQ(90,   wrap_180(int16_t(90)));
    EXPECT_EQ(180,  wrap_180(int16_t(180)));
    EXPECT_EQ(-179, wrap_180(int16_t(181)));
    EXPECT_EQ(-90,  wrap_180(int16_t(270)));
    EXPECT_EQ(0,      wrap_180(int16_t(360)));
    EXPECT_EQ(0,      wrap_180(int16_t(720)));
    EXPECT_EQ(0,      wrap_180(int16_t(3600)));
    EXPECT_EQ(0,      wrap_180((int16_t(7200))));
    EXPECT_EQ(0,      wrap_180((int16_t)-3600));
}

TEST(MathWrapTest, Angle360)
{
    // Full circle test
    for (int32_t i = 0; i <= 36000; i += 100) {
        if (i == 0) {
            // hit pole position
            EXPECT_EQ(i, wrap_360_cd(i));
            EXPECT_EQ(i, wrap_360_cd(-i));
            EXPECT_EQ(i, wrap_360_cd(long(i)));
            EXPECT_EQ(i, wrap_360_cd(long(-i)));
        } else if (i < 36000) {
            // between pole position
            EXPECT_EQ(i, wrap_360_cd(i));
            EXPECT_EQ(36000 - i, wrap_360_cd(-i));
            EXPECT_EQ(i, wrap_360_cd(long(i)));
            EXPECT_EQ(36000 - i, wrap_360_cd(long(-i)));
        } else if (i == 36000) {
            // hit pole position
            EXPECT_EQ(0, wrap_360_cd(i));
            EXPECT_EQ(0, wrap_360_cd(-i));
            EXPECT_EQ(0, wrap_360_cd(long(i)));
            EXPECT_EQ(0, wrap_360_cd(long(-i)));
        }
    }

    EXPECT_EQ(4500.f,  wrap_360_cd(4500.f));
    EXPECT_EQ(9000.f,  wrap_360_cd(9000.f));
    EXPECT_EQ(18000.f, wrap_360_cd(18000.f));
    EXPECT_EQ(27000.f, wrap_360_cd(27000.f));
    EXPECT_EQ(0.f,     wrap_360_cd(36000.f));
    EXPECT_EQ(5.f,     wrap_360_cd(36005.f));
    EXPECT_EQ(0.f,     wrap_360_cd(72000.f));
    EXPECT_EQ(0.f,     wrap_360_cd(360000.f));
    EXPECT_EQ(0.f,     wrap_360_cd(720000.f));
    EXPECT_EQ( 0.f,    wrap_360_cd(-3600000000.f));

    EXPECT_EQ(31500.f, wrap_360_cd(-4500.f));
    EXPECT_EQ(27000.f, wrap_360_cd(-9000.f));
    EXPECT_EQ(18000.f, wrap_360_cd(-18000.f));
    EXPECT_EQ(9000.f,  wrap_360_cd(-27000.f));
    EXPECT_EQ(0.f,     wrap_360_cd(-36000.f));
    EXPECT_EQ(35995.0f,wrap_360_cd(-36005.f));
    EXPECT_EQ(0.f,     wrap_360_cd(-72000.f));


    EXPECT_EQ(45.0f,  wrap_360(45.0f));
    EXPECT_EQ(90.0f,  wrap_360(90.0f));
    EXPECT_EQ(180.0f, wrap_360(180.0f));
    EXPECT_EQ(270.0f, wrap_360(270.0f));
    EXPECT_EQ(0.0f,     wrap_360(360.0f));
    EXPECT_EQ(1.0f,     wrap_360(361.0f));
    EXPECT_EQ(0.0f,     wrap_360(720.0f));
    EXPECT_EQ(0.0f,     wrap_360(3600.0f));
    EXPECT_EQ(0.0f,     wrap_360(7200.0f));
    EXPECT_EQ(260.0f,     wrap_360(-100.0f));

    EXPECT_EQ(45,  wrap_360((int16_t)45));
    EXPECT_EQ(90,  wrap_360((int16_t)90));
    EXPECT_EQ(180, wrap_360((int16_t)180));
    EXPECT_EQ(270, wrap_360((int16_t)270));
    EXPECT_EQ(0,     wrap_360((int16_t)360));
    EXPECT_EQ(1,     wrap_360((int16_t)361));
    EXPECT_EQ(0,     wrap_360((int16_t)720));
    EXPECT_EQ(0,     wrap_360((int16_t)3600));
    EXPECT_EQ(0,     wrap_360((int16_t)7200));
    EXPECT_EQ(260,     wrap_360((int16_t)-100));

}

TEST(MathWrapTest, AnglePI)
{
    const float accuracy = 1.0e-5;

    EXPECT_NEAR(M_PI,    wrap_PI(M_PI),      accuracy);
    EXPECT_NEAR(0.f,     wrap_PI(M_2PI),     accuracy);
    EXPECT_NEAR(0,       wrap_PI(M_PI * 10), accuracy);
    EXPECT_NEAR(-2.1415925025939941f,    wrap_PI(M_PI+1),      accuracy);
    EXPECT_NEAR(1.f,     wrap_PI(1),     accuracy);
    EXPECT_NEAR(1.f,     wrap_PI((short)1),     accuracy);
}

TEST(MathWrapTest, Angle2PI)
{
    const float accuracy = 1.0e-5;

    EXPECT_NEAR(M_PI, wrap_2PI(M_PI), accuracy);
    EXPECT_NEAR(0.f,  wrap_2PI(M_2PI), accuracy);
    EXPECT_NEAR(0.f,  wrap_2PI(M_PI * 10), accuracy);
    EXPECT_NEAR(0.f,  wrap_2PI(0.f), accuracy);
    EXPECT_NEAR(M_PI, wrap_2PI(-M_PI), accuracy);
    EXPECT_NEAR(0,    wrap_2PI(-M_2PI), accuracy);
    EXPECT_NEAR(1,    wrap_2PI(1), accuracy);
    EXPECT_NEAR(1,    wrap_2PI((short)1), accuracy);
}

TEST(MathTest, ASin)
{
    const float accuracy = 1.0e-5;
    EXPECT_NEAR(0.0f, safe_asin(0.0f), accuracy);
    EXPECT_NEAR(0.9033391107665127f, safe_asin(M_PI_2 * 0.5f), accuracy);
    EXPECT_NEAR(M_PI_2, safe_asin(M_PI_2 ), accuracy);
    EXPECT_NEAR(M_PI_2, safe_asin(M_PI), accuracy);
    EXPECT_NEAR(M_PI_2, safe_asin(M_2PI), accuracy);
    EXPECT_NEAR(-M_PI_2, safe_asin(-M_PI_2), accuracy);
    EXPECT_NEAR(-M_PI_2, safe_asin(-M_PI), accuracy);
    EXPECT_NEAR(-0.9033391107665127f, safe_asin(-M_PI_2 * 0.5f), accuracy);
    EXPECT_NEAR(0.0f, safe_asin(nanf("0x4152")), accuracy);
    EXPECT_NEAR(0.0f, safe_asin(int(0)), accuracy);
    EXPECT_NEAR(0.0f, safe_asin(short(0)), accuracy);
    EXPECT_NEAR(0.0f, safe_asin(double(0.0)), accuracy);

}

TEST(MathTest, Sqrt)
{
    const float accuracy = 1.0e-5;
    EXPECT_NEAR(0.0f, safe_sqrt(0.0f), accuracy);
    EXPECT_NEAR(32.0f, safe_sqrt(1024.0f), accuracy);
    EXPECT_NEAR(0.0f, safe_sqrt(-1.0f), accuracy);

    EXPECT_NEAR(0.0f, safe_sqrt(nanf("0x4152")), accuracy);
    EXPECT_NEAR(0.0f, safe_sqrt(int(0)), accuracy);
    EXPECT_NEAR(0.0f, safe_sqrt(short(0)), accuracy);
    EXPECT_NEAR(0.0f, safe_sqrt(double(0.0)), accuracy);

}

TEST(MathTest, Interpolation)
{
    const float accuracy = 1.0e-5;
    EXPECT_NEAR(1500.0f, linear_interpolate(1200.0f, 1800.0f, 1500.0f, 1000.0f, 2000.0f), accuracy);
    EXPECT_NEAR(1740.0f, linear_interpolate(1200.0f, 1800.0f, 1900.0f, 1000.0f, 2000.0f), accuracy);
    EXPECT_NEAR(1200.0f, linear_interpolate(1200.0f, 1800.0f, 1000.0f, 1000.0f, 2000.0f), accuracy);
    EXPECT_NEAR(1000.0f, linear_interpolate(1000.0f, 2000.0f, 1100.0f, 1200.0f, 1800.0f), accuracy);
    EXPECT_NEAR(2000.0f, linear_interpolate(1000.0f, 2000.0f, 1900.0f, 1200.0f, 1800.0f), accuracy);

}

TEST(MathTest, ThrottleCurve)
{
    // get hover throttle level [0,1]
    static constexpr float THR_MID = 0.5f;

    const float accuracy = 1.0e-5;
    EXPECT_NEAR(0.0f, throttle_curve(THR_MID, 0.0f, 0.0f), accuracy);
    EXPECT_NEAR(0.25f, throttle_curve(THR_MID, 0.0f, 0.25f), accuracy);
    EXPECT_NEAR(0.5f, throttle_curve(THR_MID, 0.0f, 0.5f), accuracy);
    EXPECT_NEAR(0.75f, throttle_curve(THR_MID, 0.0f, 0.75f), accuracy);
    EXPECT_NEAR(1.0f, throttle_curve(THR_MID, 0.0f, 1.0f), accuracy);
    EXPECT_NEAR(0.0f, throttle_curve(THR_MID, 0.25f, 0.0f), accuracy);
    EXPECT_NEAR(0.296875f, throttle_curve(THR_MID, 0.25f, 0.25f), accuracy);
    EXPECT_NEAR(0.5f, throttle_curve(THR_MID, 0.25f, 0.5f), accuracy);
    EXPECT_NEAR(0.703125f, throttle_curve(THR_MID, 0.25f, 0.75f), accuracy);
    EXPECT_NEAR(1.0f, throttle_curve(THR_MID, 0.25f, 1.0f), accuracy);
    EXPECT_NEAR(0.0f, throttle_curve(THR_MID, 0.5f, 0.0f), accuracy);
    EXPECT_NEAR(0.34375f, throttle_curve(THR_MID, 0.5f, 0.25f), accuracy);
    EXPECT_NEAR(0.5f, throttle_curve(THR_MID, 0.5f, 0.5f), accuracy);
    EXPECT_NEAR(0.65625f, throttle_curve(THR_MID, 0.5f, 0.75f), accuracy);
    EXPECT_NEAR(1.0f, throttle_curve(THR_MID, 0.5f, 1.0f), accuracy);
    EXPECT_NEAR(0.0f, throttle_curve(THR_MID, 0.75f, 0.0f), accuracy);
    EXPECT_NEAR(0.390625f, throttle_curve(THR_MID, 0.75f, 0.25f), accuracy);
    EXPECT_NEAR(0.5f, throttle_curve(THR_MID, 0.75f, 0.5f), accuracy);
    EXPECT_NEAR(0.609375f, throttle_curve(THR_MID, 0.75f, 0.75f), accuracy);
    EXPECT_NEAR(1.0f, throttle_curve(THR_MID, 0.75f, 1.0f), accuracy);
    EXPECT_NEAR(0.0f, throttle_curve(THR_MID, 1.0f, 0.0f), accuracy);
    EXPECT_NEAR(0.4375f, throttle_curve(THR_MID, 1.0f, 0.25f), accuracy);
    EXPECT_NEAR(0.5f, throttle_curve(THR_MID, 1.0f, 0.5f), accuracy);
    EXPECT_NEAR(0.5625f, throttle_curve(THR_MID, 1.0f, 0.75f), accuracy);
    EXPECT_NEAR(1.0f, throttle_curve(THR_MID, 1.0f, 1.0f), accuracy);
}

TEST(MathTest, RotationEqual)
{
    EXPECT_TRUE(rotation_equal(ROTATION_ROLL_180_YAW_90, ROTATION_ROLL_180_YAW_90));
    EXPECT_TRUE(rotation_equal(ROTATION_ROLL_180_YAW_90, ROTATION_PITCH_180_YAW_270));
    EXPECT_FALSE(rotation_equal(ROTATION_NONE, ROTATION_PITCH_180_YAW_270));
}

TEST(MathTest, FIXED2FLOAT)
{
    static constexpr uint16_t test_value = 1024;
    EXPECT_EQ(512.0f, fixed2float(test_value, 1));
    EXPECT_EQ(256.0f, fixed2float(test_value, 2));
}

TEST(MathTest, FLOAT2FIXED)
{
    static constexpr float test_value = 1024.0f;
    EXPECT_EQ(2048, float2fixed(test_value, 1));
    EXPECT_EQ(4096, float2fixed(test_value, 2));
}

TEST(MathTest, RANDOM16)
{
    static const uint16_t random_value = get_random16();
    EXPECT_NE(random_value, get_random16());
}

TEST(MathTest, VELCORRECTION)
{
    static constexpr Vector3F pos{1.0f, 1.0f, 0.0f};
    static constexpr Matrix3F rot(0.0f, -1.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f, 0.0f, 1.0f);
    static constexpr Vector3F rate{-1.0f, -1.0f, -1.0f};
    EXPECT_TRUE(Vector3F(1.0f, 1.0f, 0.0f) == get_vel_correction_for_sensor_offset(pos, rot, rate));
    EXPECT_TRUE(Vector3F() == get_vel_correction_for_sensor_offset(Vector3F(), rot, rate));
}

TEST(MathTest, LOWPASSALPHA)
{
    const float accuracy = 1.0e-5f;
    EXPECT_EQ(0.0f, calc_lowpass_alpha_dt(0.0f, 2.0f));
    EXPECT_EQ(1.0f, calc_lowpass_alpha_dt(1.0f, 0.0f));

    EXPECT_NEAR(0.926288f, calc_lowpass_alpha_dt(1.0f, 2.0f), accuracy);
}

TEST(MathTest, FIXEDWINGTURNRATE)
{
    const float accuracy = 1.0e-5f;

    EXPECT_NEAR(-318.65771484375f, fixedwing_turn_rate(-90, 10.0f), accuracy);
    EXPECT_NEAR(318.65771484375f, fixedwing_turn_rate(90, 10.0f), accuracy);
    EXPECT_NEAR(56.187965393066406f, fixedwing_turn_rate(45, 10.0f), accuracy);
}

TEST(CRCTest, parity)
{
    EXPECT_EQ(parity(0b1), 1);
    EXPECT_EQ(parity(0b10), 1);
    EXPECT_EQ(parity(0b100), 1);

    EXPECT_EQ(parity(0b11), 0);
    EXPECT_EQ(parity(0b110), 0);
    EXPECT_EQ(parity(0b111), 1);
    EXPECT_EQ(parity(0b11111111), 0);
}

TEST(MathTest, div1000)
{
    for (uint32_t i=0; i<1000000; i++) {
        uint64_t v;
        EXPECT_EQ(hal.util->get_random_vals((uint8_t*)&v, sizeof(v)), true);
        uint64_t v1 = v / 1000ULL;
        uint64_t v2 = uint64_div1000(v);
        EXPECT_EQ(v1, v2);
    }
}

AP_GTEST_PANIC()
AP_GTEST_MAIN()

#pragma GCC diagnostic pop
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       
// given we are in the Math library, you're epected to know what
// you're doing when directly comparing floats:
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wfloat-equal"
#include <AP_gtest.h>

#include <AP_Math/AP_Math.h>

const AP_HAL::HAL& hal = AP_HAL::get_HAL();


TEST(MathTest, IsZeroDouble)
{
    EXPECT_FALSE(is_zero(0.1));
    EXPECT_FALSE(is_zero(0.0001));
    EXPECT_TRUE(is_zero(0.0));
    EXPECT_TRUE(is_zero(DBL_MIN));
    EXPECT_TRUE(is_zero(-DBL_MIN));
}

TEST(MathTest, MAXDouble)
{
    AP_Float t_float;
    t_float.set(0.1f);
    EXPECT_EQ(2.0, MAX(t_float, 2.0));
}
TEST(MathTest, IsEqualDouble)
{
    EXPECT_FALSE(is_equal(1.0, 0.0));
    EXPECT_TRUE(is_equal(1.0, 1.0));
    EXPECT_FALSE(is_equal(0.1,  0.10001));
    EXPECT_FALSE(is_equal(0.1, -0.1001));
    EXPECT_TRUE(is_equal(0.0,   0.0));
    EXPECT_FALSE(is_equal(1.0,  1.0 + DBL_EPSILON));
    EXPECT_TRUE(is_equal(1.0,  1.0 + DBL_EPSILON / 2.0));
    EXPECT_FALSE(is_equal((double)1.0, (double)(1.0 - DBL_EPSILON)));

    // false because the common type is double
    EXPECT_FALSE(is_equal(double(1.0), 1 + 2 * std::numeric_limits<double>::epsilon()));

    // true because the common type is float
    EXPECT_FALSE(is_equal((double)1.0, (double)(1.0 + std::numeric_limits<double>::epsilon())));
}

TEST(MathTest, ConstrainDouble)
{
    for (int i = 0; i < 1000; i++) {
        if (i < 250) {
            EXPECT_EQ(250.0, constrain_value((double)i, 250.0, 500.0));
        } else if (i > 500) {
            EXPECT_EQ(500.0, constrain_value((double)i, 250.0, 500.0));
        } else {
            EXPECT_EQ(i, constrain_value((double)i, 250.0, 500.0));
        }
    }

    for (int i = 0; i <= 1000; i++) {
        int c = i - 1000;
        if (c < -250) {
            EXPECT_EQ(-250.0, constrain_value((double)c, -250.0, -50.0));
        } else if(c > -50) {
            EXPECT_EQ(-50.0, constrain_value((double)c, -250.0, -50.0));
        } else {
            EXPECT_EQ(c, constrain_value((double)c, -250.0, -50.0));
        }
    }

    for (int i = 0; i <= 2000; i++) {
        int c = i - 1000;
        if (c < -250) {
            EXPECT_EQ(-250.0, constrain_value((double)c, -250.0, 50.0));
        } else if(c > 50) {
            EXPECT_EQ(50.0, constrain_value((double)c, -250.0, 50.0));
        } else {
            EXPECT_EQ(c, constrain_value((double)c, -250.0, 50.0));
        }
    }

    EXPECT_EQ(20.0, constrain_value(20.0, 19.9, 20.1));

    EXPECT_EQ(20.1, constrain_value(21.0, 19.9, 20.1));

    EXPECT_EQ(19.9, constrain_value(19.9, 19.9, 20.1));

    EXPECT_EQ(19.9, constrain_value(19.8, 19.9, 20.1));

#if CONFIG_HAL_BOARD == HAL_BOARD_LINUX
    EXPECT_EQ(1.0, constrain_value(nan("0x4152"), 1.0, 1.0));
#elif CONFIG_HAL_BOARD == HAL_BOARD_SITL
    EXPECT_EXIT(constrain_value(nan("0x4152"), 1.0, 1.0), testing::KilledBySignal(SIGABRT), "AP_InternalError::error_t::cnstring_nan");
#endif
}

TEST(MathWrapTest, Angle180Double)
{
    EXPECT_EQ(4500.0,   wrap_180_cd(4500.0));
    EXPECT_EQ(9000.0,   wrap_180_cd(9000.0));
    EXPECT_EQ(18000.0,  wrap_180_cd(18000.0));
    EXPECT_EQ(-17990.0, wrap_180_cd(18010.0));
    EXPECT_EQ(-9000.0,  wrap_180_cd(27000.0));
    EXPECT_EQ(0.0,      wrap_180_cd(36000.0));
    EXPECT_EQ(0.0,      wrap_180_cd(72000.0));
    EXPECT_EQ(0.0,      wrap_180_cd(360000.0));
    EXPECT_EQ(0.0,      wrap_180_cd(720000.0));
    EXPECT_EQ(0.0,      wrap_180_cd(-3600000000.0));

    EXPECT_EQ(-4500.0, wrap_180_cd(-4500.0));
    EXPECT_EQ(-9000.0, wrap_180_cd(-9000.0));
    EXPECT_EQ(18000.0, wrap_180_cd(-18000.0));
    EXPECT_EQ(17990.0, wrap_180_cd(-18010.0));
    EXPECT_EQ(9000.0,  wrap_180_cd(-27000.0));
    EXPECT_EQ(0.0,     wrap_180_cd(-36000.0));
    EXPECT_EQ(0.0,     wrap_180_cd(-72000.0));

    EXPECT_EQ(-45.0, wrap_180(-45.0));
    EXPECT_EQ(-90.0, wrap_180(-90.0));
    EXPECT_EQ(180.0, wrap_180(-180.0));
    EXPECT_EQ(90.0,  wrap_180(-270.0));
    EXPECT_EQ(0.0,     wrap_180(-360.0));
    EXPECT_EQ(0.0,     wrap_180(-720.0));
}

TEST(MathWrapTest, Angle360Double)
{
// Full circle test
    for (int32_t i = 0; i <= 36000; i += 100) {
        if (i == 0) {
            // hit pole position
            EXPECT_EQ(i, wrap_360_cd(static_cast<double>(i)));
            EXPECT_EQ(i, wrap_360_cd(static_cast<double>(-i)));
        } else if (i < 36000) {
            // between pole position
            EXPECT_EQ(i, wrap_360_cd(static_cast<double>(i)));
            EXPECT_EQ(36000.0 - i, wrap_360_cd(static_cast<double>(-i)));
        } else if (i == 36000) {
            // hit pole position
            EXPECT_EQ(0.0, wrap_360_cd(static_cast<double>(i)));
            EXPECT_EQ(0.0, wrap_360_cd(static_cast<double>(-i)));
        }
    }

    EXPECT_EQ(4500.0,  wrap_360_cd(static_cast<double>(4500.0)));
    EXPECT_EQ(9000.0,  wrap_360_cd(static_cast<double>(9000.0)));
    EXPECT_EQ(18000.0, wrap_360_cd(static_cast<double>(18000.0)));
    EXPECT_EQ(27000.0, wrap_360_cd(static_cast<double>(27000.0)));
    EXPECT_EQ(0.0,     wrap_360_cd(static_cast<double>(36000.0)));
    EXPECT_EQ(5.0,     wrap_360_cd(static_cast<double>(36005.0)));
    EXPECT_EQ(0.0,     wrap_360_cd(static_cast<double>(72000.0)));
    EXPECT_EQ(0.0,     wrap_360_cd(static_cast<double>(360000.0)));
    EXPECT_EQ(0.0,     wrap_360_cd(static_cast<double>(720000.0)));
    EXPECT_EQ( 0.0,    wrap_360_cd(static_cast<double>(-3600000000.0)));

    EXPECT_EQ(31500.0, wrap_360_cd(static_cast<double>(-4500.0)));
    EXPECT_EQ(27000.0, wrap_360_cd(static_cast<double>(-9000.0)));
    EXPECT_EQ(18000.0, wrap_360_cd(static_cast<double>(-18000.0)));
    EXPECT_EQ(9000.0,  wrap_360_cd(static_cast<double>(-27000.0)));
    EXPECT_EQ(0.0,     wrap_360_cd(static_cast<double>(-36000.0)));
    EXPECT_EQ(35995.0,wrap_360_cd(static_cast<double>(-36005.0)));
    EXPECT_EQ(0.0,     wrap_360_cd(static_cast<double>(-72000.0)));

    EXPECT_EQ(45.0,  wrap_360(static_cast<double>(45.0)));
    EXPECT_EQ(90.0,  wrap_360(static_cast<double>(90.0)));
    EXPECT_EQ(180.0, wrap_360(static_cast<double>(180.0)));
    EXPECT_EQ(270.0, wrap_360(static_cast<double>(270.0)));
    EXPECT_EQ(0.0,     wrap_360(static_cast<double>(360.0)));
    EXPECT_EQ(1.0,     wrap_360(static_cast<double>(361.0)));
    EXPECT_EQ(0.0,     wrap_360(static_cast<double>(720.0)));
    EXPECT_EQ(0.0,     wrap_360(static_cast<double>(3600.0)));
    EXPECT_EQ(0.0,     wrap_360(static_cast<double>(7200.0)));
    EXPECT_EQ(260.0,     wrap_360(static_cast<double>(-100.0)));
}

TEST(MathWrapTest, AnglePIDouble)
{
    const double accuracy = 1.0e-5;

    EXPECT_NEAR(M_PI,    wrap_PI((double)M_PI),      accuracy);
    EXPECT_NEAR(0.0,     wrap_PI((double)M_2PI),     accuracy);
    EXPECT_NEAR(0,       wrap_PI((double)M_PI * 10.0), accuracy);
    EXPECT_NEAR(-2.1415925025939941,    wrap_PI((double)M_PI+1.0),      accuracy);
}

TEST(MathWrapTest, Angle2PIDouble)
{
    const double accuracy = 1.0e-5;

    EXPECT_NEAR(M_PI, wrap_2PI((double)M_PI), accuracy);
    EXPECT_NEAR(0.0,  wrap_PI((double)M_2PI), accuracy);
    EXPECT_NEAR(0.0,  wrap_PI((double)M_PI * 10.0), accuracy);
    EXPECT_NEAR(0.0,  wrap_2PI(0.0), accuracy);
    EXPECT_NEAR(M_PI, wrap_2PI((double)-M_PI), accuracy);
    EXPECT_NEAR(0,    wrap_2PI((double)-M_2PI), accuracy);
}

TEST(MathTest, ASinDouble)
{
    const double accuracy = 1.0e-5;
    EXPECT_NEAR(0.0, safe_asin(double(0.0)), accuracy);

}

TEST(MathTest, SqrtDouble)
{
    const double accuracy = 1.0e-5;
    EXPECT_NEAR(0.0, safe_sqrt(double(0.0)), accuracy);

}

TEST(MathTest, SquareDouble)
{
    double sq_0 = sq(0);
    double sq_1 = sq(1);
    double sq_2 = sq(2);

    EXPECT_DOUBLE_EQ(0.0, sq_0);
    EXPECT_DOUBLE_EQ(1.0, sq_1);
    EXPECT_DOUBLE_EQ(4.0, sq_2);
}

TEST(MathTest, NormDouble)
{
    double norm_1 = norm(1.0, 4.2);
    double norm_2 = norm(1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1);
    double norm_3 = norm(0, 5.3);
    double norm_4 = norm(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);
    double norm_5 = norm(3,4);
    double norm_6 = norm(4.0,3.0,12.0);

    EXPECT_DOUBLE_EQ(norm_1, 4.3174066289845809);
    EXPECT_DOUBLE_EQ(norm_2, 4.0);
    EXPECT_DOUBLE_EQ(norm_3, 5.2999999999999998);
    EXPECT_DOUBLE_EQ(norm_4, 0.0);
    EXPECT_DOUBLE_EQ(norm_5, 5.0);
    EXPECT_DOUBLE_EQ(norm_6, 13.0);
}

AP_GTEST_PANIC()
AP_GTEST_MAIN()

#pragma GCC diagnostic pop
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  /*
 * Copyright (C) 2016  Intel Corporation. All rights reserved.
 *
 * This file is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This file is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include "math_test.h"

const AP_HAL::HAL& hal = AP_HAL::get_HAL();

// given we are in the Math library, you're epected to know what
// you're doing when directly comparing floats:
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wfloat-equal"

#define AP_EXPECT_IDENTITY_MATRIX(m_) {\
    EXPECT_NEAR(1.0f, m_.a.x, 1.0e-6); \
    EXPECT_NEAR(0.0f, m_.a.y, 1.0e-6); \
    EXPECT_NEAR(0.0f, m_.a.z, 1.0e-6); \
    EXPECT_NEAR(0.0f, m_.b.x, 1.0e-6); \
    EXPECT_NEAR(1.0f, m_.b.y, 1.0e-6); \
    EXPECT_NEAR(0.0f, m_.b.z, 1.0e-6); \
    EXPECT_NEAR(0.0f, m_.c.x, 1.0e-6); \
    EXPECT_NEAR(0.0f, m_.c.y, 1.0e-6); \
    EXPECT_NEAR(1.0f, m_.c.z, 1.0e-6); \
}

class TestParam {
public:
    /**
     * The matrix for this param.
     */
    Matrix3f m;
    /**
     * The expected determinant for #m.
     */
    float det;
};

AP_GTEST_PRINTATBLE_PARAM_MEMBER(TestParam, m);

class Matrix3fTest : public ::testing::TestWithParam<TestParam> {};

static TestParam invertible[] = {
    {
        .m = {
            {1.0f,  2.0f,  3.0f},
            {4.0f,  6.0f,  2.0f},
            {9.0f, 18.0f, 27.0f}
        },
        .det = 0.0f,
    },
};

static TestParam non_invertible[] = {
    {
        .m = {
            { 6.0f,  2.0f,  20.0f},
            { 1.0f, -9.0f,   4.0f},
            {-4.0f,  7.0f, -27.0f}
        },
        .det = 732.0f,
    },
    {
        .m = {
            {-6.0f, -2.0f, -20.0f},
            {-1.0f,  9.0f,  -4.0f},
            { 4.0f, -7.0f,  27.0f}
        },
        .det = -732.0f,
    },
};

TEST_P(Matrix3fTest, Determinants)
{
    auto param = GetParam();
    EXPECT_FLOAT_EQ(param.det, param.m.det());
}

TEST_P(Matrix3fTest, Inverses)
{
    auto param = GetParam();
    Matrix3f inv;
    bool success = param.m.inverse(inv);

    if (param.det == 0.0f) {
        EXPECT_FALSE(success);
    } else {
        ASSERT_TRUE(success);
        auto identity = inv * param.m;
        AP_EXPECT_IDENTITY_MATRIX(identity);
    }
}

INSTANTIATE_TEST_CASE_P(InvertibleMatrices,
                        Matrix3fTest,
                        ::testing::ValuesIn(invertible));

INSTANTIATE_TEST_CASE_P(NonInvertibleMatrices,
                        Matrix3fTest,
                        ::testing::ValuesIn(non_invertible));

AP_GTEST_MAIN()

#pragma GCC diagnostic pop
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        #include <AP_gtest.h>

#include <AP_Math/vector2.h>
#include <AP_Math/vector3.h>

const AP_HAL::HAL& hal = AP_HAL::get_HAL();

#define EXPECT_VECTOR2F_EQ(v1, v2)              \
    do {                                        \
        EXPECT_FLOAT_EQ(v1[0], v2[0]);          \
        EXPECT_FLOAT_EQ(v1[1], v2[1]);          \
    } while (false);

#define EXPECT_VECTOR3F_EQ(v1, v2)              \
    do {                                        \
        EXPECT_FLOAT_EQ(v1[0], v2[0]);          \
        EXPECT_FLOAT_EQ(v1[1], v2[1]);          \
        EXPECT_FLOAT_EQ(v1[2], v2[2]);          \
    } while (false);


#define PERP_TEST_2D(px,py, vx,vy, ex,ey)               \
    do {                                                \
        Vector2f p(px,py);                              \
        Vector2f v(vx,vy);                              \
        Vector2f expected(ex,ey);                       \
        Vector2f result;                                \
        result = Vector2f::perpendicular(p, v);         \
        EXPECT_VECTOR2F_EQ(expected, result);           \
    } while (false)

#define PERP_TEST_3D(px,py,pz, vx,vy,vz, ex,ey,ez)      \
    do {                                                \
        Vector3f p(px,py,pz);                           \
        Vector3f v(vx,vy,vz);                           \
        Vector3f expected(ex,ey,ez);                    \
        Vector3f result;                                \
        result = Vector3f::perpendicular(p, v);         \
        EXPECT_VECTOR3F_EQ(expected, result);           \
    } while (false)

TEST(ThreatTests, Distance)
{

    PERP_TEST_2D( 0.0f,0.0f, 0.0f,0.0f, 0.0f,0.0f);
    PERP_TEST_2D( 0.0f,0.0f, 1.0f,0.0f, 0.0f,-1.0f);
    PERP_TEST_2D( 2.0f,0.0f, 1.0f,0.0f, 0.0f,-1.0f);
    PERP_TEST_2D( 0.0f,2.0f, 1.0f,0.0f, 0.0f,1.0f);
    PERP_TEST_2D( 0.0f,2.0f, 1.0f,2.0f, -2.0f,1.0f);
    PERP_TEST_2D( 2.0f,0.0f, 1.0f,2.0f, 2.0f,-1.0f);

    // 2D cases for the 3D code:
    PERP_TEST_3D( 0.0f,0.0f,0.0f, 0.0f,0.0f,0.0f, 0.0f,0.0f,0.0f);
    PERP_TEST_3D( 0.0f,0.0f,0.0f, 1.0f,0.0f,0.0f, 0.0f,0.0f,0.0f);
    PERP_TEST_3D( 2.0f,0.0f,0.0f, 1.0f,0.0f,0.0f, 0.0f,0.0f,0.0f);
    PERP_TEST_3D( 0.0f,2.0f,0.0f, 1.0f,0.0f,0.0f, 0.0f,2.0f,0.0f);
    PERP_TEST_3D( 0.0f,2.0f,0.0f, 1.0f,2.0f,0.0f, -0.8f,0.4f,0.0f);
    PERP_TEST_3D( 2.0f,0.0f,0.0f, 1.0f,2.0f,0.0f, 1.6f,-0.8f,0.0f);


    // 3D-specific tests
    PERP_TEST_3D( 1.0f,1.0f,1.0f, 1.0f,0.0f,0.0f, 0.0f,1.0f,1.0f);
    PERP_TEST_3D( -1.0f,-1.0f,-1.0f, -1.0f,0.0f,0.0f, 0.0f,-1.0f,-1.0f);
    PERP_TEST_3D(1.0f,1.0f,0.0f, 1.0f,0.0f,0.0f, 0.0f,1.0f,0.0f);

    PERP_TEST_3D(1.0f,1.0f,1.0f, 1.0f,-1.0f,0.0f, 1.0f,1.0f,1.0f);

    PERP_TEST_3D(1.0f,1.0f,1.0f, 1.0f,-1.0f,1.0f, 0.66666666f,1.33333333f,0.66666666f);
}

AP_GTEST_MAIN()
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              