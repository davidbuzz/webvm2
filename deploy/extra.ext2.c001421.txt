
#define REG2_AA_FILTER_BW_194HZ_A       ((0<<7) | (1<<6))
#define REG2_AA_FILTER_BW_362HZ_A       ((1<<7) | (0<<6))
#define REG2_AA_FILTER_BW_50HZ_A        ((1<<7) | (1<<6))

#define REG2_FULL_SCALE_BITS_A  ((1<<5) | (1<<4) | (1<<3))
#define REG2_FULL_SCALE_2G_A    ((0<<5) | (0<<4) | (0<<3))
#define REG2_FULL_SCALE_4G_A    ((0<<5) | (0<<4) | (1<<3))
#define REG2_FULL_SCALE_6G_A    ((0<<5) | (1<<4) | (0<<3))
#define REG2_FULL_SCALE_8G_A    ((0<<5) | (1<<4) | (1<<3))
#define REG2_FULL_SCALE_16G_A   ((1<<5) | (0<<4) | (0<<3))

#define REG5_ENABLE_T           (1<<7)

#define REG5_RES_HIGH_M         ((1<<6) | (1<<5) | (1<<7))
#define REG5_RES_LOW_M          ((0<<6) | (0<<5))

#define REG5_RATE_BITS_M        ((1<<4) | (1<<3) | (1<<2))
#define REG5_RATE_3_125HZ_M     ((0<<4) | (0<<3) | (0<<2))
#define REG5_RATE_6_25HZ_M      ((0<<4) | (0<<3) | (1<<2))
#define REG5_RATE_12_5HZ_M      ((0<<4) | (1<<3) | (0<<2))
#define REG5_RATE_25HZ_M        ((0<<4) | (1<<3) | (1<<2))
#define REG5_RATE_50HZ_M        ((1<<4) | (0<<3) | (0<<2))
#define REG5_RATE_100HZ_M       ((1<<4) | (0<<3) | (1<<2))
#define REG5_RATE_DO_NOT_USE_M  ((1<<4) | (1<<3) | (0<<2))

#define REG6_FULL_SCALE_BITS_M  ((1<<6) | (1<<5))
#define REG6_FULL_SCALE_2GA_M   ((0<<6) | (0<<5))
#define REG6_FULL_SCALE_4GA_M   ((0<<6) | (1<<5))
#define REG6_FULL_SCALE_8GA_M   ((1<<6) | (0<<5))
#define REG6_FULL_SCALE_12GA_M  ((1<<6) | (1<<5))

#define REG7_CONT_MODE_M        ((0<<1) | (0<<0))

#define INT_CTRL_M              0x12
#define INT_SRC_M               0x13

#define LSM303D_MAG_DEFAULT_RANGE_GA          2
#define LSM303D_MAG_DEFAULT_RATE            100

AP_Compass_LSM303D::AP_Compass_LSM303D(AP_HAL::OwnPtr<AP_HAL::Device> dev)
    : _dev(std::move(dev))
{
}

AP_Compass_Backend *AP_Compass_LSM303D::probe(AP_HAL::OwnPtr<AP_HAL::Device> dev,
                                              enum Rotation rotation)
{
    if (!dev) {
        return nullptr;
    }
    AP_Compass_LSM303D *sensor = NEW_NOTHROW AP_Compass_LSM303D(std::move(dev));
    if (!sensor || !sensor->init(rotation)) {
        delete sensor;
        return nullptr;
    }

    return sensor;
}

uint8_t AP_Compass_LSM303D::_register_read(uint8_t reg)
{
    uint8_t val = 0;

    reg |= DIR_READ;
    _dev->read_registers(reg, &val, 1);

    return val;
}

bool AP_Compass_LSM303D::_block_read(uint8_t reg, uint8_t *buf, uint32_t size)
{
    reg |= DIR_READ | ADDR_INCREMENT;
    return _dev->read_registers(reg, buf, size);
}

void AP_Compass_LSM303D::_register_write(uint8_t reg, uint8_t val)
{
    _dev->write_register(reg, val);
}

void AP_Compass_LSM303D::_register_modify(uint8_t reg, uint8_t clearbits, uint8_t setbits)
{
    uint8_t val;

    val = _register_read(reg);
    val &= ~clearbits;
    val |= setbits;
    _register_write(reg, val);
}

/**
 * Return true if the LSM303D has new data available for both the mag and
 * the accels.
 */
bool AP_Compass_LSM303D::_data_ready()
{
    return _drdy_pin_m == nullptr || (_drdy_pin_m->read() != 0);
}


// Read Sensor data
bool AP_Compass_LSM303D::_read_sample()
{
    struct PACKED {
        uint8_t status;
        int16_t x;
        int16_t y;
        int16_t z;
    } rx;

    if (_register_read(ADDR_CTRL_REG7) != _reg7_expected) {
        DEV_PRINTF("LSM303D _read_data_transaction_accel: _reg7_expected unexpected\n");
        return false;
    }

    if (!_data_ready()) {
        return false;
    }

    if (!_block_read(ADDR_STATUS_M, (uint8_t *) &rx, sizeof(rx))) {
        return false;
    }

    /* check for overrun */
    if ((rx.status & 0x70) != 0) {
        return false;
    }

    if (rx.x == 0 && rx.y == 0 && rx.z == 0) {
        return false;
    }

    _mag_x = rx.x;
    _mag_y = rx.y;
    _mag_z = rx.z;

    return true;
}

bool AP_Compass_LSM303D::init(enum Rotation rotation)
{
    if (LSM303D_DRDY_M_PIN >= 0) {
        _drdy_pin_m = hal.gpio->channel(LSM303D_DRDY_M_PIN);
        _drdy_pin_m->mode(HAL_GPIO_INPUT);
    }

    bool success = _hardware_init();

    if (!success) {
        return false;
    }

    _initialised = true;

    /* register the compass instance in the frontend */
    _dev->set_device_type(DEVTYPE_LSM303D);
    if (!register_compass(_dev->get_bus_id(), _compass_instance)) {
        return false;
    }
    set_dev_id(_compass_instance, _dev->get_bus_id());

    set_rotation(_compass_instance, rotation);

    // read at 91Hz. We don't run at 100Hz as fetching data too fast can cause some very
    // odd periodic changes in the output data
    _dev->register_periodic_callback(11000, FUNCTOR_BIND_MEMBER(&AP_Compass_LSM303D::_update, void));

    return true;
}

bool AP_Compass_LSM303D::_hardware_init()
{
    _dev->get_semaphore()->take_blocking();

    // initially run the bus at low speed
    _dev->set_speed(AP_HAL::Device::SPEED_LOW);

    // Test WHOAMI
    uint8_t whoami = _register_read(ADDR_WHO_AM_I);
    if (whoami != WHO_I_AM) {
        goto fail_whoami;
    }

    uint8_t tries;
    for (tries = 0; tries < 5; tries++) {
        // ensure the chip doesn't interpret any other bus traffic as I2C
        _disable_i2c();

        /* enable mag */
        _reg7_expected = REG7_CONT_MODE_M;
        _register_write(ADDR_CTRL_REG7, _reg7_expected);
        _register_write(ADDR_CTRL_REG5, REG5_RES_HIGH_M);

        // DRDY on MAG on INT2
        _register_write(ADDR_CTRL_REG4, 0x04);

        _mag_set_range(LSM303D_MAG_DEFAULT_RANGE_GA);
        _mag_set_samplerate(LSM303D_MAG_DEFAULT_RATE);

        hal.scheduler->delay(10);
        if (_data_ready()) {
            break;
        }
    }
    if (tries == 5) {
        DEV_PRINTF("Failed to boot LSM303D 5 times\n");
        goto fail_tries;
    }

    _dev->set_speed(AP_HAL::Device::SPEED_HIGH);
    _dev->get_semaphore()->give();

    return true;

fail_tries:
fail_whoami:
    _dev->get_semaphore()->give();
    _dev->set_speed(AP_HAL::Device::SPEED_HIGH);
    return false;
}

void AP_Compass_LSM303D::_update()
{
    if (!_read_sample()) {
        return;
    }

    Vector3f raw_field = Vector3f(_mag_x, _mag_y, _mag_z) * _mag_range_scale;

    accumulate_sample(raw_field, _compass_instance, 10);
}

// Read Sensor data
void AP_Compass_LSM303D::read()
{
    if (!_initialised) {
        return;
    }

    drain_accumulated_samples(_compass_instance);
}

void AP_Compass_LSM303D::_disable_i2c()
{
    // TODO: use the register names
    uint8_t a = _register_read(0x02);
    _register_write(0x02, (0x10 | a));
    a = _register_read(0x02);
    _register_write(0x02, (0xF7 & a));
    a = _register_read(0x15);
    _register_write(0x15, (0x80 | a));
    a = _register_read(0x02);
    _register_write(0x02, (0xE7 & a));
}

bool AP_Compass_LSM303D::_mag_set_range(uint8_t max_ga)
{
    uint8_t setbits = 0;
    uint8_t clearbits = REG6_FULL_SCALE_BITS_M;
    float new_scale_ga_digit = 0.0f;

    if (max_ga == 0) {
        max_ga = 12;
    }

    if (max_ga <= 2) {
        _mag_range_ga = 2;
        setbits |= REG6_FULL_SCALE_2GA_M;
        new_scale_ga_digit = 0.080f;
    } else if (max_ga <= 4) {
        _mag_range_ga = 4;
        setbits |= REG6_FULL_SCALE_4GA_M;
        new_scale_ga_digit = 0.160f;
    } else if (max_ga <= 8) {
        _mag_range_ga = 8;
        setbits |= REG6_FULL_SCALE_8GA_M;
        new_scale_ga_digit = 0.320f;
    } else if (max_ga <= 12) {
        _mag_range_ga = 12;
        setbits |= REG6_FULL_SCALE_12GA_M;
        new_scale_ga_digit = 0.479f;
    } else {
        return false;
    }

    _mag_range_scale = new_scale_ga_digit;
    _register_modify(ADDR_CTRL_REG6, clearbits, setbits);

    return true;
}

bool AP_Compass_LSM303D::_mag_set_samplerate(uint16_t frequency)
{
    uint8_t setbits = 0;
    uint8_t clearbits = REG5_RATE_BITS_M;

    if (frequency == 0) {
        frequency = 100;
    }

    if (frequency <= 25) {
        setbits |= REG5_RATE_25HZ_M;
        _mag_samplerate = 25;
    } else if (frequency <= 50) {
        setbits |= REG5_RATE_50HZ_M;
        _mag_samplerate = 50;
    } else if (frequency <= 100) {
        setbits |= REG5_RATE_100HZ_M;
        _mag_samplerate = 100;
    } else {
        return false;
    }

    _register_modify(ADDR_CTRL_REG5, clearbits, setbits);

    return true;
}

#endif  // AP_COMPASS_LSM303D_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   #pragma once

#include "AP_Compass_config.h"

#if AP_COMPASS_LSM303D_ENABLED

#include <AP_Common/AP_Common.h>
#include <AP_HAL/AP_HAL.h>
#include <AP_HAL/Device.h>
#include <AP_Math/AP_Math.h>

#include "AP_Compass.h"
#include "AP_Compass_Backend.h"

class AP_Compass_LSM303D : public AP_Compass_Backend
{
public:
    static AP_Compass_Backend *probe(AP_HAL::OwnPtr<AP_HAL::Device> dev,
                                     enum Rotation rotation);

    static constexpr const char *name = "LSM303D";

    void read() override;

    virtual ~AP_Compass_LSM303D() { }

private:
    AP_Compass_LSM303D(AP_HAL::OwnPtr<AP_HAL::Device> dev);

    bool init(enum Rotation rotation);
    uint8_t _register_read(uint8_t reg);
    void _register_write(uint8_t reg, uint8_t val);
    void _register_modify(uint8_t reg, uint8_t clearbits, uint8_t setbits);
    bool _block_read(uint8_t reg, uint8_t *buf, uint32_t size);

    bool _read_sample();

    bool _data_ready();
    bool _hardware_init();
    void _update();
    void _disable_i2c();
    bool _mag_set_range(uint8_t max_ga);
    bool _mag_set_samplerate(uint16_t frequency);

    AP_HAL::DigitalSource *_drdy_pin_m;
    AP_HAL::OwnPtr<AP_HAL::Device> _dev;

    float _mag_range_scale;
    int16_t _mag_x;
    int16_t _mag_y;
    int16_t _mag_z;

    uint8_t _compass_instance;
    bool _initialised;

    uint8_t _mag_range_ga;
    uint8_t _mag_samplerate;
    uint8_t _reg7_expected;
};

#endif  // AP_COMPASS_LSM303D_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          #include "AP_Compass_LSM9DS1.h"

#if AP_COMPASS_LSM9DS1_ENABLED

#include <AP_Math/AP_Math.h>
#include <AP_HAL/AP_HAL.h>

#define LSM9DS1M_OFFSET_X_REG_L_M   0x05
#define LSM9DS1M_OFFSET_X_REG_H_M   0x06
#define LSM9DS1M_OFFSET_Y_REG_L_M   0x07
#define LSM9DS1M_OFFSET_Y_REG_H_M   0x08
#define LSM9DS1M_OFFSET_Z_REG_L_M   0x09
#define LSM9DS1M_OFFSET_Z_REG_H_M   0x0A

#define LSM9DS1M_WHO_AM_I           0x0F
    #define WHO_AM_I_MAG            0x3D

#define LSM9DS1M_CTRL_REG1_M        0x20
    #define LSM9DS1M_TEMP_COMP      (0x1 << 7)
    #define LSM9DS1M_XY_ULTRA_HIGH  (0x3 << 5)
    #define LSM9DS1M_80HZ           (0x7 << 2)
    #define LSM9DS1M_FAST_ODR       (0x1 << 1)

#define LSM9DS1M_CTRL_REG2_M        0x21
    #define LSM9DS1M_FS_16G         (0x3 << 5)

#define LSM9DS1M_CTRL_REG3_M        0x22
    #define LSM9DS1M_SPI_ENABLE      (0x01 << 2)
    #define LSM9DS1M_CONTINUOUS_MODE 0x0

#define LSM9DS1M_CTRL_REG4_M        0x23
    #define LSM9DS1M_Z_ULTRA_HIGH  (0x3 << 2)

#define LSM9DS1M_CTRL_REG5_M        0x24
    #define LSM9DS1M_BDU            (0x0 << 6)

#define LSM9DS1M_STATUS_REG_M       0x27

#define LSM9DS1M_OUT_X_L_M          0x28
#define LSM9DS1M_OUT_X_H_M          0x29
#define LSM9DS1M_OUT_Y_L_M          0x2A
#define LSM9DS1M_OUT_Y_H_M          0x2B
#define LSM9DS1M_OUT_Z_L_M          0x2C
#define LSM9DS1M_OUT_Z_H_M          0x2D
#define LSM9DS1M_INT_CFG_M          0x30
#define LSM9DS1M_INT_SRC_M          0x31
#define LSM9DS1M_INT_THS_L_M        0x32
#define LSM9DS1M_INT_THS_H_M        0x33

extern const AP_HAL::HAL &hal;

AP_Compass_LSM9DS1::AP_Compass_LSM9DS1(AP_HAL::OwnPtr<AP_HAL::Device> dev,
                                       enum Rotation rotation)
    : _dev(std::move(dev))
    , _rotation(rotation)
{
}

AP_Compass_Backend *AP_Compass_LSM9DS1::probe(AP_HAL::OwnPtr<AP_HAL::Device> dev,
                                              enum Rotation rotation)
{
    if (!dev) {
        return nullptr;
    }
    AP_Compass_LSM9DS1 *sensor = NEW_NOTHROW AP_Compass_LSM9DS1(std::move(dev), rotation);
    if (!sensor || !sensor->init()) {
        delete sensor;
        return nullptr;
    }

    return sensor;
}

bool AP_Compass_LSM9DS1::init()
{
    AP_HAL::Semaphore *bus_sem = _dev->get_semaphore();

    if (!bus_sem) {
        DEV_PRINTF("LSM9DS1: Unable to get bus semaphore\n");
        return false;
    }
    bus_sem->take_blocking();

    if (!_check_id()) {
        DEV_PRINTF("LSM9DS1: Could not check id\n");
        goto errout;
    }

    if (!_configure()) {
        DEV_PRINTF("LSM9DS1: Could not check id\n");
        goto errout;
    }

    if (!_set_scale()) {
        DEV_PRINTF("LSM9DS1: Could not set scale\n");
        goto errout;
    }

    //register compass instance
    _dev->set_device_type(DEVTYPE_LSM9DS1);
    if (!register_compass(_dev->get_bus_id(), _compass_instance)) {
        goto errout;
    }
    set_dev_id(_compass_instance, _dev->get_bus_id());

    set_rotation(_compass_instance, _rotation);


    _dev->register_periodic_callback(10000, FUNCTOR_BIND_MEMBER(&AP_Compass_LSM9DS1::_update, void));

    bus_sem->give();

    return true;

errout:
    bus_sem->give();
    return false;
}

void AP_Compass_LSM9DS1::_dump_registers()
{
    DEV_PRINTF("LSMDS1 registers\n");
    for (uint8_t reg = LSM9DS1M_OFFSET_X_REG_L_M; reg <= LSM9DS1M_INT_THS_H_M; reg++) {
        DEV_PRINTF("%02x:%02x ", (unsigned)reg, (unsigned)_register_read(reg));
        if ((reg - (LSM9DS1M_OFFSET_X_REG_L_M-1)) % 16 == 0) {
            DEV_PRINTF("\n");
        }
    }
    DEV_PRINTF("\n");
}

void AP_Compass_LSM9DS1::_update(void)
{
    struct sample_regs regs;
    Vector3f raw_field;

    if (!_block_read(LSM9DS1M_STATUS_REG_M, (uint8_t *) &regs, sizeof(regs))) {
        return;
    }

    if (regs.status & 0x80) {
        return;
    }

    raw_field = Vector3f(regs.val[0], regs.val[1], regs.val[2]);

    if (is_zero(raw_field.x) && is_zero(raw_field.y) && is_zero(raw_field.z)) {
        return;
    }

    raw_field *= _scaling;

    accumulate_sample(raw_field, _compass_instance);
}

void AP_Compass_LSM9DS1::read()
{
    drain_accumulated_samples(_compass_instance);
}

bool AP_Compass_LSM9DS1::_check_id(void)
{
    // initially run the bus at low speed
    _dev->set_speed(AP_HAL::Device::SPEED_LOW);

    uint8_t value = _register_read(LSM9DS1M_WHO_AM_I);
    if (value != WHO_AM_I_MAG) {
        DEV_PRINTF("LSM9DS1: unexpected WHOAMI 0x%x\n", (unsigned)value);
        return false;
    }

    _dev->set_speed(AP_HAL::Device::SPEED_HIGH);

    return true;
}

bool AP_Compass_LSM9DS1::_configure(void)
{
    _register_write(LSM9DS1M_CTRL_REG1_M, LSM9DS1M_TEMP_COMP | LSM9DS1M_XY_ULTRA_HIGH | LSM9DS1M_80HZ | LSM9DS1M_FAST_ODR);
    _register_write(LSM9DS1M_CTRL_REG2_M, LSM9DS1M_FS_16G);
    _register_write(LSM9DS1M_CTRL_REG3_M, LSM9DS1M_CONTINUOUS_MODE);
    _register_write(LSM9DS1M_CTRL_REG4_M, LSM9DS1M_Z_ULTRA_HIGH);
    _register_write(LSM9DS1M_CTRL_REG5_M, LSM9DS1M_BDU);

    return true;
}

bool AP_Compass_LSM9DS1::_set_scale(void)
{
    static const uint8_t FS_M_MASK = 0xc;
    _register_modify(LSM9DS1M_CTRL_REG2_M, FS_M_MASK, LSM9DS1M_FS_16G);
    _scaling = 0.58f;

    return true;
}

uint8_t AP_Compass_LSM9DS1::_register_read(uint8_t reg)
{
    uint8_t val = 0;

    /* set READ bit */
    reg |= 0x80;
    _dev->read_registers(reg, &val, 1);

    return val;
}

bool AP_Compass_LSM9DS1::_block_read(uint8_t reg, uint8_t *buf, uint32_t size)
{
    /* set !MS bit */
    reg |= 0xc0;
    return _dev->read_registers(reg, buf, size);
}

void AP_Compass_LSM9DS1::_register_write(uint8_t reg, uint8_t val)
{
    _dev->write_register(reg, val);
}

void AP_Compass_LSM9DS1::_register_modify(uint8_t reg, uint8_t clearbits, uint8_t setbits)
{
    uint8_t val;

    val = _register_read(reg);
    val &= ~clearbits;
    val |= setbits;
    _register_write(reg, val);
}

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   #pragma once

#include "AP_Compass_config.h"

#if AP_COMPASS_LSM9DS1_ENABLED

#include <AP_Common/AP_Common.h>
#include <AP_HAL/AP_HAL.h>
#include <AP_HAL/Device.h>
#include <AP_Math/AP_Math.h>

#include "AP_Compass_Backend.h"

class AP_Compass_LSM9DS1 : public AP_Compass_Backend
{
public:
    static AP_Compass_Backend *probe(AP_HAL::OwnPtr<AP_HAL::Device> dev,
                                     enum Rotation rotation);

    static constexpr const char *name = "LSM9DS1";

    void read() override;

    virtual ~AP_Compass_LSM9DS1() {}

private:
    AP_Compass_LSM9DS1(AP_HAL::OwnPtr<AP_HAL::Device> dev,
                       enum Rotation rotation);
    bool init();
    bool _check_id(void);
    bool _configure(void);
    bool _set_scale(void);
    void _update(void);

    uint8_t _register_read(uint8_t reg);
    void _register_write(uint8_t reg, uint8_t val);
    void _register_modify(uint8_t reg, uint8_t clearbits, uint8_t setbits);
    bool _block_read(uint8_t reg, uint8_t *buf, uint32_t size);
    void _dump_registers();

    AP_HAL::OwnPtr<AP_HAL::Device> _dev;
    uint8_t _compass_instance;
    float _scaling;
    enum Rotation _rotation;

    struct PACKED sample_regs {
        uint8_t status;
        int16_t val[3];
    };
};

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                /*
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
#include "AP_Compass_MAG3110.h"

#if AP_COMPASS_MAG3110_ENABLED

#include <utility>

#include <AP_HAL/AP_HAL.h>
#include <AP_Math/AP_Math.h>
#include <stdio.h>

extern const AP_HAL::HAL &hal;


/*
EN:
    at first glance, the magnetometer MAG3110 consists only of flaws:
    * noisy, with a bad characteristic, with very large difference on axes
    * it can't be calibrated in any way, you just have to believe what he has been measured
    * There are no adjustments and settings, it just sends data with some unknown sensitivity. Or does not sends :)
    * One and a half setup registers, in which only the frequency of operation and the number of averagings are specified
    
    This is a device, wooden to the waist. But of all these shortcomings, its sole and basic virtue arises:
    * He will never comes buggy or clevers.
    
    And since we do not need much from a magnetometer and it is required to calibrate the Ardupilot itself, the device
    appears in a completely new light - as a reliable info "north is there." What we really need.

RUS:
    на первый взгляд, магнитометр MAG3110 состоит из одних лишь недостатков:
    * шумный, с кривой характеристикой, 
    * никак не калибруется, приходится просто верить тому что он намерял
    * нет никаких регулировок и настроек, он просто выдает данные с некой неизвестной чувствительностью. Или не выдает :)
    * полтора настроечных регистра, в которых задается только частота работы и количество усреднений
    
    Такой вот девайс, по пояс деревянный. Но из всех этих недостатков проистекает его единственное и основное достоинство:
    * он никогда не глючит и не умничает.
    
    А так как нам от магнитометра особо много и не требуется, а калибровать Ардупилот и сам умеет, то девайс
    предстает в совсем новом свете - как надежный указатель "север там". Что нам собственно и надо.

*/

/*
  the vector length filter can help with noise on the bus, but may
  interfere with higher level processing. It should really be moved
  into the AP_Compass_backend code, with a parameter to enable it.
 */
#ifndef MAG3110_ENABLE_LEN_FILTER
#define MAG3110_ENABLE_LEN_FILTER 0
#endif


// Registers
#define MAG3110_MAG_REG_STATUS       0x00
#define MAG3110_MAG_REG_HXL          0x01
#define MAG3110_MAG_REG_HXH          0x02
#define MAG3110_MAG_REG_HYL          0x03
#define MAG3110_MAG_REG_HYH          0x04
#define MAG3110_MAG_REG_HZL          0x05
#define MAG3110_MAG_REG_HZH          0x06
#define MAG3110_MAG_REG_WHO_AM_I     0x07
#define MAG3110_MAG_REG_SYSMODE      0x08
#define MAG3110_MAG_REG_CTRL_REG1    0x10
#define MAG3110_MAG_REG_CTRL_REG2    0x11

#define BIT_STATUS_REG_DATA_READY    (1 << 3)




AP_Compass_MAG3110::AP_Compass_MAG3110(AP_HAL::OwnPtr<AP_HAL::Device> dev)
    : _dev(std::move(dev))
{
}

AP_Compass_Backend *AP_Compass_MAG3110::probe(AP_HAL::OwnPtr<AP_HAL::Device> dev,
                                              enum Rotation rotation)
{
    if (!dev) {
        return nullptr;
    }
    AP_Compass_MAG3110 *sensor = NEW_NOTHROW AP_Compass_MAG3110(std::move(dev));
    if (!sensor || !sensor->init(rotation)) {
        delete sensor;
        return nullptr;
    }

    return sensor;
}


bool AP_Compass_MAG3110::init(enum Rotation rotation)
{

    bool success = _hardware_init();

    if (!success) {
        return false;
    }

    _initialised = true;

    // perform an initial read
    read();
    
    /* register the compass instance in the frontend */
    _dev->set_device_type(DEVTYPE_MAG3110);
    if (!register_compass(_dev->get_bus_id(), _compass_instance)) {
        return false;
    }
    set_dev_id(_compass_instance, _dev->get_bus_id());

    set_rotation(_compass_instance, rotation);

    set_external(_compass_instance, true);

    // read at 75Hz
    _dev->register_periodic_callback(13333, FUNCTOR_BIND_MEMBER(&AP_Compass_MAG3110::_update, void)); 

    return true;
}

bool AP_Compass_MAG3110::_hardware_init()
{

    AP_HAL::Semaphore *bus_sem = _dev->get_semaphore();
    bus_sem->take_blocking();

    // initially run the bus at low speed
    _dev->set_speed(AP_HAL::Device::SPEED_LOW);

    bool ret=false;
    
    _dev->set_retries(5);
    
    uint8_t sig = 0;
    bool ack = _dev->read_registers(MAG3110_MAG_REG_WHO_AM_I, &sig, 1);    
    if (!ack || sig != 0xC4) goto exit;

    ack = _dev->write_register(MAG3110_MAG_REG_CTRL_REG1, 0x01); //  active mode 80 Hz ODR with OSR = 1
    if (!ack) goto exit;

    hal.scheduler->delay(20);
    
    ack = _dev->write_register(MAG3110_MAG_REG_CTRL_REG2, 0xA0); // AUTO_MRST_EN + RAW
    if (!ack) goto exit;

    ret = true;

    _dev->set_retries(3);
    
    printf("MAG3110 found on bus 0x%x\n", (uint16_t)_dev->get_bus_id());

exit:
    _dev->set_speed(AP_HAL::Device::SPEED_HIGH);
    bus_sem->give();
    return ret;
}


// Read Sensor data
bool AP_Compass_MAG3110::_read_sample()
{
    {
        uint8_t status;
        bool ack = _dev->read_registers(MAG3110_MAG_REG_STATUS, &status, 1);
    
        if (!ack || (status & BIT_STATUS_REG_DATA_READY) == 0) {
            return false;
        }
    }

    uint8_t buf[6];
    bool ack = _dev->read_registers(MAG3110_MAG_REG_HXL, buf, 6);
    if (!ack) {
        return false;
    }

    _mag_x = (int16_t)(buf[0] << 8 | buf[1]);
    _mag_y = (int16_t)(buf[2] << 8 | buf[3]);
    _mag_z = (int16_t)(buf[4] << 8 | buf[5]);

    return true;
}


#define MAG_SCALE (1.0f/10000 / 0.0001f * 1000)  // 1 Tesla full scale of +-10000, 1 Gauss = 0,0001 Tesla, library needs milliGauss

void AP_Compass_MAG3110::_update()
{
    if (!_read_sample()) {
        return;
    }

    Vector3f raw_field = Vector3f((float)_mag_x, (float)_mag_y, (float)_mag_z) * MAG_SCALE;

    accumulate_sample(raw_field, _compass_instance);
}


// Read Sensor data
void AP_Compass_MAG3110::read()
{
    if (!_initialised) {
        return;
    }

    drain_accumulated_samples(_compass_instance);
}

#endif  // AP_COMPASS_MAG3110_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              #pragma once

#include "AP_Compass_config.h"

#if AP_COMPASS_MAG3110_ENABLED

#include <AP_Common/AP_Common.h>
#include <AP_HAL/AP_HAL.h>
#include <AP_HAL/Device.h>
#include <AP_Math/AP_Math.h>

#include "AP_Compass.h"
#include "AP_Compass_Backend.h"


#ifndef HAL_MAG3110_I2C_ADDR 
 #define HAL_MAG3110_I2C_ADDR     0x0E
#endif

class AP_Compass_MAG3110 : public AP_Compass_Backend
{
public:
    static AP_Compass_Backend *probe(AP_HAL::OwnPtr<AP_HAL::Device> dev,
                                     enum Rotation rotation);

    static constexpr const char *name = "MAG3110";

    void read() override;

    ~AP_Compass_MAG3110() { }

private:
    AP_Compass_MAG3110(AP_HAL::OwnPtr<AP_HAL::Device> dev);

    bool init(enum Rotation rotation);

    bool _read_sample();

    bool _hardware_init();
    void _update();

    AP_HAL::OwnPtr<AP_HAL::Device> _dev;

    int32_t _mag_x;
    int32_t _mag_y;
    int32_t _mag_z;

    uint8_t _compass_instance;
    bool _initialised;
};

#endif  // AP_COMPASS_MAG3110_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  /*
 * This file is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This file is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
/*
  Driver by Andrew Tridgell, Nov 2016
 */
#include "AP_Compass_MMC3416.h"

#if AP_COMPASS_MMC3416_ENABLED

#include <AP_HAL/AP_HAL.h>
#include <utility>
#include <AP_Math/AP_Math.h>
#include <stdio.h>
#include <AP_Logger/AP_Logger.h>

extern const AP_HAL::HAL &hal;

#define REG_PRODUCT_ID      0x20
#define REG_XOUT_L          0x00
#define REG_STATUS          0x06
#define REG_CONTROL0        0x07
#define REG_CONTROL1        0x08

// bits in REG_CONTROL0
#define REG_CONTROL0_REFILL 0x80
#define REG_CONTROL0_RESET  0x40
#define REG_CONTROL0_SET    0x20
#define REG_CONTROL0_NB     0x10
#define REG_CONTROL0_TM     0x01

// datasheet says 50ms min for refill
#define MIN_DELAY_SET_RESET 50

AP_Compass_Backend *AP_Compass_MMC3416::probe(AP_HAL::OwnPtr<AP_HAL::I2CDevice> dev,
                                              bool force_external,
                                              enum Rotation rotation)
{
    if (!dev) {
        return nullptr;
    }
    AP_Compass_MMC3416 *sensor = NEW_NOTHROW AP_Compass_MMC3416(std::move(dev), force_external, rotation);
    if (!sensor || !sensor->init()) {
        delete sensor;
        return nullptr;
    }

    return sensor;
}

AP_Compass_MMC3416::AP_Compass_MMC3416(AP_HAL::OwnPtr<AP_HAL::Device> _dev,
                                       bool _force_external,
                                       enum Rotation _rotation)
    : dev(std::move(_dev))
    , force_external(_force_external)
    , rotation(_rotation)
{
}

bool AP_Compass_MMC3416::init()
{
    dev->get_semaphore()->take_blocking();

    dev->set_retries(10);
    
    uint8_t whoami;
    if (!dev->read_registers(REG_PRODUCT_ID, &whoami, 1) ||
        whoami != 0x06) {
        // not a MMC3416
        dev->get_semaphore()->give();
        return false;
    }

    // reset sensor
    dev->write_register(REG_CONTROL1, 0x80);
    hal.scheduler->delay(10);
    
    dev->write_register(REG_CONTROL0, 0x00); // single shot
    dev->write_register(REG_CONTROL1, 0x00); // 16 bit, 7.92ms
    
    dev->get_semaphore()->give();

    /* register the compass instance in the frontend */
    dev->set_device_type(DEVTYPE_MMC3416);
    if (!register_compass(dev->get_bus_id(), compass_instance)) {
        return false;
    }
    
    set_dev_id(compass_instance, dev->get_bus_id());

    printf("Found a MMC3416 on 0x%x as compass %u\n", unsigned(dev->get_bus_id()), compass_instance);
    
    set_rotation(compass_instance, rotation);

    if (force_external) {
        set_external(compass_instance, true);
    }
    
    dev->set_retries(1);
    
    // call timer() at 100Hz
    dev->register_periodic_callback(10000,
                                    FUNCTOR_BIND_MEMBER(&AP_Compass_MMC3416::timer, void));

    // wait 250ms for the compass to make it's initial readings
    hal.scheduler->delay(250);
    
    return true;
}

void AP_Compass_MMC3416::timer()
{
    const uint16_t measure_count_limit = 50;
    const uint16_t zero_offset = 32768; // 16 bit mode
    const uint16_t sensitivity = 2048; // counts per Gauss, 16 bit mode
    const float counts_to_milliGauss = 1.0e3f / sensitivity;

    uint32_t now = AP_HAL::millis();
    if (now - last_sample_ms > 500) {
        // seems to be stuck or on first sample, reset state machine
        state = STATE_REFILL1;
        last_sample_ms = now;
    }
    
    /*
      we use the SET/RESET method to remove bridge offset every
      measure_count_limit measurements. This involves a fairly complex
      state machine, but means we are much less sensitive to
      temperature changes
     */
    switch (state) {
    case STATE_REFILL1:
        if (dev->write_register(REG_CONTROL0, REG_CONTROL0_REFILL)) {
            state = STATE_REFILL1_WAIT;
            refill_start_ms = AP_HAL::millis();
        }
        break;

    case STATE_REFILL1_WAIT: {
        uint8_t status;
        if (AP_HAL::millis() - refill_start_ms > MIN_DELAY_SET_RESET &&
            dev->read_registers(REG_STATUS, &status, 1) &&
            (status & 0x02) == 0) {
            if (!dev->write_register(REG_CONTROL0, REG_CONTROL0_SET) ||
                !dev->write_register(REG_CONTROL0, REG_CONTROL0_TM)) { // Take Measurement
                state = STATE_REFILL1;
            } else {
                state = STATE_MEASURE_WAIT1;
            }
        }
        break;
    }
        
    case STATE_MEASURE_WAIT1: {
        uint8_t status;
        if (dev->read_registers(REG_STATUS, &status, 1) && (status & 1)) {
            if (!dev->read_registers(REG_XOUT_L, (uint8_t *)&data0[0], 6)) {
                state = STATE_REFILL1;
                break;
            }
            if (!dev->write_register(REG_CONTROL0, REG_CONTROL0_REFILL)) {
                state = STATE_REFILL1;
            } else {
                state = STATE_REFILL2_WAIT;
                refill_start_ms = AP_HAL::millis();
            }
        }
        break;
    }

    case STATE_REFILL2_WAIT: {
        uint8_t status;
        if (AP_HAL::millis() - refill_start_ms > MIN_DELAY_SET_RESET &&
            dev->read_registers(REG_STATUS, &status, 1) &&
            (status & 0x02) == 0) {
            if (!dev->write_register(REG_CONTROL0, REG_CONTROL0_RESET) ||
                !dev->write_register(REG_CONTROL0, REG_CONTROL0_TM)) { // Take Measurement
                state = STATE_REFILL1;
            } else {
                state = STATE_MEASURE_WAIT2;
            }
        }
        break;
    }

    case STATE_MEASURE_WAIT2: {
        uint8_t status;
        if (!dev->read_registers(REG_STATUS, &status, 1) || !(status & 1)) {
            break;
        }
        uint16_t data1[3];
        if (!dev->read_registers(REG_XOUT_L, (uint8_t *)&data1[0], 6)) {
            state = STATE_REFILL1;
            break;
        }
        Vector3f field;

        /*
          calculate field and offset
         */
        Vector3f f1(float(data0[0]) - zero_offset,
                    float(data0[1]) - zero_offset,
                    float(data0[2]) - zero_offset);
        Vector3f f2(float(data1[0]) - zero_offset,
                    float(data1[1]) - zero_offset,
                    float(data1[2]) - zero_offset);
        field = (f1 - f2) * (counts_to_milliGauss / 2);
        Vector3f new_offset = (f1 + f2) * (counts_to_milliGauss / 2);
        if (!have_initial_offset) {
            offset = new_offset;
            have_initial_offset = true;
        } else {
            // low pass changes to the offset
            offset = offset * 0.95f + new_offset * 0.05f;
        }

#if 0
// @LoggerMessage: MMO
// @Description: MMC3416 compass data
// @Field: TimeUS: Time since system startup
// @Field: Nx: new measurement X axis
// @Field: Ny: new measurement Y axis
// @Field: Nz: new measurement Z axis
// @Field: Ox: new offset X axis
// @Field: Oy: new offset Y axis
// @Field: Oz: new offset Z axis
        AP::logger().Write("MMO", "TimeUS,Nx,Ny,Nz,Ox,Oy,Oz", "Qffffff",
                                               AP_HAL::micros64(),
                                               (double)new_offset.x,
                                               (double)new_offset.y,
                                               (double)new_offset.z,
                                               (double)offset.x,
                                               (double)offset.y,
                                               (double)offset.z);
        printf("F(%.1f %.1f %.1f) O(%.1f %.1f %.1f)\n",
               field.x, field.y, field.z,
               offset.x, offset.y, offset.z);
#endif

        last_sample_ms = AP_HAL::millis();

        // sensor is not FRD
        field.y = -field.y;

        accumulate_sample(field, compass_instance);

        if (!dev->write_register(REG_CONTROL0, REG_CONTROL0_TM)) {
            state = STATE_REFILL1;
        } else {
            state = STATE_MEASURE_WAIT3;
        }
        break;
    }

    case STATE_MEASURE_WAIT3: {
        uint8_t status;
        if (!dev->read_registers(REG_STATUS, &status, 1) || !(status & 1)) {
            break;
        }
        uint16_t data1[3];
        if (!dev->read_registers(REG_XOUT_L, (uint8_t *)&data1[0], 6)) {
            state = STATE_REFILL1;
            break;
        }
        Vector3f field(float(data1[0]) - zero_offset,
                       float(data1[1]) - zero_offset,
                       float(data1[2]) - zero_offset);
        field *= -counts_to_milliGauss;
        field += offset;

        // sensor is not FRD
        field.y = -field.y;

        last_sample_ms = AP_HAL::millis();
        accumulate_sample(field, compass_instance);

        // we stay in STATE_MEASURE_WAIT3 for measure_count_limit cycles
        if (measure_count++ >= measure_count_limit) {
            measure_count = 0;
            state = STATE_REFILL1;
        } else {
            if (!dev->write_register(REG_CONTROL0, REG_CONTROL0_TM)) { // Take Measurement
                state = STATE_REFILL1;
            }
        }
        break;
    }
    }
}

void AP_Compass_MMC3416::read()
{
    drain_accumulated_samples(compass_instance);
}

#endif  // AP_COMPASS_MMC3416_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              /*
 * This file is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This file is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
#pragma once

#include "AP_Compass_config.h"

#if AP_COMPASS_MMC3416_ENABLED

#include <AP_Common/AP_Common.h>
#include <AP_HAL/AP_HAL.h>
#include <AP_HAL/I2CDevice.h>
#include <AP_Math/AP_Math.h>

#include "AP_Compass.h"
#include "AP_Compass_Backend.h"

#ifndef HAL_COMPASS_MMC3416_I2C_ADDR
# define HAL_COMPASS_MMC3416_I2C_ADDR 0x30
#endif

class AP_Compass_MMC3416 : public AP_Compass_Backend
{
public:
    static AP_Compass_Backend *probe(AP_HAL::OwnPtr<AP_HAL::I2CDevice> dev,
                                     bool force_external,
                                     enum Rotation rotation);

    void read() override;

    static constexpr const char *name = "MMC3416";

private:
    AP_Compass_MMC3416(AP_HAL::OwnPtr<AP_HAL::Device> dev,
                       bool force_external,
                       enum Rotation rotation);

    AP_HAL::OwnPtr<AP_HAL::Device> dev;

    enum {
        STATE_REFILL1,
        STATE_REFILL1_WAIT,
        STATE_MEASURE_WAIT1,
        STATE_REFILL2_WAIT,
        STATE_MEASURE_WAIT2,
        STATE_MEASURE_WAIT3,
    } state;
    
    /**
     * Device periodic callback to read data from the sensor.
     */
    bool init();
    void timer();
    void accumulate_field(Vector3f &field);

    uint8_t compass_instance;
    bool force_external;
    Vector3f offset;
    uint16_t measure_count;
    bool have_initial_offset;
    uint32_t refill_start_ms;
    uint32_t last_sample_ms;
    
    uint16_t data0[3];
    
    enum Rotation rotation;
};

#endif  // AP_COMPASS_MMC3416_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             /*
 * This file is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This file is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include "AP_Compass_MMC5xx3.h"

#if AP_COMPASS_MMC5XX3_ENABLED

#include <AP_HAL/AP_HAL.h>
#include <stdio.h>

extern const AP_HAL::HAL &hal;

#define REG_PRODUCT_ID      0x2F
#define REG_XOUT_L          0x00
#define REG_STATUS          0x08
#define REG_CONTROL0        0x09
#define REG_CONTROL1        0x0A
#define REG_CONTROL2        0x0B

// bits in REG_CONTROL0
#define REG_CONTROL0_RESET  0x10 // Set coil for measuring offset
#define REG_CONTROL0_SET    0x08 // Reset coil for measuring offset
#define REG_CONTROL0_TMM    0x01 // Take Measurement for Magnetic field
#define REG_CONTROL0_TMT    0x02 // Take Measurement for Temperature

// bits in REG_CONTROL1
#define REG_CONTROL1_SW_RST 0x80 // Software reset
#define REG_CONTROL1_BW0    0x01
#define REG_CONTROL1_BW1    0x02

#define MMC5983_ID 0x30

AP_Compass_Backend *AP_Compass_MMC5XX3::probe(AP_HAL::OwnPtr<AP_HAL::Device> dev,
                                              bool force_external,
                                              enum Rotation rotation)
{
    if (!dev) {
        return nullptr;
    }
    AP_Compass_MMC5XX3 *sensor = NEW_NOTHROW AP_Compass_MMC5XX3(std::move(dev), force_external, rotation);
    if (!sensor || !sensor->init()) {
        delete sensor;
        return nullptr;
    }

    return sensor;
}

AP_Compass_MMC5XX3::AP_Compass_MMC5XX3(AP_HAL::OwnPtr<AP_HAL::Device> _dev,
                                       bool _force_external,
                                       enum Rotation _rotation)
    : dev(std::move(_dev))
    , force_external(_force_external)
    , rotation(_rotation)
    , have_initial_offset(false)
{
}

bool AP_Compass_MMC5XX3::init()
{
    // take i2c bus semaphore
    WITH_SEMAPHORE(dev->get_semaphore());

    dev->set_retries(10);

    // setup to allow reads on SPI
    if (dev->bus_type() == AP_HAL::Device::BUS_TYPE_SPI) {
        dev->set_read_flag(0x80);
    }

    // Reading REG_PRODUCT_ID fails sometimes on SPI, so we retry up to 10 times
    uint8_t whoami = 0;
    uint8_t tries = 10;
    while (whoami == 0 && tries > 0) {
        tries--;
        dev->read_registers(REG_PRODUCT_ID, &whoami, 1);
        hal.scheduler->delay(5);
    }

    if (whoami != MMC5983_ID) {
        printf("MMC5983 got unexpected product id: %d, expected: %d\n", whoami, MMC5983_ID);
        // not a MMC5983
        return false;
    }

    // reset sensor
    dev->write_register(REG_CONTROL1, REG_CONTROL1_SW_RST);

    // 10ms minimum startup time
    hal.scheduler->delay(15);

    // setup for 100Hz output
    if (!dev->write_register(REG_CONTROL1, 0)) {
        return false;
    }


    /* register the compass instance in the frontend */
    dev->set_device_type(DEVTYPE_MMC5983);
    if (!register_compass(dev->get_bus_id(), compass_instance)) {
        return false;
    }

    set_dev_id(compass_instance, dev->get_bus_id());

    printf("Found a MMC5983 on 0x%x as compass %u\n", unsigned(dev->get_bus_id()), compass_instance);

    set_rotation(compass_instance, rotation);

    if (force_external) {
        set_external(compass_instance, true);
    }

    dev->set_retries(1);

    // call timer() at 100Hz
    dev->register_periodic_callback(10000U,
                                    FUNCTOR_BIND_MEMBER(&AP_Compass_MMC5XX3::timer, void));

    return true;
}

void AP_Compass_MMC5XX3::timer()
{
    // recalculate the offset with set/reset operation every measure_count_limit measurements
    // sensor is read at about 100Hz, so about every 10 seconds
    const uint16_t measure_count_limit = 1000U;
    const uint16_t zero_offset = 32768U; // 16 bit mode
    const uint16_t sensitivity = 4096U; // counts per Gauss, 16 bit mode
    constexpr float counts_to_milliGauss = 1.0e3f / sensitivity;

    /*
      we use the SET/RESET method to remove bridge offset every
      measure_count_limit measurements. This involves a fairly complex
      state machine, but means we are much less sensitive to
      temperature changes
     */
    switch (state) {

    // perform a set operation
    case MMCState::STATE_SET: {
        if (!dev->write_register(REG_CONTROL0, REG_CONTROL0_SET)) {
            break;
        }
        // minimum time to wait after set/reset before take measurement request is 1ms
        state = MMCState::STATE_SET_MEASURE;
        break;
    }

    // request a measurement for field and offset calculation after set operation
    case MMCState::STATE_SET_MEASURE: {
        if (!dev->write_register(REG_CONTROL0, REG_CONTROL0_TMM)) {
            break;
        }
        state = MMCState::STATE_SET_WAIT;
        break;
    }

    // wait for measurement to be ready after set operation, then read the
    // measurement data and request a reset operation
    case MMCState::STATE_SET_WAIT: {
        uint8_t status;
        if (!dev->read_registers(REG_STATUS, &status, 1)) {
            state = MMCState::STATE_SET;
            break;
        }

        // check if measurement is ready
        if (!(status & 1)) {
            break;
        }

        // read measurement
        if (!dev->read_registers(REG_XOUT_L, (uint8_t *)&data0[0], 6)) {
            state = MMCState::STATE_SET;
            break;
        }

        // request set operation
        if (!dev->write_register(REG_CONTROL0, REG_CONTROL0_RESET)) {
            break;
        }
        // minimum time to wait after set/reset before take measurement request is 1ms
        state = MMCState::STATE_RESET_MEASURE;
        break;
    }

    // request a measurement for field and offset calculation after reset operation
    case MMCState::STATE_RESET_MEASURE: {
        // take measurement request
        if (!dev->write_register(REG_CONTROL0, REG_CONTROL0_TMM)) {
            state = MMCState::STATE_SET;
            break;
        }

        state = MMCState::STATE_RESET_WAIT;
        break;
    }

    // wait for measurement to be ready after reset operation,
    // then read the measurement data, calculate the field and offset,
    // and begin requesting field measurements
    case MMCState::STATE_RESET_WAIT: {
        uint8_t status;
        if (!dev->read_registers(REG_STATUS, &status, 1)) {
            state = MMCState::STATE_SET;
            break;
        }
        // check if measurement is ready
        if (!(status & 1)) {
            break;
        }

        uint8_t data1[6];
        if (!dev->read_registers(REG_XOUT_L, (uint8_t *)&data1[0], 6)) {
            state = MMCState::STATE_SET;
            break;
        }

        /*
          calculate field and offset
         */
        Vector3f f1 {float((data0[0] << 8) + data0[1]) - zero_offset,
                    float((data0[2] << 8) + data0[3]) - zero_offset,
                    float((data0[4] << 8) + data0[5]) - zero_offset};
        Vector3f f2 {float((data1[0] << 8) + data1[1]) - zero_offset,
                    float((data1[2] << 8) + data1[3]) - zero_offset,
                    float((data1[4] << 8) + data1[5]) - zero_offset};

        Vector3f field {(f2 - f1) * counts_to_milliGauss * 0.5f};
        Vector3f new_offset {(f1 + f2) * counts_to_milliGauss * 0.5f};

        if (!have_initial_offset) {
            offset = new_offset;
            have_initial_offset = true;
        } else {
            // low pass changes to the offset
            offset = offset * 0.5f + new_offset * 0.5f;
        }

        accumulate_sample(field, compass_instance);

        if (!dev->write_register(REG_CONTROL0, REG_CONTROL0_TMM)) {
            printf("failed to initiate measurement\n");
            state = MMCState::STATE_SET;
        } else {
            state = MMCState::STATE_MEASURE;
        }

        break;
    }

    // take repeated field measurements, set/reset is performed again after
    // measure_count_limit measurements
    case MMCState::STATE_MEASURE: {
        uint8_t status;
        if (!dev->read_registers(REG_STATUS, &status, 1)) {
            state = MMCState::STATE_SET;
            break;
        }

        // check if measurement is ready
        if (!(status & 1)) {
            break;
        }

        uint8_t data1[6];
        if (!dev->read_registers(REG_XOUT_L, (uint8_t *)&data1[0], 6)) {
            printf("cant read data\n");
            state = MMCState::STATE_SET;
            break;
        }

        Vector3f field {float((data1[0] << 8) + data1[1]) - zero_offset,
                       float((data1[2] << 8) + data1[3]) - zero_offset,
                       float((data1[4] << 8) + data1[5]) - zero_offset};
        field *= counts_to_milliGauss;
        field -= offset;
        accumulate_sample(field, compass_instance);

        // we stay in STATE_MEASURE for measure_count_limit cycles
        if (measure_count++ >= measure_count_limit) {
            measure_count = 0;
            state = MMCState::STATE_SET;
        } else {
            if (!dev->write_register(REG_CONTROL0, REG_CONTROL0_TMM)) { // Take Measurement
                state = MMCState::STATE_SET;
            }
        }
        break;
    }
    }
}

void AP_Compass_MMC5XX3::read()
{
    drain_accumulated_samples(compass_instance);
}

#endif  // AP_COMPASS_MMC5XX3_ENABLED

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             /*
 * This file is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This file is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
#pragma once

#include "AP_Compass_config.h"

#if AP_COMPASS_MMC5XX3_ENABLED

#include <AP_Common/AP_Common.h>
#include <AP_HAL/AP_HAL.h>
#include <AP_HAL/I2CDevice.h>
#include <AP_Math/AP_Math.h>

#include "AP_Compass.h"
#include "AP_Compass_Backend.h"

#ifndef HAL_COMPASS_MMC5xx3_I2C_ADDR
# define HAL_COMPASS_MMC5xx3_I2C_ADDR 0x30
#endif

class AP_Compass_MMC5XX3 : public AP_Compass_Backend
{
public:
    static AP_Compass_Backend *probe(AP_HAL::OwnPtr<AP_HAL::Device> dev,
                                     bool force_external,
                                     enum Rotation rotation);

    void read() override;

    static constexpr const char *name = "MMC5983";

private:
    AP_Compass_MMC5XX3(AP_HAL::OwnPtr<AP_HAL::Device> dev,
                       bool force_external,
                       enum Rotation rotation);

    AP_HAL::OwnPtr<AP_HAL::Device> dev;

    enum class MMCState {
        STATE_SET,
        STATE_SET_MEASURE,
        STATE_SET_WAIT,
        STATE_RESET_MEASURE,
        STATE_RESET_WAIT,
        STATE_MEASURE,
    } state;
    
    /**
     * Device periodic callback to read data from the sensor.
     */
    bool init();
    void timer();
    void accumulate_field(Vector3f &field);

    uint8_t compass_instance;
    bool force_external;
    Vector3f offset;
    uint16_t measure_count;
    bool have_initial_offset;
    uint32_t refill_start_ms;
    uint32_t last_sample_ms;
    
    uint8_t data0[6];
    
    enum Rotation rotation;
};

#endif  // AP_COMPASS_MMC5XX3_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    /*
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include "AP_Compass_MSP.h"

#if AP_COMPASS_MSP_ENABLED

#include <AP_HAL/AP_HAL.h>

AP_Compass_MSP::AP_Compass_MSP(uint8_t _msp_instance)
{
    msp_instance = _msp_instance;

    auto devid = AP_HAL::Device::make_bus_id(AP_HAL::Device::BUS_TYPE_MSP, 0, _msp_instance, 0);
    register_compass(devid, instance);

    set_dev_id(instance, devid);
    set_external(instance, true);
}

void AP_Compass_MSP::handle_msp(const MSP::msp_compass_data_message_t &pkt)
{
    if (pkt.instance != msp_instance) {
        return;
    }
    Vector3f field(pkt.magX, pkt.magY, pkt.magZ);
    accumulate_sample(field, instance);
}

void AP_Compass_MSP::read(void)
{
    drain_accumulated_samples(instance);
}

#endif // AP_COMPASS_MSP_ENABLED

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              #pragma once

#include "AP_Compass_config.h"

#if AP_COMPASS_MSP_ENABLED

#include "AP_Compass.h"
#include "AP_Compass_Backend.h"
#include <AP_MSP/msp.h>

class AP_Compass_MSP : public AP_Compass_Backend
{
public:
    AP_Compass_MSP(uint8_t msp_instance);

    void read(void) override;

private:
    void handle_msp(const MSP::msp_compass_data_message_t &pkt) override;
    uint8_t msp_instance;
    uint8_t instance;
};

#endif // AP_COMPASS_MSP_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        /*
 * Copyright (C) 2016  Emlid Ltd. All rights reserved.
 *
 * This file is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This file is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Driver by RadioLink LjWang, Jun 2017
 * GPS compass module See<http://www.radiolink.com>
 */
#include "AP_Compass_QMC5883L.h"

#if AP_COMPASS_QMC5883L_ENABLED

#include <stdio.h>
#include <utility>

#include <AP_HAL/AP_HAL.h>
#include <AP_HAL/utility/sparse-endian.h>
#include <AP_Math/AP_Math.h>

#define QMC5883L_REG_CONF1 0x09
#define QMC5883L_REG_CONF2 0x0A

// data output rates for 5883L
#define QMC5883L_ODR_10HZ (0x00 << 2)
#define QMC5883L_ODR_50HZ  (0x01 << 2)
#define QMC5883L_ODR_100HZ (0x02 << 2)
#define QMC5883L_ODR_200HZ (0x03 << 2)

// Sensor operation modes
#define QMC5883L_MODE_STANDBY 0x00
#define QMC5883L_MODE_CONTINUOUS 0x01

#define QMC5883L_RNG_2G (0x00 << 4)
#define QMC5883L_RNG_8G (0x01 << 4)

#define QMC5883L_OSR_512 (0x00 << 6)
#define QMC5883L_OSR_256 (0x01 << 6)
#define QMC5883L_OSR_128	(0x10 << 6)
#define QMC5883L_OSR_64	(0x11	<< 6)

#define QMC5883L_RST 0x80

#define QMC5883L_REG_DATA_OUTPUT_X 0x00
#define QMC5883L_REG_STATUS 0x06

#define QMC5883L_REG_ID 0x0D
#define QMC5883_ID_VAL 0xFF

extern const AP_HAL::HAL &hal;

AP_Compass_Backend *AP_Compass_QMC5883L::probe(AP_HAL::OwnPtr<AP_HAL::I2CDevice> dev,
                                               bool force_external,
                                               enum Rotation rotation)
{
    if (!dev) {
        return nullptr;
    }

    AP_Compass_QMC5883L *sensor = NEW_NOTHROW AP_Compass_QMC5883L(std::move(dev),force_external,rotation);
    if (!sensor || !sensor->init()) {
        delete sensor;
        return nullptr;
    }

    return sensor;
}

AP_Compass_QMC5883L::AP_Compass_QMC5883L(AP_HAL::OwnPtr<AP_HAL::Device> dev,
                                         bool force_external,
                                         enum Rotation rotation)
    : _dev(std::move(dev))
    , _rotation(rotation)
	, _force_external(force_external)
{
}

bool AP_Compass_QMC5883L::init()
{
    _dev->get_semaphore()->take_blocking();

    _dev->set_retries(10);

#if 0
    _dump_registers();
#endif

    if(!_check_whoami()){
    	 goto fail;
    }

    if (!_dev->write_register(0x0B, 0x01)||
    	 !_dev->write_register(0x20, 0x40)||
		 !_dev->write_register(0x21, 0x01)||
		 !_dev->write_register(QMC5883L_REG_CONF1,
						QMC5883L_MODE_CONTINUOUS|
						QMC5883L_ODR_100HZ|
						QMC5883L_OSR_512|
						QMC5883L_RNG_8G)) {
    		  	  goto fail;
     }

    // lower retries for run
    _dev->set_retries(3);

    _dev->get_semaphore()->give();

    //register compass instance
    _dev->set_device_type(DEVTYPE_QMC5883L);
    if (!register_compass(_dev->get_bus_id(), _instance)) {
        return false;
    }
    set_dev_id(_instance, _dev->get_bus_id());

    printf("%s found on bus %u id %u address 0x%02x\n", name,
           _dev->bus_num(), unsigned(_dev->get_bus_id()), _dev->get_bus_address());

    set_rotation(_instance, _rotation);

    if (_force_external) {
        set_external(_instance, true);
    }

    //Enable 100HZ
    _dev->register_periodic_callback(10000,
        FUNCTOR_BIND_MEMBER(&AP_Compass_QMC5883L::timer, void));

    return true;

 fail:
    _dev->get_semaphore()->give();
    return false;
}
bool AP_Compass_QMC5883L::_check_whoami()
{
    uint8_t whoami;
    //Affected by other devices,must read registers 0x00 once or reset,after can read the ID registers reliably
    _dev->read_registers(0x00,&whoami,1);
    if (!_dev->read_registers(0x0C, &whoami,1)||
      		whoami != 0x01){
    	return false;
    }
    if (!_dev->read_registers(QMC5883L_REG_ID, &whoami,1)||
    		whoami != QMC5883_ID_VAL){
    	return false;
    }
    return true;
}

void AP_Compass_QMC5883L::timer()
{
    struct PACKED {
    	le16_t rx;
    	le16_t ry;
    	le16_t rz;
    } buffer;

    const float range_scale = 1000.0f / 3000.0f;

    uint8_t status;
    if(!_dev->read_registers(QMC5883L_REG_STATUS,&status,1)){
    	return;
    }
    //new data is ready
    if (!(status & 0x04)) {
    	return;
    }

  if(!_dev->read_registers(QMC5883L_REG_DATA_OUTPUT_X, (uint8_t *) &buffer, sizeof(buffer))){
	  return ;
  }

    auto x = -static_cast<int16_t>(le16toh(buffer.rx));
    auto y = static_cast<int16_t>(le16toh(buffer.ry));
    auto z = -static_cast<int16_t>(le16toh(buffer.rz));

#if 0
    printf("mag.x:%d\n",x);
    printf("mag.y:%d\n",y);
    printf("mag.z:%d\n",z);
#endif

    Vector3f field = Vector3f{x * range_scale , y * range_scale, z * range_scale };

    // rotate to the desired orientation
    if (is_external(_instance)) {
        field.rotate(ROTATION_YAW_90);
    }

    accumulate_sample(field, _instance, 20);
}

void AP_Compass_QMC5883L::read()
{
    drain_accumulated_samples(_instance);
}

void AP_Compass_QMC5883L::_dump_registers()
{
	  printf("QMC5883L registers dump\n");
	    for (uint8_t reg = QMC5883L_REG_DATA_OUTPUT_X; reg <= 0x30; reg++) {
	        uint8_t v;
	        _dev->read_registers(reg,&v,1);
	        printf("%02x:%02x ", (unsigned)reg, (unsigned)v);
	        if ((reg - ( QMC5883L_REG_DATA_OUTPUT_X-1)) % 16 == 0) {
	            printf("\n");
	        }
	    }
}

#endif  // AP_COMPASS_QMC5883L_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             /*
 * Copyright (C) 2016  Emlid Ltd. All rights reserved.
 *
 * This file is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This file is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
#pragma once

#include "AP_Compass_config.h"

#if AP_COMPASS_QMC5883L_ENABLED

#include <AP_Common/AP_Common.h>
#include <AP_HAL/AP_HAL.h>
#include <AP_HAL/I2CDevice.h>
#include <AP_Math/AP_Math.h>

#include "AP_Compass.h"
#include "AP_Compass_Backend.h"

#ifndef HAL_COMPASS_QMC5883L_I2C_ADDR
#define HAL_COMPASS_QMC5883L_I2C_ADDR 0x0D
#endif

/*
  setup default orientations
 */
#ifndef HAL_COMPASS_QMC5883L_ORIENTATION_EXTERNAL
#define HAL_COMPASS_QMC5883L_ORIENTATION_EXTERNAL ROTATION_ROLL_180
#endif

#ifndef HAL_COMPASS_QMC5883L_ORIENTATION_INTERNAL
#define HAL_COMPASS_QMC5883L_ORIENTATION_INTERNAL ROTATION_ROLL_180_YAW_270
#endif

class AP_Compass_QMC5883L : public AP_Compass_Backend
{
public:
    static AP_Compass_Backend *probe(AP_HAL::OwnPtr<AP_HAL::I2CDevice> dev,
									 bool force_external,
                                     enum Rotation rotation);

    void read() override;

    static constexpr const char *name = "QMC5883L";

private:
    AP_Compass_QMC5883L(AP_HAL::OwnPtr<AP_HAL::Device> dev,
                        bool force_external,
                        enum Rotation rotation);

    void _dump_registers();
    bool _check_whoami();
    void timer();
    bool init();

    AP_HAL::OwnPtr<AP_HAL::Device> _dev;

    enum Rotation _rotation;
    uint8_t _instance;
    bool _force_external:1;
};

#endif  // AP_COMPASS_QMC5883L_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  /*
 * This file is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This file is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Driver by Lokesh Ramina, Jan 2022
 */
#include "AP_Compass_QMC5883P.h"

#include <stdio.h>

#include <AP_HAL/AP_HAL.h>
#include <AP_Math/AP_Math.h>

#if AP_COMPASS_QMC5883P_ENABLED

//Register Address
#define QMC5883P_REG_ID                 0x00
#define QMC5883P_REG_DATA_OUTPUT_X      0x01
#define QMC5883P_REG_DATA_OUTPUT_Z_MSB  0x06
#define QMC5883P_REG_STATUS             0x09
#define QMC5883P_REG_CONF1              0x0A
#define QMC5883P_REG_CONF2              0x0B

#define QMC5883P_ID_VAL 0x80

//Register values
// Sensor operation modes
#define QMC5883P_MODE_SUSPEND    0x00
#define QMC5883P_MODE_NORMAL     0x01
#define QMC5883P_MODE_SINGLE     0x02
#define QMC5883P_MODE_CONTINUOUS 0x03

// ODR data output rates for 5883L
#define QMC5883P_ODR_10HZ  (0x00 << 2)
#define QMC5883P_ODR_50HZ  (0x01 << 2)
#define QMC5883P_ODR_100HZ (0x02 << 2)
#define QMC5883P_ODR_200HZ (0x03 << 2)

// Over sampling Ratio OSR1
#define QMC5883P_OSR1_8 (0x00 << 4)
#define QMC5883P_OSR1_4 (0x01 << 4)
#define QMC5883P_OSR1_2	(0x02 << 4)
#define QMC5883P_OSR1_1	(0x03 << 4)

// Down sampling Rate OSR2
#define QMC5883P_OSR2_8	0x08

//RNG
#define QMC5883P_RNG_30G (0x00 << 2)
#define QMC5883P_RNG_12G (0x01 << 2)
#define QMC5883P_RNG_8G  (0x10 << 2)
#define QMC5883P_RNG_2G  (0x11 << 2)

#define QMC5883P_SET_XYZ_SIGN 0x29

//Reset
#define QMC5883P_RST 0x80

//Status Val
#define QMC5883P_STATUS_DATA_READY 0x01

#ifndef DEBUG
#define DEBUG 0
#endif

extern const AP_HAL::HAL &hal;

AP_Compass_Backend *AP_Compass_QMC5883P::probe(AP_HAL::OwnPtr<AP_HAL::I2CDevice> dev,
        bool force_external,
        enum Rotation rotation)
{
    if (!dev) {
        return nullptr;
    }
    AP_Compass_QMC5883P *sensor = NEW_NOTHROW AP_Compass_QMC5883P(std::move(dev),force_external,rotation);
    if (!sensor || !sensor->init()) {
        delete sensor;
        return nullptr;
    }
    return sensor;
}

AP_Compass_QMC5883P::AP_Compass_QMC5883P(AP_HAL::OwnPtr<AP_HAL::Device> dev,
        bool force_external,
        enum Rotation rotation)
    : _dev(std::move(dev))
    , _rotation(rotation)
    , _force_external(force_external)
{
}

bool AP_Compass_QMC5883P::init()
{
    _dev->get_semaphore()->take_blocking();

    _dev->set_retries(10);
#if DEBUG
    _dump_registers();
#endif
    if (!_check_whoami()) {
        goto fail;
    }
    //As mentioned in the Datasheet 7.2 to do continues mode 0x29 will set sign for X,Y,Z
    if (!_dev->write_register(QMC5883P_REG_DATA_OUTPUT_Z_MSB, QMC5883P_SET_XYZ_SIGN)||
        !_dev->write_register(QMC5883P_REG_CONF1,
                              QMC5883P_MODE_CONTINUOUS|
                              QMC5883P_ODR_100HZ|
                              QMC5883P_OSR1_8|
                              QMC5883P_OSR2_8)||
        !_dev->write_register(QMC5883P_REG_CONF2,QMC5883P_OSR2_8)) {
        goto fail;
    }

    // lower retries for run
    _dev->set_retries(3);

    _dev->get_semaphore()->give();

    //register compass instance
    _dev->set_device_type(DEVTYPE_QMC5883P);
    if (!register_compass(_dev->get_bus_id(), _instance)) {
        return false;
    }
    set_dev_id(_instance, _dev->get_bus_id());

    printf("%s found on bus %u id %u address 0x%02x\n", name,
           _dev->bus_num(), unsigned(_dev->get_bus_id()), _dev->get_bus_address());

    set_rotation(_instance, _rotation);

    if (_force_external) {
        set_external(_instance, true);
    }

    //Enable 100HZ
    _dev->register_periodic_callback(10000,
                                     FUNCTOR_BIND_MEMBER(&AP_Compass_QMC5883P::timer, void));

    return true;

fail:
    _dev->get_semaphore()->give();
    return false;
}
bool AP_Compass_QMC5883P::_check_whoami()
{
    uint8_t whoami;
    if (!_dev->read_registers(QMC5883P_REG_ID, &whoami,1)||
        whoami != QMC5883P_ID_VAL) {
        return false;
    }
    return true;
}

void AP_Compass_QMC5883P::timer()
{
    struct PACKED {
        int16_t rx;
        int16_t ry;
        int16_t rz;
    } buffer;

    const float range_scale = 1000.0f / 3000.0f;

    uint8_t status;
    if (!_dev->read_registers(QMC5883P_REG_STATUS,&status,1)) {
        return;
    }
    //new data is ready
    if (!(status & QMC5883P_STATUS_DATA_READY)) {
        return;
    }

    if (!_dev->read_registers(QMC5883P_REG_DATA_OUTPUT_X, (uint8_t *) &buffer, sizeof(buffer))) {
        return ;
    }

    auto x = buffer.rx;
    auto y = buffer.ry;
    auto z = buffer.rz;

#if DEBUG
    printf("mag.x:%d\n",x);
    printf("mag.y:%d\n",y);
    printf("mag.z:%d\n",z);
#endif

    Vector3f field = Vector3f{x * range_scale, y * range_scale, z * range_scale };

    accumulate_sample(field, _instance, 20);
}

void AP_Compass_QMC5883P::read()
{
    drain_accumulated_samples(_instance);
}

void AP_Compass_QMC5883P::_dump_registers()
{
    printf("QMC5883P registers dump\n");
    for (uint8_t reg = QMC5883P_REG_DATA_OUTPUT_X; reg <= 0x30; reg++) {
        uint8_t v;
        _dev->read_registers(reg,&v,1);
        printf("%02x:%02x ", (unsigned)reg, (unsigned)v);
        if ((reg - ( QMC5883P_REG_DATA_OUTPUT_X-1)) % 16 == 0) {
            printf("\n");
        }
    }
}

#endif //AP_COMPASS_QMC5883P_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   /*
 * This file is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This file is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Driver by Lokesh Ramina, Jan 2022
 */
#pragma once

#include <AP_HAL/AP_HAL.h>
#include <AP_HAL/I2CDevice.h>
#include <AP_Math/AP_Math.h>

#include "AP_Compass_config.h"

#ifdef AP_COMPASS_QMC5883P_ENABLED

#include "AP_Compass.h"
#include "AP_Compass_Backend.h"

#ifndef HAL_COMPASS_QMC5883P_I2C_ADDR
#define HAL_COMPASS_QMC5883P_I2C_ADDR 0x2C
#endif

/*
  setup default orientations
 */
#ifndef HAL_COMPASS_QMC5883P_ORIENTATION_EXTERNAL
#define HAL_COMPASS_QMC5883P_ORIENTATION_EXTERNAL ROTATION_ROLL_180
#endif

#ifndef HAL_COMPASS_QMC5883P_ORIENTATION_INTERNAL
#define HAL_COMPASS_QMC5883P_ORIENTATION_INTERNAL ROTATION_ROLL_180_YAW_270
#endif

class AP_Compass_QMC5883P : public AP_Compass_Backend
{
public:
    static AP_Compass_Backend *probe(AP_HAL::OwnPtr<AP_HAL::I2CDevice> dev,
                                     bool force_external,
                                     enum Rotation rotation);

    void read() override;

    static constexpr const char *name = "QMC5883P";

private:
    AP_Compass_QMC5883P(AP_HAL::OwnPtr<AP_HAL::Device> dev,
                        bool force_external,
                        enum Rotation rotation);

    void _dump_registers();
    bool _check_whoami();
    void timer();
    bool init();

    AP_HAL::OwnPtr<AP_HAL::Device> _dev;

    enum Rotation _rotation;
    uint8_t _instance;
    bool _force_external:1;
};

#endif  // AP_COMPASS_QMC5883P_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       /*
 * This file is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This file is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
/*
  Driver by Thomas Schumacher, Jan 2019
  Structure based on LIS3MDL driver

 */
#include "AP_Compass_RM3100.h"

#if AP_COMPASS_RM3100_ENABLED

#include <AP_HAL/AP_HAL.h>
#include <utility>
#include <AP_Math/AP_Math.h>
#include <stdio.h>

#define RM3100_POLL_REG        0x00

#define RM3100_CMM_REG         0x01

#define RM3100_CCX1_REG        0x04
#define RM3100_CCX0_REG        0x05
#define RM3100_CCY1_REG        0x06
#define RM3100_CCY0_REG        0x07
#define RM3100_CCZ1_REG        0x08
#define RM3100_CCZ0_REG        0x09

#define RM3100_TMRC_REG        0x0B

#define RM3100_MX2_REG      0x24
#define RM3100_MX1_REG      0x25
#define RM3100_MX0_REG      0x26
#define RM3100_MY2_REG      0x27
#define RM3100_MY1_REG      0x28
#define RM3100_MY0_REG      0x29
#define RM3100_MZ2_REG      0x2A
#define RM3100_MZ1_REG      0x2B
#define RM3100_MZ0_REG      0x2C

#define RM3100_BIST_REG       0x33
#define RM3100_STATUS_REG     0x34
#define RM3100_HSHAKE_REG     0x34
#define RM3100_REVID_REG      0x36

#define CCP0    0xC8      // Cycle Count values
#define CCP1    0x00
#define CCP0_DEFAULT 0xC8 // Default Cycle Count values (used as a whoami check)
#define CCP1_DEFAULT 0x00
#define GAIN_CC50 20.0f   // LSB/uT
#define GAIN_CC100 38.0f
#define GAIN_CC200 75.0f

#define TMRC    0x94    // Update rate 150Hz
#define CMM     0x71    // read 3 axes and set data ready if 3 axes are ready

extern const AP_HAL::HAL &hal;

AP_Compass_Backend *AP_Compass_RM3100::probe(AP_HAL::OwnPtr<AP_HAL::Device> dev,
                                              bool force_external,
                                              enum Rotation rotation)
{
    if (!dev) {
        return nullptr;
    }
    AP_Compass_RM3100 *sensor = NEW_NOTHROW AP_Compass_RM3100(std::move(dev), force_external, rotation);
    if (!sensor || !sensor->init()) {
        delete sensor;
        return nullptr;
    }

    return sensor;
}

AP_Compass_RM3100::AP_Compass_RM3100(AP_HAL::OwnPtr<AP_HAL::Device> _dev,
                                       bool _force_external,
                                       enum Rotation _rotation)
    : dev(std::move(_dev))
    , force_external(_force_external)
    , rotation(_rotation)
{
}

bool AP_Compass_RM3100::init()
{
    dev->get_semaphore()->take_blocking();

    if (dev->bus_type() == AP_HAL::Device::BUS_TYPE_SPI) {
        // read has high bit set for SPI
        dev->set_read_flag(0x80);
    }

    // high retries for init
    dev->set_retries(10);

    // use default cycle count values as a whoami test
    uint8_t ccx0;
    uint8_t ccx1;
    uint8_t ccy0;
    uint8_t ccy1;
    uint8_t ccz0;
    uint8_t ccz1;
    if (!dev->read_registers(RM3100_CCX1_REG, &ccx1, 1) ||
        !dev->read_registers(RM3100_CCX0_REG, &ccx0, 1) ||
        !dev->read_registers(RM3100_CCY1_REG, &ccy1, 1) ||
        !dev->read_registers(RM3100_CCY0_REG, &ccy0, 1) ||
        !dev->read_registers(RM3100_CCZ1_REG, &ccz1, 1) ||
        !dev->read_registers(RM3100_CCZ0_REG, &ccz0, 1) ||
        ccx1 != CCP1_DEFAULT || ccx0 != CCP0_DEFAULT ||
        ccy1 != CCP1_DEFAULT || ccy0 != CCP0_DEFAULT ||
        ccz1 != CCP1_DEFAULT || ccz0 != CCP0_DEFAULT) {
        // couldn't read one of the cycle count registers or didn't recognize the default cycle count values
        dev->get_semaphore()->give();
        return false;
    }

    dev->setup_checked_registers(8);

    dev->write_register(RM3100_TMRC_REG, TMRC, true); // CMM data rate
    dev->write_register(RM3100_CMM_REG, CMM, true); // CMM configuration
    dev->write_register(RM3100_CCX1_REG, CCP1, true); // cycle count x
    dev->write_register(RM3100_CCX0_REG, CCP0, true); // cycle count x
    dev->write_register(RM3100_CCY1_REG, CCP1, true); // cycle count y
    dev->write_register(RM3100_CCY0_REG, CCP0, true); // cycle count y
    dev->write_register(RM3100_CCZ1_REG, CCP1, true); // cycle count z
    dev->write_register(RM3100_CCZ0_REG, CCP0, true); // cycle count z

    _scaler = (1 / GAIN_CC200) * UTESLA_TO_MGAUSS; // has to be changed if using a different cycle count

    // lower retries for run
    dev->set_retries(3);

    dev->get_semaphore()->give();

    /* register the compass instance in the frontend */
    dev->set_device_type(DEVTYPE_RM3100);
    if (!register_compass(dev->get_bus_id(), compass_instance)) {
        return false;
    }
    set_dev_id(compass_instance, dev->get_bus_id());

    DEV_PRINTF("RM3100: Found at address 0x%x as compass %u\n", dev->get_bus_address(), compass_instance);
    
    set_rotation(compass_instance, rotation);

    if (force_external) {
        set_external(compass_instance, true);
    }
    
    // call timer() at 80Hz
    dev->register_periodic_callback(1000000U/80U,
                                    FUNCTOR_BIND_MEMBER(&AP_Compass_RM3100::timer, void));

    return true;
}

void AP_Compass_RM3100::timer()
{
    struct PACKED {
        uint8_t magx_2;
        uint8_t magx_1;
        uint8_t magx_0;
        uint8_t magy_2;
        uint8_t magy_1;
        uint8_t magy_0;
        uint8_t magz_2;
        uint8_t magz_1;
        uint8_t magz_0;
    } data;

    int32_t magx = 0;
    int32_t magy = 0;
    int32_t magz = 0;

    // check data ready on 3 axis
    uint8_t status;
    if (!dev->read_registers(RM3100_STATUS_REG, (uint8_t *)&status, 1)) {
        goto check_registers;
    }

    if (!(status & 0x80)) {
        // data not available yet
        goto check_registers;
    }

    if (!dev->read_registers(RM3100_MX2_REG, (uint8_t *)&data, sizeof(data))) {
        goto check_registers;
    }

    // the 24 bits of data for each axis are in 2s complement representation
    // each byte is shifted to its position in a 24-bit unsigned integer and from 8 more bits to be left-aligned in a 32-bit integer
    magx = ((uint32_t)data.magx_2 << 24) | ((uint32_t)data.magx_1 << 16) | ((uint32_t)data.magx_0 << 8);
    magy = ((uint32_t)data.magy_2 << 24) | ((uint32_t)data.magy_1 << 16) | ((uint32_t)data.magy_0 << 8);
    magz = ((uint32_t)data.magz_2 << 24) | ((uint32_t)data.magz_1 << 16) | ((uint32_t)data.magz_0 << 8);

    // right-shift signed integer back to get correct measurement value
    magx >>= 8;
    magy >>= 8;
    magz >>= 8;

#ifdef AP_RM3100_REVERSAL_MASK
    // some RM3100 builds get the polarity wrong on one or more of the
    // elements. By setting AP_RM3100_REVERSAL_MASK in hwdef.dat you
    // can fix it without modifying the hardware
    if (AP_RM3100_REVERSAL_MASK & 1U) {
        magx = -magx;
    }
    if (AP_RM3100_REVERSAL_MASK & 2U) {
        magy = -magy;
    }
    if (AP_RM3100_REVERSAL_MASK & 4U) {
        magz = -magz;
    }
#endif

    {
        // apply scaler and store in field vector
         Vector3f field{
             magx * _scaler,
             magy * _scaler,
             magz * _scaler
         };

        accumulate_sample(field, compass_instance);
    }

check_registers:
    dev->check_next_register();
}

void AP_Compass_RM3100::read()
{
	drain_accumulated_samples(compass_instance);
}

#endif  // AP_COMPASS_RM3100_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    /*
 * This file is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This file is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
#pragma once

#include "AP_Compass_config.h"

#if AP_COMPASS_RM3100_ENABLED

#include <AP_Common/AP_Common.h>
#include <AP_HAL/AP_HAL.h>
#include <AP_HAL/Device.h>
#include <AP_Math/AP_Math.h>

#include "AP_Compass.h"
#include "AP_Compass_Backend.h"

#ifndef HAL_COMPASS_RM3100_I2C_ADDR
# define HAL_COMPASS_RM3100_I2C_ADDR1 0x20
# define HAL_COMPASS_RM3100_I2C_ADDR2 0x21
# define HAL_COMPASS_RM3100_I2C_ADDR3 0x22
# define HAL_COMPASS_RM3100_I2C_ADDR4 0x23
#endif

class AP_Compass_RM3100 : public AP_Compass_Backend
{
public:
    static AP_Compass_Backend *probe(AP_HAL::OwnPtr<AP_HAL::Device> dev,
                                     bool force_external,
                                     enum Rotation rotation);

    void read() override;

    static constexpr const char *name = "RM3100";

private:
    AP_Compass_RM3100(AP_HAL::OwnPtr<AP_HAL::Device> dev,
                       bool force_external,
                       enum Rotation rotation);

    AP_HAL::OwnPtr<AP_HAL::Device> dev;
    
    /**
     * Device periodic callback to read data from the sensor.
     */
    bool init();
    void timer();

    uint8_t compass_instance;
    bool force_external;
    enum Rotation rotation;
    float _scaler = 1.0;
};

#endif  // AP_COMPASS_RM3100_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     #include "AP_Compass_SITL.h"

#if AP_COMPASS_SITL_ENABLED

#include <AP_HAL/AP_HAL.h>

extern const AP_HAL::HAL& hal;

AP_Compass_SITL::AP_Compass_SITL()
    : _sitl(AP::sitl())
{
    if (_sitl != nullptr) {
        for (uint8_t i=0; i<MAX_CONNECTED_MAGS; i++) {
            uint32_t dev_id = _sitl->mag_devid[i];
            if (dev_id == 0) {
                continue;
            }
            uint8_t instance;
            if (!register_compass(dev_id, instance)) {
                continue;
            } else if (_num_compass<MAX_SITL_COMPASSES) {
                _compass_instance[_num_compass] = instance;
                set_dev_id(_compass_instance[_num_compass], dev_id);

                if (_sitl->mag_save_ids) {
                    // save so the compass always comes up configured in SITL
                    save_dev_id(_compass_instance[_num_compass]);
                }
                set_rotation(instance, ROTATION_NONE);
                _num_compass++;
            }
        }

        // Scroll through the registered compasses, and set the offsets
        for (uint8_t i=0; i<_num_compass; i++) {
            if (_compass.get_offsets(i).is_zero()) {
                _compass.set_offsets(i, _sitl->mag_ofs[i]);
            }
        }

        // we want to simulate a calibrated compass by default, so set
        // scale to 1
        AP_Param::set_default_by_name("COMPASS_SCALE", 1);
        AP_Param::set_default_by_name("COMPASS_SCALE2", 1);
        AP_Param::set_default_by_name("COMPASS_SCALE3", 1);

        // make first compass external
        set_external(_compass_instance[0], true);

        hal.scheduler->register_timer_process(FUNCTOR_BIND(this, &AP_Compass_SITL::_timer, void));
    }
}


/*
  create correction matrix for diagonals and off-diagonals
*/
void AP_Compass_SITL::_setup_eliptical_correcion(uint8_t i)
{
    Vector3f diag = _sitl->mag_diag[i].get();
    if (diag.is_zero()) {
        diag = {1,1,1};
    }
    const Vector3f &diagonals = diag;
    const Vector3f &offdiagonals = _sitl->mag_offdiag[i];
    
    if (diagonals == _last_dia && offdiagonals == _last_odi) {
        return;
    }
    
    _eliptical_corr = Matrix3f(diagonals.x,    offdiagonals.x, offdiagonals.y,
                               offdiagonals.x, diagonals.y,    offdiagonals.z,
                               offdiagonals.y, offdiagonals.z, diagonals.z);
    if (!_eliptical_corr.invert()) {
        _eliptical_corr.identity();
    }
    _last_dia = diag;
    _last_odi = offdiagonals;
}

void AP_Compass_SITL::_timer()
{
    // TODO: Refactor delay buffer with AP_Baro_SITL.

    // Sampled at 100Hz
    uint32_t now = AP_HAL::millis();
    if ((now - _last_sample_time) < 10) {
        return;
    }
    _last_sample_time = now;

    // calculate sensor noise and add to 'truth' field in body frame
    // units are milli-Gauss
    Vector3f noise = rand_vec3f() * _sitl->mag_noise;
    Vector3f new_mag_data = _sitl->state.bodyMagField + noise;

    // add delay
    uint32_t best_time_delta = 1000; // initialise large time representing buffer entry closest to current time - delay.
    uint8_t best_index = 0; // initialise number representing the index of the entry in buffer closest to delay.

    // storing data from sensor to buffer
    if (now - last_store_time >= 10) { // store data every 10 ms.
        last_store_time = now;
        if (store_index > buffer_length-1) { // reset buffer index if index greater than size of buffer
            store_index = 0;
        }
        buffer[store_index].data = new_mag_data; // add data to current index
        buffer[store_index].time = last_store_time; // add time to current index
        store_index = store_index + 1; // increment index
    }

    // return delayed measurement
    uint32_t delayed_time = now - _sitl->mag_delay; // get time corresponding to delay
    // find data corresponding to delayed time in buffer
    for (uint8_t i=0; i<=buffer_length-1; i++) {
        // find difference between delayed time and time stamp in buffer
        uint32_t time_delta = abs((int32_t)(delayed_time - buffer[i].time));
        // if this difference is smaller than last delta, store this time
        if (time_delta < best_time_delta) {
            best_index= i;
            best_time_delta = time_delta;
        }
    }
    if (best_time_delta < 1000) { // only output stored state if < 1 sec retrieval error
        new_mag_data = buffer[best_index].data;
    }

    for (uint8_t i=0; i<_num_compass; i++) {
        _setup_eliptical_correcion(i);
        Vector3f f = (_eliptical_corr * new_mag_data) - _sitl->mag_ofs[i].get();
        // rotate compass
        f.rotate_inverse((enum Rotation)_sitl->mag_orient[i].get());
        f.rotate(get_board_orientation());
        // scale the compass to simulate sensor scale factor errors
        f *= _sitl->mag_scaling[i];

        switch (_sitl->mag_fail[i]) {
        case 0:
            accumulate_sample(f, _compass_instance[i], 10);
            _last_data[i] = f;
            break;
        case 1:
            // no data
            break;
        case 2:
            // frozen compass
            accumulate_sample(_last_data[i], _compass_instance[i], 10);
            break;
        }
    }
}

void AP_Compass_SITL::read()
{
    for (uint8_t i=0; i<_num_compass; i++) {
        drain_accumulated_samples(_compass_instance[i], nullptr);
    }
}
#endif  // AP_COMPASS_SITL_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       #pragma once

#include "AP_Compass.h"

#if AP_COMPASS_SITL_ENABLED

#include "AP_Compass_Backend.h"

#include <AP_Math/vectorN.h>
#include <AP_Math/AP_Math.h>
#include <AP_Declination/AP_Declination.h>
#include <SITL/SITL.h>

#define MAX_SITL_COMPASSES 3

class AP_Compass_SITL : public AP_Compass_Backend {
public:
    AP_Compass_SITL();

    void read(void) override;

private:
    uint8_t _compass_instance[MAX_SITL_COMPASSES];
    uint8_t _num_compass;
    SITL::SIM *_sitl;

    // delay buffer variables
    struct readings_compass {
        uint32_t time;
        Vector3f data;
    };
    uint8_t store_index;
    uint32_t last_store_time;
    static const uint8_t buffer_length = 50;
    VectorN<readings_compass,buffer_length> buffer;

    void _timer();
    uint32_t _last_sample_time;

    void _setup_eliptical_correcion(uint8_t i);
    
    Matrix3f _eliptical_corr;
    Vector3f _last_dia;
    Vector3f _last_odi;
    Vector3f _last_data[MAX_SITL_COMPASSES];
};
#endif // AP_COMPASS_SITL_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             