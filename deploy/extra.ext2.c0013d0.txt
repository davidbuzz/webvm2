script_time_done void uint16_t'skip_check
singleton AP_Vehicle method set_target_throttle_rate_rpy void float -100 100 float'skip_check float'skip_check float'skip_check
singleton AP_Vehicle method set_rudder_offset void float'skip_check boolean
singleton AP_Vehicle method set_desired_turn_rate_and_speed boolean float'skip_check float'skip_check
singleton AP_Vehicle method set_desired_speed boolean float'skip_check
singleton AP_Vehicle method nav_scripting_enable boolean uint8_t'skip_check
singleton AP_Vehicle method set_velocity_match boolean Vector2f
singleton AP_Vehicle method set_land_descent_rate boolean float'skip_check
singleton AP_Vehicle method has_ekf_failsafed boolean
singleton AP_Vehicle method reboot void boolean
singleton AP_Vehicle method is_landing boolean
singleton AP_Vehicle method is_taking_off boolean
singleton AP_Vehicle method set_crosstrack_start boolean Location

include AP_SerialLED/AP_SerialLED.h
singleton AP_SerialLED rename serialLED
singleton AP_SerialLED depends AP_SERIALLED_ENABLED
singleton AP_SerialLED method set_num_neopixel boolean uint8_t 1 16 uint8_t 0 AP_SERIALLED_MAX_LEDS
singleton AP_SerialLED method set_num_neopixel_rgb boolean uint8_t 1 16 uint8_t 0 AP_SERIALLED_MAX_LEDS
singleton AP_SerialLED method set_num_profiled boolean uint8_t 1 16 uint8_t 0 AP_SERIALLED_MAX_LEDS
singleton AP_SerialLED method set_RGB boolean uint8_t 1 16 int8_t -1 INT8_MAX uint8_t'skip_check uint8_t'skip_check uint8_t'skip_check
singleton AP_SerialLED method send boolean uint8_t 1 16

include SRV_Channel/SRV_Channel.h
singleton SRV_Channels depends (!defined(HAL_BUILD_AP_PERIPH) || defined(HAL_PERIPH_ENABLE_RC_OUT))
singleton SRV_Channels rename SRV_Channels
singleton SRV_Channels method find_channel boolean SRV_Channel::Aux_servo_function_t'enum SRV_Channel::k_none SRV_Channel::k_nr_aux_servo_functions-1 uint8_t'Null
singleton SRV_Channels method set_output_pwm void SRV_Channel::Aux_servo_function_t'enum SRV_Channel::k_none SRV_Channel::k_nr_aux_servo_functions-1 uint16_t'skip_check
singleton SRV_Channels method set_output_pwm_chan void uint8_t 0 NUM_SERVO_CHANNELS-1 uint16_t'skip_check
singleton SRV_Channels method set_output_pwm_chan_timeout void uint8_t 0 NUM_SERVO_CHANNELS-1 uint16_t'skip_check uint16_t'skip_check
singleton SRV_Channels method set_output_pwm_chan_timeout depends (!defined(HAL_BUILD_AP_PERIPH))
singleton SRV_Channels method set_output_scaled void SRV_Channel::Aux_servo_function_t'enum SRV_Channel::k_none SRV_Channel::k_nr_aux_servo_functions-1 float'skip_check
singleton SRV_Channels method get_output_pwm boolean SRV_Channel::Aux_servo_function_t'enum SRV_Channel::k_none SRV_Channel::k_nr_aux_servo_functions-1 uint16_t'Null
singleton SRV_Channels method get_output_scaled float SRV_Channel::Aux_servo_function_t'enum SRV_Channel::k_none SRV_Channel::k_nr_aux_servo_functions-1
singleton SRV_Channels method set_output_norm void SRV_Channel::Aux_servo_function_t'enum SRV_Channel::k_none SRV_Channel::k_nr_aux_servo_functions-1 float -1 1
singleton SRV_Channels method set_angle void SRV_Channel::Aux_servo_function_t'enum SRV_Channel::k_none SRV_Channel::k_nr_aux_servo_functions-1 uint16_t'skip_check
singleton SRV_Channels method set_range void SRV_Channel::Aux_servo_function_t'enum SRV_Channel::k_none SRV_Channel::k_nr_aux_servo_functions-1 uint16_t'skip_check
singleton SRV_Channels method get_emergency_stop boolean
singleton SRV_Channels manual get_safety_state SRV_Channels_get_safety_state 0 1

ap_object RC_Channel depends AP_RC_CHANNEL_ENABLED
ap_object RC_Channel method norm_input float
ap_object RC_Channel method norm_input_dz float
ap_object RC_Channel method get_aux_switch_pos uint8_t
ap_object RC_Channel method norm_input_ignore_trim float
ap_object RC_Channel method set_override void uint16_t 0 2200 0'literal

include RC_Channel/RC_Channel.h
singleton RC_Channels depends AP_RC_CHANNEL_ENABLED
singleton RC_Channels rename rc
singleton RC_Channels scheduler-semaphore
singleton RC_Channels method get_pwm boolean uint8_t 1 NUM_RC_CHANNELS uint16_t'Null
singleton RC_Channels method find_channel_for_option RC_Channel RC_Channel::AUX_FUNC'enum 0 UINT16_MAX
singleton RC_Channels method run_aux_function boolean RC_Channel::AUX_FUNC'enum 0 UINT16_MAX RC_Channel::AuxSwitchPos'enum RC_Channel::AuxSwitchPos::LOW RC_Channel::AuxSwitchPos::HIGH RC_Channel::AuxFuncTriggerSource::SCRIPTING'literal
singleton RC_Channels method has_valid_input boolean
singleton RC_Channels method lua_rc_channel RC_Channel uint8_t 1 NUM_RC_CHANNELS
singleton RC_Channels method lua_rc_channel rename get_channel
singleton RC_Channels method get_aux_cached boolean RC_Channel::AUX_FUNC'enum 0 UINT16_MAX uint8_t'Null

include AP_Scripting/AP_Scripting_SerialAccess.h
-- don't let user create access objects
userdata AP_Scripting_SerialAccess creation null -1
userdata AP_Scripting_SerialAccess method begin void uint32_t 1U UINT32_MAX
userdata AP_Scripting_SerialAccess method write uint32_t uint8_t'skip_check
userdata AP_Scripting_SerialAccess manual writestring lua_serial_writestring 1 1
userdata AP_Scripting_SerialAccess method read int16_t
userdata AP_Scripting_SerialAccess manual readstring lua_serial_readstring 1 1
userdata AP_Scripting_SerialAccess method available uint32_t
userdata AP_Scripting_SerialAccess method set_flow_control void AP_HAL::UARTDriver::flow_control'enum AP_HAL::UARTDriver::FLOW_CONTROL_DISABLE AP_HAL::UARTDriver::FLOW_CONTROL_RTS_DE

-- serial is not a real C++ type here, but its name never gets used in C++ as we only have manual methods
singleton serial depends AP_SERIALMANAGER_ENABLED
singleton serial manual find_serial lua_serial_find_serial 1 1
singleton serial manual find_simulated_device lua_serial_find_simulated_device 2 1 depends AP_SCRIPTING_SERIALDEVICE_ENABLED

include AP_Baro/AP_Baro.h
singleton AP_Baro depends (!defined(HAL_BUILD_AP_PERIPH) || defined(HAL_PERIPH_ENABLE_BARO))
singleton AP_Baro rename baro
singleton AP_Baro method get_pressure float
singleton AP_Baro method get_temperature float
singleton AP_Baro method get_external_temperature float
singleton AP_Baro method get_altitude float
singleton AP_Baro method healthy boolean uint8_t'skip_check
singleton AP_Baro method get_altitude_difference float float'skip_check float'skip_check

include AP_OpticalFlow/AP_OpticalFlow.h
singleton AP_OpticalFlow depends AP_OPTICALFLOW_ENABLED
singleton AP_OpticalFlow rename optical_flow
singleton AP_OpticalFlow method enabled boolean
singleton AP_OpticalFlow method healthy boolean
singleton AP_OpticalFlow method quality uint8_t

include AP_ESC_Telem/AP_ESC_Telem.h

userdata AP_ESC_Telem_Backend::TelemetryData depends (HAL_WITH_ESC_TELEM == 1)
userdata AP_ESC_Telem_Backend::TelemetryData rename ESCTelemetryData
userdata AP_ESC_Telem_Backend::TelemetryData field temperature_cdeg int16_t'skip_check write
userdata AP_ESC_Telem_Backend::TelemetryData field voltage float'skip_check write
userdata AP_ESC_Telem_Backend::TelemetryData field current float'skip_check write
userdata AP_ESC_Telem_Backend::TelemetryData field consumption_mah float'skip_check write
userdata AP_ESC_Telem_Backend::TelemetryData field motor_temp_cdeg int16_t'skip_check write

singleton AP_ESC_Telem depends HAL_WITH_ESC_TELEM == 1
singleton AP_ESC_Telem rename esc_telem
singleton AP_ESC_Telem method get_rpm boolean uint8_t'skip_check float'Null
singleton AP_ESC_Telem method get_temperature boolean uint8_t'skip_check int16_t'Null
singleton AP_ESC_Telem method get_motor_temperature boolean uint8_t'skip_check int16_t'Null
singleton AP_ESC_Telem method get_current boolean uint8_t'skip_check float'Null
singleton AP_ESC_Telem method get_voltage boolean uint8_t'skip_check float'Null
singleton AP_ESC_Telem method get_consumption_mah boolean uint8_t'skip_check float'Null
singleton AP_ESC_Telem method get_usage_seconds boolean uint8_t'skip_check uint32_t'Null
singleton AP_ESC_Telem method update_rpm void uint8_t 0 ESC_TELEM_MAX_ESCS uint16_t'skip_check float'skip_check
singleton AP_ESC_Telem method update_telem_data void uint8_t 0 ESC_TELEM_MAX_ESCS AP_ESC_Telem_Backend::TelemetryData uint16_t'skip_check
singleton AP_ESC_Telem method set_rpm_scale void uint8_t 0 ESC_TELEM_MAX_ESCS float'skip_check
singleton AP_ESC_Telem method get_last_telem_data_ms uint32_t uint8_t 0 ESC_TELEM_MAX_ESCS

include AP_Param/AP_Param.h
singleton AP_Param rename param
singleton AP_Param method get boolean string float'Null
singleton AP_Param method set_by_name boolean string float'skip_check
singleton AP_Param method set_by_name rename set
singleton AP_Param method set_and_save_by_name boolean string float'skip_check
singleton AP_Param method set_and_save_by_name rename set_and_save
singleton AP_Param method set_default_by_name boolean string float'skip_check
singleton AP_Param method set_default_by_name rename set_default
singleton AP_Param method add_table boolean uint8_t 0 200 string uint8_t 1 63
singleton AP_Param method add_table depends AP_PARAM_DYNAMIC_ENABLED
singleton AP_Param method add_param boolean uint8_t 0 200 uint8_t 1 63 string float'skip_check
singleton AP_Param method add_param depends AP_PARAM_DYNAMIC_ENABLED

include AP_Scripting/AP_Scripting_helpers.h
userdata Parameter creation lua_new_Parameter 0
userdata Parameter method init boolean string
userdata Parameter method init_by_info boolean uint16_t'skip_check uint32_t'skip_check ap_var_type'enum AP_PARAM_INT8 AP_PARAM_FLOAT
userdata Parameter method get boolean float'Null
userdata Parameter method set boolean float'skip_check
userdata Parameter method set_and_save boolean float'skip_check
userdata Parameter method configured boolean
userdata Parameter method set_default boolean float'skip_check

include AP_Scripting/AP_Scripting.h
singleton AP_Scripting rename scripting
singleton AP_Scripting method restart_all void

include AP_Mission/AP_Mission.h
singleton AP_Mission depends AP_MISSION_ENABLED
singleton AP_Mission rename mission
singleton AP_Mission scheduler-semaphore
singleton AP_Mission enum MISSION_STOPPED MISSION_RUNNING MISSION_COMPLETE
singleton AP_Mission method state uint8_t
singleton AP_Mission method get_current_nav_index uint16_t
singleton AP_Mission method set_current_cmd boolean uint16_t 0 (ud->num_commands()-1)
singleton AP_Mission method get_prev_nav_cmd_id uint16_t
singleton AP_Mission method get_current_nav_id uint16_t
singleton AP_Mission method get_current_do_cmd_id uint16_t
singleton AP_Mission method num_commands uint16_t
singleton AP_Mission method get_item boolean uint16_t'skip_check mavlink_mission_item_int_t'Null
singleton AP_Mission method set_item boolean uint16_t'skip_check mavlink_mission_item_int_t
singleton AP_Mission method clear boolean
singleton AP_Mission method cmd_has_location boolean uint16_t'skip_check
singleton AP_Mission method jump_to_tag boolean uint16_t 0 UINT16_MAX
singleton AP_Mission method get_index_of_jump_tag uint16_t uint16_t 0 UINT16_MAX
singleton AP_Mission method get_last_jump_tag boolean uint16_t'Null uint16_t'Null
singleton AP_Mission method jump_to_landing_sequence boolean
singleton AP_Mission method jump_to_abort_landing_sequence boolean


userdata mavlink_mission_item_int_t depends AP_MISSION_ENABLED
userdata mavlink_mission_item_int_t field param1 float'skip_check read write
userdata mavlink_mission_item_int_t field param2 float'skip_check read write
userdata mavlink_mission_item_int_t field param3 float'skip_check read write
userdata mavlink_mission_item_int_t field param4 float'skip_check read write
userdata mavlink_mission_item_int_t field x int32_t'skip_check read write
userdata mavlink_mission_item_int_t field y int32_t'skip_check read write
userdata mavlink_mission_item_int_t field z float'skip_check read write
userdata mavlink_mission_item_int_t field seq uint16_t'skip_check read write
userdata mavlink_mission_item_int_t field command uint16_t'skip_check read write
-- userdata mavlink_mission_item_int_t field target_system uint8_t'skip_check read write
-- userdata mavlink_mission_item_int_t field target_component uint8_t'skip_check read write
userdata mavlink_mission_item_int_t field frame uint8_t'skip_check read write
userdata mavlink_mission_item_int_t field current uint8_t'skip_check read write
-- userdata mavlink_mission_item_int_t field autocontinue uint8_t'skip_check read write


include AP_RPM/AP_RPM.h
singleton AP_RPM rename RPM
singleton AP_RPM depends AP_RPM_ENABLED
singleton AP_RPM method get_rpm boolean uint8_t 0 RPM_MAX_INSTANCES float'Null

include AP_Button/AP_Button.h
singleton AP_Button depends HAL_BUTTON_ENABLED == 1
singleton AP_Button rename button
singleton AP_Button method get_button_state boolean uint8_t 1 AP_BUTTON_NUM_PINS

include AP_Notify/ScriptingLED.h depends AP_NOTIFY_SCRIPTING_LED_ENABLED
include AP_Notify/AP_Notify_config.h
singleton ScriptingLED depends AP_NOTIFY_SCRIPTING_LED_ENABLED
singleton ScriptingLED rename LED
singleton ScriptingLED method get_rgb void uint8_t'Ref uint8_t'Ref uint8_t'Ref

include ../ArduPlane/quadplane.h depends APM_BUILD_TYPE(APM_BUILD_ArduPlane)
singleton QuadPlane rename quadplane
singleton QuadPlane depends APM_BUILD_TYPE(APM_BUILD_ArduPlane) && HAL_QUADPLANE_ENABLED
singleton QuadPlane method in_vtol_mode boolean
singleton QuadPlane method in_assisted_flight boolean
singleton QuadPlane method abort_landing boolean
singleton QuadPlane method in_vtol_land_descent boolean

include ../ArduSub/Sub.h depends APM_BUILD_TYPE(APM_BUILD_ArduSub)
singleton Sub rename sub
singleton Sub depends APM_BUILD_TYPE(APM_BUILD_ArduSub)
singleton Sub method get_and_clear_button_count uint8_t uint8_t 1 4
singleton Sub method is_button_pressed boolean uint8_t 1 4
singleton Sub method rangefinder_alt_ok boolean
singleton Sub method rangefinder_alt_ok depends AP_RANGEFINDER_ENABLED
singleton Sub method get_rangefinder_target_cm float
singleton Sub method get_rangefinder_target_cm depends AP_RANGEFINDER_ENABLED
singleton Sub method set_rangefinder_target_cm boolean float'skip_check
singleton Sub method set_rangefinder_target_cm depends AP_RANGEFINDER_ENABLED

include AP_Motors/AP_MotorsMatrix.h depends APM_BUILD_TYPE(APM_BUILD_ArduPlane)||APM_BUILD_COPTER_OR_HELI
singleton AP_MotorsMatrix depends APM_BUILD_TYPE(APM_BUILD_ArduPlane)||APM_BUILD_COPTER_OR_HELI
singleton AP_MotorsMatrix rename MotorsMatrix
singleton AP_MotorsMatrix method init boolean uint8_t 0 AP_MOTORS_MAX_NUM_MOTORS
singleton AP_MotorsMatrix method add_motor_raw void int8_t 0 (AP_MOTORS_MAX_NUM_MOTORS-1) float'skip_check float'skip_check float'skip_check uint8_t 0 AP_MOTORS_MAX_NUM_MOTORS
singleton AP_MotorsMatrix method set_throttle_factor boolean int8_t 0 (AP_MOTORS_MAX_NUM_MOTORS-1) float 0 FLT_MAX
singleton AP_MotorsMatrix method get_lost_motor uint8_t
singleton AP_MotorsMatrix method get_thrust_boost boolean

include AP_Frsky_Telem/AP_Frsky_SPort.h
singleton AP_Frsky_SPort rename frsky_sport
singleton AP_Frsky_SPort depends AP_FRSKY_SPORT_TELEM_ENABLED
singleton AP_Frsky_SPort method sport_telemetry_push boolean uint8_t'skip_check uint8_t'skip_check uint16_t'skip_check int32_t'skip_check
singleton AP_Frsky_SPort method prep_number uint16_t int32_t'skip_check uint8_t'skip_check uint8_t'skip_check

include AC_AttitudeControl/AC_AttitudeControl_Multi_6DoF.h depends APM_BUILD_TYPE(APM_BUILD_ArduCopter)
singleton AC_AttitudeControl_Multi_6DoF depends APM_BUILD_TYPE(APM_BUILD_ArduCopter)
singleton AC_AttitudeControl_Multi_6DoF rename attitude_control
singleton AC_AttitudeControl_Multi_6DoF method set_lateral_enable void boolean
singleton AC_AttitudeControl_Multi_6DoF method set_forward_enable void boolean
singleton AC_AttitudeControl_Multi_6DoF method set_offset_roll_pitch void float'skip_check float'skip_check


include AP_Motors/AP_MotorsMatrix_6DoF_Scripting.h  depends APM_BUILD_TYPE(APM_BUILD_ArduCopter)
singleton AP_MotorsMatrix_6DoF_Scripting depends APM_BUILD_TYPE(APM_BUILD_ArduCopter)
singleton AP_MotorsMatrix_6DoF_Scripting rename Motors_6DoF
singleton AP_MotorsMatrix_6DoF_Scripting method init boolean uint8_t 0 AP_MOTORS_MAX_NUM_MOTORS
singleton AP_MotorsMatrix_6DoF_Scripting method add_motor void int8_t 0 (AP_MOTORS_MAX_NUM_MOTORS-1) float'skip_check float'skip_check float'skip_check float'skip_check float'skip_check float'skip_check boolean uint8_t 0 AP_MOTORS_MAX_NUM_MOTORS

include AP_HAL/I2CDevice.h
ap_object AP_HAL::I2CDevice semaphore-pointer
ap_object AP_HAL::I2CDevice method set_retries void uint8_t 0 20
ap_object AP_HAL::I2CDevice method write_register boolean uint8_t'skip_check uint8_t'skip_check
ap_object AP_HAL::I2CDevice manual read_registers AP_HAL__I2CDevice_read_registers 2 1
ap_object AP_HAL::I2CDevice manual transfer AP_HAL__I2CDevice_transfer 2 1
ap_object AP_HAL::I2CDevice method set_address void uint8_t'skip_check

include AP_HAL/utility/Socket.h depends (AP_NETWORKING_ENABLED==1)
global manual Socket lua_get_SocketAPM 1 1 depends (AP_NETWORKING_ENABLED==1)

ap_object SocketAPM depends (AP_NETWORKING_ENABLED==1)
ap_object SocketAPM method connect boolean string uint16_t'skip_check
ap_object SocketAPM method bind boolean string uint16_t'skip_check
ap_object SocketAPM method send int32_t string uint32_t'skip_check
ap_object SocketAPM method listen boolean uint8_t'skip_check
ap_object SocketAPM method set_blocking boolean boolean
ap_object SocketAPM method is_connected boolean
ap_object SocketAPM method pollout boolean uint32_t'skip_check
ap_object SocketAPM method pollin boolean uint32_t'skip_check
ap_object SocketAPM method reuseaddress boolean
ap_object SocketAPM manual sendfile SocketAPM_sendfile 1 1
ap_object SocketAPM manual close SocketAPM_close 0 0
ap_object SocketAPM manual recv SocketAPM_recv 1 1
ap_object SocketAPM manual accept SocketAPM_accept 0 1

ap_object AP_HAL::AnalogSource depends !defined(HAL_DISABLE_ADC_DRIVER)
ap_object AP_HAL::AnalogSource method set_pin boolean uint8_t'skip_check
ap_object AP_HAL::AnalogSource method voltage_average float
ap_object AP_HAL::AnalogSource method voltage_latest float
ap_object AP_HAL::AnalogSource method voltage_average_ratiometric float

global manual PWMSource lua_get_PWMSource 0 1

ap_object AP_HAL::PWMSource method set_pin boolean uint8_t'skip_check "Scripting"'literal
ap_object AP_HAL::PWMSource method get_pwm_us uint16_t
ap_object AP_HAL::PWMSource method get_pwm_avg_us uint16_t

singleton hal.gpio rename gpio
singleton hal.gpio literal
singleton hal.gpio method read boolean uint8_t'skip_check
singleton hal.gpio method write void uint8_t'skip_check uint8_t 0 1
singleton hal.gpio method toggle void uint8_t'skip_check
singleton hal.gpio method pinMode void uint8_t'skip_check uint8_t 0 1

singleton hal.analogin depends !defined(HAL_DISABLE_ADC_DRIVER)
singleton hal.analogin rename analog
singleton hal.analogin literal
singleton hal.analogin method channel AP_HAL::AnalogSource ANALOG_INPUT_NONE'literal
singleton hal.analogin method mcu_temperature float
singleton hal.analogin method mcu_temperature depends HAL_WITH_MCU_MONITORING

include AP_Motors/AP_MotorsMatrix_Scripting_Dynamic.h depends APM_BUILD_TYPE(APM_BUILD_ArduPlane)||APM_BUILD_COPTER_OR_HELI
singleton AP_MotorsMatrix_Scripting_Dynamic depends APM_BUILD_TYPE(APM_BUILD_ArduPlane)||APM_BUILD_COPTER_OR_HELI
singleton AP_MotorsMatrix_Scripting_Dynamic rename Motors_dynamic
singleton AP_MotorsMatrix_Scripting_Dynamic method init boolean uint8_t 0 AP_MOTORS_MAX_NUM_MOTORS
singleton AP_MotorsMatrix_Scripting_Dynamic method add_motor void uint8_t 0 (AP_MOTORS_MAX_NUM_MOTORS-1) uint8_t 0 AP_MOTORS_MAX_NUM_MOTORS
singleton AP_MotorsMatrix_Scripting_Dynamic method load_factors void AP_MotorsMatrix_Scripting_Dynamic::factor_table

userdata AP_MotorsMatrix_Scripting_Dynamic::factor_table depends APM_BUILD_TYPE(APM_BUILD_ArduPlane)||APM_BUILD_COPTER_OR_HELI
userdata AP_MotorsMatrix_Scripting_Dynamic::factor_table rename motor_factor_table
userdata AP_MotorsMatrix_Scripting_Dynamic::factor_table field roll'array AP_MOTORS_MAX_NUM_MOTORS float'skip_check read write
userdata AP_MotorsMatrix_Scripting_Dynamic::factor_table field pitch'array AP_MOTORS_MAX_NUM_MOTORS float'skip_check read write
userdata AP_MotorsMatrix_Scripting_Dynamic::factor_table field yaw'array AP_MOTORS_MAX_NUM_MOTORS float'skip_check read write
userdata AP_MotorsMatrix_Scripting_Dynamic::factor_table field throttle'array AP_MOTORS_MAX_NUM_MOTORS float'skip_check read write

include AP_InertialSensor/AP_InertialSensor.h
singleton AP_InertialSensor depends AP_INERTIALSENSOR_ENABLED
singleton AP_InertialSensor rename ins
singleton AP_InertialSensor method get_temperature float uint8_t 0 INS_MAX_INSTANCES
singleton AP_InertialSensor method get_gyro_health boolean uint8_t'skip_check
singleton AP_InertialSensor method accels_consistent boolean float'skip_check
singleton AP_InertialSensor method get_accel_health boolean uint8_t'skip_check
singleton AP_InertialSensor method calibrating boolean
singleton AP_InertialSensor method get_gyro Vector3f uint8_t'skip_check
singleton AP_InertialSensor method get_accel Vector3f uint8_t'skip_check
singleton AP_InertialSensor method gyros_consistent boolean uint8_t'skip_check

singleton CAN manual get_device lua_get_CAN_device 1 1
singleton CAN manual get_device2 lua_get_CAN_device2 1 1
singleton CAN depends AP_SCRIPTING_CAN_SENSOR_ENABLED

include AP_Scripting/AP_Scripting_CANSensor.h
include AP_HAL/AP_HAL.h

userdata AP_HAL::CANFrame depends AP_SCRIPTING_CAN_SENSOR_ENABLED
userdata AP_HAL::CANFrame rename CANFrame
userdata AP_HAL::CANFrame field id uint32_t'skip_check read write
userdata AP_HAL::CANFrame field data'array int(ARRAY_SIZE(ud->data)) uint8_t'skip_check read write
userdata AP_HAL::CANFrame field dlc uint8_t read write 0 int(ARRAY_SIZE(ud->data))
userdata AP_HAL::CANFrame method id_signed int32_t
userdata AP_HAL::CANFrame method isExtended boolean
userdata AP_HAL::CANFrame method isRemoteTransmissionRequest boolean
userdata AP_HAL::CANFrame method isErrorFrame boolean

ap_object ScriptingCANBuffer depends AP_SCRIPTING_CAN_SENSOR_ENABLED
ap_object ScriptingCANBuffer method write_frame boolean AP_HAL::CANFrame uint32_t'skip_check
ap_object ScriptingCANBuffer method read_frame boolean AP_HAL::CANFrame'Null
ap_object ScriptingCANBuffer method add_filter boolean uint32_t'skip_check uint32_t'skip_check

include ../Tools/AP_Periph/AP_Periph.h depends defined(HAL_BUILD_AP_PERIPH)
singleton AP_Periph_FW depends defined(HAL_BUILD_AP_PERIPH)
singleton AP_Periph_FW rename periph
singleton AP_Periph_FW method get_yaw_earth float
singleton AP_Periph_FW method get_vehicle_state uint32_t
singleton AP_Periph_FW method can_printf void "%s"'literal string
singleton AP_Periph_FW method reboot void boolean

include AP_Motors/AP_Motors_Class.h depends APM_BUILD_TYPE(APM_BUILD_ArduPlane)||APM_BUILD_COPTER_OR_HELI
singleton AP::motors() depends APM_BUILD_TYPE(APM_BUILD_ArduPlane)||APM_BUILD_COPTER_OR_HELI
singleton AP::motors() literal
singleton AP::motors() rename motors
singleton AP::motors() method set_frame_string void string
singleton AP::motors() method get_interlock boolean
singleton AP::motors() method get_desired_spool_state uint8_t
singleton AP::motors() method get_roll float
singleton AP::motors() method get_roll_ff float
singleton AP::motors() method get_pitch float
singleton AP::motors() method get_pitch_ff float
singleton AP::motors() method get_yaw float
singleton AP::motors() method get_yaw_ff float
singleton AP::motors() method get_throttle float
singleton AP::motors() method get_forward float
singleton AP::motors() method get_lateral float
singleton AP::motors() method get_spool_state uint8_t
singleton AP::motors() method set_external_limits void boolean boolean boolean boolean boolean

include AP_Common/AP_FWVersion.h
singleton AP::fwversion() literal
singleton AP::fwversion() reference
singleton AP::fwversion() rename FWVersion
singleton AP::fwversion() field fw_short_string string read
singleton AP::fwversion() field fw_short_string rename string
singleton AP::fwversion() field vehicle_type uint8_t read
singleton AP::fwversion() field vehicle_type rename type
singleton AP::fwversion() field major uint8_t read
singleton AP::fwversion() field minor uint8_t read
singleton AP::fwversion() field patch uint8_t read
singleton AP::fwversion() field fw_hash_str string read
singleton AP::fwversion() field fw_hash_str rename hash

include AP_Follow/AP_Follow.h
singleton AP_Follow depends AP_FOLLOW_ENABLED && (APM_BUILD_TYPE(APM_BUILD_ArduPlane)||APM_BUILD_COPTER_OR_HELI)
singleton AP_Follow rename follow
singleton AP_Follow method have_target boolean
singleton AP_Follow method get_last_update_ms uint32_t
singleton AP_Follow method get_target_location_and_velocity boolean Location'Null Vector3f'Null
singleton AP_Follow method get_target_location_and_velocity_ofs boolean Location'Null Vector3f'Null
singleton AP_Follow method get_target_heading_deg boolean float'Null

include AC_PrecLand/AC_PrecLand.h
singleton AC_PrecLand depends AC_PRECLAND_ENABLED && (APM_BUILD_TYPE(APM_BUILD_ArduPlane)||APM_BUILD_COPTER_OR_HELI)
singleton AC_PrecLand rename precland
singleton AC_PrecLand method healthy boolean
singleton AC_PrecLand method target_acquired boolean
singleton AC_PrecLand method get_last_valid_target_ms uint32_t
singleton AC_PrecLand method get_target_velocity boolean Vector2f'Null
singleton AC_PrecLand method get_target_location boolean Location'Null

include AC_AttitudeControl/AC_AttitudeControl.h depends APM_BUILD_TYPE(APM_BUILD_ArduPlane)||APM_BUILD_COPTER_OR_HELI
singleton AC_AttitudeControl depends APM_BUILD_TYPE(APM_BUILD_ArduPlane)||APM_BUILD_COPTER_OR_HELI
singleton AC_AttitudeControl method get_rpy_srate void float'Ref float'Ref float'Ref

include APM_Control/AR_AttitudeControl.h depends APM_BUILD_TYPE(APM_BUILD_Rover)
singleton AR_AttitudeControl depends APM_BUILD_TYPE(APM_BUILD_Rover)
singleton AR_AttitudeControl method get_srate void float'Ref float'Ref

include APM_Control/AR_PosControl.h depends APM_BUILD_TYPE(APM_BUILD_Rover)
singleton AR_PosControl depends APM_BUILD_TYPE(APM_BUILD_Rover)
singleton AR_PosControl method get_srate void float'Ref

include AP_Mount/AP_Mount.h
singleton AP_Mount depends HAL_MOUNT_ENABLED == 1
singleton AP_Mount rename mount
singleton AP_Mount method get_mode MAV_MOUNT_MODE'enum uint8_t'skip_check
singleton AP_Mount method set_mode void uint8_t'skip_check MAV_MOUNT_MODE'enum MAV_MOUNT_MODE_RETRACT MAV_MOUNT_MODE_HOME_LOCATION
singleton AP_Mount method set_angle_target void uint8_t'skip_check float'skip_check float'skip_check float'skip_check boolean
singleton AP_Mount method set_rate_target void uint8_t'skip_check float'skip_check float'skip_check float'skip_check boolean
singleton AP_Mount method set_roi_target void uint8_t'skip_check Location
singleton AP_Mount method get_attitude_euler boolean uint8_t'skip_check float'Null float'Null float'Null
singleton AP_Mount method get_rate_target boolean uint8_t'skip_check float'Null float'Null float'Null boolean'Null
singleton AP_Mount method get_angle_target boolean uint8_t'skip_check float'Null float'Null float'Null boolean'Null
singleton AP_Mount method get_location_target boolean uint8_t'skip_check Location'Null
singleton AP_Mount method set_attitude_euler void uint8_t'skip_check float'skip_check float'skip_check float'skip_check

include AP_Camera/AP_Camera.h
singleton AP_Camera depends AP_CAMERA_ENABLED && (AP_CAMERA_SCRIPTING_ENABLED == 1)
singleton AP_Camera rename camera
singleton AP_Camera semaphore
singleton AP_Camera method take_picture void uint8_t'skip_check
singleton AP_Camera method record_video boolean uint8_t'skip_check boolean
singleton AP_Camera method set_trigger_distance void uint8_t'skip_check float'skip_check
userdata AP_Camera::camera_state_t depends AP_CAMERA_ENABLED && (AP_CAMERA_SCRIPTING_ENABLED == 1)
userdata AP_Camera::camera_state_t field take_pic_incr uint16_t'skip_check read
userdata AP_Camera::camera_state_t field recording_video boolean read
userdata AP_Camera::camera_state_t field zoom_type uint8_t'skip_check read
userdata AP_Camera::camera_state_t field zoom_value float'skip_check read
userdata AP_Camera::camera_state_t field focus_type uint8_t'skip_check read
userdata AP_Camera::camera_state_t field focus_value float'skip_check read
userdata AP_Camera::camera_state_t field tracking_type uint8_t'skip_check read
userdata AP_Camera::camera_state_t field tracking_p1 Vector2f read
userdata AP_Camera::camera_state_t field tracking_p2 Vector2f read
singleton AP_Camera method get_state boolean uint8_t'skip_check AP_Camera::camera_state_t'Null

include AP_Winch/AP_Winch.h
singleton AP_Winch depends AP_WINCH_ENABLED && APM_BUILD_COPTER_OR_HELI
singleton AP_Winch rename winch
singleton AP_Winch method healthy boolean
singleton AP_Winch method relax void
singleton AP_Winch method release_length void float'skip_check
singleton AP_Winch method set_desired_rate void float'skip_check
singleton AP_Winch method get_rate_max float

include AP_IOMCU/AP_IOMCU.h
singleton AP_IOMCU depends HAL_WITH_IO_MCU
singleton AP_IOMCU rename iomcu
singleton AP_IOMCU method healthy boolean

include AP_Compass/AP_Compass.h
singleton Compass rename compass
singleton Compass depends AP_COMPASS_ENABLED
singleton Compass method healthy boolean uint8_t'skip_check

-- ----EFI Library----
include AP_EFI/AP_EFI.h depends HAL_EFI_ENABLED
include AP_EFI/AP_EFI_Scripting.h depends AP_EFI_SCRIPTING_ENABLED
include AP_EFI/AP_EFI_config.h

userdata Cylinder_Status depends (AP_EFI_SCRIPTING_ENABLED == 1)
userdata Cylinder_Status field ignition_timing_deg float'skip_check read write
userdata Cylinder_Status field injection_time_ms float'skip_check read write
userdata Cylinder_Status field cylinder_head_temperature float'skip_check read write
userdata Cylinder_Status field cylinder_head_temperature2 float'skip_check read write
userdata Cylinder_Status field exhaust_gas_temperature float'skip_check read write
userdata Cylinder_Status field exhaust_gas_temperature2 float'skip_check read write
userdata Cylinder_Status field lambda_coefficient float'skip_check read write

userdata EFI_State depends (AP_EFI_SCRIPTING_ENABLED == 1)
userdata EFI_State field last_updated_ms uint32_t'skip_check read write
userdata EFI_State field general_error boolean read write
userdata EFI_State field engine_load_percent uint8_t'skip_check read write
userdata EFI_State field engine_speed_rpm uint32_t'skip_check read write
userdata EFI_State field spark_dwell_time_ms float'skip_check read write
userdata EFI_State field atmospheric_pressure_kpa float'skip_check read write
userdata EFI_State field intake_manifold_pressure_kpa float'skip_check read write
userdata EFI_State field intake_manifold_temperature float'skip_check read write
userdata EFI_State field coolant_temperature float'skip_check read write
userdata EFI_State field oil_pressure float'skip_check read write
userdata EFI_State field oil_temperature float'skip_check read write
userdata EFI_State field fuel_pressure float'skip_check read write
userdata EFI_State field fuel_pressure_status Fuel_Pressure_Status'enum read write Fuel_Pressure_Status::NOT_SUPPORTED Fuel_Pressure_Status::ABOVE_NOMINAL
userdata EFI_State field fuel_consumption_rate_cm3pm float'skip_check read write
userdata EFI_State field estimated_consumed_fuel_volume_cm3 float'skip_check read write
userdata EFI_State field throttle_position_percent uint8_t'skip_check read write
userdata EFI_State field ecu_index uint8_t'skip_check read write
userdata EFI_State field cylinder_status Cylinder_Status read write
userdata EFI_State field ignition_voltage float'skip_check read write
userdata EFI_State field throttle_out float'skip_check read write
userdata EFI_State field pt_compensation float'skip_check read write

ap_object AP_EFI_Backend depends (AP_EFI_SCRIPTING_ENABLED == 1)
ap_object AP_EFI_Backend method handle_scripting boolean EFI_State

singleton AP_EFI depends (AP_EFI_SCRIPTING_ENABLED == 1)
singleton AP_EFI rename efi
singleton AP_EFI method get_backend AP_EFI_Backend uint8_t'skip_check
singleton AP_EFI method get_state void EFI_State'Ref
singleton AP_EFI method get_last_update_ms uint32_t 

-- ----END EFI Library----

include AP_Logger/AP_Logger.h
singleton AP_Logger depends HAL_LOGGING_ENABLED
singleton AP_Logger rename logger
singleton AP_Logger manual write AP_Logger_Write 6 0
singleton AP_Logger method log_file_content void string
singleton AP_Logger method log_file_content depends HAL_LOGGER_FILE_CONTENTS_ENABLED

singleton i2c manual get_device lua_get_i2c_device 4 1

global manual millis lua_millis 0 1
global manual micros lua_micros 0 1
global manual mission_receive lua_mission_receive 0 5 depends AP_MISSION_ENABLED

userdata uint32_t creation lua_new_uint32_t 1
userdata uint32_t operator_getter coerce_to_uint32_t
userdata uint32_t operator +
userdata uint32_t operator -
userdata uint32_t operator *
userdata uint32_t operator /
-- We know name of the generated function so we can point at it again with a manual operator so idiv is the same as div
userdata uint32_t manual_operator __idiv uint32_t___div
userdata uint32_t operator %
userdata uint32_t operator &
userdata uint32_t operator |
userdata uint32_t operator ^
userdata uint32_t operator <<
userdata uint32_t operator >>
userdata uint32_t operator ==
userdata uint32_t operator <
userdata uint32_t operator <=
userdata uint32_t operator ~
userdata uint32_t manual_operator __tostring uint32_t___tostring
userdata uint32_t manual toint uint32_t_toint 0 1
userdata uint32_t manual tofloat uint32_t_tofloat 0 1

userdata uint64_t creation lua_new_uint64_t 2
userdata uint64_t operator_getter coerce_to_uint64_t
userdata uint64_t operator +
userdata uint64_t operator -
userdata uint64_t operator *
userdata uint64_t operator /
userdata uint64_t operator %
userdata uint64_t operator &
userdata uint64_t operator |
userdata uint64_t operator ^
userdata uint64_t operator <<
userdata uint64_t operator >>
userdata uint64_t operator ==
userdata uint64_t operator <
userdata uint64_t operator <=
userdata uint64_t operator ~
userdata uint64_t manual_operator __tostring uint64_t___tostring
userdata uint64_t manual toint uint64_t_toint 0 1
userdata uint64_t manual tofloat uint64_t_tofloat 0 1
userdata uint64_t manual split uint64_t_split 0 2

global manual dirlist lua_dirlist 1 2
global manual remove lua_removefile 1 3
global manual print lua_print 1 0

singleton mavlink depends HAL_GCS_ENABLED
singleton mavlink manual init lua_mavlink_init 2 0
singleton mavlink manual register_rx_msgid lua_mavlink_register_rx_msgid 1 1
singleton mavlink manual send_chan lua_mavlink_send_chan 3 1
singleton mavlink manual receive_chan lua_mavlink_receive_chan 0 3
singleton mavlink manual block_command lua_mavlink_block_command 1 1

include AC_Fence/AC_Fence.h depends AP_FENCE_ENABLED
include AC_Fence/AC_Fence_config.h
singleton AC_Fence depends AP_FENCE_ENABLED
singleton AC_Fence rename fence
singleton AC_Fence method get_breaches uint8_t
singleton AC_Fence method get_breach_time uint32_t

include AP_Filesystem/AP_Filesystem.h depends AP_FILESYSTEM_FILE_READING_ENABLED
include AP_Filesystem/AP_Filesystem_config.h
userdata AP_Filesystem::stat_t depends AP_FILESYSTEM_FILE_READING_ENABLED
userdata AP_Filesystem::stat_t rename stat_t
userdata AP_Filesystem::stat_t field size uint32_t read
userdata AP_Filesystem::stat_t field mode int32_t read
userdata AP_Filesystem::stat_t field mtime uint32_t read
userdata AP_Filesystem::stat_t field atime uint32_t read
userdata AP_Filesystem::stat_t field ctime uint32_t read
userdata AP_Filesystem::stat_t method is_directory boolean

singleton AP_Filesystem rename fs
singleton AP_Filesystem method stat boolean string AP_Filesystem::stat_t'Null
singleton AP_Filesystem method format boolean
singleton AP_Filesystem method format depends AP_FILESYSTEM_FORMAT_ENABLED
singleton AP_Filesystem method get_format_status uint8_t'skip_check
singleton AP_Filesystem method get_format_status depends AP_FILESYSTEM_FORMAT_ENABLED
singleton AP_Filesystem method crc32 boolean string uint32_t'Null

include AP_RTC/AP_RTC.h depends AP_RTC_ENABLED
include AP_RTC/AP_RTC_config.h
singleton AP_RTC depends AP_RTC_ENABLED
singleton AP_RTC rename rtc
singleton AP_RTC method clock_s_to_date_fields boolean uint32_t'skip_check uint16_t'Null uint8_t'Null uint8_t'Null uint8_t'Null uint8_t'Null uint8_t'Null uint8_t'Null
singleton AP_RTC method date_fields_to_clock_s uint32_t uint16_t'skip_check int8_t'skip_check uint8_t'skip_check uint8_t'skip_check uint8_t'skip_check uint8_t'skip_check

include AP_Networking/AP_Networking.h depends AP_NETWORKING_ENABLED
include AP_Networking/AP_Networking_Config.h
singleton AP_Networking depends AP_NETWORKING_ENABLED
singleton AP_Networking rename networking
singleton AP_Networking method get_ip_active uint32_t
singleton AP_Networking method get_netmask_active uint32_t
singleton AP_Networking method get_gateway_active uint32_t
singleton AP_Networking method address_to_str string uint32_t'skip_check

include AP_VisualOdom/AP_VisualOdom.h
singleton AP_VisualOdom depends HAL_VISUALODOM_ENABLED
singleton AP_VisualOdom rename visual_odom
singleton AP_VisualOdom method healthy boolean
singleton AP_VisualOdom method quality int8_t
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            #include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <stdarg.h>
#include <assert.h>
#include <string.h>
#include <unistd.h>
#include <getopt.h>

char keyword_alias[]               = "alias";
char keyword_rename[]              = "rename";
char keyword_ap_object[]           = "ap_object";
char keyword_comment[]             = "--";
char keyword_depends[]             = "depends";
char keyword_enum[]                = "enum";
char keyword_field[]               = "field";
char keyword_include[]             = "include";
char keyword_method[]              = "method";
char keyword_operator[]            = "operator";
char keyword_read[]                = "read";
char keyword_scheduler_semaphore[] = "scheduler-semaphore";
char keyword_semaphore[]           = "semaphore";
char keyword_semaphore_pointer[]   = "semaphore-pointer";
char keyword_singleton[]           = "singleton";
char keyword_userdata[]            = "userdata";
char keyword_write[]               = "write";
char keyword_literal[]             = "literal";
char keyword_reference[]           = "reference";
char keyword_deprecate[]           = "deprecate";
char keyword_manual[]              = "manual";
char keyword_global[]              = "global";
char keyword_creation[]            = "creation";
char keyword_manual_operator[]     = "manual_operator";
char keyword_operator_getter[]     = "operator_getter";

// attributes (should include the leading ' )
char keyword_attr_enum[]    = "'enum";
char keyword_attr_literal[] = "'literal";
char keyword_attr_null[]    = "'Null";
char keyword_attr_reference[]  = "'Ref";
char keyword_attr_array[]      = "'array";
char keyword_attr_no_range_check[] = "'skip_check";

// type keywords
char keyword_boolean[]  = "boolean";
char keyword_float[]    = "float";
char keyword_int8_t[]   = "int8_t";
char keyword_int16_t[]  = "int16_t";
char keyword_int32_t[]  = "int32_t";
char keyword_string[]   = "string";
char keyword_uint8_t[]  = "uint8_t";
char keyword_uint16_t[] = "uint16_t";
char keyword_uint32_t[] = "uint32_t";
char keyword_void[]     = "void";

enum error_codes {
  ERROR_OUT_OF_MEMORY   = 1, // ran out of memory
  ERROR_HEADER          = 2, // header keyword not followed by a header to include
  ERROR_UNKNOWN_KEYWORD = 3, // a keyword we didn't know how to handle
  ERROR_USERDATA        = 4, // userdata
  ERROR_INTERNAL        = 5, // internal error of some form
  ERROR_GENERAL         = 6, // general error
  ERROR_SINGLETON       = 7, // singletons
  ERROR_DEPENDS         = 8, // dependencies
  ERROR_DOCS            = 9, // Documentation
  ERROR_GLOBALS         = 10,
};

struct header {
  struct header *next;
  char *name; // name of the header to include (not sanatized)
  int line; // line of the file declared on
  char *dependency;
};

struct generator_state {
  char line[1<<14];
  int line_num; // current line read in
  int token_num; // current token on the current line
  char *token;
};

FILE *description;
FILE *header;
FILE *source;
FILE *docs;

static struct generator_state state;
static struct header * headers;

enum trace_level {
  TRACE_TOKENS    = (1 << 0),
  TRACE_HEADER    = (1 << 1),
  TRACE_GENERAL   = (1 << 2),
  TRACE_USERDATA  = (1 << 3),
  TRACE_SINGLETON = (1 << 4),
  TRACE_DEPENDS   = (1 << 5),
};

enum access_flags {
  ACCESS_FLAG_READ  = (1 << 0),
  ACCESS_FLAG_WRITE = (1 << 1),
};

enum field_type {
  TYPE_BOOLEAN = 0,
  TYPE_FLOAT,
  TYPE_INT8_T,
  TYPE_INT16_T,
  TYPE_INT32_T,
  TYPE_UINT8_T,
  TYPE_UINT16_T,
  TYPE_UINT32_T,
  TYPE_NONE,
  TYPE_STRING,
  TYPE_ENUM,
  TYPE_LITERAL,
  TYPE_USERDATA,
  TYPE_AP_OBJECT
};

const char * type_labels[TYPE_USERDATA + 1] = { "bool",
                                                "float",
                                                "int8_t",
                                                "int16_t",
                                                "int32_t",
                                                "uint8_t",
                                                "uint16_t",
                                                "void",
                                                "string",
                                                "enum",
                                                "userdata",
                                                "ap_object",
                                              };

enum operator_type {
  OP_ADD  = (1U << 0),
  OP_SUB  = (1U << 1),
  OP_MUL  = (1U << 2),
  OP_DIV  = (1U << 3),
  OP_MOD  = (1U << 4),
  OP_BAND = (1U << 5),
  OP_BOR  = (1U << 6),
  OP_BXOR = (1U << 7),
  OP_SHL  = (1U << 8),
  OP_SHR  = (1U << 9),
  OP_EQ   = (1U << 10),
  OP_LT   = (1U << 11),
  OP_LE   = (1U << 12),
  OP_BNOT = (1U << 13),
  OP_MANUAL = (1U << 14),
  OP_LAST
};

enum access_type {
  ACCESS_VALUE = 0,
  ACCESS_REFERENCE,
};

struct range_check {
  // store the requested range check as a string
  // we will check that it's a numeric form of some type, but keep it as a string rather then a casted version
  char *low;
  char *high;
};

enum type_flags {
  TYPE_FLAGS_NULLABLE = (1U << 1),
  TYPE_FLAGS_ENUM     = (1U << 2),
  TYPE_FLAGS_REFERNCE = (1U << 3),
  TYPE_FLAGS_NO_RANGE_CHECK = (1U << 4),
};

struct type {
  struct range_check *range;
  enum field_type type;
  enum access_type access;
  uint32_t flags;
  union {
    struct ud {
      char *name;
      char *sanatized_name;
    } ud;
    char *enum_name;
    char *literal;
  } data;
};

int TRACE_LEVEL = 0;

void trace(const int trace, const char *message, ...) {
  if (trace & TRACE_LEVEL) {
    char * fmt = malloc(strlen(message)+1024);
    if (fmt == NULL) {
      exit(ERROR_OUT_OF_MEMORY);
    }
  
    sprintf(fmt, "TRACE: %s\n", message);
  
    va_list args;
    va_start(args, message);
    vfprintf(stderr, fmt, args);
    va_end(args);
    free(fmt);
    fmt = NULL;
  }
}

void error(const int code, const char *message, ...) __attribute__ ((noreturn));
void error(const int code, const char *message, ...) {
  char * fmt = malloc(strlen(message)+1024);
  if (fmt == NULL) {
    exit(ERROR_OUT_OF_MEMORY);
  }

  if (state.line_num >= 0) {
    sprintf(fmt, "Error (line %d): %s\n", state.line_num, message);
  } else {
    sprintf(fmt, "Error: %s\n", message);
  }

  va_list args;
  va_start(args, message);
  vfprintf(stderr, fmt, args);
  va_end(args);
  free(fmt);
  fmt = NULL;
  exit(code);
}

char *token_delimiters = " \n";

char * next_token(void) {
  state.token = strtok(NULL, token_delimiters);
  state.token_num++;
  trace(TRACE_TOKENS, "Token %d:%d %s", state.line_num, state.token_num, state.token);
  if ((state.token!= NULL) && (strcmp(state.token, keyword_comment) == 0)) {
    trace(TRACE_TOKENS, "Detected comment %d", state.line_num);
    state.token = NULL; // burn the line
  }
  return state.token;
}

char * start_line(void) {
  while (fgets(state.line, sizeof(state.line)/sizeof(state.line[0]), description) != NULL) {//state.line = readline(NULL))) {
      state.line_num++;
    
      const size_t length = strlen(state.line);
      if (length > 1 && state.line[length - 2] == '\r') {
        trace(TRACE_TOKENS, "Discarding carriage return");
        if (length == 2) { // empty line of just carriage return, loop again
          continue;
        }
        state.line[length - 2] = '\0';
      } else if (length > 0 && state.line[length - 1] == '\n') {
        trace(TRACE_TOKENS, "Discarding newline");
        if (length == 1) { // empty line of just carriage return, loop again
          continue;
        }
        state.line[length - 1] = '\0';
      }

      state.token = strtok(state.line, token_delimiters);
      state.token_num = 1;
      trace(TRACE_TOKENS, "Start of line token %d:%d %s", state.line_num, state.token_num, state.token);

      if (state.token != NULL) {
        break;
      }
  }

  return state.token;
}

// thin wrapper for malloc that exits if we can't allocate memory, and memsets the allocated chunk
void *allocate(const size_t size) {
  void *data = malloc(size);
  if (data == NULL) {
    error(ERROR_OUT_OF_MEMORY, "Out of memory.");
  } else {
    memset(data, 0, size);
  }
  return data;
}

// lazy helper that allocates a storage buffer and does strcpy for us
void string_copy(char **dest, const char * src) {
  *dest = (char *)allocate(strlen(src) + 1);
  strcpy(*dest, src);
}

void handle_header(void) {
  trace(TRACE_HEADER, "Parsing a header");

  // find the new header
  char * name = next_token();
  if (name == NULL) {
    error(ERROR_HEADER, "Header must be followed by the name of the header to include");
  }

  // search for duplicates
  struct header *node = headers;
  while (node != NULL && strcmp(node->name, name)) {
    node = node->next;
  }
  if (node != NULL) {
    error(ERROR_HEADER, "Header %s was already included on line %d", name, node->line);
  }

  // add to the list of headers
  node = (struct header *)allocate(sizeof(struct header));
  node->next = headers;
  node->line = state.line_num;
  node->name = (char *)allocate(strlen(name) + 1);
  strcpy(node->name, name);

  // add depedns
  char * key_word = next_token();
  char *depends = NULL;
  if (key_word != NULL) {
    if (strcmp(key_word, keyword_depends) == 0) {
        depends = strtok(NULL, "");
        if (depends == NULL) {
          error(ERROR_HEADER, "Expected a depends string for %s", name);
        }
        string_copy(&(node->dependency), depends);
    } else {
      error(ERROR_HEADER, "Received an unsupported keyword on a header: %s", key_word);
    }
  }

  headers = node;

  trace(TRACE_HEADER, "Added header %s", name);

  // ensure no more tokens on the line
  if (next_token()) {
    error(ERROR_HEADER, "Header contained an unexpected extra token: %s", state.token);
  }
}

enum userdata_type {
  UD_USERDATA,
  UD_SINGLETON,
  UD_AP_OBJECT,
  UD_GLOBAL,
};

struct argument {
  struct argument * next;
  struct type type;
  int line_num; // line read from
  int token_num; // token number on the line
};

struct method {
  struct method * next;
  char *name;
  char *sanatized_name;  // sanatized name of the C++ singleton
  char *rename; // (optional) used for scripting access
  char *deprecate; // (optional) issue deprecateion warning string on first call
  int line; // line declared on
  struct type return_type;
  struct argument * arguments;
  uint32_t flags; // filled out with TYPE_FLAGS
  char *dependency;
};

enum alias_type {
  ALIAS_TYPE_NONE,
  ALIAS_TYPE_MANUAL,
  ALIAS_TYPE_MANUAL_OPERATOR,
};

struct method_alias {
  struct method_alias *next;
  char *name;
  char *alias;
  int line;
  int num_args;
  int num_ret;
  enum alias_type type;
  char *dependency;
};

struct userdata_field {
  struct userdata_field * next;
  char * name;
  char * rename;
  struct type type; // field type, points to a string
  int line; // line declared on
  unsigned int access_flags;
  char * array_len; // literal array length
};

enum userdata_flags {
  UD_FLAG_SEMAPHORE         = (1U << 0),
  UD_FLAG_SCHEDULER_SEMAPHORE = (1U << 1),
  UD_FLAG_LITERAL = (1U << 2),
  UD_FLAG_SEMAPHORE_POINTER = (1U << 3),
  UD_FLAG_REFERENCE = (1U << 4),
};

struct userdata_enum {
  struct userdata_enum * next;
  char * name;     // enum name
};

struct userdata {
  struct userdata * next;
  char *name;  // name of the C++ singleton
  char *sanatized_name;  // sanatized name of the C++ singleton
  char *rename; // (optional) used for scripting access
  struct userdata_field *fields;
  struct method *methods;
  struct method_alias *method_aliases;
  struct userdata_enum *enums;
  enum userdata_type ud_type;
  uint32_t operations; // bitset of enum operation_types
  int flags; // flags from the userdata_flags enum
  char *dependency;
  char *creation; // name of a manual creation function if set, note that this will not be used internally
  int creation_args; // number of args for custom creation function
  char *operator_getter; // Custom function to get values for use in operators
};

static struct userdata *parsed_userdata;
static struct userdata *parsed_ap_objects;
static struct userdata *parsed_globals;

void sanitize_character(char **str, char character) {
  char *position = strchr(*str, character);
  while (position) {
    *position = '_';
    position = strchr(position, character);
  }
}

void sanatize_name(char **dest, char *src) {
  *dest = (char *)allocate(strlen(src) + 1);
  strcpy(*dest, src);

  sanitize_character(dest, ':');
  sanitize_character(dest, '.');
  sanitize_character(dest, '<');
  sanitize_character(dest, '>');
  sanitize_character(dest, '(');
  sanitize_character(dest, ')');
  sanitize_character(dest, '-');

};


struct range_check *parse_range_check(enum field_type type) {
  char * low = next_token();
  if (low == NULL) {
    error(ERROR_USERDATA, "Missing low value for a range check (type: %s)", type_labels[type]);
  }

  trace(TRACE_TOKENS, "Range check: Low: %s", low);

  char * high  = next_token();
  if (high == NULL) {
    error(ERROR_USERDATA, "Missing high value for a range check");
  }

  trace(TRACE_TOKENS, "Range check: High: %s", high);

  struct range_check *check = allocate(sizeof(struct range_check));

  string_copy(&(check->low), low);
  string_copy(&(check->high), high);

  return check;
}

// parses one or more access flags, leaves the token on the first non access token
// throws an error if no flags were found
unsigned int parse_access_flags(struct type * type) {
  unsigned int flags = 0;

  next_token();

  while(state.token != NULL) {
    trace(TRACE_TOKENS, "Possible access: %s", state.token);
    if (strcmp(state.token, keyword_read) == 0) {
      flags |= ACCESS_FLAG_READ;
    } else if (strcmp(state.token, keyword_write) == 0) {
      flags |= ACCESS_FLAG_WRITE;
      if ((type->flags & TYPE_FLAGS_NO_RANGE_CHECK) == 0) {
        switch (type->type) {
          case TYPE_FLOAT:
          case TYPE_INT8_T:
          case TYPE_INT16_T:
          case TYPE_INT32_T:
          case TYPE_UINT8_T:
          case TYPE_UINT16_T:
          case TYPE_UINT32_T:
          case TYPE_ENUM:
            type->range = parse_range_check(type->type);
            break;
          case TYPE_AP_OBJECT:
          case TYPE_USERDATA:
          case TYPE_BOOLEAN:
          case TYPE_STRING:
          case TYPE_LITERAL:
            // a range check is illogical
            break;
          case TYPE_NONE:
            error(ERROR_INTERNAL, "Can't access a NONE type");
        }
      }
    } else {
      error(ERROR_UNKNOWN_KEYWORD, "Unknown access provided: %s", state.token);
      break;
    }
    next_token();
  }

  trace(TRACE_TOKENS, "Parsed access flags: 0x%x", flags);

  if (flags == 0) {
    error(ERROR_USERDATA, "Expected to find an access specifier");
  }

  return flags;
}

#define TRUE  1
#define FALSE 0

enum type_restriction {
  TYPE_RESTRICTION_NONE         = 0,
  TYPE_RESTRICTION_OPTIONAL     = (1U << 1),
  TYPE_RESTRICTION_NOT_NULLABLE = (1U << 2),
};

enum range_check_type {
  RANGE_CHECK_NONE,
  RANGE_CHECK_MANDATORY,
};

int parse_type(struct type *type, const uint32_t restrictions, enum range_check_type range_type) {
  char *data_type = next_token();

  if (data_type == NULL) {
    if (restrictions & TYPE_RESTRICTION_OPTIONAL) {
      return FALSE;
    } else {
      error(ERROR_USERDATA, "Data type must be specified");
    }
  }

  if (data_type[0] == '&') {
    type->access = ACCESS_REFERENCE;
    data_type++; // drop the reference character
  } else {
    type->access = ACCESS_VALUE;
  }

  char *attribute = strchr(data_type, '\'');
  if (attribute != NULL) {
    if (strcmp(attribute, keyword_attr_enum) == 0) {
      type->flags |= TYPE_FLAGS_ENUM;
    } else if (strcmp(attribute, keyword_attr_literal) == 0) {
      type->type = TYPE_LITERAL;
    } else if (strcmp(attribute, keyword_attr_null) == 0) {
      if (restrictions & TYPE_RESTRICTION_NOT_NULLABLE) {
        error(ERROR_USERDATA, "%s is not nullable in this context", data_type);
      }
      type->flags |= TYPE_FLAGS_NULLABLE;
    } else if (strcmp(attribute, keyword_attr_reference) == 0) {
      type->flags |= TYPE_FLAGS_REFERNCE;
    } else if (strcmp(attribute, keyword_attr_no_range_check) == 0) {
      type->flags |= TYPE_FLAGS_NO_RANGE_CHECK;
    } else {
      error(ERROR_USERDATA, "Unknown attribute: %s", attribute);
    }
    attribute[0] = 0;
  }

  if ((type->access == ACCESS_REFERENCE) && ((type->flags & (TYPE_FLAGS_NULR);
    node->operations |= OP_MANUAL;

  } else if (strcmp(type, keyword_operator_getter) == 0) {
      if (node->operator_getter != NULL) {
        error(ERROR_USERDATA, "Userdata only support a single getter string");
      }
      char *name = next_token();
      if (name == NULL) {
        error(ERROR_USERDATA, "Expected a getter string for %s",node->name);
      }
      string_copy(&(node->operator_getter), name);

  } else {
    error(ERROR_USERDATA, "Unknown or unsupported type for userdata: %s", type);
  }

}

struct userdata *parsed_singletons = NULL;

void handle_singleton(void) {
  trace(TRACE_SINGLETON, "Adding a singleton");

  char *name = next_token();
  if (name == NULL) {
    error(ERROR_USERDATA, "Expected a name for the singleton");
  }

  struct userdata *node = parsed_singletons;
  while (node != NULL && strcmp(node->name, name)) {
    node = node->next;
  }

  if (node == NULL) {
    trace(TRACE_SINGLETON, "Allocating new singleton for %s", name);
    node = (struct userdata *)allocate(sizeof(struct userdata));
    node->ud_type = UD_SINGLETON;
    node->name = (char *)allocate(strlen(name) + 1);
    strcpy(node->name, name);
    sanatize_name(&(node->sanatized_name), node->name);
    node->next = parsed_singletons;
    parsed_singletons = node;
  }

  // read type
  char *type = next_token();
  if (type == NULL) {
    error(ERROR_SINGLETON, "Expected a access type for userdata %s", name);
  }

  if (strcmp(type, keyword_rename) == 0) {
    if (node->rename != NULL) {
      error(ERROR_SINGLETON, "rename of %s was already declared for %s", node->rename, node->name);
    }
    const char *rename = next_token();
    if (rename == NULL) {
      error(ERROR_SINGLETON, "Missing the name of the rename for %s", node->name);
    }
    node->rename = (char *)allocate(strlen(rename) + 1);
    strcpy(node->rename, rename);

  } else if (strcmp(type, keyword_semaphore) == 0) {
    node->flags |= UD_FLAG_SEMAPHORE;
  } else if (strcmp(type, keyword_scheduler_semaphore) == 0) {
    node->flags |= UD_FLAG_SCHEDULER_SEMAPHORE;
  } else if (strcmp(type, keyword_semaphore_pointer) == 0) {
    node->flags |= UD_FLAG_SCHEDULER_SEMAPHORE;
  } else if (strcmp(type, keyword_method) == 0) {
    handle_method(node);
  } else if (strcmp(type, keyword_enum) == 0) {
    handle_userdata_enum(node);
  } else if (strcmp(type, keyword_depends) == 0) {
    if (node->dependency != NULL) {
      error(ERROR_SINGLETON, "Singletons only support a single depends");
    }
    char *depends = strtok(NULL, "");
    if (depends == NULL) {
      error(ERROR_DEPENDS, "Expected a depends string for %s",node->name);
    }
    string_copy(&(node->dependency), depends);
  } else if (strcmp(type, keyword_literal) == 0) {
    node->flags |= UD_FLAG_LITERAL;
  } else if (strcmp(type, keyword_field) == 0) {
    handle_userdata_field(node);
  } else if (strcmp(type, keyword_reference) == 0) {
    node->flags |= UD_FLAG_REFERENCE;
  } else if (strcmp(type, keyword_manual) == 0) {
    handle_manual(node, ALIAS_TYPE_MANUAL);
  } else {
    error(ERROR_SINGLETON, "Singletons only support renames, methods, semaphore, depends, literal or manual keywords (got %s)", type);
  }

  // ensure no more tokens on the line
  if (next_token()) {
    error(ERROR_HEADER, "Singleton contained an unexpected extra token: %s", state.token);
  }
}

void handle_ap_object(void) {
  trace(TRACE_SINGLETON, "Adding a ap_object");

  char *name = next_token();
  if (name == NULL) {
    error(ERROR_USERDATA, "Expected a name for the ap_object");
  }

  struct userdata *node = parsed_ap_objects;
  while (node != NULL && strcmp(node->name, name)) {
    node = node->next;
  }

  if (node == NULL) {
    trace(TRACE_USERDATA, "Allocating new ap_object for %s", name);
    node = (struct userdata *)allocate(sizeof(struct userdata));
    node->ud_type = UD_AP_OBJECT;
    node->name = (char *)allocate(strlen(name) + 1);
    strcpy(node->name, name);
    sanatize_name(&(node->sanatized_name), node->name);
    node->next = parsed_ap_objects;
    parsed_ap_objects = node;
  }

  // read type
  char *type = next_token();
  if (type == NULL) {
    error(ERROR_SINGLETON, "Expected a access type for ap_object %s", name);
  }

  if (strcmp(type, keyword_rename) == 0) {
    if (node->rename != NULL) {
      error(ERROR_SINGLETON, "Rename of %s was already declared for %s", node->rename, node->name);
    }
    const char *rename = next_token();
    if (rename == NULL) {
      error(ERROR_SINGLETON, "Missing the name of the rename for %s", node->name);
    }
    node->rename = (char *)allocate(strlen(rename) + 1);
    strcpy(node->rename, rename);

  } else if (strcmp(type, keyword_semaphore) == 0) {
    node->flags |= UD_FLAG_SEMAPHORE;
  } else if (strcmp(type, keyword_scheduler_semaphore) == 0) {
    node->flags |= UD_FLAG_SCHEDULER_SEMAPHORE;
  } else if (strcmp(type, keyword_semaphore_pointer) == 0) {
    node->flags |= UD_FLAG_SEMAPHORE_POINTER;
  } else if (strcmp(type, keyword_method) == 0) {
    handle_method(node);
  } else if (strcmp(type, keyword_depends) == 0) {
      if (node->dependency != NULL) {
        error(ERROR_SINGLETON, "AP_Objects only support a single depends");
      }
      char *depends = strtok(NULL, "");
      if (depends == NULL) {
        error(ERROR_DEPENDS, "Expected a depends string for %s",node->name);
      }
      string_copy(&(node->dependency), depends);

  } else if (strcmp(type, keyword_manual) == 0) {
    handle_manual(node, ALIAS_TYPE_MANUAL);

  } else {
    error(ERROR_SINGLETON, "AP_Objects only support renames, methods, semaphore or manual keywords (got %s)", type);
  }

  // check that we didn't just add 2 singleton flags
  int semaphore = (node->flags & UD_FLAG_SEMAPHORE)?1:0;
  semaphore += (node->flags & UD_FLAG_SCHEDULER_SEMAPHORE)?1:0;
  semaphore += (node->flags & UD_FLAG_SEMAPHORE_POINTER)?1:0;
  if (semaphore > 1) {
    error(ERROR_SINGLETON, "Taking multiple types of semaphore is prohibited");
  }

  // ensure no more tokens on the line
  if (next_token()) {
    error(ERROR_HEADER, "Singleton contained an unexpected extra token: %s", state.token);
  }
}

void handle_global(void) {

  if (parsed_globals == NULL) {
    parsed_globals = (struct userdata *)allocate(sizeof(struct userdata));
    parsed_globals->ud_type = UD_GLOBAL;
  }

  // read type
  char *type = next_token();
  if (type == NULL) {
    error(ERROR_GLOBALS, "Expected a access type for global");
  }

  if (strcmp(type, keyword_manual) == 0) {
    handle_manual(parsed_globals, ALIAS_TYPE_MANUAL);
  } else {
    error(ERROR_GLOBALS, "globals only support manual keyword (got %s)", type);
  }

  // ensure no more tokens on the line
  if (next_token()) {
    error(ERROR_GLOBALS, "global contained an unexpected extra token: %s", state.token);
  }
}

void sanity_check_userdata(void) {
  struct userdata * node = parsed_userdata;
  while(node) {
    if ((node->fields == NULL) && (node->methods == NULL) && (node->method_aliases == NULL)) {
      error(ERROR_USERDATA, "Userdata %s has no fields or methods", node->name);
    }
    node = node->next;
  }
}

void start_dependency(FILE *f, const char *dependency) {
  if (dependency != NULL) {
    fprintf(f, "#if %s\n", dependency);
  }
}

void end_dependency(FILE *f, const char *dependency) {
  if (dependency != NULL) {
    fprintf(f, "#endif // %s\n", dependency);
  }
}

void emit_headers(FILE *f) {
  struct header *node = headers;
  while (node) {
    start_dependency(f, node->dependency);
    fprintf(f, "#include <%s>\n", node->name);
    end_dependency(f, node->dependency);
    node = node->next;
  }
}

void emit_userdata_allocators(void) {
  struct userdata * node = parsed_userdata;
  while (node) {
    start_dependency(source, node->dependency);
    // New method used internally
    fprintf(source, "%s * new_%s(lua_State *L) {\n", node->name, node->sanatized_name);
    fprintf(source, "    void *ud = lua_newuserdata(L, sizeof(%s));\n", node->name);
    fprintf(source, "    new (ud) %s();\n", node->name);
    fprintf(source, "    luaL_getmetatable(L, \"%s\");\n", node->rename ? node->rename :  node->name);
    fprintf(source, "    lua_setmetatable(L, -2);\n");
    fprintf(source, "    return (%s *)ud;\n", node->name);
    fprintf(source, "}\n");

    // New method used externally, includes argcheck, overridden by custom creation function if provided
    if (node->creation == NULL) {
      fprintf(source, "\n");
      fprintf(source, "int lua_new_%s(lua_State *L) {\n", node->sanatized_name);

      // emit one time warning if augments are parsed
      fprintf(source, "    static bool warned = false;\n");
      fprintf(source, "    if (!warned && userdata_zero_arg_check(L)) {\n");
      fprintf(source, "        warned = true;\n");
      fprintf(source, "    }\n");

      fprintf(source, "    new_%s(L);\n", node->sanatized_name);
      fprintf(source, "    return 1;\n");
      fprintf(source, "}\n");
    }

    end_dependency(source, node->dependency);
    fprintf(source, "\n");
    node = node->next;
  }
}

void emit_ap_object_allocators(void) {
  struct userdata * node = parsed_ap_objects;
  while (node) {
    start_dependency(source, node->dependency);
    fprintf(source, "%s ** new_%s(lua_State *L) {\n", node->name, node->sanatized_name);
    fprintf(source, "    return (%s **)new_ap_object(L, sizeof(%s *), \"%s\");\n", node->name, node->name, node->name);
    fprintf(source, "}\n");
    end_dependency(source, node->dependency);
    fprintf(source, "\n");
    node = node->next;
  }
}

void emit_userdata_checkers(void) {
  struct userdata * node = parsed_userdata;
  while (node) {
    start_dependency(source, node->dependency);
    fprintf(source, "%s * check_%s(lua_State *L, int arg) {\n", node->name, node->sanatized_name);
    fprintf(source, "    return (%s *)luaL_checkudata(L, arg, \"%s\");\n", node->name, node->rename ? node->rename :  node->name);
    fprintf(source, "}\n");
    end_dependency(source, node->dependency);
    fprintf(source, "\n");
    node = node->next;
  }
}

void emit_ap_object_checkers(void) {
  struct userdata * node = parsed_ap_objects;
  while (node) {
    start_dependency(source, node->dependency);
    fprintf(source, "%s ** check_%s(lua_State *L, int arg) {\n", node->name, node->sanatized_name);
    fprintf(source, "    return (%s **)check_ap_object(L, arg, \"%s\");\n", node->name, node->name);
    fprintf(source, "}\n");
    end_dependency(source, node->dependency);
    fprintf(source, "\n");
    node = node->next;
  }
}

void emit_singleton_checkers(void) {
  struct userdata * node = parsed_singletons;
  while (node) {
    if (!(node->flags & UD_FLAG_LITERAL) && (node->methods != NULL)) {
      start_dependency(source, node->dependency);
      fprintf(source, "%s * check_%s(lua_State *L) {\n", node->name, node->sanatized_name);
      fprintf(source, "    %s * ud = %s::get_singleton();\n", node->name, node->name);
      fprintf(source, "    if (ud == nullptr) {\n");
      fprintf(source, "        // This error will never return, so there is no danger of returning a nullptr\n");
      fprintf(source, "        not_supported_error(L, 1, \"%s\");\n", node->rename ? node->rename : node->name);
      fprintf(source, "    }\n");
      fprintf(source, "    return ud;\n");
      fprintf(source, "}\n");
      end_dependency(source, node->dependency);
      fprintf(source, "\n");
    }
    node = node->next;
  }
}

void emit_userdata_declarations(void) {
  struct userdata * node = parsed_userdata;
  while (node) {
    start_dependency(header, node->dependency);
    fprintf(header, "%s * new_%s(lua_State *L);\n", node->name, node->sanatized_name);
    if (node->creation == NULL) {
      fprintf(header, "int lua_new_%s(lua_State *L);\n", node->sanatized_name);
    }
    fprintf(header, "%s * check_%s(lua_State *L, int arg);\n", node->name, node->sanatized_name);
    end_dependency(header, node->dependency);
    node = node->next;
  }
}

void emit_ap_object_declarations(void) {
  struct userdata * node = parsed_ap_objects;
  while (node) {
    start_dependency(header, node->dependency);
    fprintf(header, "%s ** new_%s(lua_State *L);\n", node->name, node->sanatized_name);
    fprintf(header, "%s ** check_%s(lua_State *L, int arg);\n", node->name, node->sanatized_name);
    end_dependency(header, node->dependency);
    node = node->next;
  }
}

#define NULLABLE_ARG_COUNT_BASE 5000
void emit_checker(const struct type t, int arg_number, int skipped, const char *indentation) {
  assert(indentation != NULL);

  if (arg_number > NULLABLE_ARG_COUNT_BASE) {
    error(ERROR_INTERNAL, "Can't handle more then %d arguments to a function", NULLABLE_ARG_COUNT_BASE);
  }

  if (t.flags & (TYPE_FLAGS_NULLABLE | TYPE_FLAGS_REFERNCE)) {
    arg_number = arg_number + NULLABLE_ARG_COUNT_BASE;
    switch (t.type) {
      case TYPE_BOOLEAN:
        fprintf(source, "%sbool data_%d {};\n", indentation, arg_number);
        break;
      case TYPE_FLOAT:
        fprintf(source, "%sfloat data_%d {};\n", indentation, arg_number);
        break;
      case TYPE_INT8_T:
        fprintf(source, "%sint8_t data_%d {};\n", indentation, arg_number);
        break;
      case TYPE_INT16_T:
        fprintf(source, "%sint16_t data_%d {};\n", indentation, arg_number);
        break;
      case TYPE_INT32_T:
        fprintf(source, "%sint32_t data_%d {};\n", indentation, arg_number);
        break;
      case TYPE_UINT8_T:
        fprintf(source, "%suint8_t data_%d {};\n", indentation, arg_number);
        break;
      case TYPE_UINT16_T:
        fprintf(source, "%suint16_t data_%d {};\n", indentation, arg_number);
        break;
      case TYPE_UINT32_T:
        fprintf(source, "%suint32_t data_%d {};\n", indentation, arg_number);
        break;
      case TYPE_AP_OBJECT:
      case TYPE_NONE:
      case TYPE_LITERAL:
        return; // nothing to do here, this should potentially be checked outside of this, but it makes an easier implementation to accept it
      case TYPE_STRING:
        fprintf(source, "%schar * data_%d {};\n", indentation, arg_number);
        break;
      case TYPE_ENUM:
        fprintf(source, "%suint32_t data_%d {};\n", indentation, arg_number);
        break;
      case TYPE_USERDATA:
        fprintf(source, "%s%s data_%d {};\n", indentation, t.data.ud.name, arg_number);
        break;
    }
  } else {
    // handle this in four stages
    //   - figure out any relevant minimum values for range checking
    //   - emit a non down casted version
    //   - then run range checks
    //   - then cast down as appropriate

    // select minimums
    char * forced_min;
    char * forced_max;
    switch (t.type) {
      case TYPE_FLOAT:
        forced_min = "-INFINITY";
        forced_max = "INFINITY";
        break;
      case TYPE_INT8_T:
        forced_min = "INT8_MIN";
        forced_max = "INT8_MAX";
        break;
      case TYPE_INT16_T:
        forced_min = "INT16_MIN";
        forced_max = "INT16_MAX";
        break;
      case TYPE_INT32_T:
        forced_min = "INT32_MIN";
        forced_max = "INT32_MAX";
        break;
      case TYPE_UINT8_T:
        forced_min = "0";
        forced_max = "UINT8_MAX";
        break;
      case TYPE_UINT16_T:
        forced_min = "0";
        forced_max = "UINT16_MAX";
        break;
      case TYPE_UINT32_T:
        forced_min = "0U";
        forced_max = "UINT32_MAX";
        break;
      case TYPE_ENUM:
        forced_min = forced_max = NULL;
        break;
      case TYPE_NONE:
        return; // nothing to do here, this should potentially be checked outside of this, but it makes an easier implementation to accept it
      case TYPE_AP_OBJECT:
      case TYPE_STRING:
      case TYPE_BOOLEAN:
      case TYPE_USERDATA:
      case TYPE_LITERAL:
        // these don't get range checked, so skip the raw_data phase
        assert(t.range == NULL); // we should have caught this during the parse phase
        break;
    }

    // non down cast
    char * type_name;
    char * get_name;
    char * get_and_check_name;
    switch (t.type) {
      case TYPE_FLOAT:
        type_name = "float";
        get_name = "luaL_checknumber";
        get_and_check_name = "get_number";
        break;
      case TYPE_INT8_T:
        type_name = (t.range == NULL)?"int8_t":"lua_Integer";
        get_name = "get_int8_t";
        get_and_check_name = "get_integer";
        break;
      case TYPE_INT16_T:
        type_name = (t.range == NULL)?"int16_t":"lua_Integer";
        get_name = "get_int16_t";
        get_and_check_name = "get_integer";
        break;
      case TYPE_UINT8_T:
        type_name = (t.range == NULL)?"uint8_t":"lua_Integer";
        get_name = "get_uint8_t";
        get_and_check_name = "get_integer";
        break;
      case TYPE_UINT16_T:
        type_name = (t.range == NULL)?"uint16_t":"lua_Integer";
        get_name = "get_uint16_t";
        get_and_check_name = "get_integer";
        break;
      case TYPE_INT32_T:
      case TYPE_ENUM:
        type_name = "lua_Integer";
        get_name = "luaL_checkinteger";
        get_and_check_name = "get_integer";
        break;
      case TYPE_UINT32_T:
        type_name = "uint32_t";
        get_name = "coerce_to_uint32_t";
        get_and_check_name = "get_uint32";
        break;
      case TYPE_AP_OBJECT:
      case TYPE_NONE:
      case TYPE_STRING:
      case TYPE_BOOLEAN:
      case TYPE_USERDATA:
      case TYPE_LITERAL:
        // these don't get range checked, so skip the raw_data phase
        assert(t.range == NULL); // we should have caught this during the parse phase
        break;
    }


    switch (t.type) {
      case TYPE_FLOAT:
      case TYPE_INT8_T:
      case TYPE_INT16_T:
      case TYPE_INT32_T:
      case TYPE_UINT8_T:
      case TYPE_UINT16_T:
      case TYPE_ENUM:
      case TYPE_UINT32_T:
        if (t.range == NULL) {
            fprintf(source, "%sconst %s raw_data_%d = %s(L, %d);\n", indentation, type_name, arg_number, get_name, arg_number - skipped);
        } else {
          if ((forced_min != NULL) && (forced_max != NULL)) {
            fprintf(source, "%sconst %s raw_data_%d = %s(L, %d, MAX(%s, %s), MIN(%s, %s));\n", indentation, type_name, arg_number, get_and_check_name, arg_number - skipped, t.range->low, forced_min,  t.range->high, forced_max);
          } else {
            char * cast_target = "";

            switch (t.type) {
              case TYPE_FLOAT:
                cast_target = "float";
                break;
              case TYPE_INT8_T:
              case TYPE_INT16_T:
              case TYPE_INT32_T:
              case TYPE_UINT8_T:
              case TYPE_UINT16_T:
              case TYPE_ENUM:
                cast_target = "int32_t";
                break;
              case TYPE_UINT32_T:
                cast_target = "uint32_t";
                break;
              case TYPE_AP_OBJECT:
              case TYPE_NONE:
              case TYPE_STRING:
              case TYPE_BOOLEAN:
              case TYPE_USERDATA:
              case TYPE_LITERAL:
                assert(t.range == NULL); // we should have caught this during the parse phase
                break;
            }
            fprintf(source, "%sconst %s raw_data_%d = %s(L, %d, static_cast<%s>(%s), static_cast<%s>(%s));\n", indentation, type_name, arg_number, get_and_check_name, arg_number - skipped, cast_target, t.range->low, cast_target, t.range->high);

          }
        }

        break;
      case TYPE_AP_OBJECT:
      case TYPE_NONE:
      case TYPE_STRING:
      case TYPE_BOOLEAN:
      case TYPE_USERDATA:
      case TYPE_LITERAL:
        break;
    }

    // down cast
    switch (t.type) {
      case TYPE_FLOAT:
        // this is a trivial transformation, trust the compiler to resolve it for us
        fprintf(source, "%sconst float data_%d = raw_data_%d;\n", indentation, arg_number, arg_number);
        break;
      case TYPE_INT8_T:
        fprintf(source, "%sconst int8_t data_%d = static_cast<int8_t>(raw_data_%d);\n", indentation, arg_number, arg_number);
        break;
      case TYPE_INT16_T:
        fprintf(source, "%sconst int16_t data_%d = static_cast<int16_t>(raw_data_%d);\n", indentation, arg_number, arg_number);
        break;
      case TYPE_INT32_T:
        fprintf(source, "%sconst int32_t data_%d = raw_data_%d;\n", indentation, arg_number, arg_number);
        break;
      case TYPE_UINT8_T:
        fprintf(source, "%sconst uint8_t data_%d = static_cast<uint8_t>(raw_data_%d);\n",html {
	background-color: #F8F8F8 ;
}

body {
	background-color: #FFFFFF ;
	color: #000000 ;
	font-family: Helvetica, Arial, sans-serif ;
	text-align: justify ;
	line-height: 1.25 ;
	margin: 16px auto ;
	padding: 32px ;
	border: solid #ccc 1px ;
	border-radius: 20px ;
	max-width: 70em ;
	width: 90% ;
}

h1, h2, h3, h4 {
	color: #000080 ;
	font-family: Verdana, Geneva, sans-serif ;
	font-weight: normal ;
	font-style: normal ;
	text-align: left ;
}

h1 {
	font-size: 28pt ;
}

h1 img {
	vertical-align: text-bottom ;
}

h2:before {
	content: "\2756" ;
	padding-right: 0.5em ;
}

a {
	text-decoration: none ;
}

a:link {
	color: #000080 ;
}

a:link:hover, a:visited:hover {
	background-color: #D0D0FF ;
	color: #000080 ;
	border-radius: 4px ;
}

a:link:active, a:visited:active {
	color: #FF0000 ;
}

div.menubar {
	padding-bottom: 0.5em ;
}

p.menubar {
	margin-left: 2.5em ;
}

.menubar a:hover  {
	margin: -3px -3px -3px -3px ;
	padding: 3px  3px  3px  3px ;
	border-radius: 4px ;
}

:target {
	background-color: #F0F0F0 ;
	margin: -8px ;
	padding: 8px ;
	border-radius: 8px ;
	outline: none ;
}

hr {
	display: none ;
}

table hr {
	background-color: #a0a0a0 ;
	color: #a0a0a0 ;
	border: 0 ;
	height: 1px ;
	display: block ;
}

.footer {
	color: gray ;
	font-size: x-small ;
	text-transform: lowercase ;
}

input[type=text] {
	border: solid #a0a0a0 2px ;
	border-radius: 2em ;
	background-image: url('images/search.png') ;
	background-repeat: no-repeat ;
	background-position: 4px center ;
	padding-left: 20px ;
	height: 2em ;
}

pre.session {
	background-color: #F8F8F8 ;
	padding: 1em ;
	border-radius: 8px ;
}

table {
	border: none ;
	border-spacing: 0 ;
	border-collapse: collapse ;
}

td {
	padding: 0 ;
	margin: 0 ;
}

td.gutter {
	width: 4% ;
}

table.columns td {
	vertical-align: top ;
	padding-bottom: 1em ;
	text-align: justify ;
	line-height: 1.25 ;
}

table.book td {
	vertical-align: top ;
}

table.book td.cover {
	padding-right: 1em ;
}

table.book img {
	border: solid #000080 1px ;
}

table.book span {
	font-size: small ;
	text-align: left ;
	display: block ;
	margin-top: 0.25em ;
}

p.logos a:link:hover, p.logos a:visited:hover {
	background-color: inherit ;
}

img {
	background-color: white ;
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               .\" $Id: luac.man,v 1.29 2011/11/16 13:53:40 lhf Exp $
.TH LUAC 1 "$Date: 2011/11/16 13:53:40 $"
.SH NAME
luac \- Lua compiler
.SH SYNOPSIS
.B luac
[
.I options
] [
.I filenames
]
.SH DESCRIPTION
.B luac
is the Lua compiler.
It translates programs written in the Lua programming language
into binary files containing precompiled chunks
that can be later loaded and executed.
.LP
The main advantages of precompiling chunks are:
faster loading,
protecting source code from accidental user changes,
and
off-line syntax checking.
Precompiling does not imply faster execution
because in Lua chunks are always compiled into bytecodes before being executed.
.B luac
simply allows those bytecodes to be saved in a file for later execution.
Precompiled chunks are not necessarily smaller than the corresponding source.
The main goal in precompiling is faster loading.
.LP
In the command line,
you can mix
text files containing Lua source and
binary files containing precompiled chunks.
.B luac
produces a single output file containing the combined bytecodes
for all files given.
Executing the combined file is equivalent to executing the given files.
By default,
the output file is named
.BR luac.out ,
but you can change this with the
.B \-o
option.
.LP
Precompiled chunks are
.I not
portable across different architectures.
Moreover,
the internal format of precompiled chunks
is likely to change when a new version of Lua is released.
Make sure you save the source files of all Lua programs that you precompile.
.LP
.SH OPTIONS
.TP
.B \-l
produce a listing of the compiled bytecode for Lua's virtual machine.
Listing bytecodes is useful to learn about Lua's virtual machine.
If no files are given, then
.B luac
loads
.B luac.out
and lists its contents.
Use
.B \-l \-l
for a full listing.
.TP
.BI \-o " file"
output to
.IR file ,
instead of the default
.BR luac.out .
(You can use
.B "'\-'"
for standard output,
but not on platforms that open standard output in text mode.)
The output file may be one of the given files because
all files are loaded before the output file is written.
Be careful not to overwrite precious files.
.TP
.B \-p
load files but do not generate any output file.
Used mainly for syntax checking and for testing precompiled chunks:
corrupted files will probably generate errors when loaded.
If no files are given, then
.B luac
loads
.B luac.out
and tests its contents.
No messages are displayed if the file loads without errors.
.TP
.B \-s
strip debug information before writing the output file.
This saves some space in very large chunks,
but if errors occur when running a stripped chunk,
then the error messages may not contain the full information they usually do.
In particular,
line numbers and names of local variables are lost.
.TP
.B \-v
show version information.
.TP
.B \-\-
stop handling options.
.TP
.B \-
stop handling options and process standard input.
.SH "SEE ALSO"
.BR lua (1)
.br
The documentation at lua.org.
.SH DIAGNOSTICS
Error messages should be self explanatory.
.SH AUTHORS
R. Ierusalimschy,
L. H. de Figueiredo,
W. Celes
.\" EOF
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 h3 code {
	font-family: inherit ;
	font-size: inherit ;
}

pre, code {
	font-size: 12pt ;
}

span.apii {
	color: gray ;
	float: right ;
	font-family: inherit ;
	font-style: normal ;
	font-size: small ;
}

h2:before {
	content: "" ;
	padding-right: 0em ;
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
<TITLE>Lua 5.3 Reference Manual</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="lua.css">
<LINK REL="stylesheet" TYPE="text/css" HREF="manual.css">
<META HTTP-EQUIV="content-type" CONTENT="text/html; charset=iso-8859-1">
</HEAD>

<BODY>

<H1>
<A HREF="http://www.lua.org/"><IMG SRC="logo.gif" ALT="Lua"></A>
Lua 5.3 Reference Manual
</H1>

<P>
by Roberto Ierusalimschy, Luiz Henrique de Figueiredo, Waldemar Celes

<P>
<SMALL>
Copyright &copy; 2015&ndash;2018 Lua.org, PUC-Rio.
Freely available under the terms of the
<a href="http://www.lua.org/license.html">Lua license</a>.
</SMALL>

<DIV CLASS="menubar">
<A HREF="contents.html#contents">contents</A>
&middot;
<A HREF="contents.html#index">index</A>
&middot;
<A HREF="http://www.lua.org/manual/">other versions</A>
</DIV>

<!-- ====================================================================== -->
<p>

<!-- $Id: manual.of,v 1.167.1.2 2018/06/26 15:49:07 roberto Exp $ -->




<h1>1 &ndash; <a name="1">Introduction</a></h1>

<p>
Lua is a powerful, efficient, lightweight, embeddable scripting language.
It supports procedural programming,
object-oriented programming, functional programming,
data-driven programming, and data description.


<p>
Lua combines simple procedural syntax with powerful data description
constructs based on associative arrays and extensible semantics.
Lua is dynamically typed,
runs by interpreting bytecode with a register-based
virtual machine,
and has automatic memory management with
incremental garbage collection,
making it ideal for configuration, scripting,
and rapid prototyping.


<p>
Lua is implemented as a library, written in <em>clean C</em>,
the common subset of Standard&nbsp;C and C++.
The Lua distribution includes a host program called <code>lua</code>,
which uses the Lua library to offer a complete,
standalone Lua interpreter,
for interactive or batch use.
Lua is intended to be used both as a powerful, lightweight,
embeddable scripting language for any program that needs one,
and as a powerful but lightweight and efficient stand-alone language.


<p>
As an extension language, Lua has no notion of a "main" program:
it works <em>embedded</em> in a host client,
called the <em>embedding program</em> or simply the <em>host</em>.
(Frequently, this host is the stand-alone <code>lua</code> program.)
The host program can invoke functions to execute a piece of Lua code,
can write and read Lua variables,
and can register C&nbsp;functions to be called by Lua code.
Through the use of C&nbsp;functions, Lua can be augmented to cope with
a wide range of different domains,
thus creating customized programming languages sharing a syntactical framework.


<p>
Lua is free software,
and is provided as usual with no guarantees,
as stated in its license.
The implementation described in this manual is available
at Lua's official web site, <code>www.lua.org</code>.


<p>
Like any other reference manual,
this document is dry in places.
For a discussion of the decisions behind the design of Lua,
see the technical papers available at Lua's web site.
For a detailed introduction to programming in Lua,
see Roberto's book, <em>Programming in Lua</em>.



<h1>2 &ndash; <a name="2">Basic Concepts</a></h1>

<p>
This section describes the basic concepts of the language.



<h2>2.1 &ndash; <a name="2.1">Values and Types</a></h2>

<p>
Lua is a <em>dynamically typed language</em>.
This means that
variables do not have types; only values do.
There are no type definitions in the language.
All values carry their own type.


<p>
All values in Lua are <em>first-class values</em>.
This means that all values can be stored in variables,
passed as arguments to other functions, and returned as results.


<p>
There are eight basic types in Lua:
<em>nil</em>, <em>boolean</em>, <em>number</em>,
<em>string</em>, <em>function</em>, <em>userdata</em>,
<em>thread</em>, and <em>table</em>.
The type <em>nil</em> has one single value, <b>nil</b>,
whose main property is to be different from any other value;
it usually represents the absence of a useful value.
The type <em>boolean</em> has two values, <b>false</b> and <b>true</b>.
Both <b>nil</b> and <b>false</b> make a condition false;
any other value makes it true.
The type <em>number</em> represents both
integer numbers and real (floating-point) numbers.
The type <em>string</em> represents immutable sequences of bytes.

Lua is 8-bit clean:
strings can contain any 8-bit value,
including embedded zeros ('<code>\0</code>').
Lua is also encoding-agnostic;
it makes no assumptions about the contents of a string.


<p>
The type <em>number</em> uses two internal representations,
or two subtypes,
one called <em>integer</em> and the other called <em>float</em>.
Lua has explicit rules about when each representation is used,
but it also converts between them automatically as needed (see <a href="#3.4.3">&sect;3.4.3</a>).
Therefore,
the programmer may choose to mostly ignore the difference
between integers and floats
or to assume complete control over the representation of each number.
Standard Lua uses 64-bit integers and double-precision (64-bit) floats,
but you can also compile Lua so that it
uses 32-bit integers and/or single-precision (32-bit) floats.
The option with 32 bits for both integers and floats
is particularly attractive
for small machines and embedded systems.
(See macro <code>LUA_32BITS</code> in file <code>luaconf.h</code>.)


<p>
Lua can call (and manipulate) functions written in Lua and
functions written in C (see <a href="#3.4.10">&sect;3.4.10</a>).
Both are represented by the type <em>function</em>.


<p>
The type <em>userdata</em> is provided to allow arbitrary C&nbsp;data to
be stored in Lua variables.
A userdata value represents a block of raw memory.
There are two kinds of userdata:
<em>full userdata</em>,
which is an object with a block of memory managed by Lua,
and <em>light userdata</em>,
which is simply a C&nbsp;pointer value.
Userdata has no predefined operations in Lua,
except assignment and identity test.
By using <em>metatables</em>,
the programmer can define operations for full userdata values
(see <a href="#2.4">&sect;2.4</a>).
Userdata values cannot be created or modified in Lua,
only through the C&nbsp;API.
This guarantees the integrity of data owned by the host program.


<p>
The type <em>thread</em> represents independent threads of execution
and it is used to implement coroutines (see <a href="#2.6">&sect;2.6</a>).
Lua threads are not related to operating-system threads.
Lua supports coroutines on all systems,
even those that do not support threads natively.


<p>
The type <em>table</em> implements associative arrays,
that is, arrays that can have as indices not only numbers,
but any Lua value except <b>nil</b> and NaN.
(<em>Not a Number</em> is a special value used to represent
undefined or unrepresentable numerical results, such as <code>0/0</code>.)
Tables can be <em>heterogeneous</em>;
that is, they can contain values of all types (except <b>nil</b>).
Any key with value <b>nil</b> is not considered part of the table.
Conversely, any key that is not part of a table has
an associated value <b>nil</b>.


<p>
Tables are the sole data-structuring mechanism in Lua;
they can be used to represent ordinary arrays, lists,
symbol tables, sets, records, graphs, trees, etc.
To represent records, Lua uses the field name as an index.
The language supports this representation by
providing <code>a.name</code> as syntactic sugar for <code>a["name"]</code>.
There are several convenient ways to create tables in Lua
(see <a href="#3.4.9">&sect;3.4.9</a>).


<p>
Like indices,
the values of table fields can be of any type.
In particular,
because functions are first-class values,
table fields can contain functions.
Thus tables can also carry <em>methods</em> (see <a href="#3.4.11">&sect;3.4.11</a>).


<p>
The indexing of tables follows
the definition of raw equality in the language.
The expressions <code>a[i]</code> and <code>a[j]</code>
denote the same table element
if and only if <code>i</code> and <code>j</code> are raw equal
(that is, equal without metamethods).
In particular, floats with integral values
are equal to their respective integers
(e.g., <code>1.0 == 1</code>).
To avoid ambiguities,
any float with integral value used as a key
is converted to its respective integer.
For instance, if you write <code>a[2.0] = true</code>,
the actual key inserted into the table will be the
integer <code>2</code>.
(On the other hand,
2 and "<code>2</code>" are different Lua values and therefore
denote different table entries.)


<p>
Tables, functions, threads, and (full) userdata values are <em>objects</em>:
variables do not actually <em>contain</em> these values,
only <em>references</em> to them.
Assignment, parameter passing, and function returns
always manipulate references to such values;
these operations do not imply any kind of copy.


<p>
The library function <a href="#pdf-type"><code>type</code></a> returns a string describing the type
of a given value (see <a href="#6.1">&sect;6.1</a>).





<h2>2.2 &ndash; <a name="2.2">Environments and the Global Environment</a></h2>

<p>
As will be discussed in <a href="#3.2">&sect;3.2</a> and <a href="#3.3.3">&sect;3.3.3</a>,
any reference to a free name
(that is, a name not bound to any declaration) <code>var</code>
is syntactically translated to <code>_ENV.var</code>.
Moreover, every chunk is compiled in the scope of
an external local variable named <code>_ENV</code> (see <a href="#3.3.2">&sect;3.3.2</a>),
so <code>_ENV</code> itself is never a free name in a chunk.


<p>
Despite the existence of this external <code>_ENV</code> variable and
the translation of free names,
<code>_ENV</code> is a completely regular name.
In particular,
you can define new variables and parameters with that name.
Each reference to a free name uses the <code>_ENV</code> that is
visible at that point in the program,
following the usual visibility rules of Lua (see <a href="#3.5">&sect;3.5</a>).


<p>
Any table used as the value of <code>_ENV</code> is called an <em>environment</em>.


<p>
Lua keeps a distinguished environment called the <em>global environment</em>.
This value is kept at a special index in the C registry (see <a href="#4.5">&sect;4.5</a>).
In Lua, the global variable <a href="#pdf-_G"><code>_G</code></a> is initialized with this same value.
(<a href="#pdf-_G"><code>_G</code></a> is never used internally.)


<p>
When Lua loads a chunk,
the default value for its <code>_ENV</code> upvalue
is the global environment (see <a href="#pdf-load"><code>load</code></a>).
Therefore, by default,
free names in Lua code refer to entries in the global environment
(and, therefore, they are also called <em>global variables</em>).
Moreover, all standard libraries are loaded in the global environment
and some functions there operate on that environment.
You can use <a href="#pdf-load"><code>load</code></a> (or <a href="#pdf-loadfile"><code>loadfile</code></a>)
to load a chunk with a different environment.
(In C, you have to load the chunk and then change the value
of its first upvalue.)





<h2>2.3 &ndash; <a name="2.3">Error Handling</a></h2>

<p>
Because Lua is an embedded extension language,
all Lua actions start from C&nbsp;code in the host program
calling a function from the Lua library.
(When you use Lua standalone,
the <code>lua</code> application is the host program.)
Whenever an error occurs during
the compilation or execution of a Lua chunk,
control returns to the host,
which can take appropriate measures
(such as printing an error message).


<p>
Lua code can explicitly generate an error by calling the
<a href="#pdf-error"><code>error</code></a> function.
If you need to catch errors in Lua,
you can use <a href="#pdf-pcall"><code>pcall</code></a> or <a href="#pdf-xpcall"><code>xpcall</code></a>
to call a given function in <em>protected mode</em>.


<p>
Whenever there is an error,
an <em>error object</em> (also called an <em>error message</em>)
is propagated with information about the error.
Lua itself only generates errors whose error object is a string,
but programs may generate errors with
any value as the error object.
It is up to the Lua program or its host to handle such error objects.


<p>
When you use <a href="#pdf-xpcall"><code>xpcall</code></a> or <a href="#lua_pcall"><code>lua_pcall</code></a>,
you may give a <em>message handler</em>
to be called in case of errors.
This function is called with the original error object
and returns a new error object.
It is called before the error unwinds the stack,
so that it can gather more information about the error,
for instance by inspecting the stack and creating a stack traceback.
This message handler is still protected by the protected call;
so, an error inside the message handler
will call the message handler again.
If this loop goes on for too long,
Lua breaks it and returns an appropriate message.
(The message handler is called only for regular runtime errors.
It is not called for memory-allocation errors
nor for errors while running finalizers.)





<h2>2.4 &ndash; <a name="2.4">Metatables and Metamethods</a></h2>

<p>
Every value in Lua can have a <em>metatable</em>.
This <em>metatable</em> is an ordinary Lua table
that defines the behavior of the original value
under certain special operations.
You can change several aspects of the behavior
of operations over a value by setting specific fields in its metatable.
For instance, when a non-numeric value is the operand of an addition,
Lua checks for a function in the field "<code>__add</code>" of the value's metatable.
If it finds one,
Lua calls this function to perform the addition.


<p>
The key for each event in a metatable is a string
with the event name prefixed by two underscores;
the corresponding values are called <em>metamethods</em>.
In the previous example, the key is "<code>__add</code>"
and the metamethod is the function that performs the addition.
Unless stated otherwise,
metamethods should be function values.


<p>
You can query the metatable of any value
using the <a href="#pdf-getmetatable"><code>getmetatable</code></a> function.
Lua queries metamethods in metatables using a raw access (see <a href="#pdf-rawget"><code>rawget</code></a>).
So, to retrieve the metamethod for event <code>ev</code> in object <code>o</code>,
Lua does the equivalent to the following code:

<pre>
     rawget(getmetatable(<em>o</em>) or {}, "__<em>ev</em>")
</pre>

<p>
You can replace the metatable of tables
using the <a href="#pdf-setmetatable"><code>setmetatable</code></a> function.
You cannot change the metatable of other types from Lua code
(except by using the debug library (<a href="#6.10">&sect;6.10</a>));
you should use the C&nbsp;API for that.


<p>
Tables and full userdata have individual metatables
(although multiple tables and userdata can share their metatables).
Values of all other types share one single metatable per type;
that is, there is one single metatable for all numbers,
one for all strings, etc.
By default, a value has no metatable,
but the string library sets a metatable for the string type (see <a href="#6.4">&sect;6.4</a>).


<p>
A metatable controls how an object behaves in
arithmetic operations, bitwise operations,
order comparisons, concatenation, length operation, calls, and indexing.
A metatable also can define a function to be called
when a userdata or a table is garbage collected (<a href="#2.5">&sect;2.5</a>).


<p>
For the unary operators (negation, length, and bitwise NOT),
the metamethod is computed and called with a dummy second operand,
equal to the first one.
This extra operand is only to simplify Lua's internals
(by making these operators behave like a binary operation)
and may be removed in future versions.
(For most uses this extra operand is irrelevant.)


<p>
A detailed list of events controlled by metatables is given next.
Each operation is identified by its corresponding key.



<ul>

<li><b><code>__add</code>: </b>
the addition (<code>+</code>) operation.
If any operand for an addition is not a number
(nor a string coercible to a number),
Lua will try to call a metamethod.
First, Lua will check the first operand (even if it is valid).
If that operand does not define a metamethod for <code>__add</code>,
then Lua will check the second operand.
If Lua can find a metamethod,
it calls the metamethod with the two operands as arguments,
and the result of the call
(adjusted to one value)
is the result of the operation.
Otherwise,
it raises an error.
</li>

<li><b><code>__sub</code>: </b>
the subtraction (<code>-</code>) operation.
Behavior similar to the addition operation.
</li>

<li><b><code>__mul</code>: </b>
the multiplication (<code>*</code>) operation.
Behavior similar to the addition operation.
</li>

<li><b><code>__div</code>: </b>
the division (<code>/</code>) operation.
Behavior similar to the addition operation.
</li>

<li><b><code>__mod</code>: </b>
the modulo (<code>%</code>) operation.
Behavior similar to the addition operation.
</li>

<li><b><code>__pow</code>: </b>
the exponentiation (<code>^</code>) operation.
Behavior similar to the addition operation.
</li>

<li><b><code>__unm</code>: </b>
the negation (unary <code>-</code>) operation.
Behavior similar to the addition operation.
</li>

<li><b><code>__idiv</code>: </b>
the floor division (<code>//</code>) operation.
Behavior similar to the addition operation.
</li>

<li><b><code>__band</code>: </b>
the bitwise AND (<code>&amp;</code>) operation.
Behavior similar to the addition operation,
except that Lua will try a metamethod
if any operand is neither an integer
nor a value coercible to an integer (see <a href="#3.4.3">&sect;3.4.3</a>).
</li>

<li><b><code>__bor</code>: </b>
the bitwise OR (<code>|</code>) operation.
Behavior similar to the bitwise AND operation.
</li>

<li><b><code>__bxor</code>: </b>
the bitwise exclusive OR (binary <code>~</code>) operation.
Behavior similar to the bitwise AND operation.
</li>

<li><b><code>__bnot</code>: </b>
the bitwise NOT (unary <code>~</code>) operation.
Behavior similar to the bitwise AND operation.
</li>

<li><b><code>__shl</code>: </b>
the bitwise left shift (<code>&lt;&lt;</code>) operation.
Behavior similar to the bitwise AND operation.
</li>

<li><b><code>__shr</code>: </b>
the bitwise right shift (<code>&gt;&gt;</code>) operation.
Behavior similar to the bitwise AND operation.
</li>

<li><b><code>__concat</code>: </b>
the concatenation (<code>..</code>) operation.
Behavior similar to the addition operation,
except that Lua will try a metamethod
if any operand is neither a string nor a number
(which is always coercible to a string).
</li>

<li><b><code>__len</code>: </b>
the length (<code>#</code>) operation.
If the object is not a string,
Lua will try its metamethod.
If there is a metamethod,
Lua calls it with the object as argument,
and the result of the call
(always adjusted to one value)
is the result of the operation.
If there is no metamethod but the object is a table,
then Lua uses the table length operation (see <a href="#3.4.7">&sect;3.4.7</a>).
Otherwise, Lua raises an error.
</li>

<li><b><code>__eq</code>: </b>
the equal (<code>==</code>) operation.
Behavior similar to the addition operation,
except that Lua will try a metamethod only when the values
being compared are either both tables or both full userdata
and they are not primitively equal.
The result of the call is always converted to a boolean.
</li>

<li><b><code>__lt</code>: </b>
the less than (<code>&lt;</code>) operation.
Behavior similar to the addition operation,
except that Lua will try a metamethod only when the values
being compared are neither both numbers nor both strings.
The result of the call is always converted to a boolean.
</li>

<li><b><code>__le</code>: </b>
the less equal (<code>&lt;=</code>) operation.
Unlike other operations,
the less-equal operation can use two different events.
First, Lua looks for the <code>__le</code> metamethod in both operands,
like in the less than operation.
If it cannot find such a metamethod,
then it will try the <code>__lt</code> metamethod,
assuming that <code>a &lt;= b</code> is equivalent to <code>not (b &lt; a)</code>.
As with the other comparison operators,
the result is always a boolean.
(This use of the <code>__lt</code> event can be removed in future versions;
it is also slower than a real <code>__le</code> metamethod.)
</li>

<li><b><code>__index</code>: </b>
The indexing access operation <code>table[key]</code>.
This event happens when <code>table</code> is not a table or
when <code>key</code> is not present in <code>table</code>.
The metamethod is looked up in <code>table</code>.


<p>
Despite the name,
the metamethod for this event can be either a function or a table.
If it is a function,
it is called with <code>table</code> and <code>key</code> as arguments,
and the result of the call
(adjusted to one value)
is the result of the operation.
If it is a table,
the final result is the result of indexing this table with <code>key</code>.
(This indexing is regular, not raw,
and therefore can trigger another metamethod.)
</li>

<li><b><code>__newindex</code>: </b>
The indexing assignment <code>table[key] = value</code>.
Like the index event,
this event happens when <code>table</code> is not a table or
when <code>key</code> is not present in <code>table</code>.
The metamethod is looked up in <code>table</code>.


<p>
Like with indexing,
the metamethod for this event can be either a function or a table.
If it is a function,
it is called with <code>table</code>, <code>key</code>, and <code>value</code> as arguments.
If it is a table,
Lua does an indexing assignment to this table with the same key and value.
(This assignment is regular, not raw,
and therefore can trigger another metamethod.)


<p>
Whenever there is a <code>__newindex</code> metamethod,
Lua does not perform the primitive assignment.
(If necessary,
the metamethod itself can call <a href="#pdf-rawset"><code>rawset</code></a>
to do the assignment.)
</li>

<li><b><code>__call</code>: </b>
The call operation <code>func(args)</code>.
This event happens when Lua tries to call a non-function value
(that is, <code>func</code> is not a function).
The metamethod is looked up in <code>func</code>.
If present,
the metamethod is called with <code>func</code> as its first argument,
followed by the arguments of the original call (<code>args</code>).
All results of the call
are the result of the operation.
(This is the only metamethod that allows multiple results.)
</li>

</ul>

<p>
It is a good practice to add all needed metamethods to a table
before setting it as a metatable of some object.
In particular, the <code>__gc</code> metamethod works only when this order
is followed (see <a href="#2.5.1">&sect;2.5.1</a>).


<p>
Because metatables are regular tables,
they can contain arbitrary fields,
not only the event names defined above.
Some functions in the standard library
(e.g., <a href="#pdf-tostring"><code>tostring</code></a>)
use other fields in metatables for their own purposes.





<h2>2.5 &ndash; <a name="2.5">Garbage Collection</a></h2>

<p>
Lua performs automatic memory management.
This means that
you do not have to worry about allocating memory for new objects
or freeing it when the objects are no longer needed.
Lua manages memory automatically by running
a <em>garbage collector</em> to collect all <em>dead objects</em>
(that is, objects that are no longer accessible from Lua).
All memory used by Lua is subject to automatic management:
strings, tables, userdata, functions, threads, internal structures, etc.


<p>
Lua implements an incremental mark-and-sweep collector.
It uses two numbers to control its garbage-collection cycles:
the <em>garbage-collector pause</em> and
the <em>garbage-collector step multiplier</em>.
Both use percentage points as units
(e.g., a value of 100 means an internal value of 1).


<p>
The garbage-collector pause
controls how long the collector waits before starting a new cycle.
Larger values make the collector less aggressive.
Values smaller than 100 mean the collector will not wait to
start a new cycle.
A value of 200 means that the collector waits for the total memory in use
to double before starting a new cycle.


<p>
The garbage-collector step multiplier
controls the relative speed of the collector relative to
memory allocation.
Larger values make the collector more aggressive but also increase
the size of each incremental step.
You should not use values smaller than 100,
because they make the collector too slow and
can result in the collector never finishing a cycle.
The default is 200,
which means that the collector runs at "twice"
the speed of memory allocation.


<p>
If you set the step multiplier to a very large number
(larger than 10% of the maximum number of
bytes that the program may use),
the collector behaves like a stop-the-world collector.
If you then set the pause to 200,
the collector behaves as in old Lua versions,
doing a complete collection every time Lua doubles its
memory usage.


<p>
You can change these numbers by calling <a href="#lua_gc"><code>lua_gc</code></a> in C
or <a href="#pdf-collectgarbage"><code>collectgarbage</code></a> in Lua.
You can also use these functions to control
the collector directly (e.g., stop and restart it).



<h3>2.5.1 &ndash; <a name="2.5.1">Garbage-Collection Metamethods</a></h3>

<p>
You can set garbage-collector metamethods for tables
and, using the C&nbsp;API,
for full userdata (see <a href="#2.4">&sect;2.4</a>).
These metamethods are also called <em>finalizers</em>.
Finalizers allow you to coordinate Lua's garbage collection
with external resource management
(such as closing files, network or database connections,
or freeing your own memory).


<p>
For an object (table or userdata) to be finalized when collected,
you must <em>mark</em> it for finalization.

You mark an object for finalization when you set its metatable
and the metatable has a field indexed by the string "<code>__gc</code>".
Note that if you set a metatable without a <code>__gc</code> field
and later create that field in the metatable,
the object will not be marked for finalization.


<p>
When a marked object becomes garbage,
it is not collected immediately by the garbage collector.
Instead, Lua puts it in a list.
After the collection,
Lua goes through that list.
For each object in the list,
it checks the object's <code>__gc</code> metamethod:
If it is a function,
Lua calls it with the object as its single argument;
if the metamethod is not a function,
Lua simply ignores it.


<p>
At the end of each garbage-collection cycle,
the finalizers for objects are called in
the reverse order that the objects were marked for finalization,
among those collected in that cycle;
that is, the first finalizer to be called is the one associated
with the object marked last in the program.
The execution of each finalizer may occur at any point during
the execution of the regular code.


<p>
Because the object being collected must still be used by the finalizer,
that object (and other objects accessible only through it)
must be <em>resurrected</em> by Lua.
Usually, this resurrection is transient,
and the object memory is freed in the next garbage-collection cycle.
However, if the finalizer stores the object in some global place
(e.g., a global variable),
then the resurrection is permanent.
Moreover, if the finalizer marks a finalizing object for finalization again,
its finalizer will be called again in the next cycle where the
object is unreachable.
In any case,
the object memory is freed only in a GC cycle where
the object is unreachable and not marked for finalization.


<p>
When you close a state (see <a href="#lua_close"><code>lua_close</code></a>),
Lua calls the finalizers of all objects marked for finalization,
following the reverse order that they were marked.
If any finalizer marks objects for collection during that phase,
these marks have no effect.





<h3>2.5.2 &ndash; <a name="2.5.2">Weak Tables</a></h3>

<p>
A <em>weak table</em> is a table whose elements are
<em>weak references</em>.
A weak reference is ignored by the garbage collector.
In other words,
if the only references to an object are weak references,
then the garbage collector will collect that object.


<p>
A weak table can have weak keys, weak values, or both.
A table with weak values allows the collection of its values,
but prevents the collection of its keys.
A table with both weak keys and weak values allows the collection of
both keys and values.
In any case, if either the key or the value is collected,
the whole pair is removed from the table.
The weakness of a table is controlled by the
<code>__mode</code> field of its metatable.
If the <code>__mode</code> field is a string containing the character&nbsp;'<code>k</code>',
the keys in the table are weak.
If <code>__mode</code> contains '<code>v</code>',
the values in the table are weak.


<p>
A table with weak keys and strong values
is also called an <em>ephemeron table</em>.
In an ephemeron table,
a value is considered reachable only if its key is reachable.
In particular,
if the only reference to a key comes through its value,
the pair is removed.


<p>
Any change in the weakness of a table may take effect only
at the next collect cycle.
In particular, if you change the weakness to a stronger mode,
Lua may still collect some items from that table
before the change takes effect.


<p>
Only objects that have an explicit construction
are removed from weak tables.
Values, such as numbers and light C&nbsp;functions,
are not subject to garbage collection,
and therefore are not removed from weak tables
(unless their associated values are collected).
Although strings are subject to garbage collection,
they do not have an explicit construction,
and therefore are not removed from weak tables.


<p>
Resurrected objects
(that is, objects being finalized
and objects accessible only through objects being finalized)
have a special behavior in weak tables.
They are removed from weak values before running their finalizers,
but are removed from weak keys only in the next collection
after running their finalizers, when such objects are actually freed.
This behavior allows the finalizer to access properties
associated with the object through weak tables.


<p>
If a weak table is among the resurrected objects in a collection cycle,
it may not be properly cleared until the next cycle.







<h2>2.6 &ndash; <a name="2.6">Coroutines</a></h2>

<p>
Lua supports coroutines,
also called <em>collaborative multithreading</em>.
A coroutine in Lua represents an independent thread of execution.
Unlike threads in multithread systems, however,
a coroutine only suspends its execution by explicitly calling
a yield function.


<p>
You create a coroutine by calling <a href="#pdf-coroutine.create"><code>coroutine.create</code></a>.
Its sole argument is a function
that is the main function of the coroutine.
The <code>create</code> function only creates a new coroutine and
returns a handle to it (an object of type <em>thread</em>);
it does not start the coroutine.


<p>
You execute a coroutine by calling <a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a>.
When you first call <a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a>,
passing as its first argument
a thread returned by <a href="#pdf-coroutine.create"><code>coroutine.create</code></a>,
the coroutine starts its execution by
calling its main function.
Extra arguments passed to <a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a> are passed
as arguments to that function.
After the coroutine starts running,
it runs until it terminates or <em>yields</em>.


<p>
A coroutine can terminate its execution in two ways:
normally, when its main function returns
(explicitly or implicitly, after the last instruction);
and abnormally, if there is an unprotected error.
In case of normal termination,
<a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a> returns <b>true</b>,
plus any values returned by the coroutine main function.
In case of errors, <a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a> returns <b>false</b>
plus an error object.


<p>
A coroutine yields by calling <a href="#pdf-coroutine.yield"><code>coroutine.yield</code></a>.
When a coroutine yields,
the corresponding <a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a> returns immediately,
even if the yield happens inside nested function calls
(that is, not in the main function,
but in a function directly or indirectly called by the main function).
In the case of a yield, <a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a> also returns <b>true</b>,
plus any values passed to <a href="#pdf-coroutine.yield"><code>coroutine.yield</code></a>.
The next time you resume the same coroutine,
it continues its execution from the point where it yielded,
with the call to <a href="#pdf-coroutine.yield"><code>coroutine.yield</code></a> returning any extra
arguments passed to <a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a>.


<p>
Like <a href="#pdf-coroutine.create"><code>coroutine.create</code></a>,
the <a href="#pdf-coroutine.wrap"><code>coroutine.wrap</code></a> function also creates a coroutine,
but instead of returning the coroutine itself,
it returns a function that, when called, resumes the coroutine.
Any arguments passed to this function
go as extra arguments to <a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a>.
<a href="#pdf-coroutine.wrap"><code>coroutine.wrap</code></a> returns all the values returned by <a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a>,
except the first one (the boolean error code).
Unlike <a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a>,
<a href="#pdf-coroutine.wrap"><code>coroutine.wrap</code></a> does not catch errors;
any error is propagated to the caller.


<p>
As an example of how coroutines work,
consider the following code:

<pre>
     function foo (a)
       print("foo", a)
       return coroutine.yield(2*a)
     end
     
     co = coroutine.create(function (a,b)
           print("co-body", a, b)
           local r = foo(a+1)
           print("co-body", r)
           local r, s = coroutine.yield(a+b, a-b)
           print("co-body", r, s)
           return b, "end"
     end)
     
     print("main", coroutine.resume(co, 1, 10))
     print("main", coroutine.resume(co, "r"))
     print("main", coroutine.resume(co, "x", "y"))
     print("main", coroutine.resume(co, "x", "y"))
</pre><p>
When you run it, it produces the following output:

<pre>
     co-body 1       10
     foo     2
     main    true    4
     co-body r
     main    true    11      -9
     co-body x       y
     main    true    10      end
     main    false   cannot resume dead coroutine
</pre>

<p>
You can also create and manipulate coroutines through the C API:
see functions <a href="#lua_newthread"><code>lua_newthread</code></a>, <a href="#lua_resume"><code>lua_resume</code></a>,
and <a href="#lua_yield"><code>lua_yield</code></a>.





<h1>3 &ndash; <a name="3">The Language</a></h1>

<p>
This section describes the lexis, the syntax, and the semantics of Lua.
In other words,
this section describes
which tokens are valid,
how they can be combined,
and what their combinations mean.


<p>
Language constructs will be explained using the usual extended BNF notation,
in which
{<em>a</em>}&nbsp;means&nbsp;0 or more <em>a</em>'s, and
[<em>a</em>]&nbsp;means an optional <em>a</em>.
Non-terminals are shown like non-terminal,
keywords are shown like <b>kword</b>,
and other terminal symbols are shown like &lsquo;<b>=</b>&rsquo;.
The complete syntax of Lua can be found in <a href="#9">&sect;9</a>
at the end of this manual.



<h2>3.1 &ndash; <a name="3.1">Lexical Conventions</a></h2>

<p>
Lua is a free-form language.
It ignores spaces (including new lines) and comments
between lexical elements (tokens),
except as delimiters between names and keywords.


<p>
<em>Names</em>
(also called <em>identifiers</em>)
in Lua can be any string of letters,
digits, and underscores,
not beginning with a digit and
not being a reserved word.
Identifiers are used to name variables, table fields, and labels.


<p>
The following <em>keywords</em> are reserved
and cannot be used as names:


<pre>
     and       break     do        else      elseif    end
     false     for       function  goto      if        in
     local     nil       not       or        repeat    return
     then      true      until     while
</pre>

<p>
Lua is a case-sensitive language:
<code>and</code> is a reserved word, but <code>And</code> and <code>AND</code>
are two different, valid names.
As a convention,
programs should avoid creating
names that start with an underscore followed by
one or more uppercase letters (such as <a href="#pdf-_VERSION"><code>_VERSION</code></a>).


<p>
The following strings denote other tokens:

<pre>
     +     -     *     /     %     ^     #
     &amp;     ~     |     &lt;&lt;    &gt;&gt;    //
     ==    ~=    &lt;=    &gt;=    &lt;     &gt;     =
     (     )     {     }     [     ]     ::
     ;     :     ,     .     ..    ...
</pre>

<p>
A <em>short literal string</em>
can be delimited by matching single or double quotes,
and can contain the following C-like escape sequences:
'<code>\a</code>' (bell),
'<code>\b</code>' (backspace),
'<code>\f</code>' (form feed),
'<code>\n</code>' (newline),
'<code>\r</code>' (carriage return),
'<code>\t</code>' (horizontal tab),
'<code>\v</code>' (vertical tab),
'<code>\\</code>' (backslash),
'<code>\"</code>' (quotation mark [double quote]),
and '<code>\'</code>' (apostrophe [single quote]).
A backslash followed by a line break
results in a newline in the string.
The escape sequence '<code>\z</code>' skips the following span
of white-space characters,
including line breaks;
it is particularly useful to break and indent a long literal string
into multiple lines without adding the newlines and spaces
into the string contents.
A short literal string cannot contain unescaped line breaks
nor escapes not forming a valid escape sequence.


<p>
We can specify any byte in a short literal string by its numeric value
(including embedded zeros).
This can be done
with the escape sequence <code>\x<em>XX</em></code>,
where <em>XX</em> is a sequence of exactly two hexadecimal digits,
or with the escape sequence <code>\<em>ddd</em></code>,
where <em>ddd</em> is a sequence of up to three decimal digits.
(Note that if a decimal escape sequence is to be followed by a digit,
it must be expressed using exactly three digits.)


<p>
The UTF-8 encoding of a Unicode character
can be inserted in a literal string with
the escape sequence <code>\u{<em>XXX</em>}</code>
(note the mandatory enclosing brackets),
where <em>XXX</em> is a sequence of one or more hexadecimal digits
representing the character code point.


<p>
Literal strings can also be defined using a long format
enclosed by <em>long brackets</em>.
We define an <em>opening long bracket of level <em>n</em></em> as an opening
square bracket followed by <em>n</em> equal signs followed by another
opening square bracket.
So, an opening long bracket of level&nbsp;0 is written as <code>[[</code>, 
an opening long bracket of level&nbsp;1 is written as <code>[=[</code>, 
and so on.
A <em>closing long bracket</em> is defined similarly;
for instance,
a closing long bracket of level&nbsp;4 is written as  <code>]====]</code>.
A <em>long literal</em> starts with an opening long bracket of any level and
ends at the first closing long bracket of the same level.
It can contain any text except a closing bracket of the same level.
Literals in this bracketed form can run for several lines,
do not interpret any escape sequences,
and ignore long brackets of any other level.
Any kind of end-of-line sequence
(carriage return, newline, carriage return followed by newline,
or newline followed by carriage return)
is converted to a simple newline.


<p>
For convenience,
when the opening long bracket is immediately followed by a newline,
the newline is not included in the string.
As an example, in a system using ASCII
(in which '<code>a</code>' is coded as&nbsp;97,
newline is coded as&nbsp;10, and '<code>1</code>' is coded as&nbsp;49),
the five literal strings below denote the same string:

<pre>
     a = 'alo\n123"'
     a = "alo\n123\""
     a = '\97lo\10\04923"'
     a = [[alo
     123"]]
     a = [==[
     alo
     123"]==]
</pre>

<p>
Any byte in a literal string not
explicitly affected by the previous rules represents itself.
However, Lua opens files for parsing in text mode,
and the system file functions may have problems with
some control characters.
So, it is safer to represent
non-text data as a quoted literal with
explicit escape sequences for the non-text ch