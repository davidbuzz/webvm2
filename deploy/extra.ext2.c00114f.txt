/*
 * This file is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This file is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include <utility>
#include <AP_HAL/AP_HAL.h>
#include <AP_Math/AP_Math.h>

#include "AP_InertialSensor_BMI088.h"

/*
  device registers, names follow datasheet conventions, with REGA_
  prefix for accel, and REGG_ prefix for gyro
 */
#define REGA_CHIPID        0x00
#define REGA_ERR_REG       0x02
#define REGA_STATUS        0x03
#define REGA_X_LSB         0x12
#define REGA_INT_STATUS_1  0x1D
#define REGA_TEMP_MSB      0x22
#define REGA_TEMP_LSB      0x23
#define REGA_CONF          0x40
#define REGA_RANGE         0x41
#define REGA_PWR_CONF      0x7C
#define REGA_PWR_CTRL      0x7D
#define REGA_SOFTRESET     0x7E
#define REGA_FIFO_CONFIG0  0x48
#define REGA_FIFO_CONFIG1  0x49
#define REGA_FIFO_DOWNS    0x45
#define REGA_FIFO_DATA     0x26
#define REGA_FIFO_LEN0     0x24
#define REGA_FIFO_LEN1     0x25

#define REGG_CHIPID        0x00
#define REGA_RATE_X_LSB    0x02
#define REGG_INT_STATUS_1  0x0A
#define REGG_INT_STATUS_2  0x0B
#define REGG_INT_STATUS_3  0x0C
#define REGG_FIFO_STATUS   0x0E
#define REGG_RANGE         0x0F
#define REGG_BW            0x10
#define REGG_LPM1          0x11
#define REGG_RATE_HBW      0x13
#define REGG_BGW_SOFTRESET 0x14
#define REGG_FIFO_CONFIG_1 0x3E
#define REGG_FIFO_DATA     0x3F

#define ACCEL_BACKEND_SAMPLE_RATE   1600
#define GYRO_BACKEND_SAMPLE_RATE    2000

const uint32_t ACCEL_BACKEND_PERIOD_US = 1000000UL / ACCEL_BACKEND_SAMPLE_RATE;
const uint32_t GYRO_BACKEND_PERIOD_US = 1000000UL / GYRO_BACKEND_SAMPLE_RATE;

extern const AP_HAL::HAL& hal;

AP_InertialSensor_BMI088::AP_InertialSensor_BMI088(AP_InertialSensor &imu,
                                                   AP_HAL::OwnPtr<AP_HAL::Device> _dev_accel,
                                                   AP_HAL::OwnPtr<AP_HAL::Device> _dev_gyro,
                                                   enum Rotation _rotation)
    : AP_InertialSensor_Backend(imu)
    , dev_accel(std::move(_dev_accel))
    , dev_gyro(std::move(_dev_gyro))
    , rotation(_rotation)
{
}

AP_InertialSensor_Backend *
AP_InertialSensor_BMI088::probe(AP_InertialSensor &imu,
                                AP_HAL::OwnPtr<AP_HAL::Device> dev_accel,
                                AP_HAL::OwnPtr<AP_HAL::Device> dev_gyro,
                                enum Rotation rotation)
{
    if (!dev_accel || !dev_gyro) {
        return nullptr;
    }
    auto sensor = NEW_NOTHROW AP_InertialSensor_BMI088(imu, std::move(dev_accel), std::move(dev_gyro), rotation);

    if (!sensor) {
        return nullptr;
    }

    if (!sensor->init()) {
        delete sensor;
        return nullptr;
    }

    return sensor;
}

void AP_InertialSensor_BMI088::start()
{
    if (!_imu.register_accel(accel_instance, ACCEL_BACKEND_SAMPLE_RATE, dev_accel->get_bus_id_devtype(_accel_devtype)) ||
        !_imu.register_gyro(gyro_instance, GYRO_BACKEND_SAMPLE_RATE,   dev_gyro->get_bus_id_devtype(DEVTYPE_INS_BMI088))) {
        return;
    }

    // setup sensor rotations from probe()
    set_gyro_orientation(gyro_instance, rotation);
    set_accel_orientation(accel_instance, rotation);

    // setup callbacks
    accel_periodic_handle = dev_accel->register_periodic_callback(ACCEL_BACKEND_PERIOD_US,
                                                                  FUNCTOR_BIND_MEMBER(&AP_InertialSensor_BMI088::read_fifo_accel, void));
    gyro_periodic_handle = dev_gyro->register_periodic_callback(GYRO_BACKEND_PERIOD_US,
                                                                FUNCTOR_BIND_MEMBER(&AP_InertialSensor_BMI088::read_fifo_gyro, void));
}

/*
  read from accelerometer registers, special SPI handling needed
*/
bool AP_InertialSensor_BMI088::read_accel_registers(uint8_t reg, uint8_t *data, uint8_t len)
{
    // when on I2C we just read normally
    if (dev_accel->bus_type() != AP_HAL::Device::BUS_TYPE_SPI) {
        return dev_accel->read_registers(reg, data, len);
    }
    // for SPI we need to discard the first returned byte. See
    // datasheet for explanation
    uint8_t b[len+2];
    b[0] = reg | 0x80;
    memset(&b[1], 0, len+1);
    if (!dev_accel->transfer(b, len+2, b, len+2)) {
        return false;
    }
    memcpy(data, &b[2], len);
    return true;
}

/*
  write to accel registers with retries. The SPI sensor may take
  several tries to correctly write a register
*/
bool AP_InertialSensor_BMI088::write_accel_register(uint8_t reg, uint8_t v)
{
    for (uint8_t i=0; i<8; i++) {
        dev_accel->write_register(reg, v);
        uint8_t v2 = 0;
        if (read_accel_registers(reg, &v2, 1) && v2 == v) {
            return true;
        }
    }
    return false;
}

static const struct {
    uint8_t reg;
    uint8_t value;
} accel_config[] = {
    // OSR2 gives 234Hz LPF @ 1.6Khz ODR
    { REGA_CONF, 0x9C },
    // setup 24g range (16g for BMI085)
    { REGA_RANGE, 0x03 },
    // disable low-power mode
    { REGA_PWR_CONF, 0 },
    { REGA_PWR_CTRL, 0x04 },
    // setup FIFO for streaming X,Y,Z
    { REGA_FIFO_CONFIG0, 0x02 },
    { REGA_FIFO_CONFIG1, 0x50 },
};

bool AP_InertialSensor_BMI088::setup_accel_config(void)
{
    if (done_accel_config) {
        return true;
    }
    accel_config_count++;
    for (uint8_t i=0; i<ARRAY_SIZE(accel_config); i++) {
        uint8_t v;
        if (!read_accel_registers(accel_config[i].reg, &v, 1)) {
            return false;
        }
        if (v == accel_config[i].value) {
            continue;
        }
        if (!write_accel_register(accel_config[i].reg, accel_config[i].value)) {
            return false;
        }
    }
    done_accel_config = true;
    DEV_PRINTF("BMI088: accel config OK (%u tries)\n", (unsigned)accel_config_count);
    return true;
}

/*
  probe and initialise accelerometer
 */
bool AP_InertialSensor_BMI088::accel_init()
{
    WITH_SEMAPHORE(dev_accel->get_semaphore());

    uint8_t v;

    // dummy ready on accel ChipID to init accel (see section 3 of datasheet)
    read_accel_registers(REGA_CHIPID, &v, 1);

    if (!read_accel_registers(REGA_CHIPID, &v, 1)) {
        return false;
    }

    switch (v) {
        case 0x1E:
            _accel_devtype = DEVTYPE_INS_BMI088;
            accel_range = 24.0;
            hal.console->printf("BMI088: Found device\n");
            break;
        case 0x1F:
            _accel_devtype = DEVTYPE_INS_BMI085;
            accel_range = 16.0;
            hal.console->printf("BMI085: Found device\n");
            break;
        default:
            return false;
    }

    if (!setup_accel_config()) {
        DEV_PRINTF("BMI08x: delaying accel config\n");
    }

    DEV_PRINTF("BMI08x: found accel\n");

    return true;
}

/*
  probe and initialise gyro
 */
bool AP_InertialSensor_BMI088::gyro_init()
{
    WITH_SEMAPHORE(dev_gyro->get_semaphore());

    uint8_t v;
    if (!dev_gyro->read_registers(REGG_CHIPID, &v, 1) || v != 0x0F) {
        return false;
    }

    /* Soft-reset gyro
        Return value of 'write_register()' is not checked.
        This commands has the tendency to fail upon soft-reset.
    */
    dev_gyro->write_register(REGG_BGW_SOFTRESET, 0xB6);
    hal.scheduler->delay(30);

    dev_gyro->setup_checked_registers(5, 20);
    
    // setup 2000dps range
    if (!dev_gyro->write_register(REGG_RANGE, 0x00, true)) {
        return false;
    }

    // setup filter bandwidth 532Hz, no decimation
    if (!dev_gyro->write_register(REGG_BW, 0x80, true)) {
        return false;
    }

    // disable low-power mode
    if (!dev_gyro->write_register(REGG_LPM1, 0, true)) {
        return false;
    }

    // setup for filtered data
    if (!dev_gyro->write_register(REGG_RATE_HBW, 0x00, true)) {
        return false;
    }

    // setup FIFO for streaming X,Y,Z, with stop-at-full
    if (!dev_gyro->write_register(REGG_FIFO_CONFIG_1, 0x40, true)) {
        return false;
    }

    DEV_PRINTF("BMI088: found gyro\n");    

    return true;
}

bool AP_InertialSensor_BMI088::init()
{
    dev_accel->set_read_flag(0x80);
    dev_gyro->set_read_flag(0x80);

    return accel_init() && gyro_init();
}

/*
  read accel fifo
 */
void AP_InertialSensor_BMI088::read_fifo_accel(void)
{
    if (!setup_accel_config()) {
        return;
    }
    uint8_t len[2];
    if (!read_accel_registers(REGA_FIFO_LEN0, len, 2)) {
        _inc_accel_error_count(accel_instance);
        return;
    }
    uint16_t fifo_length = len[0] + (len[1]<<8);
    if (fifo_length & 0x8000) {
        // empty
        return;
    }

    // don't read more than 8 frames at a time
    if (fifo_length > 8*7) {
        fifo_length = 8*7;
    }
    if (fifo_length == 0) {
        return;
    }
    
    // adjust the periodic callback to be synchronous with the incoming data
    // this means that we rarely run read_fifo_accel() without updating the sensor data
    dev_accel->adjust_periodic_callback(accel_periodic_handle, ACCEL_BACKEND_PERIOD_US);

    uint8_t data[fifo_length];
    if (!read_accel_registers(REGA_FIFO_DATA, data, fifo_length)) {
        _inc_accel_error_count(accel_instance);
        return;
    }

    // use new accel_range depending on sensor type
    const float scale = (1.0/32768.0) * GRAVITY_MSS * accel_range;
    const uint8_t *p = &data[0];
    while (fifo_length >= 7) {
        /*
          the fifo frames are variable length, with the frame type in the first byte
         */
        uint8_t frame_len = 2;
        switch (p[0] & 0xFC) {
        case 0x84: {
            // accel frame
            frame_len = 7;
            const uint8_t *d = p+1;
            int16_t xyz[3] {
                int16_t(uint16_t(d[0] | (d[1]<<8))),
                int16_t(uint16_t(d[2] | (d[3]<<8))),
                int16_t(uint16_t(d[4] | (d[5]<<8)))};
            Vector3f accel(xyz[0], xyz[1], xyz[2]);

            accel *= scale;

            _rotate_and_correct_accel(accel_instance, accel);
            _notify_new_accel_raw_sample(accel_instance, accel);
            break;
        }
        case 0x40:
            // skip frame
            frame_len = 2;
            break;
        case 0x44:
            // sensortime frame
            frame_len = 4;
            break;
        case 0x48:
            // fifo config frame
            frame_len = 2;
            break;
        case 0x50:
            // sample drop frame
            frame_len = 2;
            break;
        }
        p += frame_len;
        fifo_length -= frame_len;
    }

    if (temperature_counter++ == 100) {
        temperature_counter = 0;
        uint8_t tbuf[2];
        if (!read_accel_registers(REGA_TEMP_MSB, tbuf, 2)) {
            _inc_accel_error_count(accel_instance);
        } else {
            uint16_t temp_uint11 = (tbuf[0]<<3) | (tbuf[1]>>5);
            int16_t temp_int11 = temp_uint11>1023?temp_uint11-2048:temp_uint11;
            float temp_degc = temp_int11 * 0.125f + 23;
            _publish_temperature(accel_instance, temp_degc);
        }
    }
}

/*
  read gyro fifo
 */
void AP_InertialSensor_BMI088::read_fifo_gyro(void)
{
    uint8_t num_frames;
    if (!dev_gyro->read_registers(REGG_FIFO_STATUS, &num_frames, 1)) {
        _inc_gyro_error_count(gyro_instance);
        return;
    }
    const float scale = radians(2000.0f) / 32767.0f;
    const uint8_t max_frames = 8;
    const Vector3i bad_frame{INT16_MIN,INT16_MIN,INT16_MIN};
    Vector3i data[max_frames];

    if (num_frames & 0x80) {
        // fifo overrun, reset, likely caused by scheduling error
        dev_gyro->write_register(REGG_FIFO_CONFIG_1, 0x40, true);
        goto check_next;
    }

    num_frames &= 0x7F;
    
    // don't read more than 8 frames at a time
    num_frames = MIN(num_frames, max_frames);
    if (num_frames == 0) {
        goto check_next;
    }

    // adjust the periodic callback to be synchronous with the incoming data
    // this means that we rarely run read_fifo_gyro() without updating the sensor data
    dev_gyro->adjust_periodic_callback(gyro_periodic_handle, GYRO_BACKEND_PERIOD_US);

    if (!dev_gyro->read_registers(REGG_FIFO_DATA, (uint8_t *)data, num_frames*6)) {
        _inc_gyro_error_count(gyro_instance);
        goto check_next;
    }

    // data is 16 bits with 2000dps range
    for (uint8_t i = 0; i < num_frames; i++) {
        if (data[i] == bad_frame) {
            continue;
        }
        Vector3f gyro(data[i].x, data[i].y, data[i].z);
        gyro *= scale;

        _rotate_and_correct_gyro(gyro_instance, gyro);
        _notify_new_gyro_raw_sample(gyro_instance, gyro);
    }

check_next:
    AP_HAL::Device::checkreg reg;
    if (!dev_gyro->check_next_register(reg)) {
        log_register_change(dev_gyro->get_bus_id(), reg);
        _inc_gyro_error_count(gyro_instance);
    }
}

bool AP_InertialSensor_BMI088::update()
{
    update_accel(accel_instance);
    update_gyro(gyro_instance);
    return true;
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 /*
 * This file is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This file is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
/*
  the BMI088 is unusual as it has separate chip-select for accel and
  gyro, which means it needs two Device pointers
 */
#pragma once

#include <AP_HAL/AP_HAL.h>

#include "AP_InertialSensor.h"
#include "AP_InertialSensor_Backend.h"

class AP_InertialSensor_BMI088 : public AP_InertialSensor_Backend {
public:
    static AP_InertialSensor_Backend *probe(AP_InertialSensor &imu,
                                            AP_HAL::OwnPtr<AP_HAL::Device> dev_accel,
                                            AP_HAL::OwnPtr<AP_HAL::Device> dev_gyro,
                                            enum Rotation rotation);

    /**
     * Configure the sensors and start reading routine.
     */
    void start() override;
    bool update() override;

private:
    AP_InertialSensor_BMI088(AP_InertialSensor &imu,
                             AP_HAL::OwnPtr<AP_HAL::Device> dev_accel,
                             AP_HAL::OwnPtr<AP_HAL::Device> dev_gyro,
                             enum Rotation rotation);

    /*
     initialise hardware layer
     */
    bool accel_init();
    bool gyro_init();

    /*
      initialise driver
     */
    bool init();

    /*
      read data from the FIFOs
     */
    void read_fifo_accel();
    void read_fifo_gyro();

    /*
      read from accelerometer registers, special SPI handling needed
     */
    bool read_accel_registers(uint8_t reg, uint8_t *data, uint8_t len);

    /*
      write to an accelerometer register with retries
     */
    bool write_accel_register(uint8_t reg, uint8_t v);

    /*
      configure accel registers
     */
    bool setup_accel_config(void);

    AP_HAL::OwnPtr<AP_HAL::Device> dev_accel;
    AP_HAL::Device::PeriodicHandle accel_periodic_handle;
    AP_HAL::OwnPtr<AP_HAL::Device> dev_gyro;
    AP_HAL::Device::PeriodicHandle gyro_periodic_handle;

    enum Rotation rotation;
    uint8_t temperature_counter;
    enum DevTypes _accel_devtype;
    float accel_range;

    bool done_accel_config;
    uint32_t accel_config_count;
};
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           /*
 * Copyright (C) 2016  Intel Corporation. All rights reserved.
 *
 * This file is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This file is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
#include <utility>

#include <AP_HAL/AP_HAL.h>

#include <AP_HAL/utility/sparse-endian.h>
#include <AP_HAL_Linux/GPIO.h>
#include <AP_Math/AP_Math.h>

#include "AP_InertialSensor_BMI160.h"

/* Registers and bits definitions. The indented ones are the bits for the upper
 * register. */
#define BMI160_REG_CHIPID 0x00
#define     BMI160_CHIPID 0xD1
#define BMI160_REG_ERR_REG 0x02
#define BMI160_REG_FIFO_LENGTH 0x22
#define BMI160_REG_FIFO_DATA 0x24
#define BMI160_REG_ACC_CONF 0x40
#define BMI160_REG_ACC_RANGE 0x41
            /* For convenience, use log2(range) - 1 instead of bits defined in
             * the datasheet. See _configure_accel(). */
#define     BMI160_ACC_RANGE_16G 3
#define BMI160_REG_GYR_CONF 0x42
#define BMI160_REG_GYR_RANGE 0x43
#define     BMI160_GYR_RANGE_2000DPS 0x00
#define BMI160_REG_FIFO_CONFIG_0 0x46
#define BMI160_REG_FIFO_CONFIG_1 0x47
#define     BMI160_FIFO_ACC_EN 0x40
#define     BMI160_FIFO_GYR_EN 0x80
#define BMI160_REG_INT_EN_1 0x51
#define     BMI160_INT_FWM_EN 0x40
#define BMI160_REG_INT_OUT_CTRL 0x53
#define     BMI160_INT1_LVL 0x02
#define     BMI160_INT1_OUTPUT_EN 0x08
#define BMI160_REG_INT_MAP_1 0x56
#define     BMI160_INT_MAP_INT1_FWM 0x40
#define BMI160_REG_CMD 0x7E
#define     BMI160_CMD_ACCEL_NORMAL_POWER_MODE 0x11
#define     BMI160_CMD_GYRO_NORMAL_POWER_MODE 0x15
#define     BMI160_CMD_FIFO_FLUSH 0xB0
#define     BMI160_CMD_SOFTRESET 0xB6

#define     BMI160_OSR_NORMAL 0x20
#define     BMI160_ODR_1600HZ 0x0C

/* Datasheet says that the device powers up in less than 10ms, so waiting for
 * 10 ms before initialization is enough. */
#define BMI160_POWERUP_DELAY_MSEC 10
/* TODO: Investigate this. The delay below is way too high and with that
 * there's still at least 1% of failures on initialization. Lower values
 * increase that percentage. */
#define BMI160_SOFTRESET_DELAY_MSEC 100
/* Define a little bit more than the maximum value in the datasheet's timing
 * table. The datasheet recommends adding 300 us to the time for startup
 * occasions. */
#define BMI160_ACCEL_NORMAL_POWER_MODE_DELAY_MSEC 4
#define BMI160_GYRO_NORMAL_POWER_MODE_DELAY_MSEC 81

#define BMI160_OSR BMI160_OSR_NORMAL
#define BMI160_ODR BMI160_ODR_1600HZ
#define BMI160_ACC_RANGE BMI160_ACC_RANGE_16G
#define BMI160_GYR_RANGE BMI160_GYR_RANGE_2000DPS

/* By looking at the datasheet, the accel range i (as defined by the macros
 * BMI160_ACC_RANGE_*G) maps to the range bits by the function f defined:
 *     f(0) = 3; f(i) = f(i - 1) + i + 1
 * Which can be written as the closed formula:
 *     f(i) = (i * (i + 3)) / 2 + 3 */
#define BMI160_ACC_RANGE_BITS \
    (BMI160_ACC_RANGE * (BMI160_ACC_RANGE + 3) / 2 + 3)

/* The rate in Hz based on the ODR bits can be calculated with
 * 100 / (2 ^ (8 - odr) */
#define BMI160_ODR_TO_HZ(odr_) \
    (uint16_t)(odr_ > 8 ? 100 << (odr_ - 8) : 100 >> (8 - odr_))

/* This number of samples should provide only one read burst operation on the
 * FIFO most of the time (99.99%). */
#define BMI160_MAX_FIFO_SAMPLES 8

#define BMI160_READ_FLAG 0x80
#define BMI160_HARDWARE_INIT_MAX_TRIES 5

#if CONFIG_HAL_BOARD_SUBTYPE == HAL_BOARD_SUBTYPE_LINUX_AERO
#    define BMI160_INT1_GPIO AERO_GPIO_BMI160_INT1
#else
#    define BMI160_INT1_GPIO -1
#endif

extern const AP_HAL::HAL& hal;

struct PACKED RawData {
    struct {
        le16_t x;
        le16_t y;
        le16_t z;
    } gyro;
    struct {
        le16_t x;
        le16_t y;
        le16_t z;
    } accel;
};

AP_InertialSensor_BMI160::AP_InertialSensor_BMI160(AP_InertialSensor &imu,
                                                   AP_HAL::OwnPtr<AP_HAL::Device> dev,
                                                   enum Rotation rotation)
    : AP_InertialSensor_Backend(imu)
    , _dev(std::move(dev))
    , _rotation(rotation)
{
}

AP_InertialSensor_Backend *
AP_InertialSensor_BMI160::probe(AP_InertialSensor &imu,
                                AP_HAL::OwnPtr<AP_HAL::SPIDevice> dev,
                                enum Rotation rotation)
{
    if (!dev) {
        return nullptr;
    }
    auto sensor = NEW_NOTHROW AP_InertialSensor_BMI160(imu, std::move(dev), rotation);

    if (!sensor) {
        return nullptr;
    }

    if (!sensor->_init()) {
        delete sensor;
        return nullptr;
    }

    return sensor;
}

AP_InertialSensor_Backend *
AP_InertialSensor_BMI160::probe(AP_InertialSensor &imu,
                                AP_HAL::OwnPtr<AP_HAL::I2CDevice> dev,
                                enum Rotation rotation)
{
    if (!dev) {
        return nullptr;
    }
    auto sensor = NEW_NOTHROW AP_InertialSensor_BMI160(imu, std::move(dev), rotation);

    if (!sensor) {
        return nullptr;
    }

    if (!sensor->_init()) {
        delete sensor;
        return nullptr;
    }

    return sensor;
}

void AP_InertialSensor_BMI160::start()
{
    bool r;

    _dev->get_semaphore()->take_blocking();

    r = _configure_accel();
    if (!r) {
        AP_HAL::panic("BMI160: Unable to configure accelerometer");
    }

    r = _configure_gyro();
    if (!r) {
        AP_HAL::panic("BMI160: Unable to configure gyroscope");
    }

    r = _configure_fifo();
    if (!r) {
        AP_HAL::panic("BMI160: Unable to configure FIFO");
    }

    if (BMI160_INT1_GPIO >= 0) {
        r = _configure_int1_pin();
        if (!r) {
            AP_HAL::panic("BMI160: unable to configure INT1 pin");
        }
    }

    _dev->get_semaphore()->give();

    if (!_imu.register_accel(accel_instance, BMI160_ODR_TO_HZ(BMI160_ODR), _dev->get_bus_id_devtype(DEVTYPE_BMI160)) ||
        !_imu.register_gyro(gyro_instance, BMI160_ODR_TO_HZ(BMI160_ODR),   _dev->get_bus_id_devtype(DEVTYPE_BMI160))) {
        return;
    }

    /* Call _poll_data() at 1kHz */
    _dev->register_periodic_callback(1000,
        FUNCTOR_BIND_MEMBER(&AP_InertialSensor_BMI160::_poll_data, void));
}

bool AP_InertialSensor_BMI160::update()
{
    update_accel(accel_instance);
    update_gyro(gyro_instance);
    return true;
}

void AP_InertialSensor_BMI160::_check_err_reg()
{
#ifdef BMI160_DEBUG
    uint8_t v;
    bool r;

    r = _dev->read_registers(BMI160_REG_ERR_REG, &v, 1);
    if (!r) {
        AP_HAL::panic("BMI160: couldn't read ERR_REG\n");
    }
    if (v) {
        AP_HAL::panic("BMI160: error detected on ERR_REG\n");
    }
#endif
}

bool AP_InertialSensor_BMI160::_configure_accel()
{
    bool r;

    r = _dev->write_register(BMI160_REG_ACC_CONF, BMI160_OSR | BMI160_ODR);
    if (!r) {
        return false;
    }
    hal.scheduler->delay(1);

    _check_err_reg();

    r = _dev->write_register(BMI160_REG_ACC_RANGE, BMI160_ACC_RANGE_BITS);
    if (!r) {
        return false;
    }
    hal.scheduler->delay(1);

    /* The sensitivity in LSb/g for an accel range i (as defined by the macros
     * BMI160_ACC_RANGE_*G) can be calculated with:
     *     2 ^ 16 / (2 * 2 ^ (i + 1)) = 2 ^(14 - i)
     * That matches the typical values in the datasheet. */
    _accel_scale = GRAVITY_MSS / (1 << (14 - BMI160_ACC_RANGE));

    return true;
}

bool AP_InertialSensor_BMI160::_configure_gyro()
{
    bool r;

    r = _dev->write_register(BMI160_REG_GYR_CONF, BMI160_OSR | BMI160_ODR);
    if (!r) {
        return false;
    }
    hal.scheduler->delay(1);

    _check_err_reg();

    r = _dev->write_register(BMI160_REG_GYR_RANGE, BMI160_GYR_RANGE);
    if (!r) {
        return false;
    }
    hal.scheduler->delay(1);

    /* The sensitivity in LSb/degrees/s a gyro range i can be calculated with:
     *     2 ^ 16 / (2 * 2000 / 2 ^ i) = 2 ^ (14 + i) / 1000
     * The scale is the inverse of that. */
    _gyro_scale = radians(1000.f / (1 << (14 + BMI160_GYR_RANGE)));

    return true;
}

bool AP_InertialSensor_BMI160::_configure_int1_pin()
{
    bool r;

    r = _dev->write_register(BMI160_REG_INT_EN_1, BMI160_INT_FWM_EN);
    if (!r) {
        DEV_PRINTF("BMI160: Unable to enable FIFO watermark interrupt engine\n");
        return false;
    }
    hal.scheduler->delay(1);

    r = _dev->write_register(BMI160_REG_INT_MAP_1, BMI160_INT_MAP_INT1_FWM);
    if (!r) {
        DEV_PRINTF("BMI160: Unable to configure interrupt mapping\n");
        return false;
    }
    hal.scheduler->delay(1);

    r = _dev->write_register(BMI160_REG_INT_OUT_CTRL,
                             BMI160_INT1_OUTPUT_EN | BMI160_INT1_LVL);
    if (!r) {
        DEV_PRINTF("BMI160: Unable to configure interrupt output\n");
        return false;
    }
    hal.scheduler->delay(1);

    _int1_pin = hal.gpio->channel(BMI160_INT1_GPIO);
    if (_int1_pin == nullptr) {
        DEV_PRINTF("BMI160: Couldn't request data ready GPIO channel\n");
        return false;
    }
    _int1_pin->mode(HAL_GPIO_INPUT);

    return true;
}

bool AP_InertialSensor_BMI160::_configure_fifo()
{
    bool r;

    /* The unit for the FIFO watermark is 4 bytes. */
    r = _dev->write_register(BMI160_REG_FIFO_CONFIG_0,
                             sizeof(struct RawData) / 4);
    if (!r) {
        DEV_PRINTF("BMI160: Unable to configure FIFO watermark level\n");
        return false;
    }
    hal.scheduler->delay(1);

    r = _dev->write_register(BMI160_REG_FIFO_CONFIG_1,
                             BMI160_FIFO_ACC_EN | BMI160_FIFO_GYR_EN);
    if (!r) {
        DEV_PRINTF("BMI160: Unable to enable FIFO\n");
        return false;
    }
    hal.scheduler->delay(1);

    _check_err_reg();

    r = _dev->write_register(BMI160_REG_CMD, BMI160_CMD_FIFO_FLUSH);
    if (!r) {
        DEV_PRINTF("BMI160: Unable to flush FIFO\n");
        return false;
    }

    return true;
}

void AP_InertialSensor_BMI160::_read_fifo()
{
    struct RawData raw_data[BMI160_MAX_FIFO_SAMPLES];
    uint16_t num_bytes;
    uint16_t excess;
    uint8_t num_samples = 0;
    bool r = true;

    static_assert(sizeof(raw_data) <= 100, "Too big to keep on stack");

    /* If FIFO watermark not surpassed. */
    if (_int1_pin && _int1_pin->read() == 0) {
        goto read_fifo_end;
    }

    r = _dev->read_registers(BMI160_REG_FIFO_LENGTH,
                             (uint8_t *)&num_bytes,
                             sizeof(num_bytes));
    if (!r) {
        goto read_fifo_end;
    }

    num_bytes = le16toh(num_bytes);
    if (!num_bytes) {
        goto read_fifo_end;
    }

read_fifo_read_data:
    if (num_bytes > sizeof(raw_data)) {
        excess = num_bytes - sizeof(raw_data);
        num_bytes = sizeof(raw_data);
    } else {
        excess = 0;
    }

    r = _dev->read_registers(BMI160_REG_FIFO_DATA,
                             (uint8_t *)raw_data,
                             num_bytes);
    if (!r) {
        goto read_fifo_end;
    }

    /* Read again just once */
    if (excess && num_samples) {
        DEV_PRINTF("BMI160: dropping %u samples from fifo\n",
                            (uint8_t)(excess / sizeof(struct RawData)));
        _dev->write_register(BMI160_REG_CMD, BMI160_CMD_FIFO_FLUSH);
        excess = 0;
    }

    num_samples = num_bytes / sizeof(struct RawData);
    for (uint8_t i = 0; i < num_samples; i++) {
        Vector3f accel{(float)(int16_t)le16toh(raw_data[i].accel.x),
                       (float)(int16_t)le16toh(raw_data[i].accel.y),
                       (float)(int16_t)le16toh(raw_data[i].accel.z)};
        Vector3f gyro{(float)(int16_t)le16toh(raw_data[i].gyro.x),
                      (float)(int16_t)le16toh(raw_data[i].gyro.y),
                      (float)(int16_t)le16toh(raw_data[i].gyro.z)};

        accel.rotate(_rotation);
        gyro.rotate(_rotation);

        accel *= _accel_scale;
        gyro *= _gyro_scale;

        _rotate_and_correct_accel(accel_instance, accel);
        _rotate_and_correct_gyro(gyro_instance, gyro);

        _notify_new_accel_raw_sample(accel_instance, accel);
        _notify_new_gyro_raw_sample(gyro_instance, gyro);
    }

    if (excess) {
        num_bytes = excess;
        goto read_fifo_read_data;
    }

read_fifo_end:
    if (!r) {
        DEV_PRINTF("BMI160: error on reading FIFO\n");
    }
}

void AP_InertialSensor_BMI160::_poll_data()
{
    _read_fifo();
}

bool AP_InertialSensor_BMI160::_hardware_init()
{
    bool ret = false;

    hal.scheduler->delay(BMI160_POWERUP_DELAY_MSEC);

    _dev->get_semaphore()->take_blocking();

    _dev->set_speed(AP_HAL::Device::SPEED_LOW);

    for (unsigned i = 0; i < BMI160_HARDWARE_INIT_MAX_TRIES; i++) {
        uint8_t v;
        ret = _dev->write_register(BMI160_REG_CMD,
                                   BMI160_CMD_SOFTRESET);

        if (!ret) {
            continue;
        }
        hal.scheduler->delay(BMI160_SOFTRESET_DELAY_MSEC);

        /* The datasheet recommends doing a read operation on the register 0x7F
         * in order to guarantee the sensor works using the SPI protocol. This
         * shouldn't have side effects for I2C. */
        ret = _dev->read_registers(0x7F, &v, 1);
        if (!ret) {
            continue;
        }

        ret = _dev->read_registers(BMI160_REG_CHIPID, &v, 1);
        if (!ret) {
            continue;
        }
        if (v != BMI160_CHIPID) {
            ret = false;
            continue;
        }

        ret = _dev->write_register(BMI160_REG_CMD,
                                   BMI160_CMD_ACCEL_NORMAL_POWER_MODE);
        if (!ret) {
            continue;
        }
        hal.scheduler->delay(BMI160_ACCEL_NORMAL_POWER_MODE_DELAY_MSEC);

        ret = _dev->write_register(BMI160_REG_CMD,
                                   BMI160_CMD_GYRO_NORMAL_POWER_MODE);
        if (!ret) {
            continue;
        }
        hal.scheduler->delay(BMI160_GYRO_NORMAL_POWER_MODE_DELAY_MSEC);

        break;
    }

    _dev->set_speed(AP_HAL::Device::SPEED_HIGH);

    _dev->get_semaphore()->give();
    return ret;
}

bool AP_InertialSensor_BMI160::_init()
{
    bool ret = false;
    _dev->set_read_flag(BMI160_READ_FLAG);

    ret = _hardware_init();
    if (!ret) {
        DEV_PRINTF("BMI160: failed to init\n");
    }

    return ret;
}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       /*
 * This file is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This file is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
#pragma once

#include <AP_HAL/AP_HAL.h>
#include <AP_HAL/SPIDevice.h>
#include <AP_HAL/I2CDevice.h>

#include "AP_InertialSensor.h"
#include "AP_InertialSensor_Backend.h"

#if CONFIG_HAL_BOARD_SUBTYPE == HAL_BOARD_SUBTYPE_LINUX_AERO
#define BMI270_DEFAULT_ROTATION ROTATION_ROLL_180
#else
#define BMI270_DEFAULT_ROTATION ROTATION_NONE
#endif

class AP_InertialSensor_BMI270 : public AP_InertialSensor_Backend {
public:
    static AP_InertialSensor_Backend *probe(AP_InertialSensor &imu,
                                            AP_HAL::OwnPtr<AP_HAL::SPIDevice> dev,
                                            enum Rotation rotation=BMI270_DEFAULT_ROTATION);

    static AP_InertialSensor_Backend *probe(AP_InertialSensor &imu,
                                            AP_HAL::OwnPtr<AP_HAL::I2CDevice> dev,
                                            enum Rotation rotation=BMI270_DEFAULT_ROTATION);

    /**
     * Configure the sensors and start reading routine.
     */
    void start() override;

    bool update() override;

private:
    AP_InertialSensor_BMI270(AP_InertialSensor &imu,
                             AP_HAL::OwnPtr<AP_HAL::Device> dev,
                             enum Rotation rotation);

    bool read_registers(uint8_t reg, uint8_t *data, uint8_t len);
    bool write_register(uint8_t reg, uint8_t v);

    /**
     * If the macro BMI270_DEBUG is defined, check if there are errors reported
     * on the device's error register and panic if so. The implementation is
     * empty if the BMI270_DEBUG isn't defined.
     */
    void check_err_reg();

    /**
     * Try to perform initialization of the BMI270 device.
     *
     * The device semaphore must be taken and released by the caller.
     *
     * @return true on success, false otherwise.
     */
    bool hardware_init();

    /**
     * Try to initialize this driver.
     *
     * Do sensor and other required initializations.
     *
     * @return true on success, false otherwise.
     */
    bool init();

    /**
     * Configure accelerometer sensor. The device semaphore must already be
     * taken before calling this function.
     *
     * @return true on success, false otherwise.
     */
    void configure_accel();

    /**
     * Configure gyroscope sensor. The device semaphore must already be
     * taken before calling this function.
     *
     * @return true on success, false otherwise.
     */
    void configure_gyro();

    /**
     * Reset FIFO.
     */
    void fifo_reset();

    /**
     * Configure FIFO.
     */
    void configure_fifo();

    /**
     * Read samples from fifo.
     */
    void read_fifo();
    void parse_accel_frame(const uint8_t* d);
    void parse_gyro_frame(const uint8_t* d);

    AP_HAL::OwnPtr<AP_HAL::Device> _dev;
    AP_HAL::Device::PeriodicHandle periodic_handle;

    enum Rotation _rotation;

    uint8_t temperature_counter;

    static const uint8_t maximum_fifo_config_file[];
};                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           #define AP_INLINE_VECTOR_OPS

#include <AP_HAL/AP_HAL.h>
#include <AP_AHRS/AP_AHRS.h>
#include "AP_InertialSensor.h"
#include "AP_InertialSensor_Backend.h"
#include <AP_Logger/AP_Logger.h>
#include <AP_BoardConfig/AP_BoardConfig.h>
#if AP_MODULE_SUPPORTED
#include <AP_Module/AP_Module.h>
#endif
#include <stdio.h>

#define SENSOR_RATE_DEBUG 0

#ifndef AP_HEATER_IMU_INSTANCE
#define AP_HEATER_IMU_INSTANCE 0
#endif

const extern AP_HAL::HAL& hal;

AP_InertialSensor_Backend::AP_InertialSensor_Backend(AP_InertialSensor &imu) :
    _imu(imu)
{
}

/*
  notify of a FIFO reset so we don't use bad data to update observed sensor rate
 */
void AP_InertialSensor_Backend::notify_accel_fifo_reset(uint8_t instance)
{
    _imu._sample_accel_count[instance] = 0;
    _imu._sample_accel_start_us[instance] = 0;    
}

/*
  notify of a FIFO reset so we don't use bad data to update observed sensor rate
 */
void AP_InertialSensor_Backend::notify_gyro_fifo_reset(uint8_t instance)
{
    _imu._sample_gyro_count[instance] = 0;
    _imu._sample_gyro_start_us[instance] = 0;
}

// set the amount of oversamping a accel is doing
void AP_InertialSensor_Backend::_set_accel_oversampling(uint8_t instance, uint8_t n)
{
    _imu._accel_over_sampling[instance] = n;
}

// set the amount of oversamping a gyro is doing
void AP_InertialSensor_Backend::_set_gyro_oversampling(uint8_t instance, uint8_t n)
{
    _imu._gyro_over_sampling[instance] = n;
}

/*
  update the sensor rate for FIFO sensors

  FIFO sensors produce samples at a fixed rate, but the clock in the
  sensor may vary slightly from the system clock. This slowly adjusts
  the rate to the observed rate
*/
void AP_InertialSensor_Backend::_update_sensor_rate(uint16_t &count, uint32_t &start_us, float &rate_hz) const
{
    uint32_t now = AP_HAL::micros();
    if (start_us == 0) {
        count = 0;
        start_us = now;
    } else {
        count++;
        if (now - start_us > 1000000UL) {
            float observed_rate_hz = count * 1.0e6f / (now - start_us);
#if 0
            printf("IMU RATE: %.1f should be %.1f\n", observed_rate_hz, rate_hz);
#endif
            float filter_constant = 0.98f;
            float upper_limit = 1.05f;
            float lower_limit = 0.95f;
            if (sensors_converging()) {
                // converge quickly for first 30s, then more slowly
                filter_constant = 0.8f;
                upper_limit = 2.0f;
                lower_limit = 0.5f;
            }
            observed_rate_hz = constrain_float(observed_rate_hz, rate_hz*lower_limit, rate_hz*upper_limit);
            rate_hz = filter_constant * rate_hz + (1-filter_constant) * observed_rate_hz;
            count = 0;
            start_us = now;
        }
    }
}

void AP_InertialSensor_Backend::_rotate_and_correct_accel(uint8_t instance, Vector3f &accel) 
{
    /*
      accel calibration is always done in sensor frame with this
      version of the code. That means we apply the rotation after the
      offsets and scaling.
     */

    // rotate for sensor orientation
    accel.rotate(_imu._accel_orientation[instance]);

#if HAL_INS_TEMPERATURE_CAL_ENABLE
    if (_imu.tcal_learning) {
        _imu.tcal(instance).update_accel_learning(accel, _imu.get_temperature(instance));
    }
#endif

    if (!_imu._calibrating_accel && (_imu._acal == nullptr
#if HAL_INS_ACCELCAL_ENABLED
        || !_imu._acal->running()
#endif
    )) {

#if HAL_INS_TEMPERATURE_CAL_ENABLE
        // apply temperature corrections
        _imu.tcal(instance).correct_accel(_imu.get_temperature(instance), _imu.caltemp_accel(instance), accel);
#endif

        // apply offsets
        accel -= _imu._accel_offset(instance);


        // apply scaling
        const Vector3f &accel_scale = _imu._accel_scale(instance).get();
        accel.x *= accel_scale.x;
        accel.y *= accel_scale.y;
        accel.z *= accel_scale.z;
    }

    // rotate to body frame
    accel.rotate(_imu._board_orientation);
}

void AP_InertialSensor_Backend::_rotate_and_correct_gyro(uint8_t instance, Vector3f &gyro) 
{
    // rotate for sensor orientation
    gyro.rotate(_imu._gyro_orientation[instance]);

#if HAL_INS_TEMPERATURE_CAL_ENABLE
    if (_imu.tcal_learning) {
        _imu.tcal(instance).update_gyro_learning(gyro, _imu.get_temperature(instance));
    }
#endif
    
    if (!_imu._calibrating_gyro) {

#if HAL_INS_TEMPERATURE_CAL_ENABLE
        // apply temperature corrections
        _imu.tcal(instance).correct_gyro(_imu.get_temperature(instance), _imu.caltemp_gyro(instance), gyro);
#endif

        // gyro calibration is always assumed to have been done in sensor frame
        gyro -= _imu._gyro_offset(instance);
    }

    gyro.rotate(_imu._board_orientation);
}

/*
  rotate gyro vector and add the gyro offset
 */
void AP_InertialSensor_Backend::_publish_gyro(uint8_t instance, const Vector3f &gyro) /* front end */
{
    if (has_been_killed(instance)) {
        return;
    }
    _imu._gyro[instance] = gyro;
    _imu._gyro_healthy[instance] = true;

    // publish delta angle
    _imu._delta_angle[instance] = _imu._delta_angle_acc[instance];
    _imu._delta_angle_dt[instance] = _imu._delta_angle_acc_dt[instance];
    _imu._delta_angle_valid[instance] = true;

    _imu._delta_angle_acc[instance].zero();
    _imu._delta_angle_acc_dt[instance] = 0;
}


void AP_InertialSensor_Backend::save_gyro_window(const uint8_t instance, const Vector3f &gyro, uint8_t phase)
{
#if HAL_GYROFFT_ENABLED
    // capture gyro window for FFT analysis
    if (_imu._fft_window_phase == phase) {
        if (_imu._gyro_window_size > 0) {
            Vector3f scaled_gyro = gyro * _imu._gyro_raw_sampling_multiplier[instance];
            // LPF always must come last to remove high-frequency shot noise, but the FFT still
            // needs to see the same data so gets its own LPF at the tap point
            if (_imu._post_filter_fft) {
                scaled_gyro = _imu._post_filter_gyro_filter[instance].apply(scaled_gyro);
            }
            _imu._gyro_window[instance][0].push(scaled_gyro.x);
            _imu._gyro_window[instance][1].push(scaled_gyro.y);
            _imu._gyro_window[instance][2].push(scaled_gyro.z);
            _imu._last_gyro_for_fft[instance] = scaled_gyro;
        } else {
            _imu._last_gyro_for_fft[instance] = gyro * _imu._gyro_raw_sampling_multiplier[instance];;
        }
    }
#endif
}

/*
  apply harmonic notch and low pass gyro filters
 */
void AP_InertialSensor_Backend::apply_gyro_filters(const uint8_t instance, const Vector3f &gyro)
{
    uint8_t filter_phase = 0;
    save_gyro_window(instance, gyro, filter_phase++);

    Vector3f gyro_filtered = gyro;

#if AP_INERTIALSENSOR_HARMONICNOTCH_ENABLED
    // apply the harmonic notch filters
    for (auto &notch : _imu.harmonic_notches) {
        if (!notch.params.enabled()) {
            continue;
        }
        bool inactive = notch.is_inactive();
#if AP_AHRS_ENABLED
        // by default we only run the expensive notch filters on the
        // currently active IMU we reset the inactive notch filters so
        // that if we switch IMUs we're not left with old data
        if (!notch.params.hasOption(HarmonicNotchFilterParams::Options::EnableOnAllIMUs) &&
            instance != AP::ahrs().get_primary_gyro_index()) {
            inactive = true;
        }
#endif
        if (inactive) {
            // while inactive we reset the filter so when it activates the first output
            // will be the first input sample
            notch.filter[instance].reset();
        } else {
            gyro_filtered = notch.filter[instance].apply(gyro_filtered);
        }
        save_gyro_window(instance, gyro_filtered, filter_phase++);
    }
#endif  // AP_INERTIALSENSOR_HARMONICNOTCH_ENABLED

    // apply the low pass filter last to attenuate any notch induced noise
    gyro_filtered = _imu._gyro_filter[instance].apply(gyro_filtered);

    // if the filtering failed in any way then reset the filters and keep the old value
    if (gyro_filtered.is_nan() || gyro_filtered.is_inf()) {
        _imu._gyro_filter[instance].reset();
#if HAL_GYROFFT_ENABLED
        _imu._post_filter_gyro_filter[instance].reset();
#endif
#if AP_INERTIALSENSOR_HARMONICNOTCH_ENABLED
        for (auto &notch : _imu.harmonic_notches) {
            notch.filter[instance].reset();
        }
#endif
    } else {
        _imu._gyro_filtered[instance] = gyro_filtered;
    }
}

void AP_InertialSensor_Backend::_notify_new_gyro_raw_sample(uint8_t instance,
                                                            const Vector3f &gyro,
                                                            uint64_t sample_us)
{
    if (has_been_killed(instance)) {
        return;
    }
    float dt;

    _update_sensor_rate(_imu._sample_gyro_count[instance], _imu._sample_gyro_start_us[instance],
                        _imu._gyro_raw_sample_rates[instance]);

    uint64_t last_sample_us = _imu._gyro_last_sample_us[instance];

    /*
      we have two classes of sensors. FIFO based sensors produce data
      at a very predictable overall rate, but the data comes in
      bunches, so we use the provided sample rate for deltaT. Non-FIFO
      sensors don't bunch up samples, but also tend to vary in actual
      rate, so we use the provided sample_us to get the deltaT. The
      difference between the two is whether sample_us is provided.
     */
    if (sample_us != 0 && _imu._gyro_last_sample_us[instance] != 0) {
        dt = (sample_us - _imu._gyro_last_sample_us[instance]) * 1.0e-6f;
        _imu._gyro_last_sample_us[instance] = sample_us;
    } else {
        // don't accept below 40Hz
        if (_imu._gyro_raw_sample_rates[instance] < 40) {
            return;
        }

        dt = 1.0f / _imu._gyro_raw_sample_rates[instance];
        _imu._gyro_last_sample_us[instance] = AP_HAL::micros64();
        sample_us = _imu._gyro_last_sample_us[instance];
    }

#if AP_MODULE_SUPPORTED
    // call gyro_sample hook if any
    AP_Module::call_hook_gyro_sample(instance, dt, gyro);
#endif

    // push gyros if optical flow present
    if (hal.opticalflow) {
        hal.opticalflow->push_gyro(gyro.x, gyro.y, dt);
    }
    
    // compute delta angle
    Vector3f delta_angle = (gyro + _imu._last_raw_gyro[instance]) * 0.5f * dt;

    // compute coning correction
    // see page 26 of:
    // Tian et al (2010) Three-loop Integration of GPS and Strapdown INS with Coning and Sculling Compensation
    // Available: http://www.sage.unsw.edu.au/snap/publications/tian_etal2010b.pdf
    // see also examples/coning.py
    Vector3f delta_coning = (_imu._delta_angle_acc[instance] +
                             _imu._last_delta_angle[instance] * (1.0f / 6.0f));
    delta_coning = delta_coning % delta_angle;
    delta_coning *= 0.5f;

    {
        WITH_SEMAPHORE(_sem);
        uint64_t now = AP_HAL::micros64();

        if (now - last_sample_us > 100000U) {
            // zero accumulator if sensor was unhealthy for 0.1s
            _imu._delta_angle_acc[instance].zero();
            _imu._delta_angle_acc_dt[instance] = 0;
            dt = 0;
            delta_angle.zero();
        }

        // integrate delta angle accumulator
        // the angles and coning corrections are accumulated separately in the
        // referenced paper, but in simulation little difference was found between
        // integrating together and integrating separately (see examples/coning.py)
        _imu._delta_angle_acc[instance] += delta_angle + delta_coning;
        _imu._delta_angle_acc_dt[instance] += dt;

        // save previous delta angle for coning correction
        _imu._last_delta_angle[instance] = delta_angle;
        _imu._last_raw_gyro[instance] = gyro;

        // apply gyro filters and sample for FFT
        apply_gyro_filters(instance, gyro);

        _imu._new_gyro_data[instance] = true;
    }

    // 5us
    log_gyro_raw(instance, sample_us, gyro, _imu._gyro_filtered[instance]);
}

/*
  handle a delta-angle sample from the backend. This assumes FIFO
  style sampling and the sample should not be rotated or corrected for
  offsets.
  This function should be used when the sensor driver can directly
  provide delta-angle values from the sensor.
 */
void AP_InertialSensor_Backend::_notify_new_delta_angle(uint8_t instance, const Vector3f &dangle)
{
    if (has_been_killed(instance)) {
        return;
    }
    float dt;

    _update_sensor_rate(_imu._sample_gyro_count[instance], _imu._sample_gyro_start_us[instance],
                        _imu._gyro_raw_sample_rates[instance]);

    uint64_t last_sample_us = _imu._gyro_last_sample_us[instance];

    // don't accept below 40Hz
    if (_imu._gyro_raw_sample_rates[instance] < 40) {
        return;
    }

    dt = 1.0f / _imu._gyro_raw_sample_rates[instance];
    _imu._gyro_last_sample_us[instance] = AP_HAL::micros64();
    uint64_t sample_us = _imu._gyro_last_sample_us[instance];

    Vector3f gyro = dangle / dt;

    _rotate_and_correct_gyro(instance, gyro);

#if AP_MODULE_SUPPORTED
    // call gyro_sample hook if any
    AP_Module::call_hook_gyro_sample(instance, dt, gyro);
#endif

    // push gyros if optical flow present
    if (hal.opticalflow) {
        hal.opticalflow->push_gyro(gyro.x, gyro.y, dt);
    }
    
    // compute delta angle, including corrections
    Vector3f delta_angle = gyro * dt;

    // compute coning correction
    // see page 26 of:
    // Tian et al (2010) Three-loop Integration of GPS and Strapdown INS with Coning and Sculling Compensation
    // Available: http://www.sage.unsw.edu.au/snap/publications/tian_etal2010b.pdf
    // see also examples/coning.py
    Vector3f delta_coning = (_imu._delta_angle_acc[instance] +
                             _imu._last_delta_angle[instance] * (1.0f / 6.0f));
    delta_coning = delta_coning % delta_angle;
    delta_coning *= 0.5f;

    {
        WITH_SEMAPHORE(_sem);
        uint64_t now = AP_HAL::micros64();

        if (now - last_sample_us > 100000U) {
            // zero accumulator if sensor was unhealthy for 0.1s
            _imu._delta_angle_acc[instance].zero();
            _imu._delta_angle_acc_dt[instance] = 0;
            dt = 0;
            delta_angle.zero();
        }

        // integrate delta angle accumulator
        // the angles and coning corrections are accumulated separately in the
        // referenced paper, but in simulation little difference was found between
        // integrating together and integrating separately (see examples/coning.py)
        _imu._delta_angle_acc[instance] += delta_angle + delta_coning;
        _imu._delta_angle_acc_dt[instance] += dt;

        // save previous delta angle for coning correction
        _imu._last_delta_angle[instance] = delta_angle;
        _imu._last_raw_gyro[instance] = gyro;

        // apply gyro filters and sample for FFT
        apply_gyro_filters(instance, gyro);

        _imu._new_gyro_data[instance] = true;
    }

    log_gyro_raw(instance, sample_us, gyro, _imu._gyro_filtered[instance]);
}

void AP_InertialSensor_Backend::log_gyro_raw(uint8_t instance, const uint64_t sample_us, const Vector3f &raw_gyro, const Vector3f &filtered_gyro)
{
#if HAL_LOGGING_ENABLED
    AP_Logger *logger = AP_Logger::get_singleton();
    if (logger == nullptr) {
        // should not have been called
        return;
    }

#if AP_AHRS_ENABLED
    const bool log_because_primary_gyro = _imu.raw_logging_option_set(AP_InertialSensor::RAW_LOGGING_OPTION::PRIMARY_GYRO_ONLY) && (instance == AP::ahrs().get_primary_gyro_index());
#else
    const bool log_because_primary_gyro = false;
#endif

    if (_imu.raw_logging_option_set(AP_InertialSensor::RAW_LOGGING_OPTION::ALL_GYROS) ||
        log_because_primary_gyro ||
        should_log_imu_raw()) {

        if (_imu.raw_logging_option_set(AP_InertialSensor::RAW_LOGGING_OPTION::PRE_AND_POST_FILTER)) {
            // Both pre and post, offset post instance as batch sampler does
            Write_GYR(instance, sample_us, raw_gyro);
            Write_GYR(instance + _imu._gyro_count, sample_us, filtered_gyro);

        } else if (_imu.raw_logging_option_set(AP_InertialSensor::RAW_LOGGING_OPTION::POST_FILTER)) {
            // Just post
            Write_GYR(instance, sample_us, filtered_gyro);

        } else {
            // Just pre
            Write_GYR(instance, sample_us, raw_gyro);

        }
    } else {
#if AP_INERTIALSENSOR_BATCHSAMPLER_ENABLED
        if (!_imu.batchsampler.doing_sensor_rate_logging()) {
            _imu.batchsampler.sample(instance, AP_InertialSensor::IMU_SENSOR_TYPE_GYRO, sample_us,
                                     !_imu.batchsampler.doing_post_filter_logging() ? raw_gyro : filtered_gyro);
        }
#endif
    }
#endif
}

/*
  rotate accel vector, scale and add the accel offset
 */
void AP_InertialSensor_Backend::_publish_accel(uint8_t instance, const Vector3f &accel) /* front end */
{
    if (has_been_killed(instance)) {
        return;
    }
    _imu._accel[instance] = accel;
    _imu._accel_healthy[instance] = true;

    // publish delta velocity
    _imu._delta_velocity[instance] = _imu._delta_velocity_acc[instance];
    _imu._delta_velocity_dt[instance] = _imu._delta_velocity_acc_dt[instance];
    _imu._delta_velocity_valid[instance] = true;

    _imu._delta_velocity_acc[instance].zero();
    _imu._delta_velocity_acc_dt[instance] = 0;

    if (_imu._accel_calibrator != nullptr && _imu._accel_calibrator[instance].get_status() == ACCEL_CAL_COLLECTING_SAMPLE) {
        Vector3f cal_sample = _imu._delta_velocity[instance];

        // remove rotation. Note that we don't need to remove offsets or scale factor as those
        // are not applied when calibrating
        cal_sample.rotate_inverse(_imu._board_orientation);

        _imu._accel_calibrator[instance].new_sample(cal_sample, _imu._delta_velocity_dt[instance]);
    }
}

void AP_InertialSensor_Backend::_notify_new_accel_raw_sample(uint8_t instance,
                                                             const Vector3f &accel,
                                                             uint64_t sample_us,
                                                             bool fsync_set)
{
    if (has_been_killed(instance)) {
        return;
    }
    float dt;

    _update_sensor_rate(_imu._sample_accel_count[instance], _imu._sample_accel_start_us[instance],
                        _imu._accel_raw_sample_rates[instance]);

    uint64_t last_sample_us = _imu._accel_last_sample_us[instance];

    /*
      we have two classes of sensors. FIFO based sensors produce data
      at a very predictable overall rate, but the data comes in
      bunches, so we use the provided sample rate for deltaT. Non-FIFO
      sensors don't bunch up samples, but also tend to vary in actual
      rate, so we use the provided sample_us to get the deltaT. The
      difference between the two is whether sample_us is provided.
     */
    if (sample_us != 0 && _imu._accel_last_sample_us[instance] != 0) {
        dt = (sample_us - _imu._accel_last_sample_us[instance]) * 1.0e-6f;
        _imu._accel_last_sample_us[instance] = sample_us;
    } else {
        // don't accept below 40Hz
        if (_imu._accel_raw_sample_rates[instance] < 40) {
            return;
        }

        dt = 1.0f / _imu._accel_raw_sample_rates[instance];
        _imu._accel_last_sample_us[instance] = AP_HAL::micros64();
        sample_us = _imu._accel_last_sample_us[instance];
    }

#if AP_MODULE_SUPPORTED
    // call accel_sample hook if any
    AP_Module::call_hook_accel_sample(instance, dt, accel, fsync_set);
#endif    
    
    _imu.calc_vibration_and_clipping(instance, accel, dt);

    {
        WITH_SEMAPHORE(_sem);

        uint64_t now = AP_HAL::micros64();

        if (now - last_sample_us > 100000U) {
            // zero accumulator if sensor was unhealthy for 0.1s
            _imu._delta_velocity_acc[instance].zero();
            _imu._delta_velocity_acc_dt[instance] = 0;
            dt = 0;
        }
        
        // delta velocity
        _imu._delta_velocity_acc[instance] += accel * dt;
        _imu._delta_velocity_acc_dt[instance] += dt;

        _imu._accel_filtered[instance] = _imu._accel_filter[instance].apply(accel);
        if (_imu._accel_filtered[instance].is_nan() || _imu._accel_filtered[instance].is_inf()) {
            _imu._accel_filter[instance].reset();
        }

        _imu.set_accel_peak_hold(instance, _imu._accel_filtered[instance]);

        _imu._new_accel_data[instance] = true;
    }

    // 5us
#if AP_INERTIALSENSOR_BATCHSAMPLER_ENABLED
    if (!_imu.batchsampler.doing_post_filter_logging()) {
        log_accel_raw(instance, sample_us, accel);
    } else {
        log_accel_raw(instance, sample_us, _imu._accel_filtered[instance]);
    }
#else
    // assume we're doing pre-filter logging:
    log_accel_raw(instance, sample_us, accel);
#endif
}

/*
  handle a delta-velocity sample from the backend. This assumes FIFO style sampling and
  the sample should not be rotated or corrected for offsets

  This function should be used when the sensor driver can directly
  provide delta-velocity values from the sensor.
 */
void AP_InertialSensor_Backend::_notify_new_delta_velocity(uint8_t instance, const Vector3f &dvel)
{
    if (has_been_killed(instance)) {
        return;
    }
    float dt;

    _update_sensor_rate(_imu._sample_accel_count[instance], _imu._sample_accel_start_us[instance],
                        _imu._accel_raw_sample_rates[instance]);

    uint64_t last_sample_us = _imu._accel_last_sample_us[instance];

    // don't accept below 40Hz
    if (_imu._accel_raw_sample_rates[instance] < 40) {
        return;
    }

    dt = 1.0f / _imu._accel_raw_sample_rates[instance];
    _imu._accel_last_sample_us[instance] = AP_HAL::micros64();
    uint64_t sample_us = _imu._accel_last_sample_us[instance];

    Vector3f accel = dvel / dt;

    _rotate_and_correct_accel(instance, accel);

#if AP_MODULE_SUPPORTED
    // call accel_sample hook if any
    AP_Module::call_hook_accel_sample(instance, dt, accel, false);
#endif    
    
    _imu.calc_vibration_and_clipping(instance, accel, dt);

    {
        WITH_SEMAPHORE(_sem);

        uint64_t now = AP_HAL::micros64();

        if (now - last_sample_us > 100000U) {
            // zero accumulator if sensor was unhealthy for 0.1s
            _imu._delta_velocity_acc[instance].zero();
            _imu._delta_velocity_acc_dt[instance] = 0;
            dt = 0;
        }
        
        // delta velocity including corrections
        _imu._delta_velocity_acc[instance] += accel * dt;
        _imu._delta_velocity_acc_dt[instance] += dt;

        _imu._accel_filtered[instance] = _imu._accel_filter[instance].apply(accel);
        if (_imu._accel_filtered[instance].is_nan() || _imu._accel_filtered[instance].is_inf()) {
            _imu._accel_filter[instance].reset();
        }

        _imu.set_accel_peak_hold(instance, _imu._accel_filtered[instance]);

        _imu._new_accel_data[instance] = true;
    }

#if AP_INERTIALSENSOR_BATCHSAMPLER_ENABLED
    if (!_imu.batchsampler.doing_post_filter_logging()) {
        log_accel_raw(instance, sample_us, accel);
    } else {
        log_accel_raw(instance, sample_us, _imu._accel_filtered[instance]);
    }
#else
    // assume we're doing pre-filter logging
    log_accel_raw(instance, sample_us, accel);
#endif
}


void AP_InertialSensor_Backend::_notify_new_accel_sensor_rate_sample(uint8_t instance, const Vector3f &_accel)
{
#if AP_INERTIALSENSOR_BATCHSAMPLER_ENABLED
    if (!_imu.batchsampler.doing_sensor_rate_logging()) {
        return;
    }

    // get batch sampling in correct orientation
    Vector3f accel = _accel;
    accel.rotate(_imu._accel_orientation[instance]);

    _imu.batchsampler.sample(instance, AP_InertialSensor::IMU_SENSOR_TYPE_ACCEL, AP_HAL::micros64(), accel);
#endif
}

void AP_InertialSensor_Backend::_notify_new_gyro_sensor_rate_sample(uint8_t instance, const Vector3f &_gyro)
{
#if AP_INERTIALSENSOR_BATCHSAMPLER_ENABLED
    if (!_imu.batchsampler.doing_sensor_rate_logging()) {
        return;
    }

    // get batch sampling in correct orientation
    Vector3f gyro = _gyro;
    gyro.rotate(_imu._gyro_orientation[instance]);

    _imu.batchsampler.sample(instance, AP_InertialSensor::IMU_SENSOR_TYPE_GYRO, AP_HAL::micros64(), gyro);
#endif
}

void AP_InertialSensor_Backend::log_accel_raw(uint8_t instance, const uint64_t sample_us, const Vector3f &accel)
{
#if HAL_LOGGING_ENABLED
    AP_Logger *logger = AP_Logger::get_singleton();
    if (logger == nullptr) {
        // should not have been called
        return;
    }
    if (should_log_imu_raw()) {
        Write_ACC(instance, sample_us, accel);
    } else {
#if AP_INERTIALSENSOR_BATCHSAMPLER_ENABLED
        if (!_imu.batchsampler.doing_sensor_rate_logging()) {
            _imu.batchsampler.sample(instance, AP_InertialSensor::IMU_SENSOR_TYPE_ACCEL, sample_us, accel);
        }
#endif
    }
#endif
}

void AP_InertialSensor_Backend::_set_accel_max_abs_offset(uint8_t instance,
                                                          float max_offset)
{
    _imu._accel_max_abs_offsets[instance] = max_offset;
}

// increment accelerometer error_count
void AP_InertialSensor_Backend::_inc_accel_error_count(uint8_t instance)
{
    _imu._accel_error_count[instance]++;
}

// increment gyro error_count
void AP_InertialSensor_Backend::_inc_gyro_error_count(uint8_t instance)
{
    _imu._gyro_error_count[instance]++;
}

/*
  publish a temperature value for an instance
 */
void AP_InertialSensor_Backend::_publish_temperature(uint8_t instance, float temperature) /* front end */
{
    if (has_been_killed(instance)) {
        return;
    }
    _imu._temperature[instance] = temperature;

#if HAL_HAVE_IMU_HEATER
    /* give the temperature to the control loop in order to keep it constant*/
    if (instance == AP_HEATER_IMU_INSTANCE) {
        AP_BoardConfig *bc = AP::boardConfig();
        if (bc) {
            bc->set_imu_temp(temperature);
        }
    }
#endif
}

/*
  common gyro update function for all backends
 */
void AP_InertialSensor_Backend::update_gyro(uint8_t instance) /* front end */
{    
    WITH_SEMAPHORE(_sem);

    if (has_been_killed(instance)) {
        return;
    }
    if (_imu._new_gyro_data[instance]) {
        _publish_gyro(instance, _imu._gyro_filtered[instance]);
#if HAL_GYROFFT_ENABLED
        // copy the gyro samples from the backend to the frontend window for FFTs sampling at less than IMU rate
        _imu._gyro_for_fft[instance] = _imu._last_gyro_for_fft[instance];
#endif
        _imu._new_gyro_data[instance] = false;
    }

    // possibly update filter frequency
    const float gyro_rate = _gyro_raw_sample_rate(instance);

    if (_last_gyro_filter_hz != _gyro_filter_cutoff() || sensors_converging()) {
        _imu._gyro_filter[instance].set_cutoff_frequency(gyro_rate, _gyro_filter_cutoff());
#if HAL_GYROFFT_ENABLED
        _imu._post_filter_gyro_filter[instance].set_cutoff_frequency(gyro_rate, _gyro_filter_cutoff());
#endif
        _last_gyro_filter_hz = _gyro_filter_cutoff();
    }

#if AP_INERTIALSENSOR_HARMONICNOTCH_ENABLED
    for (auto &notch : _imu.harmonic_notches) {
        if (notch.params.enabled()) {
            notch.update_params(instance, sensors_converging(), gyro_rate);
        }
    }
#endif
}

/*
  common accel update function for all backends
 */
void AP_InertialSensor_Backend::update_accel(uint8_t instance) /* front end */
{    
    WITH_SEMAPHORE(_sem);

    if (has_been_killed(instance)) {
        return;
    }
    if (_imu._new_accel_data[instance]) {
        _publish_accel(instance, _imu._accel_filtered[instance]);
        _imu._new_accel_data[instance] = false;
    }
    
    // possibly update filter frequency
    if (_last_accel_filter_hz != _accel_filter_cutoff()) {
        _imu._accel_filter[instance].set_cutoff_frequency(_accel_raw_sample_rate(instance), _accel_filter_cutoff());
        _last_accel_filter_hz = _accel_filter_cutoff();
    }
}

#if HAL_LOGGING_ENABLED
bool AP_InertialSensor_Backend::should_log_imu_raw() const
{
    if (_imu._log_raw_bit == (uint32_t)-1) {
        // tracker does not set a bit
        return false;
    }
    const AP_Logger *logger = AP_Logger::get_singleton();
    if (logger == nullptr) {
        return false;
    }
    if (!logger->should_log(_imu._log_raw_bit)) {
        return false;
    }
    return true;
}
#endif  // HAL_LOGGING_ENABLED

// log an unexpected change in a register for an IMU
void AP_InertialSensor_Backend::log_register_change(uint32_t bus_id, const AP_HAL::Device::checkreg &reg)
{
#if HAL_LOGGING_ENABLED
    AP::logger().Write("IREG", "TimeUS,DevID,Bank,Reg,Val", "QIBBB",
                       AP_HAL::micros64(),
                       bus_id,
                       reg.bank,
                       reg.regnum,
                       reg.value);
#endif
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            // ECUPackets.h was generated by ProtoGen version 3.2.a

/*
 * This file is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This file is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Author: Oliver Walters / Currawong Engineering Pty Ltd
 */
 

#ifndef _ECUPACKETS_H
#define _ECUPACKETS_H

// Language target is C, C++ compilers: don't mangle us
#ifdef __cplusplus
extern "C" {
#endif

/*!
 * \file
 */

#include <stdbool.h>
#include "ECUProtocol.h"
#include "ECUDefines.h"
#include "ECUSettings.h"

/*!
 * The throttle command packet sets the throttle position setpoint. The ECU
 * will adjust the throttle position based on this command.
 */
typedef struct
{
    float throttleCommand; //!< Commanded throttle position in percent
}ECU_ThrottleCommand_t;

//! Create the ECU_ThrottleCommand packet from parameters
void encodeECU_ThrottleCommandPacket(void* pkt, float throttleCommand);

//! Decode the ECU_ThrottleCommand packet to parameters
int decodeECU_ThrottleCommandPacket(const void* pkt, float* throttleCommand);

//! return the packet ID for the ECU_ThrottleCommand packet
#define getECU_ThrottleCommandPacketID() (PKT_ECU_THROTTLE)

//! return the minimum encoded length for the ECU_ThrottleCommand packet
#define getECU_ThrottleCommandMinDataLength() (2)

//! return the maximum encoded length for the ECU_ThrottleCommand packet
#define getECU_ThrottleCommandMaxDataLength() (2)

/*!
 * The RPM command is used to send a target to the RPM governor on the ECU.
 * Based on this command, the ECU will use a feedback loop to maintain the
 * commanded engine speed by adjusting the throttle servo accordingly. If a
 * valid RPM command is received by the ECU, it will automatically enter RPM
 * control mode, and adjust the throttle position to match the desired RPM.
 * Sending a throttle command will cause the ECU to stop the RPM loop and enter
 * open-loop throttle control mode.
 */
typedef struct
{
    uint16_t rpmCmd;     //!< Engine speed command in revolutions per minute
    uint8_t  rpmCmdHigh; //!< RPM command in units of 50 RPM
    uint8_t  rpmCmdLow;  //!< Low part of RPM command from 0 to 49
}ECU_RPMCommand_t;

//! Create the ECU_RPMCommand packet
void encodeECU_RPMCommandPacketStructure(void* pkt, const ECU_RPMCommand_t* user);

//! Decode the ECU_RPMCommand packet
int decodeECU_RPMCommandPacketStructure(const void* pkt, ECU_RPMCommand_t* user);

//! return the packet ID for the ECU_RPMCommand packet
#define getECU_RPMCommandPacketID() (PKT_ECU_RPM_COMMAND)

//! return the minimum encoded length for the ECU_RPMCommand packet
#define getECU_RPMCommandMinDataLength() (2)

//! return the maximum encoded length for the ECU_RPMCommand packet
#define getECU_RPMCommandMaxDataLength() (2)

typedef struct
{
    bool driverPin8;      //!< 1 if driver 8 is on
    bool driverPin7;      //!< 1 if driver 7 is on
    bool driverPin2;      //!< 1 if driver 2 is on
    bool driverPin1;      //!< 1 if driver 1 is on
    bool throttleCurveOn; //!< 1 if the throttle curve is on.
    bool rs232mode;       //!< 1 if autronic, else auxiliary.
    bool errorIndicator;  //!< 1 if any errors are set - refer to [error packet](#PKT_ECU_ERROR_MSG)
    bool enabled;         //!< Global enable based on physical input
}ECU_ecuStatusBits_t;

/*!
 * Fast telemetry contains high priority telemetry data and is transmitted at a
 * user configurable period between 50ms (20Hz) and 10s. By default, the fast
 * telemetry message is transmitted at 10Hz (every 100ms)
 */
typedef struct
{
    float               throttle;      //!< Throttle signal (0 to 100%)
    uint16_t            rpm;           //!< Engine speed in revolutions per minute
    uint32_t            fuelUsed;      //!< Fuel used in grams
    ECU_ecuStatusBits_t ecuStatusBits;
}ECU_TelemetryFast_t;

//! Encode a ECU_ecuStatusBits_t into a byte array
void encodeECU_ecuStatusBits_t(uint8_t* data, int* bytecount, const ECU_ecuStatusBits_t* user);

//! Decode a ECU_ecuStatusBits_t from a byte array
int decodeECU_ecuStatusBits_t(const uint8_t* data, int* bytecount, ECU_ecuStatusBits_t* user);

//! Create the ECU_TelemetryFast packet
void encodeECU_TelemetryFastPacketStructure(void* pkt, const ECU_TelemetryFast_t* user);

//! Decode the ECU_TelemetryFast packet
int decodeECU_TelemetryFastPacketStructure(const void* pkt, ECU_TelemetryFast_t* user);

//! Create the ECU_TelemetryFast packet from parameters
void encodeECU_TelemetryFastPacket(void* pkt, float throttle, uint16_t rpm, uint32_t fuelUsed, const ECU_ecuStatusBits_t* ecuStatusBits);

//! Decode the ECU_TelemetryFast packet to parameters
int decodeECU_TelemetryFastPacket(const void* pkt, float* throttle, uint16_t* rpm, uint32_t* fuelUsed, ECU_ecuStatusBits_t* ecuStatusBits);

//! return the packet ID for the ECU_TelemetryFast packet
#define getECU_TelemetryFastPacketID() (PKT_ECU_TELEMETRY_FAST)

//! return the minimum encoded length for the ECU_TelemetryFast packet
#define getECU_TelemetryFastMinDataLength() (8)

//! return the maximum encoded length for the ECU_TelemetryFast packet
#define getECU_TelemetryFastMaxDataLength() (8)

/*!
 * This is the first of three slower telemetry packets which are transmitted by
 * the ECU at a user customizable period (between 0.5s and 10.0s). These three
 * packets contain data that is not likely to change as quickly as the data in
 * the fast telemetry packet. By default, the slow telemetry messages are
 * transmitted at 1Hz (period of 1.0s).
 */
typedef struct
{
    uint16_t          rpmCmd;        //!< The reconstructed RPM command
    float             map;           //!< The reconstructed manifold pressure in kilo-Pascals
    ECUThrottleSource throttleSrc;   //!< Source of the throttle information
    uint16_t          throttlePulse; //!< Throttle pulse width in microseconds
    float             cht;           //!< Cylinder head temperature in Celsius
    float             baro;          //!< Barometric pressure in kilo-Pascals
}ECU_TelemetrySlow0_t;

//! Create the ECU_TelemetrySlow0 packet
void encodeECU_TelemetrySlow0PacketStructure(void* pkt, const ECU_TelemetrySlow0_t* user);

//! Decode the ECU_TelemetrySlow0 packet
int decodeECU_TelemetrySlow0PacketStructure(const void* pkt, ECU_TelemetrySlow0_t* user);

//! return the packet ID for the ECU_TelemetrySlow0 packet
#define getECU_TelemetrySlow0PacketID() (PKT_ECU_TELEMETRY_SLOW_0)

//! return the minimum encoded length for the ECU_TelemetrySlow0 packet
#define getECU_TelemetrySlow0MinDataLength() (8)

//! return the maximum encoded length for the ECU_TelemetrySlow0 packet
#define getECU_TelemetrySlow0MaxDataLength() (8)

/*!
 * ECU RPM governor mode enumeration
 */
typedef enum
{
    ECU_GOV_MODE_NONE,   //!< RPM governor is off
    ECU_GOV_MODE_THROTTLE,//!< RPM governer setpoint is based on throttle input
    ECU_GOV_MODE_DIRECT  //!< RPM governor setpoint comes from direct command
} ECUGovernorMode;

/*!
 * The second of three slow telemetry packets
 */
typedef struct
{
    float           mat;          //!< Inlet air temperature in Celsius
    float           fuelPressure; //!< Fuel pressure in kilo-Pascals
    uint32_t        hobbs;        //!< Engine run time in seconds.
    float           voltage;      //!< Input voltage in Volts
    ECUGovernorMode governorMode; //!< Operational mode of the governor
}ECU_TelemetrySlow1_t;

//! Create the ECU_TelemetrySlow1 packet
void encodeECU_TelemetrySlow1PacketStructure(void* pkt, const ECU_TelemetrySlow1_t* user);

//! Decode the ECU_TelemetrySlow1 packet
int decodeECU_TelemetrySlow1PacketStructure(const void* pkt, ECU_TelemetrySlow1_t* user);

//! return the packet ID for the ECU_TelemetrySlow1 packet
#define getECU_TelemetrySlow1PacketID() (PKT_ECU_TELEMETRY_SLOW_1)

//! return the minimum encoded length for the ECU_TelemetrySlow1 packet
#define getECU_TelemetrySlow1MinDataLength() (8)

//! return the maximum encoded length for the ECU_TelemetrySlow1 packet
#define getECU_TelemetrySlow1MaxDataLength() (8)

/*!
 * The third of three slow telemetry packets
 */
typedef struct
{
    float cpuLoad;      //!< CPU load in percent
    float chargeTemp;   //!< Charge temperature in Celsius
    float injectorDuty; //!< Injector duty cycle in percent
    float ignAngle1;    //!< First ignition advance angle in degrees
    float ignAngle2;    //!< Second ignition advance angle in degrees
    float flowRate;     //!< Fuel flow rate in grams per minute
}ECU_TelemetrySlow2_t;

//! Create the ECU_TelemetrySlow2 packet
void encodeECU_TelemetrySlow2PacketStructure(void* pkt, const ECU_TelemetrySlow2_t* user);

//! Decode the ECU_TelemetrySlow2 packet
int decodeECU_TelemetrySlow2PacketStructure(const void* pkt, ECU_TelemetrySlow2_t* user);

//! return the packet ID for the ECU_TelemetrySlow2 packet
#define getECU_TelemetrySlow2PacketID() (PKT_ECU_TELEMETRY_SLOW_2)

//! return the minimum encoded length for the ECU_TelemetrySlow2 packet
#define getECU_TelemetrySlow2MinDataLength() (8)

//! return the maximum encoded length for the ECU_TelemetrySlow2 packet
#define getECU_TelemetrySlow2MaxDataLength() (8)

/*!
 * Enumeration of auxiliary to autronic serial relay states. Autronic relay is
 * an advanced feature used to allow simultaneous connection of the Autronic
 * ECUCal software and the auxiliary processor. Autronic relay should only be
 * needed for engine development.
 */
typedef enum
{
    AUT_RELAY_OFF,   //!< Relay is disengaged, 19200 autronic interface rate; must use calibration switch to connect to Autronic
    AUT_RELAY_PENDING,//!< Relay enabled but not detected, 19200 autronic and external serial interface rate
    AUT_RELAY_ON     //!< Relay detected, 38400 autronic and external serial interface rate
} ECUAutronicRelayState;

/*!
 * The hardware config packet contains the ECU serial number and various ECU
 * configuration data. Send a zero length packet to request this data.
 */
typedef struct
{
    uint16_t              serialNumber;         //!< ECU serial number
    uint16_t              fuelDivisor;          //!< Fuel used divisior. If the divisor is greater than 100 then it is interpreted as units of 0.01 (for a higher resolution fuel calibration)
    ECUAutronicRelayState relayState;           //!< Autronic relay state. This is a volatile status which will reset to AUT_RELAY_OFF on ECU power cycle.
    bool                  resetFuelUsedOnStart; //!< Set if the fuel used value is reset each on each ECU power cycle
}ECU_HardwareConfig_t;

//! Create the ECU_HardwareConfig packet
void encodeECU_HardwareConfigPacketStructure(void* pkt, const ECU_HardwareConfig_t* user);

//! Decode the ECU_HardwareConfig packet
int decodeECU_HardwareConfigPacketStructure(const void* pkt, ECU_HardwareConfig_t* user);

//! return the packet ID for the ECU_HardwareConfig packet
#define getECU_HardwareConfigPacketID() (PKT_ECU_HARDWARE_CONFIG)

//! return the minimum encoded length for the ECU_HardwareConfig packet
#define getECU_HardwareConfigMinDataLength() (5)

//! return the maximum encoded length for the ECU_HardwareConfig packet
#define getECU_HardwareConfigMaxDataLength() (5)

/*!
 * The software version packet contains the auxiliary processor firmware
 * version information. Send a zero length packet to request this data.
 */
typedef struct
{
    bool     release;          //!< 1 = Release version, 0 = Testing version
    unsigned versionMajor : 6; //!< Major version number
    uint8_t  versionMinor;     //!< Minor version number
    uint8_t  versionRev;       //!< Revision number
    uint8_t  month;            //!< The release month from 1 (January) to 12 (December)
    uint8_t  day;              //!< The release day of month from 1 to 31
    uint16_t year;             //!< The release year
    uint16_t checksum;         //!< Firmware checksum
}ECU_Version_t;

//! Create the ECU_Version packet
void encodeECU_VersionPacketStructure(void* pkt, const ECU_Version_t* user);

//! Decode the ECU_Version packet
int decodeECU_VersionPacketStructure(const void* pkt, ECU_Version_t* user);

//! return the packet ID for the ECU_Version packet
#define getECU_VersionPacketID() (PKT_ECU_SOFTWARE_VERSION)

//! return the minimum encoded length for the ECU_Version packet
#define getECU_VersionMinDataLength() (8)

//! return the maximum encoded length for the ECU_Version packet
#define getECU_VersionMaxDataLength() (8)

/*!
 * The errors packet contains error status information for the ECU. If any
 * error bits are set, then the global error bit in the [fast
 * telemetry](#PKT_ECU_TELEMETRY_FAST) packet will also be set. Send a zero
 * length packet to request this data.
 */
typedef struct
{
    ECU_AutronicErrorBits_t  autronicErrors;  //!< Error bits for the Autronic processor
    ECU_AuxiliaryErrorBits_t auxiliaryErrors; //!< Error bits for the auxiliary processor
}ECU_Errors_t;

//! Create the ECU_Errors packet
void encodeECU_ErrorsPacketStructure(void* pkt, const ECU_Errors_t* user);

//! Decode the ECU_Errors packet
int decodeECU_ErrorsPacketStructure(const void* pkt, ECU_Errors_t* user);

//! return the packet ID for the ECU_Errors packet
#define getECU_ErrorsPacketID() (PKT_ECU_ERROR_MSG)

//! return the minimum encoded length for the ECU_Errors packet
#define getECU_ErrorsMinDataLength() (8)

//! return the maximum encoded length for the ECU_Errors packet
#define getECU_ErrorsMaxDataLength() (8)

/*!
 * The power cycles packet contains information on the reset condition of the
 * ECU. Send a zero length packet to request this data.
 */
typedef struct
{
    uint16_t powerCycles; //!< Number of power cycles
    uint8_t  reserved;   
    uint8_t  resetCode;   //!< Auxiliary processor reset code
    uint32_t systemTime;  //!< Milliseconds since system reset
}ECU_PowerCycles_t;

//! Create the ECU_PowerCycles packet
void encodeECU_PowerCyclesPacketStructure(void* pkt, const ECU_PowerCycles_t* user);

//! Decode the ECU_PowerCycles packet
int decodeECU_PowerCyclesPacketStructure(const void* pkt, ECU_PowerCycles_t* user);

//! return the packet ID for the ECU_PowerCycles packet
#define getECU_PowerCyclesPacketID() (PKT_ECU_POWER_CYCLES)

//! return the minimum encoded length for the ECU_PowerCycles packet
#define getECU_PowerCyclesMinDataLength() (8)

//! return the maximum encoded length for the ECU_PowerCycles packet
#define getECU_PowerCyclesMaxDataLength() (8)

/*!
 * The fuel pump debug packet contains information on the pump control system.
 * Send a zero length packet to request this data.
 */
typedef struct
{
    float pTerm;        //!< Proportional term of the pump feedback control in percent
    float iTerm;        //!< Integral term of the pump feedback control in percent
    float dutyCycle;    //!< Pump duty cycle in percent
    float fuelPressure; //!< Fuel pressure in kilo-Pascals
}ECU_PumpDebug_t;

//! Create the ECU_PumpDebug packet
void encodeECU_PumpDebugPacketStructure(void* pkt, const ECU_PumpDebug_t* user);

//! Decode the ECU_PumpDebug packet
int decodeECU_PumpDebugPacketStructure(const void* pkt, ECU_PumpDebug_t* user);

//! return the packet ID for the ECU_PumpDebug packet
#define getECU_PumpDebugPacketID() (PKT_ECU_PUMP_DEBUG)

//! return the minimum encoded length for the ECU_PumpDebug packet
#define getECU_PumpDebugMinDataLength() (8)

//! return the maximum encoded length for the ECU_PumpDebug packet
#define getECU_PumpDebugMaxDataLength() (8)

/*!
 * While the engine time contained in the ECU telemetry packet can be reset by
 * the user, the ECU also stores the total engine time, which cannot be reset
 * by the user. Send a zero length packet to request this data.
 */
typedef struct
{
    uint32_t hobbs; //!< Total engine run time in seconds
}ECU_TotalEngineTime_t;

//! Create the ECU_TotalEngineTime packet from parameters
void encodeECU_TotalEngineTimePacket(void* pkt, uint32_t hobbs);

//! Decode the ECU_TotalEngineTime packet to parameters
int decodeECU_TotalEngineTimePacket(const void* pkt, uint32_t* hobbs);

//! return the packet ID for the ECU_TotalEngineTime packet
#define getECU_TotalEngineTimePacketID() (PKT_ECU_TOTAL_ENGINE_TIME)

//! return the minimum encoded length for the ECU_TotalEngineTime packet
#define getECU_TotalEngineTimeMinDataLength() (3)

//! return the maximum encoded length for the ECU_TotalEngineTime packet
#define getECU_TotalEngineTimeMaxDataLength() (3)

/*!
 * The eeprom settings packet contains information on the non-volatile ECU
 * settings stored in eeprom. In particular, it provides a checksum of the
 * settings data for easy comparison of settings between different ECUs. Send a
 * zero length packet to request this data.
 */
typedef struct
{
    uint8_t              eepromVersion;  //!< Version of the EEPROM data
    uint16_t             eepromSize;     //!< Number of bytes of the EEPROM data
    uint16_t             eepromChecksum; //!< Fletcher's checksum of the EEPROM data
    ECU_CompileOptions_t compileOptions; //!< ECU compilation options
}ECU_eepromSettings_t;

//! Create the ECU_eepromSettings packet
void encodeECU_eepromSettingsPacketStructure(void* pkt, const ECU_eepromSettings_t* user);

//! Decode the ECU_eepromSettings packet
int decodeECU_eepromSettingsPacketStructure(const void* pkt, ECU_eepromSettings_t* user);

//! Create the ECU_eepromSettings packet from parameters
void encodeECU_eepromSettingsPacket(void* pkt, uint8_t eepromVersion, uint16_t eepromSize, uint16_t eepromChecksum, const ECU_CompileOptions_t* compileOptions);

//! Decode the ECU_eepromSettings packet to parameters
int decodeECU_eepromSettingsPacket(const void* pkt, uint8_t* eepromVersion, uint16_t* eepromSize, uint16_t* eepromChecksum, ECU_CompileOptions_t* compileOptions);

//! return the packet ID for the ECU_eepromSettings packet
#define getECU_eepromSettingsPacketID() (PKT_ECU_SETTINGS_DATA)

//! return the minimum encoded length for the ECU_eepromSettings packet
#define getECU_eepromSettingsMinDataLength() (7)

//! return the maximum encoded length for the ECU_eepromSettings packet
#define getECU_eepromSettingsMaxDataLength() (7)

/*!
 * Control loop settings for the CHT control loop
 */
typedef struct
{
    uint8_t dTermFilter; //!< Filter value for derivative term
    bool    enabled;     //!< CHT control loop enabled
    uint8_t targetTemp;  //!< Target CHT temperature
    float   Kp;          //!< Proportaional gain Kp
    float   Ki;          //!< Proportaional gain Ki
    float   Kd;          //!< Proportaional gain Kd
}ECU_CHTLoopSettings_t;

//! Create the ECU_CHTLoopSettings packet
void encodeECU_CHTLoopSettingsPacketStructure(void* pkt, const ECU_CHTLoopSettings_t* user);

//! Decode the ECU_CHTLoopSettings packet
int decodeECU_CHTLoopSettingsPacketStructure(const void* pkt, ECU_CHTLoopSettings_t* user);

//! Create the ECU_CHTLoopSettings packet from parameters
void encodeECU_CHTLoopSettingsPacket(void* pkt, uint8_t dTermFilter, bool enabled, uint8_t targetTemp, float Kp, float Ki, float Kd);

//! Decode the ECU_CHTLoopSettings packet to parameters
int decodeECU_CHTLoopSettingsPacket(const void* pkt, uint8_t* dTermFilter, bool* enabled, uint8_t* targetTemp, float* Kp, float* Ki, float* Kd);

//! return the packet ID for the ECU_CHTLoopSettings packet
#define getECU_CHTLoopSettingsPacketID() (PKT_ECU_CHT_LOOP)

//! return the minimum encoded length for the ECU_CHTLoopSettings packet
#define getECU_CHTLoopSettingsMinDataLength() (8)

//! return the maximum encoded length for the ECU_CHTLoopSettings packet
#define getECU_CHTLoopSettingsMaxDataLength() (8)

/*!
 * Dual pump control telemetry. Send a zero-length packet with this identifier
 * to the ECU to poll (request) this packet.
 */
typedef struct
{
    uint8_t  mode;       //!< Current pump mode (which pump is running). Refer to the DualFuelPumpMode enumeration.
    uint8_t  state;      //!< Current pump state machine state. Refer to the DualFuelPumpState enumeration.
    uint16_t stateTimer; //!< Time spent in current state
}ECU_DualPumpControlTelemetry_t;

//! Create the ECU_DualPumpControlTelemetry packet
void encodeECU_DualPumpControlTelemetryPacketStructure(void* pkt, const ECU_DualPumpControlTelemetry_t* user);

//! Decode the ECU_DualPumpControlTelemetry packet
int decodeECU_DualPumpControlTelemetryPacketStructure(const void* pkt, ECU_DualPumpControlTelemetry_t* user);

//! return the packet ID for the ECU_DualPumpControlTelemetry packet
#define getECU_DualPumpControlTelemetryPacketID() (0x08)

//! return the minimum encoded length for the ECU_DualPumpControlTelemetry packet
#define getECU_DualPumpControlTelemetryMinDataLength() (4)

//! return the maximum encoded length for the ECU_DualPumpControlTelemetry packet
#define getECU_DualPumpControlTelemetryMaxDataLength() (4)

/*!
 * Set the telemetry period for dual-pump messages
 */
typedef struct
{
    uint8_t period; //!< Telemetry period (0 = Off)
}ECU_DualPump_SetTelemetryPeriod_t;

//! Create the ECU_DualPump_SetTelemetryPeriod packet from parameters
void encodeECU_DualPump_SetTelemetryPeriodPacket(void* pkt, uint8_t period);

//! Decode the ECU_DualPump_SetTelemetryPeriod packet to parameters
int decodeECU_DualPump_SetTelemetryPeriodPacket(const void* pkt, uint8_t* period);

//! return the packet ID for the ECU_DualPump_SetTelemetryPeriod packet
#define getECU_DualPump_SetTelemetryPeriodPacketID() (0x08)

//! return the minimum encoded length for the ECU_DualPump_SetTelemetryPeriod packet
#define getECU_DualPump_SetTelemetryPeriodMinDataLength() (2)

//! return the maximum encoded length for the ECU_DualPump_SetTelemetryPeriod packet
#define getECU_DualPump_SetTelemetryPeriodMaxDataLength() (2)

/*!
 * Command to manually select a given pump mode.
 */
typedef struct
{
    uint8_t pump; //!< Pump selection (see DualFuelPumpMode enumeration)
}ECU_DualPump_SelectPump_t;

//! Create the ECU_DualPump_SelectPump packet from parameters
void encodeECU_DualPump_SelectPumpPacket(void* pkt, uint8_t pump);

//! Decode the ECU_DualPump_SelectPump packet to parameters
int decodeECU_DualPump_SelectPumpPacket(const void* pkt, uint8_t* pump);

//! return the packet ID for the ECU_DualPump_SelectPump packet
#define getECU_DualPump_SelectPumpPacketID() (0x08)

//! return the minimum encoded length for the ECU_DualPump_SelectPump packet
#define getECU_DualPump_SelectPumpMinDataLength() (3)

//! return the maximum encoded length for the ECU_DualPump_SelectPump packet
#define getECU_DualPump_SelectPumpMaxDataLength() (3)

/*!
 * Command to temporarily run a particular pump in test mode. ECU will revert
 * to OTHER pump when test expires
 */
typedef struct
{
    uint8_t pump;    //!< Pump selection (see DualFuelPumpMode enumeration)
    uint8_t timeout; //!< Test timeout
}ECU_DualPump_TestPump_t;

//! Create the ECU_DualPump_TestPump packet
void encodeECU_DualPump_TestPumpPacketStructure(void* pkt, const ECU_DualPump_TestPump_t* user);

//! Decode the ECU_DualPump_TestPump packet
int decodeECU_DualPump_TestPumpPacketStructure(const void* pkt, ECU_DualPump_TestPump_t* user);

//! return the packet ID for the ECU_DualPump_TestPump packet
#define getECU_DualPump_TestPumpPacketID() (0x08)

//! return the minimum encoded length for the ECU_DualPump_TestPump packet
#define getECU_DualPump_TestPumpMinDataLength() (3)

//! return the maximum encoded length for the ECU_DualPump_TestPump packet
#define getECU_DualPump_TestPumpMaxDataLength() (4)

//! Create the ECU_ThrottleCalibration packet
void encodeECU_ThrottleCalibrationPacketStructure(void* pkt, const ECU_ThrottleSettings_t* user);

//! Decode the ECU_ThrottleCalibration packet
int decodeECU_ThrottleCalibrationPacketStructure(const void* pkt, ECU_ThrottleSettings_t* user);

//! Create the ECU_ThrottleCalibration packet from parameters
void encodeECU_ThrottleCalibrationPacket(void* pkt, uint16_t pulseClosed, uint16_t pulseOpen, const ECU_ThrottleConfigBits_t* config, uint16_t pulseInputClosed, uint16_t pulseInputOpen);

//! Decode the ECU_ThrottleCalibration packet to parameters
int decodeECU_ThrottleCalibrationPacket(const void* pkt, uint16_t* pulseClosed, uint16_t* pulseOpen, ECU_ThrottleConfigBits_t* config, uint16_t* pulseInputClosed, uint16_t* pulseInputOpen);

//! return the packet ID for the ECU_ThrottleCalibration packet
#define getECU_ThrottleCalibrationPacketID() (PKT_ECU_THROTTLE_CALIBRATION)

//! return the minimum encoded length for the ECU_ThrottleCalibration packet
#define getECU_ThrottleCalibrationMinDataLength() (8)

//! return the maximum encoded length for the ECU_ThrottleCalibration packet
#define getECU_ThrottleCalibrationMaxDataLength() (8)

//! Create the ECU_RPMLoopCalibration packet
void encodeECU_RPMLoopCalibrationPacketStructure(void* pkt, const ECU_GovernorSettings_t* user);

//! Decode the ECU_RPMLoopCalibration packet
int decodeECU_RPMLoopCalibrationPacketStructure(const void* pkt, ECU_GovernorSettings_t* user);

//! return the packet ID for the ECU_RPMLoopCalibration packet
#define getECU_RPMLoopCalibrationPacketID() (PKT_ECU_RPM_CALIBRATION)

//! return the minimum encoded length for the ECU_RPMLoopCalibration packet
#define getECU_RPMLoopCalibrationMinDataLength() (8)

//! return the maximum encoded length for the ECU_RPMLoopCalibration packet
#define getECU_RPMLoopCalibrationMaxDataLength() (8)

//! Create the ECU_TPSDelayCalibration packet
void encodeECU_TPSDelayCalibrationPacketStructure(void* pkt, const ECU_ThrottleSettings_t* user);

//! Decode the ECU_TPSDelayCalibration packet
int decodeECU_TPSDelayCalibrationPacketStructure(const void* pkt, ECU_ThrottleSettings_t* user);

//! Create the ECU_TPSDelayCalibration packet from parameters
void encodeECU_TPSDelayCalibrationPacket(void* pkt, uint8_t delay, const ECU_ThrottleDelayConfigBits_t* delayConfig, uint8_t maxDelay, uint8_t minDelay, uint8_t softLimit, uint8_t falloffRate, uint8_t throttleTarget, uint8_t hardLimit);

//! Decode the ECU_TPSDelayCalibration packet to parameters
int decodeECU_TPSDelayCalibrationPacket(const void* pkt, uint8_t* delay, ECU_ThrottleDelayConfigBits_t* delayConfig, uint8_t* maxDelay, uint8_t* minDelay, uint8_t* softLimit, uint8_t* falloffRate, uint8_t* throttleTarget, uint8_t* hardLimit);

//! return the packet ID for the ECU_TPSDelayCalibration packet
#define getECU_TPSDelayCalibrationPacketID() (PKT_ECU_TPS_DELAY_CONFIG)

//! return the minimum encoded length for the ECU_TPSDelayCalibration packet
#define getECU_TPSDelayCalibrationMinDataLength() (8)

//! return the maximum encoded length for the ECU_TPSDelayCalibration packet
#define getECU_TPSDelayCalibrationMaxDataLength() (8)

/*!
 * The telmetry settings packet is used to configure the telemetry data rates
 * for the ECU. The ECU will echo the packet as confirmation of its receipt.
 * Send a zero length packet to request the current settings.
 */
typedef struct
{
    uint8_t fastTelemetryPeriod; //!< Time between fast telemetry packets in 50ms increments
    uint8_t slowTelemetryPeriod; //!< Time between slow telemetry packets in 500ms increments
    uint8_t silencePeriod;       //!< Seconds of time the ECU waits after bootup before sending telemetry.
}ECU_TelemetrySettings_t;

//! Create the ECU_TelemetrySettings packet
void encodeECU_TelemetrySettingsPacketStructure(void* pkt, const ECU_TelemetrySettings_t* user);

//! Decode the ECU_TelemetrySettings packet
int decodeECU_TelemetrySettingsPacketStructure(const void* pkt, ECU_TelemetrySettings_t* user);

//! return the packet ID for the ECU_TelemetrySettings packet
#define getECU_TelemetrySettingsPacketID() (PKT_ECU_TELEMETRY_SETTINGS)

//! return the minimum encoded length for the ECU_TelemetrySettings packet
#define getECU_TelemetrySettingsMinDataLength() (3)

//! return the maximum encoded length for the ECU_TelemetrySettings packet
#define getECU_TelemetrySettingsMaxDataLength() (3)

//! Create the ECU_PumpConfig packet
void encodeECU_PumpConfigPacketStructure(void* pkt, const ECU_PumpSettings_t* user);

//! Decode the ECU_PumpConfig packet
int decodeECU_PumpConfigPacketStructure(const void* pkt, ECU_PumpSettings_t* user);

//! return the packet ID for the ECU_PumpConfig packet
#define getECU_PumpConfigPacketID() (PKT_ECU_PUMP_CONFIG)

//! return the minimum encoded length for the ECU_PumpConfig packet
#define getECU_PumpConfigMinDataLength() (8)

//! return the maximum encoded length for the ECU_PumpConfig packet
#define getECU_PumpConfigMaxDataLength() (8)

//! Create the ECU_Pump2Config packet
void encodeECU_Pump2ConfigPacketStructure(void* pkt, const ECU_PumpSettings_t* user);

//! Decode the ECU_Pump2Config packet
int decodeECU_Pump2ConfigPacketStructure(const void* pkt, ECU_PumpSettings_t* user);

//! return the packet ID for the ECU_Pump2Config packet
#define getECU_Pump2ConfigPacketID() (PKT_ECU_PUMP_2_CONFIG)

//! return the minimum encoded length for the ECU_Pump2Config packet
#define getECU_Pump2ConfigMinDataLength() (7)

//! return the maximum encoded length for the ECU_Pump2Config packet
#define getECU_Pump2ConfigMaxDataLength() (7)

/*!
 * The user data packet provides the user with 8 (eight) bytes of data for
 * storing custom parameters or settings in ECU EEPROM (non-volatile) memory.
 * The ECU does not make use of these values; they are simply for storing user
 * data. Send a zero length packet to request the current settings. To set
 * these values send the system command SET_USER_DATA. Data values must be set
 * individually.
 */
typedef struct
{
    uint8_t userData[8]; //!< 8 bytes of user data
}ECU_UserData_t;

//! Create the ECU_UserData packet from parameters
void encodeECU_UserDataPacket(void* pkt, const uint8_t userData[8]);

//! Decode the ECU_UserData packet to parameters
int decodeECU_UserDataPacket(const void* pkt, uint8_t userData[8]);

//! return the packet ID for the ECU_UserData packet
#define getECU_UserDataPacketID() (PKT_ECU_USER_DATA)

//! return the minimum encoded length for the ECU_UserData packet
#define getECU_UserDataMinDataLength() (8)

//! return the maximum encoded length for the ECU_UserData packet
#define getECU_UserDataMaxDataLength() (8)

/*!
 * First throttle curve packet, which contains the lower 6 term of the throttle
 * linearization table. To request the throttle curve data (both packets), send
 * the system command REQUEST_THROTTLE_CURVE_DATA. To change the throttle curve
 * data send the system command SET_THROTTLE_CURVE_ELEMENT.
 */
typedef struct
{
    float throttleCurve[6]; //!< Throttle output values for the lower 6 cells in the throttle lookup table
}ECU_ThrottleCurve_t;

//! Create the ECU_ThrottleCurve packet from parameters
void encodeECU_ThrottleCurvePacket(void* pkt, const float throttleCurve[6]);

//! Decode the ECU_ThrottleCurve packet to parameters
int decodeECU_ThrottleCurvePacket(const void* pkt, float throttleCurve[6]);

//! return the packet ID for the ECU_ThrottleCurve packet
#define getECU_ThrottleCurvePacketID() (PKT_ECU_THROTTLE_CURVE_0)

//! return the minimum encoded length for the ECU_ThrottleCurve packet
#define getECU_ThrottleCurveMinDataLength() (6)

//! return the maximum encoded length for the ECU_ThrottleCurve packet
#define getECU_ThrottleCurveMaxDataLength() (6)

//! Create the ECU_ThrottleCurve1 packet from parameters
void encodeECU_ThrottleCurve1Packet(void* pkt, const float throttleCurve[5]);

//! Decode the ECU_ThrottleCurve1 packet to parameters
int decodeECU_ThrottleCurve1Packet(const void* pkt, float throttleCurve[5]);

//! return the packet ID for the ECU_ThrottleCurve1 packet
#define getECU_ThrottleCurve1PacketID() (PKT_ECU_THROTTLE_CURVE_1)

//! return the minimum encoded length for the ECU_ThrottleCurve1 packet
#define getECU_ThrottleCurve1MinDataLength() (5)

//! return the maximum encoded length for the ECU_ThrottleCurve1 packet
#define getECU_ThrottleCurve1MaxDataLength() (5)

/*!
 * The system command packets follow the format provided below. Refer further
 * in the document for complete documentation on each system command packet.
 */
typedef struct
{
    ECUSystemCommands cmd;           //!< The command enumeration
    uint8_t           parambytes[3]; //!< Up to 3 parameter bytes for a system command
}ECU_SystemCommand_t;

//! Create the ECU_SystemCommand packet
void encodeECU_SystemCommandPacketStructure(void* pkt, const ECU_SystemCommand_t* user);

//! Decode the ECU_SystemCommand packet
int decodeECU_SystemCommandPacketStructure(const void* pkt, ECU_SystemCommand_t* user);

//! return the packet ID for the ECU_SystemCommand packet
#define getECU_SystemCommandPacketID() (PKT_ECU_SYS_CMD)

//! return the minimum encoded length for the ECU_SystemCommand packet
#define getECU_SystemCommandMinDataLength() (1)

//! return the maximum encoded length for the ECU_SystemCommand packet
#define getECU_SystemCommandMaxDataLength() (4)

/*!
 * Save the current value of the analog throttle position input as the 'Closed'
 * position. To calibrate the closed analog input position, set the desired
 * analog input level, and send this command to the ECU.
 */
typedef struct
{
    ECUSystemCommands cmd; //!< The command enumeration. Field is encoded constant.
}ECU_CalibrateAnalogClosed_t;

//! Create the ECU_CalibrateAnalogClosed packet from parameters
void encodeECU_CalibrateAnalogClosedPacket(void* pkt);

//! Decode the ECU_CalibrateAnalogClosed packet to parameters
int decodeECU_CalibrateAnalogClosedPacket(const void* pkt, ECUSystemCommands* cmd);

//! return the packet ID for the ECU_CalibrateAnalogClosed packet
#define getECU_CalibrateAnalogClosedPacketID() (PKT_ECU_SYS_CMD)

//! return the minimum encoded length for the ECU_CalibrateAnalogClosed packet
#define getECU_CalibrateAnalogClosedMinDataLength() (1)

//! return the maximum encoded length for the ECU_CalibrateAnalogClosed packet
#define getECU_CalibrateAnalogClosedMaxDataLength() (1)

/*!
 * Save the current value of the analog throttle position input as the 'Open'
 * position. To calibrate the open analog input position, set the desired
 * analog input level, and send this command to the ECU.
 */
typedef struct
{
    ECUSystemCommands cmd; //!< The command enumeration. Field is encoded constant.
}ECU_CalibrateAnalogOpen_t;

//! Create the ECU_CalibrateAnalogOpen packet from parameters
void encodeECU_CalibrateAnalogOpenPacket(void* pkt);

//! Decode the ECU_CalibrateAnalogOpen packet to parameters
int decodeECU_CalibrateAnalogOpenPacket(const void* pkt, ECUSystemCommands* cmd);

//! return the packet ID for the ECU_CalibrateAnalogOpen packet
#define getECU_CalibrateAnalogOpenPacketID() (PKT_ECU_SYS_CMD)

//! return the minimum encoded length for the ECU_CalibrateAnalogOpen packet
#define getECU_CalibrateAnalogOpenMinDataLength() (1)

//! return the maximum encoded length for the ECU_CalibrateAnalogOpen packet
#define getECU_CalibrateAnalogOpenMaxDataLength() (1)

/*!
 * Save the current value of the throttle output pulse width to a temporary
 * variable in the ECU. When the CALIBRATE_PULSE_WRITE command is sent to the
 * ECU, this value will be saved as the 'Closed' pulse width.
 */
typedef struct
{
    ECUSystemCommands cmd; //!< The command enumeration. Field is encoded constant.
}ECU_CalibratePulseClosed_t;

//! Create the ECU_CalibratePulseClosed packet from parameters
void encodeECU_CalibratePulseClosedPacket(void* pkt);

//! Decode the ECU_CalibratePulseClosed packet to parameters
int decodeECU_CalibratePulseClosedPacket(const void* pkt, ECUSystemCommands* cmd);

//! return the packet ID for the ECU_CalibratePulseClosed packet
#define getECU_CalibratePulseClosedPacketID() (PKT_ECU_SYS_CMD)

//! return the minimum encoded length for the ECU_CalibratePulseClosed packet
#define getECU_CalibratePulseClosedMinDataLength() (1)

//! return the maximum encoded length for the ECU_CalibratePulseClosed packet
#define getECU_CalibratePulseClosedMaxDataLength() (1)

/*!
 * Save the current value of the throttle output pulse width to a temporary
 * variable in the ECU. When the CALIBRATE_PULSE_WRITE command is sent to the
 * ECU, this value will be saved as the 'Open' pulse width.
 */
typedef struct
{
    ECUSystemCommands cmd; //!< The command enumeration. Field is encoded constant.
}ECU_CalibratePulseOpen_t;

//! Create the ECU_CalibratePulseOpen packet from parameters
void encodeECU_CalibratePulseOpenPacket(void* pkt);

//! Decode the ECU_CalibratePulseOpen packet to parameters
int decodeECU_CalibratePulseOpenPacket(const void* pkt, ECUSystemCommands* cmd);

//! return the packet ID for the ECU_CalibratePulseOpen packet
#define getECU_CalibratePulseOpenPacketID() (PKT_ECU_SYS_CMD)

//! return the minimum encoded length for the ECU_CalibratePulseOpen packet
#define getECU_CalibratePulseOpenMinDataLength() (1)

//! return the maximum encoded length for the ECU_CalibratePulseOpen packet
#define getECU_CalibratePulseOpenMaxDataLength() (1)

/*!
 * Configure the throttle output positions. The CALIBRATE_PULSE_CLOSED and
 * CALIBRATE_PULSE_OPEN commands should have already been sent to the ECU. The
 * ECU then saves the temporary values as the 'Closed' and 'Open' throttle
 * output values, respectively.
 */
typedef struct
{
    ECUSystemCommands cmd; //!< The command enumeration. Field is encoded constant.
}ECU_CalibratePulseWrite_t;

//! Create the ECU_CalibratePulseWrite packet from parameters
void encodeECU_CalibratePulseWritePacket(void* pkt);

//! Decode the ECU_CalibratePulseWrite packet to parameters
int decodeECU_CalibratePulseWritePacket(const void* pkt, ECUSystemCommands* cmd);

//! return the packet ID for the ECU_CalibratePulseWrite packet
#define getECU_CalibratePulseWritePacketID() (PKT_ECU_SYS_CMD)

//! return the minimum encoded length for the ECU_CalibratePulseWrite packet
#define getECU_CalibratePulseWriteMinDataLength() (1)

//! return the maximum encoded length for the ECU_CalibratePulseWrite packet
#define getECU_CalibratePulseWriteMaxDataLength() (1)

/*!
 * Set one of four high-current output drivers.
 */
typedef struct
{
    ECUSystemCommands cmd;    //!< The command enumeration. Field is encoded constant.
    uint8_t           driver; //!< Select driver number (1, 2, 3 or 4)
    uint8_t           status; //!< Set driver status (1 = ON, 0 = OFF)
}ECU_SetOutputDriver_t;

//! Create the ECU_SetOutputDriver packet from parameters
void encodeECU_SetOutputDriverPacket(void* pkt, uint8_t driver, uint8_t status);

//! Decode the ECU_SetOutputDriver packet to parameters
int decodeECU_SetOutputDriverPacket(const void* pkt, ECUSystemCommands* cmd, uint8_t* driver, uint8_t* status);

//! return the packet ID for the ECU_SetOutputDriver packet
#define getECU_SetOutputDriverPacketID() (PKT_ECU_SYS_CMD)

//! return the minimum encoded length for the ECU_SetOutputDriver packet
#define getECU_SetOutputDriverMinDataLength() (3)

//! return the maximum encoded length for the ECU_SetOutputDriver packet
#define getECU_SetOutputDriverMaxDataLength() (3)

/*!
 * Turn the throttle linearization curve either on or off.
 */
typedef struct
{
    ECUSystemCommands cmd;    //!< The command enumeration. Field is encoded constant.
    uint8_t           active; //!< Curve active (1 = ON, 0 = OFF)
}ECU_SetThrottleCurveActive_t;

//! Create the ECU_SetThrottleCurveActive packet from parameters
void encodeECU_SetThrottleCurveActivePacket(void* pkt, uint8_t active);

//! Decode the ECU_SetThrottleCurveActive packet to parameters
int decodeECU_SetThrottleCurveActivePacket(const void* pkt, ECUSystemCommands* cmd, uint8_t* active);

//! return the packet ID for the ECU_SetThrottleCurveActive packet
#define getECU_SetThrottleCurveActivePacketID() (PKT_ECU_SYS_CMD)

//! return the minimum encoded length for the ECU_SetThrottleCurveActive packet
#define getECU_SetThrottleCurveActiveMinDataLength() (2)

//! return the maximum encoded length for the ECU_SetThrottleCurveActive packet
#define getECU_SetThrottleCurveActiveMaxDataLength() (2)

/*!
 * Set individual elements in the throttle linearization lookup table.
 */
typedef struct
{
    ECUSystemCommands cmd;            //!< The command enumeration. Field is encoded constant.
    uint8_t           index;          //!< Index into the throttle curve table from 0 to 10 (0% to 100%) throttle input
    float             throttleOutput; //!< Percentage throttle output for this curve element
}ECU_SetThrottleCurveElement_t;

//! Create the ECU_SetThrottleCurveElement packet from parameters
void encodeECU_SetThrottleCurveElementPacket(void* pkt, uint8_t index, float throttleOutput);

//! Decode the ECU_SetThrottleCurveElement packet to parameters
int decodeECU_SetThrottleCurveElementPacket(const void* pkt, ECUSystemCommands* cmd, uint8_t* index, float* throttleOutput);

//! return the packet ID for the ECU_SetThrottleCurveElement packet
#define getECU_SetThrottleCurveElementPacketID() (PKT_ECU_SYS_CMD)

//! return the minimum encoded length for the ECU_SetThrottleCurveElement packet
#define getECU_SetThrottleCurveElementMinDataLength() (3)

//! return the maximum encoded length for the ECU_SetThrottleCurveElement packet
#define getECU_SetThrottleCurveElementMaxDataLength() (3)

/*!
 * Request the throttle curve lookup table data. If requested on CAN, the data
 * will be returned on CAN. If requested on RS232, the data will be returned on
 * RS232.
 */
typedef struct
{
    ECUSystemCommands cmd; //!< The command enumeration. Field is encoded constant.
}ECU_RequestThrottleCurveData_t;

//! Create the ECU_RequestThrottleCurveData packet from parameters
void encodeECU_RequestThrottleCurveDataPacket(void* pkt);

//! Decode the ECU_RequestThrottleCurveData packet to parameters
int decodeECU_RequestThrottleCurveDataPacket(const void* pkt, ECUSystemCommands* cmd);

//! return the packet ID for the ECU_RequestThrottleCurveData packet
#define getECU_RequestThrottleCurveDataPacketID() (PKT_ECU_SYS_CMD)

//! return the minimum encoded length for the ECU_RequestThrottleCurveData packet
#define getECU_RequestThrottleCurveDataMinDataLength() (1)

//! return the maximum encoded length for the ECU_RequestThrottleCurveData packet
#define getECU_RequestThrottleCurveDataMaxDataLength() (1)

/*!
 * Reset the FuelUsed value. This will set the FuelUsed data to zero.
 */
typedef struct
{
    ECUSystemCommands cmd; //!< The command enumeration. Field is encoded constant.
}ECU_ResetFuelUsed_t;

//! Create the ECU_ResetFuelUsed packet from parameters
void encodeECU_ResetFuelUsedPacket(void* pkt);

//! Decode the ECU_ResetFuelUsed packet to parameters
int decodeECU_ResetFuelUsedPacket(const void* pkt, ECUSystemCommands* cmd);

//! return the packet ID for the ECU_ResetFuelUsed packet
#define getECU_ResetFuelUsedPacketID() (PKT_ECU_SYS_CMD)

//! return the minimum encoded length for the ECU_ResetFuelUsed packet
#define getECU_ResetFuelUsedMinDataLength() (1)

//! return the maximum encoded length for the ECU_ResetFuelUsed packet
#define getECU_ResetFuelUsedMaxDataLength() (1)

/*!
 * Set the fuel used divisor
 */
typedef struct
{
    ECUSystemCommands cmd;     //!< The command enumeration. Field is encoded constant.
    uint16_t          divisor; //!< The fuel used divisor. The fuel used value is divided by this divisor before being transmitted by the auxiliary processor. Set this value to 1 to leave the fuel used data unaffected. If you use values greater than 100 the divisor is automatically interpreted as being in units of 0.01 (i.e. 100 times the resolution).
}ECU_SetFuelUsedDivisor_t;

//! Create the ECU_SetFuelUsedDivisor packet from parameters
void encodeECU_SetFuelUsedDivisorPacket(void* pkt, uint16_t divisor);

//! Decode the ECU_SetFuelUsedDivisor packet to parameters
int decodeECU_SetFuelUsedDivisorPacket(const void* pkt, ECUSystemCommands* cmd, uint16_t* divisor);

//! return the packet ID for the ECU_SetFuelUsedDivisor packet
#define getECU_SetFuelUsedDivisorPacketID() (PKT_ECU_SYS_CMD)

//! return the minimum encoded length for the ECU_SetFuelUsedDivisor packet
#define getECU_SetFuelUsedDivisorMinDataLength() (3)

//! return the maximum encoded length for the ECU_SetFuelUsedDivisor packet
#define getECU_SetFuelUsedDivisorMaxDataLength() (3)

/*!
 * Set or clear the Fuel Used reset flag. If this flag is set, the FuelUsed
 * data will reset (to zero) when the ECU is power cycled.
 */
typedef struct
{
    ECUSystemCommands cmd;   //!< The command enumeration. Field is encoded constant.
    uint8_t           reset; //!< 1 = Reset Fuel Used data on powerup 0 = Do not reset Fuel Used data on power up
}ECU_SetFuelUsedResetFlag_t;

//! Create the ECU_SetFuelUsedResetFlag packet from parameters
void encodeECU_SetFuelUsedResetFlagPacket(void* pkt, uint8_t reset);

//! Decode the ECU_SetFuelUsedResetFlag packet to parameters
int decodeECU_SetFuelUsedResetFlagPacket(const void* pkt, ECUSystemCommands* cmd, uint8_t* reset);

//! return the packet ID for the ECU_SetFuelUsedResetFlag packet
#define getECU_SetFuelUsedResetFlagPacketID() (PKT_ECU_SYS_CMD)

//! return the minimum encoded length for the ECU_SetFuelUsedResetFlag packet
#define getECU_SetFuelUsedResetFlagMinDataLength() (2)

//! return the maximum encoded length for the ECU_SetFuelUsedResetFlag packet
#define getECU_SetFuelUsedResetFlagMaxDataLength() (2)

/*!
 * Manually set the RPM governor mode.
 */
typedef struct
{
    ECUSystemCommands cmd;  //!< The command enumeration. Field is encoded constant.
    ECUGovernorMode   mode; //!< MODE 0 = Governor Off (Open loop throttle control) 1 = Governor based on throttle command 2 = Governor based on RPM command
}ECU_SetGovernorMode_t;

//! Create the ECU_SetGovernorMode packet from parameters
void encodeECU_SetGovernorModePacket(void* pkt, ECUGovernorMode mode);

//! Decode the ECU_SetGovernorMode packet to parameters
int decodeECU_SetGovernorModePacket(const void* pkt, ECUSystemCommands* cmd, ECUGovernorMode* mode);

//! return the packet ID for the ECU_SetGovernorMode packet
#define getECU_SetGovernorModePacketID() (PKT_ECU_SYS_CMD)

//! return the minimum encoded length for the ECU_SetGovernorMode packet
#define getECU_SetGovernorModeMinDataLength() (2)

//! return the maximum encoded length for the ECU_SetGovernorMode packet
#define getECU_SetGovernorModeMaxDataLength() (2)

/*!
 * Set the serial mode used for Autronic relay. When Autronic relay is enabled
 * the external serial port of the ECU is reconfigured to connect to ECUCal,
 * relaying bytes to the internal autronic processor; while still allowing the
 * auxiliary processor to see telemetry from Autronic. This is fundamentally
 * different from using the switch to calibration mode, which bypasses the
 * auxiliary processor altogether, cutting it off from autronic telemetry.
 */
typedef struct
{
    ECUSystemCommands     cmd;  //!< The command enumeration. Field is encoded constant.
    ECUAutronicRelayState mode; //!< The serial relay mode to command
}ECU_SetSerialMode_t;

//! Create the ECU_SetSerialMode packet from parameters
void encodeECU_SetSerialModePacket(void* pkt, ECUAutronicRelayState mode);

//! Decode the ECU_SetSerialMode packet to parameters
int decodeECU_SetSerialModePacket(const void* pkt, ECUSystemCommands* cmd, ECUAutronicRelayState* mode);

//! return the packet ID for the ECU_SetSerialMode packet
#define getECU_SetSerialModePacketID() (PKT_ECU_SYS_CMD)

//! return the minimum encoded length for the ECU_SetSerialMode packet
#define getECU_SetSerialModeMinDataLength() (2)

//! return the maximum encoded length for the ECU_SetSerialMode packet
#define getECU_SetSerialModeMaxDataLength() (2)

/*!
 * Set a custom address value for the ECU.
 */
typedef struct
{
    ECUSystemCommands cmd;     //!< The command enumeration. Field is encoded constant.
    uint16_t          address; //!< ECU address in the range {1, 65534}
}ECU_SetECUAddress_t;

//! Create the ECU_SetECUAddress packet from parameters
void encodeECU_SetECUAddressPacket(void* pkt, uint16_t address);

//! Decode the ECU_SetECUAddress packet to parameters
int decodeECU_SetECUAddressPacket(const void* pkt, ECUSystemCommands* cmd, uint16_t* address);

//! return the packet ID for the ECU_SetECUAddress packet
#define getECU_SetECUAddressPacketID() (PKT_ECU_SYS_CMD)

//! return the minimum encoded length for the ECU_SetECUAddress packet
#define getECU_SetECUAddressMinDataLength() (3)

//! return the maximum encoded length for the ECU_SetECUAddress packet
#define getECU_SetECUAddressMaxDataLength() (3)

/*!
 * Save a single byte of USER_DATA in EEPROM.
 */
typedef struct
{
    ECUSystemCommands cmd;      //!< The command enumeration. Field is encoded constant.
    uint8_t           index;    //!< USER_DATA address (0 to 7)
    uint8_t           userdata; //!< USER_DATA variable
}ECU_SetUserData_t;

//! Create the ECU_SetUserData packet from parameters
void encodeECU_SetUserDataPacket(void* pkt, uint8_t index, uint8_t userdata);

//! Decode the ECU_SetUserData packet to parameters
int decodeECU_SetUserDataPacket(const void* pkt, ECUSystemCommands* cmd, uint8_t* index, uint8_t* userdata);

//! return the packet ID for the ECU_SetUserData packet
#define getECU_SetUserDataPacketID() (PKT_ECU_SYS_CMD)

//! return the minimum encoded length for the ECU_SetUserData packet
#define getECU_SetUserDataMinDataLength() (3)

//! return the maximum encoded length for the ECU_SetUserData packet
#define getECU_SetUserDataMaxDataLength() (3)

/*!
 * Reset the engine runtime.
 */
typedef struct
{
    ECUSystemCommands cmd;  //!< The command enumeration. Field is encoded constant.
    uint32_t          time; //!< The new value of the engine time counter in seconds
}ECU_ResetEngineTime_t;

//! Create the ECU_ResetEngineTime packet from parameters
void encodeECU_ResetEngineTimePacket(void* pkt, uint32_t time);

//! Decode the ECU_ResetEngineTime packet to parameters
int decodeECU_ResetEngineTimePacket(const void* pkt, ECUSystemCommands* cmd, uint32_t* time);

//! return the packet ID for the ECU_ResetEngineTime packet
#define getECU_ResetEngineTimePacketID() (PKT_ECU_SYS_CMD)

//! return the minimum encoded length for the ECU_ResetEngineTime packet
#define getECU_ResetEngineTimeMinDataLength() (1)

//! return the maximum encoded length for the ECU_ResetEngineTime packet
#define getECU_ResetEngineTimeMaxDataLength() (4)

/*!
 * Reset the ECU
 */
typedef struct
{
    ECUSystemCommands cmd; //!< The command enumeration. Field is encoded constant.
}ECU_ResetECU_t;

//! Create the ECU_ResetECU packet from parameters
void encodeECU_ResetECUPacket(void* pkt);

//! Decode the ECU_ResetECU packet to parameters
int decodeECU_ResetECUPacket(const void* pkt, ECUSystemCommands* cmd);

//! return the packet ID for the ECU_ResetECU packet
#define getECU_ResetECUPacketID() (PKT_ECU_SYS_CMD)

//! return the minimum encoded length for the ECU_ResetECU packet
#define getECU_ResetECUMinDataLength() (4)

//! return the maximum encoded length for the ECU_ResetECU packet
#define getECU_ResetECUMaxDataLength() (4)

#ifdef __cplusplus
}
#endif
#endif // _ECUPACKETS_H
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          // ECUProtocol.c was generated by ProtoGen version 3.2.a

/*
 * This file is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This file is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Author: Oliver Walters / Currawong Engineering Pty Ltd
 */
 

#include "ECUProtocol.h"

/*!
 * \brief Lookup label for 'ECUPackets' enum entry
 * 
 * \param value is the integer value of the enum entry
 * \return string label of the given entry
 */
const char* ECUPackets_EnumLabel(int value)
{
    switch (value)
    {
    default:
        return "";
    case PKT_ECU_TELEMETRY_FAST:
        return translateECU("PKT_ECU_TELEMETRY_FAST");
    case PKT_ECU_TELEMETRY_SLOW_0:
        return translateECU("PKT_ECU_TELEMETRY_SLOW_0");
    case PKT_ECU_TELEMETRY_SLOW_1:
        return translateECU("PKT_ECU_TELEMETRY_SLOW_1");
    case PKT_ECU_TELEMETRY_SLOW_2:
        return translateECU("PKT_ECU_TELEMETRY_SLOW_2");
    case PKT_ECU_TELEMETRY_SLOW_3:
        return translateECU("PKT_ECU_TELEMETRY_SLOW_3");
    case PKT_ECU_THROTTLE_CALIBRATION:
        return translateECU("PKT_ECU_THROTTLE_CALIBRATION");
    case PKT_ECU_THROTTLE:
        return translateECU("PKT_ECU_THROTTLE");
    case PKT_ECU_RPM_COMMAND:
        return translateECU("PKT_ECU_RPM_COMMAND");
    case PKT_ECU_RPM_CALIBRATION:
        return translateECU("PKT_ECU_RPM_CALIBRATION");
    case PKT_ECU_HARDWARE_CONFIG:
        return translateECU("PKT_ECU_HARDWARE_CONFIG");
    case PKT_ECU_SOFTWARE_VERSION:
        return translateECU("PKT_ECU_SOFTWARE_VERSION");
    case PKT_ECU_TPS_DELAY_CONFIG:
        return translateECU("PKT_ECU_TPS_DELAY_CONFIG");
    case PKT_ECU_TELEMETRY_SETTINGS:
        return translateECU("PKT_ECU_TELEMETRY_SETTINGS");
    case PKT_ECU_PUMP_CONFIG:
        return translateECU("PKT_ECU_PUMP_CONFIG");
    case PKT_ECU_ERROR_MSG:
        return translateECU("PKT_ECU_ERROR_MSG");
    case PKT_ECU_POWER_CYCLES:
        return translateECU("PKT_ECU_POWER_CYCLES");
    case PKT_ECU_PUMP_2_CONFIG:
        return translateECU("PKT_ECU_PUMP_2_CONFIG");
    case PKT_ECU_PUMP_DEBUG:
        return translateECU("PKT_ECU_PUMP_DEBUG");
    case PKT_ECU_TOTAL_ENGINE_TIME:
        return translateECU("PKT_ECU_TOTAL_ENGINE_TIME");
    case PKT_ECU_SYS_CMD:
        return translateECU("PKT_ECU_SYS_CMD");
    case PKT_ECU_USER_DATA:
        return translateECU("PKT_ECU_USER_DATA");
    case PKT_ECU_THROTTLE_CURVE_0:
        return translateECU("PKT_ECU_THROTTLE_CURVE_0");
    case PKT_ECU_THROTTLE_CURVE_1:
        return translateECU("PKT_ECU_THROTTLE_CURVE_1");
    case PKT_ECU_GPIO:
        return translateECU("PKT_ECU_GPIO");
    case PKT_ECU_SETTINGS_DATA:
        return translateECU("PKT_ECU_SETTINGS_DATA");
    case PKT_ECU_CHT_LOOP:
        return translateECU("PKT_ECU_CHT_LOOP");
    }
}


/*!
 * \brief Lookup label for 'ECUSystemCommands' enum entry
 * 
 * \param value is the integer value of the enum entry
 * \return string label of the given entry
 */
const char* ECUSystemCommands_EnumLabel(int value)
{
    switch (value)
    {
    default:
        return "";
    case CMD_ECU_CALIBRATE_ANALOG_CLOSED:
        return translateECU("CMD_ECU_CALIBRATE_ANALOG_CLOSED");
    case CMD_ECU_CALIBRATE_ANALOG_OPEN:
        return translateECU("CMD_ECU_CALIBRATE_ANALOG_OPEN");
    case CMD_ECU_CALIBRATE_PULSE_CLOSED:
        return translateECU("CMD_ECU_CALIBRATE_PULSE_CLOSED");
    case CMD_ECU_CALIBRATE_PULSE_OPEN:
        return translateECU("CMD_ECU_CALIBRATE_PULSE_OPEN");
    case CMD_ECU_CALIBRATE_PULSE_WRITE:
        return translateECU("CMD_ECU_CALIBRATE_PULSE_W