            AP_HAL::millis(),                               // time since system boot
                        dist_min,                                       // minimum distance the sensor can measure in centimeters
                        dist_max,                                       // maximum distance the sensor can measure in centimeters
                        (uint16_t)(dist_array.distance[i] * 100.0f),    // current distance reading
                        MAV_DISTANCE_SENSOR_LASER,                      // type from MAV_DISTANCE_SENSOR enum
                        PROXIMITY_SENSOR_ID_START + i,                  // onboard ID of the sensor
                        dist_array.orientation[i],                      // direction the sensor faces from MAV_SENSOR_ORIENTATION enum
                        0,                                              // Measurement covariance in centimeters, 0 for unknown / invalid readings
                        0, 0, nullptr, 0);
            }
        }
    }

    // send upward distance
    float dist_up;
    if (proximity->get_upward_distance(dist_up)) {
        if (!HAVE_PAYLOAD_SPACE(chan, DISTANCE_SENSOR)) {
            return;
        }
        mavlink_msg_distance_sensor_send(
                chan,
                AP_HAL::millis(),                                         // time since system boot
                dist_min,                                                 // minimum distance the sensor can measure in centimeters
                dist_max,                                                 // maximum distance the sensor can measure in centimeters
                (uint16_t)(dist_up * 100.0f),                             // current distance reading
                MAV_DISTANCE_SENSOR_LASER,                                // type from MAV_DISTANCE_SENSOR enum
                PROXIMITY_SENSOR_ID_START + PROXIMITY_MAX_DIRECTION + 1,  // onboard ID of the sensor
                MAV_SENSOR_ROTATION_PITCH_90,                             // direction upwards
                0,                                                        // Measurement covariance in centimeters, 0 for unknown / invalid readings
                0, 0, nullptr, 0);
    }
}
#endif // HAL_PROXIMITY_ENABLED

#if AP_AHRS_ENABLED
// report AHRS2 state
void GCS_MAVLINK::send_ahrs2()
{
    const AP_AHRS &ahrs = AP::ahrs();
    Vector3f euler;
    Location loc {};
    // we want one or both of these, use | to avoid short-circuiting:
    if (uint8_t(ahrs.get_secondary_attitude(euler)) |
        uint8_t(ahrs.get_secondary_position(loc))) {
        mavlink_msg_ahrs2_send(chan,
                               euler.x,
                               euler.y,
                               euler.z,
                               loc.alt*1.0e-2f,
                               loc.lat,
                               loc.lng);
    }
}
#endif  // AP_AHRS_ENABLED

MissionItemProtocol *GCS::get_prot_for_mission_type(const MAV_MISSION_TYPE mission_type) const
{
    if (mission_type >= ARRAY_SIZE(missionitemprotocols)) {
        return nullptr;
    }
    return missionitemprotocols[mission_type];
}

// handle a request for the number of items we have stored for a mission type:
void GCS_MAVLINK::handle_mission_request_list(const mavlink_message_t &msg)
{
    // decode
    mavlink_mission_request_list_t packet;
    mavlink_msg_mission_request_list_decode(&msg, &packet);

    MissionItemProtocol *prot = gcs().get_prot_for_mission_type((MAV_MISSION_TYPE)packet.mission_type);
    if (prot == nullptr) {
        mavlink_msg_mission_ack_send(chan,
                                     msg.sysid,
                                     msg.compid,
                                     MAV_MISSION_UNSUPPORTED,
                                     packet.mission_type);
        return;
    }

    prot->handle_mission_request_list(*this, packet, msg);
}

/*
  handle a MISSION_REQUEST mavlink packet
 */
void GCS_MAVLINK::handle_mission_request_int(const mavlink_message_t &msg)
{
        // decode
        mavlink_mission_request_int_t packet;
        mavlink_msg_mission_request_int_decode(&msg, &packet);

        MissionItemProtocol *prot = gcs().get_prot_for_mission_type((MAV_MISSION_TYPE)packet.mission_type);
        if (prot == nullptr) {
            return;
        }
        prot->handle_mission_request_int(*this, packet, msg);
}

#if AP_MAVLINK_MSG_MISSION_REQUEST_ENABLED
void GCS_MAVLINK::handle_mission_request(const mavlink_message_t &msg)
{
        // decode
        mavlink_mission_request_t packet;
        mavlink_msg_mission_request_decode(&msg, &packet);

        MissionItemProtocol *prot = gcs().get_prot_for_mission_type((MAV_MISSION_TYPE)packet.mission_type);
        if (prot == nullptr) {
            return;
        }
        prot->handle_mission_request(*this, packet, msg);
}
#endif

// returns a MISSION_STATE numeration value best describing out
// current mission state.
MISSION_STATE GCS_MAVLINK::mission_state(const AP_Mission &mission) const
{
    if (mission.num_commands() < 2) {  // 1 means just home is present
        return MISSION_STATE_NO_MISSION;
    }
    switch (mission.state()) {
    case AP_Mission::mission_state::MISSION_STOPPED:
        return MISSION_STATE_NOT_STARTED;
    case AP_Mission::mission_state::MISSION_RUNNING:
        return MISSION_STATE_ACTIVE;
    case AP_Mission::mission_state::MISSION_COMPLETE:
        return MISSION_STATE_COMPLETE;
    }

    // compiler ensures we can't get here as no default case in above enumeration

    return MISSION_STATE_UNKNOWN;
}

void GCS_MAVLINK::send_mission_current(const class AP_Mission &mission, uint16_t seq)
{
    auto num_commands = mission.num_commands();
    if (num_commands > 0) {
        // exclude home location from the count; see message definition.
        num_commands -= 1;
    }

#if AP_VEHICLE_ENABLED
    const uint8_t mission_mode = AP::vehicle()->current_mode_requires_mission() ? 1 : 0;
#else
    const uint8_t mission_mode = 0;
#endif

    mavlink_msg_mission_current_send(
        chan,
        seq,
        num_commands, // total
        mission_state(mission), // mission_state
        mission_mode);  // mission_mode
}

#if AP_MAVLINK_MISSION_SET_CURRENT_ENABLED
/*
  handle a MISSION_SET_CURRENT mavlink packet

  Note that there exists a relatively new mavlink DO command,
  MAV_CMD_DO_SET_MISSION_CURRENT which provides an acknowledgement
  that the command has been received, rather than the GCS having to
  rely on getting back an identical sequence number as some currently
  do.
 */
void GCS_MAVLINK::handle_mission_set_current(AP_Mission &mission, const mavlink_message_t &msg)
{
    // send_received_message_deprecation_warning("MISSION_SET_CURRENT");

    // decode
    mavlink_mission_set_current_t packet;
    mavlink_msg_mission_set_current_decode(&msg, &packet);

    // set current command
    if (mission.set_current_cmd(packet.seq)) {
        // because MISSION_SET_CURRENT is a message not a command,
        // there is not ACK associated with us successfully changing
        // our waypoint.  Some GCSs use the fact we return exactly the
        // same mission sequence number in this packet as an ACK - so
        // if they send a MISSION_SET_CURRENT with seq number of 4
        // then they expect to receive a MISSION_CURRENT message with
        // exactly that sequence number in it, even if ArduPilot never
        // actually holds that as a sequence number (e.g. packet.seq==0).
        if (HAVE_PAYLOAD_SPACE(chan, MISSION_CURRENT)) {
            send_mission_current(mission, packet.seq);
        } else {
            // schedule it for later:
            send_message(MSG_CURRENT_WAYPOINT);
        }
    }
}
#endif  // AP_MAVLINK_MISSION_SET_CURRENT_ENABLED

/*
  handle a MISSION_COUNT mavlink packet
 */
void GCS_MAVLINK::handle_mission_count(const mavlink_message_t &msg)
{
    // decode
    mavlink_mission_count_t packet;
    mavlink_msg_mission_count_decode(&msg, &packet);

    MissionItemProtocol *prot = gcs().get_prot_for_mission_type((MAV_MISSION_TYPE)packet.mission_type);
    if (prot == nullptr) {
        mavlink_msg_mission_ack_send(chan,
                                     msg.sysid,
                                     msg.compid,
                                     MAV_MISSION_UNSUPPORTED,
                                     packet.mission_type);
        return;
    }

    prot->handle_mission_count(*this, packet, msg);
}

/*
  handle a MISSION_CLEAR_ALL mavlink packet
 */
void GCS_MAVLINK::handle_mission_clear_all(const mavlink_message_t &msg)
{
    // decode
    mavlink_mission_clear_all_t packet;
    mavlink_msg_mission_clear_all_decode(&msg, &packet);

    const MAV_MISSION_TYPE mission_type = (MAV_MISSION_TYPE)packet.mission_type;
    MissionItemProtocol *prot = gcs().get_prot_for_mission_type(mission_type);
    if (prot == nullptr) {
        send_mission_ack(msg, mission_type, MAV_MISSION_UNSUPPORTED);
        return;
    }

    prot->handle_mission_clear_all(*this, msg);
}

bool GCS_MAVLINK::requesting_mission_items() const
{
    for (const auto *prot : gcs().missionitemprotocols) {
        if (prot && prot->receiving && prot->active_link_is(this)) {
            return true;
        }
    }
    return false;
}

void GCS_MAVLINK::handle_mission_write_partial_list(const mavlink_message_t &msg)
{
    // decode
    mavlink_mission_write_partial_list_t packet;
    mavlink_msg_mission_write_partial_list_decode(&msg, &packet);

    MissionItemProtocol *use_prot = gcs().get_prot_for_mission_type((MAV_MISSION_TYPE)packet.mission_type);
    if (use_prot == nullptr) {
        send_mission_ack(msg, (MAV_MISSION_TYPE)packet.mission_type, MAV_MISSION_UNSUPPORTED);
        return;
    }
    use_prot->handle_mission_write_partial_list(*this, msg, packet);
}

#if HAL_MOUNT_ENABLED
/*
  pass mavlink messages to the AP_Mount singleton
 */
void GCS_MAVLINK::handle_mount_message(const mavlink_message_t &msg)
{
    AP_Mount *mount = AP::mount();
    if (mount == nullptr) {
        return;
    }
    mount->handle_message(chan, msg);
}

#endif

/*
  pass parameter value messages through to mount library
 */
void GCS_MAVLINK::handle_param_value(const mavlink_message_t &msg)
{
#if HAL_MOUNT_ENABLED
    AP_Mount *mount = AP::mount();
    if (mount == nullptr) {
        return;
    }
    mount->handle_param_value(msg);
#endif
}

void GCS_MAVLINK::send_text(MAV_SEVERITY severity, const char *fmt, ...) const
{
    va_list arg_list;
    va_start(arg_list, fmt);
    gcs().send_textv(severity, fmt, arg_list, (1<<chan));
    va_end(arg_list);
}

float GCS_MAVLINK::telemetry_radio_rssi()
{
    if (AP_HAL::millis() - last_radio_status.received_ms > 5000) {
        // telemetry radio has disappeared?!
        return 0;
    }
    if (last_radio_status.rssi == 255) {
        // see RADIO_STATUS packet definition
        return 0;
    }
    return last_radio_status.rssi/254.0f;
}

bool GCS_MAVLINK::last_txbuf_is_greater(uint8_t txbuf_limit)
{
    if (AP_HAL::millis() - last_radio_status.received_ms > 5000) {
        // stale report
        return true;
    }
    return last_radio_status.txbuf > txbuf_limit;
}

void GCS_MAVLINK::handle_radio_status(const mavlink_message_t &msg)
{
    mavlink_radio_t packet;
    mavlink_msg_radio_decode(&msg, &packet);

    const uint32_t now = AP_HAL::millis();

    last_radio_status.received_ms = now;
    last_radio_status.rssi = packet.rssi;

    // record if the GCS has been receiving radio messages from
    // the aircraft
    if (packet.remrssi != 0) {
        last_radio_status.remrssi_ms = now;
    }

    last_radio_status.txbuf = packet.txbuf;

    // use the state of the transmit buffer in the radio to
    // control the stream rate, giving us adaptive software
    // flow control
    if (packet.txbuf < 20 && stream_slowdown_ms < 2000) {
        // we are very low on space - slow down a lot
        stream_slowdown_ms += 60;
    } else if (packet.txbuf < 50 && stream_slowdown_ms < 2000) {
        // we are a bit low on space, slow down slightly
        stream_slowdown_ms += 20;
    } else if (packet.txbuf > 95 && stream_slowdown_ms > 200) {
        // the buffer has plenty of space, speed up a lot
        stream_slowdown_ms -= 40;
    } else if (packet.txbu/*
 * Copyright (C) 2015-2016  Intel Corporation. All rights reserved.
 *
 * This file is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This file is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
#pragma once

#include "SIM_Aircraft.h"

#include <AP_Math/AP_Math.h>

namespace SITL {

/**
 * Simulation model to simulate calibration of accelerometers and compasses.
 *
 * The vehicle rotation can be controlled by sending PWM values to the servos
 * input, denoted by PWM[i] for the i-th channel (starting by zero). All PWM
 * values must be in [1000, 2000], otherwise that will cause undefined
 * behavior.
 *
 * There are four control modes, that are set with PWM[4]:
 *
 *  1) Stop (1000 <= PWM[4] < 1100):
 *    Stop the vehicle, i.e., stop the actuation of the other modes.
 *
 *  2) Attitude (1100 <= PWM[4] < 1200):
 *    Rotate the vehicle to the specified attitude. The attitude is defined
 *    with the PWM channels 5, 6 and 7 for roll, pitch and yaw angles,
 *    respectively. The PWM value for a desired angle in radians is given by:
 *
 *        pwm(theta) = 1500 + 500 * round(theta / pi)
 *        where -pi <= theta <= pi
 *
 *  3) Simple autonomous compass calibration (1200 <= PWM[4] < 1300):
 *    Move continuously the vehicle through six calibration poses and do a
 *    rotation about each pose over a short period of time.
 *
 *  4) Angular Velocity (1300 <= PWM[4] <= 2000):
 *    Rotate the vehicle at a desired angular velocity. The angular velocity is
 *    specified by a rotation axis and an angular speed.
 *
 *    The x, y and z components of the rotation axis is given, respectively, by
 *    the PWM channels 5, 6 and 7 with an offset of 1500. The rotation axis is
 *    normalized internally, so that PWM[5,6,7] = [1600, 1300, 0] and
 *    PWM[5,6,7] = [1700, 1100, 0] means the same normalized rotation axis.
 *
 *    The angular speed value is specified by PWM[4]. The PWM value for a
 *    desired angular speed in radians/s is given by:
 *
 *        pwm(theta) = 1300 + 700 * round(theta / (2 * pi)),
 *        where 0 <= theta <= 2 * pi
 */
class Calibration : public Aircraft {
public:
    Calibration(const char *frame_str);

    void update(const struct sitl_input &input) override;

    static Aircraft *create(const char *frame_str) {
        return NEW_NOTHROW Calibration(frame_str);
    }

private:
    void _stop_control(const struct sitl_input &input, Vector3f& rot_accel);

    void _attitude_set(float desired_roll, float desired_pitch, float desired_yaw,
                       Vector3f& rot_accel);

    void _attitude_control(const struct sitl_input &input,
                           Vector3f& rot_accel);

    void _angular_velocity_control(const struct sitl_input &input,
                                   Vector3f& rot_accel);

    void _calibration_poses(Vector3f& rot_accel);
};
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           /*
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
/*
  base class for CAN simulated devices
*/
#include "SIM_DroneCANDevice.h"
#if AP_TEST_DRONECAN_DRIVERS

#include <canard/publisher.h>
#include <AP_Vehicle/AP_Vehicle.h>
#include <AP_Baro/AP_Baro.h>
#include <AP_Baro/AP_Baro_SITL.h>
#include <dronecan_msgs.h>
#include <SITL/SITL.h>
#include <AP_DroneCAN/AP_Canard_iface.h>


using namespace SITL;

void DroneCANDevice::update_baro() {
    const uint64_t now = AP_HAL::micros64();
    if (((now - _baro_last_update_us) < 10000) && (_baro_last_update_us != 0)) {
        return;
    }
    _baro_last_update_us = now;
    const uint32_t now_ms = AP_HAL::millis();
    float sim_alt = AP::sitl()->state.altitude;

    if (AP::sitl()->baro_count < 1) {
        // barometer is disabled
        return;
    }

    sim_alt += AP::sitl()->baro[0].drift * now_ms * 0.001f;
    sim_alt += AP::sitl()->baro[0].noise * rand_float();


    // add baro glitch
    sim_alt += AP::sitl()->baro[0].glitch;

    // add delay
    uint32_t best_time_delta = 200;  // initialise large time representing buffer entry closest to current time - delay.
    uint8_t best_index = 0;  // initialise number representing the index of the entry in buffer closest to delay.

    // storing data from sensor to buffer
    if (now_ms - _last_store_time >= 10) {  // store data every 10 ms.
        _last_store_time = now_ms;
        if (_store_index > _buffer_length - 1) {  // reset buffer index if index greater than size of buffer
            _store_index = 0;
        }

        // if freezed barometer, report altitude to last recorded altitude
        if (AP::sitl()->baro[0].freeze == 1) {
            sim_alt = _last_altitude;
        } else {
            _last_altitude = sim_alt;
        }

        _buffer[_store_index].data = sim_alt;  // add data to current index
        _buffer[_store_index].time = _last_store_time;  // add time_stamp to current index
        _store_index = _store_index + 1;  // increment index
    }

    // return delayed measurement
    const uint32_t delayed_time = now_ms - AP::sitl()->baro[0].delay;  // get time corresponding to delay

    // find data corresponding to delayed time in buffer
    for (uint8_t i = 0; i <= _buffer_length - 1; i++) {
        // find difference between delayed time and time stamp in buffer
        uint32_t time_delta = abs(
                (int32_t)(delayed_time - _buffer[i].time));
        // if this difference is smaller than last delta, store this time
        if (time_delta < best_time_delta) {
            best_index = i;
            best_time_delta = time_delta;
        }
    }
    if (best_time_delta < 200) {  // only output stored state if < 200 msec retrieval error
        sim_alt = _buffer[best_index].data;
    }

#if !APM_BUILD_TYPE(APM_BUILD_ArduSub)

    float p, t_K;
    AP_Baro::get_pressure_temperature_for_alt_amsl(sim_alt, p, t_K);
    float T = KELVIN_TO_C(t_K);

    AP_Baro_SITL::temperature_adjustment(p, T);
    T = C_TO_KELVIN(T);
#else
    float rho, delta, theta;
    AP_Baro::SimpleUnderWaterAtmosphere(-sim_alt * 0.001f, rho, delta, theta);
    float p = SSL_AIR_PRESSURE * delta;
    float T = SSL_AIR_TEMPERATURE * theta;
#endif

    // add in correction for wind effects
    p += AP_Baro_SITL::wind_pressure_correction(0);
    static Canard::Publisher<uavcan_equipment_air_data_StaticPressure> press_pub{CanardInterface::get_test_iface()};
    static Canard::Publisher<uavcan_equipment_air_data_StaticTemperature> temp_pub{CanardInterface::get_test_iface()};
    uavcan_equipment_air_data_StaticPressure press_msg {};
    press_msg.static_pressure = p;
    press_pub.broadcast(press_msg);
    uavcan_equipment_air_data_StaticTemperature temp_msg {};
    temp_msg.static_temperature = T;
    temp_pub.broadcast(temp_msg);
}

void DroneCANDevice::update_airspeed() {
    const uint32_t now = AP_HAL::micros64();
    if ((now - _airspeed_last_update_us < 50000) && (_airspeed_last_update_us != 0)) {
        return;
    }
    _airspeed_last_update_us = now;
    uavcan_equipment_air_data_RawAirData msg {};
    msg.differential_pressure = AP::sitl()->state.airspeed_raw_pressure[0];

    // this was mostly swiped from SIM_Airspeed_DLVR:
    const float sim_alt = AP::sitl()->state.altitude;

    // To Do: Add a sensor board temperature offset parameter
    msg.static_air_temperature = C_TO_KELVIN(AP_Baro::get_temperatureC_for_alt_amsl(sim_alt));

    static Canard::Publisher<uavcan_equipment_air_data_RawAirData> raw_air_pub{CanardInterface::get_test_iface()};
    raw_air_pub.broadcast(msg);
}

void DroneCANDevice::_setup_eliptical_correcion(uint8_t i)
{
    Vector3f diag = AP::sitl()->mag_diag[i].get();
    if (diag.is_zero()) {
        diag = {1,1,1};
    }
    const Vector3f &diagonals = diag;
    const Vector3f &offdiagonals = AP::sitl()->mag_offdiag[i];
    
    if (diagonals == _last_dia && offdiagonals == _last_odi) {
        return;
    }
    
    _eliptical_corr = Matrix3f(diagonals.x,    offdiagonals.x, offdiagonals.y,
                               offdiagonals.x, diagonals.y,    offdiagonals.z,
                               offdiagonals.y, offdiagonals.z, diagonals.z);
    if (!_eliptical_corr.invert()) {
        _eliptical_corr.identity();
    }
    _last_dia = diag;
    _last_odi = offdiagonals;
}

void DroneCANDevice::update_compass() {

    // Sampled at 100Hz
    const uint32_t now = AP_HAL::micros64();
    if ((now - _compass_last_update_us < 10000) && (_compass_last_update_us != 0)) {
        return;
    }
    _compass_last_update_us = now;

    // calculate sensor noise and add to 'truth' field in body frame
    // units are milli-Gauss
    Vector3f noise = rand_vec3f() * AP::sitl()->mag_noise;
    Vector3f new_mag_data = AP::sitl()->state.bodyMagField + noise;

    _setup_eliptical_correcion(0);
    Vector3f f = (_eliptical_corr * new_mag_data) - AP::sitl()->mag_ofs[0].get();
    // rotate compass
    f.rotate_inverse((enum Rotation)AP::sitl()->mag_orient[0].get());
    f.rotate(AP::compass().get_board_orientation());
    // scale the compass to simulate sensor scale factor errors
    f *= AP::sitl()->mag_scaling[0];

    static Canard::Publisher<uavcan_equipment_ahrs_MagneticFieldStrength> mag_pub{CanardInterface::get_test_iface()};
    uavcan_equipment_ahrs_MagneticFieldStrength mag_msg {};
    mag_msg.magnetic_field_ga[0] = f.x/1000.0f;
    mag_msg.magnetic_field_ga[1] = f.y/1000.0f;
    mag_msg.magnetic_field_ga[2] = f.z/1000.0f;
    mag_msg.magnetic_field_covariance.len = 0;
    mag_pub.broadcast(mag_msg);
    static Canard::Publisher<uavcan_equipment_ahrs_MagneticFieldStrength2> mag2_pub{CanardInterface::get_test_iface()};
    uavcan_equipment_ahrs_MagneticFieldStrength2 mag2_msg;
    mag2_msg.magnetic_field_ga[0] = f.x/1000.0f;
    mag2_msg.magnetic_field_ga[1] = f.y/1000.0f;
    mag2_msg.magnetic_field_ga[2] = f.z/1000.0f;
    mag2_msg.sensor_id = 0;
    mag2_msg.magnetic_field_covariance.len = 0;
    mag2_pub.broadcast(mag2_msg);
}

void DroneCANDevice::update_rangefinder() {

    // Sampled at 100Hz
    const uint32_t now = AP_HAL::micros64();
    if ((now - _rangefinder_last_update_us < 10000) && (_rangefinder_last_update_us != 0)) {
        return;
    }
    _rangefinder_last_update_us = now;
    static Canard::Publisher<uavcan_equipment_range_sensor_Measurement> pub{CanardInterface::get_test_iface()};
    uavcan_equipment_range_sensor_Measurement msg;
    msg.timestamp.usec = AP_HAL::micros64();
    msg.sensor_id = 0;
    msg.sensor_type = UAVCAN_EQUIPMENT_RANGE_SENSOR_MEASUREMENT_SENSOR_TYPE_LIDAR;
    const float dist = AP::sitl()->get_rangefinder(0);
    if (!isnan(dist)) {
        msg.reading_type = UAVCAN_EQUIPMENT_RANGE_SENSOR_MEASUREMENT_READING_TYPE_VALID_RANGE;
        msg.range = MAX(0, dist);
    } else {
        msg.reading_type = UAVCAN_EQUIPMENT_RANGE_SENSOR_MEASUREMENT_READING_TYPE_TOO_FAR;
        msg.range = 0;
    }
    pub.broadcast(msg);
}

void DroneCANDevice::update()
{
    update_baro();
    update_airspeed();
    update_compass();
    update_rangefinder();
}

#endif // AP_TEST_DRONECAN_DRIVERS
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               /*
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
/*
  base class for CAN simulated devices
*/

#pragma once

#include <stdint.h>
#include <AP_HAL/AP_HAL_Boards.h>
#include <AP_Math/AP_Math.h>
#include <AP_Math/vectorN.h>

#if AP_TEST_DRONECAN_DRIVERS
namespace SITL {

class DroneCANDevice {
public:
    void update(void);

private:
    // barometer delay buffer variables
    struct readings_baro {
        uint32_t time;
        float data;
    };
    uint8_t _store_index;
    uint32_t _last_store_time;
    static const uint8_t _buffer_length = 50;
    VectorN<readings_baro, _buffer_length> _buffer;
      float _last_altitude;
    void update_baro(void);

    void update_airspeed(void);
    void update_compass(void);
    void update_rangefinder(void);
    void _setup_eliptical_correcion(uint8_t i);
    uint64_t _baro_last_update_us;
    uint64_t _airspeed_last_update_us;
    uint64_t _compass_last_update_us;
    uint64_t _rangefinder_last_update_us;
    Matrix3f _eliptical_corr;
    Vector3f _last_dia;
    Vector3f _last_odi;
};

}
#endif // AP_TEST_DRONECAN_DRIVERS                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                /*
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
/*
  simulate Hirth EFI system
*/

#include "SIM_Aircraft.h"
#include <SITL/SITL.h>
#include <AP_HAL/utility/sparse-endian.h>
#include <stdio.h>
#include "SIM_EFI_Hirth.h"

using namespace SITL;

// assume SERVO3 is throttle
#define HIRTH_RPM_INDEX 2

void EFI_Hirth::update_receive()
{
    const ssize_t num_bytes_read = read_from_autopilot((char*)&receive_buf[receive_buf_ofs], ARRAY_SIZE(receive_buf) - receive_buf_ofs);
    if (num_bytes_read < 0) {
        return;
    }
    receive_buf_ofs += num_bytes_read;

    if (receive_buf_ofs < 1) {
        return;
    }

    const uint8_t expected_bytes_in_message = receive_buf[0];

    if (expected_bytes_in_message == 0) {
        AP_HAL::panic("zero bytes expected is unexpected");
    }

    if (expected_bytes_in_message > ARRAY_SIZE(receive_buf)) {
        AP_HAL::panic("Unexpectedly large byte count");
    }

    if (receive_buf_ofs < expected_bytes_in_message) {
        return;
    }

    // checksum is sum of all bytes except the received checksum:
    const uint8_t expected_checksum = 256U - crc_sum_of_bytes(receive_buf, expected_bytes_in_message-1);
    const uint8_t received_checksum = receive_buf[expected_bytes_in_message-1];
    if (expected_checksum == received_checksum) {
        PacketCode received_packet_code = PacketCode(receive_buf[1]);
        if (received_packet_code == PacketCode::SetValues) {
            // do this synchronously for now
            handle_set_values();
        } else if (uint8_t(received_packet_code) == 0x04 ||
                   uint8_t(received_packet_code) == 0x0B ||
                   uint8_t(received_packet_code) == 0x0D) {
            assert_receive_size(3);
            if (requested_data_record.time_ms != 0) {
                AP_HAL::panic("Requesting too fast?");
            }
            requested_data_record.code = received_packet_code;
            requested_data_record.time_ms = AP_HAL::millis();
        } else {
            AP_HAL::panic("Invalid packet code");
        }
    } else {
        AP_HAL::panic("checksum failed");
        // simply throw these bytes away.  What the actual device does in the
        // face of weird data is unknown.
    }
    memmove(&receive_buf[0], &receive_buf[expected_bytes_in_message], receive_buf_ofs - expected_bytes_in_message);
    receive_buf_ofs -= expected_bytes_in_message;
}

void EFI_Hirth::assert_receive_size(uint8_t receive_size)
{
    if (receive_buf[0] != receive_size) {
        AP_HAL::panic("Expected %u message size, got %u message size", receive_size, receive_buf[0]);
    }
}

void EFI_Hirth::handle_set_values()
{
    assert_receive_size(23);
    static_assert(sizeof(settings) == 20, "correct number of bytes in settings");
    memcpy((void*)&settings, &receive_buf[2], sizeof(settings));

    // send ACK for set-values
    constexpr uint8_t set_values_ack[] {
        3,  // length
        uint8_t(PacketCode::SetValues),  // code
        3 + uint8_t(PacketCode::SetValues)
    };
    write_to_autopilot((const char*)set_values_ack, sizeof(set_values_ack));
}

void EFI_Hirth::update_send()
{
    if (requested_data_record.time_ms == 0) {
        // no outstanding request
        return;
    }
    if (AP_HAL::millis() - requested_data_record.time_ms < 20) {
        // 20ms to service a request
        return;
    }
    requested_data_record.time_ms = 0;

    switch (requested_data_record.code) {
    case PacketCode::DataRecord1:
        send_record1();
        break;
    case PacketCode::DataRecord2:
        send_record2();
        break;
    case PacketCode::DataRecord3:
        send_record3();
        break;
    default:
        AP_HAL::panic("Unknown data record (%u) requested", (unsigned)requested_data_record.code);
    }
}

void EFI_Hirth::update_engine_model()
{
    auto sitl = AP::sitl();

    // FIXME: this should come from simulation, not baro.  baro gets
    // warmed by the simulated electronics!
    const float ambient = AP::baro().get_temperature();

    const uint32_t now_ms = AP_HAL::millis();

    const float delta_t = (now_ms - engine.last_update_ms) * 1e-6;
    engine.last_update_ms = now_ms;

    // lose heat to environment (air-cooling due to airspeed and prop
    // airflow could be taken into account here)
    const float ENV_LOSS_FACTOR = 25;
    engine.cht1_temperature -= (engine.cht1_temperature - ambient) * delta_t * ENV_LOSS_FACTOR;
    engine.cht2_temperature -= (engine.cht2_temperature - ambient) * delta_t * ENV_LOSS_FACTOR;

    const float rpm = sitl->state.rpm[HIRTH_RPM_INDEX];
    const float RPM_GAIN_FACTOR_CHT1 = 10;
    const float RPM_GAIN_FACTOR_CHT2 = 8;
    engine.cht1_temperature += rpm * delta_t * RPM_GAIN_FACTOR_CHT1;
    engine.cht2_temperature += rpm * delta_t * RPM_GAIN_FACTOR_CHT2;
}

void EFI_Hirth::init()
{
    // auto sitl = AP::sitl();

    if (is_zero(AP::baro().get_temperature())) {
        // defer until the baro has had a chance to update....
        return;
    }

    engine.cht1_temperature = AP::baro().get_temperature();
    engine.cht2_temperature = AP::baro().get_temperature();

    init_done = true;
}

void EFI_Hirth::update()
{
    const auto *sitl = AP::sitl();
    if (!sitl || sitl->efi_type != SIM::EFI_TYPE_HIRTH) {
        return;
    }

    if (!init_done) {
        init();
    }

    // update throttle; interim thing to make life a little more interesting
    throttle = 0.9 * throttle + 0.1 * settings.throttle/10;

    update_engine_model();

    update_receive();
    update_send();
}

uint16_t EFI_Hirth::engine_status_field_value() const
{
    return (
        0U << 0 |  // engine temperature sensor
        1U << 1 |  // air temperature sensor
        1U << 2 |  // air pressure sensor
        1U << 3    // throttle sensor OK
        );
}

void SITL::EFI_Hirth::send_record1()
{
    const auto *sitl = AP::sitl();

    // notionally the field updates should happen in the update()
    // method, but here to save CPU for now:
    auto &r = packed_record1.record;
    r.engine_status = engine_status_field_value();
    r.rpm = sitl->state.rpm[HIRTH_RPM_INDEX];
    r.air_temperature = AP::baro().get_temperature();
    r.throttle = settings.throttle / 10;  // just echo this back

    packed_record1.update_checksum();

    write_to_autopilot((char*)&packed_record1, sizeof(packed_record1));

    ASSERT_STORAGE_SIZE(Record1, 84);
}

void SITL::EFI_Hirth::send_record2()
{
    const auto *sitl = AP::sitl();

    // notionally the field updates should happen in the update()
    // method, but here to save CPU for now:
    auto &r = packed_record2.record;
    r.throttle_percent_times_10 = throttle * 10.0;
    r.fuel_consumption = ((MAX(sitl->state.rpm[HIRTH_RPM_INDEX] - 1500.0, 0)) /2200.0) * 10;  // from log, very rough

    packed_record2.update_checksum();

    write_to_autopilot((char*)&packed_record2, sizeof(packed_record2));

    ASSERT_STORAGE_SIZE(Record2, 98);
}


void SITL::EFI_Hirth::send_record3()
{
    // notionally the field updates should happen in the update()
    // method, but here to save CPU for now:
    auto &r = packed_record3.record;
    r.excess_temperature_1 = engine.cht1_temperature;  // cht1
    r.excess_temperature_2 = engine.cht2_temperature;  // cht2
    r.excess_temperature_3 = 39;  // egt1
    r.excess_temperature_4 = 41;  // egt2

    packed_record3.update_checksum();

    write_to_autopilot((char*)&packed_record3, sizeof(packed_record3));

    ASSERT_STORAGE_SIZE(Record3, 100);
}
                                                                                                           /*
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
/*
  simulate Hirth EFI system

./Tools/autotest/sim_vehicle.py --gdb --debug -v ArduPlane -A --serial5=sim:hirth --speedup=1
param set SERIAL5_PROTOCOL 24
param set SIM_EFI_TYPE 6
param set EFI_TYPE 6
reboot
status EFI_STATUS

./Tools/autotest/autotest.py --gdb --debug build.Plane test.Plane.Hirth

*/

#pragma once

#include <SITL/SITL.h>
#include <AP_HAL/utility/Socket_native.h>
#include "SIM_SerialDevice.h"

namespace SITL {

class EFI_Hirth : public SerialDevice {
public:

    using SerialDevice::SerialDevice;

    void update();

private:

    void update_receive();
    void update_send();

    void assert_receive_size(uint8_t receive_size);

    void handle_set_values();

    // maps from an on-wire number to a record number:
    enum class PacketCode : uint8_t {
        DataRecord1 = 4,
        DataRecord2 = 11,
        DataRecord3 = 13,
        SetValues = 201,
    };

    template <typename T>
    class PACKED PackedRecord {
    public:
        PackedRecord(PacketCode _code, T _record) :
            code(uint8_t(_code)),
            record(_record)
        { }
            const uint8_t length { sizeof(T) + 3 };  // 1 each of length, code and checksum
        const uint8_t code;
        T record;
        uint8_t checksum;

        void update() {
            record.update();
            update_checksum();
        }

        void update_checksum() {
            checksum = 256U - crc_sum_of_bytes((uint8_t*)this, length-1);
        }
    };

    void send_record1();
    void send_record2();
    void send_record3();

    class PACKED Record1 {
    public:
        uint8_t reserved1[2];
        uint16_t save_in_flash;  // "1 = data are saved in flash automatically"
        uint8_t reserved2[4];
        uint16_t engine_status;
        uint16_t rpm;
        uint8_t reserved3[12];
        uint16_t number_of_interfering_pulses;
        uint16_t reserved4[2];
        uint16_t number_of_speed_errors;
        uint16_t injection_time;
        uint16_t ignition_angle;
        uint16_t reserved5;
        uint16_t voltage_throttle;
        uint16_t reserved6;
        uint8_t reserved7[2];
        uint16_t voltage_engine_temperature;
        uint16_t voltage_air_temperature;
        uint8_t reserved8[2];
        uint16_t voltage_int_air_pressure;
        uint8_t reserved9[20];
        int16_t throttle;
        int16_t engine_temperature;
        int16_t battery_voltage;
        int16_t air_temperature;
        int16_t reserved10;
        uint16_t sensor_ok;

        void update();
    };

    class PACKED Record2 {
    public:
        uint8_t reserved1[12];
        int16_t injection_rate_from_basic_graphic_map;
        int16_t reserved2;
        int16_t basic_injection_rate;
        int16_t injection_rate_from_air_correction;
        int16_t reserved3;
        int16_t injection_rate_from_warming_up_characteristic_curve;
        int16_t injection_rate_from_acceleration_enrichment;
        int16_t turn_on_time_of_intake_valves;
        int16_t injection_rate_from_race_switch;
        int16_t reserved4;
        int16_t injection_angle_from_ignition_angle_map;
        int16_t injection_angle_from_air_temperature_characteristic_curve;
        int16_t injection_angle_from_air_pressure_characteristic_curve;
        int16_t ignition_angle_from_engine_temperature_characteristic_curve;
        int16_t ignition_angle_from_acceleration;
        int16_t ignition_angle_from_race_switch;
        uint32_t total_time_in_26ms;
        uint32_t total_number_of_rotations;
        uint16_t fuel_consumption;
        uint16_t number_of_errors_in_error_memory;
        int16_t voltage_input1_throttle_target;
        int16_t reserved5;
        int16_t position_throttle_target;
        uint16_t throttle_percent_times_10;  // percent * 10
        int16_t reserved6[3];
        uint16_t time_of_injector_opening_percent_times_10;
        uint8_t reserved7[10];
        uint32_t no_of_logged_data;
        uint8_t reserved8[12];
    };

    class PACKED Record3 {
    public:
        uint16_t voltage_excess_temperature_1;
        uint16_t voltage_excess_temperature_2;
        uint16_t voltage_excess_temperature_3;
        uint16_t voltage_excess_temperature_4;
        uint16_t voltage_excess_temperature_5;
        uint8_t reserved1[6];
        uint16_t excess_temperature_1;  // cht1
        uint16_t excess_temperature_2;  // cht2
        uint16_t excess_temperature_3;  // egt1
        uint16_t excess_temperature_4;  // egt2
        uint16_t excess_temperature_5;
        uint8_t reserved2[6];
        uint16_t enrichment_excess_temperature_cylinder_1;
        uint16_t enrichment_excess_temperature_cylinder_2;
        uint16_t enrichment_excess_temperature_cylinder_3;
        uint16_t enrichment_excess_temperature_cylinder_4;
        uint8_t reserved3[6];
        uint16_t enrichment_excess_temperature_bitfield;
        uint16_t mixing_ratio_oil_pump1;
        uint16_t mixing_ratio_oil_pump2;
        uint16_t ouput_value_water_pump;
        uint16_t ouput_value_fuel_pump;
        uint16_t ouput_value_exhaust_valve;
        uint16_t ouput_value_air_vane;
        uint16_t ouput_value_e_throttle;
        uint16_t number_of_injections_oil_pump_1;
        uint32_t system_time_in_ms;
        uint16_t number_of_injections_oil_pump_2;
        uint16_t target_rpm;
        uint16_t FPC;
        // these appear to be duplicates of the above; one is probably
        // voltage?
        uint16_t xenrichment_excess_temperature_cylinder_1;
        uint16_t xenrichment_excess_temperature_cylinder_2;
        uint16_t xenrichment_excess_temperature_cylinder_3;
        uint16_t xenrichment_excess_temperature_cylinder_4;
        uint16_t voltage_input_temperature_crankshaft_housing;
        uint16_t temperature_crankshaft_housing;
        uint8_t reserved4[14];
    };

    class PACKED SetValues {
    public:
        int16_t throttle;  // percent * 10
        int16_t rpm;;
        int8_t reserved1[16];
    };

    // these records are just used for initial values of the fields;
    // they aren't used past that.
    Record1 record1;
    Record2 record2;
    Record3 record3;


    SetValues settings;

    PackedRecord<Record1> packed_record1{PacketCode::DataRecord1, record1};
    PackedRecord<Record2> packed_record2{PacketCode::DataRecord2, record2};
    PackedRecord<Record3> packed_record3{PacketCode::DataRecord3, record3};

    struct {
        PacketCode code;  // code which was requested by driver
        uint32_t time_ms;  // time that code was requested by driver
    } requested_data_record;

    uint8_t receive_buf[32];
    uint8_t receive_buf_ofs;

    float throttle;

    uint16_t engine_status_field_value() const;

    void init();
    bool init_done = false;

    // engine model:
    void update_engine_model();
    struct {
        float cht1_temperature;  // engine reports in deg-C
        float cht2_temperature;
        uint32_t last_update_ms;
    } engine;
};

}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           /*
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
/*
  simulate MegaSquirt EFI system
*/

#include "SIM_Aircraft.h"
#include <SITL/SITL.h>
#include <AP_HAL/utility/sparse-endian.h>
#include <stdio.h>
#include "SIM_EFI_MegaSquirt.h"

using namespace SITL;

static uint32_t CRC32_MS(const uint8_t *buf, uint32_t len)
{
    uint32_t crc = 0;
    while (len--) {
        crc ^= ~0U;
        crc = crc_crc32(crc, buf++, 1);
        crc ^= ~0U;
    }
    return crc;
}

void EFI_MegaSquirt::update()
{
    auto sitl = AP::sitl();
    if (!sitl || sitl->efi_type != SIM::EFI_TYPE_MS) {
        return;
    }
    const float rpm = sitl->state.rpm[2];

    tps = 0.9 * tps + 0.1 * (rpm / 7000) * 100;

    table7.rpm = rpm;
    table7.fuelload = 20;
    table7.dwell = 2.0;
    table7.baro_hPa = 1000;
    table7.map_hPa = 895;
    table7.mat_cF = C_TO_F(AP::baro().get_temperature()) * 10;
    table7.fuelPressure = 6280;
    table7.throttle_pos = tps * 10;
    table7.ct_cF = 3940;
    table7.afr_target1 = 148;

    // receive command
    while (ofs < sizeof(r_command)) {
        if (read_from_autopilot((char*)&buf[ofs], 1) != 1) {
            break;
        }
        switch (ofs) {
        case 0:
            if (buf[ofs] == 0) {
                ofs++;
            }
            break;
        case 1:
            if (buf[ofs] != 7) {
                ofs = 0;
            } else {
                ofs++;
            }
            break;
        case 2:
            if (buf[ofs] != 0x72) {
                ofs = 0;
            } else {
                ofs++;
            }
            break;
        case 3:
            if (buf[ofs] != 0x00) {
                ofs = 0;
            } else {
                ofs++;
            }
            break;
        case 4:
            if (buf[ofs] != 0x07) {
                ofs = 0;
            } else {
                ofs++;
            }
            break;
        case 5 ... 12:
            ofs++;
            break;
        }
    }
    if (ofs >= sizeof(r_command)) {
        // check CRC
        uint32_t crc = CRC32_MS(&buf[2], sizeof(r_command)-6);
        uint32_t crc2 = be32toh(r_command.crc);
        if (crc == crc2) {
            send_table();
        } else {
            printf("BAD EFI CRC: 0x%08x 0x%08x\n", crc, crc2);
        }
        ofs = 0;
    }
}

/*
  send table response
 */
void EFI_MegaSquirt::send_table(void)
{
    uint16_t table_offset = be16toh(r_command.table_offset);
    uint16_t table_size = be16toh(r_command.table_size);

    if (table_offset >= sizeof(table7)) {
        printf("EFI_MS: bad table_offset %u\n", table_offset);
        return;
    }
    if (table_size+table_offset > sizeof(table7)) {
        table_size = sizeof(table7) - table_offset;
    }

    uint16_t len = htobe16(table_size+1);
    uint8_t outbuf[1+table_size];
    outbuf[0] = 0;
    swab(table_offset+(const uint8_t *)&table7, &outbuf[1], table_size);

    write_to_autopilot((const char*)&len, sizeof(len));
    write_to_autopilot((const char*)outbuf, sizeof(outbuf));
    uint32_t crc = htobe32(CRC32_MS(outbuf, sizeof(outbuf)));
    write_to_autopilot((const char *)&crc, sizeof(crc));
}
                                                                                                                                                                                                                                                                                                                                                                /*
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
/*
  simulate MegaSquirt EFI system

./Tools/autotest/sim_vehicle.py --gdb --debug -v ArduPlane -A --serial5=sim:megasquirt --speedup=1
param set SERIAL5_PROTOCOL 24
param set SIM_EFI_TYPE 1
param set EFI_TYPE 1
reboot
status EFI_STATUS

./Tools/autotest/autotest.py --gdb --debug build.Plane test.Plane.MegaSquirt

*/

#pragma once

#include <AP_HAL/utility/Socket_native.h>
#include <SITL/SITL.h>
#include "SIM_SerialDevice.h"

namespace SITL {

class EFI_MegaSquirt : public SerialDevice {
public:

    using SerialDevice::SerialDevice;

    void update();

private:
    void send_table();

    struct PACKED {
        uint16_t size;
        uint8_t command;
        uint8_t CANid;
        uint8_t table;
        uint16_t table_offset;
        uint16_t table_size;
        uint32_t crc;
    } r_command;
    uint8_t *buf = (uint8_t *)&r_command;
    uint8_t ofs;
    
    struct PACKED {
        uint16_t uptime_s;
        uint16_t pulseWidth1_us;
        uint16_t pulseWidth2_us;
        uint16_t rpm;
        int16_t advance_cdeg;
        int8_t squirt;
        int8_t engine_status;
        uint8_t afr_target1;
        uint8_t afr_target2;
        uint8_t wbo2_en1;
        uint8_t wbo2_en2;
        int16_t baro_hPa;
        int16_t map_hPa;
        int16_t mat_cF;
        int16_t ct_cF;
        int16_t throttle_pos;
        int16_t afr1;
        int16_t afr2;
        int16_t knock;
        int16_t egocor1;
        int16_t egocor2;
        int16_t aircor;
        int16_t warmcor;
        int16_t accel_enrich;
        int16_t tps_fuel_cut;
        int16_t baroCorrection;
        int16_t gammaEnrich;
        int16_t ve1;
        int16_t ve2;
        int16_t iacstep;
        int16_t cold_adv_deg;
        int16_t TPSdot;
        int16_t MAPdot;
        int16_t dwell;
        int16_t MAF;
        uint8_t fuelload;
        uint8_t pad[128-67];
        uint16_t fuelPressure;
    } table7;

    float tps;
};

}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  #include <AP_HAL/AP_HAL.h>

// Only support ELRS simulation in SITL (not Sim on Hardware)
#if CONFIG_HAL_BOARD == HAL_BOARD_SITL

#include "SIM_ELRS.h"
#include <SITL/SITL.h>

#include <AP_HAL_SITL/AP_HAL_SITL.h>
#include <AP_HAL_SITL/UARTDriver.h>

#include "include/mavlink/v2.0/all/mavlink.h"

// Example command: -A --serial2=sim:ELRS
// TCP connection will be started on normal AP port eg 5763 for serial 2

// Baud rate must be set correctly
// param set SERIAL2_BAUD 460

using namespace SITL;

ELRS::ELRS(const uint8_t portNumber, HALSITL::SITL_State_Common *sitl_state) :
    // Mirror typical ELRS UART buffer sizes
    SerialDevice::SerialDevice(64, 128),
    target_address("127.0.0.1"),
    target_port(5761 + portNumber),
    // Mirror MAVLink buffer sizes
    mavlinkInputBuffer(2048),
    mavlinkOutputBuffer(2048),
    // Typical setup is about 500 B /s
    input_data_rate(500),
    output_data_rate(500),
    // 255 is typically used by the GCS, for RC override to work in ArduPilot `SYSID_MYGCS` must be set to this value (255 is the default)
    this_system_id(255),
    // Strictly this is not a valid source component ID
    this_component_id(MAV_COMPONENT::MAV_COMP_ID_ALL)
{

    // Setup TCP server
    listener.reuseaddress();
    listener.bind(target_address, target_port);
    listener.listen(1);
    listener.set_blocking(false);

}

void ELRS::update()
{
    // Connect to incoming TCP
    if (sock == nullptr) {
        sock = listener.accept(0);
        if (sock != nullptr) {
            sock->set_blocking(false);
            sock->reuseaddress();
            ::printf("ELRS connected to %s:%u\n", target_address, (unsigned)target_port);
        }
    }
    if (sock == nullptr) {
        return;
    }

    // Read from AP into radio
    const uint32_t input_space = mavlinkInputBuffer.space();
    if (input_space > 0) {
        uint8_t buf[input_space];
        ssize_t len = read_from_autopilot((char*)buf, input_space);
        mavlinkInputBuffer.write(buf, len);
    }

    // Send from radio to GCS
    const uint32_t send_bytes = input_limit.max_bytes(input_data_rate);
    if (send_bytes > 0) {
        uint8_t buf[send_bytes];
        const uint32_t len = mavlinkInputBuffer.read(buf, send_bytes);
        if (len > 0) {
            sock->send(buf, len);
        }
    }

    // Incoming data from GCS to radio
    const uint32_t receive_bytes = output_limit.max_bytes(output_data_rate);
    if (receive_bytes > 0) {
        uint8_t buf[receive_bytes];
        const ssize_t len = sock->recv(buf, receive_bytes, 1);
        if (len > 0) {
            mavlinkOutputBuffer.write(buf, len);
        } else if (len == 0) {
            // EOF, go back to waiting for a new connection
            delete sock;
            sock = nullptr;
        }
    }

    // Write from radio to AP
    sendQueuedData();
}

// Function to behave like MAVLink libs `mavlink_parse_char` but use local buffer
uint8_t ELRS::mavlink_parse_char_helper(uint8_t c, mavlink_message_t* r_message, mavlink_status_t* r_mavlink_status)
{
    uint8_t msg_received = mavlink_frame_char_buffer(&mavlink.rxmsg, &mavlink.status, c, r_message, r_mavlink_status);
    if ((msg_received == MAVLINK_FRAMING_BAD_CRC) || (msg_received == MAVLINK_FRAMING_BAD_SIGNATURE)) {
        return 0;
    }
    return msg_received;
}

// Send incoming data to AP, this is a re-implementation of the ELRS function found here:
// https://github.com/ExpressLRS/ExpressLRS/blob/0d31863f34ca16a036e94a9c2a56038ae56c7f9e/src/src/rx-serial/SerialMavlink.cpp#L78
void ELRS::sendQueuedData()
{

    // Send radio messages at 100Hz
    const uint32_t now = AP_HAL::millis();
    if ((now - lastSentFlowCtrl) > 10) {
        lastSentFlowCtrl = now; 

        // Space remaining as a percentage.
        const uint8_t percentage_remaining = (mavlinkInputBuffer.space() * 100) / mavlinkInputBuffer.get_size();

        // Populate radio status packet
        const mavlink_radio_status_t radio_status {
            rxerrors: 0,
            fixed: 0,
            rssi: UINT8_MAX, // Unknown
            remrssi: UINT8_MAX, // Unknown
            txbuf: percentage_remaining,
            noise: UINT8_MAX, // Unknown
            remnoise: UINT8_MAX, // Unknown
        };

        uint8_t buf[MAVLINK_MSG_ID_RADIO_STATUS_LEN + MAVLINK_NUM_NON_PAYLOAD_BYTES];
        mavlink_message_t msg;
        mavlink_msg_radio_status_encode(this_system_id, this_component_id, &msg, &radio_status);
        uint16_t len = mavlink_msg_to_send_buffer(buf, &msg);
        write_to_autopilot((char*)buf, len);
    }

    // Read one byte at a time until were done
    while (true) {
        uint8_t c;
        if (!mavlinkOutputBuffer.read_byte(&c)) {
            break;
        }

        mavlink_message_t msg;
        mavlink_status_t status;

        // Try parse a mavlink message
        if (mavlink_parse_char_helper(c, &msg, &status)) {
            // Message decoded successfully

            // Forward message to the UART
            uint8_t buf[MAVLINK_MAX_PACKET_LEN];
            uint16_t len = mavlink_msg_to_send_buffer(buf, &msg);
            uint16_t written = write_to_autopilot((char*)buf, len);
            if ((written != uint16_t(-1)) && (len != written)) {
                ::fprintf(stderr, "Failed to write full msg, wanted %u achieved %u (msg id: %u)\n", len, written, msg.msgid);
            }
        }
    }

}

#endif // CONFIG_HAL_BOARD == HAL_BOARD_SITL
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           #pragma once

#include <SITL/SITL.h>
#include "SIM_SerialDevice.h"
#include <AP_HAL/utility/DataRateLimit.h>
#include <AP_HAL/utility/Socket_native.h>

namespace SITL {

class ELRS : public SerialDevice {
public:
    ELRS(const uint8_t portNumber, HALSITL::SITL_State_Common *sitl_state);

    uint32_t device_baud() const override { return 460800; }

    void update();

private:
    void sendQueuedData();

    struct {
        mavlink_message_t rxmsg;
        mavlink_status_t status;
    } mavlink;

    uint8_t mavlink_parse_char_helper(uint8_t c, mavlink_message_t* r_message, mavlink_status_t* r_mavlink_status);

    ByteBuffer mavlinkInputBuffer;
    ByteBuffer mavlinkOutputBuffer;

    DataRateLimit input_limit;
    DataRateLimit output_limit;

    uint32_t lastSentFlowCtrl;

    const uint8_t this_system_id;
    const uint8_t this_component_id;

    // Air data rate limits in bytes per second
    const float input_data_rate;
    const float output_data_rate;

    // Sockets for communicating with GCS
    SocketAPM_native listener {false};
    SocketAPM_native *sock = nullptr;
    const char *target_address;
    const uint16_t target_port;

};

}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 /*
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
/*
  Simulator for the FETtecOneWireESC

  TODO:
 - verify the assertion that DMA is required
 - stop ignoring REQ_TYPE while in bootloader?
 - correct visibility of members in simulation
 - half-duplex will require the use of a thread as every time we call update() we expect to send out a configuration message
 - tidy break vs return in AP_FETtec::handle_message
 - determine if we should have a "REQ_OK" as well as an "OK"
 - should rename simulated ESC "pwm" field to "value" or "fettec_value" or something
 - periodically log _unknown_esc_message, _message_invalid_in_state_count, _period_too_short, _receive_buf_used to dataflash using a low prio thread.
 - log type, version, subversion and sn to dataflash once.



Protocol:
 - SET_FAST_COM_LENGTH could set a 32-bit bitmask that will be present rather than requring consecutive motors
 - Use two magic bytes in the header instead of just one
 - Use a 16bit CRC
 - the reply request needs to repeat the data that it replies to, to make sure the reply can be clearly assigned to a request
 - need to cope with reversals
 - in the case that we don't have ESC telemetry, consider probing ESCs periodically with an "OK"-request while disarmed
*/

#include <AP_HAL/AP_HAL.h>

extern const AP_HAL::HAL& hal;

#include <AP_Math/AP_Math.h>

#include "SIM_FETtecOneWireESC.h"
#include "SITL.h"
#include <AP_HAL/utility/sparse-endian.h>

#include "SIM_Aircraft.h"

#include <stdio.h>
#include <errno.h>

using namespace SITL;

// table of user settable parameters
const AP_Param::GroupInfo FETtecOneWireESC::var_info[] = {

    // @Param: ENA
    // @DisplayName: FETtec OneWire ESC simulator enable/disable
    // @Description: Allows you to enable (1) or disable (0) the FETtecOneWireESC simulator
    // @Values: 0:Disabled,1:Enabled
    // @User: Advanced
    AP_GROUPINFO("ENA", 1, FETtecOneWireESC, _enabled, 0),

    // @Param: PWOF
    // @DisplayName: Power off FETtec ESC mask
    // @Description: Allows you to turn power off to the simulated ESCs.  Bits correspond to the ESC ID, *NOT* their servo channel.
    // @User: Advanced
    AP_GROUPINFO("POW", 2, FETtecOneWireESC, _powered_mask, 0xfff),

    AP_GROUPEND
};

FETtecOneWireESC::FETtecOneWireESC() : SerialDevice::SerialDevice()
{
    AP_Param::setup_object_defaults(this, var_info);

    // initialise serial numbers and IDs
    for (uint8_t n=0; n<ARRAY_SIZE(escs); n++) {
        ESC &esc = escs[n];
        esc.ofs = n;  // so we can index for RPM, for example
        esc.id = n+1;  // really should parameterise this
        for (uint8_t i=0; i<ARRAY_SIZE(esc.sn); i++) {
            esc.sn[i] = n+1;
        }
    }
}

void FETtecOneWireESC::update_escs()
{
    // process the power-off mask
    for (auto  &esc : escs) {
        bool should_be_on = _powered_mask & (1U<<(esc.id-1));
        switch (esc.state) {
        case ESC::State::POWERED_OFF:
            if (should_be_on) {
                esc.state = ESC::State::IN_BOOTLOADER;
                esc.pwm = 0;
                esc.fast_com = {};
                esc.telem_request = false;
            }
            break;
        case ESC::State::IN_BOOTLOADER:
        case ESC::State::RUNNING:
        case ESC::State::RUNNING_START:
            if (!should_be_on) {
                esc.state = ESC::State::POWERED_OFF;
                break;
            }
        }
    }

    for (auto  &esc : escs) {
        switch (esc.state) {
        case ESC::State::POWERED_OFF:
        case ESC::State::IN_BOOTLOADER:
        case ESC::State::RUNNING:
            continue;
        case ESC::State::RUNNING_START:
            esc.set_state(ESC::State::RUNNING);
            send_response(PackedMessage<OK> {
                esc.id,
                OK{}
            });
        }
    }

    for (auto  &esc : escs) {
        if (esc.state != ESC::State::RUNNING) {
            continue;
        }
        // FIXME: this may not be an entirely accurate model of the
        // temperature profile of these ESCs.
        esc.temperature += esc.pwm/100000;
        esc.temperature *= 0.95;
    }
}

void FETtecOneWireESC::update(const class Aircraft &aircraft)
{
    if (!_enabled.get()) {
        return;
    }

    update_escs();

    update_input();
    update_send(aircraft);
}

void FETtecOneWireESC::handle_config_message()
{
    ESC &esc = escs[u.config_message_header.target_id-1];
    simfet_debug("Config message type=%u esc=%u", (unsigned)u.config_message_header.request_type, (unsigned)u.config_message_header.target_id);
    if ((ResponseFrameHeaderID)u.config_message_header.header != ResponseFrameHeaderID::MASTER) {
        AP_HAL::panic("Unexpected header ID");
    }
    switch (esc.state) {
    case ESC::State::POWERED_OFF:
        return;
    case ESC::State::IN_BOOTLOADER:
        return bootloader_handle_config_message(esc);
    case ESC::State::RUNNING_START:
        return;
    case ESC::State::RUNNING:
        return running_handle_config_message(esc);
    }
    AP_HAL::panic("Unknown state");
}

template <typename T>
void FETtecOneWireESC::send_response(const T &r)
{
    // simfet_debug("Sending response");
    if (write_to_autopilot((char*)&r, sizeof(r)) != sizeof(r)) {
        AP_HAL::panic("short write");
    }
}

void FETtecOneWireESC::bootloader_handle_config_message(FETtecOneWireESC::ESC &esc)
{
    switch ((ConfigMessageType)u.config_message_header.request_type) {
    case ConfigMessageType::OK: {
        PackedMessage<OK> msg {
            esc.id,
            OK{},
        };
        msg.header = (uint8_t)ResponseFrameHeaderID::BOOTLOADER;
        msg.update_checksum();
        send_response(msg);
        return;
    }
    case ConfigMessageType::BL_PAGE_CORRECT:   // BL only
    case ConfigMessageType::NOT_OK:
        break;
    case ConfigMessageType::BL_START_FW:       // BL only
        esc.set_state(ESC::State::RUNNING_START);
        // the main firmware sends an OK
        return;
    case ConfigMessageType::BL_PAGES_TO_FLASH: // BL only
        break;
    case ConfigMessageType::REQ_TYPE:
        // ignore this for now
        return;
    case ConfigMessageType::REQ_SN:
    case ConfigMessageType::REQ_SW_VER:
    case ConfigMessageType::BEEP:
    case ConfigMessageType::SET_FAST_COM_LENGTH:
    case ConfigMessageType::SET_TLM_TYPE: //1 for alternative telemetry. ESC sends full telem per ESC: Temp, Volt, Current, ERPM, Consumption, CrcErrCount
    case ConfigMessageType::SET_LED_TMP_COLOR:
        break;
    }
    return;
    AP_HAL::panic("Unhandled config message in bootloader (%u)",
                  (unsigned)u.config_message_header.request_type);
}

void FETtecOneWireESC::running_handle_config_message(FETtecOneWireESC::ESC &esc)
{
    switch ((ConfigMessageType)u.config_message_header.request_type) {

    case ConfigMessageType::OK:
        return send_response(PackedMessage<OK> {
            esc.id,
            OK{}
        });

    case ConfigMessageType::BL_PAGE_CORRECT:   // BL only
    case ConfigMessageType::NOT_OK:
        break;
    case ConfigMessageType::BL_START_FW:       // BL only
        hal.console->printf("received unexpected BL_START_FW message\n");
        AP_HAL::panic("received unexpected BL_START_FW message");
        return;
    case ConfigMessageType::BL_PAGES_TO_FLASH: // BL only
        break;

    case ConfigMessageType::REQ_TYPE:
        return send_response(PackedMessage<ESC_TYPE> {
            esc.id,
            ESC_TYPE{esc.type}
        });

    case ConfigMessageType::REQ_SN:
        return send_response(PackedMessage<SN> {
            esc.id,
            SN{esc.sn, ARRAY_SIZE(esc.sn)}
        });

    case ConfigMessageType::REQ_SW_VER:
        return send_response(PackedMessage<SW_VER> {
            esc.id,
            SW_VER{esc.sw_version, esc.sw_subversion}
        });

    case ConfigMessageType::BEEP:
        break;

    case ConfigMessageType::SET_FAST_COM_LENGTH:
        esc.fast_com.length = u.packed_set_fast_com_length.msg.length;
        esc.fast_com.byte_count = u.packed_set_fast_com_length.msg.byte_count;
        esc.fast_com.min_esc_id = u.packed_set_fast_com_length.msg.min_esc_id;
        esc.fast_com.id_count = u.packed_set_fast_com_length.msg.id_count;
        return send_response(PackedMessage<OK> {
            esc.id,
            OK{}
        });

    case ConfigMessageType::SET_TLM_TYPE: //1 for alternative telemetry. ESC sends full telem per ESC: Temp, Volt, Current, ERPM, Consumption, CrcErrCount
        return handle_config_message_set_tlm_type(esc);

    case ConfigMessageType::SET_LED_TMP_COLOR:
        break;
    }
    AP_HAL::panic("Unknown config message (%u)", (unsigned)u.config_message_header.request_type);
}


void FETtecOneWireESC::handle_config_message_set_tlm_type(ESC &esc)
{
    const TLMType type = (TLMType)u.packed_set_tlm_type.msg.type;
    switch (type) {
    case TLMType::NORMAL:
    case TLMType::ALTERNATIVE:
        esc.telem_type = type;
        send_response(PackedMessage<OK> {
            esc.id,
            OK{}
        });
        return;
    }
    AP_HAL::panic("unknown telem type=%u", (unsigned)type);
}

void FETtecOneWireESC::handle_fast_esc_data()
{
    // decode first byte - see driver for details
    const uint8_t telem_request = u.buffer[0] >> 4;

    // offset into escs array for first esc involved in fast-throttle
    // command:
    const uint8_t esc0_ofs = fast_com.min_esc_id - 1;

    // ::fprintf(stderr, "telem_request=%u\n", (unsigned)telem_request);
    uint16_t esc0_pwm;
    esc0_pwm = ((u.buffer[0] >> 3) & 0x1) << 10;
    if ((u.buffer[0] & 0b111) != 0x1) {
        AP_HAL::panic("expected fast-throttle command");
    }

    // decode second byte
    esc0_pwm |= (u.buffer[1] >> 5) << 7;
    if ((u.buffer[1] & 0b00011111) != 0x1f) {
        AP_HAL::panic("Unexpected 5-bit target id");
    }

    // decode enough of third byte to complete pwm[0]
    esc0_pwm |= u.buffer[2] >> 1;

    if (escs[esc0_ofs].state == ESC::State::RUNNING) {
        ESC &esc { escs[esc0_ofs] };
        esc.pwm = esc0_pwm;

        if (telem_request == esc.id) {
            esc.telem_request = true;
        }
        simfet_debug("esc=%u out: %u", esc.id, (unsigned)esc.pwm);
    }

    // decode remainder of ESC values

    // slides a window across the input buffer, extracting 11-bit ESC
    // values.  The top 11 bits in "window" are the ESC value.
    uint8_t byte_ofs = 2;
    uint32_t window = u.buffer[byte_ofs++]<<24;
    window <<= 7;
    uint8_t bits_free = 32-1;
    for (uint8_t i=esc0_ofs+1; i<esc0_ofs+fast_com.id_count; i++) {
        while (bits_free > 7) {
            window |= u.buffer[byte_ofs++] << (bits_free-8);
            bits_free -= 8;
        }
        ESC &esc { escs[i] };
        if (esc.state == ESC::State::RUNNING) {
            if (telem_request == esc.id) {
                esc.telem_request = true;
            }
            esc.pwm = window >> 21;
            simfet_debug("esc=%u out: %u", esc.id, (unsigned)esc.pwm);
        }
        window <<= 11;
        bits_free += 11;
    }

    for (uint8_t i=0; i<ARRAY_SIZE(escs); i++) {
        const ESC &esc { escs[i] };
        if (esc.pwm == 0) {
            continue;
        }
        // this will need to adjust for reversals.  We should also set
        // one of the simulated ESCs up to have a pair of motor wires
        // crossed i.e. spin backwards.  Maybe a mask for it
        if (esc.pwm >= 1000 && esc.pwm <= 2000) {
            continue;
        }
        AP_HAL::panic("transmitted value out of range (%u)", esc.pwm);
    }
}

void FETtecOneWireESC::consume_bytes(uint8_t count)
{
    if (count > buflen) {
        AP_HAL::panic("Consuming more bytes than in buffer?");
    }
    if (buflen == count) {
        buflen = 0;
        return;
    }
    memmove(&u.buffer[0], &u.buffer[count], buflen - count);
    buflen -= count;
}

void FETtecOneWireESC::update_input()
{
    const ssize_t n = read_from_autopilot((char*)&u.buffer[buflen], ARRAY_SIZE(u.buffer) - buflen - 1);
    if (n < 0) {
        // TODO: do better here
        if (errno != EAGAIN && errno != EWOULDBLOCK && errno != 0) {
            AP_HAL::panic("Failed to read from autopilot");
        }
    } else {
        buflen += n;
    }

    // bool config_message_checksum_fail = false;

    if (buflen > offsetof(ConfigMessageHeader, header) &&
        u.config_message_header.header == 0x01 &&
        buflen > offsetof(ConfigMessageHeader, frame_len) &&
        buflen >= u.config_message_header.frame_len) {
        const uint8_t calculated_checksum = crc8_dvb_update(0, u.buffer, u.config_message_header.frame_len-1);
        const uint8_t received_checksum = u.buffer[u.config_message_header.frame_len-1];
        if (calculated_checksum == received_checksum) {
            handle_config_message();
            // consume the message:
            consume_bytes(u.config_message_header.frame_len);
            return;
        } else {
            simfet_debug("Checksum mismatch");
            abort();
            // config_message_checksum_fail = true;
        }
        return; // 1 message/loop....
    }

    // no config message, so let's see if there's fast PWM input.
    if (fast_com.id_count == 255) {
        // see if any ESC has been configured:
        for (uint8_t i=0; i<ARRAY_SIZE(escs); i++) {
            if (escs[i].fast_com.id_count == 255) {
                continue;
            }
            fast_com.id_count = escs[i].fast_com.id_count;
            fast_com.min_esc_id = escs[i].fast_com.min_esc_id;
            break;
        }
    }
    if (fast_com.id_count == 255) {
        // no ESC is configured.  Ummm.
        buflen = 0;
        return;
    }

    const uint16_t total_bits_required = 4 + 1 + 7  + (fast_com.id_count*11);
    const uint8_t bytes_required = (total_bits_required + 7) / 8 + 1;

    if (buflen < bytes_required) {
        return;
    }

    if (buflen == bytes_required) {
        const uint8_t calculated_checksum = crc8_dvb_update(0, u.buffer, buflen-1);
        if (u.buffer[buflen-1] != calculated_checksum) {
            AP_HAL::panic("checksum failure");
        }

        handle_fast_esc_data();
        consume_bytes(bytes_required);
        return;
    }

    // debug("Read (%d) bytes from autopilot (%u)", (signed)n, config_message_checksum_fail);
    if (n >= 0) {
        abort();
    }
    buflen = 0;
}

void FETtecOneWireESC::update_sitl_input_pwm(struct sitl_input &input)
{
    // overwrite the SITL input values passed through from
    // sitl_model->update_model with those we're receiving serially
    for (auto &esc : escs) {
        if (esc.id > ARRAY_SIZE(input.servos)) {
            // silently ignore; input.servos is 12-long, we are
            // usually 16-long
            continue;
        }
        input.servos[esc.id-1] = esc.pwm;
    }
}

void FETtecOneWireESC::send_esc_telemetry(const Aircraft &aircraft)
{
    for (auto &esc : escs) {
        if (!esc.telem_request) {
            continue;
        }
        esc.telem_request = false;
        if (esc.state != ESC::State::RUNNING) {
            continue;
        }
        if (esc.telem_type != TLMType::ALTERNATIVE) {
            // no idea what "normal" looks like
            abort();
        }

        const int8_t temp_cdeg = esc.temperature * 100;
        const uint16_t voltage = aircraft.get_battery_voltage() * 100;
        const uint16_t current = (6 + esc.id * 100);

        // FIXME: the vehicle models should be supplying this RPM!
        const uint16_t Kv = 1000;
        const float p = (esc.pwm-1000)/1000.0;
        int16_t rpm = aircraft.get_battery_voltage() * Kv * p;

        const uint16_t consumption_mah = 0;
        const uint16_t errcount = 17;
        send_response(PackedMessage<ESCTelem> {
            esc.id,
            ESCTelem{temp_cdeg, voltage, current, rpm, consumption_mah, errcount}
        });
    }
}

void FETtecOneWireESC::update_send(const Aircraft &aircraft)
{
    send_esc_telemetry(aircraft);
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   /*
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
/*
  Simulator for the FETtecOneWire ESCs

./Tools/autotest/sim_vehicle.py --gdb --debug -v ArduCopter -A --serial5=sim:fetteconewireesc --speedup=1 --console

param set SERIAL5_PROTOCOL 38
param set SERIAL5_BAUD 500000
param set SERVO_FTW_MASK 15
param set SIM_FTOWESC_ENA 1
reboot

param fetch

#param set SIM_FTOWESC_FM 1  # fail mask

./Tools/autotest/autotest.py --gdb --debug build.ArduCopter fly.ArduCopter.FETtecESC

*/

#pragma once

#include <AP_Param/AP_Param.h>

#include "SITL_Input.h"

#include "SIM_SerialDevice.h"

#include <stdio.h>

#define SIM_FTW_DEBUGGING 0
#if SIM_FTW_DEBUGGING
#define simfet_debug(fmt, args ...)  do {::fprintf(stderr,"SIMFET: %s:%d: " fmt "\n", __FUNCTION__, __LINE__, ## args); } while(0)
#else
#define simfet_debug(fmt, args ...)
#endif


namespace SITL {

class FETtecOneWireESC : public SerialDevice {
public:

    FETtecOneWireESC();

    // update state
    void update(const class Aircraft &aircraft);

    static const AP_Param::GroupInfo var_info[];

    bool enabled() const { return _enabled.get(); }

    void update_sitl_input_pwm(struct sitl_input &input);

private:

    AP_Int8  _enabled;  // enable FETtec ESC sim
    AP_Int32  _powered_mask;  // mask of ESCs with power

    struct PACKED ConfigMessageHeader {
        uint8_t header;  // master is always 0x01
        uint8_t target_id;  // 5 bits only
        uint16_t frame_type;
        uint8_t frame_len;
        uint8_t request_type;
    };

    enum class TLMType : uint8_t {
        NORMAL = 0,
        ALTERNATIVE =1,
    };

    template <typename T>
    class PACKED PackedMessage {
    public:
        PackedMessage(uint8_t _target_id, T _msg) :
            target_id{_target_id},
            msg{_msg}
        {
            frame_len = 6 + sizeof(T);
            update_checksum();
        }
        uint8_t header = (uint8_t)ResponseFrameHeaderID::ESC;  // master is always 0x01
        uint8_t target_id;  // 5 bits only
        uint16_t frame_type = 0;
        uint8_t frame_len;
        T msg;
        uint8_t checksum;

        uint8_t calculate_checksum() const WARN_IF_UNUSED {
            return crc8_dvb_update(0, (const uint8_t*)this, frame_len-1);
        }

        void update_checksum() {
            checksum = calculate_checksum();
        }
    };

    class PACKED SetTLMType {
    public:
        SetTLMType(uint8_t _type) :
            type(_type)
            { }
        uint8_t request_type { (uint8_t)ConfigMessageType::SET_TLM_TYPE };
        uint8_t type;
    };

    class PACKED OK {
    public:
        OK() { }
        uint8_t request_type { (uint8_t)ConfigMessageType::OK };
    };

    class PACKED ESC_TYPE {
    public:
        ESC_TYPE(uint8_t _type) :
            type{_type} { }
        uint8_t type;
    };

    class PACKED SW_VER {
    public:
        SW_VER(uint8_t _version, uint8_t _subversion) :
            version{_version},
            subversion{_subversion}
            { }
        uint8_t version;
        uint8_t subversion;
    };

    class PACKED SN {
    public:
        SN(uint8_t *_sn, uint8_t snlen) {
            memset(sn, 0, ARRAY_SIZE(sn));
            memcpy(sn, _sn, MIN(ARRAY_SIZE(sn), snlen));
        }
        uint8_t sn[12];
    };

    class PACKED SetFastComLength {
    public:
        SetFastComLength() {
        }
        uint8_t length;
        uint8_t byte_count;
        uint8_t min_esc_id;
        uint8_t id_count;
    };

            // tlm_from_id = (uint8_t)telem[1];

            // t.temperature_cdeg = int16_t(telem[5+0] * 100);
            // t.voltage = float((telem[5+1]<<8)|telem[5+2]) * 0.01f;
            // t.current = float((telem[5+3]<<8)|telem[5+4]) * 0.01f;
            // centi_erpm = (telem[5+5]<<8)|telem[5+6];
            // t.consumption_mah = float((telem[5+7]<<8)|telem[5+8]);
            // tx_err_count = (telem[5+9]<<8)|telem[5+10];
    class PACKED ESCTelem {
    public:
        ESCTelem(int8_t _temp, uint16_t _voltage, uint16_t _current, int16_t _rpm, uint16_t _consumption_mah, uint16_t _tx_err_count) :
            temp{_temp},
            voltage{_voltage},
            current{_current},
            rpm{_rpm},
            consumption_mah{_consumption_mah},
            tx_err_count{_tx_err_count}
        { }
        int8_t temp;  // centidegrees
        uint16_t voltage;  // centivolts
        uint16_t current;  // centiamps  (signed?)
        int16_t rpm;  // centi-rpm
        uint16_t consumption_mah;  // ???
        uint16_t tx_err_count;
    };


    union MessageUnion {
        MessageUnion() { }
        uint8_t buffer[255];
//        uint16_t checksum_buffer[35];
        struct ConfigMessageHeader config_message_header;

        PackedMessage<OK> packed_ok;
        PackedMessage<SetTLMType> packed_set_tlm_type;
        PackedMessage<SetFastComLength> packed_set_fast_com_length;

        // void update_checksum();
    };
    MessageUnion u;
    uint8_t buflen;

    // remove count bytes from the start of u.buffer
    void consume_bytes(uint8_t count);

    enum class ConfigMessageType {
        OK = 0,
        BL_PAGE_CORRECT = 1,   // BL only
        NOT_OK = 2,
        BL_START_FW = 3,       // BL only
        BL_PAGES_TO_FLASH = 4, // BL only
        REQ_TYPE = 5,
        REQ_SN = 6,
        REQ_SW_VER = 7,
        BEEP = 13,
        SET_FAST_COM_LENGTH = 26,
        SET_TLM_TYPE = 27, //1 for alternative telemetry. ESC sends full telem per ESC: Temp, Volt, Current, ERPM, Consumption, CrcErrCount
        SET_LED_TMP_COLOR = 51,
    };

    class ESC {
    public:

        enum class State {
            POWERED_OFF = 17,
            IN_BOOTLOADER,
            RUNNING_START,
            RUNNING,
            // UNRESPONSIVE,
        };

        void set_state(State _state) {
            simfet_debug("Moving ESC.id=%u from state=%u to state=%u", (unsigned)id, (unsigned)state, (unsigned)_state);
            state = _state;
        }

        State state = State::POWERED_OFF;

        uint8_t sn[12];
        TLMType telem_type;
        uint8_t id;
        uint8_t type = 34;
        static const uint8_t sw_version = 3;
        static const uint8_t sw_subversion = 4;

        // make sure to zero any state when powering the virtual ESC on
        struct {
            uint8_t length;
            uint8_t byte_count;
            uint8_t min_esc_id;
            uint8_t id_count = 255;
        }  fast_com;

        uint16_t pwm;
        bool telem_request;  // true if we've been asked to send telem

        uint8_t ofs;

        float temperature;
    };

    // canonical structure used for fast com, copied from an ESC
    struct {
        uint8_t min_esc_id;
        uint8_t id_count = 255;
    }  fast_com;

    void bootloader_handle_config_message(ESC &esc);
    void running_handle_config_message(ESC &esc);

    void handle_config_message();
    void handle_config_message_set_tlm_type(ESC &esc);

    void handle_fast_esc_data();

    void update_escs();
    void update_send(const class Aircraft &aircraft);
    void update_input();

    void send_esc_telemetry(const class Aircraft &aircraft);

    template <typename T>
    void send_response(const T& r);

    enum class ResponseFrameHeaderID {
        MASTER = 0x01,
        BOOTLOADER = 0x02,
        ESC = 0x03,
    };

    ESC escs[16];
};

}
                                                                                                                                                                                                                                                               /*
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
/*
  simulator connector for FlightAxis
*/

#include "SIM_FlightAxis.h"

#if HAL_SIM_FLIGHTAXIS_ENABLED

#include <arpa/inet.h>
#include <errno.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdarg.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <sys/time.h>

#include <AP_HAL/AP_HAL.h>
#include <AP_Logger/AP_Logger.h>

extern const AP_HAL::HAL& hal;

using namespace SITL;

/*
  we use a thread for socket creation to reduce the impact of socket
  creation latency. These condition variables are used to synchronise
  the thread
 */
static pthread_cond_t sockcond1 = PTHREAD_COND_INITIALIZER;
static pthread_cond_t sockcond2 = PTHREAD_COND_INITIALIZER;
static pthread_mutex_t sockmtx = PTHREAD_MUTEX_INITIALIZER;

// the asprintf() calls are not worth checking for SITL
#pragma GCC diagnostic ignored "-Wunused-result"

static const struct {
    const char *name;
    float value;
    bool save;
} sim_defaults[] = {
    { "BRD_OPTIONS", 0},
    { "AHRS_EKF_TYPE", 10 },
    { "INS_GYR_CAL", 0 },
    { "BATT_MONITOR", 4 },
    { "RC1_MIN", 1000, true },
    { "RC1_MAX", 2000, true },
    { "RC2_MIN", 1000, true },
    { "RC2_MAX", 2000, true },
    { "RC3_MIN", 1000, true },
    { "RC3_MAX", 2000, true },
    { "RC4_MIN", 1000, true },
    { "RC4_MAX", 2000, true },
    { "RC2_REVERSED", 1 }, // interlink has reversed rc2
    { "SERVO1_MIN", 1000 },
    { "SERVO1_MAX", 2000 },
    { "SERVO2_MIN", 1000 },
    { "SERVO2_MAX", 2000 },
    { "SERVO3_MIN", 1000 },
    { "SERVO3_MAX", 2000 },
    { "SERVO4_MIN", 1000 },
    { "SERVO4_MAX", 2000 },
    { "SERVO5_MIN", 1000 },
    { "SERVO5_MAX", 2000 },
    { "SERVO6_MIN", 1000 },
    { "SERVO6_MAX", 2000 },
    { "SERVO6_MIN", 1000 },
    { "SERVO6_MAX", 2000 },
    { "INS_ACC2OFFS_X",    0.001 },
    { "INS_ACC2OFFS_Y",    0.001 },
    { "INS_ACC2OFFS_Z",    0.001 },
    { "INS_ACC2SCAL_X",    1.001 },
    { "INS_ACC2SCAL_Y",    1.001 },
    { "INS_ACC2SCAL_Z",    1.001 },
    { "INS_ACCOFFS_X",     0.001 },
    { "INS_ACCOFFS_Y",     0.001 },
    { "INS_ACCOFFS_Z",     0.001 },
    { "INS_ACCSCAL_X",     1.001 },
    { "INS_ACCSCAL_Y",     1.001 },
    { "INS_ACCSCAL_Z",     1.001 },
    { "RPM1_TYPE", 10 },
};

/*
  get system timestamp in seconds
 */
static double timestamp_sec()
{
    struct timeval tval;
    gettimeofday(&tval,NULL);
    return tval.tv_sec + (tval.tv_usec*1.0e-6);
}

FlightAxis::FlightAxis(const char *frame_str) :
    Aircraft(frame_str)
{
    use_time_sync = false;
    rate_hz = 250 / target_speedup;
    heli_demix = strstr(frame_str, "helidemix") != nullptr;
    rev4_servos = strstr(frame_str, "rev4") != nullptr;
    const char *colon = strchr(frame_str, ':');
    if (colon) {
        controller_ip = colon+1;
    }
    for (uint8_t i=0; i<ARRAY_SIZE(sim_defaults); i++) {
        AP_Param::set_default_by_name(sim_defaults[i].name, sim_defaults[i].value);
        if (sim_defaults[i].save) {
            enum ap_var_type ptype;
            AP_Param *p = AP_Param::find(sim_defaults[i].name, &ptype);
            if (!p->configured()) {
                p->save();
            }
        }
    }

    if (!hal.scheduler->thread_create(FUNCTOR_BIND_MEMBER(&FlightAxis::socket_creator, void), "SocketCreator", 8192,
                                      AP_HAL::Scheduler::PRIORITY_BOOST, 0)) {
        printf("Failed to create socket_creator thread\n");
    }
}
    
/*
  extremely primitive SOAP parser that assumes the format used by FlightAxis
*/
void FlightAxis::parse_reply(const char *reply)
{
    const char *reply0 = reply;
    for (uint16_t i=0; i<num_keys; i++) {
        const char *p = strstr(reply, keytable[i].key);
        if (p == nullptr) {
            p = strstr(reply0, keytable[i].key);
        }
        if (p == nullptr) {
            printf("Failed to find key %s\n", keytable[i].key);
            controller_started = false;
            break;
        }
        p += strlen(keytable[i].key) + 1;
        double v;
        if (strncmp(p, "true", 4) == 0) {
            v = 1;
        } else if (strncmp(p, "false", 5) == 0) {
            v = 0;
        } else {
            v = atof(p);
        }
        keytable[i].ref = v;
        // this assumes key order and allows us to decode arrays
        p = strchr(p, '>');
        if (p != nullptr) {
            reply = p;
        }
    }
}


/*
  make a SOAP request, returning body of reply
 */
bool FlightAxis::soap_request_start(const char *action, const char *fmt, ...)
{
    va_list ap;
    char *req1;

    if (sock) {
        delete sock;
        sock = nullptr;
    }

    va_start(ap, fmt);
    vasprintf(&req1, fmt, ap);
    va_end(ap);

    pthread_mutex_lock(&sockmtx);
    while (socknext == nullptr) {
        pthread_cond_wait(&sockcond1, &sockmtx);
    }
    sock = socknext;
    socknext = nullptr;
    pthread_cond_broadcast(&sockcond2);
    pthread_mutex_unlock(&sockmtx);

    char *req;
    asprintf(&req, R"(POST / HTTP/1.1
soapaction: '%s'
content-length: %u
content-type: text/xml;charset='UTF-8'
Connection: Keep-Alive

%s)",
             action,
             (unsigned)strlen(req1), req1);
    sock->send(req, strlen(req));
    free(req1);
    free(req);
    return true;
}

char *FlightAxis::soap_request_end(uint32_t timeout_ms)
{
    if (!sock) {
        return nullptr;
    }
    if (!sock->pollin(timeout_ms)) {
        return nullptr;
    }
    sock->set_blocking(true);
    ssize_t ret = sock->recv(replybuf, sizeof(replybuf)-1, 1000);
    if (ret <= 0) {
        return nullptr;
    }
    replybuf[ret] = 0;

    char *p = strstr(replybuf, "Content-Length: ");
    if (p == nullptr) {
        delete sock;
        sock = nullptr;
        printf("No Content-Length\n");
        return nullptr;
    }

    // get the content length
    uint32_t content_length = strtoul(p+16, nullptr, 10);
    char *body = strstr(p, "\r\n\r\n");
    if (body == nullptr) {
        printf("No body\n");
        delete sock;
        sock = nullptr;
        return nullptr;
    }
    body += 4;

    // get the rest of the body
    int32_t expected_length = content_length + (body - replybuf);
    if (expected_length >= (int32_t)sizeof(replybuf)) {
        printf("Reply too large %i\n", expected_length);
        delete sock;
        sock = nullptr;
        return nullptr;
    }
    while (ret < expected_length) {
        ssize_t ret2 = sock->recv(&replybuf[ret], sizeof(replybuf)-(1+ret), 1000);
        if (ret2 <= 0) {
            delete sock;
            sock = nullptr;
            return nullptr;
        }
        // nul terminate
        replybuf[ret+ret2] = 0;
        ret += ret2;
    }
    delete sock;
    sock = nullptr;

    return strdup(replybuf);
}

void FlightAxis::exchange_data(const struct sitl_input &input)
{
    if (!sock &&
        (!controller_started ||
         is_zero(state.m_flightAxisControllerIsActive) ||
         !is_zero(state.m_resetButtonHasBeenPressed))) {
        printf("Starting controller at %s\n", controller_ip);
        // call a restore first. This allows us to connect after the aircraft is changed in RealFlight
        soap_request_start("RestoreOriginalControllerDevice", R"(<?xml version='1.0' encoding='UTF-8'?>
<soap:Envelope xmlns:soap='http://schemas.xmlsoap.org/soap/envelope/' xmlns:xsd='http://www.w3.org/2001/XMLSchema' xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'>
<soap:Body>
<RestoreOriginalControllerDevice><a>1</a><b>2</b></RestoreOriginalControllerDevice>
</soap:Body>
</soap:Envelope>)");
        soap_request_end(1000);
        soap_request_start("InjectUAVControllerInterface", R"(<?xml version='1.0' encoding='UTF-8'?>
<soap:Envelope xmlns:soap='http://schemas.xmlsoap.org/soap/envelope/' xmlns:xsd='http://www.w3.org/2001/XMLSchema' xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'>
<soap:Body>
<InjectUAVControllerInterface><a>1</a><b>2</b></InjectUAVControllerInterface>
</soap:Body>
</soap:Envelope>)");
        soap_request_end(1000);
        activation_frame_counter = frame_counter;
        controller_started = true;
    }

    // maximum number of servos to send is 12 with new FlightAxis
    float scaled_servos[12];
    for (uint8_t i=0; i<ARRAY_SIZE(scaled_servos); i++) {
        scaled_servos[i] = (input.servos[i] - 1000) / 1000.0f;
    }

    if (rev4_servos) {
        // swap first 4 and last 4 servos, for quadplane testing
        float saved[4];
        memcpy(saved, &scaled_servos[0], sizeof(saved));
        memcpy(&scaled_servos[0], &scaled_servos[4], sizeof(saved));
        memcpy(&scaled_servos[4], saved, sizeof(saved));
    }

    if (heli_demix) {
        // FlightAxis expects "roll/pitch/collective/yaw" input
        float swash1 = scaled_servos[0];
        float swash2 = scaled_servos[1];
        float swash3 = scaled_servos[2];

        float roll_rate = swash1 - swash2;
        float pitch_rate = ((swash1+swash2) / 2.0f - swash3);
        float col = (swash1 + swash2 + swash3) / 3.0;

        scaled_servos[0] = constrain_float(roll_rate + 0.5, 0, 1);
        scaled_servos[1] = constrain_float(pitch_rate + 0.5, 0, 1);
        scaled_servos[2] = constrain_float(col, 0, 1);
    }

    const uint16_t channels = hal.scheduler->is_system_initialized()?4095:0;
    if (!sock) {
        soap_request_start("ExchangeData", R"(<?xml version='1.0' encoding='UTF-8'?><soap:Envelope xmlns:soap='http://schemas.xmlsoap.org/soap/envelope/' xmlns:xsd='http://www.w3.org/2001/XMLSchema' xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'>
<soap:Body>
<ExchangeData>
<pControlInputs>
<m-selectedChannels>%u</m-selectedChannels>
<m-channelValues-0to1>
<item>%.4f</item>
<item>%.4f</item>
<item>%.4f</item>
<item>%.4f</item>
<item>%.4f</item>
<item>%.4f</item>
<item>%.4f</item>
<item>%.4f</item>
<item>%.4f</item>
<item>%.4f</item>
<item>%.4f</item>
<item>%.4f</item>
</m-channelValues-0to1>
</pControlInputs>
</ExchangeData>
</soap:Body>
</soap:Envelope>)",
                           channels,
                           scaled_servos[0],
                           scaled_servos[1],
                           scaled_servos[2],
                           scaled_servos[3],
                           scaled_servos[4],
                           scaled_servos[5],
                           scaled_servos[6],
                           scaled_servos[7],
                           scaled_servos[8],
                           scaled_servos[9],
                           scaled_servos[10],
                           scaled_servos[11]);
    }

    char *reply = nullptr;
    if (sock) {
        reply = soap_request_end(0);
        if (reply == nullptr) {
            sock_error_count++;
            if (sock_error_count >= 10000 && timestamp_sec() - last_recv_sec > 1) {
                printf("socket timeout\n");
                delete sock;
                sock = nullptr;
                sock_error_count = 0;
                last_recv_sec = timestamp_sec();
            }
        }
    }

    if (reply) {
        sock_error_count = 0;
        last_recv_sec = timestamp_sec();
        double lastt_s = state.m_currentPhysicsTime_SEC;
        parse_reply(reply);
        double dt = state.m_currentPhysicsTime_SEC - lastt_s;
        if (dt > 0 && dt < 0.1) {
            if (average_frame_time_s < 1.0e-6) {
                average_frame_time_s = dt;
            }
            average_frame_time_s = average_frame_time_s * 0.98 + dt * 0.02;
        }
        socket_frame_counter++;
        free(reply);
    }
}


/*
  update the FlightAxis simulation by one time step
 */
void FlightAxis::update(const struct sitl_input &input)
{
    last_input = input;
    exchange_data(input);

    double dt_seconds = state.m_currentPhysicsTime_SEC - last_time_s;
    if (dt_seconds < 0) {
        // cope with restarting RealFlight while connected
        initial_time_s = time_now_us * 1.0e-6f;
        last_time_s = state.m_currentPhysicsTime_SEC;
        position_offset.zero();
        return;
    }
    if (dt_seconds < 0.00001f) {
        float delta_time = 0.001;
        // don't go past the next expected frame
        if (delta_time + extrapolated_s > average_frame_time_s) {
            delta_time = average_frame_time_s - extrapolated_s;
        }
        if (delta_time <= 0) {
            return;
        }
        time_now_us += delta_time * 1.0e6;
        extrapolate_sensors(delta_time);
        update_position();
        update_mag_field_bf();
        extrapolated_s += delta_time;
        report_FPS();
        return;
    }

    extrapolated_s = 0;
    
    if (initial_time_s <= 0) {
        dt_seconds = 0.001f;
        initial_time_s = state.m_currentPhysicsTime_SEC - dt_seconds;
    }

    /*
      the quaternion convention in realflight seems to have Z negative
     */
    Quaternion quat(state.m_orientationQuaternion_W,
                    state.m_orientationQuaternion_Y,
                    state.m_orientationQuaternion_X,
                    -state.m_orientationQuaternion_Z);
    quat.rotation_matrix(dcm);

    gyro = Vector3f(radians(constrain_float(state.m_rollRate_DEGpSEC, -2000, 2000)),
                    radians(constrain_float(state.m_pitchRate_DEGpSEC, -2000, 2000)),
                    -radians(constrain_float(state.m_yawRate_DEGpSEC, -2000, 2000))) * target_speedup;

    velocity_ef = Vector3f(state.m_velocityWorldU_MPS,
                             state.m_velocityWorldV_MPS,
                             state.m_velocityWorldW_MPS);
    position = Vector3d(state.m_aircraftPositionY_MTR,
                        state.m_aircraftPositionX_MTR,
                        -state.m_altitudeASL_MTR - home.alt*0.01);
    position.xy() += origin.get_distance_NE_double(home);

    accel_body = {
        float(state.m_accelerationBodyAX_MPS2),
        float(state.m_accelerationBodyAY_MPS2),
        float(state.m_accelerationBodyAZ_MPS2)
    };

    // accel on the ground is nasty in realflight, and prevents helicopter disarm
    if (!is_zero(state.m_isTouchingGround)) {
        Vector3f accel_ef = (velocity_ef - last_velocity_ef) / dt_seconds;
        accel_ef.z -= GRAVITY_MSS;
        accel_body = dcm.transposed() * accel_ef;
    }

    // limit to 16G to match pixhawk
    float a_limit = GRAVITY_MSS*16;
    accel_body.x = constrain_float(accel_body.x, -a_limit, a_limit);
    accel_body.y = constrain_float(accel_body.y, -a_limit, a_limit);
    accel_body.z = constrain_float(accel_body.z, -a_limit, a_limit);

    // offset based on first position to account for offset in RF world
    if (position_offset.is_zero() || !is_zero(state.m_resetButtonHasBeenPressed)) {
        position_offset = position;
    }
    position -= position_offset;

    airspeed = state.m_airspeed_MPS;

    /* for pitot airspeed we need the airspeed along the X axis. We
       can't get that from m_airspeed_MPS, so instead we calculate it
       from wind vector and ground speed
     */
    wind_ef = Vector3f(state.m_windY_MPS,state.m_windX_MPS,state.m_windZ_MPS);
    Vector3f airspeed_3d_ef = velocity_ef - wind_ef;
    Vector3f airspeed3d = dcm.mul_transpose(airspeed_3d_ef);

    if (last_imu_rotation != ROTATION_NONE) {
        airspeed3d = sitl->ahrs_rotation * airspeed3d;
    }
    airspeed_pitot = MAX(airspeed3d.x,0);

#if 0
    printf("WIND: %.1f %.1f %.1f AS3D %.1f %.1f %.1f\n",
           state.m_windX_MPS,
           state.m_windY_MPS,
           state.m_windZ_MPS,
           airspeed3d.x,
           airspeed3d.y,
           airspeed3d.z);
#endif

    battery_voltage = MAX(state.m_batteryVoltage_VOLTS, 0);
    battery_current = MAX(state.m_batteryCurrentDraw_AMPS, 0);
    rpm[0] = state.m_heliMainRotorRPM;
    rpm[1] = state.m_propRPM;
    motor_mask = 3;

    /*
      the interlink interface supports 12 input channels
     */
    rcin_chan_count = 12;
    for (uint8_t i=0; i<rcin_chan_count; i++) {
        rcin[i] = state.rcin[i];
    }

    update_position();
    time_advance();
    uint64_t new_time_us = (state.m_currentPhysicsTime_SEC - initial_time_s)*1.0e6;
    if (new_time_us < time_now_us) {
        uint64_t dt_us = time_now_us - new_time_us;
        if (dt_us > 500000) {
            // time going backwards
            time_now_us = new_time_us;
        }
    } else {
        uint64_t dt_us = new_time_us - time_now_us;
        const uint64_t glitch_threshold_us = 50000;
        const uint64_t glitch_max_us = 2000000;
        if (dt_us > glitch_threshold_us && dt_us < glitch_max_us) {
            // we've had a network glitch, compensate by advancing initial time
            float adjustment_s = (dt_us-glitch_threshold_us)*1.0e-6;
            initial_time_s += adjustment_s;
            printf("glitch %.2fs\n", adjustment_s);
            dt_us = glitch_threshold_us;
            glitch_count++;
        }
        time_now_us += dt_us;
    }

    last_time_s = state.m_currentPhysicsTime_SEC;

    last_velocity_ef = velocity_ef;

    // update magnetic field
    update_mag_field_bf();

    // one rangefinder
    if (is_positive(dcm.c.z)) {
        rangefinder_m[0] = state.m_altitudeAGL_MTR / dcm.c.z;
    } else {
        rangefinder_m[0] = nanf("");
    }

    report_FPS();
}

/*
  report frame rates
 */
void FlightAxis::report_FPS(void)
{
    if (frame_counter++ % 1000 == 0) {
        if (!is_zero(last_frame_count_s)) {
            uint64_t frames = socket_frame_counter - last_socket_frame_counter;
            last_socket_frame_counter = socket_frame_counter;
            double dt = state.m_currentPhysicsTime_SEC - last_frame_count_s;
            printf("%.2f/%.2f FPS avg=%.2f glitches=%u\n",
                   frames / dt, 1000 / dt, 1.0/average_frame_time_s, unsigned(glitch_count));
        } else {
            printf("Initial position %f %f %f\n", position.x, position.y, position.z);
        }
        last_frame_count_s = state.m_currentPhysicsTime_SEC;
    }
}

void FlightAxis::socket_creator(void)
{
    socket_pid = getpid();
    while (true) {
        pthread_mutex_lock(&sockmtx);
        while (socknext != nullptr) {
            pthread_cond_wait(&sockcond2, &sockmtx);
        }
        pthread_mutex_unlock(&sockmtx);
        auto *sck = NEW_NOTHROW SocketAPM_native(false);
        if (sck == nullptr) {
            usleep(500);
            continue;
        }
        /*
          don't let the connection take more than 100ms (10Hz). Longer
          than this and we are better off trying for a new socket
         */
        if (!sck->connect_timeout(controller_ip, controller_port, 100)) {
            ::printf("connect failed\n");
            delete sck;
            usleep(5000);
            continue;
        }
        sck->set_blocking(false);
        socknext = sck;
        pthread_mutex_lock(&sockmtx);
        pthread_cond_broadcast(&sockcond1);
        pthread_mutex_unlock(&sockmtx);
    }
}

#endif // HAL_SIM_FLIGHTAXIS_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         /*
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
/*
  simulator connection for ardupilot version of FlightAxis
*/

#pragma once

#include <AP_HAL/AP_HAL_Boards.h>

#ifndef HAL_SIM_FLIGHTAXIS_ENABLED
#define HAL_SIM_FLIGHTAXIS_ENABLED (CONFIG_HAL_BOARD == HAL_BOARD_SITL)
#endif

#if HAL_SIM_FLIGHTAXIS_ENABLED

#include <AP_HAL/utility/Socket_native.h>

#include "SIM_Aircraft.h"

namespace SITL {

/*
  a FlightAxis simulator
 */
class FlightAxis : public Aircraft {
public:
    FlightAxis(const char *frame_str);

    /* update model by one time step */
    void update(const struct sitl_input &input) override;

    /* static object creator */
    static Aircraft *create(const char *frame_str) {
        return NEW_NOTHROW FlightAxis(frame_str);
    }

    struct state {
        double rcin[12];
        double m_airspeed_MPS;
        double m_altitudeASL_MTR;
        double m_altitudeAGL_MTR;
        double m_groundspeed_MPS;
        double m_pitchRate_DEGpSEC;
        double m_rollRate_DEGpSEC;
        double m_yawRate_DEGpSEC;
        double m_azimuth_DEG;
        double m_inclination_DEG;
        double m_roll_DEG;
        double m_aircraftPositionX_MTR;
        double m_aircraftPositionY_MTR;
        double m_velocityWorldU_MPS;
        double m_velocityWorldV_MPS;
        double m_velocityWorldW_MPS;
        double m_velocityBodyU_MPS;
        double m_velocityBodyV_MPS;
        double m_velocityBodyW_MPS;
        double m_accelerationWorldAX_MPS2;
        double m_accelerationWorldAY_MPS2;
        double m_accelerationWorldAZ_MPS2;
        double m_accelerationBodyAX_MPS2;
        double m_accelerationBodyAY_MPS2;
        double m_accelerationBodyAZ_MPS2;
        double m_windX_MPS;
        double m_windY_MPS;
        double m_windZ_MPS;
        double m_propRPM;
        double m_heliMainRotorRPM;
        double m_batteryVoltage_VOLTS;
        double m_batteryCurrentDraw_AMPS;
        double m_batteryRemainingCapacity_MAH;
        double m_fuelRemaining_OZ;
        double m_isLocked;
        double m_hasLostComponents;
        double m_anEngineIsRunning;
        double m_isTouchingGround;
        double m_currentAircraftStatus;
        double m_currentPhysicsTime_SEC;
        double m_currentPhysicsSpeedMultiplier;
        double m_orientationQuaternion_X;
        double m_orientationQuaternion_Y;
        double m_orientationQuaternion_Z;
        double m_orientationQuaternion_W;
        double m_flightAxisControllerIsActive;
        double m_resetButtonHasBeenPressed;
    } state;

    static const uint16_t num_keys = sizeof(state)/sizeof(double);

    struct keytable {
        const char *key;
        double &ref;
    } keytable[num_keys] = {
        { "item", state.rcin[0] },
        { "item", state.rcin[1] },
        { "item", state.rcin[2] },
        { "item", state.rcin[3] },
        { "item", state.rcin[4] },
        { "item", state.rcin[5] },
        { "item", state.rcin[6] },
        { "item", state.rcin[7] },
        { "item", state.rcin[8] },
        { "item", state.rcin[9] },
        { "item", state.rcin[10] },
        { "item", state.rcin[11] },
        { "m-airspeed-MPS", state.m_airspeed_MPS },
        { "m-altitudeASL-MTR", state.m_altitudeASL_MTR },
        { "m-altitudeAGL-MTR", state.m_altitudeAGL_MTR },
        { "m-groundspeed-MPS", state.m_groundspeed_MPS },
        { "m-pitchRate-DEGpSEC", state.m_pitchRate_DEGpSEC },
        { "m-rollRate-DEGpSEC", state.m_rollRate_DEGpSEC },
        { "m-yawRate-DEGpSEC", state.m_yawRate_DEGpSEC },
        { "m-azimuth-DEG", state.m_azimuth_DEG },
        { "m-inclination-DEG", state.m_inclination_DEG },
        { "m-roll-DEG", state.m_roll_DEG },
        { "m-aircraftPositionX-MTR", state.m_aircraftPositionX_MTR },
        { "m-aircraftPositionY-MTR", state.m_aircraftPositionY_MTR },
        { "m-velocityWorldU-MPS", state.m_velocityWorldU_MPS },
        { "m-velocityWorldV-MPS", state.m_velocityWorldV_MPS },
        { "m-velocityWorldW-MPS", state.m_velocityWorldW_MPS },
        { "m-velocityBodyU-MPS", state.m_velocityBodyU_MPS },
        { "m-velocityBodyV-MPS", state.m_velocityBodyV_MPS },
        { "m-velocityBodyW-MPS", state.m_velocityBodyW_MPS },
        { "m-accelerationWorldAX-MPS2", state.m_accelerationWorldAX_MPS2 },
        { "m-accelerationWorldAY-MPS2", state.m_accelerationWorldAY_MPS2 },
        { "m-accelerationWorldAZ-MPS2", state.m_accelerationWorldAZ_MPS2 },
        { "m-accelerationBodyAX-MPS2", state.m_accelerationBodyAX_MPS2 },
        { "m-accelerationBodyAY-MPS2", state.m_accelerationBodyAY_MPS2 },
        { "m-accelerationBodyAZ-MPS2", state.m_accelerationBodyAZ_MPS2 },
        { "m-windX-MPS", state.m_windX_MPS },
        { "m-windY-MPS", state.m_windY_MPS },
        { "m-windZ-MPS", state.m_windZ_MPS },
        { "m-propRPM", state.m_propRPM },
        { "m-heliMainRotorRPM", state.m_heliMainRotorRPM },
        { "m-batteryVoltage-VOLTS", state.m_batteryVoltage_VOLTS },
        { "m-batteryCurrentDraw-AMPS", state.m_batteryCurrentDraw_AMPS },
        { "m-batteryRemainingCapacity-MAH", state.m_batteryRemainingCapacity_MAH },
        { "m-fuelRemaining-OZ", state.m_fuelRemaining_OZ },
        { "m-isLocked", state.m_isLocked },
        { "m-hasLostComponents", state.m_hasLostComponents },
        { "m-anEngineIsRunning", state.m_anEngineIsRunning },
        { "m-isTouchingGround", state.m_isTouchingGround },
        { "m-currentAircraftStatus", state.m_currentAircraftStatus },
        { "m-currentPhysicsTime-SEC", state.m_currentPhysicsTime_SEC },
        { "m-currentPhysicsSpeedMultiplier", state.m_currentPhysicsSpeedMultiplier },
        { "m-orientationQuaternion-X", state.m_orientationQuaternion_X },
        { "m-orientationQuaternion-Y", state.m_orientationQuaternion_Y },
        { "m-orientationQuaternion-Z", state.m_orientationQuaternion_Z },
        { "m-orientationQuaternion-W", state.m_orientationQuaternion_W },
        { "m-flightAxisControllerIsActive", state.m_flightAxisControllerIsActive },
        { "m-resetButtonHasBeenPressed", state.m_resetButtonHasBeenPressed },
    };

private:
    bool soap_request_start(const char *action, const char *fmt, ...);
    char *soap_request_end(uint32_t timeout_ms);
    void exchange_data(const struct sitl_input &input);
    void parse_reply(const char *reply);

    void update_loop(void);
    void report_FPS(void);
    void socket_creator(void);

    struct sitl_input last_input;

    double average_frame_time_s;
    double extrapolated_s;
    double initial_time_s;
    double last_time_s;
    bool heli_demix;
    bool rev4_servos;
    bool controller_started;
    uint32_t glitch_count;
    uint64_t frame_counter;
    uint64_t activation_frame_counter;
    uint64_t socket_frame_counter;
    uint64_t last_socket_frame_counter;
    double last_frame_count_s;
    Vector3d position_offset;
    Vector3f last_velocity_ef;

    const char *controller_ip = "127.0.0.1";
    uint16_t controller_port = 18083;
    SocketAPM_native *socknext;
    SocketAPM_native *sock;
    char replybuf[10000];
    pid_t socket_pid;
    uint32_t sock_error_count;
    double last_recv_sec;
};


} // namespace SITL

#endif // HAL_SIM_FLIGHTAXIS_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                              /*
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
/*
  multicopter frame simulator class
*/

#include "SIM_Frame.h"
#include <AP_Motors/AP_Motors.h>
#include <AP_Baro/AP_Baro.h>
#include <AP_Filesystem/AP_Filesystem.h>
#include "SIM_Aircraft.h"

#include <stdio.h>
#include <sys/stat.h>

using namespace SITL;

static Motor quad_plus_motors[] =
{
    Motor(AP_MOTORS_MOT_1,  90, AP_MOTORS_MATRIX_YAW_FACTOR_CCW, 2),
    Motor(AP_MOTORS_MOT_2, -90, AP_MOTORS_MATRIX_YAW_FACTOR_CCW, 4),
    Motor(AP_MOTORS_MOT_3,   0, AP_MOTORS_MATRIX_YAW_FACTOR_CW,  1),
    Motor(AP_MOTORS_MOT_4, 180, AP_MOTORS_MATRIX_YAW_FACTOR_CW,  3),
};

static Motor quad_x_motors[] =
{
    Motor(AP_MOTORS_MOT_1,   45, AP_MOTORS_MATRIX_YAW_FACTOR_CCW, 1),
    Motor(AP_MOTORS_MOT_2, -135, AP_MOTORS_MATRIX_YAW_FACTOR_CCW, 3),
    Motor(AP_MOTORS_MOT_3,  -45, AP_MOTORS_MATRIX_YAW_FACTOR_CW,  4),
    Motor(AP_MOTORS_MOT_4,  135, AP_MOTORS_MATRIX_YAW_FACTOR_CW,  2),
};

// motor order to match betaflight conventions
// See: https://fpvfrenzy.com/betaflight-motor-order/
static Motor quad_bf_x_motors[] =
{
    Motor(AP_MOTORS_MOT_1,  135, AP_MOTORS_MATRIX_YAW_FACTOR_CW, 2),
    Motor(AP_MOTORS_MOT_2,   45, AP_MOTORS_MATRIX_YAW_FACTOR_CCW,1),
    Motor(AP_MOTORS_MOT_3, -135, AP_MOTORS_MATRIX_YAW_FACTOR_CCW,3),
    Motor(AP_MOTORS_MOT_4,  -45, AP_MOTORS_MATRIX_YAW_FACTOR_CW, 4),
};

// motor order to match betaflight conventions, reversed direction
static Motor quad_bf_x_rev_motors[] =
{
    Motor(AP_MOTORS_MOT_1,  135, AP_MOTORS_MATRIX_YAW_FACTOR_CCW, 2),
    Motor(AP_MOTORS_MOT_2,   45, AP_MOTORS_MATRIX_YAW_FACTOR_CW,  1),
    Motor(AP_MOTORS_MOT_3, -135, AP_MOTORS_MATRIX_YAW_FACTOR_CW,  3),
    Motor(AP_MOTORS_MOT_4,  -45, AP_MOTORS_MATRIX_YAW_FACTOR_CCW, 4),
};

// motor order to match DJI conventions
// See: https://forum44.djicdn.com/data/attachment/forum/201711/26/172348bppvtt1ot1nrtp5j.jpg
static Motor quad_dji_x_motors[] =
{
    Motor(AP_MOTORS_MOT_1,   45, AP_MOTORS_MATRIX_YAW_FACTOR_CCW, 1),
    Motor(AP_MOTORS_MOT_2,  -45, AP_MOTORS_MATRIX_YAW_FACTOR_CW,  4),
    Motor(AP_MOTORS_MOT_3, -135, AP_MOTORS_MATRIX_YAW_FACTOR_CCW, 3),
    Motor(AP_MOTORS_MOT_4,  135, AP_MOTORS_MATRIX_YAW_FACTOR_CW,  2),
};

// motor order so that test order matches motor order ("clockwise X")
static Motor quad_cw_x_motors[] =
{
    Motor(AP_MOTORS_MOT_1,   45, AP_MOTORS_MATRIX_YAW_FACTOR_CCW, 1),
    Motor(AP_MOTORS_MOT_2,  135, AP_MOTORS_MATRIX_YAW_FACTOR_CW,  2),
    Motor(AP_MOTORS_MOT_3, -135, AP_MOTORS_MATRIX_YAW_FACTOR_CCW, 3),
    Motor(AP_MOTORS_MOT_4,  -45, AP_MOTORS_MATRIX_YAW_FACTOR_CW,  4),
};

static Motor tiltquad_h_vectored_motors[] =
{
    Motor(AP_MOTORS_MOT_1,   45, AP_MOTORS_MATRIX_YAW_FACTOR_CW,  1, -1, 0, 0, 7, 10, -90),
    Motor(AP_MOTORS_MOT_2, -135, AP_MOTORS_MATRIX_YAW_FACTOR_CW,  3, -1, 0, 0, 8, 10, -90),
    Motor(AP_MOTORS_MOT_3,  -45, AP_MOTORS_MATRIX_YAW_FACTOR_CCW, 4, -1, 0, 0, 8, 10, -90),
    Motor(AP_MOTORS_MOT_4,  135, AP_MOTORS_MATRIX_YAW_FACTOR_CCW, 2, -1, 0, 0, 7, 10, -90),
};

static Motor tiltquad[] =
{
    Motor(AP_MOTORS_MOT_1,   45, AP_MOTORS_MATRIX_YAW_FACTOR_CCW,  1, -1, 0, 0, 7, 10, -90),
    Motor(AP_MOTORS_MOT_2, -135, AP_MOTORS_MATRIX_YAW_FACTOR_CCW,  3),
    Motor(AP_MOTORS_MOT_3,  -45, AP_MOTORS_MATRIX_YAW_FACTOR_CW,   4, -1, 0, 0, 8, 10, -90),
    Motor(AP_MOTORS_MOT_4,  135, AP_MOTORS_MATRIX_YAW_FACTOR_CW,   2),
};

static Motor hexa_motors[] =
{
    Motor(AP_MOTORS_MOT_1,   0, AP_MOTORS_MATRIX_YAW_FACTOR_CW,  1),
    Motor(AP_MOTORS_MO