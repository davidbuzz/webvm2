r is negative, add sign bit in front
                res |= 0x1 << 9
        elif digits == 3 and power == 1: # number encoded on 11 bits: 10 bits for digits + 1 for 10^power
            if abs_number < 1000:
                res = abs_number << 1
            elif abs_number < 10240:
                res = (round(abs_number * 0.1) << 1) | 0x1
            else: # transmit max possible value (0x3FF x 10^1 = 10240)
                res = 0x7FF
            if number < 0: # if number is negative, add sign bit in front
                res |= 0x1 << 11
        elif digits == 3 and power == 2: # number encoded on 12 bits: 10 bits for digits + 2 for 10^power
            if abs_number < 1000:
                res = abs_number << 2
            elif abs_number < 10000:
                res = (round(abs_number * 0.1) << 2) | 0x1
            elif abs_number < 100000:
                res = (round(abs_number * 0.01) << 2) | 0x2
            elif abs_number < 1024000:
                res = (round(abs_number * 0.001) << 2) | 0x3
            else: # transmit max possible value (0x3FF x 10^3 = 127000)
                res = 0xFFF
            if number < 0: # if number is negative, add sign bit in front
                res |= 0x1 << 12
        return res

    def tfp_validate_ap_status(self, value): # 0x5001
        self.progress("validating ap_status(0x%02x)" % value)
        flight_mode = self.bit_extract(value, 0, 5) - 1 # first mode is 1 not 0 :-)
        # simple_mode = self.bit_extract(value, 5, 2)
        # is_flying = not self.bit_extract(value, 7, 1)
        # status_armed = self.bit_extract(value, 8, 1)
        # batt_failsafe = self.bit_extract(value, 9, 1)
        # ekf_failsafe = self.bit_extract(value, 10, 2)
        # imu_temp = self.bit_extract(value, 26, 6) + 19 # IMU temperature: 0 means temp =< 19, 63 means temp => 82
        heartbeat = self.wait_heartbeat()
        mav_flight_mode = heartbeat.custom_mode
        self.progress(" mode=%u heartbeat=%u" % (flight_mode, mav_flight_mode))
        if mav_flight_mode == flight_mode:
            self.progress("flight mode match")
            return True
            # FIXME: need to check other values as well
        return False

    def tfp_validate_attitude(self, value):
        self.progress("validating attitude(0x%02x)" % value)
        roll = (min(self.bit_extract(value, 0, 11), 1800) - 900) * 0.2 # roll [0,1800] ==> [-180,180]
        pitch = (min(self.bit_extract(value, 11, 10), 900) - 450) * 0.2 # pitch [0,900] ==> [-90,90]
#        rng_cm = self.bit_extract(value, 22, 10) * (10 ^ self.bit_extract(value, 21, 1)) # cm
        atti = self.mav.recv_match(
            type='ATTITUDE',
            blocking=True,
            timeout=1
        )
        if atti is None:
            raise NotAchievedException("Did not get ATTITUDE message")
        atti_roll = round(atti.roll)
        self.progress("ATTITUDE roll==%f frsky==%f" % (atti_roll, roll))
        if abs(atti_roll - roll) >= 5:
            return False
        atti_pitch = round(atti.pitch)
        self.progress("ATTITUDE pitch==%f frsky==%f" % (atti_pitch, pitch))
        if abs(atti_pitch - pitch) >= 5:
            return False
            # FIXME: need to check other values as well
        return True

    def tfp_validate_home_status(self, value):
        self.progress("validating home status(0x%02x)" % value)
#        home_dist_m = self.bit_extract(value,2,10) * (10^self.bit_extract(value,0,2))
        home_alt_dm = self.bit_extract(value, 14, 10) * (10 ^ self.bit_extract(value, 12, 2)) * 0.1 * (self.bit_extract(value, 24, 1) == 1 and -1 or 1)  # noqa
        # home_angle_d = self.bit_extract(value, 25,  7) * 3
        gpi = self.mav.recv_match(
            type='GLOBAL_POSITION_INT',
            blocking=True,
            timeout=1
        )
        if gpi is None:
            raise NotAchievedException("Did not get GLOBAL_POSITION_INT message")
        gpi_relative_alt_dm = gpi.relative_alt/100.0
        self.progress("GLOBAL_POSITION_INT rel_alt==%fm frsky_home_alt==%fm" % (gpi_relative_alt_dm, home_alt_dm))
        if abs(gpi_relative_alt_dm - home_alt_dm) < 10:
            return True
            # FIXME: need to check other values as well
        return False

    def tfp_validate_gps_status(self, value):
        self.progress("validating gps status(0x%02x)" % value)
#        num_sats = self.bit_extract(value, 0, 4)
        gps_status = self.bit_extract(value, 4, 2) + self.bit_extract(value, 14, 2)
#        gps_hdop = self.bit_extract(value, 7, 7) * (10 ^ self.bit_extract(value, 6, 1)) # dm
#        gps_alt = self.bit_extract(value, 24, 7) * (10 ^ self.bit_extract(value, 22, 2)) * (self.bit_extract(value, 31, 1) == 1 and -1 or 1) # dm  # noqa
        gri = self.mav.recv_match(
            type='GPS_RAW_INT',
            blocking=True,
            timeout=1
        )
        if gri is None:
            raise NotAchievedException("Did not get GPS_RAW_INT message")
        gri_status = gri.fix_type
        self.progress("GPS_RAW_INT fix_type==%f frsky==%f" % (gri_status, gps_status))
        if gps_status == gri_status:
            return True
            # FIXME: need to check other values as well
        return False

    def tfp_validate_vel_and_yaw(self, value): # 0x5005
        self.progress("validating vel_and_yaw(0x%02x)" % value)
        z_vel_dm_per_second = self.bit_extract(value, 1, 7) * (10 ^ self.bit_extract(value, 0, 1)) * (self.bit_extract(value, 8, 1) == 1 and -1 or 1)  # noqa
        xy_vel = self.bit_extract(value, 10, 7) * (10 ^ self.bit_extract(value, 9, 1))
        yaw = self.bit_extract(value, 17, 11) * 0.2
        gpi = self.mav.recv_match(
            type='GLOBAL_POSITION_INT',
            blocking=True,
            timeout=1
        )
        if gpi is None:
            return
        self.progress(" yaw=%u gpi=%u" % (yaw, gpi.hdg*0.01))
        self.progress(" xy_vel=%u" % xy_vel)
        self.progress(" z_vel_dm_per_second=%u" % z_vel_dm_per_second)
        if self.compare_number_percent(gpi.hdg*0.01, yaw, 10):
            self.progress("Yaw match")
            return True
        # FIXME: need to be under way to check the velocities, really....
        return False

    def tfp_validate_battery1(self, value):
        self.progress("validating battery1 (0x%02x)" % value)
        voltage = self.bit_extract(value, 0, 9)  # dV
        # current = self.bit_extract(value, 10, 7) * (10 ^ self.bit_extract(value, 9, 1))
        # mah = self.bit_extract(value, 17, 15)
        voltage = value * 0.1
        batt = self.mav.recv_match(
            type='BATTERY_STATUS',
            blocking=True,
            timeout=5,
            condition="BATTERY_STATUS.id==0"
        )
        if batt is None:
            raise NotAchievedException("Did not get BATTERY_STATUS message")
        battery_status_value = batt.voltages[0]*0.001
        self.progress("BATTERY_STATUS voltage==%f frsky==%f" % (battery_status_value, voltage))
        if abs(battery_status_value - voltage) > 0.1:
            return False
        # FIXME: need to check other values as well
        return True

    def tfp_validate_params(self, value):
        param_id = self.bit_extract(value, 24, 4)
        param_value = self.bit_extract(value, 0, 24)
        self.progress("received param (0x%02x) (id=%u value=%u)" %
                      (value, param_id, param_value))
        frame_type = param_value
        hb = self.mav.messages['HEARTBEAT']
        hb_type = hb.type
        self.progress("validate_params: HEARTBEAT type==%f frsky==%f param_id=%u" % (hb_type, frame_type, param_id))
        if param_id != 1:
            return False
        if hb_type == frame_type:
            return True
            # FIXME: need to check other values as well
        return False

    def tfp_validate_rpm(self, value):
        self.progress("validating rpm (0x%02x)" % value)
        tf_rpm = self.bit_extract(value, 0, 16)
        rpm = self.mav.recv_match(
            type='RPM',
            blocking=True,
            timeout=5
        )
        if rpm is None:
            raise NotAchievedException("Did not get RPM message")
        rpm_value = round(rpm.rpm1 * 0.1)
        self.progress("RPM rpm==%f frsky==%f" % (rpm_value, tf_rpm))
        if rpm_value != tf_rpm:
            return False
        return True

    def tfp_validate_terrain(self, value):
        self.progress("validating terrain(0x%02x)" % value)
        alt_above_terrain_dm = self.bit_extract(value, 2, 10) * (10 ^ self.bit_extract(value, 0, 2)) * 0.1 * (self.bit_extract(value, 12, 1) == 1 and -1 or 1)  # noqa
        terrain = self.mav.recv_match(
            type='TERRAIN_REPORT',
            blocking=True,
            timeout=1
        )
        if terrain is None:
            raise NotAchievedException("Did not get TERRAIN_REPORT message")
        altitude_terrain_dm = round(terrain.current_height*10)
        self.progress("TERRAIN_REPORT terrain_alt==%fdm frsky_terrain_alt==%fdm" % (altitude_terrain_dm, alt_above_terrain_dm))
        if abs(altitude_terrain_dm - alt_above_terrain_dm) < 1:
            return True
        return False

    def tfp_validate_wind(self, value):
        self.progress("validating wind(0x%02x)" % value)
        speed_m = self.bit_extract(value, 8, 7) * (10 ^ self.bit_extract(value, 7, 1)) * 0.1 # speed in m/s
        wind = self.mav.recv_match(
            type='WIND',
            blocking=True,
            timeout=1
        )
        if wind is None:
            raise NotAchievedException("Did not get WIND message")
        self.progress("WIND mav==%f frsky==%f" % (speed_m, wind.speed))
        if abs(speed_m - wind.speed) < 0.5:
            return True
        return False

    def test_frsky_passthrough_do_wants(self, frsky, wants):

        tstart = self.get_sim_time_cached()
        while len(wants):
            self.progress("Still wanting (%s)" % ",".join([("0x%02x" % x) for x in wants.keys()]))
            wants_copy = copy.copy(wants)
            self.drain_mav()
            t2 = self.get_sim_time_cached()
            if t2 - tstart > 300:
                self.progress("Failed to get frsky passthrough data")
                self.progress("Counts of sensor_id polls sent:")
                frsky.dump_sensor_id_poll_counts_as_progress_messages()
                self.progress("Counts of dataids received:")
                frsky.dump_dataid_counts_as_progress_messages()
                raise AutoTestTimeoutException("Failed to get frsky passthrough data")
            frsky.update()
            for want in wants_copy:
                data = frsky.get_data(want)
                if data is None:
                    continue
                self.progress("Checking 0x%x" % (want,))
                if wants[want](data):
                    self.progress("  Fulfilled")
                    del wants[want]

    def FRSkyPassThroughStatustext(self):
        '''test FRSKy protocol's telem-passthrough functionality'''
        # we disable terrain here as RCTelemetry can queue a lot of
        # statustexts if terrain tiles aren't available which can
        # happen on the autotest server.
        self.set_parameters({
            "SERIAL5_PROTOCOL": 10, # serial5 is FRSky passthrough
            "RPM1_TYPE": 10, # enable RPM output
            "TERRAIN_ENABLE": 0,
        })
        port = self.spare_network_port()
        self.customise_SITL_commandline([
            "--serial5=tcp:%u" % port # serial5 spews to localhost port
        ])
        frsky = FRSkyPassThrough(("127.0.0.1", port),
                                 get_time=self.get_sim_time_cached)

        # waiting until we are ready to arm should ensure our wanted
        # statustext doesn't get blatted out of the ArduPilot queue by
        # random messages.
        self.wait_ready_to_arm()

        # test we get statustext strings.  This relies on ArduPilot
        # emitting statustext strings when we fetch parameters. (or,
        # now, an updating-barometer statustext)
        tstart = self.get_sim_time()
        old_data = None
        text = ""

        self.context_collect('STATUSTEXT')
        command = mavutil.mavlink.MAV_CMD_PREFLIGHT_CALIBRATION
        self.send_cmd(
            command,
            p3=1, # p3, baro
        )
        # this is a test for asynchronous handling of mavlink messages:
        self.run_cmd_get_ack(command, mavutil.mavlink.MAV_RESULT_IN_PROGRESS, 2)
        self.run_cmd_get_ack(command, mavutil.mavlink.MAV_RESULT_ACCEPTED, 5)

        received_frsky_texts = []
        last_len_received_statustexts = 0
        timeout = 7 * self.speedup # it can take a *long* time to get these messages down!
        while True:
            self.drain_mav()
            now = self.get_sim_time_cached()
            if now - tstart > timeout:
                raise NotAchievedException("Did not get statustext in time")
            frsky.update()
            data = frsky.get_data(0x5000) # no timestamping on this data, so we can't catch legitimate repeats.
            if data is None:
                continue
            # frsky sends each quartet three times; skip the suplicates.
            if old_data is not None and old_data == data:
                continue
            old_data = data
            self.progress("Got (0x%x)" % data)
            severity = 0
            last = False
            for i in 3, 2, 1, 0:
                x = (data >> i*8) & 0xff
                text += chr(x & 0x7f)
                self.progress("  x=0x%02x" % x)
                if x & 0x80:
                    severity += 1 << i
                self.progress("Text sev=%u: %s" % (severity, str(text)))
                if (x & 0x7f) == 0x00:
                    last = True
            if last:
                m = None
                text = text.rstrip("\0")
                self.progress("Received frsky text (%s)" % (text,))
                self.progress("context texts: %s" %
                              str([st.text for st in self.context_collection('STATUSTEXT')]))
                m = self.statustext_in_collections(text)
                if m is not None:
                    want_sev = m.severity
                    if severity != want_sev:
                        raise NotAchievedException("Incorrect severity; want=%u got=%u" % (want_sev, severity))
                    self.progress("Got statustext (%s)" % m.text)
                    break
                received_frsky_texts.append((severity, text))
                text = ""
            received_statustexts = self.context_collection('STATUSTEXT')
            if len(received_statustexts) != last_len_received_statustexts:
                last_len_received_statustexts = len(received_statustexts)
                self.progress("received statustexts: %s" % str([st.text for st in received_statustexts]))
                self.progress("received frsky texts: %s" % str(received_frsky_texts))
                for (want_sev, received_text) in received_frsky_texts:
                    for m in received_statustexts:
                        if m.text == received_text:
                            if want_sev != m.severity:
                                raise NotAchievedException("Incorrect severity; want=%u got=%u" % (want_sev, severity))
                            self.progress("Got statustext (%s)" % received_text)
                            break

    def FRSkyPassThroughSensorIDs(self):
        '''test FRSKy protocol's telem-passthrough functionality (sensor IDs)'''
        self.set_parameters({
            "SERIAL5_PROTOCOL": 10, # serial5 is FRSky passthrough
            "RPM1_TYPE": 10, # enable RPM output
        })
        port = self.spare_network_port()
        self.customise_SITL_commandline([
            "--serial5=tcp:%u" % port # serial5 spews to localhost port
        ])
        frsky = FRSkyPassThrough(("127.0.0.1", port),
                                 get_time=self.get_sim_time_cached)

        self.wait_ready_to_arm()

        # we need to start the engine to get some RPM readings, we do it for plane only
        # anything with a lambda in here needs a proper test written.
        # This, at least makes sure we're getting some of each
        # message.  These are ordered according to the wfq scheduler
        wants = {
            0x5000: lambda xx: True,
            0x5006: self.tfp_validate_attitude,
            0x0800: self.tf_validate_gps,
            0x5005: self.tfp_validate_vel_and_yaw,
            0x5001: self.tfp_validate_ap_status,
            0x5002: self.tfp_validate_gps_status,
            0x5004: self.tfp_validate_home_status,
            # 0x5008: lambda x : True, # no second battery, so this doesn't arrive
            0x5003: self.tfp_validate_battery1,
            0x5007: self.tfp_validate_params,
            0x500B: self.tfp_validate_terrain,
            0x500C: self.tfp_validate_wind,
        }
        self.test_frsky_passthrough_do_wants(frsky, wants)

        # now check RPM:
        if self.is_plane():
            self.set_autodisarm_delay(0)
            if not self.arm_vehicle():
                raise NotAchievedException("Failed to ARM")
            self.set_rc(3, 1050)
            wants = {
                0x500A: self.tfp_validate_rpm,
            }
            self.test_frsky_passthrough_do_wants(frsky, wants)
            self.zero_throttle()
            self.progress("Wait for vehicle to slow down")
            self.wait_groundspeed(0, 0.3)
            self.disarm_vehicle()

        self.progress("Counts of sensor_id polls sent:")
        frsky.dump_sensor_id_poll_counts_as_progress_messages()
        self.progress("Counts of dataids received:")
        frsky.dump_dataid_counts_as_progress_messages()

    def decode_mavlite_param_value(self, message):
        '''returns a tuple of parameter name, value'''
        (value,) = struct.unpack("<f", message[0:4])
        name = message[4:]
        return (name, value)

    def decode_mavlite_command_ack(self, message):
        '''returns a tuple of parameter name, value'''
        (command, result) = struct.unpack("<HB", message)
        return (command, result)

    def read_message_via_mavlite(self, frsky, sport_to_mavlite):
        '''read bytes from frsky mavlite stream, trying to form up a mavlite
        message'''
        tstart = self.get_sim_time()
        timeout = 30 * self.speedup/10.0
        if self.valgrind or self.callgrind:
            timeout *= 10
        while True:
            self.drain_mav(quiet=True)
            tnow = self.get_sim_time_cached()
            if tnow - tstart > timeout:
                raise NotAchievedException("Did not get parameter via mavlite")
            frsky.update()
            if sport_to_mavlite.state == sport_to_mavlite.state_MESSAGE_RECEIVED:
                message = sport_to_mavlite.get_message()
                sport_to_mavlite.reset()
#                self.progress("############ message received (type=%u)" % message.msgid)
                return message

    def read_parameter_via_mavlite(self, frsky, sport_to_mavlite, name):
        tstart = self.get_sim_time()
        while True:
            tnow = self.get_sim_time_cached()
            if tnow - tstart > 30 * self.speedup / 10.0:
                raise NotAchievedException("Did not get parameter via mavlite")
            message = self.read_message_via_mavlite(frsky, sport_to_mavlite)
            if message.msgid != mavutil.mavlink.MAVLINK_MSG_ID_PARAM_VALUE:
                raise NotAchievedException("Unexpected msgid %u received" % message.msgid)
            (got_name, value) = self.decode_mavlite_param_value(message.body)
            #                self.progress("Received parameter: %s=%f" % (name, value))
            got_name = got_name.decode('ascii')
            if got_name != name:
                raise NotAchievedException("Incorrect name received (want=%s) (got=%s)" % (name, got_name))
            return value

    def get_parameter_via_mavlite(self, frsky, sport_to_mavlite, name):
        # self.progress("########## Sending request")
        frsky.send_mavlite_param_request_read(name)
        return self.read_parameter_via_mavlite(frsky, sport_to_mavlite, name)

    def set_parameter_via_mavlite(self, frsky, sport_to_mavlite, name, value):
        # self.progress("########## Sending request")
        frsky.send_mavlite_param_set(name, value)
        # new value is echoed back immediately:
        got_val = self.read_parameter_via_mavlite(frsky, sport_to_mavlite, name)
        if abs(got_val - value) > 0.00001:
            raise NotAchievedException("Returned value not same as set value (want=%f got=%f)" % (value, got_val))

    def run_cmd_via_mavlite(self,
                            frsky,
                            sport_to_mavlite,
                            command,
                            p1=None,
                            p2=None,
                            p3=None,
                            p4=None,
                            p5=None,
                            p6=None,
                            p7=None,
                            want_result=mavutil.mavlink.MAV_RESULT_ACCEPTED):
        frsky.send_mavlite_command_long(
            command,
            p1=p1,
            p2=p2,
            p3=p3,
            p4=p4,
            p5=p5,
            p6=p6,
            p7=p7,
        )
        self.run_cmd_via_mavlite_get_ack(
            frsky,
            sport_to_mavlite,
            command,
            want_result
        )

    def run_cmd_via_mavlite_get_ack(self, frsky, sport_to_mavlite, command, want_result):
        '''expect and read a command-ack from frsky sport passthrough'''
        msg = self.read_message_via_mavlite(frsky, sport_to_mavlite)
        if msg.msgid != mavutil.mavlink.MAVLINK_MSG_ID_COMMAND_ACK:
            raise NotAchievedException("Expected a command-ack, got a %u" % msg.msgid)
        (got_command, got_result) = self.decode_mavlite_command_ack(msg.body)
        if got_command != command:
            raise NotAchievedException(
                "Did not receive expected command in command_ack; want=%u got=%u" %
                (command, got_command))
        if got_result != want_result:
            raise NotAchievedException(
                "Did not receive expected result in command_ack; want=%u got=%u" %
                (want_result, got_result))

    def FRSkyMAVlite(self):
        '''Test FrSky MAVlite serial output'''
        self.set_parameter("SERIAL5_PROTOCOL", 10) # serial5 is FRSky passthrough
        port = self.spare_network_port()
        self.customise_SITL_commandline([
            "--serial5=tcp:%u" % port # serial5 spews to localhost port
        ])
        frsky = FRSkyPassThrough(("127.0.0.1", port))
        frsky.connect()

        sport_to_mavlite = SPortToMAVlite()
        frsky.data_downlink_handler = sport_to_mavlite.downlink_handler

        self.start_subtest("Get parameter via MAVlite")
        param_name = "STAB_PITCH_DOWN"  # FIXME: want common across vehicles
        set_value = 97.21
        self.set_parameter(param_name, set_value)  # DO NOT FLY
        got_value = self.get_parameter_via_mavlite(frsky,
                                                   sport_to_mavlite,
                                                   param_name)
        if abs(got_value - set_value) > 0.00001:
            raise NotAchievedException("Incorrect value retrieved via mavlite (want=%f got=%f)" % (set_value, got_value))
        self.progress("Got value OK")
        self.end_subtest("Get parameter via MAVlite")

        self.start_subtest("Set parameter via MAVlite")
        param_name = "STAB_PITCH_DOWN"  # FIXME: want common across vehicles
        set_value = 91.67
#        frsky.verbose = True
        self.set_parameter_via_mavlite(frsky, sport_to_mavlite, param_name, set_value)  # DO NOT FLY
        got_value = self.get_parameter(param_name)
        if abs(got_value - set_value) > 0.00001:
            raise NotAchievedException("Incorrect value retrieved via mavlink (want=%f got=%f)" % (set_value, got_value))
        self.progress("Set value OK")
        self.end_subtest("Set parameter via MAVlite")

        self.start_subtest("Calibrate Baro via MAVLite")
        self.context_push()
        self.context_collect("STATUSTEXT")
        self.run_cmd_via_mavlite(
            frsky,
            sport_to_mavlite,
            mavutil.mavlink.MAV_CMD_PREFLIGHT_CALIBRATION,
            p1=0,
            p2=0,
            p3=1.0,
        )
        self.wait_statustext("Updating barometer calibration", check_context=True)
        self.context_pop()
        self.end_subtest("Calibrate Baro via MAVLite")

        self.start_subtest("Change mode via MAVLite")
        #  FIXME: currently plane-specific
        self.run_cmd_via_mavlite(
            frsky,
            sport_to_mavlite,
            mavutil.mavlink.MAV_CMD_DO_SET_MODE,
            p1=mavutil.mavlink.PLANE_MODE_MANUAL,
        )
        self.wait_mode("MANUAL")
        self.run_cmd_via_mavlite(
            frsky,
            sport_to_mavlite,
            mavutil.mavlink.MAV_CMD_DO_SET_MODE,
            p1=mavutil.mavlink.PLANE_MODE_FLY_BY_WIRE_A,
        )
        self.wait_mode("FBWA")
        self.end_subtest("Change mode via MAVLite")

        self.start_subtest("Enable fence via MAVlite")
        #  Fence can be enabled using MAV_CMD
        self.run_cmd_via_mavlite(
            frsky,
            sport_to_mavlite,
            mavutil.mavlink.MAV_CMD_DO_FENCE_ENABLE,
            p1=1,
            want_result=mavutil.mavlink.MAV_RESULT_ACCEPTED,
        )
        self.end_subtest("Enable fence via MAVlite")

    def tfs_validate_gps_alt(self, value):
        self.progress("validating gps altitude (0x%02x)" % value)
        alt_m = value * 0.01 # cm -> m
        gpi = self.mav.recv_match(
            type='GLOBAL_POSITION_INT',
            blocking=True,
            timeout=1
        )
        if gpi is None:
            raise NotAchievedException("Did not get GLOBAL_POSITION_INT message")
        gpi_alt_m = round(gpi.alt * 0.001) # mm-> m
        self.progress("GLOBAL_POSITION_INT alt==%f frsky==%f" % (gpi_alt_m, alt_m))
        if self.compare_number_percent(gpi_alt_m, alt_m, 10):
            return True
        return False

    def tfs_validate_baro_alt(self, value):
        self.progress("validating baro altitude (0x%02x)" % value)
        alt_m = value * 0.01 # cm -> m
        gpi = self.mav.recv_match(
            type='GLOBAL_POSITION_INT',
            blocking=True,
            timeout=1
        )
        if gpi is None:
            raise NotAchievedException("Did not get GLOBAL_POSITION_INT message")
        gpi_alt_m = round(gpi.relative_alt * 0.001) # mm -> m
        self.progress("GLOBAL_POSITION_INT relative_alt==%f frsky==%f" % (gpi_alt_m, alt_m))
        if abs(gpi_alt_m - alt_m) < 1:
            return True
        return False

    def tfs_validate_gps_speed(self, value):
        self.progress("validating gps speed (0x%02x)" % value)
        speed_ms = value * 0.001 # mm/s -> m/s
        vfr_hud = self.mav.recv_match(
            type='VFR_HUD',
            blocking=True,
            timeout=1
        )
        if vfr_hud is None:
            raise NotAchievedException("Did not get VFR_HUD message")
        vfr_hud_speed_ms = round(vfr_hud.groundspeed)
        self.progress("VFR_HUD groundspeed==%f frsky==%f" % (vfr_hud_speed_ms, speed_ms))
        if self.compare_number_percent(vfr_hud_speed_ms, speed_ms, 10):
            return True
        return False

    def tfs_validate_yaw(self, value):
        self.progress("validating yaw (0x%02x)" % value)
        yaw_deg = value * 0.01 # cd -> deg
        vfr_hud = self.mav.recv_match(
            type='VFR_HUD',
            blocking=True,
            timeout=1
        )
        if vfr_hud is None:
            raise NotAchievedException("Did not get VFR_HUD message")
        vfr_hud_yaw_deg = round(vfr_hud.heading)
        self.progress("VFR_HUD heading==%f frsky==%f" % (vfr_hud_yaw_deg, yaw_deg))
        if self.compare_number_percent(vfr_hud_yaw_deg, yaw_deg, 10):
            return True
        return False

    def tfs_validate_vspeed(self, value):
        self.progress("validating vspeed (0x%02x)" % value)
        vspeed_ms = value * 0.01 # cm/s -> m/s
        vfr_hud = self.mav.recv_match(
            type='VFR_HUD',
            blocking=True,
            timeout=1
        )
        if vfr_hud is None:
            raise NotAchievedException("Did not get VFR_HUD message")
        vfr_hud_vspeed_ms = round(vfr_hud.climb)
        self.progress("VFR_HUD climb==%f frsky==%f" % (vfr_hud_vspeed_ms, vspeed_ms))
        if self.compare_number_percent(vfr_hud_vspeed_ms, vspeed_ms, 10):
            return True
        return False

    def tfs_validate_battery1(self, value):
        self.progress("validating battery1 (0x%02x)" % value)
        voltage_v = value * 0.01 # cV -> V
        batt = self.mav.recv_match(
            type='BATTERY_STATUS',
            blocking=True,
            timeout=5,
            condition="BATTERY_STATUS.id==0"
        )
        if batt is None:
            raise NotAchievedException("Did not get BATTERY_STATUS message")
        battery_status_voltage_v = batt.voltages[0] * 0.001 # mV -> V
        self.progress("BATTERY_STATUS volatge==%f frsky==%f" % (battery_status_voltage_v, voltage_v))
        if self.compare_number_percent(battery_status_voltage_v, voltage_v, 10):
            return True
        return False

    def tfs_validate_current1(self, value):
        # test frsky current vs BATTERY_STATUS
        self.progress("validating battery1 (0x%02x)" % value)
        current_a = value * 0.1 # dA -> A
        batt = self.mav.recv_match(
            type='BATTERY_STATUS',
            blocking=True,
            timeout=5,
            condition="BATTERY_STATUS.id==0"
        )
        if batt is None:
            raise NotAchievedException("Did not get BATTERY_STATUS message")
        battery_status_current_a = batt.current_battery * 0.01 # cA -> A
        self.progress("BATTERY_STATUS current==%f frsky==%f" % (battery_status_current_a, current_a))
        if self.compare_number_percent(round(battery_status_current_a * 10), round(current_a * 10), 10):
            return True
        return False

    def tfs_validate_fuel(self, value):
        self.progress("validating fuel (0x%02x)" % value)
        fuel = value
        batt = self.mav.recv_match(
            type='BATTERY_STATUS',
            blocking=True,
            timeout=5,
            condition="BATTERY_STATUS.id==0"
        )
        if batt is None:
            raise NotAchievedException("Did not get BATTERY_STATUS message")
        battery_status_fuel = batt.battery_remaining
        self.progress("BATTERY_STATUS fuel==%f frsky==%f" % (battery_status_fuel, fuel))
        if self.compare_number_percent(battery_status_fuel, fuel, 10):
            return True
        return False

    def tfs_validate_tmp1(self, value):
        self.progress("validating tmp1 (0x%02x)" % value)
        tmp1 = value
        heartbeat = self.wait_heartbeat()
        heartbeat_tmp1 = heartbeat.custom_mode
        self.progress("GLOBAL_POSITION_INT custom_mode==%f frsky==%f" % (heartbeat_tmp1, tmp1))
        if heartbeat_tmp1 == tmp1:
            return True
        return False

    def tfs_validate_tmp2(self, value):
        self.progress("validating tmp2 (0x%02x)" % value)
        tmp2 = value
        gps_raw = self.mav.recv_match(
            type='GPS_RAW_INT',
            blocking=True,
            timeout=1
        )
        if gps_raw is None:
            raise NotAchievedException("Did not get GPS_RAW_INT message")
        gps_raw_tmp2 = gps_raw.satellites_visible*10 + gps_raw.fix_type
        self.progress("GPS_RAW_INT tmp2==%f frsky==%f" % (gps_raw_tmp2, tmp2))
        if gps_raw_tmp2 == tmp2:
            return True
        return False

    def tfs_validate_rpm(self, value):
        self.progress("validating rpm (0x%02x)" % value)
        tfs_rpm = value
        rpm = self.mav.recv_match(
            type='RPM',
            blocking=True,
            timeout=5
        )
        if rpm is None:
            raise NotAchievedException("Did not get RPM message")
        rpm_value = round(rpm.rpm1)
        self.progress("RPM rpm==%f frsky==%f" % (rpm_value, tfs_rpm))
        if rpm_value == tfs_rpm:
            return True
        return False

    def wait_rpm1(self, min_rpm=None, timeout=10):
        '''wait for mavlink RPM message to indicate valid RPM'''
        tstart = self.get_sim_time()
        while True:
            t = self.get_sim_time_cached()
            if t - tstart > timeout:
                raise AutoTestTimeoutException("Failed to do get valid RPM")
            rpm = self.mav.recv_match(
                type='RPM',
                blocking=True,
                timeout=1
            )
            self.progress("rpm: (%s)" % str(rpm))
            if rpm is None:
                continue
            if min_rpm is None:
                return
            if rpm.rpm1 >= min_rpm:
                return

    def FRSkySPort(self):
        '''Test FrSky SPort mode'''
        self.set_parameter("SERIAL5_PROTOCOL", 4) # serial5 is FRSky sport
        self.set_parameter("RPM1_TYPE", 10) # enable SITL RPM sensor
        port = self.spare_network_port()
        self.customise_SITL_commandline([
            "--serial5=tcp:%u" % port # serial5 spews to localhost port
        ])
        frsky = FRSkySPort(("127.0.0.1", port), verbose=True)
        self.wait_ready_to_arm()

        # we need to start the engine to get some RPM readings, we do it for plane only
        if self.is_plane():
            self.set_autodisarm_delay(0)
            if not self.arm_vehicle():
                raise NotAchievedException("Failed to ARM")
            self.set_rc(3, 1050)
            self.wait_rpm1(timeout=10, min_rpm=200)

        self.assert_current_onboard_log_contains_message("RPM")

        self.drain_mav()
        # anything with a lambda in here needs a proper test written.
        # This, at least makes sure we're getting some of each
        # message.
        wants = {
            0x082F: self.tfs_validate_gps_alt, # gps altitude integer cm
            0x040F: self.tfs_validate_tmp1, # Tmp1
            0x060F: self.tfs_validate_fuel, # fuel % 0-100
            0x041F: self.tfs_validate_tmp2, # Tmp2
            0x010F: self.tfs_validate_baro_alt, # baro alt cm
            0x083F: self.tfs_validate_gps_speed, # gps speed integer mm/s
            0x084F: self.tfs_validate_yaw, # yaw in cd
            0x020F: self.tfs_validate_current1, # current dA
            0x011F: self.tfs_validate_vspeed, # vertical speed cm/s
            0x021F: self.tfs_validate_battery1, # battery 1 voltage cV
            0x0800: self.tf_validate_gps, # gps lat/lon
            0x050E: self.tfs_validate_rpm, # rpm 1
        }
        tstart = self.get_sim_time_cached()
        last_wanting_print = 0

        last_data_time = None
        while len(wants):
            now = self.get_sim_time()
            if now - last_wanting_print > 1:
                self.progress("Still wanting (%s)" %
                              ",".join([("0x%02x" % x) for x in wants.keys()]))
                last_wanting_print = now
            wants_copy = copy.copy(wants)
            if now - tstart > 300:
                self.progress("Failed to get frsky passthrough data")
                self.progress("Counts of sensor_id polls sent:")
                frsky.dump_sensor_id_poll_counts_as_progress_messages()
                self.progress("Counts of dataids received:")
                frsky.dump_dataid_counts_as_progress_messages()
                raise AutoTestTimeoutException("Failed to get frsky sport data")
            frsky.update()
            if frsky.last_data_time == last_data_time:
                continue
            last_data_time = frsky.last_data_time
            for want in wants_copy:
                data = frsky.get_data(want)
                if data is None:
                    continue
                self.progress("Checking 0x%x" % (want,))
                if wants[want](data):
                    self.progress("  Fulfilled")
                    del wants[want]
        # ok done, stop the engine
        if self.is_plane():
            self.zero_throttle()
            self.disarm_vehicle(force=True)

    def FRSkyD(self):
        '''Test FrSkyD serial output'''
        self.set_parameter("SERIAL5_PROTOCOL", 3) # serial5 is FRSky output
        port = self.spare_network_port()
        self.customise_SITL_commandline([
            "--serial5=tcp:%u" % port # serial5 spews to localhost port
        ])
        frsky = FRSkyD(("127.0.0.1", port))
        self.wait_ready_to_arm()
        m = self.assert_receive_message('GLOBAL_POSITION_INT', timeout=1)
        gpi_abs_alt = int((m.alt+500) / 1000) # mm -> m

        # grab a battery-remaining percentage
        self.run_cmd(
            mavutil.mavlink.MAV_CMD_BATTERY_RESET,
            p1=65535,   # battery mask
            p2=96,      # percentage
        )
        m = self.assert_receive_message('BATTERY_STATUS', timeout=1)
        want_battery_remaining_pct = m.battery_remaining

        tstart = self.get_sim_time_cached()
        have_alt = False
        have_battery = False
        while True:
            t2 = self.get_sim_time_cached()
            if t2 - tstart > 10:
                raise AutoTestTimeoutException("Failed to get frsky D data")
            frsky.update()

            alt = frsky.get_data(frsky.dataid_GPS_ALT_BP)
            self.progress("Got alt (%s) mav=%s" % (str(alt), str(gpi_abs_alt)))
            if alt is None:
                continue
            if alt == gpi_abs_alt:
                have_alt = True

            batt = frsky.get_data(frsky.dataid_FUEL)
            self.progress("Got batt (%s) mav=%s" % (str(batt), str(want_battery_remaining_pct)))
            if batt is None:
                continue
            if batt == want_battery_remaining_pct:
                have_battery = True

            if have_alt and have_battery:
                break
            self.drain_mav()

    def test_ltm_g(self, ltm):
        g = ltm.g()
        if g is None:
            return
        m = self.mav.recv_match(type='GLOBAL_POSITION_INT', blocking=True)
        print("m: %s" % str(m))

        print("g.lat=%s m.lat=%s" % (str(g.lat()), str(m.lat)))
        if abs(m.lat - g.lat()) > 10:
            return False

        print("g.lon:%s m.lon:%s" % (str(g.lon()), str(m.lon)))
        if abs(m.lon - g.lon()) > 10:
            return False

        print("gndspeed: %s" % str(g.gndspeed()))
        if g.gndspeed() != 0:
            # FIXME if we start the vehicle moving.... check against VFR_HUD?
            return False

        print("g.alt=%s m.alt=%s" % (str(g.alt()/100.0), str(m.relative_alt/1000.0)))
        if abs(m.relative_alt/1000.0 - g.alt()/100.0) > 1:
            return False

        print("sats: %s" % str(g.sats()))
        m = self.mav.recv_match(type='GPS_RAW_INT', blocking=True)
        if m.satellites_visible != g.sats():
            return False

        constrained_fix_type = m.fix_type
        if constrained_fix_type > 3:
            constrained_fix_type = 3
        print("fix_type: %s" % g.fix_type())
        if constrained_fix_type != g.fix_type():
            return False

        return True

    def test_ltm_a(self, ltm):
        a = ltm.a()
        if a is None:
            return
        m = self.assert_receive_message('ATTITUDE')

        pitch = a.pitch()
        print("pitch: %s" % str(pitch))
        if abs(math.degrees(m.pitch) - pitch) > 1:
            return False

        roll = a.roll()
        print("roll: %s" % str(roll))
        if abs(math.degrees(m.roll) - roll) > 1:
            return False

        hdg = a.hdg()
        myaw = math.degrees(m.yaw)
        myaw += 360
        myaw %= 360
        print("a.hdg=%s m.hdg=%s" % (str(hdg), str(myaw)))
        if abs(myaw - hdg) > 1:
            return False

        return True

    def test_ltm_s(self, ltm):
        s = ltm.s()
        if s is None:
            return
        # FIXME.  Actually check the field values are correct :-)
        return True

    def LTM(self):
        '''Test LTM serial output'''
        self.set_parameter("SERIAL5_PROTOCOL", 25) # serial5 is LTM output
        port = self.spare_network_port()
        self.customise_SITL_commandline([
            "--serial5=tcp:%u" % port  # serial5 spews to localhost port
        ])
        ltm = LTM(("127.0.0.1", port))
        self.wait_ready_to_arm()

        wants = {
            "g": self.test_ltm_g,
            "a": self.test_ltm_a,
            "s": self.test_ltm_s,
        }

        tstart = self.get_sim_time()
        while True:
            self.progress("Still wanting (%s)" %
                          ",".join([("%s" % x) for x in wants.keys()]))
            if len(wants) == 0:
                break
            now = self.get_sim_time_cached()
            if now - tstart > 10:
                raise AutoTestTimeoutException("Failed to get ltm data")

            ltm.update()

            wants_copy = copy.copy(wants)
            for want in wants_copy:
                self.progress("Checking %s" % (want,))
                if wants[want](ltm):
                    self.progress("  Fulfilled")
                    del wants[want]

    def convertDmsToDdFormat(self, dms):
        deg = math.trunc(dms * 1e-7)
        dd = deg + (((dms * 1.0e-7) - deg) * 100.0 / 60.0)
        if dd < -180.0 or dd > 180.0:
            dd = 0.0
        return math.trunc(dd * 1.0e7)

    def DEVO(self):
        '''Test DEVO serial output'''
        self.context_push()
        self.set_parameter("SERIAL5_PROTOCOL", 17) # serial5 is DEVO output
        port = self.spare_network_port()
        self.customise_SITL_commandline([
            "--serial5=tcp:%u" % port  # serial5 spews to localhost port
        ])
        devo = DEVO(("127.0.0.1", port))
        self.wait_ready_to_arm()
        m = self.assert_receive_message('GLOBAL_POSITION_INT', timeout=1)

        tstart = self.get_sim_time_cached()
        while True:
            self.drain_mav()
            now = self.get_sim_time_cached()
            if now - tstart > 10:
                if devo.frame is not None:
                    # we received some frames but could not find correct values
                    raise AutoTestTimeoutException("Failed to get correct data")
                else:
                    # No frames received. Devo telemetry is compiled out?
                    break

            devo.update()
            frame = devo.frame
            if frame is None:
                continue

            m = self.mav.recv_match(type='GLOBAL_POSITION_INT', blocking=True)

            loc = LocationInt(self.convertDmsToDdFormat(frame.lat()), self.convertDmsToDdFormat(frame.lon()), 0, 0)

            print("received lat:%s expected lat:%s" % (str(loc.lat), str(m.lat)))
            print("received lon:%s expected lon:%s" % (str(loc.lon), str(m.lon)))
            dist_diff = self.get_distance_int(loc, m)
            print("Distance:%s" % str(dist_diff))
            if abs(dist_diff) > 2:
                continue

            gpi_rel_alt = int(m.relative_alt / 10) # mm -> cm, since driver send alt in cm
            print("received alt:%s expected alt:%s" % (str(frame.alt()), str(gpi_rel_alt)))
            if abs(gpi_rel_alt - frame.alt()) > 10:
                continue

            print("received gndspeed: %s" % str(frame.speed()))
            if frame.speed() != 0:
                # FIXME if we start the vehicle moving.... check against VFR_HUD?
                continue

            print("received temp:%s expected temp:%s" % (str(frame.temp()), str(self.mav.messages['HEARTBEAT'].custom_mode)))
            if frame.temp() != self.mav.messages['HEARTBEAT'].custom_mode:
                # currently we receive mode as temp. This should be fixed when driver is updated
                continue

            # we match the received voltage with the voltage of primary instance
            batt = self.mav.recv_match(
                type='BATTERY_STATUS',
                blocking=True,
                timeout=5,
                condition="BATTERY_STATUS.id==0"
            )
            if batt is None:
                raise NotAchievedException("Did not get BATTERY_STATUS message")
            volt = batt.voltages[0]*0.001
            print("received voltage:%s expected voltage:%s" % (str(frame.volt()*0.1), str(volt)))
            if abs(frame.volt()*0.1 - volt) > 0.1:
                continue
            # if we reach here, exit
            break
        self.context_pop()
        self.reboot_sitl()

    def MSP_DJI(self):
        '''Test MSP DJI serial output'''
        self.set_parameter("SERIAL5_PROTOCOL", 33) # serial5 is MSP DJI output
        self.set_parameter("MSP_OPTIONS", 1) # telemetry (unpolled) mode
        port = self.spare_network_port()
        self.customise_SITL_commandline([
            "--serial5=tcp:%u" % port # serial5 spews to localhost port
        ])
        msp = MSP_DJI(("127.0.0.1", port))
        self.wait_ready_to_arm()

        tstart = self.get_sim_time()
        while True:
            self.drain_mav()
            if self.get_sim_time_cached() - tstart > 10:
                raise NotAchievedException("Did not get location")
            msp.update()
            try:
                f = msp.get_frame(msp.FRAME_GPS_RAW)
            except KeyError:
                continue
            dist = self.get_distance_int(f.LocationInt(), self.sim_location_int())
            print("lat=%f lon=%f dist=%f" % (f.lat(), f.lon(), dist))
            if dist < 1:
                break

    def CRSF(self):
        '''Test RC CRSF'''
        self.context_push()
        ex = None
        try:
            self.set_parameter("SERIAL5_PROTOCOL", 23) # serial5 is RCIN input
            port = self.spare_network_port()
            self.customise_SITL_commandline([
                "--serial5=tcp:%u" % port # serial5 reads from to localhost port
            ])
            crsf = CRSF(("127.0.0.1", port))
            crsf.connect()

            self.progress("Writing vtx_frame")
            crsf.write_data_id(crsf.dataid_vtx_frame)
            self.delay_sim_time(5)
            self.progress("Writing vtx_telem")
            crsf.write_data_id(crsf.dataid_vtx_telem)
            self.delay_sim_time(5)
            self.progress("Writing vtx_unknown")
            crsf.write_data_id(crsf.dataid_vtx_unknown)
            self.delay_sim_time(5)
        except Exception as e:
            self.print_exception_caught(e)
            ex = e
        self.context_pop()
        self.disarm_vehicle(force=True)
        self.reboot_sitl()
        if ex is not None:
            raise ex

    def CompassPrearms(self):
        '''test compass prearm checks'''
        self.wait_ready_to_arm()
        # XY are checked specially:
        for axis in 'X', 'Y':  # ArduPilot only checks these two axes
            self.context_push()
            self.set_parameter(f"COMPASS_OFS2_{axis}", 1000)
            self.assert_prearm_failure("Compasses inconsistent")
            self.context_pop()
            self.wait_ready_to_arm()

        # now test the total anglular difference:
        self.context_push()
        self.set_parameters({
            "COMPASS_OFS2_X": 1000,
            "COMPASS_OFS2_Y": -1000,
            "COMPASS_OFS2_Z": -10000,
        })
        self.assert_prearm_failure("Compasses inconsistent")
        self.context_pop()
        self.wait_ready_to_arm()
        # the following line papers over a probably problem with the
        # EKF recovering from bad compass offsets.  Without it, the
        # EKF will maintain a 10-degree offset from the true compass
        # heading seemingly indefinitely.
        self.reboot_sitl()

    def run_replay(self, filepath):
        '''runs replay in filepath, returns filepath to Replay logfile'''
        util.run_cmd(
            ['build/sitl/tool/Replay', filepath],
            directory=util.topdir(),
            checkfail=True,
            show=True,
            output=True,
        )
        return self.current_onboard_log_filepath()

    def AHRS_ORIENTATION(self):
        '''test AHRS_ORIENTATION parameter works'''
        self.context_push()
        self.wait_ready_to_arm()
        original_imu = self.assert_receive_message("RAW_IMU", verbose=True)
        self.set_parameter("AHRS_ORIENTATION", 16)  # roll-90
        self.delay_sim_time(2)  # we update this on a timer
        new_imu = self.assert_receive_message("RAW_IMU", verbose=True)
        delta_zacc = original_imu.zacc - new_imu.zacc
        delta_z_g = delta_zacc/1000.0  # milligravities -> gravities
        if delta_z_g - 1 > 0.1:  # milligravities....
            raise NotAchievedException("Magic AHRS_ORIENTATION update did not work (delta_z_g=%f)" % (delta_z_g,))
        delta_yacc = original_imu.yacc - new_imu.yacc
        delta_y_g = delta_yacc/1000.0  # milligravities -> gravities
        if delta_y_g + 1 > 0.1:
            raise NotAchievedException("Magic AHRS_ORIENTATION update did not work (delta_y_g=%f)" % (delta_y_g,))
        self.context_pop()
        self.reboot_sitl()
        self.delay_sim_time(2)  # we update orientation on a timer

    def GPSTypes(self):
        '''check each simulated GPS works'''
        self.reboot_sitl()
        orig = self.poll_home_position(timeout=60)
        sim_gps = [
            # (sim_gps_type, name, gps_type, detect_name, serial_protocol, detect_prefix)
            # if gps_type is None we auto-detect
            # (0, "NONE"),
            (1, "UBLOX", None, "u-blox", 5, 'probing'),
            (5, "NMEA", 5, "NMEA", 5, 'probing'),
            (6, "SBP", None, "SBP", 5, 'probing'),
            (8, "NOVA", 15, "NOVA", 5, 'probing'),  # no attempt to auto-detect this in AP_GPS
            (9, "SBP2", None, "SBP2", 5, 'probing'),
            (10, "SBF", 10, 'SBF', 5, 'probing'),
            (11, "GSOF", 11, "GSOF", 5, 'specified'), # no attempt to auto-detect this in AP_GPS
            (19, "MSP", 19, "MSP", 32, 'specified'),  # no attempt to auto-detect this in AP_GPS
            # (9, "FILE"),
        ]
        self.context_collect("STATUSTEXT")
        for (sim_gps_type, name, gps_type, detect_name, serial_protocol, detect_prefix) in sim_gps:
            self.start_subtest("Checking GPS type %s" % name)
            self.set_parameter("SIM_GPS_TYPE", sim_gps_type)
            self.set_parameter("SERIAL3_PROTOCOL", serial_protocol)
            if gps_type is None:
                gps_type = 1  # auto-detect
            self.set_parameter("GPS1_TYPE", gps_type)
            self.context_clear_collection('STATUSTEXT')
            self.reboot_sitl()
            if detect_prefix == "probing":
                self.wait_statustext(f"probing for {detect_name}", check_context=True)
            else:
                self.wait_statustext(f"specified as {detect_name}", check_context=True)
            self.wait_statustext(f"detected {detect_name}", check_context=True)
            n = self.poll_home_position(timeout=120)
            distance = self.get_distance_int(orig, n)
            if distance > 1:
                raise NotAchievedException(f"gps type {name} misbehaving")

    def assert_gps_satellite_count(self, messagename, count):
        m = self.assert_receive_message(messagename)
        if m.satellites_visible != count:
            raise NotAchievedException("Expected %u sats, got %u" %
                                       (count, m.satellites_visible))

    def check_attitudes_match(self):
        '''make sure ahrs2 and simstate and ATTTIUDE_QUATERNION all match'''

        # these are ordered to bookend the list with timestamps (which
        # both attitude messages have):
        get_names = ['ATTITUDE', 'SIMSTATE', 'AHRS2', 'ATTITUDE_QUATERNION']
        msgs = self.get_messages_frame(get_names)

        for get_name in get_names:
            self.progress("%s: %s" % (get_name, msgs[get_name]))

        simstate = msgs['SIMSTATE']
        attitude = msgs['ATTITUDE']
        ahrs2 = msgs['AHRS2']
        attitude_quaternion = msgs['ATTITUDE_QUATERNION']

        # check ATTITUDE
        want = math.degrees(simstate.roll)
        got = math.degrees(attitude.roll)
        if abs(mavextra.angle_diff(want, got)) > 20:
            raise NotAchievedException("ATTITUDE.Roll looks bad (want=%f got=%f)" %
                                       (want, got))
        want = math.degrees(simstate.pitch)
        got = math.degrees(attitude.pitch)
        if abs(mavextra.angle_diff(want, got)) > 20:
            raise NotAchievedException("ATTITUDE.Pitch looks bad (want=%f got=%f)" %
                                       (want, got))

        # check AHRS2
        want = math.degrees(simstate.roll)
        got = math.degrees(ahrs2.roll)
        if abs(mavextra.angle_diff(want, got)) > 20:
            raise NotAchievedException("AHRS2.Roll looks bad (want=%f got=%f)" %
                                       (want, got))

        want = math.degrees(simstate.pitch)
        got = math.degrees(ahrs2.pitch)
        if abs(mavextra.angle_diff(want, got)) > 20:
            raise NotAchievedException("AHRS2.Pitch looks bad (want=%f got=%f)" %
                                       (want, got))

        # check ATTITUDE_QUATERNION
        q = quaternion.Quaternion([
            attitude_quaternion.q1,
            attitude_quaternion.q2,
            attitude_quaternion.q3,
            attitude_quaternion.q4
        ])
        euler = q.euler
        self.progress("attquat:%s q:%s euler:%s" % (
            str(attitude_quaternion), q, euler))

        want = math.degrees(simstate.roll)
        got = math.degrees(euler[0])
        if mavextra.angle_diff(want, got) > 20:
            raise NotAchievedException("quat roll differs from attitude roll; want=%f got=%f" %
                                       (want, got))

        want = math.degrees(simstate.pitch)
        got = math.degrees(euler[1])
        if mavextra.angle_diff(want, got) > 20:
            raise NotAchievedException("quat pitch differs from attitude pitch; want=%f got=%f" %
                                       (want, got))

    def MultipleGPS(self):
        '''check ArduPilot behaviour across multiple GPS units'''
        self.assert_message_rate_hz('GPS2_RAW', 0)

        # we start sending GPS2_TYPE - but it will never actually be
        # filled in as _port[1] is only filled in in AP_GPS::init()
        self.start_subtest("Get GPS2_RAW as soon as we're configured for a second GPS")
        self.set_parameter("GPS2_TYPE", 1)
        self.assert_message_rate_hz('GPS2_RAW', 5)

        self.start_subtest("Ensure correct fix type when no connected GPS")
        m = self.assert_receive_message("GPS2_RAW")
        self.progress(self.dump_message_verbose(m))
        if m.fix_type != mavutil.mavlink.GPS_FIX_TYPE_NO_GPS:
            raise NotAchievedException("Incorrect fix type")

        self.start_subtest("Ensure detection when sim gps connected")
        self.set_parameter("SIM_GPS2_TYPE", 1)
        self.set_parameter("SIM_GPS2_DISABLE", 0)
        # a reboot is required after setting GPS2_TYPE.  We start
        # sending GPS2_RAW out, once the parameter is set, but a
        # reboot is required because _port[1] is only set in
        # AP_GPS::init() at boot time, so it will never be detected.
        self.context_collect("STATUSTEXT")
        self.reboot_sitl()
        self.wait_statustext("GPS 1: detected u-blox", check_context=True)
        self.wait_statustext("GPS 2: detected u-blox", check_context=True)
        m = self.assert_receive_message("GPS2_RAW")
        self.progress(self.dump_message_verbose(m))
        # would be nice for it to take some time to get a fix....
        if m.fix_type != mavutil.mavlink.GPS_FIX_TYPE_RTK_FIXED:
            raise NotAchievedException("Incorrect fix type")

        self.start_subtest("Check parameters are per-GPS")
        self.assert_parameter_value("SIM_GPS_NUMSATS", 10)
        self.assert_gps_satellite_count("GPS_RAW_INT", 10)
        self.set_parameter("SIM_GPS_NUMSATS", 13)
        self.assert_gps_satellite_count("GPS_RAW_INT", 13)

        self.assert_parameter_value("SIM_GPS2_NUMSATS", 10)
        self.assert_gps_satellite_count("GPS2_RAW", 10)
        self.set_parameter("SIM_GPS2_NUMSATS", 12)
        self.assert_gps_satellite_count("GPS2_RAW", 12)

        self.start_subtest("check that GLOBAL_POSITION_INT fails over")
        m = self.assert_receive_message("GLOBAL_POSITION_INT")
        gpi_alt = m.alt
        for msg in ["GPS_RAW_INT", "GPS2_RAW"]:
            m = self.assert_receive_message(msg)
            if abs(m.alt - gpi_alt) > 100:  # these are in mm
                raise NotAchievedException("Alt (%s) discrepancy; %d vs %d" %
                                           (msg, m.alt, gpi_alt))
        introduced_error = 10  # in metres
        self.set_parameter("SIM_GPS2_ALT_OFS", introduced_error)
        self.do_timesync_roundtrip()
        m = self.assert_receive_message("GPS2_RAW")
        if abs((m.alt-introduced_error*1000) - gpi_alt) > 100:
            raise NotAchievedException("skewed Alt (%s) discrepancy; %d+%d vs %d" %
                                       (msg, introduced_error*1000, m.alt, gpi_alt))
        m = self.assert_receive_message("GLOBAL_POSITION_INT")
        new_gpi_alt = m.alt
        if abs(gpi_alt - new_gpi_alt) > 100:
            raise NotAchievedException("alt moved unexpectedly")
        self.progress("Killing first GPS")
        self.set_parameter("SIM_GPS_DISABLE", 1)
        self.delay_sim_time(1)
        self.progress("Checking altitude now matches second GPS")
        m = self.assert_receive_message("GLOBAL_POSITION_INT")
        new_gpi_alt2 = m.alt
        m = self.assert_receive_message("GPS2_RAW")
        if abs(new_gpi_alt2 - m.alt) > 100:
            raise NotAchievedException("Failover not detected")

    def fetch_file_via_ftp(self, path, timeout=20):
        '''returns the content of the FTP'able file at path'''
        self.progress("Retrieving (%s) using MAVProxy" % path)
        mavproxy = self.start_mavproxy()
        mavproxy.expect("Saved .* parameters to")
        ex = None
        tmpfile = tempfile.NamedTemporaryFile(mode='r', delete=False)
        try:
            mavproxy.send("module load ftp\n")
            mavproxy.expect(["Loaded module ftp", "module ftp already loaded"])
            mavproxy.send("ftp set debug 1\n")  # so we get the "Terminated session" message
            mavproxy.send("ftp get %s %s\n" % (path, tmpfile.name))
            mavproxy.expect("Getting")
            tstart = self.get_sim_time()
            while True:
                now = self.get_sim_time()
                if now - tstart > timeout:
                    raise NotAchievedException("expected complete transfer")
                self.progress("Polling status")
                mavproxy.send("ftp status\n")
                try:
                    mavproxy.expect("No transfer in progress", timeout=1)
                    break
                except Exception:
                    continue
            # terminate the connection, or it may still be in progress the next time an FTP is attempted:
            mavproxy.send("ftp cancel\n")
            mavproxy.expect("Terminated session")
        except Exception as e:
            self.print_exception_caught(e)
            ex = e

        self.stop_mavproxy(mavproxy)

        if ex is not None:
            raise ex

        return tmpfile.read()

    def MAVFTP(self):
        '''ensure MAVProxy can do MAVFTP to ardupilot'''
        mavproxy = self.start_mavproxy()
        ex = None
        try:
            mavproxy.send("module load ftp\n")
            mavproxy.expect(["Loaded module ftp", "module ftp already loaded"])
            mavproxy.send("ftp list\n")
            some_directory = None
            for entry in sorted(os.listdir(".")):
                if os.path.isdir(entry):
                    some_directory = entry
                    break
            if some_directory is None:
                raise NotAchievedException("No directories?!")
            expected_line = " D %s" % some_directory
            mavproxy.expect(expected_line)  # one line from the ftp list output
        except Exception as e:
            self.print_exception_caught(e)
            ex = e

        self.stop_mavproxy(mavproxy)

        if ex is not None:
            raise ex

    def write_content_to_filepath(self, content, filepath):
        '''write biunary content to filepath'''
        with open(filepath, "wb") as f:
            if sys.version_info.major >= 3:
                if not isinstance(content, bytes):
                    raise NotAchievedException("Want bytes to write_content_to_filepath")
            f.write(content)
            f.close()

    def add_embedded_params_to_binary(self, binary, defaults):
        sys.path.insert(1, os.path.join(self.rootdir(), 'Tools', 'scripts'))
        import apj_tool

        # copy binary
        if getattr(self, "embedded_default_counter", None) is None:
            self.embedded_default_counter = 0
        self.embedded_default_counter += 1

        new_filepath = binary + "-newdefaults-%u" % self.embedded_default_counter
        shutil.copy(binary, new_filepath)

        # create file for defaults
        defaults_filepath = "embed-these-defaults.txt"
        self.write_content_to_filepath(defaults.encode('utf-8'), defaults_filepath)

        # do the needful
        a = apj_tool.embedded_defaults(new_filepath)
        if not a.find():
            raise NotAchievedException("Did not find defaults")
        a.set_file(defaults_filepath)
        a.save()

        return new_filepath

    def sample_param_file_content(self):
        '''returns an array of tuples, (param file content, dictionary of what
        parameter values should be tested afterwards)'''
        dashes = "-" * 150
        return [
            # multiple lines:
            ("""SERIAL5_BAUD 1234
SERIAL4_BAUD=4567
""", {"SERIAL5_BAUD": 1234, "SERIAL4_BAUD": 4567}),

            # line missing CR:
            ("""SERIAL5_BAUD 6789""", {"SERIAL5_BAUD": 6789}),

            # commented-out line:
            ("""# SERIAL5_BAUD 6789""", {"SERIAL5_BAUD": 57}),

            # very long comment line followed by more text:
            ("""SERIAL4_BAUD 6789
# awesome dashes: %s
SERIAL5_BAUD 128
""" % dashes, {"SERIAL4_BAUD": 6789, "SERIAL5_BAUD": 128}),

        ]

    def EmbeddedParamParser(self):
        '''check parsing of embedded defaults file'''
        # warning: don't try this test on Copter as it won't boot
        # without the passed-in file (which we don't parse if there
        # are embedded defaults)
        for (content, param_values) in self.sample_param_file_content():
            binary_with_defaults = self.add_embedded_params_to_binary(self.binary, content)
            self.customise_SITL_commandline([], binary=binary_with_defaults)
            self.assert_parameter_values(param_values)

    def _MotorTest(self,
                   command,
                   timeout=60,
                   mot1_servo_chan=1,
                   mot4_servo_chan=4,
                   wait_finish_text=True,
                   quadplane=False):
        '''Run Motor Tests (with specific mavlink message)'''
        self.start_subtest("Testing PWM output")
        pwm_in = 1300
        # default frame is "+" - start motor of 2 is "B", which is
        # motor 1... see
        # https://ardupilot.org/copter/docs/connect-escs-and-motors.html
        command(
            mavutil.mavlink.MAV_CMD_DO_MOTOR_TEST,
            p1=2, # start motor
            p2=mavutil.mavlink.MOTOR_TEST_THROTTLE_PWM,
            p3=pwm_in, # pwm-to-output
            p4=2, # timeout in seconds
            p5=2, # number of motors to output
            p6=0, # compass learning
            timeout=timeout,
        )
        # long timeouts here because there's a pause before we start motors
        self.wait_servo_channel_value(mot1_servo_chan, pwm_in, timeout=10)
        self.wait_servo_channel_value(mot4_servo_chan, pwm_in, timeout=10)
        if wait_finish_text:
            self.wait_statustext("finished motor test")
        self.wait_disarmed()
        # wait_disarmed is not sufficient here; it's actually the
        # *motors* being armed which causes the problem, not the
        # vehicle's arm state!  Could we use SYS_STATUS here instead?
        self.delay_sim_time(10)
        self.end_subtest("Testing PWM output")

        self.start_subtest("Testing percentage output")
        percentage = 90.1
        # since MOT_SPIN_MIN and MOT_SPIN_MAX are not set, the RC3
        # min/max are used.
        expected_pwm = 1000 + (self.get_parameter("RC3_MAX") - self.get_parameter("RC3_MIN")) * percentage/100.0
        # quadplane doesn't use the expect value - it wants 1900
        # rather than the calculated 1901...
        if quadplane:
            expected_pwm = 1900
        self.progress("expected pwm=%f" % expected_pwm)
        command(
            mavutil.mavlink.MAV_CMD_DO_MOTOR_TEST,
            p1=2, # start motor
            p2=mavutil.mavlink.MOTOR_TEST_THROTTLE_PERCENT,
            p3=percentage, # pwm-to-output
            p4=2, # timeout in seconds
            p5=2, # number of motors to output
            p6=0, # compass learning
            timeout=timeout,
        )
        self.wait_servo_channel_value(mot1_servo_chan, expected_pwm, timeout=10)
        self.wait_servo_channel_value(mot4_servo_chan, expected_pwm, timeout=10)
        if wait_finish_text:
            self.wait_statustext("finished motor test")
        self.wait_disarmed()
        # wait_disarmed is not sufficient here; it's actually the
        # *motors* being armed which causes the problem, not the
        # vehicle's arm state!  Could we use SYS_STATUS here instead?
        self.delay_sim_time(10)
        self.end_subtest("Testing percentage output")

    def MotorTest(self, timeout=60, **kwargs):
        '''Run Motor Tests'''  # common to Copter and QuadPlane
        self._MotorTest(self.run_cmd, **kwargs)
        self._MotorTest(self.run_cmd_int, **kwargs)

    def test_ibus_voltage(self, message):
        batt = self.mav.recv_match(
            type='BATTERY_STATUS',
            blocking=True,
            timeout=5,
            condition="BATTERY_STATUS.id==0"
        )
        if batt is None:
            raise NotAchievedException("Did not get BATTERY_STATUS message")
        want = int(batt.voltages[0] * 0.1)

        if want != message.get_sensor_value():
            raise NotAchievedException("Bad voltage (want=%u got=%u)" %
                                       (want, message.get_sensor_value()))
        self.progress("iBus voltage OK")

    def test_ibus_armed(self, message):
        got = message.get_sensor_value()
        want = 1 if self.armed() else 0
        if got != want:
            raise NotAchievedException("Expected armed %u got %u" %
                                       (want, got))
        self.progress("iBus armed OK")

    def test_ibus_mode(self, message):
        got = message.get_sensor_value()
        want = self.mav.messages['HEARTBEAT'].custom_mode
        if got != want:
            raise NotAchievedException("Expected mode %u got %u" %
                                       (want, got))
        self.progress("iBus mode OK")

    def test_ibus_get_response(self, ibus, timeout=5):
        tstart = self.get_sim_time()
        while True:
            now = self.get_sim_time()
            if now - tstart > timeout:
                raise AutoTestTimeoutException("Failed to get ibus data")
            packet = ibus.update()
            if packet is not None:
                return packet

    def IBus(self):
        '''test the IBus protocol'''
        self.set_parameter("SERIAL5_PROTOCOL", 49)
        self.customise_SITL_commandline([
            "--serial5=tcp:6735" # serial5 spews to localhost:6735
        ])
        ibus = IBus(("127.0.0.1", 6735))
        ibus.connect()

        # expected_sensors should match the list created in AP_IBus_Telem
        expected_sensors = {
            # sensor id : (len, IBUS_MEAS_TYPE_*, test_function)
            1: (2, 0x15, self.test_ibus_armed),
            2: (2, 0x16, self.test_ibus_mode),
            5: (2, 0x03, self.test_ibus_voltage),
        }

        for (sensor_addr, results) in expected_sensors.items():
            # first make sure it is present:
            request = IBusRequest_DISCOVER(sensor_addr)
            ibus.port.sendall(request.for_wire())

            packet = self.test_ibus_get_response(ibus)
            if packet.address != sensor_addr:
                raise ValueError("Unexpected sensor address %u" %
                                 (packet.address,))

            (expected_length, expected_type, validator) = results

            self.progress("Getting sensor (%x) type" % (sensor_addr))
            request = IBusRequest_GET_SENSOR_TYPE(sensor_addr)
            ibus.port.sendall(request.for_wire())

            packet = self.test_ibus_get_response(ibus)
            if packet.address != sensor_addr:
                raise ValueError("Unexpected sensor address %u" %
                                 (packet.address,))

            if packet.sensor_type != expected_type:
                raise ValueError("Unexpected sensor type want=%u got=%u" %
                                 (expected_type, packet.sensor_type))

            if packet.sensor_length != expected_length:
                raise ValueError("Unexpected sensor len want=%u got=%u" %
                                 (expected_length, packet.sensor_length))

            self.progress("Getting sensor (%x) value" % (sensor_addr))
            request = IBusRequest_GET_SENSOR_VALUE(sensor_addr)
            ibus.port.sendall(request.for_wire())

            packet = self.test_ibus_get_response(ibus)
            validator(packet)

        # self.progress("Ensure we cover all sensors")
        # for i in range(1, 17):  # zero is special
        #     if i in expected_sensors:
        #         continue
        #     request = IBusRequest_DISCOVER(i)
        #     ibus.port.sendall(request.for_wire())

        #     try:
        #         packet = self.test_ibus_get_response(ibus, timeout=1)
        #     except AutoTestTimeoutException:
        #         continue
        #     self.progress("Received packet (%s)" % str(packet))
        #     raise NotAchievedException("IBus sensor %u is untested" % i)

    def tests(self):
        return [
            self.PIDTuning,
            self.ArmFeatures,
            self.SetHome,
            self.ConfigErrorLoop,
            self.CPUFailsafe,
            self.Parameters,
            self.LoggerDocumentation,
            self.Logging,
            self.GetCapabilities,
            self.InitialMode,
        ]

    def post_tests_announcements(self):
        if self._show_test_timings:
            if self.waiting_to_arm_count == 0:
                avg = None
            else:
                avg = self.total_waiting_to_arm_time/self.waiting_to_arm_count
            self.progress("Spent %f seconds waiting to arm. count=%u avg=%s" %
                          (self.total_waiting_to_arm_time,
                           self.waiting_to_arm_count,
                           str(avg)))
            self.show_test_timings()
        if self.forced_post_test_sitl_reboots != 0:
            print("Had to force-reset SITL %u times" %
                  (self.forced_post_test_sitl_reboots,))

    def autotest(self, tests=None, allow_skips=True, step_name=None):
        """Autotest used by ArduPilot autotest CI."""
        if tests is None:
            tests = self.tests()
        all_tests = []
        for test in tests:
            if not isinstance(test, Test):
                test = Test(test)
            all_tests.append(test)

        disabled = self.disabled_tests()
        if not allow_skips:
            disabled = {}
        skip_list = []
        tests = []
        seen_test_name = set()
        for test in all_tests:
            if test.name in seen_test_name:
                raise ValueError("Duplicate test name %s" % test.name)
            seen_test_name.add(test.name)
            if test.name in disabled:
                self.progress("##### %s is skipped: %s" % (test, disabled[test.name]))
                skip_list.append((test, disabled[test.name]))
                continue
            tests.append(test)

        results = self.run_tests(tests)

        if len(skip_list):
            self.progress("Skipped tests:")
            for skipped in skip_list:
                (test, reason) = skipped
                print("  %s (see %s)" % (test.name, reason))

        self.fail_list = list(filter(lambda x : not x.passed, results))
        if len(self.fail_list):
            self.progress("Failing tests:")
            for failure in self.fail_list:
                print(str(failure))

        self.post_tests_announcements()
        if self.generate_junit:
            if step_name is None:
                step_name = "Unknown_step_name"
            step_name.replace(".", "_")
            self.create_junit_report(step_name, results, skip_list)

        return len(self.fail_list) == 0

    def create_junit_report(self, test_name: str, results: List[Result], skip_list: List[Tuple[Test, Dict[str, str]]]) -> None:
        """Generate Junit report from the autotest results"""
        from junitparser import TestCase, TestSuite, JUnitXml, Skipped, Failure
        frame = self.vehicleinfo_key()
        xml_filename = f"autotest_result_{frame}_{test_name}_junit.xml"
        self.progress(f"Writing test result in jUnit format to {xml_filename}\n")

        suite = TestSuite(f"Autotest {frame} {test_name}")
        suite.timestamp = datetime.now().replace(microsecond=0).isoformat()
        for result in results:
            case = TestCase(f"{result.test.name}", f"{frame}", result.time_elapsed)
            # f"{result.test.description}"
            # case.file ## TODO : add file properties to match test location
            if not result.passed:
                case.result = [Failure(f"see {result.debug_filename}", f"{result.exception}")]
            suite.add_testcase(case)
        for skipped in skip_list:
            (test, reason) = skipped
            case = TestCase(f"{test.name}", f"{test.function}")
            case.result = [Skipped(f"Skipped : {reason}")]

        suite.add_property("Firmware Version Major", self.fcu_firmware_version[0])
        suite.add_property("Firmware Version Minor", self.fcu_firmware_version[1])
        suite.add_property("Firmware Version Rev", self.fcu_firmware_version[2])
        suite.add_property("Firmware hash", self.fcu_firmware_hash)
        suite.add_property("Git hash", self.githash)
        mavproxy_version = util.MAVProxy_version()
        suite.add_property("Mavproxy Version Major", mavproxy_version[0])
        suite.add_property("Mavproxy Version Minor", mavproxy_version[1])
        suite.add_property("Mavproxy Version Rev", mavproxy_version[2])

        xml = JUnitXml()
        xml.add_testsuite(suite)
        xml.write(xml_filename, pretty=True)

    def mavfft_fttd(self, sensor_type, sensor_instance, since, until):
        '''display fft for raw ACC data in current logfile'''

        '''object to store data about a single FFT plot'''
        class MessageData(object):
            def __init__(self, ffth):
                self.seqno = -1
                self.fftnum = ffth.N
                self.sensor_type = ffth.type
                self.instance = ffth.instance
                self.sample_rate_hz = ffth.smp_rate
                self.multiplier = ffth.mul
                self.sample_us = ffth.SampleUS
                self.data = {}
                self.data["X"] = []
                self.data["Y"] = []
                self.data["Z"] = []
                self.holes = False
                self.freq = None

            def add_fftd(self, fftd):
                self.seqno += 1
                self.data["X"].extend(fftd.x)
                self.data["Y"].extend(fftd.y)
                self.data["Z"].extend(fftd.z)

        mlog = self.dfreader_for_current_onboard_log()

        # see https://holometer.fnal.gov/GH_FFT.pdf for a description of the techniques used here
        messages = []
        messagedata = None
        while True:
            m = mlog.recv_match()
            if m is None:
                break
            msg_type = m.get_type()
            if msg_type == "ISBH":
                if messagedata is not None:
                    if (messagedata.sensor_type == sensor_type and
                            messagedata.instance == sensor_instance and
                            messagedata.sample_us > since and
                            messagedata.sample_us < until):
                        messages.append(messagedata)
                messagedata = MessageData(m)
                continue

            if msg_type == "ISBD":
                if (messagedata is not None and
                        messagedata.sensor_type == sensor_type and
                        messagedata.instance == sensor_instance):
                    messagedata.add_fftd(m)

        fft_len = len(messages[0].data["X"])
        sum_fft = {
            "X": numpy.zeros(int(fft_len / 2 + 1)),
            "Y": numpy.zeros(int(fft_len / 2 + 1)),
            "Z": numpy.zeros(int(fft_len / 2 + 1)),
        }
        sample_rate = 0
        counts = 0
        window = numpy.hanning(fft_len)
        # The returned float array f contains the frequency bin centers in cycles per unit of the
        # sample spacing (with zero at the start).
        freqmap = numpy.fft.rfftfreq(fft_len, 1.0 / messages[0].sample_rate_hz)

        # calculate NEBW constant
        S2 = numpy.inner(window, window)

        for message in messages:
            for axis in ["X", "Y", "Z"]:
                # normalize data and convert to dps in order to produce more meaningful magnitudes
                if message.sensor_type == 1:
                    d = numpy.array(numpy.degrees(message.data[axis])) / float(message.multiplier)
                else:
                    d = numpy.array(message.data[axis]) / float(message.multiplier)

                # apply window to the input
                d *= window
                # perform RFFT
                d_fft = numpy.fft.rfft(d)
                # convert to squared complex magnitude
                d_fft = numpy.square(abs(d_fft))
                # remove DC component
                d_fft[0] = 0
                d_fft[-1] = 0
                # accumulate the sums
                sum_fft[axis] += d_fft

            sample_rate = message.sample_rate_hz
            counts += 1

        numpy.seterr(divide='ignore')
        psd = {}
        for axis in ["X", "Y", "Z"]:
            # normalize output to averaged PSD
            psd[axis] = 2 * (sum_fft[axis] / counts) / (sample_rate * S2)
            psd[axis] = 10 * numpy.log10(psd[axis])

        psd["F"] = freqmap

        return psd

    def model_defaults_filepath(self, model):
        vehicle = self.vehicleinfo_key()
        vinfo = vehicleinfo.VehicleInfo()
        defaults_filepath = vinfo.options[vehicle]["frames"][model]["default_params_filename"]
        if isinstance(defaults_filepath, str):
            defaults_filepath = [defaults_filepath]
        defaults_list = []
        for d in defaults_filepath:
            defaults_list.append(util.reltopdir(os.path.join(testdir, d)))
        return defaults_list

    def load_default_params_file(self, filename):
        '''load a file from Tools/autotest/default_params'''
        filepath = util.reltopdir(os.path.join("Tools", "autotest", "default_params", filename))
        self.repeatedly_apply_parameter_filepath(filepath)

    def load_params_file(self, filename):
        '''load a file from test-specific directory'''
        filepath = os.path.join(testdir, self.current_test_name_directory, filename)
        self.repeatedly_apply_parameter_filepath(filepath)

    def send_pause_command(self):
        '''pause AUTO/GUIDED modes'''
        self.run_cmd(
            mavutil.mavlink.MAV_CMD_DO_PAUSE_CONTINUE,
            p1=0, # 0: pause, 1: continue
        )

    def send_resume_command(self):
        '''resume AUTO/GUIDED modes'''
        self.run_cmd(
            mavutil.mavlink.MAV_CMD_DO_PAUSE_CONTINUE,
            p1=1, # 0: pause, 1: continue
        )

    def enum_state_name(self, enum_name, state, pretrim=None):
        e = mavutil.mavlink.enums[enum_name]
        e_value = e[state]
        name = e_value.name
        if pretrim is not None:
            if not pretrim.startswith(pretrim):
                raise NotAchievedException("Expected %s to pretrim" % (pretrim))
            name = name.replace(pretrim, "")
        return name

    def vtol_state_name(self, state):
        return self.enum_state_name("MAV_VTOL_STATE", state, pretrim="MAV_VTOL_STATE_")

    def landed_state_name(self, state):
        return self.enum_state_name("MAV_LANDED_STATE", state, pretrim="MAV_LANDED_STATE_")

    def assert_extended_sys_state(self, vtol_state, landed_state):
        m = self.assert_receive_message('EXTENDED_SYS_STATE', timeout=1)
        if m.vtol_state != vtol_state:
            raise ValueError("Bad MAV_VTOL_STATE.  Want=%s got=%s" %
                             (self.vtol_state_name(vtol_state),
                              self.vtol_state_name(m.vtol_state)))
        if m.landed_state != landed_state:
            raise ValueError("Bad MAV_LANDED_STATE.  Want=%s got=%s" %
                             (self.landed_state_name(landed_state),
                              self.landed_state_name(m.landed_state)))

    def wait_extended_sys_state(self, vtol_state, landed_state, timeout=10):
        tstart = self.get_sim_time()
        while True:
            if self.get_sim_time() - tstart > timeout:
                raise NotAchievedException("Did not achieve vol/landed states")
            self.progress("Waiting for MAV_VTOL_STATE=%s MAV_LANDED_STATE=%s" %
                          (self.vtol_state_name(vtol_state),
                           self.landed_state_name(landed_state)))
            m = self.assert_receive_message('EXTENDED_SYS_STATE', verbose=True)
            if m.landed_state != landed_state:
                self.progress("Wrong MAV_LANDED_STATE (want=%s got=%s)" %
                              (self.landed_state_name(landed_state),
                               self.landed_state_name(m.landed_state)))
                continue
            if m.vtol_state != vtol_state:
                self.progress("Wrong MAV_VTOL_STATE (want=%s got=%s)" %
                              (self.vtol_state_name(vtol_state),
                               self.vtol_state_name(m.vtol_state)))
                continue

            self.progress("vtol and landed states match")
            return

    def setGCSfailsafe(self, paramValue):
        # Slow down the sim rate if GCS Failsafe is in use
        if paramValue == 0:
            self.set_parameters({
                "FS_GCS_ENABLE": paramValue,
                "SIM_SPEEDUP": 10,
            })
        else:
            self.set_parameters({
                "SIM_SPEEDUP": 4,
                "FS_GCS_ENABLE": paramValue,
            })
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     