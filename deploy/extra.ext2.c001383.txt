to omit this prefix or use option -c++11 for scoped enumerations
enum tt__Duplex
{
	tt__Duplex__Full,	///< xs:string value="Full"
	tt__Duplex__Half,	///< xs:string value="Half"
};

/// @brief "http://www.onvif.org/ver10/schema":IANA-IfTypes is a simpleType restriction of type xs:int.
///
/// <PRE><BLOCKQUOTE>
///   For valid numbers, please refer to http://www.iana.org/assignments/ianaiftype-mib.
/// </BLOCKQUOTE></PRE>
///
typedef int tt__IANA_IfTypes;

/// @brief "http://www.onvif.org/ver10/schema":IPv6DHCPConfiguration is a simpleType restriction of type xs:string.
///
/// @note The enum values are prefixed with "tt__IPv6DHCPConfiguration__" to prevent name clashes: use wsdl2h option -e to omit this prefix or use option -c++11 for scoped enumerations
enum tt__IPv6DHCPConfiguration
{
	tt__IPv6DHCPConfiguration__Auto,	///< xs:string value="Auto"
	tt__IPv6DHCPConfiguration__Stateful,	///< xs:string value="Stateful"
	tt__IPv6DHCPConfiguration__Stateless,	///< xs:string value="Stateless"
	tt__IPv6DHCPConfiguration__Off,	///< xs:string value="Off"
};

/// @brief "http://www.onvif.org/ver10/schema":NetworkProtocolType is a simpleType restriction of type xs:string.
///
/// @note The enum values are prefixed with "tt__NetworkProtocolType__" to prevent name clashes: use wsdl2h option -e to omit this prefix or use option -c++11 for scoped enumerations
enum tt__NetworkProtocolType
{
	tt__NetworkProtocolType__HTTP,	///< xs:string value="HTTP"
	tt__NetworkProtocolType__HTTPS,	///< xs:string value="HTTPS"
	tt__NetworkProtocolType__RTSP,	///< xs:string value="RTSP"
};

/// @brief "http://www.onvif.org/ver10/schema":NetworkHostType is a simpleType restriction of type xs:string.
///
/// @note The enum values are prefixed with "tt__NetworkHostType__" to prevent name clashes: use wsdl2h option -e to omit this prefix or use option -c++11 for scoped enumerations
enum tt__NetworkHostType
{
	tt__NetworkHostType__IPv4,	///< xs:string value="IPv4"
	tt__NetworkHostType__IPv6,	///< xs:string value="IPv6"
	tt__NetworkHostType__DNS,	///< xs:string value="DNS"
};

/// @brief "http://www.onvif.org/ver10/schema":IPv4Address is a simpleType restriction of type xs:token.
///
typedef xsd__token tt__IPv4Address;

/// @brief "http://www.onvif.org/ver10/schema":IPv6Address is a simpleType restriction of type xs:token.
///
typedef xsd__token tt__IPv6Address;

/// @brief "http://www.onvif.org/ver10/schema":HwAddress is a simpleType restriction of type xs:token.
///
typedef xsd__token tt__HwAddress;

/// @brief "http://www.onvif.org/ver10/schema":IPType is a simpleType restriction of type xs:string.
///
/// @note The enum values are prefixed with "tt__IPType__" to prevent name clashes: use wsdl2h option -e to omit this prefix or use option -c++11 for scoped enumerations
enum tt__IPType
{
	tt__IPType__IPv4,	///< xs:string value="IPv4"
	tt__IPType__IPv6,	///< xs:string value="IPv6"
};

/// @brief "http://www.onvif.org/ver10/schema":DNSName is a simpleType restriction of type xs:token.
///
typedef xsd__token tt__DNSName;

// Optimization: simpleType "http://www.onvif.org/ver10/schema":Domain is not used and was removed

/// @brief "http://www.onvif.org/ver10/schema":IPAddressFilterType is a simpleType restriction of type xs:string.
///
/// @note The enum values are prefixed with "tt__IPAddressFilterType__" to prevent name clashes: use wsdl2h option -e to omit this prefix or use option -c++11 for scoped enumerations
enum tt__IPAddressFilterType
{
	tt__IPAddressFilterType__Allow,	///< xs:string value="Allow"
	tt__IPAddressFilterType__Deny,	///< xs:string value="Deny"
};

/// @brief "http://www.onvif.org/ver10/schema":DynamicDNSType is a simpleType restriction of type xs:string.
///
/// @note The enum values are prefixed with "tt__DynamicDNSType__" to prevent name clashes: use wsdl2h option -e to omit this prefix or use option -c++11 for scoped enumerations
enum tt__DynamicDNSType
{
	tt__DynamicDNSType__NoUpdate,	///< xs:string value="NoUpdate"
	tt__DynamicDNSType__ClientUpdates,	///< xs:string value="ClientUpdates"
	tt__DynamicDNSType__ServerUpdates,	///< xs:string value="ServerUpdates"
};

/// @brief "http://www.onvif.org/ver10/schema":Dot11SSIDType is a simpleType restriction of type xs:hexBinary.
///
/// Length of this content is 1 to 32.
typedef xsd__hexBinary tt__Dot11SSIDType 1 : 32;

/// @brief "http://www.onvif.org/ver10/schema":Dot11StationMode is a simpleType restriction of type xs:string.
///
/// @note The enum values are prefixed with "tt__Dot11StationMode__" to prevent name clashes: use wsdl2h option -e to omit this prefix or use option -c++11 for scoped enumerations
enum tt__Dot11StationMode
{
	tt__Dot11StationMode__Ad_hoc,	///< xs:string value="Ad-hoc"
	tt__Dot11StationMode__Infrastructure,	///< xs:string value="Infrastructure"
	tt__Dot11StationMode__Extended,	///< xs:string value="Extended"
};

/// @brief "http://www.onvif.org/ver10/schema":Dot11SecurityMode is a simpleType restriction of type xs:string.
///
/// @note The enum values are prefixed with "tt__Dot11SecurityMode__" to prevent name clashes: use wsdl2h option -e to omit this prefix or use option -c++11 for scoped enumerations
enum tt__Dot11SecurityMode
{
	tt__Dot11SecurityMode__None,	///< xs:string value="None"
	tt__Dot11SecurityMode__WEP,	///< xs:string value="WEP"
	tt__Dot11SecurityMode__PSK,	///< xs:string value="PSK"
	tt__Dot11SecurityMode__Dot1X,	///< xs:string value="Dot1X"
	tt__Dot11SecurityMode__Extended,	///< xs:string value="Extended"
};

/// @brief "http://www.onvif.org/ver10/schema":Dot11Cipher is a simpleType restriction of type xs:string.
///
/// @note The enum values are prefixed with "tt__Dot11Cipher__" to prevent name clashes: use wsdl2h option -e to omit this prefix or use option -c++11 for scoped enumerations
enum tt__Dot11Cipher
{
	tt__Dot11Cipher__CCMP,	///< xs:string value="CCMP"
	tt__Dot11Cipher__TKIP,	///< xs:string value="TKIP"
	tt__Dot11Cipher__Any,	///< xs:string value="Any"
	tt__Dot11Cipher__Extended,	///< xs:string value="Extended"
};

/// @brief "http://www.onvif.org/ver10/schema":Dot11PSK is a simpleType restriction of type xs:hexBinary.
///
/// Length of this content is 32.
typedef xsd__hexBinary tt__Dot11PSK 32 : 32;

/// @brief "http://www.onvif.org/ver10/schema":Dot11PSKPassphrase is a simpleType restriction of type xs:string.
///
/// Content pattern is "[ -~]{8,63}".
typedef char* tt__Dot11PSKPassphrase "[ -~]{8,63}";

/// @brief "http://www.onvif.org/ver10/schema":Dot11SignalStrength is a simpleType restriction of type xs:string.
///
/// @note The enum values are prefixed with "tt__Dot11SignalStrength__" to prevent name clashes: use wsdl2h option -e to omit this prefix or use option -c++11 for scoped enumerations
enum tt__Dot11SignalStrength
{
	tt__Dot11SignalStrength__None,	///< xs:string value="None"
	tt__Dot11SignalStrength__Very_x0020Bad,	///< xs:string value="Very Bad"
	tt__Dot11SignalStrength__Bad,	///< xs:string value="Bad"
	tt__Dot11SignalStrength__Good,	///< xs:string value="Good"
	tt__Dot11SignalStrength__Very_x0020Good,	///< xs:string value="Very Good"
	tt__Dot11SignalStrength__Extended,	///< xs:string value="Extended"
};

/// @brief "http://www.onvif.org/ver10/schema":Dot11AuthAndMangementSuite is a simpleType restriction of type xs:string.
///
/// @note The enum values are prefixed with "tt__Dot11AuthAndMangementSuite__" to prevent name clashes: use wsdl2h option -e to omit this prefix or use option -c++11 for scoped enumerations
enum tt__Dot11AuthAndMangementSuite
{
	tt__Dot11AuthAndMangementSuite__None,	///< xs:string value="None"
	tt__Dot11AuthAndMangementSuite__Dot1X,	///< xs:string value="Dot1X"
	tt__Dot11AuthAndMangementSuite__PSK,	///< xs:string value="PSK"
	tt__Dot11AuthAndMangementSuite__Extended,	///< xs:string value="Extended"
};

/// @brief "http://www.onvif.org/ver10/schema":CapabilityCategory is a simpleType restriction of type xs:string.
///
/// @note The enum values are prefixed with "tt__CapabilityCategory__" to prevent name clashes: use wsdl2h option -e to omit this prefix or use option -c++11 for scoped enumerations
enum tt__CapabilityCategory
{
	tt__CapabilityCategory__All,	///< xs:string value="All"
	tt__CapabilityCategory__Analytics,	///< xs:string value="Analytics"
	tt__CapabilityCategory__Device,	///< xs:string value="Device"
	tt__CapabilityCategory__Events,	///< xs:string value="Events"
	tt__CapabilityCategory__Imaging,	///< xs:string value="Imaging"
	tt__CapabilityCategory__Media,	///< xs:string value="Media"
	tt__CapabilityCategory__PTZ,	///< xs:string value="PTZ"
};

/// @brief "http://www.onvif.org/ver10/schema":SystemLogType is a simpleType restriction of type xs:string.
///
/// <PRE><BLOCKQUOTE>
///   Enumeration describing the available system log modes.
/// </BLOCKQUOTE></PRE>
///
/// @note The enum values are prefixed with "tt__SystemLogType__" to prevent name clashes: use wsdl2h option -e to omit this prefix or use option -c++11 for scoped enumerations
enum tt__SystemLogType
{
/// <PRE><BLOCKQUOTE>
///   Indicates that a system log is requested.
/// </BLOCKQUOTE></PRE>
///
	tt__SystemLogType__System,	///< xs:string value="System"
/// <PRE><BLOCKQUOTE>
///   Indicates that a access log is requested.
/// </BLOCKQUOTE></PRE>
///
	tt__SystemLogType__Access,	///< xs:string value="Access"
};

/// @brief "http://www.onvif.org/ver10/schema":FactoryDefaultType is a simpleType restriction of type xs:string.
///
/// <PRE><BLOCKQUOTE>
///   Enumeration describing the available factory default modes.
/// </BLOCKQUOTE></PRE>
///
/// @note The enum values are prefixed with "tt__FactoryDefaultType__" to prevent name clashes: use wsdl2h option -e to omit this prefix or use option -c++11 for scoped enumerations
enum tt__FactoryDefaultType
{
/// <PRE><BLOCKQUOTE>
///   Indicates that a hard factory default is requested.
/// </BLOCKQUOTE></PRE>
///
	tt__FactoryDefaultType__Hard,	///< xs:string value="Hard"
/// <PRE><BLOCKQUOTE>
///   Indicates that a soft factory default is requested.
/// </BLOCKQUOTE></PRE>
///
	tt__FactoryDefaultType__Soft,	///< xs:string value="Soft"
};

/// @brief "http://www.onvif.org/ver10/schema":SetDateTimeType is a simpleType restriction of type xs:string.
///
/// @note The enum values are prefixed with "tt__SetDateTimeType__" to prevent name clashes: use wsdl2h option -e to omit this prefix or use option -c++11 for scoped enumerations
enum tt__SetDateTimeType
{
/// <PRE><BLOCKQUOTE>
///   Indicates that the date and time are set manually.
/// </BLOCKQUOTE></PRE>
///
	tt__SetDateTimeType__Manual,	///< xs:string value="Manual"
/// <PRE><BLOCKQUOTE>
///   Indicates that the date and time are set through NTP
/// </BLOCKQUOTE></PRE>
///
	tt__SetDateTimeType__NTP,	///< xs:string value="NTP"
};

/// @brief "http://www.onvif.org/ver10/schema":UserLevel is a simpleType restriction of type xs:string.
///
/// @note The enum values are prefixed with "tt__UserLevel__" to prevent name clashes: use wsdl2h option -e to omit this prefix or use option -c++11 for scoped enumerations
enum tt__UserLevel
{
	tt__UserLevel__Administrator,	///< xs:string value="Administrator"
	tt__UserLevel__Operator,	///< xs:string value="Operator"
	tt__UserLevel__User,	///< xs:string value="User"
	tt__UserLevel__Anonymous,	///< xs:string value="Anonymous"
	tt__UserLevel__Extended,	///< xs:string value="Extended"
};

/// @brief "http://www.onvif.org/ver10/schema":RelayLogicalState is a simpleType restriction of type xs:string.
///
/// @note The enum values are prefixed with "tt__RelayLogicalState__" to prevent name clashes: use wsdl2h option -e to omit this prefix or use option -c++11 for scoped enumerations
enum tt__RelayLogicalState
{
	tt__RelayLogicalState__active,	///< xs:string value="active"
	tt__RelayLogicalState__inactive,	///< xs:string value="inactive"
};

/// @brief "http://www.onvif.org/ver10/schema":RelayIdleState is a simpleType restriction of type xs:string.
///
/// @note The enum values are prefixed with "tt__RelayIdleState__" to prevent name clashes: use wsdl2h option -e to omit this prefix or use option -c++11 for scoped enumerations
enum tt__RelayIdleState
{
	tt__RelayIdleState__closed,	///< xs:string value="closed"
	tt__RelayIdleState__open,	///< xs:string value="open"
};

/// @brief "http://www.onvif.org/ver10/schema":RelayMode is a simpleType restriction of type xs:string.
///
/// @note The enum values are prefixed with "tt__RelayMode__" to prevent name clashes: use wsdl2h option -e to omit this prefix or use option -c++11 for scoped enumerations
enum tt__RelayMode
{
	tt__RelayMode__Monostable,	///< xs:string value="Monostable"
	tt__RelayMode__Bistable,	///< xs:string value="Bistable"
};

// Optimization: simpleType "http://www.onvif.org/ver10/schema":DigitalIdleState is not used and was removed

/// @brief "http://www.onvif.org/ver10/schema":EFlipMode is a simpleType restriction of type xs:string.
///
/// @note The enum values are prefixed with "tt__EFlipMode__" to prevent name clashes: use wsdl2h option -e to omit this prefix or use option -c++11 for scoped enumerations
enum tt__EFlipMode
{
	tt__EFlipMode__OFF,	///< xs:string value="OFF"
	tt__EFlipMode__ON,	///< xs:string value="ON"
	tt__EFlipMode__Extended,	///< xs:string value="Extended"
};

/// @brief "http://www.onvif.org/ver10/schema":ReverseMode is a simpleType restriction of type xs:string.
///
/// @note The enum values are prefixed with "tt__ReverseMode__" to prevent name clashes: use wsdl2h option -e to omit this prefix or use option -c++11 for scoped enumerations
enum tt__ReverseMode
{
	tt__ReverseMode__OFF,	///< xs:string value="OFF"
	tt__ReverseMode__ON,	///< xs:string value="ON"
	tt__ReverseMode__AUTO,	///< xs:string value="AUTO"
	tt__ReverseMode__Extended,	///< xs:string value="Extended"
};

/// @brief "http://www.onvif.org/ver10/schema":AuxiliaryData is a simpleType restriction of type xs:string.
///
/// Length of this content is 0 to 128.
typedef char* tt__AuxiliaryData : 128;

/// @brief "http://www.onvif.org/ver10/schema":PTZPresetTourState is a simpleType restriction of type xs:string.
///
/// @note The enum values are prefixed with "tt__PTZPresetTourState__" to prevent name clashes: use wsdl2h option -e to omit this prefix or use option -c++11 for scoped enumerations
enum tt__PTZPresetTourState
{
	tt__PTZPresetTourState__Idle,	///< xs:string value="Idle"
	tt__PTZPresetTourState__Touring,	///< xs:string value="Touring"
	tt__PTZPresetTourState__Paused,	///< xs:string value="Paused"
	tt__PTZPresetTourState__Extended,	///< xs:string value="Extended"
};

/// @brief "http://www.onvif.org/ver10/schema":PTZPresetTourDirection is a simpleType restriction of type xs:string.
///
/// @note The enum values are prefixed with "tt__PTZPresetTourDirection__" to prevent name clashes: use wsdl2h option -e to omit this prefix or use option -c++11 for scoped enumerations
enum tt__PTZPresetTourDirection
{
	tt__PTZPresetTourDirection__Forward,	///< xs:string value="Forward"
	tt__PTZPresetTourDirection__Backward,	///< xs:string value="Backward"
	tt__PTZPresetTourDirection__Extended,	///< xs:string value="Extended"
};

/// @brief "http://www.onvif.org/ver10/schema":PTZPresetTourOperation is a simpleType restriction of type xs:string.
///
/// @note The enum values are prefixed with "tt__PTZPresetTourOperation__" to prevent name clashes: use wsdl2h option -e to omit this prefix or use option -c++11 for scoped enumerations
enum tt__PTZPresetTourOperation
{
	tt__PTZPresetTourOperation__Start,	///< xs:string value="Start"
	tt__PTZPresetTourOperation__Stop,	///< xs:string value="Stop"
	tt__PTZPresetTourOperation__Pause,	///< xs:string value="Pause"
	tt__PTZPresetTourOperation__Extended,	///< xs:string value="Extended"
};

// Optimization: simpleType "http://www.onvif.org/ver10/schema":MoveAndTrackMethod is not used and was removed

/// @brief "http://www.onvif.org/ver10/schema":AutoFocusMode is a simpleType restriction of type xs:string.
///
/// @note The enum values are prefixed with "tt__AutoFocusMode__" to prevent name clashes: use wsdl2h option -e to omit this prefix or use option -c++11 for scoped enumerations
enum tt__AutoFocusMode
{
	tt__AutoFocusMode__AUTO,	///< xs:string value="AUTO"
	tt__AutoFocusMode__MANUAL,	///< xs:string value="MANUAL"
};

// Optimization: simpleType "http://www.onvif.org/ver10/schema":AFModes is not used and was removed

/// @brief "http://www.onvif.org/ver10/schema":WideDynamicMode is a sim/*
 * This file is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This file is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

#include <AP_OSD/AP_OSD_Backend.h>
#include <AP_HAL/Util.h>
#include <GCS_MAVLink/GCS.h>
#include <ctype.h>

extern const AP_HAL::HAL& hal;
constexpr uint8_t AP_OSD_Backend::symbols[AP_OSD_NUM_SYMBOLS];

#define SYM_DIG_OFS_1 0x90
#define SYM_DIG_OFS_2 0xA0


uint8_t AP_OSD_Backend::convert_to_decimal_packed_characters(char* buff, uint8_t size) {
    if (size == 0) {
        return 0;
    }
#if OSD_ENABLED
    // use packed decimal characters based on fiam idea implemented in inav osd
    // search the decimal separator with a bound and always terminate the string
    char* p = (char*)memchr(&buff[1],'.',size-1);
    if (p && isdigit(p[1]) && isdigit(p[-1])) {
        // remove the decimal separator and replace the digit before and after
        p[-1] += SYM_DIG_OFS_1;
        p[1] += SYM_DIG_OFS_2;
        // shift anything after p[1] 1 character to the left
        const char* move_start = p+1;
        const uint8_t move_size = size-(move_start-buff);
        memmove(p, move_start, move_size);
        p[move_size] = 0x00; // terminate
        return size-1;
    }
#else
    // we guarantee string is terminated
    buff[size-1] = 0x00;
#endif
    return size;
}

uint8_t AP_OSD_Backend::format_string_for_osd(char* buff, uint8_t size, bool decimal_packed, const char *fmt, va_list ap)
{
    if (size == 0) {
        return 0;
    }
#if OSD_ENABLED
    // note: vsnprintf() always terminates the string
    int res = hal.util->vsnprintf(buff, size, fmt, ap);
    res = MIN(res, size);
    if (res > 0 && decimal_packed) {
        // note: convert_to_decimal_packed_characters() always terminates the string
        res = convert_to_decimal_packed_characters(buff, res);
    }
    return res;
#else
    // we guarantee string is terminated
    buff[0] = 0x00;
    // and notify the caller we actually failed
    return 0;
#endif
}

void AP_OSD_Backend::write(uint8_t x, uint8_t y, bool blink, const char *fmt, ...)
{
#if OSD_ENABLED
    if (blink && (blink_phase < 2)) {
        return;
    }
    va_list ap;
    va_start(ap, fmt);
    char buff[32+1]; // +1 for null-termination
    // note: format_string_for_osd() always terminates the string
    IGNORE_RETURN(format_string_for_osd(buff, sizeof(buff), check_option(AP_OSD::OPTION_DECIMAL_PACK), fmt, ap));
    va_end(ap);
    // buff is null terminated, this call should be safe without further checks
    write(x, y, buff);
#endif
}

/*
  load a font from sdcard or ROMFS
 */
FileData *AP_OSD_Backend::load_font_data(uint8_t font_num)
{
    FileData *fd;

    // first try from microSD
    char fontname[] = "font0.bin";
    fontname[4] = font_num + '0';

    fd = AP::FS().load_file(fontname);
    if (fd == nullptr) {
        char fontname_romfs[] = "@ROMFS/font0.bin";
        fontname_romfs[7+4] = font_num + '0';
        fd = AP::FS().load_file(fontname_romfs);
    }
    if (fd == nullptr) {
        GCS_SEND_TEXT(MAV_SEVERITY_ERROR, "OSD: Failed to load font %u", font_num);
        if (font_num != 0) {
            // fallback to font0.bin. This allows us to reduce the
            // number of fonts we include in flash without breaking
            // user setups
            return load_font_data(0);
        }
    }
    return fd;
}

void AP_OSD_Backend::init_symbol_set(uint8_t *lookup_table, const uint8_t size)
{
    memcpy(lookup_table, symbols, size);
}
                                                                                                         /*
 * This file is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This file is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

#pragma once

#include <AP_HAL/HAL.h>
#include <AP_OSD/AP_OSD.h>
#include <AP_Filesystem/AP_Filesystem.h>


class AP_OSD_Backend
{

public:
    //constructor
    AP_OSD_Backend(AP_OSD &osd): _osd(osd) {}

    //destructor
    virtual ~AP_OSD_Backend(void) {}

    //draw given text to framebuffer
    virtual void write(uint8_t x, uint8_t y, const char* text) = 0;

    //draw formatted text to framebuffer
    virtual void write(uint8_t x, uint8_t y, bool blink, const char *fmt, ...) FMT_PRINTF(5, 6);

    //initilize framebuffer and underlying hardware
    virtual bool init() = 0;

    //update screen
    virtual void flush() = 0;

    // return a correction factor used to display angles correctly
    virtual float get_aspect_ratio_correction() const {return 1;}

    //clear screen
    //should match hw blink
    virtual void clear()
    {
        blink_phase = (blink_phase+1)%4;
    }

    // copy the backend specific symbol set to the OSD lookup table
    virtual void init_symbol_set(uint8_t *symbols, const uint8_t size);
    virtual bool is_compatible_with_backend_type(AP_OSD::osd_types type) const = 0;
    virtual AP_OSD::osd_types get_backend_type() const = 0;

    // called by the OSD thread once
    virtual void osd_thread_run_once() { return; }

    AP_OSD * get_osd()
    {
        return &_osd;
    }

protected:
    AP_OSD& _osd;

    // get font choice
    uint8_t get_font_num(void) const
    {
        return (uint8_t)_osd.font_num.get();
    }

    //check option
    bool check_option(uint32_t option) const
    {
        return (_osd.options & option) != 0;
    }

    uint8_t convert_to_decimal_packed_characters(char* buff, uint8_t size);
    virtual uint8_t format_string_for_osd(char* dst, uint8_t size, bool decimal_packed, const char *fmt, va_list ap);

    // load a font from sdcard or ROMFS
    FileData *load_font_data(uint8_t font_num);

    int8_t blink_phase;

    enum vid_format {
        FORMAT_UNKNOWN = 0,
        FORMAT_NTSC = 1,
        FORMAT_PAL = 2,
    } _format;

    // default OSD symbols
    static const uint8_t SYM_M = 0xB9;
    static const uint8_t SYM_KM = 0xBA;
    static const uint8_t SYM_FT = 0x0F;
    static const uint8_t SYM_MI = 0xBB;
    static const uint8_t SYM_ALT_M = 0xB1;
    static const uint8_t SYM_ALT_FT = 0xB3;
    static const uint8_t SYM_BATT_FULL = 0x90;
    static const uint8_t SYM_RSSI = 0x01;

    static const uint8_t SYM_VOLT = 0x06;
    static const uint8_t SYM_AMP = 0x9A;
    static const uint8_t SYM_MAH = 0x07;
    static const uint8_t SYM_MS = 0x9F;
    static const uint8_t SYM_FS = 0x99;
    static const uint8_t SYM_KMH = 0xA1;
    static const uint8_t SYM_MPH = 0xB0;
    static const uint8_t SYM_DEGR = 0xA8;
    static const uint8_t SYM_PCNT = 0x25;
    static const uint8_t SYM_RPM = 0xE0;
    static const uint8_t SYM_ASPD = 0xE1;
    static const uint8_t SYM_GSPD = 0xE2;
    static const uint8_t SYM_WSPD = 0xE3;
    static const uint8_t SYM_VSPD = 0xE4;
    static const uint8_t SYM_WPNO = 0xE5;
    static const uint8_t SYM_WPDIR = 0xE6;
    static const uint8_t SYM_WPDST = 0xE7;
    static const uint8_t SYM_FTMIN = 0xE8;
    static const uint8_t SYM_FTSEC = 0x99;

    static const uint8_t SYM_SAT_L = 0x1E;
    static const uint8_t SYM_SAT_R = 0x1F;
    static const uint8_t SYM_HDOP_L = 0xBD;
    static const uint8_t SYM_HDOP_R = 0xBE;

    static const uint8_t SYM_HOME = 0xBF;
    static const uint8_t SYM_WIND = 0x16;

    static const uint8_t SYM_ARROW_START = 0x60;
    static const uint8_t SYM_ARROW_COUNT = 16;
    static const uint8_t SYM_AH_H_START = 0x80;
    static const uint8_t SYM_AH_H_COUNT = 9;

    static const uint8_t SYM_AH_V_START = 0xCA;
    static const uint8_t SYM_AH_V_COUNT = 6;

    static const uint8_t SYM_AH_CENTER_LINE_LEFT = 0x26;
    static const uint8_t SYM_AH_CENTER_LINE_RIGHT = 0x27;
    static const uint8_t SYM_AH_CENTER = 0x7E;

    static const uint8_t SYM_HEADING_N = 0x18;
    static const uint8_t SYM_HEADING_S = 0x19;
    static const uint8_t SYM_HEADING_E = 0x1A;
    static const uint8_t SYM_HEADING_W = 0x1B;
    static const uint8_t SYM_HEADING_DIVIDED_LINE = 0x1C;
    static const uint8_t SYM_HEADING_LINE = 0x1D;

    static const uint8_t SYM_UP_UP = 0xA2;
    static const uint8_t SYM_UP = 0xA3;
    static const uint8_t SYM_DOWN = 0xA4;
    static const uint8_t SYM_DOWN_DOWN = 0xA5;

    static const uint8_t SYM_DEGREES_C = 0x0E;
    static const uint8_t SYM_DEGREES_F = 0x0D;
    static const uint8_t SYM_GPS_LAT = 0xA6;
    static const uint8_t SYM_GPS_LONG = 0xA7;
    static const uint8_t SYM_ARMED = 0x00;
    static const uint8_t SYM_DISARMED = 0xE9;
    static const uint8_t SYM_ROLL0 = 0x2D;
    static const uint8_t SYM_ROLLR = 0xEA;
    static const uint8_t SYM_ROLLL = 0xEB;
    static const uint8_t SYM_PTCH0 = 0x7C;
    static const uint8_t SYM_PTCHUP = 0xEC;
    static const uint8_t SYM_PTCHDWN = 0xED;
    static const uint8_t SYM_XERR = 0xEE;
    static const uint8_t SYM_KN = 0xF0;
    static const uint8_t SYM_NM = 0xF1;
    static const uint8_t SYM_DIST = 0x22;
    static const uint8_t SYM_FLY = 0x9C;
    static const uint8_t SYM_EFF = 0xF2;
    static const uint8_t SYM_AH = 0xF3;
    static const uint8_t SYM_MW = 0xF4;
    static const uint8_t SYM_CLK = 0xBC;
    static const uint8_t SYM_KILO = 0x4B;
    static const uint8_t SYM_TERALT = 0xEF;
    static const uint8_t SYM_FENCE_ENABLED = 0xF5;
    static const uint8_t SYM_FENCE_DISABLED = 0xF6;
    static const uint8_t SYM_RNGFD = 0xF7;
    static const uint8_t SYM_LQ = 0xF8;
    static const uint8_t SYM_WATT = 0xAE;
    static const uint8_t SYM_WH = 0xAB;
    static const uint8_t SYM_DB = 0xF9;
    static const uint8_t SYM_DBM = 0xFA;
    static const uint8_t SYM_SNR = 0xFB;
    static const uint8_t SYM_ANT = 0xFC;
    static const uint8_t SYM_ARROW_RIGHT = 0xFD;
    static const uint8_t SYM_ARROW_LEFT = 0xFE;
    static const uint8_t SYM_G = 0xDF;
    static const uint8_t SYM_BATT_UNKNOWN = 0x97;
    static const uint8_t SYM_ROLL = 0xA9;
    static const uint8_t SYM_PITCH = 0xAF;
    static const uint8_t SYM_DPS = 0xAA;
    static const uint8_t SYM_HEADING = 0x89;
    static const uint8_t SYM_RADIUS = 0x7A;
    static const uint8_t SYM_FLAP = 0x23;

    static const uint8_t SYM_SIDEBAR_R_ARROW = 0x09;
    static const uint8_t SYM_SIDEBAR_L_ARROW = 0x0A;
    static const uint8_t SYM_SIDEBAR_A = 0x13;
    static const uint8_t SYM_SIDEBAR_B = 0x14;
    static const uint8_t SYM_SIDEBAR_C = 0x15;
    static const uint8_t SYM_SIDEBAR_D = 0xDD;
    static const uint8_t SYM_SIDEBAR_E = 0xDB;
    static const uint8_t SYM_SIDEBAR_F = 0xDC;
    static const uint8_t SYM_SIDEBAR_G = 0xDA;
    static const uint8_t SYM_SIDEBAR_H = 0xDE;
    static const uint8_t SYM_SIDEBAR_I = 0x11;
    static const uint8_t SYM_SIDEBAR_J = 0x12;

    static constexpr uint8_t symbols[AP_OSD_NUM_SYMBOLS] {
        SYM_M,
        SYM_KM,
        SYM_FT,
        SYM_MI,
        SYM_ALT_M,
        SYM_ALT_FT,
        SYM_BATT_FULL,
        SYM_RSSI,
        SYM_VOLT,
        SYM_AMP,
        SYM_MAH,
        SYM_MS,
        SYM_FS,
        SYM_KMH,
        SYM_MPH,
        SYM_DEGR,
        SYM_PCNT,
        SYM_RPM,
        SYM_ASPD,
        SYM_GSPD,
        SYM_WSPD,
        SYM_VSPD,
        SYM_WPNO,
        SYM_WPDIR,
        SYM_WPDST,
        SYM_FTMIN,
        SYM_FTSEC,
        SYM_SAT_L,
        SYM_SAT_R,
        SYM_HDOP_L,
        SYM_HDOP_R,
        SYM_HOME,
        SYM_WIND,
        SYM_ARROW_START,
        SYM_ARROW_COUNT,
        SYM_AH_H_START,
        SYM_AH_H_COUNT,
        SYM_AH_V_START,
        SYM_AH_V_COUNT,
        SYM_AH_CENTER_LINE_LEFT,
        SYM_AH_CENTER_LINE_RIGHT,
        SYM_AH_CENTER,
        SYM_HEADING_N,
        SYM_HEADING_S,
        SYM_HEADING_E,
        SYM_HEADING_W,
        SYM_HEADING_DIVIDED_LINE,
        SYM_HEADING_LINE,
        SYM_UP_UP,
        SYM_UP,
        SYM_DOWN,
        SYM_DOWN_DOWN,
        SYM_DEGREES_C,
        SYM_DEGREES_F,
        SYM_GPS_LAT,
        SYM_GPS_LONG,
        SYM_ARMED,
        SYM_DISARMED,
        SYM_ROLL0,
        SYM_ROLLR,
        SYM_ROLLL,
        SYM_PTCH0,
        SYM_PTCHUP,
        SYM_PTCHDWN,
        SYM_XERR,
        SYM_KN,
        SYM_NM,
        SYM_DIST,
        SYM_FLY,
        SYM_EFF,
        SYM_AH,
        SYM_MW,
        SYM_CLK,
        SYM_KILO,
        SYM_TERALT,
        SYM_FENCE_ENABLED,
        SYM_FENCE_DISABLED,
        SYM_RNGFD,
        SYM_LQ,
        SYM_SIDEBAR_R_ARROW,
        SYM_SIDEBAR_L_ARROW,
        SYM_SIDEBAR_A,
        SYM_SIDEBAR_B,
        SYM_SIDEBAR_C,
        SYM_SIDEBAR_D,
        SYM_SIDEBAR_E,
        SYM_SIDEBAR_F,
        SYM_SIDEBAR_G,
        SYM_SIDEBAR_H,
        SYM_SIDEBAR_I,
        SYM_SIDEBAR_J,
        SYM_WATT,
        SYM_WH,
        SYM_DB,
        SYM_DBM,
        SYM_SNR,
        SYM_ANT,
        SYM_ARROW_RIGHT,
        SYM_ARROW_LEFT,
        SYM_G,
        SYM_BATT_UNKNOWN,
        SYM_ROLL,
        SYM_PITCH,
        SYM_DPS,
        SYM_HEADING,
        SYM_RADIUS,
        SYM_FLAP,
    };
};
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   /*
 * This file is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This file is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * MAX7456 driver partially based on betaflight and inav max7456.c implemention.
 * Many thanks to their authors.
 */

#include <AP_OSD/AP_OSD_MAX7456.h>

#if HAL_WITH_OSD_BITMAP
#include <AP_HAL/Util.h>
#include <AP_HAL/Semaphores.h>
#include <AP_HAL/Scheduler.h>
#include <AP_Filesystem/AP_Filesystem.h>
#include <GCS_MAVLink/GCS.h>

#include <utility>

#define VIDEO_COLUMNS             30
#define NVM_RAM_SIZE              54

//MAX7456 registers
#define MAX7456ADD_READ         0x80
#define MAX7456ADD_VM0          0x00
#define MAX7456ADD_VM1          0x01
#define MAX7456ADD_HOS          0x02
#define MAX7456ADD_VOS          0x03
#define MAX7456ADD_DMM          0x04
#define MAX7456ADD_DMAH         0x05
#define MAX7456ADD_DMAL         0x06
#define MAX7456ADD_DMDI         0x07
#define MAX7456ADD_CMM          0x08
#define MAX7456ADD_CMAH         0x09
#define MAX7456ADD_CMAL         0x0a
#define MAX7456ADD_CMDI         0x0b
#define MAX7456ADD_OSDM         0x0c
#define MAX7456ADD_RB0          0x10
#define MAX7456ADD_OSDBL        0x6c
#define MAX7456ADD_STAT         0xA0
#define MAX7456ADD_CMDO         0xC0

// VM0 register bits
#define VIDEO_BUFFER_DISABLE        0x01
#define MAX7456_RESET               0x02
#define VERTICAL_SYNC_NEXT_VSYNC    0x04
#define OSD_ENABLE                  0x08
#define VIDEO_MODE_PAL              0x40
#define VIDEO_MODE_NTSC             0x00
#define VIDEO_MODE_MASK             0x40

#define VIDEO_MODE_IS_PAL(val)      (((val) & VIDEO_MODE_MASK) == VIDEO_MODE_PAL)
#define VIDEO_MODE_IS_NTSC(val) (((val) & VIDEO_MODE_MASK) == VIDEO_MODE_NTSC)

// VM1 register bits
// duty cycle is on_off
#define BLINK_DUTY_CYCLE_50_50 0x00
#define BLINK_DUTY_CYCLE_33_66 0x01
#define BLINK_DUTY_CYCLE_25_75 0x02
#define BLINK_DUTY_CYCLE_75_25 0x03

// blinking time
#define BLINK_TIME_0 0x00
#define BLINK_TIME_1 0x04
#define BLINK_TIME_2 0x08
#define BLINK_TIME_3 0x0C

// background mode brightness (percent)
#define BACKGROUND_BRIGHTNESS_0  (0x00 << 4)
#define BACKGROUND_BRIGHTNESS_7  (0x01 << 4)
#define BACKGROUND_BRIGHTNESS_14 (0x02 << 4)
#define BACKGROUND_BRIGHTNESS_21 (0x03 << 4)
#define BACKGROUND_BRIGHTNESS_28 (0x04 << 4)
#define BACKGROUND_BRIGHTNESS_35 (0x05 << 4)
#define BACKGROUND_BRIGHTNESS_42 (0x06 << 4)
#define BACKGROUND_BRIGHTNESS_49 (0x07 << 4)

// STAT register bits
#define STAT_PAL      0x01
#define STAT_NTSC     0x02
#define STAT_LOS      0x04
#define STAT_NVR_BUSY 0x20

#define STAT_IS_PAL(val)  ((val) & STAT_PAL)
#define STAT_IS_NTSC(val) ((val) & STAT_NTSC)
#define STAT_IS_LOS(val)  ((val) & STAT_LOS)

#define VIN_IS_PAL(val)  (!STAT_IS_LOS(val) && STAT_IS_PAL(val))
#define VIN_IS_NTSC(val)  (!STAT_IS_LOS(val) && STAT_IS_NTSC(val))

// There are occasions that NTSC is not detected even with !LOS (AB7456 specific?)
// When this happens, lower 3 bits of STAT register is read as zero.
// To cope with this case, this macro defines !LOS && !PAL as NTSC.
// Should be compatible with MAX7456 and non-problematic case.
#define VIN_IS_NTSC_ALT(val)  (!STAT_IS_LOS(val) && !STAT_IS_PAL(val))

//CMM register bits
#define WRITE_NVR               0xA0
#define READ_NVR                0x50

// DMM special bits
#define DMM_BLINK (1 << 4)
#define DMM_INVERT_PIXEL_COLOR (1 << 3)
#define DMM_CLEAR_DISPLAY (1 << 2)
#define DMM_CLEAR_DISPLAY_VERT (DMM_CLEAR_DISPLAY | 1 << 1)
#define DMM_AUTOINCREMENT (1 << 0)

// time to check video signal format
#define VIDEO_SIGNAL_CHECK_INTERVAL_MS 1000
//time to wait for input to stabilize
#define VIDEO_SIGNAL_DEBOUNCE_MS 100
//time to wait nvm flash complete
#define MAX_NVM_WAIT 10000

//black and white level
#ifndef WHITEBRIGHTNESS
#define WHITEBRIGHTNESS 0x01
#endif
#ifndef BLACKBRIGHTNESS
#define BLACKBRIGHTNESS 0x00
#endif
#define BWBRIGHTNESS ((BLACKBRIGHTNESS << 2) | WHITEBRIGHTNESS)

extern const AP_HAL::HAL &hal;

AP_OSD_MAX7456::AP_OSD_MAX7456(AP_OSD &osd, AP_HAL::OwnPtr<AP_HAL::Device> dev):
    AP_OSD_Backend(osd), _dev(std::move(dev))
{
    video_signal_reg = VIDEO_MODE_PAL | OSD_ENABLE;
    video_lines = video_lines_pal;
}

bool AP_OSD_MAX7456::init()
{
    uint8_t status = 0xFF;

    _dev->get_semaphore()->take_blocking();
    _dev->write_register(MAX7456ADD_VM0, MAX7456_RESET);
    hal.scheduler->delay(1);
    _dev->read_registers(MAX7456ADD_VM0|MAX7456ADD_READ, &status, 1);
    _dev->get_semaphore()->give();
    if (status != 0) {
        return false;
    }
    return update_font();
}

bool AP_OSD_MAX7456::update_font()
{
    uint8_t updated_chars = 0;
    last_font = get_font_num();
    FileData *fd = load_font_data(last_font);

    if (fd == nullptr) {
        return false;
    }

    const uint8_t *font_data = fd->data;
    uint32_t font_size = fd->length;
    if (font_size != NVM_RAM_SIZE * 256) {
        GCS_SEND_TEXT(MAV_SEVERITY_ERROR, "AP_OSD: bad font size %u\n", unsigned(font_size));
        delete fd;
        return false;
    }

    for (uint16_t chr=0; chr < 256; chr++) {
        const uint8_t* chr_font_data = font_data + chr*NVM_RAM_SIZE;
        //check if char already up to date
        if (!check_font_char(chr, chr_font_data)) {
            //update char inside max7456 NVM
            if (!update_font_char(chr, chr_font_data)) {
                delete fd;
                return false;
            }
            updated_chars++;
        }
    }
    delete fd;
    return true;
}

//compare char chr inside MAX7456 NVM with font_data
bool AP_OSD_MAX7456::check_font_char(uint8_t chr, const uint8_t* font_data)
{
    buffer_offset = 0;
    //send request to read data from NVM
    buffer_add_cmd(MAX7456ADD_VM0, 0);
    buffer_add_cmd(MAX7456ADD_CMAH, chr);
    buffer_add_cmd(MAX7456ADD_CMM, READ_NVR);
    for (uint16_t x = 0; x < NVM_RAM_SIZE; x++) {
        buffer_add_cmd(MAX7456ADD_CMAL, x);
        buffer_add_cmd(MAX7456ADD_CMDO, 0xFF);
    }
    _dev->get_semaphore()->take_blocking();
    _dev->transfer(buffer, buffer_offset, buffer, buffer_offset);
    _dev->get_semaphore()->give();

    //skip response from MAX7456ADD_VM0/MAX7456ADD_CMAH...
    buffer_offset = 9;
    for (uint16_t x = 0; x < NVM_RAM_SIZE; x++) {
        if (buffer[buffer_offset] != font_data[x]) {
            return false;
        }
        //one byte per MAX7456ADD_CMAL/MAX7456ADD_CMDO pair
        buffer_offset += 4;
    }
    return true;
}

bool AP_OSD_MAX7456::update_font_char(uint8_t chr, const uint8_t* font_data)
{
    uint16_t retry;
    buffer_offset = 0;
    buffer_add_cmd(MAX7456ADD_VM0, 0);
    buffer_add_cmd(MAX7456ADD_CMAH, chr);
    for (uint16_t x = 0; x < NVM_RAM_SIZE; x++) {
        buffer_add_cmd(MAX7456ADD_CMAL, x);
        buffer_add_cmd(MAX7456ADD_CMDI, font_data[x]);
    }
    buffer_add_cmd(MAX7456ADD_CMM, WRITE_NVR);

    _dev->get_semaphore()->take_blocking();
    _dev->transfer(buffer, buffer_offset, nullptr, 0);
    _dev->get_semaphore()->give();

    for (retry = 0; retry < MAX_NVM_WAIT; retry++) {
        uint8_t status = 0xFF;
        hal.scheduler->delay(15);
        _dev->get_semaphore()->take_blocking();
        _dev->read_registers(MAX7456ADD_STAT, &status, 1);
        _dev->get_semaphore()->give();
        if ((status & STAT_NVR_BUSY) == 0x00) {
            break;
        }
    }
    return retry != MAX_NVM_WAIT;
}

AP_OSD_Backend *AP_OSD_MAX7456::probe(AP_OSD &osd, AP_HAL::OwnPtr<AP_HAL::Device> dev)
{
    if (!dev) {
        return nullptr;
    }

    AP_OSD_MAX7456 *backend = NEW_NOTHROW AP_OSD_MAX7456(osd, std::move(dev));
    if (!backend) {
        return nullptr;
    }
    if (!backend->init()) {
        delete backend;
        return nullptr;
    }
    return backend;
}

void AP_OSD_MAX7456::buffer_add_cmd(uint8_t reg, uint8_t arg)
{
    if (buffer_offset < spi_buffer_size - 1) {
        buffer[buffer_offset++] = reg;
        buffer[buffer_offset++] = arg;
    }
}

//Thanks to betaflight for the max stall/reboot detection approach and ntsc/pal autodetection
void AP_OSD_MAX7456::check_reinit()
{
    uint8_t check = 0xFF;
    _dev->get_semaphore()->take_blocking();

    _dev->read_registers(MAX7456ADD_VM0|MAX7456ADD_READ, &check, 1);

    uint32_t now = AP_HAL::millis();

    // Stall check
    if (check != video_signal_reg) {
        reinit();
    } else if ((now - last_signal_check) > VIDEO_SIGNAL_CHECK_INTERVAL_MS) {
        uint8_t sense;

        // Adjust output format based on the current input format
        _dev->read_registers(MAX7456ADD_STAT, &sense, 1);

        if (sense & STAT_LOS) {
            video_detect_time = 0;
        } else {
            if ((VIN_IS_PAL(sense) && VIDEO_MODE_IS_NTSC(video_signal_reg))
                || (VIN_IS_NTSC_ALT(sense) && VIDEO_MODE_IS_PAL(video_signal_reg))) {
                if (video_detect_time) {
                    if (AP_HAL::millis() - video_detect_time > VIDEO_SIGNAL_DEBOUNCE_MS) {
                        reinit();
                    }
                } else {
                    // Wait for signal to stabilize
                    video_detect_time = AP_HAL::millis();
                }
            }
        }
        last_signal_check = now;
    }
    _dev->get_semaphore()->give();
}

void AP_OSD_MAX7456::reinit()
{
    uint8_t sense;

    //do not init MAX before camera power up correctly
    if (AP_HAL::millis() < 1500) {
        return;
    }

    //check input signal format
    _dev->read_registers(MAX7456ADD_STAT, &sense, 1);
    if (VIN_IS_PAL(sense)) {
        video_signal_reg = VIDEO_MODE_PAL | OSD_ENABLE;
        video_lines = video_lines_pal;
        _format = FORMAT_PAL;
    } else {
        video_signal_reg = VIDEO_MODE_NTSC | OSD_ENABLE;
        video_lines = video_lines_ntsc;
        _format = FORMAT_NTSC;
    }

    // set all rows to same character black/white level
    for (uint8_t x = 0; x < video_lines_pal; x++) {
        _dev->write_register(MAX7456ADD_RB0 + x, BWBRIGHTNESS);
    }

    // make sure the Max7456 is enabled
    _dev->write_register(MAX7456ADD_VM0, video_signal_reg);
    _dev->write_register(MAX7456ADD_VM1, BLINK_DUTY_CYCLE_50_50 | BLINK_TIME_3 | BACKGROUND_BRIGHTNESS_28);
    _dev->write_register(MAX7456ADD_DMM, DMM_CLEAR_DISPLAY);

    //write osd position
    int8_t hos = constrain_int16(_osd.h_offset, 0, 63);
    int8_t vos = constrain_int16(_osd.v_offset, 0, 31);
    _dev->write_register(MAX7456ADD_HOS, hos);
    _dev->write_register(MAX7456ADD_VOS, vos);
    last_v_offset = _osd.v_offset;
    last_h_offset = _osd.h_offset;

    // force redrawing all screen
    memset(shadow_frame, 0xFF, sizeof(shadow_frame));

    initialized = true;
}

void AP_OSD_MAX7456::flush()
{
    if (last_font != get_font_num()) {
        update_font();
    }

    // check for offset changes
    if (last_v_offset != _osd.v_offset) {
        int8_t vos = constrain_int16(_osd.v_offset, 0, 31);
        _dev->get_semaphore()->take_blocking();
        _dev->write_register(MAX7456ADD_VOS, vos);
        _dev->get_semaphore()->give();
        last_v_offset = _osd.v_offset;
    }
    if (last_h_offset != _osd.h_offset) {
        int8_t hos = constrain_int16(_osd.h_offset, 0, 63);
        _dev->get_semaphore()->take_blocking();
        _dev->write_register(MAX7456ADD_HOS, hos);
        _dev->get_semaphore()->give();
        last_h_offset = _osd.h_offset;
    }

    check_reinit();
    transfer_frame();
}

void AP_OSD_MAX7456::transfer_frame()
{
    uint16_t previous_pos = UINT16_MAX - 1;
    bool autoincrement = false;
    if (!initialized) {
        return;
    }

    buffer_offset = 0;
    for (uint8_t y=0; y<video_lines; y++) {
        for (uint8_t x=0; x<video_columns; x++) {
            if (!is_dirty(x, y)) {
                continue;
            }
            //ensure space for 1 char and escape sequence
            if (buffer_offset >= spi_buffer_size - 32) {
                break;
            }
            shadow_frame[y][x] = frame[y][x];
            uint8_t chr = frame[y][x];
            uint16_t pos = y * video_columns + x;
            bool position_changed = ((previous_pos + 1) != pos);

            if (position_changed && autoincrement) {
                //it is impossible to write to MAX7456ADD_DMAH/MAX7456ADD_DMAL in autoincrement mode
                //so, exit autoincrement mode
                buffer_add_cmd(MAX7456ADD_DMDI, 0xFF);
                buffer_add_cmd(MAX7456ADD_DMM, 0);
                autoincrement = false;
            }

            if (!autoincrement) {
                buffer_add_cmd(MAX7456ADD_DMAH, pos >> 8);
                buffer_add_cmd(MAX7456ADD_DMAL, pos & 0xFF);
            }

            if (!autoincrement && is_dirty(x+1, y)) {
                //(re)enter autoincrement mode
                buffer_add_cmd(MAX7456ADD_DMM, DMM_AUTOINCREMENT);
                autoincrement = true;
            }

            buffer_add_cmd(MAX7456ADD_DMDI, chr);
            previous_pos = pos;
        }
    }
    if (autoincrement) {
        buffer_add_cmd(MAX7456ADD_DMDI, 0xFF);
        buffer_add_cmd(MAX7456ADD_DMM, 0);
        autoincrement = false;
    }

    if (buffer_offset > 0) {
        _dev->get_semaphore()->take_blocking();
        _dev->transfer(buffer, buffer_offset, nullptr, 0);
        _dev->get_semaphore()->give();
    }
}

bool AP_OSD_MAX7456::is_dirty(uint8_t x, uint8_t y)
{
    if (y>=video_lines || x>=video_columns) {
        return false;
    }
    return frame[y][x] != shadow_frame[y][x];
}

void AP_OSD_MAX7456::clear()
{
    AP_OSD_Backend::clear();
    memset(frame, ' ', sizeof(frame));
}

void AP_OSD_MAX7456::write(uint8_t x, uint8_t y, const char* text)
{
    if (y >= video_lines_pal || text == nullptr) {
        return;
    }
    while ((x < VIDEO_COLUMNS) && (*text != 0)) {
        frame[y][x] = *text;
        ++text;
        ++x;
    }
}

// return a correction factor used to display angles correctly
float AP_OSD_MAX7456::get_aspect_ratio_correction() const
{
    switch (_format) {
    case FORMAT_NTSC:
        return 12.0f/18.46f;

    case FORMAT_PAL:
        return 12.0f/15.0f;

    default:
        return 1.0f;
    };
}
#endif // HAL_WITH_OSD_BITMAP
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 /*
 * This file is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This file is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
#pragma once

#include <AP_OSD/AP_OSD_Backend.h>
#include <AP_Common/Bitmask.h>

#if HAL_WITH_OSD_BITMAP
class AP_OSD_MAX7456 : public AP_OSD_Backend
{

public:

    static AP_OSD_Backend *probe(AP_OSD &osd, AP_HAL::OwnPtr<AP_HAL::Device> dev);

    //draw given text to framebuffer
    void write(uint8_t x, uint8_t y, const char* text) override;

    //initilize display port and underlying hardware
    bool init() override;

    //flush framebuffer to screen
    void flush() override;

    //clear framebuffer
    void clear() override;

    // return a correction factor used to display angles correctly
    float get_aspect_ratio_correction() const override;

    bool is_compatible_with_backend_type(AP_OSD::osd_types type) const override {
        switch(type) {
        case AP_OSD::osd_types::OSD_MAX7456:
        case AP_OSD::osd_types::OSD_SITL:
            return false;
        case AP_OSD::osd_types::OSD_NONE:
        case AP_OSD::osd_types::OSD_TXONLY:
        case AP_OSD::osd_types::OSD_MSP:
        case AP_OSD::osd_types::OSD_MSP_DISPLAYPORT:
            return true;
        }
        return false;
    }

    AP_OSD::osd_types get_backend_type() const override {
        return AP_OSD::osd_types::OSD_MAX7456;
    }

private:

    //constructor
    AP_OSD_MAX7456(AP_OSD &osd, AP_HAL::OwnPtr<AP_HAL::Device> dev);

    void buffer_add_cmd(uint8_t reg, uint8_t arg);

    bool update_font();

    bool check_font_char(uint8_t chr, const uint8_t* font_data);

    bool update_font_char(uint8_t chr, const uint8_t* font_data);

    void check_reinit();

    void reinit();

    void transfer_frame();

    bool is_dirty(uint8_t x, uint8_t y);

    AP_HAL::OwnPtr<AP_HAL::Device> _dev;

    uint8_t  video_signal_reg;
    bool initialized;
    uint8_t last_font;
    int8_t last_v_offset;
    int8_t last_h_offset;

    static const uint8_t video_lines_ntsc = 13;
    static const uint8_t video_lines_pal = 16;
    static const uint8_t video_columns = 30;
    static const uint16_t spi_buffer_size = 512;

    uint8_t frame[video_lines_pal][video_columns];

    //frame already transfered to max
    //used to optimize number of characters updated
    uint8_t shadow_frame[video_lines_pal][video_columns];

    uint8_t buffer[spi_buffer_size];
    int buffer_offset;

    uint32_t last_signal_check;
    uint32_t video_detect_time;

    uint16_t video_lines;
};
#endif // HAL_WITH_OSD_BITMAP
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           /*
 * This file is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This file is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
/*
  OSD backend for MSP
 */
#include "AP_OSD_MSP.h"


static const struct AP_Param::defaults_table_struct defaults_table[] = {
    /*
    //OSD_RSSI_VALUE
    { "OSD_RSSI_EN",       1.0 },
    { "OSD_RSSI_X",        1.0 },
    { "OSD_RSSI_Y",        1.0 },

    //OSD_MAIN_BATT_VOLTAGE
    { "OSD_BAT_VOLT_EN",       1.0 },
    { "OSD_BAT_VOLT_X",        1.0 },
    { "OSD_BAT_VOLT_Y",        1.0 },

    //OSD_CRAFT_NAME (text flightmode + status text messages + wind)
    { "OSD_MESSAGE_EN",       1.0 },
    { "OSD_MESSAGE_X",        1.0 },
    { "OSD_MESSAGE_Y",        1.0 },

    //OSD_FLYMODE (displays failsafe status and optionally rtl engaged)
    { "OSD_FLTMODE_EN",       1.0 },
    { "OSD_FLTMODE_X",        1.0 },
    { "OSD_FLTMODE_Y",        1.0 },

    //OSD_CURRENT_DRAW
    { "OSD_CURRENT_EN",       1.0 },
    { "OSD_CURRENT_X",        1.0 },
    { "OSD_CURRENT_Y",        1.0 },

    //OSD_MAH_DRAWN
    { "OSD_BATUSED_EN",       1.0 },
    { "OSD_BATUSED_X",        1.0 },
    { "OSD_BATUSED_Y",        1.0 },

    //OSD_GPS_SPEED
    { "OSD_GSPEED_EN",       1.0 },
    { "OSD_GSPEED_X",        1.0 },
    { "OSD_GSPEED_Y",        1.0 },

    //OSD_GPS_SATS
    { "OSD_SATS_EN",       1.0 },
    { "OSD_SATS_X",        1.0 },
    { "OSD_SATS_Y",        1.0 },

    //OSD_ALTITUDE
    { "OSD_ALTITUDE_EN",       1.0 },
    { "OSD_ALTITUDE_X",        1.0 },
    { "OSD_ALTITUDE_Y",        1.0 },

    //OSD_GPS_LON
    { "OSD_GPSLONG_EN",       1.0 },
    { "OSD_GPSLONG_X",        1.0 },
    { "OSD_GPSLONG_Y",        1.0 },

    //OSD_GPS_LAT
    { "OSD_GPSLAT_EN",       1.0 },
    { "OSD_GPSLAT_X",        1.0 },
    { "OSD_GPSLAT_Y",        1.0 },

    //OSD_PITCH_ANGLE
    { "OSD_PITCH_EN",       1.0 },
    { "OSD_PITCH_X",        1.0 },
    { "OSD_PITCH_Y",        1.0 },

    //OSD_ROLL_ANGLE
    { "OSD_ROLL_EN",       1.0 },
    { "OSD_ROLL_X",        1.0 },
    { "OSD_ROLL_Y",        1.0 },

    //OSD_MAIN_BATT_USAGE
    { "OSD_BATTBAR_EN",       1.0 },
    { "OSD_BATTBAR_X",        1.0 },
    { "OSD_BATTBAR_Y",        1.0 },

    //OSD_NUMERICAL_VARIO
    { "OSD_VSPEED_EN",       1.0 },
    { "OSD_VSPEED_X",        1.0 },
    { "OSD_VSPEED_Y",        1.0 },

#if HAVE_AP_BLHELI_SUPPORT
    //OSD_ESC_TMP
    { "OSD_BLHTEMP_EN",       1.0 },
    { "OSD_BLHTEMP_X",        1.0 },
    { "OSD_BLHTEMP_Y",        1.0 },
#endif

    //OSD_RTC_DATETIME
    { "OSD_CLK_EN",       1.0 },
    { "OSD_CLK_X",        1.0 },
    { "OSD_CLK_Y",        1.0 },

    // --------------------------
    // MSP OSD only
    // --------------------------

    // OSD items disabled by default (partially supported)
    //OSD_CROSSHAIRS
    { "OSD_CRSSHAIR_EN",       0 },

    //OSD_ARTIFICIAL_HORIZON
    { "OSD_HORIZON_EN",        0 },

    //OSD_HORIZON_SIDEBARS
    { "OSD_SIDEBARS_EN",       0 },

    //OSD_NUMERICAL_HEADING
    { "OSD_HEADING_EN",       0.0 },

    // Supported OSD items

    //OSD_POWER
    { "OSD_POWER_EN",       1.0 },
    { "OSD_POWER_X",        1.0 },
    { "OSD_POWER_Y",        1.0 },

    //OSD_AVG_CELL_VOLTAGE
    { "OSD_CELLVOLT_EN",       1.0 },
    { "OSD_CELLVOLT_X",        1.0 },
    { "OSD_CELLVOLT_Y",        1.0 },

    //OSD_DISARMED
    { "OSD_ARMING_EN",       1.0 },
    { "OSD_ARMING_X",        1.0 },
    { "OSD_ARMING_Y",        1.0 },

    //OSD_HOME_DIR
    { "OSD_HOMEDIR_EN",       1.0 },
    { "OSD_HOMEDIR_X",        1.0 },
    { "OSD_HOMEDIR_Y",        1.0 },

    //OSD_HOME_DIST
    { "OSD_HOMEDIST_EN",       1.0 },
    { "OSD_HOMEDIST_X",        1.0 },
    { "OSD_HOMEDIST_Y",        1.0 },
    */
};


extern const AP_HAL::HAL &hal;

// initialise backend
bool AP_OSD_MSP::init(void)
{
    return true;
}

// override built in positions with defaults for MSP OSD
void AP_OSD_MSP::setup_defaults(void)
{
    AP_Param::set_defaults_from_table(defaults_table, ARRAY_SIZE(defaults_table));
}

AP_OSD_Backend *AP_OSD_MSP::probe(AP_OSD &osd)
{
    AP_OSD_MSP *backend = NEW_NOTHROW AP_OSD_MSP(osd);
    if (!backend) {
        return nullptr;
    }
    if (!backend->init()) {
        delete backend;
        return nullptr;
    }
    return backend;
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   #include <AP_OSD/AP_OSD_Backend.h>
#include <AP_MSP/AP_MSP.h>

class AP_OSD_MSP : public AP_OSD_Backend
{
    using AP_OSD_Backend::AP_OSD_Backend;
public:
    static AP_OSD_Backend *probe(AP_OSD &osd);

    //initilize display port and underlying hardware
    bool init() override;

    //draw given text to framebuffer
    void write(uint8_t x, uint8_t y, const char* text) override {};

    //flush framebuffer to screen
    void flush() override {};

    //clear framebuffer
    void clear() override {};

    bool is_compatible_with_backend_type(AP_OSD::osd_types type) const override {
        switch(type) {
        case AP_OSD::osd_types::OSD_MSP:
        case AP_OSD::osd_types::OSD_MSP_DISPLAYPORT:
            return false;
        case AP_OSD::osd_types::OSD_NONE:
        case AP_OSD::osd_types::OSD_TXONLY:
        case AP_OSD::osd_types::OSD_MAX7456:
        case AP_OSD::osd_types::OSD_SITL:
            return true;
        }
        return false;
    }

    AP_OSD::osd_types get_backend_type() const override {
        return AP_OSD::osd_types::OSD_MSP;
    }
private:
    void setup_defaults(void);
};
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              /*
 * This file is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This file is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
/*
  OSD backend for MSP
 */
#include <AP_MSP/AP_MSP.h>
#include <AP_MSP/msp.h>
#include "AP_OSD_MSP_DisplayPort.h"

#if HAL_WITH_MSP_DISPLAYPORT

#include <GCS_MAVLink/GCS.h>

static const struct AP_Param::defaults_table_struct defaults_table[] = {
    /*
    { "PARAM_NAME",       value_float }
    */
};

extern const AP_HAL::HAL &hal;
constexpr uint8_t AP_OSD_MSP_DisplayPort::symbols[AP_OSD_NUM_SYMBOLS];

// initialise backend
bool AP_OSD_MSP_DisplayPort::init(void)
{
    // check if we have a DisplayPort backend to use
    const AP_MSP *msp = AP::msp();
    if (msp == nullptr) {
        GCS_SEND_TEXT(MAV_SEVERITY_WARNING,"MSP backend not available");
        return false;
    }
    _displayport = msp->find_protocol(AP_SerialManager::SerialProtocol_MSP_DisplayPort);
    if (_displayport == nullptr) {
        GCS_SEND_TEXT(MAV_SEVERITY_WARNING,"MSP DisplayPort uart not available");
        return false;
    }
    // re-init port here for use in this thread
    _displayport->init_uart();
    return true;
}

// called by the OSD thread once
void AP_OSD_MSP_DisplayPort::osd_thread_run_once()
{
    if (_displayport != nullptr) {
        _displayport->init_uart();
    }
}

void AP_OSD_MSP_DisplayPort::clear(void)
{
    // check if we need to enable some options
    // but only for actual OSD screens
    if (_osd.get_current_screen() < AP_OSD_NUM_DISPLAY_SCREENS) {
        const uint8_t txt_resolution = _osd.screen[_osd.get_current_screen()].get_txt_resolution();
        const uint8_t font_index = _osd.screen[_osd.get_current_screen()].get_font_index();
        _displayport->msp_displayport_set_options(font_index, txt_resolution);
    }

    // clear remote MSP screen
    _displayport->msp_displayport_clear_screen();

    // toggle flashing @1Hz
    const uint32_t now = AP_HAL::millis();
    if ((uint32_t(now * 0.004) & 0x01) != _blink_on) {
        _blink_on = !_blink_on;
        blink_phase = (blink_phase+1)%4;
    }
}

void AP_OSD_MSP_DisplayPort::write(uint8_t x, uint8_t y, const char* text)
{
    _displayport->msp_displayport_write_string(x, y, 0, text);
}

uint8_t AP_OSD_MSP_DisplayPort::format_string_for_osd(char* buff, uint8_t size, bool decimal_packed, const char *fmt, va_list ap)
{
    const AP_MSP *msp = AP::msp();
    const bool pack =  decimal_packed && msp && !msp->is_option_enabled(AP_MSP::Option::DISPLAYPORT_BTFL_SYMBOLS);
    return AP_OSD_Backend::format_string_for_osd(buff, size, pack, fmt, ap);
}

void AP_OSD_MSP_DisplayPort::flush(void)
{
    // grab the screen and force a redraw
    _displayport->msp_displayport_grab();
    _displayport->msp_displayport_draw_screen();

    // ok done processing displayport data
    // let's process incoming MSP frames (and reply if needed)
    _displayport->process_incoming_data();
}

void AP_OSD_MSP_DisplayPort::init_symbol_set(uint8_t *lookup_table, const uint8_t size)
{
    const AP_MSP *msp = AP::msp();
    // do we use backend specific symbols table?
    if (msp && msp->is_option_enabled(AP_MSP::Option::DISPLAYPORT_BTFL_SYMBOLS)) {
        memcpy(lookup_table, symbols, size);
    } else {
        memcpy(lookup_table, AP_OSD_Backend::symbols, size);
    }
}

// override built in positions with defaults for MSP OSD
void AP_OSD_MSP_DisplayPort::setup_defaults(void)
{
    AP_Param::set_defaults_from_table(defaults_table, ARRAY_SIZE(defaults_table));
}

AP_OSD_Backend *AP_OSD_MSP_DisplayPort::probe(AP_OSD &osd)
{
    AP_OSD_MSP_DisplayPort *backend = NEW_NOTHROW AP_OSD_MSP_DisplayPort(osd);
    if (!backend) {
        return nullptr;
    }
    if (!backend->init()) {
        delete backend;
        return nullptr;
    }
    return backend;
}
 
// return a correction factor used to display angles correctly
float AP_OSD_MSP_DisplayPort::get_aspect_ratio_correction() const
{
    return 12.0/18.0;
}


#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      nnel::AuxSwitchPos yaw = get_channel_pos(AP::rcmap()->yaw());
    const RC_Channel::AuxSwitchPos roll = get_channel_pos(AP::rcmap()->roll());
    const RC_Channel::AuxSwitchPos pitch = get_channel_pos(AP::rcmap()->pitch());

    Event result = Event::NONE;

    if (yaw != RC_Channel::AuxSwitchPos::MIDDLE || throttle != RC_Channel::AuxSwitchPos::LOW) {
        return result;
    }

    if (pitch == RC_Channel::AuxSwitchPos::MIDDLE && roll == RC_Channel::AuxSwitchPos::LOW) {
        result = Event::MENU_EXIT;
    } else if (pitch == RC_Channel::AuxSwitchPos::MIDDLE && roll == RC_Channel::AuxSwitchPos::HIGH) {
        result = Event::MENU_ENTER;
    } else if (pitch == RC_Channel::AuxSwitchPos::LOW && roll == RC_Channel::AuxSwitchPos::MIDDLE) {
        result = Event::MENU_UP;
    } else if (pitch == RC_Channel::AuxSwitchPos::HIGH && roll == RC_Channel::AuxSwitchPos::MIDDLE) {
        result = Event::MENU_DOWN;
    } else {
        // OSD option has not changed so assume stick re-centering
        result = Event::NONE;
    }
    return result;
}

// update the state machine when disarmed
void AP_OSD_ParamScreen::update_state_machine()
{
    const uint32_t now = AP_HAL::millis();
    if ((now - _transition_start_ms) < _transition_timeout_ms) {
        return;
    }

    const Event ev = map_rc_input_to_event();
    // only take action on transitions
    if (ev == Event::NONE && ev == _last_rc_event) {
        return;
    }

    debug("update_state_machine(%s)\n", event_names[int(ev)]);

    _transition_start_ms = now;
    if (ev == _last_rc_event) {
        _transition_timeout_ms = OSD_HOLD_BUTTON_PRESS_DELAY;
        _transition_count++;
    } else {
        _transition_timeout_ms = osd->button_delay_ms;
        _transition_count = 0;
    }
    _last_rc_event = ev;

    // if we were armed then there is no selected parameter - so find one
    if (_selected_param == 0) {
        _selected_param = 1;
        for (uint8_t i = 0; i < NUM_PARAMS && !params[_selected_param-1].enabled; i++) {
            _selected_param++;
        }
    }

    switch (ev) {
    case Event::MENU_ENTER:
        switch(_menu_state) {
        case MenuState::PARAM_SELECT:
            if (_selected_param == SAVE_PARAM) {
                if (_transition_count >= OSD_HOLD_BUTTON_PRESS_COUNT) {
                    save_parameters();
                    hal.scheduler->reboot();
                } else {
                    save_parameters();
                }
            } else {
                _menu_state = MenuState::PARAM_VALUE_MODIFY;
            }
            break;
        case MenuState::PARAM_VALUE_MODIFY:
            if (_transition_count >= OSD_HOLD_BUTTON_PRESS_COUNT) {
                _menu_state = MenuState::PARAM_PARAM_MODIFY;
            }
            break;
        case MenuState::PARAM_PARAM_MODIFY:
            break;
        }
        break;
    case Event::MENU_UP:
        switch (_menu_state) {
        case MenuState::PARAM_SELECT:
            _selected_param--;
            if (_selected_param < 1) {
                _selected_param = SAVE_PARAM;
            }
            // skip over parameters that are not enabled
            for (uint8_t i = 0; i < NUM_PARAMS + 1 && (_selected_param != SAVE_PARAM && !params[_selected_param-1].enabled); i++) {
                _selected_param--;
                if (_selected_param < 1) {
                    _selected_param = SAVE_PARAM;
                }
            }
            // repeat at the standard rate
            _transition_timeout_ms = osd->button_delay_ms;
            break;
        case MenuState::PARAM_VALUE_MODIFY:
            modify_parameter(_selected_param, ev);
            break;
        case MenuState::PARAM_PARAM_MODIFY:
            modify_configured_parameter(_selected_param, ev);
            break;
        }
        break;
    case Event::MENU_DOWN:
        switch (_menu_state) {
        case MenuState::PARAM_SELECT:
            _selected_param++;
            if (_selected_param > SAVE_PARAM) {
                _selected_param = 1;
            }
            // skip over parameters that are not enabled
            for (uint8_t i = 0; i < NUM_PARAMS + 1 && (_selected_param != SAVE_PARAM && !params[_selected_param-1].enabled); i++) {
                _selected_param++;
                if (_selected_param > SAVE_PARAM) {
                    _selected_param = 1;
                }
            }
            // repeat at the standard rate
            _transition_timeout_ms = osd->button_delay_ms;
            break;
        case MenuState::PARAM_VALUE_MODIFY:
            modify_parameter(_selected_param, ev);
            break;
        case MenuState::PARAM_PARAM_MODIFY:
            modify_configured_parameter(_selected_param, ev);
            break;
        }
        break;
    case Event::MENU_EXIT:
        switch(_menu_state) {
        case MenuState::PARAM_SELECT:
            break;
        case MenuState::PARAM_VALUE_MODIFY:
            _menu_state = MenuState::PARAM_SELECT;
            break;
        case MenuState::PARAM_PARAM_MODIFY:
            _menu_state = MenuState::PARAM_VALUE_MODIFY;
            break;
        }
        break;
    case Event::NONE:
        break;
    }
}

#if HAL_WITH_OSD_BITMAP || HAL_WITH_MSP_DISPLAYPORT
void AP_OSD_ParamScreen::draw(void)
{
    if (!enabled || !backend) {
        return;
    }

    // first update the state machine
    if (!AP::arming().is_armed()) {
        update_state_machine();
    } else {
        _selected_param = 0;
    }

    for (uint8_t i = 0; i < NUM_PARAMS; i++) {
        AP_OSD_ParamSetting n = params[i];
        if (n.enabled) {
            draw_parameter(n._param_number, n.xpos, n.ypos);
        }
    }
    // the save button
    draw_parameter(SAVE_PARAM, save_x, save_y);
}
#endif

#endif // OSD_ENABLED

// save all of the parameters
void AP_OSD_ParamScreen::save_parameters()
{
    if (!_requires_save) {
        return;
    }

    for (uint8_t i = 0; i < NUM_PARAMS; i++) {
        if (params[i].enabled && (_requires_save & (1 << i))) {
            AP_Param* p = params[i]._param;
            if (p != nullptr) {
                p->save();
            }
            params[i].save_as_new();
        }
    }
    _requires_save = 0;
}

// handle OSD configuration messages
#if HAL_GCS_ENABLED
void AP_OSD_ParamScreen::handle_write_msg(const mavlink_osd_param_config_t& packet, const class GCS_MAVLINK& link)
{
    // request out of range - return an error
    if (packet.osd_index < 1 || packet.osd_index > AP_OSD_ParamScreen::NUM_PARAMS) {
        mavlink_msg_osd_param_config_reply_send(link.get_chan(), packet.request_id, OSD_PARAM_INVALID_PARAMETER_INDEX);
        return;
    }
    // set the parameter
    bool ret = params[packet.osd_index - 1].set_by_name(packet.param_id, packet.config_type, packet.min_value, packet.max_value, packet.increment);
    mavlink_msg_osd_param_config_reply_send(link.get_chan(), packet.request_id, ret ? OSD_PARAM_SUCCESS : OSD_PARAM_INVALID_PARAMETER);
}

// handle OSD show configuration messages
void AP_OSD_ParamScreen::handle_read_msg(const mavlink_osd_param_show_config_t& packet, const class GCS_MAVLINK& link)
{
    // request out of range - return an error
    if (packet.osd_index < 1 || packet.osd_index > AP_OSD_ParamScreen::NUM_PARAMS) {
        mavlink_msg_osd_param_show_config_reply_send(link.get_chan(), packet.request_id, OSD_PARAM_INVALID_PARAMETER_INDEX,
            nullptr, uint8_t(AP_OSD_ParamSetting::Type::NONE), 0, 0, 0);
        return;
    }
    // get the parameter and make sure it is fresh
    AP_OSD_ParamSetting& param = params[packet.osd_index - 1];
    param.update();

    // check for bad things
    if (param._param == nullptr) {
        mavlink_msg_osd_param_show_config_reply_send(link.get_chan(), packet.request_id, OSD_PARAM_INVALID_PARAMETER_INDEX,
            nullptr, uint8_t(AP_OSD_ParamSetting::Type::NONE), 0, 0, 0);
        return;
    }
    // get the name and send back the details
    char buf[AP_MAX_NAME_SIZE+1];
    param._param->copy_name_token(param._current_token, buf, AP_MAX_NAME_SIZE);
    buf[AP_MAX_NAME_SIZE] = 0;
    mavlink_msg_osd_param_show_config_reply_send(link.get_chan(), packet.request_id, OSD_PARAM_SUCCESS,
        buf, param._type, param._param_min, param._param_max, param._param_incr);
}
#endif

#endif // OSD_PARAM_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      /*
 * This file is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This file is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * AP_OSD partially based on betaflight and inav osd.c implemention.
 * clarity.mcm font is taken from inav configurator.
 * Many thanks to their authors.
 */

/*
  parameter object for one setting in AP_OSD
 */

#include "AP_OSD.h"
#include <AP_Vehicle/AP_Vehicle_Type.h>
#include <GCS_MAVLink/GCS.h>
#include <SRV_Channel/SRV_Channel.h>
#include <AP_SerialManager/AP_SerialManager.h>
#include <ctype.h>

#if OSD_PARAM_ENABLED

const AP_Param::GroupInfo AP_OSD_ParamSetting::var_info[] = {
    // @Param: _EN
    // @DisplayName: Enable
    // @Description: Enable setting
    // @Values: 0:Disabled,1:Enabled
    // @User: Standard
    AP_GROUPINFO_FLAGS_DEFAULT_POINTER("_EN", 1, AP_OSD_ParamSetting, enabled, default_enabled),

    // @Param: _X
    // @DisplayName: X position
    // @Description: Horizontal position on screen
    // @Range: 0 29
    // @User: Standard
    AP_GROUPINFO("_X", 2, AP_OSD_ParamSetting, xpos, 2),

    // @Param: _Y
    // @DisplayName: Y position
    // @Description: Vertical position on screen
    // @Range: 0 15
    // @User: Standard
    AP_GROUPINFO_FLAGS_DEFAULT_POINTER("_Y", 3, AP_OSD_ParamSetting, ypos, default_ypos),

    // Parameter access keys. These default to -1 too allow user overrides
    // to work properly

    // @Param: _KEY
    // @DisplayName: Parameter key
    // @Description: Key of the parameter to be displayed and modified
    // @User: Standard
    AP_GROUPINFO_FLAGS_DEFAULT_POINTER("_KEY", 4, AP_OSD_ParamSetting, _param_key, default_param_key),

    // @Param: _IDX
    // @DisplayName: Parameter index
    // @Description: Index of the parameter to be displayed and modified
    // @User: Standard
    AP_GROUPINFO_FLAGS_DEFAULT_POINTER("_IDX", 5, AP_OSD_ParamSetting, _param_idx, default_param_idx),

    // @Param: _GRP
    // @DisplayName: Parameter group
    // @Description: Group of the parameter to be displayed and modified
    // @User: Standard
    AP_GROUPINFO_FLAGS_DEFAULT_POINTER("_GRP", 6, AP_OSD_ParamSetting, _param_group, default_param_group),

    // @Param: _MIN
    // @DisplayName: Parameter minimum
    // @Description: Minimum value of the parameter to be displayed and modified
    // @User: Standard
    AP_GROUPINFO("_MIN", 7, AP_OSD_ParamSetting, _param_min, 0.0f),

    // @Param: _MAX
    // @DisplayName: Parameter maximum
    // @Description: Maximum of the parameter to be displayed and modified
    // @User: Standard
    AP_GROUPINFO("_MAX", 8, AP_OSD_ParamSetting, _param_max, 1.0f),

    // @Param: _INCR
    // @DisplayName: Parameter increment
    // @Description: Increment of the parameter to be displayed and modified
    // @User: Standard
    AP_GROUPINFO("_INCR", 9, AP_OSD_ParamSetting, _param_incr, 0.001f),

    // @Param: _TYPE
    // @DisplayName: Parameter type
    // @Description: Type of the parameter to be displayed and modified
    // @User: Standard
    AP_GROUPINFO_FLAGS_DEFAULT_POINTER("_TYPE", 10, AP_OSD_ParamSetting, _type, default_type),

    AP_GROUPEND
};

#if HAL_GCS_ENABLED
// ensure that our OSD_PARAM type enumeration is 1:1 with the mavlink
// numbers.  This allows us to do a simple cast from one to the other
// when sending mavlink messages, rather than having some sort of
// mapping function from our internal enumeration into the mavlink
// enumeration.  Doing things this way has two advantages - in the
// future we could add that mapping function and change our
// enumeration, and the other is that it allows us to build the GPS
// library without having the mavlink headers built (for example, in
// AP_Periph we shouldn't need mavlink headers).
static_assert((uint32_t)AP_OSD_ParamSetting::Type::NONE == (uint32_t)OSD_PARAM_NONE, "OSD_PARAM_NONE incorrect");
static_assert((uint32_t)AP_OSD_ParamSetting::Type::SERIAL_PROTOCOL == (uint32_t)OSD_PARAM_SERIAL_PROTOCOL, "OSD_PARAM_SERIAL_PROTOCOL incorrect");
static_assert((uint32_t)AP_OSD_ParamSetting::Type::SERVO_FUNCTION == (uint32_t)OSD_PARAM_SERVO_FUNCTION, "OSD_PARAM_SERVO_FUNCTION incorrect");
static_assert((uint32_t)AP_OSD_ParamSetting::Type::AUX_FUNCTION == (uint32_t)OSD_PARAM_AUX_FUNCTION, "OSD_PARAM_AUX_FUNCTION incorrect");
static_assert((uint32_t)AP_OSD_ParamSetting::Type::FLIGHT_MODE == (uint32_t)OSD_PARAM_FLIGHT_MODE, "OSD_PARAM_FLIGHT_MODE incorrect");
static_assert((uint32_t)AP_OSD_ParamSetting::Type::FAILSAFE_ACTION == (uint32_t)OSD_PARAM_FAILSAFE_ACTION, "OSD_PARAM_FAILSAFE_ACTION incorrect");
static_assert((uint32_t)AP_OSD_ParamSetting::Type::FAILSAFE_ACTION_1 == (uint32_t)OSD_PARAM_FAILSAFE_ACTION_1, "OSD_PARAM_FAILSAFE_ACTION_1 incorrect");
static_assert((uint32_t)AP_OSD_ParamSetting::Type::FAILSAFE_ACTION_2 == (uint32_t)OSD_PARAM_FAILSAFE_ACTION_2, "OSD_PARAM_FAILSAFE_ACTION_2 incorrect");
static_assert((uint32_t)AP_OSD_ParamSetting::Type::NUM_TYPES == (uint32_t)AP_OSD_ParamSetting::Type::NUM_TYPES, "AP_OSD_ParamSetting::Type::NUM_TYPES incorrect");
#endif  // HAL_GCS_ENABLED

#define PARAM_COMPOSITE_INDEX(key, idx, group) (uint32_t((uint32_t(key) << 23) | (uint32_t(idx) << 18) | uint32_t(group)))

#define OSD_PARAM_DEBUG 0
#if OSD_PARAM_DEBUG
#define debug(fmt, args ...) do { hal.console->printf("OSD: " fmt, args); } while (0)
#else
#define debug(fmt, args ...)
#endif

// at the cost of a little flash, we can create much better ranges and values for certain important settings
// common labels - all strings must be upper case
#if APM_BUILD_TYPE(APM_BUILD_ArduPlane) || APM_BUILD_COPTER_OR_HELI

static const char* SERIAL_PROTOCOL_VALUES[] = {
    "", "MAV", "MAV2", "FSKY_D", "FSKY_S", "GPS", "", "ALEX", "STORM", "RNG", 
    "FSKY_TX", "LID360", "", "BEACN", "VOLZ", "SBUS", "ESC_TLM", "DEV_TLM", "OPTFLW", "RBTSRV",
    "NMEA", "WNDVNE", "SLCAN", "RCIN", "MGSQRT", "LTM", "RUNCAM", "HOT_TLM", "SCRIPT", "CRSF",
    "GEN", "WNCH", "MSP", "DJI", "AIRSPD", "ADSB", "AHRS", "AUDIO", "FETTEC", "TORQ",
    "AIS", "CD_ESC", "MSP_DP", "MAV_HL", "TRAMP", "DDS", "IMUOUT", "IQ", "PPP", "IBUS_TLM"
};
static_assert(AP_SerialManager::SerialProtocol_NumProtocols == ARRAY_SIZE(SERIAL_PROTOCOL_VALUES), "Wrong size SerialProtocol_NumProtocols");

static const char* SERVO_FUNCTIONS[] = {
    "NONE", "RCPASS", "FLAP", "FLAP_AUTO", "AIL", "", "MNT_PAN", "MNT_TLT", "MNT_RLL", "MNT_OPEN", 
    "CAM_TRG", "", "MNT2_PAN", "MNT2_TLT", "MNT2_RLL", "MNT2_OPEN", "DIF_SPL_L1", "DIF_SPL_R1", "", "ELE",
    "", "RUD", "SPR_PMP", "SPR_SPIN", "FLPRON_L", "FLPRON_R", "GRND_STEER", "PARACHT", "GRIP", "GEAR",
    "ENG_RUN_EN", "HELI_RSC", "HELI_TAIL_RSC", "MOT_1", "MOT_2", "MOT_3", "MOT_4", "MOT_5", "MOT_6", "MOT_7",
    "MOT_8", "MOT_TLT", "", "", "", "", "", "", "", "",
    "", "RCIN_1", "RCIN_2", "RCIN_3", "RCIN_4", "RCIN_5", "RCIN_6", "RCIN_7", "RCIN_8", "RCIN_9",
    "RCIN_10", "RCIN_11", "RCIN_12", "RCIN_13", "RCIN_14", "RCIN_15", "RCIN_16", "IGN", "", "START",
    "THR", "TRCK_YAW", "TRCK_PIT", "THR_L", "THR_R", "TLTMOT_L", "TLTMOT_R", "ELEVN_L", "ELEVN_R", "VTAIL_L",
    "VTAIL_R", "BOOST_THR", "MOT_9", "MOT_10", "MOT_11", "MOT_12", "DIF_SPL_L2", "DIF_SPL_R2", "", "MAIN_SAIL",
    "CAM_ISO", "CAM_APTR", "CAM_FOC", "CAM_SH_SPD", "SCRPT_1", "SCRPT_2", "SCRPT_3", "SCRPT_4", "SCRPT_5", "SCRPT_6",
    "SCRPT_7", "SCRPT_8", "SCRPT_9", "SCRPT_10", "SCRPT_11", "SCRPT_12", "SCRPT_13", "SCRPT_14", "SCRPT_15", "SCRPT_16",
    "", "", "", "", "", "", "", "", "", "",
    "NEOPX_1", "NEOPX_2", "NEOPX_3", "NEOPX_4", "RAT_RLL", "RAT_PIT","RAT_THRST", "RAT_YAW", "WSAIL_EL", "PRLED_1",
    "PRLED_2", "PRLED_3", "PRLED_CLK", "WNCH_CL"
};

#endif

#if APM_BUILD_TYPE(APM_BUILD_ArduPlane)

static const char* AUX_OPTIONS[] = {
    "NONE", "", "", "", "RTL", "", "", "", "", "CAM_TRG",
    "", "", "", "", "", "", "AUTO", "", "", "",
    "", "", "", "", "MIS_RST", "", "", "", "RLY", "LAND_GR",
    "LOST_SND", "M_ESTOP", "", "", "", "RLY3", "RLY4", "", "OA_ADSB", "",
    "", "ARM/DS", "", "INVERT", "", "", "RC_OVRD", "", "", "",
    "", "MANUAL", "", "", "", "GUIDE", "LOIT", "", "CLR_WP", "",
    "", "", "COMP_LRN", "", "REV_THR", "GPS_DIS", "RLY5", "RLY6", "", "",
    "", "", "CIRCLE", "", "", "", "", "TAKEOFF", "RCAM_CTL", "RCAM_OSD",
    "", "DSARM", "QASS3POS", "", "AIR", "GEN", "TER_AUTO", "CROW_SEL", "SOAR", "", 
    "", "", "", "", "", "", "", "", "", "",
    "KILLIMU1", "KILLIMU2", "CAM_TOG", "", "", "GPSYAW_DIS"
};

static const char* FLTMODES[] = {
    "MAN", "CIRC", "STAB", "TRAIN", "ACRO", "FBWA", "FBWB", "CRUISE", "ATUNE", "", "AUTO",
    "RTL", "LOIT", "TKOF", "ADSB", "GUID", "", "QSTAB", "QHOV", "QLOIT", "QLAND",
    "QRTL", "QTUNE", "QACRO", "THRML", "L2QLND"
};

static const char* FS_ACT[] = {
    "NONE", "RTL", "LAND", "TERM", "QLAND", "PARA"
};

static const char* FS_SHRT_ACTNS[] = {
    "CRC_NOCHNGE", "CIRC", "FBWA", "DSABLE"
};

static const char* FS_LNG_ACTNS[] = {
    "CNTNUE", "RTL", "GLIDE", "PARACHT"
};

// plane parameters
const AP_OSD_ParamSetting::ParamMetadata AP_OSD_ParamSetting::_param_metadata[unsigned(AP_OSD_ParamSetting::Type::NUM_TYPES)] = {
    { -1, AP_SerialManager::SerialProtocol_NumProtocols - 1,    1, ARRAY_SIZE(SERIAL_PROTOCOL_VALUES), SERIAL_PROTOCOL_VALUES },  // OSD_PARAM_SERIAL_PROTOCOL
    { 0, SRV_Channel::k_nr_aux_servo_functions - 1,             1, ARRAY_SIZE(SERVO_FUNCTIONS), SERVO_FUNCTIONS },                // OSD_PARAM_SERVO_FUNCTION
    { 0, 105, 1, ARRAY_SIZE(AUX_OPTIONS), AUX_OPTIONS },                        // OSD_PARAM_AUX_FUNCTION
    { 0, 25, 1,  ARRAY_SIZE(FLTMODES), FLTMODES },                              // OSD_PARAM_FLIGHT_MODE
    { 0, 5, 1,   ARRAY_SIZE(FS_ACT), FS_ACT },                                  // OSD_PARAM_FAILSAFE_ACTION
    { 0, 3, 1,   ARRAY_SIZE(FS_SHRT_ACTNS), FS_SHRT_ACTNS },                    // OSD_PARAM_FAILSAFE_ACTION_1
    { 0, 3, 1,   ARRAY_SIZE(FS_LNG_ACTNS), FS_LNG_ACTNS },                      // OSD_PARAM_FAILSAFE_ACTION_2
};

#elif APM_BUILD_COPTER_OR_HELI

static const char* AUX_OPTIONS[] = {
    "NONE", "", "FLIP", "SIMP", "RTL", "SAV_TRM", "", "SAV_WP", "", "CAM_TRG",
    "RNG", "FENCE", "", "SSIMP", "ACRO_TRN", "SPRAY", "AUTO", "AUTOTN", "LAND", "GRIP",
    "", "CHUTE_EN", "CHUTE_RL", "CHUTE_3P", "MIS_RST", "ATT_FF", "ATT_ACC", "RET_MNT", "RLY", "LAND_GR",
    "LOST_SND", "M_ESTOP", "M_ILOCK", "BRAKE", "RLY2", "RLY3", "RLY4", "THROW", "OA_ADSB", "PR_LOIT",
    "OA_PROX", "ARM/DS", "SMRT_RTL", "INVERT", "", "", "RC_OVRD", "USR1", "USR2", "USR3",
    "", "", "ACRO", "", "", "GUIDE", "LOIT", "FOLLOW", "CLR_WP", "",
    "ZZAG", "ZZ_SVWP", "COMP_LRN", "", "", "GPS_DIS", "RLY5", "RLY6", "STAB", "PHOLD",
    "AHOLD", "FHOLD", "CIRCLE", "DRIFT", "", "", "STANDBY", "", "RCAM_CTL", "RCAM_OSD",
    "VISO_CAL", "DISARM", "", "ZZ_Auto", "AIR", "", "", "", "", "",
    "", "", "", "", "", "", "", "", "", "",
    "KILLIMU1", "KILLIMU2", "CAM_MOD_TOG", "", "", "GPSYAW_DIS"
};

static const char* FLTMODES[] = {
    "STAB", "ACRO", "ALTHOLD", "AUTO", "GUIDED", "LOIT", "RTL", "CIRC", "", "LAND",
    "", "DRFT", "", "SPORT", "FLIP", "ATUN", "POSHLD", "BRAKE", "THROW", "AVD_ADSB",
    "GUID_NOGPS", "SMRTRTL", "FLOHOLD", "FOLLOW", "ZIGZAG", "SYSID", "HELI_ARO", "AUTORTL",
    "TRTLE"
};

static const char* FS_OPTIONS[] = {
    "NONE", "CONT_RCFS", "CONT_GCSFS", "CONT_RC/GCSFS", "CONT_GUID_RC", "", "", "", "CONT_LAND", "",
    "", "", "", "", "", "CONT_CTRL_GCS", "", "", "CONTNUE"
};

static const char* THR_FS_ACT[] = {
    "NONE", "RTL", "CONT", "LAND", "SRTL_RTL", "SRTL_LAND"
};

static const char* FS_ACT[] = {
    "NONE", "LAND", "RTL", "SRTL_RTL", "SRTL_LAND", "TERM"
};

// copter parameters
const AP_OSD_ParamSetting::ParamMetadata AP_OSD_ParamSetting::_param_metadata[unsigned(AP_OSD_ParamSetting::Type::NUM_TYPES)] = {
    { -1, AP_SerialManager::SerialProtocol_NumProtocols - 1,    1, ARRAY_SIZE(SERIAL_PROTOCOL_VALUES), SERIAL_PROTOCOL_VALUES },  // OSD_PARAM_SERIAL_PROTOCOL
    { 0, SRV_Channel::k_nr_aux_servo_functions - 1,             1, ARRAY_SIZE(SERVO_FUNCTIONS), SERVO_FUNCTIONS },                // OSD_PARAM_SERVO_FUNCTION
    { 0, 105, 1, ARRAY_SIZE(AUX_OPTIONS), AUX_OPTIONS },                        // OSD_PARAM_AUX_FUNCTION
    { 0, 28, 1,  ARRAY_SIZE(FLTMODES), FLTMODES },                              // OSD_PARAM_FLIGHT_MODE
    { 0, 3, 1,   ARRAY_SIZE(FS_OPTIONS), FS_OPTIONS },                          // OSD_PARAM_FAILSAFE_ACTION
    { 0, 5, 1,   ARRAY_SIZE(FS_ACT), FS_ACT },                                  // OSD_PARAM_FAILSAFE_ACTION_1
    { 0, 5, 1,   ARRAY_SIZE(THR_FS_ACT), THR_FS_ACT },                          // OSD_PARAM_FAILSAFE_ACTION_2
};

#else
const AP_OSD_ParamSetting::ParamMetadata AP_OSD_ParamSetting::_param_metadata[unsigned(AP_OSD_ParamSetting::Type::NUM_TYPES)] = {};
#endif

extern const AP_HAL::HAL& hal;

// default constructor that just sets some sensible defaults that exist on all platforms
AP_OSD_ParamSetting::AP_OSD_ParamSetting(uint8_t param_number) :
    _param_number(param_number),
    default_ypos(param_number + 1),
    default_param_group(-1),
    default_param_idx(-1),
    default_param_key(-1)
{
    AP_Param::setup_object_defaults(this, var_info);
}

// construct a setting from a compact static initializer structure
AP_OSD_ParamSetting::AP_OSD_ParamSetting(const Initializer& initializer) :
    _param_number(initializer.index),
    default_enabled(true),
    default_ypos(initializer.index + 1),
    default_param_group(initializer.token.group_element),
    default_param_idx(initializer.token.idx),
    default_param_key(initializer.token.key),
    default_type(float(initializer.type))
{
    AP_Param::setup_object_defaults(this, var_info);
}

// update the contained parameter
void AP_OSD_ParamSetting::update()
{
    // if the user has not made any changes then skip the update
    if (PARAM_TOKEN_INDEX(_current_token) == PARAM_COMPOSITE_INDEX(_param_key, _param_idx, _param_group) && _param_key >= 0) {
        return;
    }
    // if a parameter was configured then use that
    _current_token = AP_Param::ParamToken {};
    // surely there is a more efficient way than brute-force search
    for (_param = AP_Param::first(&_current_token, &_param_type);
        _param && (AP_Param::get_persistent_key(_current_token.key) != uint16_t(_param_key.get())
            || _current_token.idx != uint8_t(_param_idx.get())
            || _current_token.group_element != uint32_t(_param_group.get()));
        _param = AP_Param::next_scalar(&_current_token, &_param_type)) {
    }

    if (_param == nullptr) {
        enabled.set(false);
    } else {
        guess_ranges();
    }
}

// update parameter settings from the named parameter
bool AP_OSD_ParamSetting::set_by_name(const char* name, uint8_t config_type, float pmin, float pmax, float pincr)
{
    AP_Param::ParamToken token = AP_Param::ParamToken {};
    ap_var_type type;
    AP_Param* param = AP_Param::find_by_name(name, &type, &token);

    if (param == nullptr) {
        // leave unchanged
        return false;
    } else {
        _current_token = token;
        _param_type = type;
        _param = param;
        enabled.set_and_save_ifchanged(true);
    }

    _type.set_and_save_ifchanged(config_type);

    if (config_type == uint8_t(Type::NONE) && !is_zero(pincr)) {
        // ranges
        _param_min.set_and_save_ifchanged(pmin);
        _param_max.set_and_save_ifchanged(pmax);
        _param_incr.set_and_save_ifchanged(pincr);
    } else {
        guess_ranges(true);
    }

    _param_key.set_and_save_ifchanged(AP_Param::get_persistent_key(_current_token.key));
    _param_idx.set_and_save_ifchanged(_current_token.idx);
    _param_group.set_and_save_ifchanged(_current_token.group_element);
    return true;
}

// guess the ranges and increment for the selected parameter
// only called when a change has been made
void AP_OSD_ParamSetting::guess_ranges(bool force)
{
    if (_param->is_read_only()) {
        return;
    }

    // check for statically configured setting metadata
    if (set_from_metadata()) {
        return;
    }

    // nothing statically configured so guess some appropriate values
    float min = -1, max = 127, incr = 1;

    if (_param != nullptr) {
        switch (_param_type) {
        case AP_PARAM_INT8:
            break;
        case AP_PARAM_INT16: {
            AP_Int16* p = (AP_Int16*)_param;
            min = -1;
            uint8_t digits = 0;
            for (int16_t int16p = p->get(); int16p > 0; int16p /= 10) {
                digits++;
            }
            incr = MAX(1, powf(10, digits - 2));
            max = powf(10, digits + 1);
            debug("Guessing range for value %d as %f -> %f, %f\n", p->get(), min, max, incr);
            break;
        }
        case AP_PARAM_INT32: {
            AP_Int32* p = (AP_Int32*)_param;
            min = -1;
            uint8_t digits = 0;
            for (int32_t int32p = p->get(); int32p > 0; int32p /= 10) {
                digits++;
            }
            incr = MAX(1, powf(10, digits - 2));
            max = powf(10, digits + 1);
            debug("Guessing range for value %d as %f -> %f, %f\n", int(p->get()), min, max, incr);
            break;
        }
        case AP_PARAM_FLOAT: {
            AP_Float* p = (AP_Float*)_param;

            uint8_t digits = 0;
            for (float floatp = p->get(); floatp > 1.0f; floatp /= 10) {
                digits++;
            }
            float floatp = p->get();
            if (digits < 1) {
                if (!is_zero(floatp)) {
                    incr = floatp * 0.01f; // move in 1% increments
                } else {
                    incr = 0.01f; // move in absolute 1% increments
                }
                max = 1.0;
                min = 0.0f;
            } else {
                if (!is_zero(floatp)) {
                    incr = floatp * 0.01f; // move in 1% increments
                } else {
                    incr = MAX(1, powf(10, digits - 2));
                }
                max = powf(10, digits + 1);
                min = 0.0f;
            }
            debug("Guessing range for value %f as %f -> %f, %f\n", p->get(), min, max, incr);
            break;
        }
        case AP_PARAM_VECTOR3F:
        case AP_PARAM_NONE:
        case AP_PARAM_GROUP:
            break;
        }

        if (force || !_param_min.configured()) {
            _param_min.set(min);
        }
        if (force || !_param_max.configured()) {
            _param_max.set(max);
        }
        if (force || !_param_incr.configured()) {
            _param_incr.set(incr);
        }
    }
}

// copy the name converting FOO_BAR_BAZ to FooBarBaz
void AP_OSD_ParamSetting::copy_name_camel_case(char* name, size_t len) const
{
    char buf[17];
    _param->copy_name_token(_current_token, buf, 17);
    buf[16] = 0;
    name[0] = buf[0];
    for (uint8_t i = 1, n = 1; i < len; i++, n++) {
        if (buf[i] == '_') {
            name[n] = buf[i+1];
            i++;
        } else {
            name[n] = tolower(buf[i]);
        }
    }
}

bool AP_OSD_ParamSetting::set_from_metadata()
{
    // check for statically configured setting metadata
    if (_type > 0 && _type < uint8_t(Type::NUM_TYPES) && _param_metadata[_type - 1].values_max > 0) {
        _param_incr.set(_param_metadata[_type - 1].increment);
        _param_min.set(_param_metadata[_type - 1].min_value);
        _param_max.set(_param_metadata[_type - 1].max_value);
        return true;
    }
    return false;
}

// modify the selected parameter values
void AP_OSD_ParamSetting::save_as_new()
{
    _param_group.save();
    _param_key.save();
    _param_idx.save();
    // the user has configured the range and increment, but the parameter
    // is no longer valid so reset these to guessed values
    guess_ranges(true);
    if (_param_min.configured()) {
        _param_min.save();
    }
    if (_param_max.configured()) {
        _param_max.save();
    }
    if (_param_incr.configured()) {
        _param_incr.save();
    }
}

#endif // OSD_PARAM_ENABLED

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          /*
 * This file is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This file is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
/*
  OSD backend for SITL. Uses SFML media library. See
  https://www.sfml-dev.org/index.php

  To use install SFML libraries, and run sim_vehicle.py with --osd
  option. Then set OSD_TYPE to 2
 */
#ifdef WITH_SITL_OSD

#include "AP_OSD_SITL.h"
#include <AP_HAL/Util.h>
#include <AP_HAL/Semaphores.h>
#include <AP_HAL/Scheduler.h>
#include <AP_ROMFS/AP_ROMFS.h>
#include <SITL/SITL.h>
#include <utility>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include "pthread.h"

#include <AP_Notify/AP_Notify.h>

extern const AP_HAL::HAL &hal;

/*
  load *.bin font file, in MAX7456 format
 */
void AP_OSD_SITL::load_font(void)
{
    last_font = get_font_num();
    FileData *fd = load_font_data(last_font);
    if (fd == nullptr || fd->length != 54 * 256) {
        AP_HAL::panic("Bad font file");
    }
    for (uint16_t i=0; i<256; i++) {
        const uint8_t *c = &fd->data[i*54];
        // each pixel is 4 bytes, RGBA
        sf::Uint8 *pixels = NEW_NOTHROW sf::Uint8[char_width * char_height * 4];
        if (!font[i].create(char_width, char_height)) {
            AP_HAL::panic("Failed to create texture");
        }
        for (uint16_t y=0; y<char_height; y++) {
            for (uint16_t x=0; x<char_width; x++) {
                // 2 bits per pixel
                uint16_t bitoffset = (y*char_width+x)*2;
                uint8_t byteoffset = bitoffset / 8;
                uint8_t bitshift = 6-(bitoffset % 8);
                uint8_t v = (c[byteoffset] >> bitshift) & 3;
                sf::Uint8 *p = &pixels[(y*char_width+x)*4];
                switch (v) {
                case 0:
                    p[0] = 0;
                    p[1] = 0;
                    p[2] = 0;
                    p[3] = 255;
                    break;
                case 1:
                case 3:
                    p[0] = 0;
                    p[1] = 0;
                    p[2] = 0;
                    p[3] = 0;
                    break;
                case 2:
                    p[0] = 255;
                    p[1] = 255;
                    p[2] = 255;
                    p[3] = 255;
                    break;
                }

            }
        }
        font[i].update(pixels);
    }
    delete fd;
}

void AP_OSD_SITL::write(uint8_t x, uint8_t y, const char* text)
{
    if (y >= video_lines || text == nullptr) {
        return;
    }
    WITH_SEMAPHORE(mutex);

    while ((x < video_cols) && (*text != 0)) {
        getbuffer(buffer, y, x) = *text;
        ++text;
        ++x;
    }
}

void AP_OSD_SITL::clear(void)
{
    AP_OSD_Backend::clear();
    WITH_SEMAPHORE(mutex);
    memset(buffer, 0, video_cols*video_lines);
}

void AP_OSD_SITL::flush(void)
{
    counter++;
}

// main loop of graphics thread
void AP_OSD_SITL::update_thread(void)
{
    load_font();
    {
        WITH_SEMAPHORE(AP::notify().sf_window_mutex);
        w = NEW_NOTHROW sf::RenderWindow(sf::VideoMode(video_cols*(char_width+char_spacing)*char_scale,
                                               video_lines*(char_height+char_spacing)*char_scale),
                                 "OSD");
    }
    if (!w) {
        AP_HAL::panic("Unable to create OSD window");
    }

    while (true) {
        {
            WITH_SEMAPHORE(AP::notify().sf_window_mutex);
            sf::Event event;
            while (w->pollEvent(event)) {
                if (event.type == sf::Event::Closed) {
                    w->close();
                }
            }
            if (!w->isOpen()) {
                break;
            }
            if (counter != last_counter) {
                last_counter = counter;

                uint8_t buffer2[video_lines][video_cols];
                {
                    WITH_SEMAPHORE(mutex);
                    memcpy(buffer2, buffer, sizeof(buffer2));
                }
                w->clear();

                for (uint8_t y=0; y<video_lines; y++) {
                    for (uint8_t x=0; x<video_cols; x++) {
                        uint16_t px = x * (char_width+char_spacing) * char_scale;
                        uint16_t py = y * (char_height+char_spacing) * char_scale;
                        sf::Sprite s;
                        uint8_t c = buffer2[y][x];
                        s.setTexture(font[c]);
                        s.setPosition(sf::Vector2f(px, py));
                        s.scale(sf::Vector2f(char_scale,char_scale));
                        w->draw(s);
                    }
                }

                w->display();
                if (last_font != get_font_num()) {
                    load_font();
                }
            }
        }
        usleep(10000);
    }
}

// trampoline for update thread
void *AP_OSD_SITL::update_thread_start(void *obj)
{
    ((AP_OSD_SITL *)obj)->update_thread();
    return nullptr;
}

// initialise backend
bool AP_OSD_SITL::init(void)
{
    pthread_create(&thread, NULL, update_thread_start, this);
    return true;
}

AP_OSD_Backend *AP_OSD_SITL::probe(AP_OSD &osd)
{
    AP_OSD_SITL *backend = NEW_NOTHROW AP_OSD_SITL(osd);
    if (!backend) {
        return nullptr;
    }
    if (!backend->init()) {
        delete backend;
        return nullptr;
    }
    return backend;
}

AP_OSD_SITL::AP_OSD_SITL(AP_OSD &osd):
    AP_OSD_Backend(osd)
{
    const auto *_sitl = AP::sitl();
    video_lines = _sitl->osd_rows;
    video_cols = _sitl->osd_columns;
    buffer = (uint8_t *)malloc(video_lines*video_cols);
}

#endif // WITH_SITL_OSD
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 /*
 * This file is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This file is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
#pragma once

#ifdef WITH_SITL_OSD

#include <AP_OSD/AP_OSD_Backend.h>

#ifdef HAVE_SFML_GRAPHICS_H
#include <SFML/Graphics.h>
#else
#include <SFML/Graphics.hpp>
#endif

class AP_OSD_SITL : public AP_OSD_Backend
{

public:
    static AP_OSD_Backend *probe(AP_OSD &osd);

    //draw given text to framebuffer
    void write(uint8_t x, uint8_t y, const char* text) override;

    //initialize display port and underlying hardware
    bool init() override;

    //flush framebuffer to screen
    void flush() override;

    //clear framebuffer
    void clear() override;

    bool is_compatible_with_backend_type(AP_OSD::osd_types type) const override {
        switch(type) {
        case AP_OSD::osd_types::OSD_MAX7456:
        case AP_OSD::osd_types::OSD_SITL:
            return false;
        case AP_OSD::osd_types::OSD_NONE:
        case AP_OSD::osd_types::OSD_TXONLY:
        case AP_OSD::osd_types::OSD_MSP:
        case AP_OSD::osd_types::OSD_MSP_DISPLAYPORT:
            return true;
        }
        return false;
    }

    AP_OSD::osd_types get_backend_type() const override {
        return AP_OSD::osd_types::OSD_SITL;
    }
private:
    //constructor
    AP_OSD_SITL(AP_OSD &osd);

    sf::RenderWindow *w;

    sf::Texture font[256];
    uint8_t last_font;

    // setup to match MAX7456 layout
    static const uint8_t char_width = 12;
    static const uint8_t char_height = 18;
    uint8_t video_lines;
    uint8_t video_cols;
    static const uint8_t char_spacing = 0;

    // scaling factor to make it easier to read
    static const uint8_t char_scale = 2;

    // get a byte from a buffer
    uint8_t &getbuffer(uint8_t *buf, uint8_t y, uint8_t x) const {
        return buf[y*uint32_t(video_cols) + x];
    }

    uint8_t *buffer;

    void update_thread();
    static void *update_thread_start(void *obj);
    void load_font();

    pthread_t thread;
    HAL_Semaphore mutex;
    uint32_t counter;
    uint32_t last_counter;
};

#endif // WITH_SITL_OSD
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              #pragma once

#include <AP_Logger/LogStructure.h>
#include "AP_VisualOdom_config.h"

#define LOG_IDS_FROM_VISUALODOM \
    LOG_VISUALODOM_MSG, \
    LOG_VISUALPOS_MSG, \
    LOG_VISUALVEL_MSG

// @LoggerMessage: VISO
// @Description: Visual Odometry
// @Field: TimeUS: System time
// @Field: dt: Time period this data covers
// @Field: AngDX: Angular change for body-frame roll axis
// @Field: AngDY: Angular change for body-frame pitch axis
// @Field: AngDZ: Angular change for body-frame z axis
// @Field: PosDX: Position change for body-frame X axis (Forward-Back)
// @Field: PosDY: Position change for body-frame Y axis (Right-Left)
// @Field: PosDZ: Position change for body-frame Z axis (Down-Up)
// @Field: conf: Confidence
struct PACKED log_VisualOdom {
    LOG_PACKET_HEADER;
    uint64_t time_us;
    float time_delta;
    float angle_delta_x;
    float angle_delta_y;
    float angle_delta_z;
    float position_delta_x;
    float position_delta_y;
    float position_delta_z;
    float confidence;
};

// @LoggerMessage: VISP
// @Description: Vision Position
// @Field: TimeUS: System time
// @Field: RTimeUS: Remote system time
// @Field: CTimeMS: Corrected system time
// @Field: PX: Position X-axis (North-South)
// @Field: PY: Position Y-axis (East-West)
// @Field: PZ: Position Z-axis (Down-Up)
// @Field: R: Roll lean angle
// @Field: P: Pitch lean angle
// @Field: Y: Yaw angle
// @Field: PErr: Position estimate error
// @Field: AErr: Attitude estimate error
// @Field: Rst: Position reset counter
// @Field: Ign: Ignored
// @Field: Q: Quality
struct PACKED log_VisualPosition {
    LOG_PACKET_HEADER;
    uint64_t time_us;
    uint64_t remote_time_us;
    uint32_t time_ms;
    float pos_x;
    float pos_y;
    float pos_z;
    float roll;     // degrees
    float pitch;    // degrees
    float yaw;      // degrees
    float pos_err;  // meters
    float ang_err;  // radians
    uint8_t reset_counter;
    uint8_t ignored;
    int8_t quality;
};

// @LoggerMessage: VISV
// @Description: Vision Velocity
// @Field: TimeUS: System time
// @Field: RTimeUS: Remote system time
// @Field: CTimeMS: Corrected system time
// @Field: VX: Velocity X-axis (North-South)
// @Field: VY: Velocity Y-axis (East-West)
// @Field: VZ: Velocity Z-axis (Down-Up)
// @Field: VErr: Velocity estimate error
// @Field: Rst: Velocity reset counter
// @Field: Ign: Ignored
// @Field: Q: Quality
struct PACKED log_VisualVelocity {
    LOG_PACKET_HEADER;
    uint64_t time_us;
    uint64_t remote_time_us;
    uint32_t time_ms;
    float vel_x;
    float vel_y;
    float vel_z;
    float vel_err;
    uint8_t reset_counter;
    uint8_t ignored;
    int8_t quality;
};

#if HAL_VISUALODOM_ENABLED
#define LOG_STRUCTURE_FROM_VISUALODOM \
    { LOG_VISUALODOM_MSG, sizeof(log_VisualOdom), \
      "VISO", "Qffffffff", "TimeUS,dt,AngDX,AngDY,AngDZ,PosDX,PosDY,PosDZ,conf", "ssrrrmmm-", "FF000000-" }, \
    { LOG_VISUALPOS_MSG, sizeof(log_VisualPosition), \
      "VISP", "QQIffffffffBBb", "TimeUS,RTimeUS,CTimeMS,PX,PY,PZ,R,P,Y,PErr,AErr,Rst,Ign,Q", "sssmmmddhmd--%", "FFC00000000--0" }, \
    { LOG_VISUALVEL_MSG, sizeof(log_VisualVelocity), \
      "VISV", "QQIffffBBb", "TimeUS,RTimeUS,CTimeMS,VX,VY,VZ,VErr,Rst,Ign,Q", "sssnnnn--%", "FFC0000--0" },
#else
#define LOG_STRUCTURE_FROM_VISUALODOM
#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           /*
 * AP_VOLZ_PROTOCOL.cpp
 *
 *  Created on: Oct 31, 2017
 *      Author: guy
 */
#include "AP_Volz_Protocol.h"

#if AP_VOLZ_ENABLED

#include <AP_HAL/AP_HAL.h>

#include <AP_SerialManager/AP_SerialManager.h>
#include <SRV_Channel/SRV_Channel.h>
#include <AP_BoardConfig/AP_BoardConfig.h>

#define SET_EXTENDED_POSITION_CMD      0xDC

// Extended Position Data Format defines -100 as 0x0080 decimal 128, we map this to a PWM of 1000 (if range is default)
#define PWM_POSITION_MIN               1000
#define ANGLE_POSITION_MIN            -100.0
#define EXTENDED_POSITION_MIN          0x0080

// Extended Position Data Format defines +100 as 0x0F80 decimal 3968, we map this to a PWM of 2000 (if range is default)
#define PWM_POSITION_MAX               2000
#define ANGLE_POSITION_MAX             100.0
#define EXTENDED_POSITION_MAX          0x0F80

#define UART_BUFSIZE_RX                128
#define UART_BUFSIZE_TX                128

extern const AP_HAL::HAL& hal;

const AP_Param::GroupInfo AP_Volz_Protocol::var_info[] = {
    // @Param: MASK
    // @DisplayName: Channel Bitmask
    // @Description: Enable of volz servo protocol to specific channels
    // @Bitmask: 0:Channel1,1:Channel2,2:Channel3,3:Channel4,4:Channel5,5:Channel6,6:Channel7,7:Channel8,8:Channel9,9:Channel10,10:Channel11,11:Channel12,12:Channel13,13:Channel14,14:Channel15,15:Channel16,16:Channel17,17:Channel18,18:Channel19,19:Channel20,20:Channel21,21:Channel22,22:Channel23,23:Channel24,24:Channel25,25:Channel26,26:Channel27,28:Channel29,29:Channel30,30:Channel31,31:Channel32
    // @User: Standard
    AP_GROUPINFO("MASK",  1, AP_Volz_Protocol, bitmask, 0),

    // @Param: RANGE
    // @DisplayName: Range of travel
    // @Description: Range to map between 1000 and 2000 PWM. Default value of 200 gives full +-100 deg range of extended position command. This results in 0.2 deg movement per US change in PWM. If the full range is not needed it can be reduced to increase resolution. 40 deg range gives 0.04 deg movement per US change in PWM, this is higher resolution than possible with the VOLZ protocol so further reduction in range will not improve resolution. Reduced range does allow PWMs outside the 1000 to 2000 range, with 40 deg range 750 PWM results in a angle of -30 deg, 2250 would be +30 deg. This is still limited by the 200 deg maximum range of the actuator.
    // @Units: deg
    AP_GROUPINFO("RANGE", 2, AP_Volz_Protocol, range, 200),

    AP_GROUPEND
};

// constructor
AP_Volz_Protocol::AP_Volz_Protocol(void)
{
    // set defaults from the parameter table
    AP_Param::setup_object_defaults(this, var_info);
}

void AP_Volz_Protocol::init(void)
{
    if (uint32_t(bitmask.get()) == 0) {
        // No servos enabled
        return;
    }

    const AP_SerialManager &serial_manager = AP::serialmanager();
    port = serial_manager.find_serial(AP_SerialManager::SerialProtocol_Volz,0);
    if (port == nullptr) {
        // No port configured
        return;
    }

    // Create thread to handle output
    if (!hal.scheduler->thread_create(FUNCTOR_BIND_MEMBER(&AP_Volz_Protocol::loop, void),
                                          "Volz",
                                           1024, AP_HAL::Scheduler::PRIORITY_RCOUT, 1)) {
        AP_BoardConfig::allocation_error("Volz thread");
    }
}

void AP_Volz_Protocol::loop()
{
    const uint32_t baudrate = 115200;
    port->begin(baudrate, UART_BUFSIZE_RX, UART_BUFSIZE_TX);
    port->set_unbuffered_writes(true);
    port->set_flow_control(AP_HAL::UARTDriver::FLOW_CONTROL_DISABLE);

    // Calculate the amount of time it should take to send a command
    // Multiply by 10 to convert from bit rate to byte rate (8 data bits + start and stop bits)
    // B/s to s/B, 1000000 converts to microseconds, multiply by number of bytes
    // 6 bytes at 11520 bytes per second takes 520 us
    const uint16_t send_us =  (sizeof(CMD) * 1000000 * 10) / baudrate;

    // receive packet is same length as sent, double to allow some time for the servo respond
    const uint16_t receive_us = send_us * 2;

    // This gives a total time of 1560