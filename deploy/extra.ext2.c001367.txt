act);
            break;
        }
        break;
    }
#endif

#if AP_GPS_ENABLED
    case AUX_FUNC::GPS_DISABLE:
        AP::gps().force_disable(ch_flag == AuxSwitchPos::HIGH);
#if HAL_EXTERNAL_AHRS_ENABLED
        AP::externalAHRS().set_gnss_disable(ch_flag == AuxSwitchPos::HIGH);
#endif
        break;

    case AUX_FUNC::GPS_DISABLE_YAW:
        AP::gps().set_force_disable_yaw(ch_flag == AuxSwitchPos::HIGH);
        break;
#endif  // AP_GPS_ENABLED

#if AP_AIRSPEED_ENABLED
    case AUX_FUNC::DISABLE_AIRSPEED_USE: {
        AP_Airspeed *airspeed = AP::airspeed();
        if (airspeed == nullptr) {
            break;
        }
        switch (ch_flag) {
        case AuxSwitchPos::HIGH:
            airspeed->force_disable_use(true);
            break;
        case AuxSwitchPos::MIDDLE:
            break;
        case AuxSwitchPos::LOW:
            airspeed->force_disable_use(false);
            break;
        }
        break;
    }
#endif

    case AUX_FUNC::MOTOR_ESTOP:
        switch (ch_flag) {
        case AuxSwitchPos::HIGH: {
            SRV_Channels::set_emergency_stop(true);
            break;
        }
        case AuxSwitchPos::MIDDLE:
            // nothing
            break;
        case AuxSwitchPos::LOW: {
            SRV_Channels::set_emergency_stop(false);
            break;
        }
        }
        break;

#if HAL_VISUALODOM_ENABLED
    case AUX_FUNC::VISODOM_ALIGN:
        if (ch_flag == AuxSwitchPos::HIGH) {
            AP_VisualOdom *visual_odom = AP::visualodom();
            if (visual_odom != nullptr) {
                visual_odom->request_align_yaw_to_ahrs();
            }
        }
        break;
#endif

    case AUX_FUNC::EKF_POS_SOURCE: {
        uint8_t source_set = 0;
        switch (ch_flag) {
        case AuxSwitchPos::LOW:
            // low switches to primary source
            source_set = 0;
            break;
        case AuxSwitchPos::MIDDLE:
            // middle switches to secondary source
            source_set = 1;
            break;
        case AuxSwitchPos::HIGH:
            // high switches to tertiary source
            source_set = 2;
            break;
        }
        AP::ahrs().set_posvelyaw_source_set(source_set);
        GCS_SEND_TEXT(MAV_SEVERITY_INFO, "Using EKF Source Set %u", source_set+1);
        break;
    }

#if AP_OPTICALFLOW_CALIBRATOR_ENABLED
    case AUX_FUNC::OPTFLOW_CAL: {
        AP_OpticalFlow *optflow = AP::opticalflow();
        if (optflow == nullptr) {
            GCS_SEND_TEXT(MAV_SEVERITY_CRITICAL, "OptFlow Cal: failed sensor not enabled");
            break;
        }
        if (ch_flag == AuxSwitchPos::HIGH) {
            optflow->start_calibration();
        } else {
            optflow->stop_calibration();
        }
        break;
    }
#endif

#if AP_INERTIALSENSOR_KILL_IMU_ENABLED
    case AUX_FUNC::KILL_IMU1:
        AP::ins().kill_imu(0, ch_flag == AuxSwitchPos::HIGH);
        break;

    case AUX_FUNC::KILL_IMU2:
        AP::ins().kill_imu(1, ch_flag == AuxSwitchPos::HIGH);
        break;

    case AUX_FUNC::KILL_IMU3:
        AP::ins().kill_imu(2, ch_flag == AuxSwitchPos::HIGH);
        break;
#endif  // AP_INERTIALSENSOR_KILL_IMU_ENABLED

#if AP_CAMERA_ENABLED
    case AUX_FUNC::CAMERA_TRIGGER:
        do_aux_function_camera_trigger(ch_flag);
        break;

    case AUX_FUNC::CAM_MODE_TOGGLE: {
        // Momentary switch to for cycling camera modes
        AP_Camera *camera = AP_Camera::get_singleton();
        if (camera == nullptr) {
            break;
        }
        switch (ch_flag) {
        case AuxSwitchPos::LOW:
            // nothing
            break;
        case AuxSwitchPos::MIDDLE:
            // nothing
            break;
        case AuxSwitchPos::HIGH:
            camera->cam_mode_toggle();
            break;
        }
        break;
    }
    case AUX_FUNC::CAMERA_REC_VIDEO:
        return do_aux_function_record_video(ch_flag);

    case AUX_FUNC::CAMERA_ZOOM:
        return do_aux_function_camera_zoom(ch_flag);

    case AUX_FUNC::CAMERA_MANUAL_FOCUS:
        return do_aux_function_camera_manual_focus(ch_flag);

    case AUX_FUNC::CAMERA_AUTO_FOCUS:
        return do_aux_function_camera_auto_focus(ch_flag);

    case AUX_FUNC::CAMERA_IMAGE_TRACKING:
        return do_aux_function_camera_image_tracking(ch_flag);

#if AP_CAMERA_SET_CAMERA_SOURCE_ENABLED
    case AUX_FUNC::CAMERA_LENS:
        return do_aux_function_camera_lens(ch_flag);
#endif // AP_CAMERA_SET_CAMERA_SOURCE_ENABLED
#endif // AP_CAMERA_ENABLED

#if HAL_MOUNT_ENABLED
    case AUX_FUNC::RETRACT_MOUNT1:
        do_aux_function_retract_mount(ch_flag, 0);
        break;

    case AUX_FUNC::RETRACT_MOUNT2:
        do_aux_function_retract_mount(ch_flag, 1);
        break;

    case AUX_FUNC::MOUNT_LOCK: {
        AP_Mount *mount = AP::mount();
        if (mount == nullptr) {
            break;
        }
        mount->set_yaw_lock(ch_flag == AuxSwitchPos::HIGH);
        break;
    }

    case AUX_FUNC::MOUNT_LRF_ENABLE: {
        AP_Mount *mount = AP::mount();
        if (mount == nullptr) {
            break;
        }
        mount->set_rangefinder_enable(0, ch_flag == AuxSwitchPos::HIGH);
        break;
    }
#endif

#if HAL_LOGGING_ENABLED
    case AUX_FUNC::LOG_PAUSE: {
        AP_Logger *logger = AP_Logger::get_singleton();
        switch (ch_flag) {
        case AuxSwitchPos::LOW:
            logger->log_pause(false);
            break;
        case AuxSwitchPos::MIDDLE:
            // nothing
            break;
        case AuxSwitchPos::HIGH:
            logger->log_pause(true);
            break;
        }
        break;
    }
#endif

#if COMPASS_CAL_ENABLED
    case AUX_FUNC::MAG_CAL: {
        Compass &compass = AP::compass();
        switch (ch_flag) {
        case AuxSwitchPos::LOW:
            compass.cancel_calibration_all();
            break;
        case AuxSwitchPos::MIDDLE:
            // nothing
            break;
        case AuxSwitchPos::HIGH:
            if (!hal.util->get_soft_armed()) {
                const bool retry = true;
                const bool autosave = true;
                const float delay = 5.0;
                const bool autoreboot = false;
                compass.start_calibration_all(retry, autosave, delay, autoreboot);
            } else {
                GCS_SEND_TEXT(MAV_SEVERITY_NOTICE, "Disarm to allow compass calibration");
            }
            break;
        }
        break;
    }
#endif

    case AUX_FUNC::ARM_EMERGENCY_STOP: {
        switch (ch_flag) {
        case AuxSwitchPos::HIGH:
            // request arm, disable emergency motor stop
            SRV_Channels::set_emergency_stop(false);
            AP::arming().arm(AP_Arming::Method::AUXSWITCH, true);
            break;
        case AuxSwitchPos::MIDDLE:
            // disable emergency motor stop
            SRV_Channels::set_emergency_stop(false);
            break;
        case AuxSwitchPos::LOW:
            // enable emergency motor stop
            SRV_Channels::set_emergency_stop(true);
            break;
        }
        break;
    }

    case AUX_FUNC::EKF_LANE_SWITCH:
        // used to test emergency lane switch
        AP::ahrs().check_lane_switch();
        break;

    case AUX_FUNC::EKF_YAW_RESET:
        // used to test emergency yaw reset
        AP::ahrs().request_yaw_reset();
        break;

    case AUX_FUNC::AHRS_TYPE: {
#if HAL_NAVEKF3_AVAILABLE && HAL_EXTERNAL_AHRS_ENABLED
        AP::ahrs().set_ekf_type(ch_flag==AuxSwitchPos::HIGH? AP_AHRS::EKFType::EXTERNAL : AP_AHRS::EKFType::THREE);
#endif
        break;
    }
        

#if HAL_TORQEEDO_ENABLED
    // clear torqeedo error
    case AUX_FUNC::TORQEEDO_CLEAR_ERR: {
        if (ch_flag == AuxSwitchPos::HIGH) {
            AP_Torqeedo *torqeedo = AP_Torqeedo::get_singleton();
            if (torqeedo != nullptr) {
                torqeedo->clear_motor_error();
            }
        }
        break;
    }
#endif

    // do nothing for these functions
    case AUX_FUNC::MOUNT1_ROLL:
    case AUX_FUNC::MOUNT1_PITCH:
    case AUX_FUNC::MOUNT1_YAW:
    case AUX_FUNC::MOUNT2_ROLL:
    case AUX_FUNC::MOUNT2_PITCH:
    case AUX_FUNC::MOUNT2_YAW:
    case AUX_FUNC::SCRIPTING_1:
    case AUX_FUNC::SCRIPTING_2:
    case AUX_FUNC::SCRIPTING_3:
    case AUX_FUNC::SCRIPTING_4:
    case AUX_FUNC::SCRIPTING_5:
    case AUX_FUNC::SCRIPTING_6:
    case AUX_FUNC::SCRIPTING_7:
    case AUX_FUNC::SCRIPTING_8:
        break;

    case AUX_FUNC::LOWEHEISER_THROTTLE:
    case AUX_FUNC::LOWEHEISER_STARTER:
        // monitored by the library itself
        break;

    default:
        GCS_SEND_TEXT(MAV_SEVERITY_INFO, "Invalid channel option (%u)", (unsigned int)ch_option);
        return false;
    }

    return true;
}

void RC_Channel::init_aux()
{
    AuxSwitchPos position;
    if (!read_3pos_switch(position)) {
        position = AuxSwitchPos::LOW;
    }
    init_aux_function((AUX_FUNC)option.get(), position);
}

// read_3pos_switch
bool RC_Channel::read_3pos_switch(RC_Channel::AuxSwitchPos &ret) const
{
    const uint16_t in = get_radio_in();
    if (in <= RC_MIN_LIMIT_PWM || in >= RC_MAX_LIMIT_PWM) {
        return false;
    }

    // switch is reversed if 'reversed' option set on channel and switches reverse is allowed by RC_OPTIONS
    bool switch_reversed = reversed && rc().option_is_enabled(RC_Channels::Option::ALLOW_SWITCH_REV);

    if (in < AUX_SWITCH_PWM_TRIGGER_LOW) {
        ret = switch_reversed ? AuxSwitchPos::HIGH : AuxSwitchPos::LOW;
    } else if (in > AUX_SWITCH_PWM_TRIGGER_HIGH) {
        ret = switch_reversed ? AuxSwitchPos::LOW : AuxSwitchPos::HIGH;
    } else {
        ret = AuxSwitchPos::MIDDLE;
    }
    return true;
}

// return switch position value as LOW, MIDDLE, HIGH
// if reading the switch fails then it returns LOW
RC_Channel::AuxSwitchPos RC_Channel::get_aux_switch_pos() const
{
    AuxSwitchPos position = AuxSwitchPos::LOW;
    UNUSED_RESULT(read_3pos_switch(position));

    return position;
}

// return switch position value as LOW, MIDDLE, HIGH
// if reading the switch fails then it returns LOW
RC_Channel::AuxSwitchPos RC_Channels::get_channel_pos(const uint8_t rcmapchan) const
{
    const RC_Channel* chan = rc().channel(rcmapchan-1);
    return chan != nullptr ? chan->get_aux_switch_pos() : RC_Channel::AuxSwitchPos::LOW;
}

RC_Channel *RC_Channels::find_channel_for_option(const RC_Channel::AUX_FUNC option)
{
    for (uint8_t i=0; i<NUM_RC_CHANNELS; i++) {
        RC_Channel *c = channel(i);
        if (c == nullptr) {
            // odd?
            continue;
        }
        if ((RC_Channel::AUX_FUNC)c->option.get() == option) {
            return c;
        }
    }
    return nullptr;
}

// duplicate_options_exist - returns true if any options are duplicated
bool RC_Channels::duplicate_options_exist()
{
    Bitmask<(uint16_t)RC_Channel::AUX_FUNC::AUX_FUNCTION_MAX> used_auxsw_options;
    for (uint8_t i=0; i<NUM_RC_CHANNELS; i++) {
        const RC_Channel *c = channel(i);
        if (c == nullptr) {
            // odd?
            continue;
        }
        const uint16_t option = c->option.get();
        if (option == (uint16_t)RC_Channel::AUX_FUNC::DO_NOTHING) {
            continue;
        }
        if (option >= used_auxsw_options.size()) {
            continue;
        }
        if (used_auxsw_options.get(option)) {
            return true;
        }
        used_auxsw_options.set(option);
    }
    return false;
}

// convert option parameter from old to new
void RC_Channels::convert_options(const RC_Channel::AUX_FUNC old_option, const RC_Channel::AUX_FUNC new_option)
{
    for (uint8_t i=0; i<NUM_RC_CHANNELS; i++) {
        RC_Channel *c = channel(i);
        if (c == nullptr) {
            // odd?
            continue;
        }
        if ((RC_Channel::AUX_FUNC)c->option.get() == old_option) {
            c->option.set_and_save((int16_t)new_option);
        }
    }
}

#endif  // AP_RC_CHANNEL_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                    /// @file	RC_Channel.h
/// @brief	RC_Channel manager, with EEPROM-backed storage of constants.
#pragma once

#include "RC_Channel_config.h"

#if AP_RC_CHANNEL_ENABLED

#include <AP_Common/AP_Common.h>
#include <AP_Param/AP_Param.h>
#include <AP_Math/AP_Math.h>
#include <AP_Common/Bitmask.h>

#define NUM_RC_CHANNELS 16

/// @class	RC_Channel
/// @brief	Object managing one RC channel
class RC_Channel {
public:
    friend class RC_Channels;
    // Constructor
    RC_Channel(void);

    enum class ControlType {
        ANGLE = 0,
        RANGE = 1,
    };

    // setup the control preferences
    void        set_range(uint16_t high);
    uint16_t    get_range() const { return high_in; }
    void        set_angle(uint16_t angle);
    bool        get_reverse(void) const;
    void        set_default_dead_zone(int16_t dzone);
    uint16_t    get_dead_zone(void) const { return dead_zone; }

    // get the center stick position expressed as a control_in value
    int16_t     get_control_mid() const;

    // read input from hal.rcin - create a control_in value
    bool        update(void);

    // calculate an angle given dead_zone and trim. This is used by the quadplane code
    // for hover throttle
    int16_t     pwm_to_angle_dz_trim(uint16_t dead_zone, uint16_t trim) const;

    // return a normalised input for a channel, in range -1 to 1,
    // centered around the channel trim. Ignore deadzone.
    float       norm_input() const;

    // return a normalised input for a channel, in range -1 to 1,
    // centered around the channel trim. Take into account the deadzone
    float       norm_input_dz() const;

    // return a normalised input for a channel, in range -1 to 1,
    // ignores trim and deadzone
    float       norm_input_ignore_trim() const;

    // returns true if input is within deadzone of min
    bool        in_min_dz() const;

    uint8_t     percent_input() const;

    static const struct AP_Param::GroupInfo var_info[];

    // return true if input is within deadzone of trim
    bool       in_trim_dz() const;

    int16_t    get_radio_in() const { return radio_in;}
    void       set_radio_in(int16_t val) {radio_in = val;}

    int16_t    get_control_in() const { return control_in;}
    void       set_control_in(int16_t val) { control_in = val;}

    void       clear_override();
    void       set_override(const uint16_t v, const uint32_t timestamp_ms);
    bool       has_override() const;

    float    stick_mixing(const float servo_in);

    // get control input with zero deadzone
    int16_t    get_control_in_zero_dz(void) const;

    int16_t    get_radio_min() const {return radio_min.get();}

    int16_t    get_radio_max() const {return radio_max.get();}

    int16_t    get_radio_trim() const { return radio_trim.get();}

    void       set_and_save_trim() { radio_trim.set_and_save_ifchanged(radio_in);}

    // set and save trim if changed
    void       set_and_save_radio_trim(int16_t val) { radio_trim.set_and_save_ifchanged(val);}

    // check if any of the trim/min/max param are configured, this would indicate that the user has done a calibration at somepoint
    bool       configured() { return radio_min.configured() || radio_max.configured() || radio_trim.configured(); }

    ControlType get_type(void) const { return type_in; }

    AP_Int16    option; // e.g. activate EPM gripper / enable fence

    // auxiliary switch support
    void init_aux();
    bool read_aux();

    // Aux Switch enumeration
    enum class AUX_FUNC {
        DO_NOTHING =           0, // aux switch disabled
        FLIP =                 2, // flip
        SIMPLE_MODE =          3, // change to simple mode
        RTL =                  4, // change to RTL flight mode
        SAVE_TRIM =            5, // save current position as level
        SAVE_WP =              7, // save mission waypoint or RTL if in auto mode
        CAMERA_TRIGGER =       9, // trigger camera servo or relay
        RANGEFINDER =         10, // allow enabling or disabling rangefinder in flight which helps avoid surface tracking when you are far above the ground
        FENCE =               11, // allow enabling or disabling fence in flight
        RESETTOARMEDYAW =     12, // UNUSED
        SUPERSIMPLE_MODE =    13, // change to simple mode in middle, super simple at top
        ACRO_TRAINER =        14, // low = disabled, middle = leveled, high = leveled and limited
        SPRAYER =             15, // enable/disable the crop sprayer
        AUTO =                16, // change to auto flight mode
        AUTOTUNE_MODE =       17, // auto tune
        LAND =                18, // change to LAND flight mode
        GRIPPER =             19, // Operate cargo grippers low=off, middle=neutral, high=on
        PARACHUTE_ENABLE  =   21, // Parachute enable/disable
        PARACHUTE_RELEASE =   22, // Parachute release
        PARACHUTE_3POS =      23, // Parachute disable, enable, release with 3 position switch
        MISSION_RESET =       24, // Reset auto mission to start from first command
        ATTCON_FEEDFWD =      25, // enable/disable the roll and pitch rate feed forward
        ATTCON_ACCEL_LIM =    26, // enable/disable the roll, pitch and yaw accel limiting
        RETRACT_MOUNT1 =      27, // Retract Mount1
        RELAY =               28, // Relay pin on/off (only supports first relay)
        LANDING_GEAR =        29, // Landing gear controller
        LOST_VEHICLE_SOUND =  30, // Play lost vehicle sound
        MOTOR_ESTOP =         31, // Emergency Stop Switch
        MOTOR_INTERLOCK =     32, // Motor On/Off switch
        BRAKE =               33, // Brake flight mode
        RELAY2 =              34, // Relay2 pin on/off
        RELAY3 =              35, // Relay3 pin on/off
        RELAY4 =              36, // Relay4 pin on/off
        THROW =               37, // change to THROW flight mode
        AVOID_ADSB =          38, // enable AP_Avoidance library
        PRECISION_LOITER =    39, // enable precision loiter
        AVOID_PROXIMITY =     40, // enable object avoidance using proximity sensors (ie. horizontal lidar)
        ARMDISARM_UNUSED =    41, // UNUSED
        SMART_RTL =           42, // change to SmartRTL flight mode
        INVERTED  =           43, // enable inverted flight
        WINCH_ENABLE =        44, // winch enable/disable
        WINCH_CONTROL =       45, // winch control
        RC_OVERRIDE_ENABLE =  46, // enable RC Override
        USER_FUNC1 =          47, // user function #1
        USER_FUNC2 =          48, // user function #2
        USER_FUNC3 =          49, // user function #3
        LEARN_CRUISE =        50, // learn cruise throttle (Rover)
        MANUAL       =        51, // manual mode
        ACRO         =        52, // acro mode
        STEERING     =        53, // steering mode
        HOLD         =        54, // hold mode
        GUIDED       =        55, // guided mode
        LOITER       =        56, // loiter mode
        FOLLOW       =        57, // follow mode
        CLEAR_WP     =        58, // clear waypoints
        SIMPLE       =        59, // simple mode
        ZIGZAG       =        60, // zigzag mode
        ZIGZAG_SaveWP =       61, // zigzag save waypoint
        COMPASS_LEARN =       62, // learn compass offsets
        SAILBOAT_TACK =       63, // rover sailboat tack
        REVERSE_THROTTLE =    64, // reverse throttle input
        GPS_DISABLE  =        65, // disable GPS for testing
        RELAY5 =              66, // Relay5 pin on/off
        RELAY6 =              67, // Relay6 pin on/off
        STABILIZE =           68, // stabilize mode
        POSHOLD   =           69, // poshold mode
        ALTHOLD   =           70, // althold mode
        FLOWHOLD  =           71, // flowhold mode
        CIRCLE    =           72, // circle mode
        DRIFT     =           73, // drift mode
        SAILBOAT_MOTOR_3POS = 74, // Sailboat motoring 3pos
        SURFACE_TRACKING =    75, // Surface tracking upwards or downwards
        STANDBY  =            76, // Standby mode
        TAKEOFF   =           77, // takeoff
        RUNCAM_CONTROL =      78, // control RunCam device
        RUNCAM_OSD_CONTROL =  79, // control RunCam OSD
        VISODOM_ALIGN =       80, // align visual odometry camera's attitude to AHRS
        DISARM =              81, // disarm vehicle
        Q_ASSIST =            82, // disable, enable and force Q assist
        ZIGZAG_Auto =         83, // zigzag auto switch
        AIRMODE =             84, // enable / disable airmode for copter
        GENERATOR   =         85, // generator control
        TER_DISABLE =         86, // disable terrain following in CRUISE/FBWB modes
        CROW_SELECT =         87, // select CROW mode for diff spoilers;high disables,mid forces progressive
        SOARING =             88, // three-position switch to set soaring mode
        LANDING_FLARE =       89, // force flare, throttle forced idle, pitch to LAND_PITCH_DEG, tilts up
        EKF_POS_SOURCE =      90, // change EKF position source between primary, secondary and tertiary sources
        ARSPD_CALIBRATE=      91, // calibrate airspeed ratio 
        FBWA =                92, // Fly-By-Wire-A
        RELOCATE_MISSION =    93, // used in separate branch MISSION_RELATIVE
        VTX_POWER =           94, // VTX power level
        FBWA_TAILDRAGGER =    95, // enables FBWA taildragger takeoff mode. Once this feature is enabled it will stay enabled until the aircraft goes above TKOFF_TDRAG_SPD1 airspeed, changes mode, or the pitch goes above the initial pitch when this is engaged or goes below 0 pitch. When enabled the elevator will be forced to TKOFF_TDRAG_ELEV. This option allows for easier takeoffs on taildraggers in FBWA mode, and also makes it easier to test auto-takeoff steering handling in FBWA.
        MODE_SWITCH_RESET =   96, // trigger re-reading of mode switch
        WIND_VANE_DIR_OFSSET= 97, // flag for windvane direction offset input, used with windvane type 2
        TRAINING            = 98, // mode training
        AUTO_RTL =            99, // AUTO RTL via DO_LAND_START

        // entries from 100-150  are expected to be developer
        // options used for testing
        KILL_IMU1 =          100, // disable first IMU (for IMU failure testing)
        KILL_IMU2 =          101, // disable second IMU (for IMU failure testing)
        CAM_MODE_TOGGLE =    102, // Momentary switch to cycle camera modes
        EKF_LANE_SWITCH =    103, // trigger lane switch attempt
        EKF_YAW_RESET =      104, // trigger yaw reset attempt
        GPS_DISABLE_YAW =    105, // disable GPS yaw for testing
        DISABLE_AIRSPEED_USE = 106, // equivalent to AIRSPEED_USE 0
        FW_AUTOTUNE =          107, // fixed wing auto tune
        QRTL =               108, // QRTL mode
        CUSTOM_CONTROLLER =  109,  // use Custom Controller
        KILL_IMU3 =          110, // disable third IMU (for IMU failure testing)
        LOWEHEISER_STARTER = 111,  // allows for manually running starter
        AHRS_TYPE =          112, // change AHRS_EKF_TYPE
        RETRACT_MOUNT2 =     113, // Retract Mount2

        // if you add something here, make sure to update the documentation of the parameter in RC_Channel.cpp!
        // also, if you add an option >255, you will need to fix duplicate_options_exist

        // options 150-199 continue user rc switch options
        CRUISE =             150,  // CRUISE mode
        TURTLE =             151,  // Turtle mode - flip over after crash
        SIMPLE_HEADING_RESET = 152, // reset simple mode reference heading to current
        ARMDISARM =          153, // arm or disarm vehicle
        ARMDISARM_AIRMODE =  154, // arm or disarm vehicle enabling airmode
        TRIM_TO_CURRENT_SERVO_RC = 155, // trim to current servo and RC
        TORQEEDO_CLEAR_ERR = 156, // clear torqeedo error
        EMERGENCY_LANDING_EN = 157, //Force long FS action to FBWA for landing out of range
        OPTFLOW_CAL =        158, // optical flow calibration
        FORCEFLYING =        159, // enable or disable land detection for GPS based manual modes preventing land detection and maintainting set_throttle_mix_max
        WEATHER_VANE_ENABLE = 160, // enable/disable weathervaning
        TURBINE_START =      161, // initialize turbine start sequence
        FFT_NOTCH_TUNE =     162, // FFT notch tuning function
        MOUNT_LOCK =         163, // Mount yaw lock vs follow
        LOG_PAUSE =          164, // Pauses logging if under logging rate control
        ARM_EMERGENCY_STOP = 165, // ARM on high, MOTOR_ESTOP on low
        CAMERA_REC_VIDEO =   166, // start recording on high, stop recording on low
        CAMERA_ZOOM =        167, // camera zoom high = zoom in, middle = hold, low = zoom out
        CAMERA_MANUAL_FOCUS = 168,// camera manual focus.  high = long shot, middle = stop focus, low = close shot
        CAMERA_AUTO_FOCUS =  169, // camera auto focus
        QSTABILIZE =         170, // QuadPlane QStabilize mode
        MAG_CAL =            171, // Calibrate compasses (disarmed only)
        BATTERY_MPPT_ENABLE = 172,// Battery MPPT Power enable. high = ON, mid = auto (controlled by mppt/batt driver), low = OFF. This effects all MPPTs.
        PLANE_AUTO_LANDING_ABORT = 173, // Abort Glide-slope or VTOL landing during payload place or do_land type mission items
        CAMERA_IMAGE_TRACKING = 174, // camera image tracking
        CAMERA_LENS =        175, // camera lens selection
        VFWD_THR_OVERRIDE =  176, // force enabled VTOL forward throttle method
        MOUNT_LRF_ENABLE =   177,  // mount LRF enable/disable
        FLIGHTMODE_PAUSE =   178,  // e.g. pause movement towards waypoint
        AUTOTUNE_TEST_GAINS = 180, // auto tune tuning switch to test or revert gains


        // inputs from 200 will eventually used to replace RCMAP
        ROLL =               201, // roll input
        PITCH =              202, // pitch input
        THROTTLE =           203, // throttle pilot input
        YAW =                204, // yaw pilot input
        MAINSAIL =           207, // mainsail input
        FLAP =               208, // flap input
        FWD_THR =            209, // VTOL manual forward throttle
        AIRBRAKE =           210, // manual airbrake control
        WALKING_HEIGHT =     211, // walking robot height input
        MOUNT1_ROLL =        212, // mount1 roll input
        MOUNT1_PITCH =       213, // mount1 pitch input
        MOUNT1_YAW =         214, // mount1 yaw input
        MOUNT2_ROLL =        215, // mount2 roll input
        MOUNT2_PITCH =       216, // mount3 pitch input
        MOUNT2_YAW =         217, // mount4 yaw input
        LOWEHEISER_THROTTLE= 218,  // allows for throttle on slider
        TRANSMITTER_TUNING = 219, // use a transmitter knob or slider for in-flight tuning

        // inputs 248-249 are reserved for the Skybrush fork at
        // https://github.com/skybrush-io/ardupilot

        // inputs for the use of onboard lua scripting
        SCRIPTING_1 =        300,
        SCRIPTING_2 =        301,
        SCRIPTING_3 =        302,
        SCRIPTING_4 =        303,
        SCRIPTING_5 =        304,
        SCRIPTING_6 =        305,
        SCRIPTING_7 =        306,
        SCRIPTING_8 =        307,

        // this must be higher than any aux function above
        AUX_FUNCTION_MAX =   308,
    };

    // auxiliary switch handling (n.b.: we store this as 2-bits!):
    enum class AuxSwitchPos : uint8_t {
        LOW,       // indicates auxiliary switch is in the low position (pwm <1200)
        MIDDLE,    // indicates auxiliary switch is in the middle position (pwm >1200, <1800)
        HIGH       // indicates auxiliary switch is in the high position (pwm >1800)
    };

    enum class AuxFuncTriggerSource : uint8_t {
        INIT,
        RC,
        BUTTON,
        MAVLINK,
        MISSION,
        SCRIPTING,
    };

    AuxSwitchPos get_aux_switch_pos() const;

    // wrapper function around do_aux_function which allows us to log
    bool run_aux_function(AUX_FUNC ch_option, AuxSwitchPos pos, AuxFuncTriggerSource source);

#if AP_RC_CHANNEL_AUX_FUNCTION_STRINGS_ENABLED
    const char *string_for_aux_function(AUX_FUNC function) const;
    const char *string_for_aux_pos(AuxSwitchPos pos) const;
#endif
    // pwm value under which we consider that Radio value is invalid
    static const uint16_t RC_MIN_LIMIT_PWM = 800;
    // pwm value above which we consider that Radio value is invalid
    static const uint16_t RC_MAX_LIMIT_PWM = 2200;

    // pwm value above which we condider that Radio min value is invalid
    static const uint16_t RC_CALIB_MIN_LIMIT_PWM = 1300;
    // pwm value under which we condider that Radio max value is invalid
    static const uint16_t RC_CALIB_MAX_LIMIT_PWM = 1700;

    // pwm value above which the switch/button will be invoked:
    static const uint16_t AUX_SWITCH_PWM_TRIGGER_HIGH = 1800;
    // pwm value below which the switch/button will be disabled:
    static const uint16_t AUX_SWITCH_PWM_TRIGGER_LOW = 1200;

    // pwm value above which the option will be invoked:
    static const uint16_t AUX_PWM_TRIGGER_HIGH = 1700;
    // pwm value below which the option will be disabled:
    static const uint16_t AUX_PWM_TRIGGER_LOW = 1300;

protected:

    virtual void init_aux_function(AUX_FUNC ch_option, AuxSwitchPos);

    // virtual function to be overridden my subclasses
    virtual bool do_aux_function(AUX_FUNC ch_option, AuxSwitchPos);

    void do_aux_function_armdisarm(const AuxSwitchPos ch_flag);
    void do_aux_function_avoid_adsb(const AuxSwitchPos ch_flag);
    void do_aux_function_avoid_proximity(const AuxSwitchPos ch_flag);
    void do_aux_function_camera_trigger(const AuxSwitchPos ch_flag);
    bool do_aux_function_record_video(const AuxSwitchPos ch_flag);
    bool do_aux_function_camera_zoom(const AuxSwitchPos ch_flag);
    bool do_aux_function_camera_manual_focus(const AuxSwitchPos ch_flag);
    bool do_aux_function_camera_auto_focus(const AuxSwitchPos ch_flag);
    bool do_aux_function_camera_image_tracking(const AuxSwitchPos ch_flag);
    bool do_aux_function_camera_lens(const AuxSwitchPos ch_flag);
    void do_aux_function_runcam_control(const AuxSwitchPos ch_flag);
    void do_aux_function_runcam_osd_control(const AuxSwitchPos ch_flag);
    void do_aux_function_fence(const AuxSwitchPos ch_flag);
    void do_aux_function_clear_wp(const AuxSwitchPos ch_flag);
    void do_aux_function_gripper(const AuxSwitchPos ch_flag);
    void do_aux_function_lost_vehicle_sound(const AuxSwitchPos ch_flag);
    void do_aux_function_mission_reset(const AuxSwitchPos ch_flag);
    void do_aux_function_rc_override_enable(const AuxSwitchPos ch_flag);
    void do_aux_function_relay(uint8_t relay, bool val);
    void do_aux_function_sprayer(const AuxSwitchPos ch_flag);
    void do_aux_function_generator(const AuxSwitchPos ch_flag);
    void do_aux_function_fft_notch_tune(const AuxSwitchPos ch_flag);
    void do_aux_function_retract_mount(const AuxSwitchPos ch_flag, const uint8_t instance);

    typedef int8_t modeswitch_pos_t;
    virtual void mode_switch_changed(modeswitch_pos_t new_pos) {
        // no action by default (e.g. Tracker, Sub, who do their own thing)
    };


private:

    // pwm is stored here
    int16_t     radio_in;

    // value generated from PWM normalised to configured scale
    int16_t    control_in;

    AP_Int16    radio_min;
    AP_Int16    radio_trim;
    AP_Int16    radio_max;

    AP_Int8     reversed;
    AP_Int16    dead_zone;

    ControlType type_in;
    int16_t     high_in;

    // the input channel this corresponds to
    uint8_t     ch_in;

    // overrides
    uint16_t override_value;
    uint32_t last_override_time;

    int16_t pwm_to_angle() const;
    int16_t pwm_to_angle_dz(uint16_t dead_zone) const;

    int16_t pwm_to_range() const;
    int16_t pwm_to_range_dz(uint16_t dead_zone) const;

    bool read_3pos_switch(AuxSwitchPos &ret) const WARN_IF_UNUSED;
    bool read_6pos_switch(int8_t& position) WARN_IF_UNUSED;

    // Structure used to detect and debounce switch changes
    struct {
        int8_t debounce_position = -1;
        int8_t current_position = -1;
        uint32_t last_edge_time_ms;
        bool initialised;
    } switch_state;

    void reset_mode_switch();
    void read_mode_switch();
    bool debounce_completed(int8_t position);
    // returns true if the first time we successfully read the
    // channel's three-position-switch position we should record that
    // position as the current position *without* executing the
    // associated auxiliary function.  e.g. do not attempt to arm a
    // vehicle when the user turns on their transmitter with the arm
    // switch high!
    bool init_position_on_first_radio_read(AUX_FUNC func) const;

#if AP_RC_CHANNEL_AUX_FUNCTION_STRINGS_ENABLED
    // Structure to lookup switch change announcements
    struct LookupTable{
       AUX_FUNC option;
       const char *announcement;
    };

    static const LookupTable lookuptable[];
#endif
};


/*
  class	RC_Channels. Hold the full set of RC_Channel objects
*/
class RC_Channels {
public:
    friend class SRV_Channels;
    friend class RC_Channel;
    // constructor
    RC_Channels(void);

    void init(void);

    // get singleton instance
    static RC_Channels *get_singleton() {
        return _singleton;
    }

    static const struct AP_Param::GroupInfo var_info[];

    // compatability functions for Plane:
    static uint16_t get_radio_in(const uint8_t chan) {
        RC_Channel *c = _singleton->channel(chan);
        if (c == nullptr) {
            return 0;
        }
        return c->get_radio_in();
    }
    static RC_Channel *rc_channel(const uint8_t chan) {
        return _singleton->channel(chan);
    }
    //end compatability functions for Plane

    // this function is implemented in the child class in the vehicle
    // code
    virtual RC_Channel *channel(uint8_t chan) = 0;
    // helper used by scripting to convert the above function from 0 to 1 indexeing
    // range is checked correctly by the underlying channel function
    RC_Channel *lua_rc_channel(const uint8_t chan) {
        return channel(chan -1);
    }

    uint8_t get_radio_in(uint16_t *chans, const uint8_t num_channels); // reads a block of chanel radio_in values starting from channel 0
                                                                       // returns the number of valid channels

    static uint8_t get_valid_channel_count(void);                      // returns the number of valid channels in the last read
    static int16_t get_receiver_rssi(void);                            // returns [0, 255] for receiver RSSI (0 is no link) if present, otherwise -1
    static int16_t get_receiver_link_quality(void);                         // returns 0-100 % of last 100 packets received at receiver are valid
    bool read_input(void);                                             // returns true if new input has been read in
    static void clear_overrides(void);                                 // clears any active overrides
    static bool receiver_bind(const int dsmMode);                      // puts the receiver in bind mode if present, returns true if success
    static void set_override(const uint8_t chan, const int16_t value, const uint32_t timestamp_ms = 0); // set a channels override value
    static bool has_active_overrides(void);                            // returns true if there are overrides applied that are valid

    // returns a mask indicating which channels have overrides.  Bit 0
    // is RC channel 1.  Beware this is not a cheap call.
    uint16_t get_override_mask() const;

    class RC_Channel *find_channel_for_option(const RC_Channel::AUX_FUNC option);
    bool duplicate_options_exist();
    RC_Channel::AuxSwitchPos get_channel_pos(const uint8_t rcmapchan) const;
    void convert_options(const RC_Channel::AUX_FUNC old_option, const RC_Channel::AUX_FUNC new_option);

    void init_aux_all();
    void read_aux_all();

    // mode switch handling
    void reset_mode_switch();
    virtual void read_mode_switch();

    virtual bool in_rc_failsafe() const { return true; };
    virtual bool has_valid_input() const { return false; };

    virtual RC_Channel *get_arming_channel(void) const { return nullptr; };

    bool gcs_overrides_enabled() const { return _gcs_overrides_enabled; }
    void set_gcs_overrides_enabled(bool enable) {
        _gcs_overrides_enabled = enable;
        if (!_gcs_overrides_enabled) {
            clear_overrides();
        }
    }

    enum class Option {
        IGNORE_RECEIVER         = (1U << 0), // RC receiver modules
        IGNORE_OVERRIDES        = (1U << 1), // MAVLink overrides
        IGNORE_FAILSAFE         = (1U << 2), // ignore RC failsafe bits
        FPORT_PAD               = (1U << 3), // pad fport telem output
        LOG_RAW_DATA            = (1U << 4), // log rc input bytes
        ARMING_CHECK_THROTTLE   = (1U << 5), // run an arming check for neutral throttle
        ARMING_SKIP_CHECK_RPY   = (1U << 6), // skip the an arming checks for the roll/pitch/yaw channels
        ALLOW_SWITCH_REV        = (1U << 7), // honor the reversed flag on switches
        CRSF_CUSTOM_TELEMETRY   = (1U << 8), // use passthrough data for crsf telemetry
        SUPPRESS_CRSF_MESSAGE   = (1U << 9), // suppress CRSF mode/rate message for ELRS systems
        MULTI_RECEIVER_SUPPORT  = (1U << 10), // allow multiple receivers
        USE_CRSF_LQ_AS_RSSI     = (1U << 11), // returns CRSF link quality as RSSI value, instead of RSSI
        CRSF_FM_DISARM_STAR     = (1U << 12), // when disarmed, add a star at the end of the flight mode in CRSF telemetry
        ELRS_420KBAUD           = (1U << 13), // use 420kbaud for ELRS protocol
    };

    bool option_is_enabled(Option option) const {
        return _options & uint32_t(option);
    }

    virtual bool arming_check_throttle() const {
        return option_is_enabled(Option::ARMING_CHECK_THROTTLE);
    }

    // returns true if overrides should time out.  If true is returned
    // then returned_timeout_ms will contain the timeout in
    // milliseconds, with 0 meaning overrides are disabled.
    bool get_override_timeout_ms(uint32_t &returned_timeout_ms) const {
        const float value = _override_timeout.get();
        if (is_positive(value)) {
            returned_timeout_ms = uint32_t(value * 1e3f);
            return true;
        }
        if (is_zero(value)) {
            returned_timeout_ms = 0;
            return true;
        }
        // overrides will not time out
        return false;
    }

    // get mask of enabled protocols
    uint32_t enabled_protocols() const;

    // returns true if we have had a direct detach RC receiver, does not include overrides
    bool has_had_rc_receiver() const { return _has_had_rc_receiver; }

    // returns true if we have had an override on any channel
    bool has_had_rc_override() const { return _has_had_override; }

    /*
      get the RC input PWM value given a channel number.  Note that
      channel numbers start at 1, as this API is designed for use in
      LUA
    */
    bool get_pwm(uint8_t channel, uint16_t &pwm) const;

    uint32_t last_input_ms() const { return last_update_ms; };

    // method for other parts of the system (e.g. Button and mavlink)
    // to trigger auxiliary functions
    bool run_aux_function(RC_Channel::AUX_FUNC ch_option, RC_Channel::AuxSwitchPos pos, RC_Channel::AuxFuncTriggerSource source) {
        return rc_channel(0)->run_aux_function(ch_option, pos, source);
    }

    // check if flight mode channel is assigned RC option
    // return true if assigned
    bool flight_mode_channel_conflicts_with_rc_option() const;

    // flight_mode_channel_number must be overridden in vehicle specific code
    virtual int8_t flight_mode_channel_number() const = 0;

    // set and get calibrating flag, stops arming if true
    void calibrating(bool b) { gcs_is_calibrating = b; }
    bool calibrating() { return gcs_is_calibrating; }

#if AP_SCRIPTING_ENABLED
    // get last aux cached value for scripting. Returns false if never set, otherwise 0,1,2
    bool get_aux_cached(RC_Channel::AUX_FUNC aux_fn, uint8_t &pos);
#endif

    // returns true if we've ever seen RC input, via overrides or via
    // AP_RCProtocol
    bool has_ever_seen_rc_input() const {
        return _has_ever_seen_rc_input;
    }

    // get failsafe timeout in milliseconds
    uint32_t get_fs_timeout_ms() const { return MAX(_fs_timeout * 1000, 100); }

protected:

    void new_override_received() {
        has_new_overrides = true;
        _has_had_override = true;
    }

private:
    static RC_Channels *_singleton;
    // this static arrangement is to avoid static pointers in AP_Param tables
    static RC_Channel *channels;

    uint32_t last_update_ms;
    bool has_new_overrides;
    bool _has_had_rc_receiver; // true if we have had a direct detach RC receiver, does not include overrides
    bool _has_had_override; // true if we have had an override on any channel

    AP_Float _override_timeout;
    AP_Int32  _options;
    AP_Int32  _protocols;
    AP_Float _fs_timeout;

    // set to true if we see overrides or other RC input
    bool _has_ever_seen_rc_input;

    RC_Channel *flight_mode_channel() const;

    // Allow override by default at start
    bool _gcs_overrides_enabled = true;

    // true if GCS is performing a RC calibration
    bool gcs_is_calibrating;

#if AP_SCRIPTING_ENABLED
    // bitmask of last aux function value, 2 bits per function
    // value 0 means never set, otherwise level+1
    HAL_Semaphore aux_cache_sem;
    Bitmask<unsigned(RC_Channel::AUX_FUNC::AUX_FUNCTION_MAX)*2> aux_cached;

    void set_aux_cached(RC_Channel::AUX_FUNC aux_fn, RC_Channel::AuxSwitchPos pos);
#endif
};

RC_Channels &rc();

#endif  // AP_RC_CHANNEL_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         #pragma once

#include <AP_HAL/AP_HAL_Boards.h>

#ifndef AP_RC_CHANNEL_ENABLED
#define AP_RC_CHANNEL_ENABLED 1
#endif

#ifndef AP_RC_CHANNEL_AUX_FUNCTION_STRINGS_ENABLED
#define AP_RC_CHANNEL_AUX_FUNCTION_STRINGS_ENABLED AP_RC_CHANNEL_ENABLED
#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      /*
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/*
 *       RC_Channels.cpp - class containing an array of RC_Channel objects
 *
 */

#include "RC_Channel_config.h"

#if AP_RC_CHANNEL_ENABLED

#include <stdlib.h>
#include <cmath>

#include <AP_HAL/AP_HAL.h>
extern const AP_HAL::HAL& hal;

#include <AP_Math/AP_Math.h>
#include <AP_Logger/AP_Logger.h>

#include "RC_Channel.h"

/*
  channels group object constructor
 */
RC_Channels::RC_Channels(void)
{
    // set defaults from the parameter table
    AP_Param::setup_object_defaults(this, var_info);

    if (_singleton != nullptr) {
        AP_HAL::panic("RC_Channels must be singleton");
    }
    _singleton = this;
}

void RC_Channels::init(void)
{
    // setup ch_in on channels
    for (uint8_t i=0; i<NUM_RC_CHANNELS; i++) {
        channel(i)->ch_in = i;
    }

    init_aux_all();
}

uint8_t RC_Channels::get_radio_in(uint16_t *chans, const uint8_t num_channels)
{
    memset(chans, 0, num_channels*sizeof(*chans));

    const uint8_t read_channels = MIN(num_channels, NUM_RC_CHANNELS);
    for (uint8_t i = 0; i < read_channels; i++) {
        chans[i] = channel(i)->get_radio_in();
    }

    return read_channels;
}

// update all the input channels
bool RC_Channels::read_input(void)
{
    if (hal.rcin->new_input()) {
        _has_had_rc_receiver = true;
    } else if (!has_new_overrides) {
        return false;
    }

    _has_ever_seen_rc_input = true;

    has_new_overrides = false;

    last_update_ms = AP_HAL::millis();

    bool success = false;
    for (uint8_t i=0; i<NUM_RC_CHANNELS; i++) {
        success |= channel(i)->update();
    }

    return success;
}

uint8_t RC_Channels::get_valid_channel_count(void)
{
    return MIN(NUM_RC_CHANNELS, hal.rcin->num_channels());
}

int16_t RC_Channels::get_receiver_rssi(void)
{
    return hal.rcin->get_rssi();
}
int16_t RC_Channels::get_receiver_link_quality(void)
{
    return hal.rcin->get_rx_link_quality();
}
void RC_Channels::clear_overrides(void)
{
    RC_Channels &_rc = rc();
    for (uint8_t i = 0; i < NUM_RC_CHANNELS; i++) {
        _rc.channel(i)->clear_override();
    }
    // we really should set has_new_overrides to true, and rerun read_input from
    // the vehicle code however doing so currently breaks the failsafe system on
    // copter and plane, RC_Channels needs to control failsafes to resolve this
}

uint16_t RC_Channels::get_override_mask(void) const
{
    uint16_t ret = 0;
    RC_Channels &_rc = rc();
    for (uint8_t i = 0; i < NUM_RC_CHANNELS; i++) {
        if (_rc.channel(i)->has_override()) {
            ret |= (1U << i);
        }
    }
    return ret;
}

void RC_Channels::set_override(const uint8_t chan, const int16_t value, const uint32_t timestamp_ms)
{
    RC_Channels &_rc = rc();
    if (chan < NUM_RC_CHANNELS) {
        _rc.channel(chan)->set_override(value, timestamp_ms);
    }
}

bool RC_Channels::has_active_overrides()
{
    RC_Channels &_rc = rc();
    for (uint8_t i = 0; i < NUM_RC_CHANNELS; i++) {
        if (_rc.channel(i)->has_override()) {
            return true;
        }
    }

    return false;
}

bool RC_Channels::receiver_bind(const int dsmMode)
{
    return hal.rcin->rc_bind(dsmMode);
}


// support for auxiliary switches:
// read_aux_switches - checks aux switch positions and invokes configured actions
void RC_Channels::read_aux_all()
{
    if (!has_valid_input()) {
        // exit immediately when no RC input
        return;
    }
    bool need_log = false;

    for (uint8_t i=0; i<NUM_RC_CHANNELS; i++) {
        RC_Channel *c = channel(i);
        if (c == nullptr) {
            continue;
        }
        need_log |= c->read_aux();
    }
#if HAL_LOGGING_ENABLED
    if (need_log) {
        // guarantee that we log when a switch changes
        AP::logger().Write_RCIN();
    }
#endif
}

void RC_Channels::init_aux_all()
{
    for (uint8_t i=0; i<NUM_RC_CHANNELS; i++) {
        RC_Channel *c = channel(i);
        if (c == nullptr) {
            continue;
        }
        c->init_aux();
    }
    reset_mode_switch();
}

//
// Support for mode switches
//
RC_Channel *RC_Channels::flight_mode_channel() const
{
    const int8_t num = flight_mode_channel_number();
    if (num <= 0) {
        return nullptr;
    }
    if (num >= NUM_RC_CHANNELS) {
        return nullptr;
    }
    return rc_channel(num-1);
}

void RC_Channels::reset_mode_switch()
{
    RC_Channel *c = flight_mode_channel();
    if (c == nullptr) {
        return;
    }
    c->reset_mode_switch();
}

void RC_Channels::read_mode_switch()
{
    if (!has_valid_input()) {
        // exit immediately when no RC input
        return;
    }
    RC_Channel *c = flight_mode_channel();
    if (c == nullptr) {
        return;
    }
    c->read_mode_switch();
}

// check if flight mode channel is assigned RC option
// return true if assigned
bool RC_Channels::flight_mode_channel_conflicts_with_rc_option() const
{
    RC_Channel *chan = flight_mode_channel();
    if (chan == nullptr) {
        return false;
    }
    return (RC_Channel::AUX_FUNC)chan->option.get() != RC_Channel::AUX_FUNC::DO_NOTHING;
}

/*
  get the RC input PWM value given a channel number.  Note that
  channel numbers start at 1, as this API is designed for use in
  LUA
*/
bool RC_Channels::get_pwm(uint8_t c, uint16_t &pwm) const
{
    RC_Channel *chan = rc_channel(c-1);
    if (chan == nullptr) {
        return false;
    }
    int16_t pwm_signed = chan->get_radio_in();
    if (pwm_signed < 0) {
        return false;
    }
    pwm = (uint16_t)pwm_signed;
    return true;
}

// return mask of enabled protocols.
uint32_t RC_Channels::enabled_protocols() const
{
    if (_singleton == nullptr) {
        // for example firmware
        return 1U;
    }
    return uint32_t(_protocols.get());
}

#if AP_SCRIPTING_ENABLED
/*
  implement aux function cache for scripting
 */

/*
  get last aux cached value for scripting. Returns false if never set, otherwise 0,1,2
*/
bool RC_Channels::get_aux_cached(RC_Channel::AUX_FUNC aux_fn, uint8_t &pos)
{
    const uint16_t aux_idx = uint16_t(aux_fn);
    if (aux_idx >= unsigned(RC_Channel::AUX_FUNC::AUX_FUNCTION_MAX)) {
        return false;
    }
    WITH_SEMAPHORE(aux_cache_sem);
    uint8_t v = aux_cached.get(aux_idx*2) | (aux_cached.get(aux_idx*2+1)<<1);
    if (v == 0) {
        // never been set
        return false;
    }
    pos = v-1;
    return true;
}

/*
  set cached value of an aux function
 */
void RC_Channels::set_aux_cached(RC_Channel::AUX_FUNC aux_fn, RC_Channel::AuxSwitchPos pos)
{
    const uint16_t aux_idx = uint16_t(aux_fn);
    if (aux_idx < unsigned(RC_Channel::AUX_FUNC::AUX_FUNCTION_MAX)) {
        WITH_SEMAPHORE(aux_cache_sem);
        uint8_t v = unsigned(pos)+1;
        aux_cached.setonoff(aux_idx*2, v&1);
        aux_cached.setonoff(aux_idx*2+1, v>>1);
    }
}
#endif // AP_SCRIPTING_ENABLED

// singleton instance
RC_Channels *RC_Channels::_singleton;


RC_Channels &rc()
{
    return *RC_Channels::get_singleton();
}

#endif  // AP_RC_CHANNEL_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 	  I1a'?A
:u:uB7;4  @?P
:uB7;4
B7;4  0h>3bi
B7;4B7;4Z*  -e9>Syr
B7;4Z*
Z*  .A+	>V}
Z*Z*Mq  {BZ=9
Z*Mq
Mq  S19\0?S\0S\4Fc#  S19\0?4Fc#0S\S\  S19\0?4Fc#S\
4Fc#  S19\0?
4Fc#S\7 S\  S19\0?
4Fc#7 S\
S\  
C/\0S198%	S\  
C/\0S197 sQ<7 .<G` NX<  
C/\0S19G` NX<7 .<.<  
C/\0S19s2FF<G` NX<%M*1<  
C/\0S19%M*1<G` NX<.<  
C/\0S19%M*1<.<2FF<  
C/\0S19G` rg =s=P<rg =  
C/\0S19rg =s=P<%>n<  
C/\0S19rg =%>n<=P<  
C/\0S19s2FF<e#4<G` NX<  
C/\0S19G` NX<e#4<p7K<  
C/\0S19G` NX<p7K<G` rg =  
C/\0S19G` rg =p7K<e#c*;<  
C/\0S19G` rg =e#c*;<s=P<  
C/\0S19=P</(c*;<rg =  
C/\0S19rg =/(c*;<$7K<  
C/\0S19rg =$7K<.<  
C/\0S19.<$7K</(4<  
C/\0S19.</(4<2FF<  
C/\0S19e#Af_2=po5=G` rg =  
C/\0S19;=/(8=IN/q=  
C/\0S19rg =$o5=/(Af_2=  
C/\0S19G` rg =po5=G` IN/q=  
C/\0S19/(Af_2=-0=rg =  
C/\0S19rg =-0=%1/=  
C/\0S19rg =%1/=G` rg =  
C/\0S19G` rg =%1/=s-0=  
C/\0S19G` rg =s-0=e#Af_2=  
C/\0S19po5=e#8=G` IN/q=  
C/\0S19G` IN/q=e#8=s;=  
C/\0S19G` IN/q=s;=IN/q=  
C/\0S19IN/q=s;=%PfW;=  
C/\0S19IN/q=%PfW;=;=  
C/\0S19
a;
S\".<  
C/\0S19".<
S\7 S\  
C/\0S19l2k9a\J.<  
C/\0S19.<a\JS\  
C/\0S19a\Jl2e(S\  
C/\0S19S\l2e(48  
C/\0S19S\480S\  
C/\0S190S\480	  
C/\0S190S\0	S\  
C/\0S19S\0	}8  
C/\0S19}8-e(S\  
C/\0S19S\-e(\J  
C/\0S19S\\J.<  
C/\0S19\J-k9.<  
C/\0S19.<-k9}O:  
C/\0S19.<}O:0.<  
C/\0S190.<}O:0eB:  
C/\0S190.<0eB:.<  
C/\0S19.<0eB:4O:  
C/\0S19.<4O:l2k9  
C/\0S19.<rg =a7K<  
C/\0S19a7K<rg =l2c*;<  
C/\0S19a7K<l24<.<  
C/\0S19.<l24<42FF<  
C/\0S19.<42FF<0.<  
C/\0S190.<42FF<0M*1<  
C/\0S190.<0M*1<.<  
C/\0S19.<0M*1<}2FF<  
C/\0S19rg =}=P<0rg =  
C/\0S190rg =}=P<0>n<  
C/\0S190rg =0>n<rg =  
C/\0S19rg =0>n<4=P<  
C/\0S19rg =4=P<l2c*;<  
C/\0S19}2FF<-4<.<  
C/\0S19.<-4<7K<  
C/\0S19.<7K<rg =  
C/\0S19rg =7K<-c*;<  
C/\0S19rg =-c*;<}=P<  
C/\0S19rg =IN/q=ao5=  
C/\0S19ao5=IN/q=l28=  
C/\0S19-Af_2=o5=rg =  
C/\0S19rg =o5=IN/q=  
C/\0S19rg =IN/q=$o5=  
C/\0S19$o5=IN/q=/(8=  
C/\0S19ao5=l2Af_2=rg =  
C/\0S19rg =l2Af_2=4-0=  
C/\0S19rg =4-0=0rg =  
C/\0S190rg =4-0=01/=  
C/\0S190rg =01/=rg =  
C/\0S19rg =01/=}-0=  
C/\0S19rg =}-0=-Af_2=  
C/\0S19o5=-8=IN/q=  
C/\0S19IN/q=-8=};=  
C/\0S19IN/q=};=0IN/q=  
C/\0S190IN/q=};=0PfW;=  
C/\0S190IN/q=0PfW;=IN/q=  
C/\0S19IN/q=0PfW;=4;=  
C/\0S19IN/q=4;=l28=  
C/\0S19IN/q=B6:=0IN/q=  
C/\0S190IN/q=B6:=0B6:=  
C/\0S190IN/q=0B6:=IN/q=  
C/\0S19IN/q=0B6:=B6:=  
C/\0S19IN/q=B6:=G` IN/q=  
C/\0S19G` IN/q=B6:=G` B6:=  
C/\0S19S\%	7 S\  
C/\0S197 S\%	s8  
C/\0S197 S\s8e#e(  
C/\0S197 sQ<".<7 .<  
C/\0S197 .<".<7 S\  
C/\0S197 .<7 S\p\J  
C/\0S19p\J7 S\e#e(  
C/\0S19p\Je#k97 .<  
C/\0S197 .<e#k9sO:  
C/\0S197 .<sO:.<  
C/\0S19.<sO:%eB:  
C/\0S19.<%eB:O:  
C/\0S19O:/(k9.<  
C/\0S19.</(k9$\J  
C/\0S19.<$\JS\  
C/\0S19S\$\J/(e(  
C/\0S19S\/(e(8  S19\0?G` =G` B6:=B6:=  S19\0?G` =B6:==  S19\0?=B6:=0B6:=  S19\0?=0B6:=B6:=  
C\0?S19?8=%S9=6Fga=  
C\0?S19?G` njsT=tG=7 :lb*=  
C\0?S19?7 :lb*=tG=7 tG=  
C\0?S19?7 :lb*=7 tG="tG=  
C\0?S19?6Fga=%S9=G` 6Fga=  
C\0?S19?p?ks3=G` njsT=e#V6=  
C\0?S19?e#V6=G` njsT=G` 6Fga=  
C\0?S19?e#V6=G` 6Fga=s8=  
C\0?S19?s8=G` 6Fga=%S9=  
C\0?S19?s-=/(D0=tG=  
C\0?S19?tG=/(D0=$?ks3=  
C\0?S19?tG=$?ks3=6Fga=  
C\0?S19?6Fga=$?ks3=/(V6=  
C\0?S19?6Fga=/(V6=8=  
C\0?S19?p?ks3=e#D0=G` njsT=  
C\0?S19?G` njsT=e#D0=ss-=  
C\0?S19?G` njsT=ss-=tG=  
C\0?S19?tG=ss-=%!-=  
C\0?S19?tG=%!-=s-=  
C\0?S19?
<Q<
3<7 <Q<  
C\0?S19?7 <Q<
3<"tG=  
C\0?S19?_=%`Iy=G` _=  
C\0?S19?G` _=%`Iy=s2H\o=  
C\0?S19?/(F?=$lB=_=  
C\0?S19?$lB=/(E@E=_=  
C\0?S19?_=/(E@E=2H\o=  
C\0?S19?_=2H\o=%`Iy=  
C\0?S19?s2H\o=e#E@E=G` _=  
C\0?S19?G` _=e#E@E=plB=  
C\0?S19?G` _=plB=G` 6Fga=  
C\0?S19?plB=e#F?=G` 6Fga=  
C\0?S19?G` 6Fga=e#F?=s<=  
C\0?S19?G` 6Fga=s<=6Fga=  
C\0?S19?6Fga=s<=%;=  
C\0?S19?6Fga=%;=<=  
C\0?S19?<Q<l269<a+y<  
C\0?S19?<Q<a+y<tG=  
C\0?S19?<Q<tG=+y<  
C\0?S19?+y<tG=-6
}r<  
C\0?S19?a+y<l26
}r<tG=  
C\0?S19?tG=l26
}r<4 <  
C\0?S19?tG=4 <0tG=  
C\0?S19?0tG=4 <0e<  
C\0?S19?0tG=0e<tG=  
C\0?S19?tG=0e<} <  
C\0?S19?tG=} <-6
}r<  
C\0?S19?+y<-69<<Q<  
C\0?S19?<Q<-69<}|:=<  
C\0?S19?<Q<}|:=<0<Q<  
C\0?S19?0<Q<}|:=<0:[<  
C\0?S19?0<Q<0:[<<Q<  
C\0?S19?<Q<0:[<4|:=<  
C\0?S19?<Q<4|:=<l269<  
C\0?S19?l2D0=a?ks3=tG=  
C\0?S19?tG=a?ks3=6Fga=  
C\0?S19?a?ks3=l2V6=6Fga=  
C\0?S19?6Fga=l2V6=48=  
C\0?S19?6Fga=48=06Fga=  
C\0?S19?06Fga=48=0S9=  
C\0?S19?06Fga=0S9=6Fga=  
C\0?S19?6Fga=0S9=}8=  
C\0?S19?tG=}s-=0tG=  
C\0?S19?0tG=}s-=0!-=  
C\0?S19?0tG=0!-=tG=  
C\0?S19?tG=0!-=4s-=  
C\0?S19?tG=4s-=l2D0=  
C\0?S19?}8=-V6=6Fga=  
C\0?S19?6Fga=-V6=?ks3=  
C\0?S19?6Fga=?ks3=tG=  
C\0?S19?tG=?ks3=-D0=  
C\0?S19?tG=-D0=}s-=  
C\0?S19?alB=_=l2F?=  
C\0?S19?l2F?=_=6Fga=  
C\0?S19?alB=l2E@E=_=  
C\0?S19?_=l2E@E=42H\o=  
C\0?S19?_=42H\o=0_=  
C\0?S19?0_=42H\o=0`Iy=  
C\0?S19?0_=0`Iy=_=  
C\0?S19?_=0`Iy=}2H\o=  
C\0?S19?_=}2H\o=-E@E=  
C\0?S19?-E@E=lB=_=  
C\0?S19?_=lB=6Fga=  
C\0?S19?_=6Fga=/(F?=  
C\0?S19?/(F?=6Fga=<=  
C\0?S19?lB=-F?=6Fga=  
C\0?S19?6Fga=-F?=}<=  
C\0?S19?6Fga=}<=06Fga=  
C\0?S19?06Fga=}<=0;=  
C\0?S19?06Fga=0;=6Fga=  
C\0?S19?6Fga=0;=4<=  
C\0?S19?6Fga=4<=l2F?=  
C\0?S19?"tG=7 tG=7 <Q<  
C\0?S19?7 <Q<7 tG=e#6
}r<  
C\0?S19?7 <Q<e#6
}r<p+y<  
C\0?S19?p+y<e#69<7 <Q<  
C\0?S19?7 <Q<e#69<s|:=<  
C\0?S19?7 <Q<s|:=<<Q<  
C\0?S19?<Q<s|:=<%:[<  
C\0?S19?<Q<%:[<|:=<  
C\0?S19?/(6
}r<tG=$+y<  
C\0?S19?$+y<tG=<Q<  
C\0?S19?$+y<<Q</(69<  
C\0?S19?/(69<<Q<|:=<  
C\0?S19?/(6
}r< <tG=  
C\0?S19?tG= <%e<  
C\0?S19?tG=%e<7 tG=  
C\0?S19?7 tG=%e<s <  
C\0?S19?7 tG=s <e#6
}r<  
C\0?S19?<Q<v'<;0<Q<  
C\0?S19?0<Q<v'<;0v'<;  
C\0?S19?0<Q<0v'<;<Q<  
C\0?S19?<Q<0v'<;v'<;  
C\0?S19?<Q<v'<;7 <Q<  
C\0?S19?7 <Q<v'<;7 v'<;  
C\0?S19?7 <Q<7 v'<;
<Q<  
C\0?S19?
<Q<7 v'<;
v'<;  0S19?\0A<B:u
A<B  0S19?\0
A<B:u
:u    9"1a0
S\
A<B
:u    9"1a0
SJ
P?
a;    9"1a0
3<
RJ;
C?;    9"1a0
Mq
4Fc#
Z*    9"1a0
Z*
4Fc#
S\    9"1a0
Z*
S\
B7;4    9"1a0
B7;4
S\
:u    9"1a0
a;
P?
S\    9"1a0
3<
C?;
a;    9"1a0
a;
C?;
|!;    9"1a0
a;
|!;
SJ    9"1a0
P?
!|
S\    9"1a0
S\
!|
eJ:    9"1a0
S\
eJ:
A<B    9"1a0
A<B
eJ:
G?;    9"1a0
A<B
G?;
<    9"1a0
<
G?;
|;!    9"1a0
<
|;!
<d    9"1a0
RJ;
3<
!;|;    9"1a0
!;|;
3<
<Q<    9"1a0
!;|;
<Q<
;R?;    9"1a0
;R?;
<Q<
v'<;    9"1a0
;R?;
v'<;
;SJ:    9"1a0
;SJ:
v'<;
<I/;    9"1a0
;SJ:
<I/;
|;!    9"1a0
|;!
<I/;
1<    9"1a0
|;!
1<
<d    ?9"aB7;4:uS\    ?9"aB7;4S\Z*    ?9"aZ*S\4Fc#    ?9"aZ*4Fc#Mq    ?9"a+~=B6:=t=    ?9"at=B6:=IN/q=    ?9"a2`=M9B=+~=    ?9"a+~=M9B==    ?9"a+~==B6:=    ?9"a8Hm=tG=!p4;x=    ?9"a!p4;x=tG=6Fga=    ?9"a!p4;x=6Fga=R=    ?9"aB=#=2`=    ?9"a2`=#==    ?9"a2`==M9B=    ?9"a6Fga=_=R=    ?9"aR=_=u=    ?9"aR=u=nj=    ?9"anj=u=eh=    ?9"anj=eh=B=    ?9"aB=eh=u=    ?9"aB=u=#=    ?9"a.<|!;C?;    ?9"a<|;!A<B    ?9"aA<B|;!G?;    ?9"aA<BG?;:u    ?9"a:uG?;eJ:    ?9"a:ueJ:S\    ?9"aeJ:!|S\    ?9"aS\!|P?    ?9"aS\P?.<    ?9"a.<P?SJ    ?9"a.<SJ|!;    ?9"aC?;0e=.<    ?9"a.<0e=eYa=    ?9"a.<eYa=rg =    ?9"arg =eYa=	vc=    ?9"arg =	vc=IN/q=    ?9"aIN/q=	vc='w(j=    ?9"aIN/q='w(j=t=    ?9"a<<d|;!    ?9"a|;!<d1<    ?9"a|;!1<;SJ:    ?9"a;SJ:1<<I/;    ?9"a;SJ:<I/;;R?;    ?9"a;R?;<I/;v'<;    ?9"a;R?;v'<;!;|;    ?9"a!;|;v'<;<Q<    ?9"a!;|;<Q<RJ;    ?9"aRJ;<Q<tG=    ?9"aRJ;tG=C?;    ?9"aC?;tG=8Hm=    ?9"aC?;8Hm=0e=  5tm>G` NX<G` njsT=7 sQ<  5tm>7 sQ<G` njsT=7 :lb*=  5tm>7 sQ<7 :lb*=".<  5tm>".<7 :lb*="tG=  5tm>".<"tG=
a;  5tm>
a;"tG=
3<    9"1a0G` 2`=G` #=G` B=    9"1a0G` B=G` #=G` u=    9"1a0G` B=G` u=G` nj=    9"1a0G` IN/q=G` 'w(j=G` 	vc=    9"1a0G` IN/q=G` 	vc=G` rg =    9"1a0G` rg =G` 	vc=G` eYa=    9"1a0G` rg =G` eYa=G` 0e=    9"1a0G` u=G` eh=G` nj=    9"1a0G` nj=G` eh=G` u=    9"1a0G` nj=G` u=G` R=    9"1a0G` R=G` u=G` _=    9"1a0G` R=G` _=G` !p4;x=    9"1a0G` !p4;x=G` _=G` 6Fga=    9"1a0G` !p4;x=G` 6Fga=G` 8Hm=    9"1a0G` 8Hm=G` 6Fga=G` njsT=    9"1a0G` 8Hm=G` njsT=G` 0e=    9"1a0G` 0e=G` njsT=G` NX<    9"1a0G` 0e=G` NX<G` rg =    9"1a0G` B6:=G` +~=G` IN/q=    9"1a0G` IN/q=G` +~=G` t=    9"1a0G` IN/q=G` t=G` 'w(j=    9"1a0G` B6:=G` =G` +~=    9"1a0G` +~=G` =G` M9B=    9"1a0G` +~=G` M9B=G` 2`=    9"1a0G` 2`=G` M9B=G` =    9"1a0G` 2`=G` =G` #=  /o6 .?0:[<0	4|:=<  -y%?4|:=<0	48  2$.?4|:=<48l269<  gDj>l269<48l2e(  fp~_s>l269<l2e(a+y<  0|_=a+y<l2e(a\J  0|=_a+y<a\Jl26
}r<  fp~>_sl26
}r<a\Jl2k9  gDk>l26
}r<l2k94 <  2$?.4 <l2k94O:  -?y%4 <4O:0e<  /o6? .0e<4O:0eB:  />o6? .0e<0eB:} <  >-?y%} <0eB:}O:  2$??.} <}O:-6
}r<  gD?j>-6
}r<}O:-k9  fp?~>_s-6
}r<-k9+y<  0|?=_+y<-k9\J  0|?_=+y<\J-69<  fp?~_s>-69<\J-e(  gD?k>-69<-e(}|:=<  2$?.?}|:=<-e(}8  >-y%?}|:=<}80:[<  />o6 .?0:[<}80	  /o6 .?%:[<%	|:=<  -y%?|:=<%	8  2$.?|:=<8/(69<  gDj>/(69<8/(e(  fp~_s>/(69</(e($+y<  0|_=$+y</(e($\J  0|=_$+y<$\J/(6
}r<  fp~>_s/(6
}r<$\J/(k9  gDk>/(6
}r</(k9 <  2$?. </(k9O:  -?y% <O:%e<  /o6? .%e<O:%eB:  />o6? .%e<%eB:s <  >-?y%s <%eB:sO:  2$??.s <sO:e#6
}r<  gD?j>e#6
}r<sO:e#k9  fp?~>_se#6
}r<e#k9p+y<  0|?=_p+y<e#k9p\J  0|?_=p+y<p\Je#69<  fp?~_s>e#69<p\Je#e(  gD?k>e#69<e#e(s|:=<  2$?.?s|:=<e#e(s8  >-y%?s|:=<s8%:[<  />o6 .?%:[<s8%	  /o6 .?0!-=0M*1<4s-=  -y%?4s-=0M*1<42FF<  2$.?4s-=42FF<l2D0=  gDj>l2D0=42FF<l24<  fp~_s>l2D0=l24<a?ks3=  0|_=a?ks3=l24<a7K<  0|=_a?ks3=a7K<l2V6=  fp~>_sl2V6=a7K<l2c*;<  gDk>l2V6=l2c*;<48=  2$?.48=l2c*;<4=P<  -?y%48=4=P<0S9=  /o6? .0S9=4=P<0>n<  />o6? .0S9=0>n<}8=  >-?y%}8=0>n<}=P<  2$??.}8=}=P<-V6=  gD?j>-V6=}=P<-c*;<  fp?~>_s-V6=-c*;<?ks3=  0|?=_?ks3=-c*;<7K<  0|?_=?ks3=7K<-D0=  fp?~_s>-D0=7K<-4<  gD?k>-D0=-4<}s-=  2$?.?}s-=-4<}2FF<  >-y%?}s-=}2FF<0!-=  />o6 .?0!-=}2FF<0M*1<  /o6 .?0;=01/=4<=  -y%?4<=01/=4-0=  2$.?4<=4-0=l2F?=  gDj>l2F?=4-0=l2Af_2=  fp~_s>l2F?=l2Af_2=alB=  0|_=alB=l2Af_2=ao5=  0|=_alB=ao5=l2E@E=  fp~>_sl2E@E=ao5=l28=  gDk>l2E@E=l28=42H\o=  2$?.42H\o=l28=4;=  -?y%42H\o=4;=0`Iy=  /o6? .0`Iy=4;=0PfW;=  />o6? .0`Iy=0PfW;=}2H\o=  >-?y%}2H\o=0PfW;=};=  2$??.}2H\o=};=-E@E=  gD?j>-E@E=};=-8=  fp?~>_s-E@E=-8=lB=  0|?=_lB=-8=o5=  0|?_=lB=o5=-F?=  fp?~_s>-F?=o5=-Af_2=  gD?k>-F?=-Af_2=}<=  2$?.?}<=-Af_2=}-0=  >-y%?}<=}-0=0;=  />o6 .?0;=}-0=01/=  /o6 .?%!-=%M*1<s-=  -y%?s-=%M*1<2FF<  2$.?s-=2FF</(D0=  gDj>/(D0=2FF</(4<  fp~_s>/(D0=/(4<$?ks3=  0|_=$?ks3=/(4<$7K<  0|=_$?ks3=$7K</(V6=  fp~>_s/(V6=$7K</(c*;<  gDk>/(V6=/(c*;<8=  2$?.8=/(c*;<=P<  -?y%8==P<%S9=  /o6? .%S9==P<%>n<  />o6? .%S9=%>n<s8=  >-?y%s8=%>n<s=P<  2$??.s8=s=P<e#V6=  gD?j>e#V6=s=P<e#c*;<  fp?~>_se#V6=e#c*;<p?ks3=  0|?=_p?ks3=e#c*;<p7K<  0|?_=p?ks3=p7K<e#D0=  fp?~_s>e#D0=p7K<e#4<  gD?k>e#D0=e#4<ss-=  2$?.?ss-=e#4<s2FF<  >-y%?ss-=s2FF<%!-=  />o6 .?%!-=s2FF<%M*1<  /o6 .?%;=%1/=<=  -y%?<=%1/=-0=  2$.?<=-0=/(F?=  gDj>/(F?=-0=/(Af_2=  fp~_s>/(F?=/(Af_2=$lB=  0|_=$lB=/(Af_2=$o5=  0|=_$lB=$o5=/(E@E=  fp~>_s/(E@E=$o5=/(8=  gDk>/(E@E=/(8=2H\o=  2$?.2H\o=/(8=;=  -?y%2H\o=;=%`Iy=  /o6? .%`Iy=;=%PfW;=  />o6? .%`Iy=%PfW;=s2H\o=  >-?y%s2H\o=%PfW;=s;=  2$??.s2H\o=s;=e#E@E=  gD?j>e#E@E=s;=e#8=  fp?~>_se#E@E=e#8=plB=  0|?=_plB=e#8=po5=  0|?_=plB=po5=e#F?=  fp?~_s>e#F?=po5=e#Af_2=  gD?k>e#F?=e#Af_2=s<=  2$?.?s<=e#Af_2=s-0=  >-y%?s<=s-0=%;=  />o6 .?%;=s-0=%1/=  qx:hv?
eJ:eJ:
G?;  /$5f?
G?;eJ:G?;  +Q72?
G?;G?;
|;!  01T_?
|;!G?;|;!  +&0x.\|>
|;!|;!
;SJ:  N1[=
;SJ:|;!;SJ:  .hv:
;SJ:;SJ:
;R?;  $5f
;R?;;SJ:;R?;  /22Q7
;R?;;R?;
!;|;  t._T
!;|;;R?;!;|;  $1.\|x
!;|;!;|;
RJ;  '1[
RJ;!;|;RJ;  qx-:>hv
RJ;RJ;
C?;  >$5f
C?;RJ;C?;  +0Q7?2
C?;C?;
|!;  0T?_
|!;C?;|!;  +&x?.\|
|!;|!;
SJ  N[?
SJ|!;SJ  .2hv?:>
SJSJ
P?  1$5f?>
P?SJP?  /2?Q7?
P?P?
!|  t_?T?
!|P?!|  $.\|>x?
!|!|
eJ:  '=[?
eJ:!|eJ:  '1[B=G` B=nj=  $1.\|xnj=G` B=G` nj=  t._Tnj=G` nj=R=  /22Q7R=G` nj=G` R=  $5fR=G` R=!p4;x=  .hv:!p4;x=G` R=G` !p4;x=  N1[=!p4;x=G` !p4;x=8Hm=  +&0x.\|>8Hm=G` !p4;x=G` 8Hm=  01T_?8Hm=G` 8Hm=0e=  +Q72?0e=G` 8Hm=G` 0e=  /$5f?0e=G` 0e=eYa=  qx:hv?eYa=G` 0e=G` eYa=  '=[?eYa=G` eYa=	vc=  $.\|>x?	vc=G` eYa=G` 	vc=  t_?T?	vc=G` 	vc='w(j=  /2?Q7?'w(j=G` 	vc=G` 'w(j=  1$5f?>'w(j=G` 'w(j=t=  .2hv?:>t=G` 'w(j=G` t=  N[?t=G` t=+~=  +&x?.\|+~=G` t=G` +~=  0T?_+~=G` +~=2`=  +0Q7?22`=G` +~=G` 2`=  >$5f2`=G` 2`=B=  qx-:>hvB=G` 2`=G` B=  82itUOMq4Fc#
Mq  82itUO
Mq4Fc#
4Fc#  tnC?@%?
v'<;7 v'<;
<I/;  tnC?@%?
<I/;7 v'<;v'<;  tnC?@%?v'<;<I/;0v'<;  tnC?@%?0v'<;<I/;v'<;  wTSqS?P?v'<;<I/;
<I/;  k1l?j>
<I/;<I/;1<  r1"u?r>
<I/;1<
1<  1tB?=
1<1<<d  1?
1<<d
<d  $cb2Tx?|q
<d<d<  	q?tx
<d<
<  Y?L
<<A<B  S71J?
<A<B
A<B  \m<~+>?G` ==M9B=  q"?EE?_=u=0_=  q"?EE?0_=u=_=  _u1eJ?G` =M9B=G` M9B=  X[v_?G` M9B=M9B==  4h?G` M9B==G` =  00qu?G` ==#=  {U]z?G` =#=G` #=  uJ3*y?G` #=#=u=  Qh<b?G` #=u=G` u=   
&>|?G` u=u=eh=  kD1|r>0x?G` u=eh=G` eh=  AJ(2>Hl?G` eh=eh=u=  s0o>e?G` eh=u=G` u=  *0{$?|Q?G` u=u=_=  q"?EE?G` u=_=G` _=  Y<6u^<1L>Z|J>{sJ>  V7=w<i}>5O>~nxN>'Op M>  <z"X>'Op M>~nxN>0vgM>  X/={BuB>'Op M>0vgM>/]qM>  r1	j72yE?>$\Dc?>FA>  D*8;=;+FA>$\Dc?>nsSA>  /8;JFA>nsSA>YEiB>  ><ja>D>=zE>_5C>  	<
h8_5C>=zE>ZC>  p<O+`%_5C>ZC>,t_B>  A6;E#] ,t_B>ZC>UB>  BC</Xn	,t_B>UB>1ZaB>  r;x<W
1ZaB>UB>YEiB>  /<K$TkC1ZaB>YEiB>{7)B>  u;eN=:{7)B>YEiB>nsSA>  n!<m>D>n 'nE>=zE>  <Apc=zE>n 'nE>6E>  ?<ur2=zE>6E>V	F>  -U<?u?V	F>6E>XG>  ^<Lw)V	F>XG>aG>  <ixsaG>XG>XdG>  yh<z6 MaG>XdG>H>  ,<m|'H>XdG>	H>  ,<N~7H>	H>Z|J>  =}Z|J>	H>I>  9=yAC2Z|J>I>{sJ>  -=	}cN=1L>{sJ>N,L>  
<'} >1L>N,L>0vgM>  '=}n>0vgM>N,L>6M>  e,={x0>0vgM>6M>/]qM>  i?=|n>?WP>n*Q>5O>  <Xp>5O>n*Q>9O>  v<Eeua[>5O>9O>~nxN>  5zB=l'>?WP>'XP>n*Q>  ^D=Jj>n*Q>'XP>u#Q>  <Sf!>n*Q>u#Q>3/6R>  PI=a>3/6R>u#Q>R>  W<t]D ?3/6R>R>)R>  7Q=sN?)?hU>UrU>
T>  1<!Ex"?
T>UrU>T>  O=XL?
T>T>P0S>  I<2RQ?P0S>T>)R>  N=V?P0S>)R>ifQ S>  \L=iZ?ifQ S>)R>R>  r1	j72"!2E?>yE?>FA>  |?)?T>UrU>hU>  )8d72q\Dc?>"!2E?>({HA>  >*8=<+({HA>"!2E?>FA>  TH#({HA>FA>7B>  VpNX57B>FA>YEiB>  /F$TrC7B>YEiB>?Z`B>  B`V?Z`B>YEiB>TrB>  %X*	TrB>YEiB>UB>  `Bo3 ]Y'TrB>UB>Z6C>  E	`#Z6C>UB>ZC>  "eZ6C>ZC>VD>  : jCVD>ZC>=zE>  d!mVD>=zE>KvpE>  \[p.KvpE>=zE>{?oE>  D6r{?oE>=zE>V	F>  Ou={?oE>V	F>]ZG>  ^Lw)]ZG>V	F>aG>  L	xs]ZG>aG>KeT~G>  hzr&MKeT~G>aG>H>  (Mm|F'KeT~G>H>EH>  1d$~IEH>H>I>  .I>H>Z|J>  #YK(I>Z|J>;)tJ>   x}>0vgM>eW&
L>1L>  V&"|~[=1L>eW&
L>GbX,L>  kP=1L>GbX,L>Z|J>  -T<Z|J>GbX,L>;)tJ>  Wt]D ?)R>dR>3/6R>  PIa>3/6R>dR>$!Q>  Sf!>3/6R>$!Q>n*Q>  wDhjL>n*Q>$!Q> mP>  ;8~n>n*Q> mP>9O>  z?cq&>9O> mP>6O>  }Eeua[>9O>6O>~nxN>  V7w<i}>~nxN>6O>m=mM>  z#X>~nxN>m=mM>0vgM>  /l{jB>0vgM>m=mM>dG{oM>  Q+N;|)>0vgM>dG{oM>eW&
L>  7Q}iEu"?hU>
T>T>  OL*?T>
T>{3sS>  RK?T>{3sS>)R>  _NBV
?)R>{3sS>e S>  LiZ?)R>e S>dR>  S19\0?UrU>bK\>UrU>  S19\0?UrU>bK\>bK\>  <2F\7?U]>bK\>*\>  <7j?`>H_>A6.`>  *8;	)?t??$#ApZ]>`Cp]]>qm^>  6*8;"?E?qm^>`Cp]]>_q][^>  7Q=}+=?*\>
;Q^]>U]>  FO=@wH?U]>
;Q^]>m<^>  <SN?U]>m<^>`_>  	L=T?`_>m<^>v^>  W<t
;W?`_>v^>m__>  xK=SX?m__>v^>4_>  f< ;#]?m__>4_>H_>  H=<aT`?H_>4_>f_>  *C=Z%e?H_>f_>A6.`>  @?=ym?A6.`>.d`>`>  -;=4p?`>.d`>`>  >b<-zr?`>`>A0`>  6=dRD5u?A0`>`>(~`>  <Rw?A0`>(~`>~a>  /=/qx?~a>(~`>|2'~'a>  l<.Lz?~a>|2'~'a>p|Wa>  *X<n<N?{z2{*a>yUla>9{a>  "Z=8*?{z2{*a>9{a>aX|a>  e<@%?aX|a>9{a>p|Wa>  >/ =Xv~?aX|a>p|Wa>/Oj|[a>  %)=%g|?/Oj|[a>p|Wa>|2'~'a>  =bV=?{z2{*a>|zyqa>yUla>  u"<y=T~?yUla>|zyqa>\xia>  Vq<4>3}?yUla>\xia>w<a>  C<2>K{?\xia>4xQa>w<a>  d<R\D>%{?w<a>4xQa>w3a>  ^<EY>z?w<a>w3a>_=wU-a>   k<A>>w?_=wU-a>w3a>- .#v`>  95<p>cu?_=wU-a>- .#v`>Y,v`>  <5>pq?Y,v`>- .#v`>=Ou`>  g <hC>n?Y,v`>=Ou`>te"`>  D<>Sl?=Ou`>HQu	p`>te"`>  <]>3j?te"`>HQu	p`>>^t*`>  <	<Rv>Rf?te"`>>^t*`>s_>  <g<8f>na?s_>>^t*`>7svX_>  r;f ?Fw]?s_>7svX_>!
sd_>  l.<A?Z?!
sd_>7svX_>(.rO#_>  h;s?*^U?!
sd_>(.rO#_>_q][^>  <p?'DQ?_q][^>(.rO#_>q?^>  ;^?CL?_q][^>q?^>qm^>  .B?RZ?^wrj"_>sV_>!
sd_>  (*8	)?t??"!Bpy\]>q#ApZ]>q*m^>  rf ?Fw]?!
sd_>sV_>s_>  ^m<[?g:2{@a>9{a>yUla>  7QX207?*\>bK\>@Ql]>  /p+8=?@Ql]>bK\>U]>  HOFwH?@Ql]>U]>.U^>  NN?.U^>U]>`_>  _`?H_>_>m__>  H+ 7\?m__>_>0_>  ]-	H%X?m__>0_>`_>  K?V?`_>0_>^>  
LT?`_>^>.U^>  n4L|z?p|Wa>bcE(~a>~a>  /6qx?~a>bcE(~a>Ym ~a>  Rw?~a>Ym ~a>A0`>  L5
u?A0`>Ym ~a>UI`>  C
r?A0`>UI`>`>  u:Ip?`>UI`>'_`>  k?`>'_`>H_>  e?2{i?H_>'_`>~)`>  ,C`%e?H_>~)`>_>  @ ?9{a>g:2{@a>0{ea>  >1?9{a>0{ea>p|Wa>  !%~?p|Wa>0{ea>:FU|Ya>  &)*%g|?p|Wa>:FU|Ya>bcE(~a>  jx>v}?w<a>|xta>yUla>  L=~?yUla>|xta>5%zyxa>  V=?yUla>5%zyxa>g:2{@a>  9RG>b?s_>sV_>te"`>  NgvC>Jd?te"`>sV_>7t^%`>  s	gW>l?te"`>7t^%`>Y,v`>  F5W,>cnn?7t^%`>nU[:u`>Y,v`>  T>)q?Y,v`>nU[:u`>u/"v`>  D5p>cu?Y,v`>u/"v`>_=wU-a>  jC>>w?_=wU-a>u/"v`>w-a>  ^DY>z?_=wU-a>w-a>w<a>  QD>|&{?w<a>w-a>26xIa>  +>D|?w<a>26xIa>|xta>  S?%?V?^wrj"_>!
sd_>J_q^>  n7?R?J_q^>!
sd_>_q][^>  %+?M?J_q^>_q][^>q*m^>  V*8"?E?q*m^>_q][^>`Cp]]>  (*8	)?t??q*m^>`Cp]]>"!Bpy\]>  <!90?bK\>UrU>*\>  Q=:80?*\>UrU>hU>  K=8$(0?*\>hU>3\>  + =7
/?3\>hU> Gf>U>  >)!?^J_T>^kf[>eT>  {>+2L#?eT>^kf[>3M[>  >T-Y%?eT>3M[>Bk!T>  >}V.>c&?Bk!T>3M[>\>  d>I0?(?Bk!T>\><K8T>  	>YH12)?<K8T>\>6KxE\>  |>x3H+?<K8T>6KxE\>l_83U>  mg>d45*,?l_83U>6KxE\>\>  ]uG>A5\-?l_83U>\>Se=U>  ?>5-?Se=U>\>0,\>  U3>T6.?Se=U>0,\> Gf>U>  2>Y6C.? Gf>U>0,\>I\>  ?>507.? Gf>U>I\>3\>  ?$HbV?sS>	L\Z>4lS>  ,
??4lS>	L\Z>OteZ>  !?bq?'nR>.Zk3Y>sS>   ?	?sS>.Zk3Y>'wxY>  ?"U?sS>'wxY>	L\Z>  }l>U"?o.U*[>.36T>OteZ>  `?#S)?OteZ>.36T>t?S>  d
??OteZ>t?S>4lS>  >ms'?^J_T>Z/MT>^kf[>  >&u?^kf[>Z/MT>.36T>  >\&T?^kf[>.36T>`J[>  "7>%?`J[>.36T>o.U*[>  )?#(?VR>.Y?nX>'nR>  [T(?;\*?'nR>.Y?nX>-2Y>  g#?R?'nR>-2Y>.Zk3Y>  -?x&?VR>&\<_R>.Y?nX>  p5?<a>.Y?nX>&\<_R>QaQ>  ]8?{ @>.Y?nX>QaQ>'W>  n>?">'W>QaQ>6CmQ>  h??p>'W>6CmQ>JHfGW>  B2G?,3
>JHfGW>6CmQ>FP>  .K?R>JHfGW>FP>fUWV>  O?J
m>fUWV>FP>feP>  DO?S3>fUWV>feP>" V>  U?v>" V>feP>MO>  yZ??>" V>MO>OT>  p_?&>OT>MO>T>  _?H^>T>MO><	,O>  @d?K>T><	,O>(~R>  li?Zs>(~R><	,O>DEN>  n?>(~R>DEN>5cy~jR>  6o?7q{>5cy~jR>DEN>^]?#+qN>  Zp?%zn>5cy~jR>^]?#+qN>~Q>  B+r?A1p7=e>^]?#+qN>N>~Q>  t?W?M>~Q>N>OfM>  eu?7N-D>~Q>OfM>R}"Q>  "y?z">R}"Q>OfM>h3~$L>  	{?b)
x>R}"Q>h3~$L>7RX@|C5O>  \}?toP=7RX@|C5O>h3~$L>M*[`~ L>  }?]d=7RX@|C5O>M*[`~ L>0{N>  ]~?Ax=0{N>M*[`~ L>
~K>  B?=3A{I>Fy3nK>"m|yJ>  m?	<"m|yJ>Fy3nK>vzMM>  ?N="m|yJ>vzMM>
~K>  R3?, jkT_=
~K>vzMM>{PN>  \~?X>+=
~K>{PN>0{N>  @=~1<N,L>{sJ>#xxSJ>  hr=:-B?>X)?>^A>  {?^9i^T<9]~:J>8+YK>HI>  6l? KHJE>{F>G>  L|~?:|1V'|H>A{I>A\Q~XH>  ><&PJ%j9~"@>M[[n1@>XSB>  ?l#lzp5B>
bC>Qb4E>  hb.?GQb4E>
bC>JE>  =l<>'XP>?WP>FI72P>  3?~	(>[cP>&\<_R>{!19P>  ,?bt>{!19P>&\<_R>VR>  ('?>VR>'nR>{!19P>  $?r
>{!19P>'nR>sS>  e ?u	 P>{!19P>sS>:=yQ>  	4?}?sS>4lS>:=yQ>  hU?4"?:=yQ>4lS>t?S>  ?L,>:=yQ>t?S>eKQ>  >)?eKQ>t?S>.36T>  >z7?eKQ>.36T>^HRR>  >1*?^HRR>.36T>Z/MT>  &>OH?OR>X
R><K8T>  `6b>??<K8T>l_83U>OR>  A>p@$!?OR>l_83U>Se=U>  8>^:Ao!?OR>Se=U> Gf>U>  :>z1y?Z/MT>^J_T>^HRR>  >i	4?^HRR>^J_T>eT>  >A?^HRR>eT>X
R>  >9?X
R>eT>Bk!T>  >y;?X
R>Bk!T><K8T>  )>>Bh"? Gf>U>hU>OR>  &=. I?OR>hU>
T>  =#PI'?OR>
T>P0S>  Yk>Z>OR>FI72P>X
R>  I>(_>X
R>FI72P>;O>  _>LSf>X
R>;O>^HRR>  ?>`V>^HRR>;O>rFO>  >3HEf>^HRR>rFO>eKQ>  R>FJ2>eKQ>rFO>+iO>  	c?'<a>eKQ>+iO>:=yQ>  !?<U2>:=yQ>+iO>Yz'O>  !?g->:=yQ>Yz'O>{!19P>  i+?,M>{!19P>Yz'O>v|?N>  { 5?>{!19P>v|?N>[cP>  ?=?+>[cP>v|?N>EWE"FN>  \F?HP>[cP>EWE"FN>xO>  M?U>x{fPL>n-K>M>  .=o8>?WP>5O>FI72P>  >rl>FI72P>5O>An\OM>  lu>mP>FI72P>An\OM>;O>  > o{_>;O>An\OM>&y#M>  >Zd5h>;O>&y#M>rFO>  w>7dS>rFO>&y#M>L>  i>Wk>rFO>L>+iO>  ^?)VuqD>+iO>L>E/L>  ?HSt>+iO>E/L>Yz'O>  B#?EV4>Yz'O>E/L>Y_mL>  L)?7R`>Yz'O>Y_mL>v|?N>  b1?M3">v|?N>Y_mL>x{fPL>  <?T%BJ>v|?N>x{fPL>EWE"FN>  G?w7>EWE"FN>x{fPL>M>  M?	>EWE"FN>M>xO>  5=LFT?P0S>ifQ S>OR>  2=*%X?OR>ifQ S>R>  >@<_>OR>R>FI72P>  =e<>FI72P>R>u#Q>  =jR>FI72P>u#Q>'XP>  >~ WG@>@>zp5B>  K>/zp5B>@>t]@>  ?j	zp5B>t]@>
bC>  R?
bC>t]@>A>  p?/m
bC>A>q4A>  ,m>vwZ#xxSJ>>L\G>O&5J>  >>r#(O&5J>>L\G>a(UMG>  ->0mybO&5J>a(UMG>0J>  >umg*0J>a(UMG>?IG>  H>Q_^#0J>?IG>L$`HJ>  e?GX7+L$`HJ>?IG>KRG>  ?tNGoL$`HJ>KRG>oWmI>  ?G)E)oWmI>KRG>oQfG>  *?<?oWmI>oQfG>:uiI>  |>DB|K(#xxSJ>{sJ>>L\G>  >=C}j>L\G>{sJ>I>  Z=9-X)?>k?>^A>  >8m-^A>k?>e]?>  BE8>A ^A>e]?>>(KA>  U=|a_5C>,t_B>m}D>  B=HZtm}D>,t_B>^A>  A>>\m}D>^A>Q D>  Z^>RVQ D>^A>>(KA>  fj>aTs$Q D>>(KA>gI'JD>  c\>LJ+agI'JD>>(KA>!B>  _`>~IgI'JD>!B>?D>  >;a/**C5?>!B>LU?>  sL>?\;+LU?>!B>>(KA>  k>~-4,LU?>>(KA>4?>  NN>5,4?>>(KA>e]?>  O=|GI>	H>>L\G>  =z9BF>L\G>	H>XdG>  I=xjl>L\G>XdG>XG>  J=wmw6E>n 'nE>m}D>  3=jm}D>n 'nE>>D>  $c=fam}D>>D>_5C>  =/uXG>6E>>L\G>  n=9pU6>L\G>6E>m}D>  #[>n>L\G>m}D>a(UMG>  }>\*ga(UMG>m}D>Q D>  &>8e]a(UMG>Q D>?IG>  X4>\?IG>Q D>gI'JD>  h>yXF?IG>gI'JD>KRG>  >HO0FKRG>gI'JD>?D>  ?HIhKRG>?D>oQfG>  >|%"$M[[n1@>WG@>XSB>  >=1)XSB>WG@>zp5B>  ?2LXSB>zp5B>]9D>  Q?,w]9D>zp5B>Qb4E>  (?|h.8]9D>Qb4E>&G>  5?"&G>Qb4E>JE>  C?|e|&G>JE>G>  <|?>Y/V'|H>A\Q~XH>z}FH>  T?;Y]S"BC> 8*2RC> KHJE>  \?i:EX KHJE> 8*2RC>AOaD>  `f?]P KHJE>AOaD>{F>  Hj?q"N{F>AOaD>E>  ql?t_E>uE>{F>  n?P{F>uE>"dW!F>  'q?cT{F>"dW!F>G>  #t?pG-8vG>"dW!F>u~ReG>  5Ry?~:
:G>u~ReG>A\Q~XH>  z?t@9;A\Q~XH>u~ReG>XYH~G>  8{?]-A\Q~XH>XYH~G>z}FH>  ?=A{I>"m|yJ>9]~:J>  ?FsQE=9]~:J>"m|yJ>
~K>  ~?Rw=
~K>M*[`~ L>9]~:J>  as~?KO=9]~:J>M*[`~ L>h3~$L>  @}?Q
*=9]~:J>h3~$L>8+YK>  u?Vx9>OfM>N>ehwL>  es?Mo"O>ehwL>N>^]?#+qN>  nb?huDZ>MO>doN><	,O>  g?+><	,O>doN>DEN>  O?iN>feP>FP>xO>  K?D>xO>FP>6CmQ>  D?S>xO>6CmQ>[cP>  ??,>[cP>6CmQ>QaQ>  9?T7>[cP>QaQ>&\<_R>  z?[/+=h3~$L>OfM>8+YK>  w?dX/
>8+YK>OfM>ehwL>  r?6!>8+YK>ehwL>doN>  o?OY>doN>ehwL>^]?#+qN>  8Xl?b|>doN>^]?#+qN>DEN>  4?]q4A>w1{A>
bC>  H
%?
bC>w1{A>NiC>  tJ0?
bC>NiC>JE>  ??)bJE>NiC>uE>  ,hK?	JE>uE>G>  Z?^bG>uE> dqGH>  d??(P
G> dqGH>8oy=I>  p?Vf8oy=I> dqGH>HI>  @q? 8oy=I>HI><2z^K>  u? <<2z                                                                                G  H~ev$&/K9v$./K9WX%&_)  qy.lWX%&_)v$./K9WX%._)  d1WX%&_)WX%._)R'&   kU/R'& WX%._)R'.   /eL:R'& R'. Z*&  ~2lMZ*&R'. Z*.  
6u1okZ*&Z*.e.&j  C&_2Hue.&jZ*.e..j  TpAe.&je..j<2&j  Tp=<2&je..j<2.j  B>>a1Hu<2&j<2.j5&  
>B2ok5&<2.j5.  ~?!lM5&5.8&   /?CL:8& 5.8.   kU?a8& 8. J:&_)  d?!!J:&_)8. J:._)  qy?t0/lJ:&_)J:._)*q;&/K9  H~?s1*q;&/K9J:._)*q;./K9  H~?e1=*q;&/K9*q;./K9J:&H  qy?.1l>J:&H*q;./K9J:.H  d?>J:&HJ:.H8&V  kU??8&VJ:.H8.V  /?e2L:?8&V8.V5&`  ~?21lM?5&`8.V5.`  
>6uok?5&`5.`<2&[+f  C>&_Hu?<2&[+f5.`<2.[+f  Tp=A2?<2&[+f<2.[+fe.&[+f  Tp3?e.&[+f<2.[+fe..[+f  B>aHu?e.&[+fe..[+fZ*&`  
Bok?Z*&`e..[+fZ*.`  ~!3lM?Z*&`Z*.`R'&V  /C1L:?R'&VZ*.`R'.V  kUa1?R'&VR'.VWX%&H  d!!2>WX%&HR'.VWX%.H  qyt0l>WX%&HWX%.Hv$&/K9  H~s=v$&/K9WX%.Hv$./K9  *500|/%X4	K=HX4	K=%].O=   "fp%].O=HX4	K=H].O=  xCgD2$%].O=H].O=%AiS=  {2$gD%AiS=H].O=HAiS=  q[fp%AiS=HAiS=%+-@T=  6B/0|%+-@T=HAiS=H+-@T=  ;L/>0|%+-@T=H+-@T=%TiS=  >fp%TiS=H+-@T=HTiS=  I
22$?gD%TiS=HTiS=%+O=  ,EgD?2$%+O=HTiS=H+O=  :fp?%+O=H+O=%z4	K=  $20|?/%z4	K=H+O=Hz4	K=  *50|?/>%z4	K=Hz4	K=%+mF=   "0fp?>%+mF=Hz4	K=H+mF=  xC1gD?2$?%+mF=H+mF=%TC=  {/2$?gD?%TC=H+mF=HTC=  q[0>fp?%TC=HTC=%+-A=  6B1/>0|?%+-A=HTC=H+-A=  ;L2/0|?%+-A=H+-A=%AC=  0fp?%AC=H+-A=HAC=  I
2$gD?%AC=HAC=%].mF=  ,E1gD2$?%].mF=HAC=H].mF=  :1fp>%].mF=H].mF=%X4	K=  $0|/>%X4	K=H].mF=HX4	K=  *500|/%/4	K=H/4	K=%4O=   "fp%4O=H/4	K=H4O=  xCgD2$%4O=H4O=%iS=  {2$gD%iS=H4O=HiS=  q[fp%iS=HiS=%@T=  6B/0|%@T=HiS=H@T=  ;L/>0|%@T=H@T=%iS=  >fp%iS=H@T=HiS=  I
22$?gD%iS=HiS=%O=  ,EgD?2$%O=HiS=HO=  :fp?%O=HO=%4	K=  $20|?/%4	K=HO=H4	K=  *50|?/>%4	K=H4	K=%mF=   "0fp?>%mF=H4	K=HmF=  xC1gD?2$?%mF=HmF=%C=  {/2$?gD?%C=HmF=HC=  q[0>fp?%C=HC=%A=  6B1/>0|?%A=HC=HA=  ;L2/0|?%A=HA=%C=  0fp?%C=HA=HC=  I
2$gD?%C=HC=%4mF=  ,E1gD2$?%4mF=HC=H4mF=  :1fp>%4mF=H4mF=%/4	K=  $0|/>%/4	K=H4mF=H/4	K=  Q  ?He=%eS=Hes=  Q  ?Hes=%eS=%es=    	1eZ%S=%TC=%+-A=    	1eZ%TiS=%+O=%s=    	1eZ%s=%+O=%z4	K=    	1eZ%s=%z4	K=%S=    	1eZ%S=%z4	K=%+mF=    	1eZ%S=%+mF=%TC=    	1eZ%iS=%@T=%es=    	1eZ%es=%@T=%iS=    	1eZ%AC=%4	K=%+-A=    	1eZ%+-A=%4	K=%mF=    	1eZ%+-A=%mF=%S=    	1eZ%S=%mF=%C=    	1eZ%S=%C=%eS=    	1eZ%eS=%C=%A=    	1eZ%eS=%A=%C=    	1eZ%C=%4mF=%eS=    	1eZ%eS=%4mF=%/4	K=    	1eZ%eS=%/4	K=%es=    	1eZ%es=%/4	K=%4O=    	1eZ%es=%4O=%iS=    	1eZ%AC=%].mF=%4	K=    	1eZ%4	K=%].mF=%X4	K=    	1eZ%4	K=%X4	K=%O=    	1eZ%O=%X4	K=%].O=    	1eZ%O=%].O=%iS=    	1eZ%iS=%].O=%es=    	1eZ%es=%].O=%AiS=    	1eZ%es=%AiS=%s=    	1eZ%s=%AiS=%+-@T=    	1eZ%s=%+-@T=%TiS=  55?2%S=0&c<%s=  55?2%s=0&c<0&s=  Q  ?z-.Xe..[+fs0./dZ  Q  ?s0./dZe..[+f<2.[+f  Q  ?s0./dZ<2.[+f54.oV  Q  ?54.oV<2.[+f5.`  Q  ?54.oV5.`6.L  Q  ?6.L5.`8.V  Q  ?6.L8.V108.6@  Q  ?z-.{Z*.{*.   Q  ?{*. Z*.R'.   Q  ?{*. R'. 	s(.+  Q  ?	s(.+R'. WX%._)  Q  ?	s(.+WX%._)'./K9  Q  ?'./K9WX%._)v$./K9  Q  ?'./K9v$./K9	s(.sF  Q  ?	s(.sFv$./K9WX%.H  Q  ?	s(.sFWX%.H{*.R  Q  ?{*.RWX%.HR'.V  Q  ?{*.RR'.Vz-.X  Q  ?z-.XR'.VZ*.`  Q  ?z-.XZ*.`e..[+f  Q  ?8.VJ:.H108.6@  Q  ?108.6@J:.H*q;./K9  Q  ?108.6@*q;./K9108._2  Q  ?108._2*q;./K9J:._)  Q  ?108._2J:._)6.o%  Q  ?6.o%J:._)8.   Q  ?6.o%8. 54.x  Q  ?54.x8. 5.  Q  ?54.x5.s0.+2  Q  ?s0.+25.<2.j  Q  ?s0.+2<2.jz-.{  Q  ?z-.{<2.je..j  Q  ?z-.{e..jZ*.  Q  ?*&.&)B&&
  Q  ?B&&
.&).&  Q  ?B&&
.&o#&  Q  ?o#&.&.&K  Q  ?T%&"&+tDF!&c  Q  ?5&8& jI&s=  Q  ?jI&s=8& J:&_)  Q  ?jI&s=J:&_)jI&  Q  ?jI&J:&_)*q;&/K9  Q  ?jI&*q;&/K9J:&H  Q  ?<2&j9&r)=e.&j  Q  ?e.&j9&r)=,8&6i  Q  ?e.&j,8&6iJ1&q   Q  ?8&VP0&g>J:&H  Q  ?J:&HP0&g>J1&K  Q  ?J:&HJ1&KjI&  Q  ?jI&J1&K{1&  Q  ?jI&{1&h?&	  Q  ?h?&	{1&J1&)  Q  ?h?&	J1&)+5&	  Q  ?+5&	J1&)P0&5  Q  ?+5&	P0&5/&  Q  ?/&P0&50&  Q  ?/&0&*&  Q  ?*&0&PU/&5  Q  ?*&PU/&5.&)  Q  ?P0&3R'& J1&q   Q  ?J1&q R'& Z*&  Q  ?J1&q Z*&e.&j  Q  ?P0&30&qR'&   Q  ?R'& 0&qPU/&3  Q  ?R'& PU/&3WX%&_)  Q  ?N/&90&i2&  Q  ?2&0&iP0&U  Q  ?2&P0&UL5&a  Q  ?L5&aP0&UJ1&m  Q  ?L5&aJ1&m,8&6i  Q  ?,8&6iJ1&m{1&mD  Q  ?,8&6i{1&mDJ1&q   Q  ?5&/<58&g_<jI&s=  Q  ?jI&s=58&g_<P9&<  Q  ?jI&s=P9&<AJ:&j<  Q  ?0&s=0&c<jI&s=  Q  ?jI&s=0&c<Z2&s$<  Q  ?jI&s=Z2&s$<5&/<  Q  ?AJ:&j<AJ:&2jI&s=  Q  ?jI&s=AJ:&29&r)=  Q  ?jI&s=9&r)=5&  Q  ?5&9&r)=<2&j  Q  ?8&V5&`P0&g>  Q  ?P0&g>5&`<2&[+f  Q  ?P0&g><2&[+f0&  Q  ?0&<2&[+fe.&[+f  Q  ?0&e.&[+fPU/&g>  Q  ?PU/&g>e.&[+fZ*&`  Q  ?PU/&g>Z*&`R'&V  Q  ?R'&V &+PU/&g>  Q  ?PU/&g> &+ &[(^  Q  ?PU/&g> &[(^.&K  Q  ?.&K &[(^Mc!&/\s  Q  ?.&KMc!&/\so#&  Q  ?d'&pWX%&_)9(&a  Q  ?9(&aWX%&_)PU/&3  Q  ?9(&aPU/&3rM)&=  Q  ?rM)&=PU/&3.&q   Q  ?rM)&=.&q 5O*&  Q  ?5O*&.&q .&mD  Q  ?5O*&.&mD`,&c  Q  ?`,&c.&mD.&m  Q  ?`,&c.&mN/&9  Q  ?N/&9.&mPU/&U  Q  ?N/&9PU/&U0&i  Q  ?d'&pT%&WX%&_)  Q  ?WX%&_)T%&DF!&c  Q  ?WX%&_)DF!&cv$&/K9  Q  ?v$&/K9DF!&c &+  Q  ?v$&/K9 &+WX%&H  Q  ?WX%&H &+R'&V  D>2Zt?2f212&L5f21a  S>	s2i?L5f21a2&L5&a  |?G1L?L5f21aL5&a,8f216i  =1?K0,8?,8f216iL5&a,8&6i  xV?:e1c?,8f216i,8&6i9f21r)=  JXe?$/{>9f21r)=,8&6i9&r)=  3y?O"jj>9f21r)=9&r)=AJ:f212  IQ~?,!j=AJ:f2129&r)=AJ:&2  y?:R701`>rM)f21=rM)&=5O*&  J^r?_*2>rM)f21=5O*&5O*f21  z[?T302G2?5O*f215O*&`,&c  L?($0?5O*f21`,&c`,f21c  ;(?S2bA?`,f21c`,&cN/&9  ?HQ?`,f21cN/&9N/f219  h)>E!2k?N/f219N/&92&  }>HE1u?N/f2192&2f21  /z?2X>rM)&=rM)f21=9(&a  s?lz1>9(&arM)f21=9(f21a  &_?m1#>9(&a9(f21ad'&p  R?K1wg?d'&p9(f21ad'f21p  2?U.[7?d'&pd'f21pT%&  ?G?T%&d'f21pT%f21  =t~?&1= f21+ &+DF!&c  @y?`> f21+DF!&cDF!f21c  |g?X'1>DF!f21cDF!&c"&+t  Y?1Y?DF!f21c"&+t"f21+t  [7?}2?"f21+t"&+tT%&  `"?2E?"f21+tT%&T%f21    ?	dZ0 &+ f21+ &[(^    ?	dZ0 &[(^ f21+ f21[(^  ?AmW
 &[(^ f21[(^Mc!f21/\s  |?5`0X
2 &[(^Mc!f21/\sMc!&/\s  p?1Mc!&/\sMc!f21/\so#f21  g?3O{Mc!&/\so#f21o#&  RQ?!h2o#&o#f21B&f21
  D?<1$o#&B&f21
B&&
  $?1DB&&
B&f21
*f21  ?d1RQB&&
*f21*&  {>2g*&*f21/f21  >"^1p*&/f21/&  X
2>2|/&/f21+5f21	  Y
=j3/&+5f21	+5&	  Kr.;  +5&	+5f21	h?&	  Kr.;  h?&	+5f21	h?f21	  55h?f21	jIf21h?&	  55h?&	jIf21jI&    	1dZjI&jIf21jI&s=    	1dZjI&s=jIf21jIf21s=  Kr1.;2  ?Hf21s=Hes=%es=  Kr1.;2  ?jI&s=jIf21s=0&s=  Kr1.;2  ?0&s=jIf21s=Hf21s=  Kr1.;2  ?0&s=Hf21s=%s=  Kr1.;2  ?%s=Hf21s=%es=    ?	dZ0HiS=H4O=Hes=    ?	dZ0Hes=H4O=H/4	K=    ?	dZ0Hes=H/4	K=He=    ?	dZ0H/4	K=H4mF=He=    ?	dZ0He=H4mF=HC=    ?	dZ0He=HC=HA=    ?	dZ0Hf21=He=H+-A=    ?	dZ0HC=HX4	K=HA=    ?	dZ0HA=HX4	K=H].mF=    ?	dZ0HA=H].mF=He=    ?	dZ0He=H].mF=HAC=    ?	dZ0He=HAC=H+-A=    ?	dZ0H+O=HTiS=Hf21s=    ?	dZ0Hf21s=HTiS=H+-@T=    ?	dZ0Hf21s=H+-@T=Hes=    ?	dZ0Hes=H+-@T=HAiS=    ?	dZ0H+-A=HTC=Hf21=    ?	dZ0Hf21=HTC=H+mF=    ?	dZ0Hf21=H+mF=Hf21s=    ?	dZ0Hf21s=H+mF=Hz4	K=    ?	dZ0Hf21s=Hz4	K=H+O=    ?	dZ0HC=HmF=HX4	K=    ?	dZ0HX4	K=HmF=H4	K=    ?	dZ0HX4	K=H4	K=H].O=    ?	dZ0H].O=H4	K=HO=    ?	dZ0H].O=HO=HAiS=    ?	dZ0HAiS=HO=HiS=    ?	dZ0HAiS=HiS=Hes=    ?	dZ0Hes=HiS=H@T=    ?	dZ0Hes=H@T=HiS=  ;>2NPj%eS=He=%S=  ;>2NPj%S=He=Hf21=  ;>2NPj%S=Hf21=0&c<  ;>2NPj0&c<Hf21=Z2f21s$<  ;>2NPj0&c<Z2f21s$<Z2&s$<  9>L8&X_Z2&s$<Z2f21s$<5&/<  @%?f26/R5&/<Z2f21s$<5f21/<  7?}/Xj25&/<5f21/<58&g_<  G?8L2h58&g_<5f21/<58f21g_<  b?1]58&g_<58f21g_<P9&<  @m?:2LVP9&<58f21g_<P9f21<  )?{?shtJiDP9&<P9f21<AJ:&j<  ~?a.HiAJ:&j<P9f21<AJ:f21j<    ?	dZ0AJ:f212AJ:&2AJ:f21j<    ?	dZ0AJ:f21j<AJ:&2AJ:&j<  0|e/.&.f21.&K  fpr/.&K.f21.f21K  gDE22$.&K.f21KPU/&g>  2$5ygDPU/&g>.f21KPU/f21g>  2fpPU/&g>PU/f21g>0&  /f'20|0&PU/f21g>0f21  />u0|0&0f21P0&g>  >3fpP0&g>0f21P0f21g>  2$?
gDP0&g>P0f21g>J1&K  gD?A+2$J1&KP0f21g>J1f21K  fp?L?J1&KJ1f21K{1&  0|?_2/{1&J1f21K{1f21  0|?e0/>{1&{1f21J1&)  fp?r>J1&){1f21J1f21)  gD?E2$?J1&)J1f21)P0&5  2$?5y1gD?P0&5J1f21)P0f215  >fp?P0&5P0f2150&  />f'0|?0&P0f2150f21  /u20|?0&0f21PU/&5  fp?PU/&50f21PU/f215  2$
1gD?PU/&5PU/f215.&)  gDA+02$?.&)PU/f215.f21)  fpL?/>.&).f21).&  0|_/>.&.f21).f21  }Tc0X'./K9'f21/K9	s(.+  v5X	s(.+'f21/K9	s(f21+  9Y.u	s(.+	s(f21+{*.   Cm>${*. 	s(f21+{*f21   HY00	T{*. {*f21 z-.{  L_11fz-.{{*f21 z-f21{  2Y2|z-.{z-f21{s0.+2  -#(s0.+2z-f21{s0f21+2  !v>W-!sxs0.+2s0f21+254.x  Q<>|$2JEm54.xs0f21+254f21x  kl?sx4I54.x54f21x6.o%  P8?
016.o%54f21x6f21o%  a?976.o%6f21o%108._2  Op?>1108._26f21o%108f21_2  \?Q108._2108f21_2108.6@  \?0=108.6@108f21_2108f216@  Op?g0>108.6@108f216@6.L  a?/c>6.L108f216@6f21L  P8?21?6.L6f21L54.oV  kl?#5I?54.oV6f21L54f21oV  Q<>82JEm?54.oV54f21oVs0./dZ  #v>\{sx?s0./dZ54f21oVs0f21/dZ  -]c2(?s0./dZs0f21/dZz-.X  2'm2|?z-.Xs0f21/dZz-f21X  91f?z-.Xz-f21X{*.R  HYg 	T?{*.Rz-f21X{*f21R  C;f$?{*.R{*f21R	s(.sF  9Y1u?	s(.sF{*f21R	s(f21sF  vR0X>	s(.sF	s(f21sF'./K9  }DYU2X>'./K9	s(f21sF'f21/K9  0|e/.&mD.f21mD.&m  fpr/.&m.f21mD.f21m  gDE22$.&m.f21mPU/&U  2$5ygDPU/&U.f21mPU/f21U  2fpPU/&UPU/f21U0&i  /f'20|0&iPU/f21U0f21i  />u0|0&i0f21iP0&U  >3fpP0&U0f21iP0f21U  2$?
gDP0&UP0f21UJ1&m  gD?A+2$J1&mP0f21UJ1f21m  fp?L?J1&mJ1f21m{1&mD  0|?_2/{1&mDJ1f21m{1f21mD  0|?e0/>{1&mD{1f21mDJ1&q   fp?r>J1&q {1f21mDJ1f21q   gD?E2$?J1&q J1f21q P0&3  2$?5y1gD?P0&3J1f21q P0f213  >fp?P0&3P0f2130&q  />f'0|?0&qP0f2130f21q  /u20|?0&q0f21qPU/&3  fp?PU/&30f21qPU/f213  2$
1gD?PU/&3PU/f213.&q   gDA+02$?.&q PU/f213.f21q   fpL?/>.&q .f21q .&mD  0|_/>.&mD.f21q .f21mD  Q1  2*f21B&f21
.f21  Q1  2J1f21mP0f21U2f21  Q1  22f21P0f21UN/f219  Q1  2.f21B&f21
.f21K  Q1  2.f21.f21)*f21  Q1  2*f21.f21)PU/f215  Q1  2*f21PU/f215/f21  Q1  2/f21PU/f2150f21  Q1  2/f210f21+5f21	  Q1  2+5f21	0f21P0f215  Q1  2+5f21	P0f215h?f21	  Q1  2h?f21	P0f215J1f21)  Q1  2h?f21	J1f21)jIf21  Q1  22f21L5f21aJ1f21m  Q1  2J1f21mL5f21a,8f216i  Q1  2J1f21m,8f216i{1f21mD  Q1  2{1f21mD,8f216ijIf21  Q1  2{1f21mDjIf21J1f21q   Q1  2J1f21q jIf21P0f213  Q1  2P9f21<58f21g_<jIf21s=  Q1  2B&f21
o#f21.f21K  Q1  2.f21Ko#f21Mc!f21/\s  Q1  2.f21KMc!f21/\sPU/f21g>  Q1  2Hf21=Hf21s=Z2f21s$<  Q1  2Z2f21s$<Hf21s=jIf21s=  Q1  2Z2f21s$<jIf21s=5f21/<  Q1  25f21/<jIf21s=58f21g_<  Q1  2	s(f21+'f21/K9 f21+  Q1  2P0f21U0f21iN/f219  Q1  2N/f2190f21iPU/f21U  Q1  2N/f219PU/f21U`,f21c  Q1  2`,f21cPU/f21U.f21m  Q1  2`,f21c.f21m5O*f21  Q1  25O*f21.f21m.f21mD  Q1  25O*f21.f21mDrM)f21=  Q1  2rM)f21=.f21mD.f21q   Q1  2rM)f21=.f21q 9(f21a  Q1  29(f21a.f21q PU/f213  Q1  29(f21aPU/f213d'f21p  Q1  20f21q108f21_26f21o%  Q1  2'f21/K9	s(f21sF f21+  Q1  2 f21+	s(f21sFPU/f21g>  Q1  2 f21+PU/f21g> f21[(^  Q1  2 f21[(^PU/f21g>Mc!f21/\s  Q1  2,8f216i9f21r)=jIf21  Q1  2jIf219f21r)=AJ:f212  Q1  2jIf21AJ:f212jIf21s=  Q1  2jIf21s=AJ:f212AJ:f21j<  Q1  2jIf21s=AJ:f21j<P9f21<  Q1  2DF!f21c"f21+t f21+  Q1  2 f21+"f21+tT%f21  Q1  2 f21+T%f21d'f21p  Q1  2d'f21pPU/f213 f21+  Q1  2 f21+PU/f213{*f21   Q1  2 f21+{*f21 	s(f21+  Q1  2J1f21){1f21jIf21  Q1  2jIf21{1f21J1f21K  Q1  2jIf21J1f21KP0f21g>  Q1  26f21o%54f21x0f21q  Q1  20f21q54f21xs0f21+2  Q1  20f21qs0f21+2PU/f213  Q1  2PU/f213s0f21+2z-f21{  Q1  2PU/f213z-f21{{*f21   Q1  20f21qP0f213108f21_2  Q1  2108f21_2P0f213jIf21  Q1  2108f21_2jIf21108f216@  Q1  2108f216@jIf21P0f21g>  Q1  2108f216@P0f21g>6f21L  Q1  2	s(f21sF{*f21RPU/f21g>  Q1  2PU/f21g>{*f21Rz-f21X  Q1  2PU/f21g>z-f21X0f21  Q1  20f21z-f21Xs0f21/dZ  Q1  20f21s0f21/dZP0f21g>  Q1  2P0f21g>s0f21/dZ54f21oV  Q1  2P0f21g>54f21oV6f21L    	1ZZTz<T;v5<T.^1<    	1ZZT.^1<T;v5<Tvt`<    	1ZZT.^1<Tvt`<TY;pV<    	1ZZTY;pV<Tvt`<TK<    	1ZZTY;pV<TK<TVrt<    	1ZZTVrt<TK<Tn<    	1ZZTVrt<Tn<T\[L<    	1ZZT\[L<Tn<T|tS<    	1ZZT\[L<T|tS<T`K<    	1ZZT`K<T|tS<T8o