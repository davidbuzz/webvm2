neral parameter requests
    switch (_pending_request.frame_type) {
    // construct a response to a ping frame
    case AP_RCProtocol_CRSF::CRSF_FRAMETYPE_PARAM_DEVICE_INFO:
        _custom_telem.params_mode_start_ms = AP_HAL::millis();
        calc_device_info();
        break;
    // construct a ping frame originating here
    case AP_RCProtocol_CRSF::CRSF_FRAMETYPE_PARAM_DEVICE_PING:
        calc_device_ping(_pending_request.destination);
        break;
    case AP_RCProtocol_CRSF::CRSF_FRAMETYPE_PARAMETER_READ:
        // reset parameter passthrough timeout
        _custom_telem.params_mode_start_ms = AP_HAL::millis();
        calc_parameter();
        break;
    default:
        break;
    }

    _pending_request.frame_type = 0;
}

#if AP_VIDEOTX_ENABLED
void AP_CRSF_Telem::update_vtx_params()
{
    AP_VideoTX& vtx = AP::vtx();

    // This function does ugly things with the vtx parameters which will upset other providers
    if (!vtx.get_enabled() || !vtx.is_provider_enabled(AP_VideoTX::VTXType::CRSF)) {
        return;
    }

    _vtx_freq_change_pending = vtx.update_band() || vtx.update_channel() || vtx.update_frequency() || _vtx_freq_change_pending;
    // don't update the power if we are supposed to be in pitmode as this will take us out of pitmode
    const bool pitmode = vtx.get_configured_options() & uint8_t(AP_VideoTX::VideoOptions::VTX_PITMODE);
    _vtx_power_change_pending = !pitmode && (vtx.update_power() || _vtx_power_change_pending);
    _vtx_options_change_pending = vtx.update_options() || _vtx_options_change_pending;

    if (_vtx_freq_change_pending || _vtx_power_change_pending || _vtx_options_change_pending) {
        // make the desired frequency match the desired band and channel
        if (_vtx_freq_change_pending) {
            if (vtx.update_band() || vtx.update_channel()) {
                vtx.update_configured_frequency();
            } else {
                vtx.update_configured_channel_and_band();
            }
        }

        debug("update_params(): freq %d->%d, chan: %d->%d, band: %d->%d, pwr: %d->%d, opts: %d->%d",
            vtx.get_frequency_mhz(),  vtx.get_configured_frequency_mhz(),
            vtx.get_channel(), vtx.get_configured_channel(),
            vtx.get_band(), vtx.get_configured_band(),
            vtx.get_power_mw(), vtx.get_configured_power_mw(),
            vtx.get_options(), vtx.get_configured_options());

        _telem_type = AP_RCProtocol_CRSF::CRSF_FRAMETYPE_COMMAND;
        _telem.ext.command.destination = AP_RCProtocol_CRSF::CRSF_ADDRESS_VTX;
        _telem.ext.command.origin = AP_RCProtocol_CRSF::CRSF_ADDRESS_FLIGHT_CONTROLLER;
        _telem.ext.command.command_id = AP_RCProtocol_CRSF::CRSF_COMMAND_VTX;

        uint8_t len = 5;
        // prioritize option changes so that the pilot can get in and out of pitmode
        if (_vtx_options_change_pending) {
            _telem.ext.command.payload[0] = AP_RCProtocol_CRSF::CRSF_COMMAND_VTX_PITMODE;
            if (vtx.get_configured_options() & uint8_t(AP_VideoTX::VideoOptions::VTX_PITMODE)) {
                _telem.ext.command.payload[1] = 1;
            } else {
                _telem.ext.command.payload[1] = 0;
            }
        } else if (_vtx_freq_change_pending && _vtx_freq_update) {
            _telem.ext.command.payload[0] = AP_RCProtocol_CRSF::CRSF_COMMAND_VTX_FREQ;
            _telem.ext.command.payload[1] = (vtx.get_frequency_mhz() & 0xFF00) >> 8;
            _telem.ext.command.payload[2] = (vtx.get_frequency_mhz() & 0xFF);
            _vtx_freq_update = false;
            len++;
        } else if (_vtx_freq_change_pending) {
            _telem.ext.command.payload[0] = AP_RCProtocol_CRSF::CRSF_COMMAND_VTX_CHANNEL;
            _telem.ext.command.payload[1] = vtx.get_configured_band() * VTX_MAX_CHANNELS + vtx.get_configured_channel();
            _vtx_freq_update = true;
        } else if (_vtx_power_change_pending && _vtx_dbm_update) {
            _telem.ext.command.payload[0] = AP_RCProtocol_CRSF::CRSF_COMMAND_VTX_POWER_DBM;
            _telem.ext.command.payload[1] = vtx.get_configured_power_dbm();
            _vtx_dbm_update = false;
        } else if (_vtx_power_change_pending) {
            _telem.ext.command.payload[0] = AP_RCProtocol_CRSF::CRSF_COMMAND_VTX_POWER;
            if (vtx.get_configured_power_mw() < 26) {
                vtx.set_configured_power_mw(25);
            } else if (vtx.get_configured_power_mw() < 201) {
                if (vtx.get_configured_power_mw() < 101) {
                    vtx.set_configured_power_mw(100);
                } else {
                    vtx.set_configured_power_mw(200);
                }
            } else if (vtx.get_configured_power_mw() < 501) {
                if (vtx.get_configured_power_mw() < 401) {
                    vtx.set_configured_power_mw(400);
                } else {
                    vtx.set_configured_power_mw(500);
                }
            } else {
                vtx.set_configured_power_mw(800);
            }
            _telem.ext.command.payload[1] = vtx.get_configured_power_level();
            _vtx_dbm_update = true;
        }
        _telem_pending = true;
        // calculate command crc
#pragma GCC diagnostic push
#if defined(__GNUC__) &&  __GNUC__ >= 10
#pragma GCC diagnostic ignored "-Wstringop-overflow"
#endif
        uint8_t* crcptr = &_telem.ext.command.destination;
        uint8_t crc = crc8_dvb(0, AP_RCProtocol_CRSF::CRSF_FRAMETYPE_COMMAND, 0xBA);
        for (uint8_t i = 0; i < len; i++) {
            crc = crc8_dvb(crc, crcptr[i], 0xBA);
        }
        crcptr[len] = crc;
        _telem_size = len + 1;
#pragma GCC diagnostic pop
    }
}
#endif  // AP_VIDEOTX_ENABLED

// prepare parameter ping data
void AP_CRSF_Telem::calc_parameter_ping()
{
    _telem_type = AP_RCProtocol_CRSF::CRSF_FRAMETYPE_PARAM_DEVICE_PING;
    _telem.ext.ping.destination = AP_RCProtocol_CRSF::CRSF_ADDRESS_VTX;
    _telem.ext.ping.origin = AP_RCProtocol_CRSF::CRSF_ADDRESS_FLIGHT_CONTROLLER;
    _telem_size = sizeof(ParameterPingFrame);
    _telem_pending = true;
}

// prepare qos data - mandatory frame that must be sent periodically
void AP_CRSF_Telem::calc_heartbeat()
{
    _telem.bcast.heartbeat.origin = AP_RCProtocol_CRSF::CRSF_ADDRESS_FLIGHT_CONTROLLER;
    _telem_size = sizeof(HeartbeatFrame);
    _telem_type = AP_RCProtocol_CRSF::CRSF_FRAMETYPE_HEARTBEAT;
    _telem_pending = true;
}

// prepare battery data
void AP_CRSF_Telem::calc_battery()
{
    const AP_BattMonitor &_battery = AP::battery();

    _telem.bcast.battery.voltage = htobe16(uint16_t(roundf(_battery.voltage(0) * 10.0f)));

    float current;
    if (!_battery.current_amps(current, 0)) {
        current = 0;
    }
    _telem.bcast.battery.current = htobe16(int16_t(roundf(current * 10.0f)));

    float used_mah;
    if (!_battery.consumed_mah(used_mah, 0)) {
        used_mah = 0;
    }

    uint8_t percentage = 0;
    IGNORE_RETURN(_battery.capacity_remaining_pct(percentage, 0));

    _telem.bcast.battery.remaining = percentage;

    const int32_t capacity = used_mah;
    _telem.bcast.battery.capacity[0] = (capacity & 0xFF0000) >> 16;
    _telem.bcast.battery.capacity[1] = (capacity & 0xFF00) >> 8;
    _telem.bcast.battery.capacity[2] = (capacity & 0xFF);

    _telem_size = sizeof(BatteryFrame);
    _telem_type = AP_RCProtocol_CRSF::CRSF_FRAMETYPE_BATTERY_SENSOR;

    _telem_pending = true;
}

uint16_t AP_CRSF_Telem::get_altitude_packed()
{
    int32_t altitude_dm = get_nav_alt_m(Location::AltFrame::ABOVE_HOME) * 10;

    enum : int32_t {
        ALT_MIN_DM = 10000,                     // minimum altitude in dm
        ALT_THRESHOLD_DM = 0x8000 - ALT_MIN_DM, // altitude of precision changing in dm
        ALT_MAX_DM = 0x7ffe * 10 - 5,           // maximum altitude in dm
    };

    if (altitude_dm < -ALT_MIN_DM) { // less than minimum altitude
        return 0; // minimum
    }
    if (altitude_dm > ALT_MAX_DM) { // more than maximum
        return 0xFFFEU; // maximum
    }
    if(altitude_dm < ALT_THRESHOLD_DM) { //dm-resolution range
        return uint16_t(altitude_dm + ALT_MIN_DM);
    }
    return uint16_t((altitude_dm + 5) / 10) | uint16_t(0x8000); // meter-resolution range
}

int8_t AP_CRSF_Telem::get_vertical_speed_packed()
{
    float vspeed = get_vspeed_ms();
    float vertical_speed_cm_s = vspeed * 100.0f;
    const int16_t Kl = 100; // linearity constant;
    const float Kr = .026f; // range constant;
    int8_t vspeed_packed = int8_t(logf(fabsf(vertical_speed_cm_s)/Kl + 1)/Kr);
    return vspeed_packed * (is_negative(vertical_speed_cm_s) ? -1 : 1);
}

// prepare vario data
void AP_CRSF_Telem::calc_baro_vario()
{
    _telem.bcast.baro_vario.altitude_packed = get_altitude_packed();
    _telem.bcast.baro_vario.vertical_speed_packed = get_vertical_speed_packed();

    _telem_size = sizeof(BaroVarioFrame);
    _telem_type = AP_RCProtocol_CRSF::CRSF_FRAMETYPE_BARO_VARIO;

    _telem_pending = true;
}

// prepare vario data
void AP_CRSF_Telem::calc_vario()
{
    _telem.bcast.vario.v_speed = int16_t(get_vspeed_ms() * 100.0f);
    _telem_size = sizeof(VarioFrame);
    _telem_type = AP_RCProtocol_CRSF::CRSF_FRAMETYPE_VARIO;

    _telem_pending = true;
}

// prepare gps data
void AP_CRSF_Telem::calc_gps()
{
    const Location &loc = AP::gps().location(0); // use the first gps instance (same as in send_mavlink_gps_raw)

    _telem.bcast.gps.latitude = htobe32(loc.lat);
    _telem.bcast.gps.longitude = htobe32(loc.lng);
    _telem.bcast.gps.groundspeed = htobe16(roundf(AP::gps().ground_speed() * 100000 / 3600));
    _telem.bcast.gps.altitude = htobe16(constrain_int16(loc.alt / 100, 0, 5000) + 1000);
    _telem.bcast.gps.gps_heading = htobe16(roundf(AP::gps().ground_course() * 100.0f));
    _telem.bcast.gps.satellites = AP::gps().num_sats();

    _telem_size = sizeof(AP_CRSF_Telem::GPSFrame);
    _telem_type = AP_RCProtocol_CRSF::CRSF_FRAMETYPE_GPS;

    _telem_pending = true;
}

// prepare attitude data
void AP_CRSF_Telem::calc_attitude()
{
    AP_AHRS &_ahrs = AP::ahrs();
    WITH_SEMAPHORE(_ahrs.get_semaphore());

    const int16_t INT_PI = 31415;
    // units are radians * 10000
    _telem.bcast.attitude.roll_angle = htobe16(constrain_int16(roundf(wrap_PI(_ahrs.get_roll()) * 10000.0f), -INT_PI, INT_PI));
    _telem.bcast.attitude.pitch_angle = htobe16(constrain_int16(roundf(wrap_PI(_ahrs.get_pitch()) * 10000.0f), -INT_PI, INT_PI));
    _telem.bcast.attitude.yaw_angle = htobe16(constrain_int16(roundf(wrap_PI(_ahrs.get_yaw()) * 10000.0f), -INT_PI, INT_PI));

    _telem_size = sizeof(AP_CRSF_Telem::AttitudeFrame);
    _telem_type = AP_RCProtocol_CRSF::CRSF_FRAMETYPE_ATTITUDE;

    _telem_pending = true;
}

// prepare flight mode data
void AP_CRSF_Telem::calc_flight_mode()
{
    AP_Notify * notify = AP_Notify::get_singleton();
    if (notify) {
        // Note: snprintf() always terminates the string
        hal.util->snprintf(
            _telem.bcast.flightmode.flight_mode, 
            sizeof(AP_CRSF_Telem::FlightModeFrame), 
            "%s%s", 
            notify->get_flight_mode_str(), 
            rc().option_is_enabled(RC_Channels::Option::CRSF_FM_DISARM_STAR) && !hal.util->get_soft_armed() ? "*" : ""
        );
        // Note: strlen(_telem.bcast.flightmode.flight_mode) is safe because called on a guaranteed null terminated string
        _telem_size = strlen(_telem.bcast.flightmode.flight_mode) + 1; //send the terminator as well
        _telem_type = AP_RCProtocol_CRSF::CRSF_FRAMETYPE_FLIGHT_MODE;
        _telem_pending = true;
    }
}

// return device information about ArduPilot
void AP_CRSF_Telem::calc_device_info() {
#if !APM_BUILD_TYPE(APM_BUILD_UNKNOWN)
    _telem.ext.info.destination = _param_request.origin;
    _telem.ext.info.origin = AP_RCProtocol_CRSF::CRSF_ADDRESS_FLIGHT_CONTROLLER;

    const AP_FWVersion &fwver = AP::fwversion();
    // write out the name with version, max width is 60 - 18 = the meaning of life
    int32_t n = strlen(fwver.fw_short_string);
    strncpy((char*)_telem.ext.info.payload, fwver.fw_short_string, 41);
    n = MIN(n + 1, 42);

    put_be32_ptr(&_telem.ext.info.payload[n], // serial number
        uint32_t(fwver.major) << 24 | uint32_t(fwver.minor) << 16 | uint32_t(fwver.patch) << 8 | uint32_t(fwver.fw_type));
    n += 4;
    put_be32_ptr(&_telem.ext.info.payload[n], // hardware id
        uint32_t(fwver.vehicle_type) << 24 | uint32_t(fwver.board_type) << 16 | uint32_t(fwver.board_subtype));
    n += 4;
    put_be32_ptr(&_telem.ext.info.payload[n], fwver.os_sw_version);   // software id
    n += 4;
#if OSD_PARAM_ENABLED
    _telem.ext.info.payload[n++] = AP_OSD_ParamScreen::NUM_PARAMS * AP_OSD_NUM_PARAM_SCREENS; // param count
#else
    _telem.ext.info.payload[n++] = 0; // param count
#endif
    _telem.ext.info.payload[n++] = 0;   // param version

    _telem_size = n + 2;
    _telem_type = AP_RCProtocol_CRSF::CRSF_FRAMETYPE_PARAM_DEVICE_INFO;

    _pending_request.frame_type = 0;
    _telem_pending = true;
#endif
}

// send a device ping
void AP_CRSF_Telem::calc_device_ping(uint8_t destination) {
    _telem.ext.ping.destination = destination;
    _telem.ext.ping.origin = AP_RCProtocol_CRSF::CRSF_ADDRESS_FLIGHT_CONTROLLER;
    _telem_size = 2;
    _telem_type = AP_RCProtocol_CRSF::CRSF_FRAMETYPE_PARAM_DEVICE_PING;
    _pending_request.frame_type = 0;

    _telem_pending = true;
}

// send a command response
void AP_CRSF_Telem::calc_command_response() {
    _telem.ext.command.destination = AP_RCProtocol_CRSF::CRSF_ADDRESS_CRSF_RECEIVER;
    _telem.ext.command.origin = AP_RCProtocol_CRSF::CRSF_ADDRESS_FLIGHT_CONTROLLER;
    _telem.ext.command.command_id = AP_RCProtocol_CRSF::CRSF_COMMAND_GENERAL;
    _telem.ext.command.payload[0] = AP_RCProtocol_CRSF::CRSF_COMMAND_GENERAL_CRSF_SPEED_RESPONSE;
    _telem.ext.command.payload[1] = _baud_rate_request.port_id;
    _telem.ext.command.payload[2] = _baud_rate_request.valid;
    _telem_type = AP_RCProtocol_CRSF::CRSF_FRAMETYPE_COMMAND;

    // calculate command crc
    uint8_t len = 6;
    uint8_t* crcptr = &_telem.ext.command.destination;
    uint8_t crc = crc8_dvb(0, AP_RCProtocol_CRSF::CRSF_FRAMETYPE_COMMAND, 0xBA);
    for (uint8_t i = 0; i < len; i++) {
        crc = crc8_dvb(crc, crcptr[i], 0xBA);
    }
    crcptr[len] = crc;
    _telem_size = len + 1;

    _pending_request.frame_type = 0;
    _baud_rate_request.pending = false;

    debug("sent baud rate response: %u", _baud_rate_request.valid);
    _telem_pending = true;
}

// send a command response
void AP_CRSF_Telem::calc_bind() {
    _telem.ext.command.destination = AP_RCProtocol_CRSF::CRSF_ADDRESS_CRSF_RECEIVER;
    _telem.ext.command.origin = AP_RCProtocol_CRSF::CRSF_ADDRESS_FLIGHT_CONTROLLER;
    _telem.ext.command.command_id = AP_RCProtocol_CRSF::CRSF_COMMAND_RX;
    _telem.ext.command.payload[0] = AP_RCProtocol_CRSF::CRSF_COMMAND_RX_BIND;
    _telem_type = AP_RCProtocol_CRSF::CRSF_FRAMETYPE_COMMAND;

    // calculate command crc
    uint8_t len = 4;
    uint8_t* crcptr = &_telem.ext.command.destination;
    uint8_t crc = crc8_dvb(0, AP_RCProtocol_CRSF::CRSF_FRAMETYPE_COMMAND, 0xBA);
    for (uint8_t i = 0; i < len; i++) {
        crc = crc8_dvb(crc, crcptr[i], 0xBA);
    }
    crcptr[len] = crc;
    _telem_size = len + 1;

    _pending_request.frame_type = 0;
    _bind_request_pending = false;

    debug("sent bind request");
    _telem_pending = true;
}

// return parameter information
void AP_CRSF_Telem::calc_parameter() {
#if OSD_PARAM_ENABLED
    _telem.ext.param_entry.header.destination = _param_request.origin;
    _telem.ext.param_entry.header.origin = AP_RCProtocol_CRSF::CRSF_ADDRESS_FLIGHT_CONTROLLER;
    size_t idx = 0;

    // root folder request
    if (_param_request.param_num == 0) {
        _telem.ext.param_entry.header.param_num = 0;
        _telem.ext.param_entry.header.chunks_left = 0;
        _telem.ext.param_entry.payload[idx++] = 0; // parent folder
        _telem.ext.param_entry.payload[idx++] = ParameterType::FOLDER; // type
        _telem.ext.param_entry.payload[idx++] = 'r'; // "root" name
        _telem.ext.param_entry.payload[idx++] = 'o';
        _telem.ext.param_entry.payload[idx++] = 'o';
        _telem.ext.param_entry.payload[idx++] = 't';
        _telem.ext.param_entry.payload[idx++] = 0; // null terminator

        // write out all of the ids we are going to send
        for (uint8_t i = 0; i < AP_OSD_ParamScreen::NUM_PARAMS * AP_OSD_NUM_PARAM_SCREENS; i++) {
            _telem.ext.param_entry.payload[idx++] = i + 1;
        }
        _telem.ext.param_entry.payload[idx] = 0xFF; // terminator

        _telem_size = sizeof(AP_CRSF_Telem::ParameterSettingsEntryHeader) + 1 + idx;
        _telem_type = AP_RCProtocol_CRSF::CRSF_FRAMETYPE_PARAMETER_SETTINGS_ENTRY;
        _pending_request.frame_type = 0;
        _telem_pending = true;
        return;
    }

    AP_OSD* osd = AP::osd();

    if (osd == nullptr) {
        return;
    }

    AP_OSD_ParamSetting* param = osd->get_setting((_param_request.param_num - 1) / AP_OSD_ParamScreen::NUM_PARAMS,
        (_param_request.param_num - 1) % AP_OSD_ParamScreen::NUM_PARAMS);

    if (param == nullptr) {
        return;
    }

    _telem.ext.param_entry.header.param_num = _param_request.param_num;
#if HAL_CRSF_TELEM_TEXT_SELECTION_ENABLED
    if (param->get_custom_metadata() != nullptr) {
        calc_text_selection(param, _param_request.param_chunk);
        return;
    }
#endif
    _telem.ext.param_entry.header.chunks_left = 0;
    _telem.ext.param_entry.payload[idx++] = 0; // parent folder
    idx++;  // leave a gap for the type
    param->copy_name_camel_case((char*)&_telem.ext.param_entry.payload[idx], 17);
    idx += strnlen((char*)&_telem.ext.param_entry.payload[idx], 16) + 1;

    switch (param->_param_type) {
    case AP_PARAM_INT8: {
        AP_Int8* p = (AP_Int8*)param->_param;
        _telem.ext.param_entry.payload[1] = ParameterType::INT8;
        _telem.ext.param_entry.payload[idx] = p->get();  // value
        _telem.ext.param_entry.payload[idx+1] = int8_t(param->_param_min);  // min
        _telem.ext.param_entry.payload[idx+2] = int8_t(param->_param_max); // max
        _telem.ext.param_entry.payload[idx+3] = int8_t(0);  // default
        idx += 4;
        break;
    }
    case AP_PARAM_INT16: {
        AP_Int16* p = (AP_Int16*)param->_param;
        _telem.ext.param_entry.payload[1] = ParameterType::INT16;
        put_be16_ptr(&_telem.ext.param_entry.payload[idx], p->get());  // value
        put_be16_ptr(&_telem.ext.param_entry.payload[idx+2], param->_param_min);  // min
        put_be16_ptr(&_telem.ext.param_entry.payload[idx+4], param->_param_max); // max
        put_be16_ptr(&_telem.ext.param_entry.payload[idx+6], 0);  // default
        idx += 8;
        break;
    }
    case AP_PARAM_INT32: {
        AP_Int32* p = (AP_Int32*)param->_param;
        _telem.ext.param_entry.payload[1] = ParameterType::FLOAT;
#define FLOAT_ENCODE(f) (int32_t(roundf(f)))
        put_be32_ptr(&_telem.ext.param_entry.payload[idx], p->get());  // value
        put_be32_ptr(&_telem.ext.param_entry.payload[idx+4], FLOAT_ENCODE(param->_param_min));  // min
        put_be32_ptr(&_telem.ext.param_entry.payload[idx+8], FLOAT_ENCODE(param->_param_max)); // max
        put_be32_ptr(&_telem.ext.param_entry.payload[idx+12], FLOAT_ENCODE(0.0f));  // default
#undef FLOAT_ENCODE
        _telem.ext.param_entry.payload[idx+16] = 0; // decimal point
        put_be32_ptr(&_telem.ext.param_entry.payload[idx+17], 1);  // step size
        idx += 21;
        break;
    }
    case AP_PARAM_FLOAT: {
        AP_Float* p = (AP_Float*)param->_param;
        _telem.ext.param_entry.payload[1] = ParameterType::FLOAT;
        uint8_t digits = 0;
        const float incr = MAX(0.001f, param->_param_incr); // a bug in OpenTX prevents this going any smaller

        for (float floatp = incr; floatp < 1.0f; floatp *= 10) {
            digits++;
        }
        const float mult = powf(10, digits);
#define FLOAT_ENCODE(f) (int32_t(roundf(mult * f)))
        put_be32_ptr(&_telem.ext.param_entry.payload[idx], FLOAT_ENCODE(p->get()));  // value
        put_be32_ptr(&_telem.ext.param_entry.payload[idx+4], FLOAT_ENCODE(param->_param_min));  // min
        put_be32_ptr(&_telem.ext.param_entry.payload[idx+8], FLOAT_ENCODE(param->_param_max)); // max
        put_be32_ptr(&_telem.ext.param_entry.payload[idx+12], FLOAT_ENCODE(0.0f));  // default
        _telem.ext.param_entry.payload[idx+16] = digits; // decimal point
        put_be32_ptr(&_telem.ext.param_entry.payload[idx+17], FLOAT_ENCODE(incr));  // step size
#undef FLOAT_ENCODE
        //debug("Encoding param %f(%f -> %f, %f) as %d(%d) (%d -> %d, %d)", p->get(),
        //    param->_param_min.get(), param->_param_max.get(), param->_param_incr.get(),
        //    int(FLOAT_ENCODE(p->get())), digits, int(FLOAT_ENCODE(param->_param_min)),
        //    int(FLOAT_ENCODE(param->_param_max)), int(FLOAT_ENCODE(param->_param_incr)));
        idx += 21;
        break;
    }
    default:
        return;
    }
    _telem.ext.param_entry.payload[idx] = 0; // units

    _telem_size = sizeof(AP_CRSF_Telem::ParameterSettingsEntryHeader) + 1 + idx;
    _telem_type = AP_RCProtocol_CRSF::CRSF_FRAMETYPE_PARAMETER_SETTINGS_ENTRY;

    _pending_request.frame_type = 0;
    _telem_pending = true;
#endif  // OSD_PARAM_ENABLED
}

#if HAL_CRSF_TELEM_TEXT_SELECTION_ENABLED
// class that spits out a chunk of data from a larger stream of contiguous chunks
// the caller describes which chunk it needs and provides this class with all of the data
// data is not written until the start position is reached and after a whole chunk
// is accumulated the rest of the data is skipped in order to determine how many chunks
// are left to be sent
class BufferChunker {
public:
    BufferChunker(uint8_t* buf, uint16_t chunk_size, uint16_t start_chunk) :
        _buf(buf), _idx(0), _start_chunk(start_chunk), _chunk_size(chunk_size), _chunk(0), _bytes(0) {
    }

    // accumulate a string, writing to the underlying buffer as required
    void put_string(const char* str, uint16_t str_len) {
        // skip over data we have already written or have yet to write
        if (_chunk != _start_chunk) {
            if (skip_bytes(str_len)) {
                // partial write
                strncpy((char*)_buf, &str[str_len - _idx], _idx);
                _bytes += _idx;
            }
            return;
        }

        uint16_t rem = remaining();
        if (rem > str_len) {
            strncpy_noterm((char*)&_buf[_idx], str, str_len);
            _idx += str_len;
            _bytes += str_len;
        } else {
            strncpy_noterm((char*)&_buf[_idx], str, rem);
            _chunk++;
            _idx += str_len;
            _bytes += rem;
            _idx %= _chunk_size;
        }
    }

    // accumulate a byte, writing to the underlying buffer as required
    void put_byte(uint8_t b) {
        if (_chunk != _start_chunk) {
            if (skip_bytes(1)) {
                _buf[0] = b;
                _bytes++;
            }
            return;
        }
        if (remaining() > 0) {
            _buf[_idx++] = b;
            _bytes++;
        } else {
            _chunk++;
            _idx = 0;
        }
    }

    uint8_t chunks_remaining() const { return _chunk - _start_chunk; }
    uint8_t bytes_written() const { return _bytes; }

private:
    uint16_t remaining() const { return _chunk_size - _bytes; }

    // skip over the requested number of bytes
    // returns true if we overflow into a chunk that needs to be written
    bool skip_bytes(uint16_t len) {
        _idx += len;
        if (_idx >= _chunk_size) {
            _chunk++;
            _idx %= _chunk_size;
            // partial write
            if (_chunk == _start_chunk && _idx > 0) {
                return true;
            }
        }
        return false;
    }

    uint8_t* _buf;
    uint16_t _idx;
    uint16_t _bytes;
    uint8_t _chunk;
    const uint16_t _start_chunk;
    const uint16_t _chunk_size;
};

// provide information about a text selection, possibly over multiple chunks
void AP_CRSF_Telem::calc_text_selection(AP_OSD_ParamSetting* param, uint8_t chunk)
{
    const uint8_t CHUNK_SIZE = 56;
    const AP_OSD_ParamSetting::ParamMetadata* metadata = param->get_custom_metadata();

    // chunk the output
    BufferChunker chunker(_telem.ext.param_entry.payload, CHUNK_SIZE, chunk);

    chunker.put_byte(0);  // parent folder
    chunker.put_byte(ParameterType::TEXT_SELECTION);  // parameter type

    char name[17];
    param->copy_name_camel_case(name, 17);
    chunker.put_string(name, strnlen(name, 16)); // parameter name
    chunker.put_byte(0);  // trailing null

    for (uint8_t i = 0; i < metadata->values_max; i++) {
        uint8_t len = strnlen(metadata->values[i], 16);
        if (len == 0) {
            chunker.put_string("---", 3);
        } else {
            chunker.put_string(metadata->values[i], len);
        }
        if (i == metadata->values_max - 1) {
            chunker.put_byte(0);
        } else {
            chunker.put_byte(';');
        }
    }

    int32_t val = -1;
    switch (param->_param_type) {
    case AP_PARAM_INT8:
        val = ((AP_Int8*)param->_param)->get();
        break;
    case AP_PARAM_INT16:
        val = ((AP_Int16*)param->_param)->get();
        break;
    case AP_PARAM_INT32:
        val = ((AP_Int32*)param->_param)->get();
        break;
    default:
        return;
    }

    // out of range values really confuse the TX
    val = constrain_int16(val, 0, metadata->values_max - 1);
    chunker.put_byte(val);  // value
    chunker.put_byte(0);  // min
    chunker.put_byte(metadata->values_max); // max
    chunker.put_byte(0);  // default
    chunker.put_byte(0); // units

    _telem.ext.param_entry.header.chunks_left = chunker.chunks_remaining();

    _telem_size = sizeof(AP_CRSF_Telem::ParameterSettingsEntryHeader) + chunker.bytes_written();
    _telem_type = AP_RCProtocol_CRSF::CRSF_FRAMETYPE_PARAMETER_SETTINGS_ENTRY;

    _pending_request.frame_type = 0;
    _telem_pending = true;
}
#endif  // HAL_CRSF_TELEM_TEXT_SELECTION_ENABLED

// write parameter information back into AP - assumes we already know the encoding for floats
void AP_CRSF_Telem::process_param_write_frame(ParameterSettingsWriteFrame* write_frame)
{
    debug("process_param_write_frame: %d -> %d", write_frame->origin, write_frame->destination);
    if (write_frame->destination != AP_RCProtocol_CRSF::CRSF_ADDRESS_FLIGHT_CONTROLLER) {
        return; // request was not for us
    }
#if OSD_PARAM_ENABLED
    AP_OSD* osd = AP::osd();

    if (osd == nullptr) {
        return;
    }

    AP_OSD_ParamSetting* param = osd->get_setting((write_frame->param_num - 1) / AP_OSD_ParamScreen::NUM_PARAMS,
        (write_frame->param_num - 1) % AP_OSD_ParamScreen::NUM_PARAMS);

    if (param == nullptr) {
        return;
    }

#if HAL_CRSF_TELEM_TEXT_SELECTION_ENABLED
    bool text_selection = param->get_custom_metadata() != nullptr;
#else
    bool text_selection = false;
#endif

    switch (param->_param_type) {
    case AP_PARAM_INT8: {
        AP_Int8* p = (AP_Int8*)param->_param;
        p->set_and_save(write_frame->payload[0]);
        break;
    }
    case AP_PARAM_INT16: {
        AP_Int16* p = (AP_Int16*)param->_param;
        if (text_selection) {
            // if we have custom metadata then the parameter is a text selection
            p->set_and_save(write_frame->payload[0]);
        } else {
            p->set_and_save(be16toh_ptr(write_frame->payload));
        }
        break;
    }
    case AP_PARAM_INT32: {
        AP_Int32* p = (AP_Int32*)param->_param;
        if (text_selection) {
            // if we have custom metadata then the parameter is a text selection
            p->set_and_save(write_frame->payload[0]);
        } else {
            p->set_and_save(be32toh_ptr(write_frame->payload));
        }
        break;
    }
    case AP_PARAM_FLOAT: {
        AP_Float* p = (AP_Float*)param->_param;
        const int32_t val = be32toh_ptr(write_frame->payload);
        uint8_t digits = 0;
        const float incr = MAX(0.001f, param->_param_incr); // a bug in OpenTX prevents this going any smaller

        for (float floatp = incr; floatp < 1.0f; floatp *= 10) {
            digits++;
        }
        p->set_and_save(float(val) / powf(10, digits));
        break;
    }
    default:
        break;
    }
#endif  // OSD_PARAM_ENABLED
}

// get status text data
void AP_CRSF_Telem::calc_status_text()
{
    if (!_statustext.available) {
        WITH_SEMAPHORE(_statustext.sem);
        // check link speed
        if (_crsf_version.protocol != AP_RCProtocol_CRSF::ProtocolType::PROTOCOL_ELRS
                && !is_high_speed_telemetry(_telem_rf_mode)) {
            // keep only warning/error/critical/alert/emergency status text messages
            bool got_message = false;
            while (_statustext.queue.pop(_statustext.next)) {
                if (_statustext.next.severity <= MAV_SEVERITY_WARNING) {
                    got_message = true;
                    break;
                }
            }
            if (!got_message) {
                return;
            }
        } else if (!_statustext.queue.pop(_statustext.next)) {
            return;
        }
        _statustext.available = true;
    }

    _telem_type = get_custom_telem_frame_id();
    _telem.bcast.custom_telem.status_text.sub_type = AP_RCProtocol_CRSF::CustomTelemSubTypeID::CRSF_AP_CUSTOM_TELEM_STATUS_TEXT;
    _telem.bcast.custom_telem.status_text.severity = _statustext.next.severity;
    // Note: snprintf() always terminates the string
    hal.util->snprintf(_telem.bcast.custom_telem.status_text.text, AP_CRSF_Telem::PASSTHROUGH_STATUS_TEXT_FRAME_MAX_SIZE, "%s", _statustext.next.text);
    // frame size = sub_type(1) + severity(1) + strlen(text) + terminator
    // Note: strlen(_telem.bcast.custom_telem.status_text.text) is safe because called on a guaranteed null terminated string
    _telem_size = 2 + strlen(_telem.bcast.custom_telem.status_text.text) + 1;
    _telem_pending = true;
    _statustext.available = false;
}

/*
 Get 1 packet of passthrough telemetry data
*/
void AP_CRSF_Telem::get_single_packet_passthrough_telem_data()
{
    _telem_pending = false;
    uint8_t packet_count;
    AP_Frsky_SPort::sport_packet_t packet;
    if (!AP_Frsky_Telem::get_telem_data(&packet, packet_count, 1)) {
        return;
    }
    _telem.bcast.custom_telem.single_packet_passthrough.sub_type = AP_RCProtocol_CRSF::CustomTelemSubTypeID::CRSF_AP_CUSTOM_TELEM_SINGLE_PACKET_PASSTHROUGH;
    _telem.bcast.custom_telem.single_packet_passthrough.appid = packet.appid;
    _telem.bcast.custom_telem.single_packet_passthrough.data = packet.data;
    _telem_size = sizeof(AP_CRSF_Telem::PassthroughSinglePacketFrame);
    _telem_type = get_custom_telem_frame_id();
    _telem_pending = true;
}

/*
 Get up to PASSTHROUGH_MULTI_PACKET_FRAME_MAX_SIZE packets of passthrough telemetry data (for slow links)
 Note: we have 2 distinct frame types (single packet vs multi packet) because
 whenever possible we use smaller frames for they have a higher "chance"
 of being transmitted by the crossfire RX scheduler.
*/
void AP_CRSF_Telem::get_multi_packet_passthrough_telem_data(uint8_t size)
{
    size = MIN(size, AP_CRSF_Telem::PASSTHROUGH_MULTI_PACKET_FRAME_MAX_SIZE);
    _telem_pending = false;
    uint8_t count = 0;
    AP_Frsky_SPort::sport_packet_t buffer[AP_CRSF_Telem::PASSTHROUGH_MULTI_PACKET_FRAME_MAX_SIZE] {};
    // we request a PASSTHROUGH_MULTI_PACKET_FRAME_MAX_SIZE packet array, i.e. 9 packets
    if (!AP_Frsky_Telem::get_telem_data(buffer, count, size)) {
        return;
    }
    _telem.bcast.custom_telem.multi_packet_passthrough.sub_type = AP_RCProtocol_CRSF::CustomTelemSubTypeID::CRSF_AP_CUSTOM_TELEM_MULTI_PACKET_PASSTHROUGH;
    for (uint8_t idx=0; idx<count; idx++) {
        _telem.bcast.custom_telem.multi_packet_passthrough.packets[idx].appid = buffer[idx].appid;
        _telem.bcast.custom_telem.multi_packet_passthrough.packets[idx].data = buffer[idx].data;
    }
    _telem.bcast.custom_telem.multi_packet_passthrough.size = count;
    _telem_size = 2 + sizeof(AP_CRSF_Telem::PassthroughMultiPacketFrame::PassthroughTelemetryPacket)*count; //subtype + size + 6*count
    _telem_type = get_custom_telem_frame_id();
    _telem_pending = true;
}

/*
  fetch CRSF frame data
  if is_tx_active is true then this will be a request for telemetry after receiving an RC frame
 */
bool AP_CRSF_Telem::_get_telem_data(AP_RCProtocol_CRSF::Frame* data, bool is_tx_active)
{
    memset(&_telem, 0, sizeof(TelemetryPayload));
    // update telemetry tasks if we either lost or regained the transmitter
    if (_is_tx_active != is_tx_active) {
        if (is_tx_active) {
            disable_scheduler_entry(DEVICE_PING);
            enable_tx_entries();
        } else {
            disable_tx_entries();
            enable_scheduler_entry(DEVICE_PING);
        }
        _is_tx_active = is_tx_active;
    }

    run_wfq_scheduler();
    if (!_telem_pending) {
        return false;
    }
    memcpy(data->payload, &_telem, _telem_size);
    data->device_address = AP_RCProtocol_CRSF::CRSF_ADDRESS_FLIGHT_CONTROLLER;  // sync byte
    data->length = _telem_size + 2;
    data->type = _telem_type;

    _telem_pending = false;
    return true;
}

/*
  fetch data for an external transport, such as CRSF
 */
bool AP_CRSF_Telem::process_frame(AP_RCProtocol_CRSF::FrameType frame_type, void* data)
{
    if (!get_singleton()) {
        return false;
    }
    return singleton->_process_frame(frame_type, data);
}

/*
  fetch data for an external transport, such as CRSF
 */
bool AP_CRSF_Telem::get_telem_data(AP_RCProtocol_CRSF::Frame* data, bool is_tx_active)
{
    if (!get_singleton()) {
        return false;
    }
    return singleton->_get_telem_data(data, is_tx_active);
}

AP_CRSF_Telem *AP_CRSF_Telem::get_singleton(void) {
    if (!singleton && !hal.util->get_soft_armed()) {
        // if telem data is requested when we are disarmed and don't
        // yet have a AP_CRSF_Telem object then try to allocate one
        NEW_NOTHROW AP_CRSF_Telem();
        // initialize the passthrough scheduler
        if (singleton) {
            singleton->init();
        }
    }
    return singleton;
}

namespace AP {
    AP_CRSF_Telem *crsf_telem() {
        return AP_CRSF_Telem::get_singleton();
    }
};

#endif  // HAL_CRSF_TELEM_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ET_ECU_STATE_EMERGENCY = 0x39,
		HORNET_ECU_STATE_FUEL_HEAT = 0x3A,
		HORNET_ECU_STATE_FUEL_IGNITE = 0x3B,
		HORNET_ECU_STATE_GO_IDLE = 0x3C,
		HORNET_ECU_STATE_PROP_IGNITE = 0x3D,
		HORNET_ECU_STATE_RAMP_DELAY = 0x3E,
		HORNET_ECU_STATE_RAMP_UP = 0x3F,
		HORNET_ECU_STATE_STANDBY = 0x40,
		HORNET_ECU_STATE_STEADY = 0x41,
		HORNET_ECU_STATE_WAIT_ACC = 0x42,
		HORNET_ECU_STATE_ERROR = 0x43,
		// undefined states 0x44-0x4F
		XICOY_ECU_STATE_Temp_High = 0x50,
		XICOY_ECU_STATE_Trim_Low = 0x51,
		XICOY_ECU_STATE_Set_Idle = 0x52,
		XICOY_ECU_STATE_Ready = 0x53,
		XICOY_ECU_STATE_Ignition = 0x54,
		XICOY_ECU_STATE_Fuel_Ramp = 0x55,
		XICOY_ECU_STATE_Glow_Test = 0x56,
		XICOY_ECU_STATE_Running = 0x57,
		XICOY_ECU_STATE_Stop = 0x58,
		XICOY_ECU_STATE_Flameout = 0x59,
		XICOY_ECU_STATE_Speed_Low = 0x5A,
		XICOY_ECU_STATE_Cooling = 0x5B,
		XICOY_ECU_STATE_Igniter_Bad = 0x5C,
		XICOY_ECU_STATE_Starter_F = 0x5D,
		XICOY_ECU_STATE_Weak_Fuel = 0x5E,
		XICOY_ECU_STATE_Start_On = 0x5F,
		XICOY_ECU_STATE_Pre_Heat = 0x60,
		XICOY_ECU_STATE_Battery = 0x61,
		XICOY_ECU_STATE_Time_Out = 0x62,
		XICOY_ECU_STATE_Overload = 0x63,
		XICOY_ECU_STATE_Igniter_Fail = 0x64,
		XICOY_ECU_STATE_Burner_On = 0x65,
		XICOY_ECU_STATE_Starting = 0x66,
		XICOY_ECU_STATE_SwitchOver = 0x67,
		XICOY_ECU_STATE_Cal_Pump = 0x68,
		XICOY_ECU_STATE_Pump_Limit = 0x69,
		XICOY_ECU_STATE_No_Engine = 0x6A,
		XICOY_ECU_STATE_Pwr_Boost = 0x6B,
		XICOY_ECU_STATE_Run_Idle = 0x6C,
		XICOY_ECU_STATE_Run_Max = 0x6D,
		// undefined states 0x6e-0x73
		JETCENT_ECU_STATE_STOP = 0x74,
		JETCENT_ECU_STATE_GLOW_TEST = 0x75,
		JETCENT_ECU_STATE_STARTER_TEST = 0x76,
		JETCENT_ECU_STATE_PRIME_FUEL = 0x77,
		JETCENT_ECU_STATE_PRIME_BURNER = 0x78,
		JETCENT_ECU_STATE_MAN_COOL = 0x79,
		JETCENT_ECU_STATE_AUTO_COOL = 0x7A,
		JETCENT_ECU_STATE_IGN_HEAT = 0x7B,
		JETCENT_ECU_STATE_IGNITION = 0x7C,
		JETCENT_ECU_STATE_PREHEAT = 0x7D,
		JETCENT_ECU_STATE_SWITCHOVER = 0x7E,
		JETCENT_ECU_STATE_TO_IDLE = 0x7F,
		JETCENT_ECU_STATE_RUNNING = 0x80,
		JETCENT_ECU_STATE_STOP_ERROR = 0x81,
		// undefined states 0x82-0x8F
		SWIWIN_ECU_STATE_STOP = 0x90,
		SWIWIN_ECU_STATE_READY = 0x91,
		SWIWIN_ECU_STATE_IGNITION = 0x92,
		SWIWIN_ECU_STATE_PREHEAT = 0x93,
		SWIWIN_ECU_STATE_FUEL_RAMP = 0x94,
		SWIWIN_ECU_STATE_RUNNING = 0x95,
		SWIWIN_ECU_STATE_COOLING = 0x96,
		SWIWIN_ECU_STATE_RESTART_SWOVER = 0x97,
		SWIWIN_ECU_STATE_NOTUSED = 0x98,
		// undefined states 0x99-0x9F

		TURBINE_ECU_MAX_STATE = 0x9F
};

enum JETCAT_ECU_OFF_CONDITIONS {					// ECU off conditions. Valid only when the ECUStatus = JETCAT_ECU_STATE_OFF
		JETCAT_ECU_OFF_No_Off_Condition_defined = 0,
		JETCAT_ECU_OFF_Shut_down_via_RC,
		JETCAT_ECU_OFF_Overtemperature,
		JETCAT_ECU_OFF_Ignition_timeout,
		JETCAT_ECU_OFF_Acceleration_time_out,
		JETCAT_ECU_OFF_Acceleration_too_slow,
		JETCAT_ECU_OFF_Over_RPM,
		JETCAT_ECU_OFF_Low_Rpm_Off,
		JETCAT_ECU_OFF_Low_Battery,
		JETCAT_ECU_OFF_Auto_Off,
		JETCAT_ECU_OFF_Low_temperature_Off,
		JETCAT_ECU_OFF_Hi_Temp_Off,
		JETCAT_ECU_OFF_Glow_Plug_defective,
		JETCAT_ECU_OFF_Watch_Dog_Timer,
		JETCAT_ECU_OFF_Fail_Safe_Off,
		JETCAT_ECU_OFF_Manual_Off, // (via GSU)
		JETCAT_ECU_OFF_Power_fail, // (Battery fail)
		JETCAT_ECU_OFF_Temp_Sensor_fail, // (only during startup)
		JETCAT_ECU_OFF_Fuel_fail,
		JETCAT_ECU_OFF_Prop_fail,
		JETCAT_ECU_OFF_2nd_Engine_fail,
		JETCAT_ECU_OFF_2nd_Engine_Diff_Too_High,
		JETCAT_ECU_OFF_2nd_Engine_No_Comm,
		JETCAT_ECU_MAX_OFF_COND,
		// Jet Central
		JETCENT_ECU_OFF_No_Off_Condition_defined = 24,		// ECU off conditions. Valid only when the ECUStatus = JETCENT_ECU_STATE_STOP or JETCENT_ECU_STATE_STOP_ERROR or JETCENT_ECU_STATE_RUNNING
		JETCENT_ECU_OFF_IGNITION_ERROR,
		JETCENT_ECU_OFF_PREHEAT_ERROR,
		JETCENT_ECU_OFF_SWITCHOVER_ERROR,
		JETCENT_ECU_OFF_STARTER_MOTOR_ERROR,
		JETCENT_ECU_OFF_TO_IDLE_ERROR,
		JETCENT_ECU_OFF_ACCELERATION_ERROR,
		JETCENT_ECU_OFF_IGNITER_BAD,
		JETCENT_ECU_OFF_MIN_PUMP_OK,
		JETCENT_ECU_OFF_MAX_PUMP_OK,
		JETCENT_ECU_OFF_LOW_RX_BATTERY,
		JETCENT_ECU_OFF_LOW_ECU_BATTERY,
		JETCENT_ECU_OFF_NO_RX,
		JETCENT_ECU_OFF_TRIM_DOWN,
		JETCENT_ECU_OFF_TRIM_UP,
		JETCENT_ECU_OFF_FAILSAFE,
		JETCENT_ECU_OFF_FULL,
		JETCENT_ECU_OFF_RX_SETUP_ERROR,
		JETCENT_ECU_OFF_TEMP_SENSOR_ERROR,
		JETCENT_ECU_OFF_COM_TURBINE_ERROR,
		JETCENT_ECU_OFF_MAX_TEMP,
		JETCENT_ECU_OFF_MAX_AMPS,
		JETCENT_ECU_OFF_LOW_RPM,
		JETCENT_ECU_OFF_ERROR_RPM_SENSOR,
		JETCENT_ECU_OFF_MAX_PUMP,
		JETCENT_ECU_MAX_OFF_COND
};

typedef struct
{
	UINT8		identifier;														// Source device = 0x19
	UINT8		sID;															// Secondary ID
	UINT16		FuelFlowRateMLMin;												// (BCD) mL per Minute
	UINT32		RestFuelVolumeInTankML;											// (BCD) mL remaining in tank
	UINT8		ECUbatteryPercent;												// (BCD) % battery pack capacity remaining
	// 7 bytes left
} STRU_TELE_JETCAT2;

//////////////////////////////////////////////////////////////////////////////
//
//								GPS
//						  Packed-BCD Type
//
//////////////////////////////////////////////////////////////////////////////
//
typedef struct
{
	UINT8		identifier;														// Source device = 0x16
	UINT8		sID;															// Secondary ID
	UINT16		altitudeLow;													// BCD, meters, format 3.1 (Low order of altitude)
	UINT32		latitude;														// BCD, format 4.4, Degrees * 100 + minutes, less than 100 degrees
	UINT32		longitude;														// BCD, format 4.4 , Degrees * 100 + minutes, flag indicates > 99 degrees
	UINT16		course;															// BCD, 3.1
	UINT8		HDOP;															// BCD, format 1.1
	UINT8		GPSflags;														// see definitions below
} STRU_TELE_GPS_LOC;

typedef struct
{
	UINT8		identifier;														// Source device = 0x17
	UINT8		sID;															// Secondary ID
	UINT16		speed;															// BCD, knots, format 3.1
	UINT32		UTC;															// BCD, format HH:MM:SS.S, format 6.1
	UINT8		numSats;														// BCD, 0-99
	UINT8		altitudeHigh;													// BCD, meters, format 2.0 (High order of altitude)
} STRU_TELE_GPS_STAT;

// GPS flags definitions:
#define	GPS_INFO_FLAGS_IS_NORTH_BIT					(0)
#define	GPS_INFO_FLAGS_IS_NORTH						(1 << GPS_INFO_FLAGS_IS_NORTH_BIT)
#define	GPS_INFO_FLAGS_IS_EAST_BIT					(1)
#define	GPS_INFO_FLAGS_IS_EAST						(1 << GPS_INFO_FLAGS_IS_EAST_BIT)
#define	GPS_INFO_FLAGS_LONGITUDE_GREATER_99_BIT		(2)
#define	GPS_INFO_FLAGS_LONGITUDE_GREATER_99			(1 << GPS_INFO_FLAGS_LONGITUDE_GREATER_99_BIT)
#define	GPS_INFO_FLAGS_GPS_FIX_VALID_BIT			(3)
#define	GPS_INFO_FLAGS_GPS_FIX_VALID				(1 << GPS_INFO_FLAGS_GPS_FIX_VALID_BIT)
#define	GPS_INFO_FLAGS_GPS_DATA_RECEIVED_BIT		(4)
#define	GPS_INFO_FLAGS_GPS_DATA_RECEIVED			(1 << GPS_INFO_FLAGS_GPS_DATA_RECEIVED_BIT)
#define	GPS_INFO_FLAGS_3D_FIX_BIT					(5)
#define	GPS_INFO_FLAGS_3D_FIX						(1 << GPS_INFO_FLAGS_3D_FIX_BIT)
#define GPS_INFO_FLAGS_NEGATIVE_ALT_BIT				(7)
#define GPS_INFO_FLAGS_NEGATIVE_ALT					(1 << GPS_INFO_FLAGS_NEGATIVE_ALT_BIT)

//////////////////////////////////////////////////////////////////////////////
//
//								GPS
//							Binary Type
//
//		NOTE:	Data resolution for all fields matches Crossfire EXCEPT speed.
//
//////////////////////////////////////////////////////////////////////////////
//
typedef struct
{
	UINT8		identifier;														// Source device = 0x26
	UINT8		sID;															// Secondary ID
	UINT16		altitude;														// m, 1000m offset
	INT32		latitude;														// degree / 10,000,000
	INT32		longitude;														// degree / 10,000,000
	UINT16		heading;														// degree / 10
	UINT8		groundSpeed;													// km/h
	UINT8		numSats;														// count
} STRU_TELE_GPS_BINARY;

//////////////////////////////////////////////////////////////////////////////
//
//					AS3X Legacy Gain Report
//
//////////////////////////////////////////////////////////////////////////////
//
typedef struct
{
	UINT8		identifier;														// Source device = TELE_DEVICE_AS3X_LEGACYGAIN
	UINT8		sID;															// Secondary ID
	UINT8		gainRoll;														// Configured normal gains per axis
	UINT8		gainPitch;
	UINT8		gainYaw;
	UINT8		headRoll;														// Configured heading hold gains per axis
	UINT8		headPitch;
	UINT8		headYaw;
	UINT8		activeRoll;														// Active gains per axis (as affected by FM channel)
	UINT8		activePitch;
	UINT8		activeYaw;
	UINT8		flightMode;														// bit 7 1 --> FM present in bits 0,1 except 0xFF --> not present
	UINT8		unused[4];
} STRU_TELE_AS3X_LEGACY;

//////////////////////////////////////////////////////////////////////////////
//
//					AS6X Gain Report (AS3X Legacy + more fields)
//
//////////////////////////////////////////////////////////////////////////////
//
typedef struct
{
	UINT8		identifier;														// Source device = TELE_DEVICE_AS6X_GAIN
	UINT8		sID;															// Secondary ID
	UINT8		gainRoll;														// Configured normal gains per axis
	UINT8		gainPitch;
	UINT8		gainYaw;
	UINT8		headRoll;														// Configured heading hold gains per axis
	UINT8		headPitch;
	UINT8		headYaw;
	UINT8		activeRoll;														// Active gains per axis (as affected by FM channel)
	UINT8		activePitch;
	UINT8		activeYaw;
	UINT8		flightMode;														// bit 7 1 --> FM present in bits 0,1 except 0xFF --> not present
	// new fields go here:
	UINT8		unused[4];
} STRU_TELE_AS6X_GAIN;

//////////////////////////////////////////////////////////////////////////////
//
//							GYRO
//
//////////////////////////////////////////////////////////////////////////////
//
typedef struct
{
	UINT8		identifier;														// Source device = 0x1A
	UINT8		sID;															// Secondary ID
	INT16		gyroX;															// Rotation rates of the body - Rate is about the X Axis which is defined out the nose of the vehicle.
	INT16		gyroY;															// Units are 0.1 deg/sec  - Rate is about the Y Axis which is define out the right wing of the vehicle.
	INT16		gyroZ;															// Rate is about the Z axis which is defined down from the vehicle.
	INT16		maxGyroX;														// Max rates (absolute value)
	INT16		maxGyroY;
	INT16		maxGyroZ;
} STRU_TELE_GYRO;

//////////////////////////////////////////////////////////////////////////////
//
//						Alpha6 Stabilizer
//
//////////////////////////////////////////////////////////////////////////////
//
typedef struct
{
	UINT8		identifier;														// Source device = 0x24
	UINT8		sID;															// Secondary ID
	UINT16		volts;															// 0.01V increments
	UINT8		state_FM;														// Flight Mode and System State (see below)
	UINT8		gainRoll,														// Roll Gain,  high bit --> Heading Hold
				gainPitch,														// Pitch Gain
				gainYaw;														// Yaw Gain
	INT16		attRoll,														// Roll Attitude, 0.1degree, RHR
				attPitch,														// Pitch Attitude
				attYaw;															// Yaw Attitude
	UINT16		spare;
} STRU_TELE_ALPHA6;

#define	GBOX_STATE_BOOT							(0x00)							// Alpha6 State - Boot
#define	GBOX_STATE_INIT							(0x01)							// Init
#define	GBOX_STATE_READY						(0x02)							// Ready
#define	GBOX_STATE_SENSORFAULT					(0x03)							// Sensor Fault
#define	GBOX_STATE_POWERFAULT					(0x04)							// Power Fault
#define	GBOX_STATE_MASK							(0x0F)

#define	GBOX_FMODE_FM0							(0x00)							// FM0 through FM4
#define	GBOX_FMODE_FM1							(0x10)
#define	GBOX_FMODE_FM2							(0x20)
#define	GBOX_FMODE_FM3							(0x30)
#define	GBOX_FMODE_FM4							(0x40)
#define	GBOX_FMODE_PANIC						(0x50)
#define	GBOX_FMODE_MASK							(0xF0)

//////////////////////////////////////////////////////////////////////////////
//
//						ATTITUDE & MAG COMPASS
//
//////////////////////////////////////////////////////////////////////////////
//
typedef struct
{
	UINT8		identifier;														// Source device = 0x1B
	UINT8		sID;															// Secondary ID
	INT16		attRoll;														// Attitude, 3 axes.  Roll is a rotation about the X Axis of the vehicle using the RHR.
	INT16		attPitch;														// Units are 0.1 deg - Pitch is a rotation about the Y Axis of the vehicle using the RHR.
	INT16		attYaw;															// Yaw is a rotation about the Z Axis of the vehicle using the RHR.
	INT16		magX;															// Magnetic Compass, 3 axes
	INT16		magY;															// Units are 0.1mG
	INT16		magZ;															//
	UINT16		heading;														// Heading, 0.1deg
} STRU_TELE_ATTMAG;

//////////////////////////////////////////////////////////////////////////////
//
//						Altitude "Zero" Message
//
//////////////////////////////////////////////////////////////////////////////
//
typedef struct
{
	UINT8		identifier;														// Source device = 0x7B
	UINT8		sID;															// Secondary ID
	UINT8		spare[2];
	UINT32		altOffset;														// Altitude "zero" log
} STRU_TELE_ALT_ZERO;

//////////////////////////////////////////////////////////////////////////////
//
//						Real-Time Clock
//
//////////////////////////////////////////////////////////////////////////////
//
typedef struct
{
	UINT8		identifier;														// Source device = 0x7C
	UINT8		sID;															// Secondary ID
	UINT8		spare[6];
	UINT64		UTC64;															// Linux 64-bit time_t for post-2038 date compatibility
} STRU_TELE_RTC;

//////////////////////////////////////////////////////////////////////////////
//
//						V-Speak (Placeholder)
//
//////////////////////////////////////////////////////////////////////////////
//
typedef struct
{
	UINT8		identifier;														// Source device = 0x61
	UINT8		sID;															// Secondary ID
	UINT8		spare[14];														// Format TBD by V-Speak
} STRU_TELE_V_SPEAK;

//////////////////////////////////////////////////////////////////////////////
//
//						www.Smoke-EL.de
//
//////////////////////////////////////////////////////////////////////////////
//
typedef struct
{
	UINT8		identifier;														// Source device = 0x61
	UINT8		sID;															// Secondary ID
	UINT16		batteryV;														// 0.01V, Range 0.00-70.00V
	UINT16		countdown;														// 0.01s, Range 0.00-30.00s
	INT16		GForce;															// 0.01g, Range = +/-8.00g
	UINT8		cutoff;															// 1 count, Range 0-9
	UINT8		connected;														// 0=not connected, 1=connected, x = TBD
	UINT16		spare[3];
} STRU_TELE_SMOKE_EL;

//////////////////////////////////////////////////////////////////////////////
//
//							MULTI-CYLINDER SENSOR
//
//////////////////////////////////////////////////////////////////////////////
//
typedef struct
{
	UINT8		identifier;														// Source device = TELE_DEVICE_MULTICYLINDER
	UINT8		sID;															// Secondary ID
	UINT8		temperature[9];													// Temperature, 1C increments, Offset = 30C, 0xFF = NO DATA
				// 0x00 = 30C		(86F)
				// 0x01 = 31C ...	(88F)
				// 0xFE = 284C		(543F)
				// 0xFF = NO SENSOR ATTACHED.  Note that sensors must be installed cylinder 1-9 in sequence!
	UINT8		throttlePct;													// Throttle percent (0-100% typical, 0xFF = NO DATA)
	UINT16		RPM;															// 4 RPM increments, Offset = 400RPM, range 404-16776.
				// 0x000 = 0 RPM
				// 0x001 = 404 RPM
				// 0x002 = 408 RPM
				// 0xFFE = 16776 RPM
				// 0xFFF = NO SENSOR ATTACHED
				// NOTE:  HI NYBBLE RESERVED, set to 0xF to mark "NO DATA" for now
	UINT8		batteryV;														// Voltage, 0.1V increments, Offset = 3.5V, 0xFF = NO DATA
				// 0x00 = 3.5V
				// 0x01 = 3.6V
				// 0xFE = 28.9V
				// 0xFF = NO SENSOR ATTACHED
	UINT8		spare;															// 0xFF --> no data
} STRU_TELE_MULTI_TEMP;

//////////////////////////////////////////////////////////////////////////////
//
//						Transmitter Frame Data
//
//////////////////////////////////////////////////////////////////////////////
//
typedef struct
{
	UINT8		identifier;														// Source device = 0x7D
	UINT8		sID;															// Secondary ID
	UINT16		chanData[7];													// Channel Data array
} STRU_TELE_FRAMEDATA;

//////////////////////////////////////////////////////////////////////////////
//
//							AHRS Monitor
//
//////////////////////////////////////////////////////////////////////////////
//
typedef struct
{
	UINT8		identifier;														// Source device = TELE_DEVICE_AHRS
	UINT8		sID;															// Secondary ID
	INT16		attRoll;														// Attitude, 3 axes.  Roll is a rotation about the X Axis of the vehicle using the RHR.
	INT16		attPitch;														// Units are 0.1 deg - Pitch is a rotation about the Y Axis of the vehicle using the RHR.
	INT16		attYaw;															// Roll is a rotation about the Z Axis of the vehicle using the RHR.
	INT16		altitude;														// .1m increments
	UINT8		waypoint;														// Waypoint number
	UINT8		spare8;
	UINT16		spare16[2];
} STRU_TELE_AHRS;																// AHRS data from rx

//////////////////////////////////////////////////////////////////////////////
//
//							FLIGHT MODE
//
//////////////////////////////////////////////////////////////////////////////
//
typedef struct
{
	UINT8		identifier;														// Source device = 0x05 TELE_DEVICE_FLITECTRL
	UINT8		sID;															// Secondary ID
	UINT8		fMode,															// Current flight mode (low nybble)
				spare8;
	UINT16		spare[6];														// Growth
	// Ideas -
	//		arming status in a bitmap
	//		time in state
} STRU_TELE_FLITECTRL;


//////////////////////////////////////////////////////////////////////////////
//
//							Crossfire QOS
//
//////////////////////////////////////////////////////////////////////////////
//
typedef struct
{
	UINT8		identifier;														// Source device = TELE_XRF_LINKSTATUS
	UINT8		sID;															// Secondary ID
	UINT8		ant1,					// dBm * -1
				ant2,
				quality;				// %
	INT8		SNR;					// dB
	UINT8		activeAnt,				// ant1=0, ant2=1
				RFmode,					// 4fps=0, 50fps, 150Hz
				upPower,				// 0mW=0, 10mW, 25mW, 100mW, 500mW, 1000mW, 2000mW
				downlink,				// dBm * -1
				qualityDown;			// %
	INT8		SNRdown;				// dB
} STRU_TELE_XF_QOS;

//////////////////////////////////////////////////////////////////////////////
//
//						RPM/Volts/Temperature
//
//////////////////////////////////////////////////////////////////////////////
//
//	Uses big-endian byte order
//
typedef struct
{
	UINT8		identifier;														// Source device = 0x7E
	UINT8		sID;															// Secondary ID
	UINT16		microseconds;													// microseconds between pulse leading edges
	UINT16		volts;															// 0.01V increments (typically flight pack voltage)
	INT16		temperature;													// Temperature in degrees F.  0x7FFF = "No Data"
	INT8		dBm_A,															// Avg RSSI in dBm (<-1 = dBm, 0 = no data, >0 = % range) -- (legacy)antenna A in dBm
				dBm_B;															// Avg RSSI in % (<-1 = dBm, 0 = no data, >0 = % range)   -- (legacy)antenna B in dBm
																				// Note: Legacy use as antenna A/B dBm values is still supported. If only 1 antenna, set B = A.
																				//       The "no data" value is 0, but -1 (0xFF) is treated the same for backwards compatibility
	UINT16		spare[2];
} STRU_TELE_RPM;

//////////////////////////////////////////////////////////////////////////////
//
//							QoS DATA
//
//////////////////////////////////////////////////////////////////////////////
//
//	NOTE:  AR6410-series send:
//			id = 7F
//			sID = 0
//			A = 0
//			B = 0
//			L = 0
//			R = 0
//			F = fades
//			H = holds
//			rxV = 0xFFFF
//
typedef struct
{
	UINT8		identifier;														// Source device = 0x7F
	UINT8		sID;															// Secondary ID
	UINT16		A;																// Internal/base receiver fades. 0xFFFF = "No data"
	UINT16		B;																// Remote receiver fades. 0xFFFF = "No data"
	UINT16		L;																// Third receiver fades. 0xFFFF = "No data"
	UINT16		R;																// Fourth receiver fades. 0xFFFF = "No data"
	UINT16		F;																// Frame losses. 0xFFFF = "No data"
	UINT16		H;																// Holds. 0xFFFF = "No data"
	UINT16		rxVoltage;														// Volts, .01V increment. 0xFFFF = "No data"
} STRU_TELE_QOS;

//////////////////////////////////////////////////////////////////////////////
//
//					UNION OF ALL DEVICE MESSAGES
//
//////////////////////////////////////////////////////////////////////////////
//
typedef union
{
	UINT16					raw[8];
	STRU_TELE_QOS			qos;
	STRU_TELE_RPM			rpm;
	STRU_TELE_HV			hv;
	STRU_TELE_TEMP			temp;
	STRU_TELE_IHIGH			amps;
	STRU_TELE_ALT			alt;
	STRU_TELE_SPEED			speed;
	STRU_TELE_ESC			escSPM;
	STRU_TELE_VARIO_S		varioSimple;
	STRU_TELE_G_METER		accel;
	STRU_TELE_JETCAT		jetcat;
	STRU_TELE_JETCAT2		jetcat2;
	STRU_TELE_GPS_LOC		gpsloc;
	STRU_TELE_GPS_STAT		gpsstat;
	STRU_TELE_GPS_BINARY	gpsbin;
	STRU_TELE_AS3X_LEGACY	as3x;
	STRU_TELE_AS6X_GAIN		as6x;
	STRU_TELE_GYRO			gyro;
	STRU_TELE_ALPHA6		alpha6;
	STRU_TELE_ATTMAG		attMag;
	STRU_TELE_POWERBOX		powerBox;
	STRU_TELE_RX_MAH		rxMAH;
	STRU_TELE_FP_MAH		fpMAH;
	STRU_TELE_ESC			esc;
	STRU_TELE_FUEL			fuel;
	STRU_TELE_DIGITAL_AIR	digAir;
	STRU_TELE_STRAIN		strain;
	STRU_TELE_LIPOMON		lipomon;
	STRU_TELE_LIPOMON_14	lipomon14;
	STRU_SMARTBATT_HEADER	smartBatt_header;
	STRU_SMARTBATT_REALTIME	smartBatt_realtime;
	STRU_SMARTBATT_CELLS	smartBatt_cells;
	STRU_SMARTBATT_ID		smartBatt_ID;
	STRU_SMARTBATT_LIMITS	smartBatt_limits;
	STRU_TELE_USER_16SU		user_16SU;
	STRU_TELE_USER_16SU32U	user_16SU32U;
	STRU_TELE_USER_16SU32S	user_16SU32S;
	STRU_TELE_USER_16U32SU	user_16U32SU;
	STRU_TELE_TEXTGEN		textgen;
	STRU_TELE_VTX			vtx;
	STRU_TELE_V_SPEAK		vSpeak;
	STRU_TELE_SMOKE_EL		smoke_el;
	STRU_TELE_MULTI_TEMP	multiCylinder;
	STRU_TELE_FLITECTRL		fControl;
	STRU_TELE_TILT			tilt;
	STRU_TELE_XF_QOS		xfire;
} UN_TELEMETRY;																	// All telemetry messages

//////////////////////////////////////////////////////////////////
//
//					sID Field Functionality
//
//////////////////////////////////////////////////////////////////
//
//		if .sID == 0x00 then .identifier = device type (TELE_DEVICE_xxx) and address I2C bus
//		if .sID != 0x00 then .sID = device type and .identifer = address on I2C bus

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        /*
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/
/*
  implement a file store for embedded firmware images
 */

#include "AP_ROMFS.h"
#include "tinf.h"
#include <AP_Math/crc.h>

#include <AP_Common/AP_Common.h>
#include <AP_HAL/AP_HAL_Boards.h>

#include <string.h>

#ifdef HAL_HAVE_AP_ROMFS_EMBEDDED_H
#include <ap_romfs_embedded.h>
#else
const AP_ROMFS::embedded_file AP_ROMFS::files[] = {};
#endif

/*
  find an embedded file
*/
const AP_ROMFS::embedded_file *AP_ROMFS::find_file(const char *name)
{
    for (uint16_t i=0; i<ARRAY_SIZE(files); i++) {
        if (strcmp(name, files[i].filename) == 0) {
            return &files[i];
        }
    }
    return nullptr;
}

/*
  Find the named file and return its decompressed data and size. Caller must
  call AP_ROMFS::free() on the return value after use to free it. The data is
  guaranteed to be null-terminated such that it can be treated as a string.
*/
const uint8_t *AP_ROMFS::find_decompress(const char *name, uint32_t &size)
{
    const struct embedded_file *f = find_file(name);
    if (f == nullptr) {
        return nullptr;
    }

#ifdef HAL_ROMFS_UNCOMPRESSED
    size = f->decompressed_size;
    return f->contents;
#else
    // add one byte for null termination; ArduPilot's malloc will zero it.
    uint8_t *decompressed_data = (uint8_t *)malloc(f->decompressed_size+1);
    if (!decompressed_data) {
        return nullptr;
    }

    if (f->decompressed_size == 0) {
        // empty file, avoid decompression problems
        size = 0;
        return decompressed_data;
    }

    TINF_DATA *d = (TINF_DATA *)malloc(sizeof(TINF_DATA));
    if (!d) {
        ::free(decompressed_data);
        return nullptr;
    }
    uzlib_uncompress_init(d, NULL, 0);

    d->source = f->contents;
    d->source_limit = f->contents + f->compressed_size;
    d->dest = decompressed_data;
    d->destSize = f->decompressed_size;

    int res = uzlib_uncompress(d);

    ::free(d);
    
    if (res != TINF_OK) {
        ::free(decompressed_data);
        return nullptr;
    }

    if (crc32_small(0, decompressed_data, f->decompressed_size) != f->crc) {
        ::free(decompressed_data);
        return nullptr;
    }
    
    size = f->decompressed_size;
    return decompressed_data;
#endif
}

// free decompressed file data
void AP_ROMFS::free(const uint8_t *data)
{
#ifndef HAL_ROMFS_UNCOMPRESSED
    ::free(const_cast<uint8_t *>(data));
#endif
}

/*
  directory listing interface. Start with ofs=0. Returns pathnames
  that match dirname prefix. Ends with nullptr return when no more
  files found
*/
const char *AP_ROMFS::dir_list(const char *dirname, uint16_t &ofs)
{
    const size_t dlen = strlen(dirname);
    for ( ; ofs < ARRAY_SIZE(files); ofs++) {
        if (strncmp(dirname, files[ofs].filename, dlen) == 0) {
            const char last_char = files[ofs].filename[dlen];
            if (dlen != 0 && last_char != '/' && last_char != 0) {
                // only a partial match, skip
                continue;
            }
            /*
              prevent duplicate directories
             */
            const char *start_name = files[ofs].filename + dlen + 1;
            const char *slash = strchr(start_name, '/');
            if (ofs > 0 && slash != nullptr) {
                auto len = slash - start_name;
                if (memcmp(files[ofs].filename, files[ofs-1].filename, len+dlen+1) == 0) {
                    continue;
                }
            }
            // found one
            return files[ofs++].filename;
        }
    }
    return nullptr;
}

/*
  find a compressed file and return its size
*/
bool AP_ROMFS::find_size(const char *name, uint32_t &size)
{
    const struct embedded_file *f = find_file(name);
    if (f == nullptr) {
        return false;
    }
    size = f->decompressed_size;
    return true;
}

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          /*
  implement a file store for embedded firmware images
 */
#pragma once

#include <stdint.h>

class AP_ROMFS {
public:
    //  Find the named file and return its decompressed data and size. Caller
    //  must call AP_ROMFS::free() on the return value after use to free it.
    //  The data is guaranteed to be null-terminated such that it can be
    //  treated as a string.
    static const uint8_t *find_decompress(const char *name, uint32_t &size);

    // free decompressed file data
    static void free(const uint8_t *data);

    // get the size of a file without decompressing
    static bool find_size(const char *name, uint32_t &size);

    /*
      directory listing interface. Start with ofs=0. Returns pathnames
      that match dirname prefix. Ends with nullptr return when no more
      files found
    */
    static const char *dir_list(const char *dirname, uint16_t &ofs);

private:
    struct embedded_file {
        const char *filename;
        uint32_t compressed_size;
        uint32_t decompressed_size;
        uint32_t crc;
        const uint8_t *contents;
    };

    // find an embedded file
    static const AP_ROMFS::embedded_file *find_file(const char *name);

    static const struct embedded_file files[];
};
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     /*
 * uzlib  -  tiny deflate/inflate library (deflate, gzip, zlib)
 *
 * Copyright (c) 2003 by Joergen Ibsen / Jibz
 * All Rights Reserved
 * http://www.ibsensoftware.com/
 *
 * Copyright (c) 2014-2016 by Paul Sokolovsky
 */

#ifndef TINF_H_INCLUDED
#define TINF_H_INCLUDED

#include <stdlib.h>
#include <stdint.h>
#include <stdbool.h>

/* calling convention */
#ifndef TINFCC
 #ifdef __WATCOMC__
  #define TINFCC __cdecl
 #else
  #define TINFCC
 #endif
#endif

#ifdef __cplusplus
extern "C" {
#endif

/* ok status, more data produced */
#define TINF_OK             0
/* end of compressed stream reached */
#define TINF_DONE           1
#define TINF_DATA_ERROR    (-3)
#define TINF_CHKSUM_ERROR  (-4)
#define TINF_DICT_ERROR    (-5)

/* checksum types */
#define TINF_CHKSUM_NONE  0
#define TINF_CHKSUM_ADLER 1
#define TINF_CHKSUM_CRC   2

/* helper macros */
#define TINF_ARRAY_SIZE(arr) (sizeof(arr) / sizeof(*(arr)))

/* data structures */

typedef struct {
   unsigned short table[16];  /* table of code length counts */
   unsigned short trans[288]; /* code -> symbol translation table */
} TINF_TREE;

struct TINF_DATA;
typedef struct TINF_DATA {
   /* Pointer to the next byte in the input buffer */
   const unsigned char *source;
   /* Pointer to the next byte past the input buffer (source_limit = source + len) */
   const unsigned char *source_limit;
   /* If source_limit == NULL, or source >= source_limit, this function
      will be used to read next byte from source stream. The function may
      also return -1 in
      case of EOF (or irrecoverable error). Note that besides returning
      the next byte, it may also update source and sourceRemaining fields,
      thus allowing for buffered operation. */
   int (*readSource)(struct TINF_DATA *data);

   unsigned int tag;
   unsigned int bitcount;

    /* Buffer start */
    unsigned char *destStart;
    /* Buffer total size */
    unsigned int destSize;
    /* Current pointer in buffer */
    unsigned char *dest;
    /* Remaining bytes in buffer */
    unsigned int destRemaining;

    /* Accumulating checksum */
    unsigned int checksum;
    char checksum_type;
    bool eof;

    int btype;
    int bfinal;
    unsigned int curlen;
    int lzOff;
    unsigned char *dict_ring;
    unsigned int dict_size;
    unsigned int dict_idx;

   TINF_TREE ltree; /* dynamic length/symbol tree */
   TINF_TREE dtree; /* dynamic distance tree */
} TINF_DATA;

#define TINF_PUT(d, c) \
    { \
        *d->dest++ = c; \
        if (d->dict_ring) { d->dict_ring[d->dict_idx++] = c; if (d->dict_idx == d->dict_size) d->dict_idx = 0; } \
    }

unsigned char TINFCC uzlib_get_byte(TINF_DATA *d);

/* Decompression API */

void TINFCC uzlib_init(void);
void TINFCC uzlib_uncompress_init(TINF_DATA *d, void *dict, unsigned int dictLen);
int  TINFCC uzlib_uncompress(TINF_DATA *d);
int  TINFCC uzlib_uncompress_chksum(TINF_DATA *d);

int TINFCC uzlib_zlib_parse_header(TINF_DATA *d);
int TINFCC uzlib_gzip_parse_header(TINF_DATA *d);

/* Compression API */

void TINFCC uzlib_compress(void *data, const uint8_t *src, unsigned slen);

/* Checksum API */

/* prev_sum is previous value for incremental computation, 1 initially */
uint32_t TINFCC uzlib_adler32(const void *data, unsigned int length, uint32_t prev_sum);
/* crc is previous value for incremental computation, 0xffffffff initially */
uint32_t TINFCC uzlib_crc32(const void *data, unsigned int length, uint32_t crc);

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif /* TINF_H_INCLUDED */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    /*
 * tinflate  -  tiny inflate
 *
 * Copyright (c) 2003 by Joergen Ibsen / Jibz
 * All Rights Reserved
 * http://www.ibsensoftware.com/
 *
 * Copyright (c) 2014-2016 by Paul Sokolovsky
 *
 * This software is provided 'as-is', without any express
 * or implied warranty.  In no event will the authors be
 * held liable for any damages arising from the use of
 * this software.
 *
 * Permission is granted to anyone to use this software
 * for any purpose, including commercial applications,
 * and to alter it and redistribute it freely, subject to
 * the following restrictions:
 *
 * 1. The origin of this software must not be
 *    misrepresented; you must not claim that you
 *    wrote the original software. If you use this
 *    software in a product, an acknowledgment in
 *    the product documentation would be appreciated
 *    but is not required.
 *
 * 2. Altered source versions must be plainly marked
 *    as such, and must not be misrepresented as
 *    being the original software.
 *
 * 3. This notice may not be removed or altered from
 *    any source distribution.
 */

/*
  minor changes for C++ build for ArduPilot by tridge
 */

#include <assert.h>
#include "tinf.h"

uint32_t tinf_get_le_uint32(TINF_DATA *d);
uint32_t tinf_get_be_uint32(TINF_DATA *d);

/* --------------------------------------------------- *
 * -- uninitialized global data (static structures) -- *
 * --------------------------------------------------- */

#ifdef RUNTIME_BITS_TABLES

/* extra bits and base tables for length codes */
unsigned char length_bits[30];
unsigned short length_base[30];

/* extra bits and base tables for distance codes */
unsigned char dist_bits[30];
unsigned short dist_base[30];

#else

static const unsigned char length_bits[30] = {
   0, 0, 0, 0, 0, 0, 0, 0,
   1, 1, 1, 1, 2, 2, 2, 2,
   3, 3, 3, 3, 4, 4, 4, 4,
   5, 5, 5, 5
};
static const unsigned short length_base[30] = {
   3, 4, 5, 6, 7, 8, 9, 10,
   11, 13, 15, 17, 19, 23, 27, 31,
   35, 43, 51, 59, 67, 83, 99, 115,
   131, 163, 195, 227, 258
};

static const unsigned char dist_bits[30] = {
   0, 0, 0, 0, 1, 1, 2, 2,
   3, 3, 4, 4, 5, 5, 6, 6,
   7, 7, 8, 8, 9, 9, 10, 10,
   11, 11, 12, 12, 13, 13
};
static const unsigned short dist_base[30] = {
   1, 2, 3, 4, 5, 7, 9, 13,
   17, 25, 33, 49, 65, 97, 129, 193,
   257, 385, 513, 769, 1025, 1537, 2049, 3073,
   4097, 6145, 8193, 12289, 16385, 24577
};

#endif

/* special ordering of code length codes */
static const unsigned char clcidx[] = {
   16, 17, 18, 0, 8, 7, 9, 6,
   10, 5, 11, 4, 12, 3, 13, 2,
   14, 1, 15
};

/* ----------------------- *
 * -- utility functions -- *
 * ----------------------- */

#ifdef RUNTIME_BITS_TABLES
/* build extra bits and base tables */
static void tinf_build_bits_base(unsigned char *bits, unsigned short *base, int delta, int first)
{
   int i, sum;

   /* build bits table */
   for (i = 0; i < delta; ++i) bits[i] = 0;
   for (i = 0; i < 30 - delta; ++i) bits[i + delta] = i / delta;

   /* build base table */
   for (sum = first, i = 0; i < 30; ++i)
   {
      base[i] = sum;
      sum += 1 << bits[i];
   }
}
#endif

/* build the fixed huffman trees */
static void tinf_build_fixed_trees(TINF_TREE *lt, TINF_TREE *dt)
{
   int i;

   /* build fixed length tree */
   for (i = 0; i < 7; ++i) lt->table[i] = 0;

   lt->table[7] = 24;
   lt->table[8] = 152;
   lt->table[9] = 112;

   for (i = 0; i < 24; ++i) lt->trans[i] = 256 + i;
   for (i = 0; i < 144; ++i) lt->trans[24 + i] = i;
   for (i = 0; i < 8; ++i) lt->trans[24 + 144 + i] = 280 + i;
   for (i = 0; i < 112; ++i) lt->trans[24 + 144 + 8 + i] = 144 + i;

   /* build fixed distance tree */
   for (i = 0; i < 5; ++i) dt->table[i] = 0;

   dt->table[5] = 32;

   for (i = 0; i < 32; ++i) dt->trans[i] = i;
}

/* given an array of code lengths, build a tree */
static void tinf_build_tree(TINF_TREE *t, const unsigned char *lengths, unsigned int num)
{
   unsigned short offs[16];
   unsigned int i, sum;

   /* clear code length count table */
   for (i = 0; i < 16; ++i) t->table[i] = 0;

   /* scan symbol lengths, and sum code length counts */
   for (i = 0; i < num; ++i) t->table[lengths[i]]++;

   t->table[0] = 0;

   /* compute offset table for distribution sort */
   for (sum = 0, i = 0; i < 16; ++i)
   {
      offs[i] = sum;
      sum += t->table[i];
   }

   /* create code->symbol translation table (symbols sorted by code) */
   for (i = 0; i < num; ++i)
   {
      if (lengths[i]) t->trans[offs[lengths[i]]++] = i;
   }
}

/* ---------------------- *
 * -- decode functions -- *
 * ---------------------- */

unsigned char uzlib_get_byte(TINF_DATA *d)
{
    /* If end of source buffer is not reached, return next byte from source
       buffer. */
    if (d->source < d->source_limit) {
        return *d->source++;
    }

    /* Otherwise if there's callback and we haven't seen EOF yet, try to
       read next byte using it. (Note: the callback can also update ->source
       and ->source_limit). */
    if (d->readSource && !d->eof) {
        int val = d->readSource(d);
        if (val >= 0) {
            return (unsigned char)val;
        }
    }

    /* Otherwise, we hit EOF (either from ->readSource() or from exhaustion
       of the buffer), and it will be "sticky", i.e. further calls to this
       function will end up here too. */
    d->eof = true;

    return 0;
}

uint32_t tinf_get_le_uint32(TINF_DATA *d)
{
    uint32_t val = 0;
    int i;
    for (i = 4; i--;) {
        val = val >> 8 | ((uint32_t)uzlib_get_byte(d)) << 24;
    }
    return val;
}

uint32_t tinf_get_be_uint32(TINF_DATA *d)
{
    uint32_t val = 0;
    int i;
    for (i = 4; i--;) {
        val = val << 8 | uzlib_get_byte(d);
    }
    return val;
}

/* get one bit from source stream */
static int tinf_getbit(TINF_DATA *d)
{
   unsigned int bit;

   /* check if tag is empty */
   if (!d->bitcount--)
   {
      /* load next tag */
      d->tag = uzlib_get_byte(d);
      d->bitcount = 7;
   }

   /* shift bit out of tag */
   bit = d->tag & 0x01;
   d->tag >>= 1;

   return bit;
}

/* read a num bit value from a stream and add base */
static unsigned int tinf_read_bits(TINF_DATA *d, int num, int base)
{
   unsigned int val = 0;

   /* read num bits */
   if (num)
   {
      unsigned int limit = 1 << (num);
      unsigned int mask;

      for (mask = 1; mask < limit; mask *= 2)
         if (tinf_getbit(d)) val += mask;
   }

   return val + base;
}

/* given a data stream and a tree, decode a symbol */
static int tinf_decode_symbol(TINF_DATA *d, TINF_TREE *t)
{
   int sum = 0, cur = 0, len = 0;

   /* get more bits while code value is above sum */
   do {

      cur = 2*cur + tinf_getbit(d);

      if (++len == TINF_ARRAY_SIZE(t->table)) {
         return TINF_DATA_ERROR;
      }

      sum += t->table[len];
      cur -= t->table[len];

   } while (cur >= 0);

   sum += cur;
   if (sum < 0 || sum >= (int)(TINF_ARRAY_SIZE(t->trans))) {
      return TINF_DATA_ERROR;
   }

   return t->trans[sum];
}

/* given a data stream, decode dynamic trees from it */
static int tinf_decode_trees(TINF_DATA *d, TINF_TREE *lt, TINF_TREE *dt)
{
   unsigned char lengths[288+32];
   unsigned int hlit, hdist, hclen, hlimit;
   unsigned int i, num, length;

   /* get 5 bits HLIT (257-286) */
   hlit = tinf_read_bits(d, 5, 257);

   /* get 5 bits HDIST (1-32) */
   hdist = tinf_read_bits(d, 5, 1);

   /* get 4 bits HCLEN (4-19) */
   hclen = tinf_read_bits(d, 4, 4);

   for (i = 0; i < 19; ++i) lengths[i] = 0;

   /* read code lengths for code length alphabet */
   for (i = 0; i < hclen; ++i)
   {
      /* get 3 bits code length (0-7) */
      unsigned int clen = tinf_read_bits(d, 3, 0);

      lengths[clcidx[i]] = clen;
   }

   /* build code length tree, temporarily use length tree */
   tinf_build_tree(lt, lengths, 19);

   /* decode code lengths for the dynamic trees */
   hlimit = hlit + hdist;
   for (num = 0; num < hlimit; )
   {
      int sym = tinf_decode_symbol(d, lt);
      unsigned char fill_value = 0;
      int lbits, lbase = 3;

      /* error decoding */
      if (sym < 0) return sym;

      switch (sym)
      {
      case 16:
          if (num == 0) {
              return TINF_DATA_ERROR;
          }
         /* copy previous code length 3-6 times (read 2 bits) */
         fill_value = lengths[num - 1];
         lbits = 2;
         break;
      case 17:
         /* repeat code length 0 for 3-10 times (read 3 bits) */
         lbits = 3;
         break;
      case 18:
         /* repeat code length 0 for 11-138 times (read 7 bits) */
         lbits = 7;
         lbase = 11;
         break;
      default:
         /* values 0-15 represent the actual code lengths */
         lengths[num++] = sym;
         /* continue the for loop */
         continue;
      }

      /* special code length 16-18 are handled here */
      length = tinf_read_bits(d, lbits, lbase);
      if (num + length > hlimit) return TINF_DATA_ERROR;
      for (; length; --length)
      {
         lengths[num++] = fill_value;
      }
   }

   /* build dynamic trees */
   tinf_build_tree(lt, lengths, hlit);
   tinf_build_tree(dt, lengths + hlit, hdist);

   return TINF_OK;
}

/* ----------------------------- *
 * -- block inflate functions -- *
 * ----------------------------- */

/* given a stream and two trees, inflate a block of data */
static int tinf_inflate_block_data(TINF_DATA *d, TINF_TREE *lt, TINF_TREE *dt)
{
    if (d->curlen == 0) {
        unsigned int offs;
        int dist;
        int sym = tinf_decode_symbol(d, lt);
        //printf("huff sym: %02x\n", sym);

        if (d->eof) {
            return TINF_DATA_ERROR;
        }

        /* literal byte */
        if (sym < 256) {
            TINF_PUT(d, sym);
            return TINF_OK;
        }

        /* end of block */
        if (sym == 256) {
            return TINF_DONE;
        }

        /* substring from sliding dictionary */
        sym -= 257;
        /* possibly get more bits from length code */
        d->curlen = tinf_read_bits(d, length_bits[sym], length_base[sym]);

        dist = tinf_decode_symbol(d, dt);
        if (dist < 0) {
            return dist;
        }
        /* possibly get more bits from distance code */
        offs = tinf_read_bits(d, dist_bits[dist], dist_base[dist]);
        if (d->dict_ring) {
            if (offs > d->dict_size) {
                return TINF_DICT_ERROR;
            }
            d->lzOff = d->dict_idx - offs;
            if (d->lzOff < 0) {
                d->lzOff += d->dict_size;
            }
        } else {
            d->lzOff = -offs;
        }
    }

    /* copy next byte from dict substring */
    if (d->dict_ring) {
        TINF_PUT(d, d->dict_ring[d->lzOff]);
        if ((unsigned)++d->lzOff == d->dict_size) {
            d->lzOff = 0;
        }
    } else {
        d->dest[0] = d->dest[d->lzOff];
        d->dest++;
    }
    d->curlen--;
    return TINF_OK;
}

/* inflate an uncompressed block of data */
static int tinf_inflate_uncompressed_block(TINF_DATA *d)
{
    if (d->curlen == 0) {
        unsigned int length, invlength;

        /* get length */
        length = uzlib_get_byte(d);
        length += 256 * uzlib_get_byte(d);
        /* get one's complement of length */
        invlength = uzlib_get_byte(d);
        invlength += 256 * uzlib_get_byte(d);
        /* check length */
        if (length != (~invlength & 0x0000ffff)) return TINF_DATA_ERROR;

        /* increment length to properly return TINF_DONE below, without
           producing data at the same time */
        d->curlen = length + 1;

        /* make sure we start next block on a byte boundary */
        d->bitcount = 0;
    }

    if (--d->curlen == 0) {
        return TINF_DONE;
    }

    unsigned char c = uzlib_get_byte(d);
    TINF_PUT(d, c);
    return TINF_OK;
}

/* ---------------------- *
 * -- public functions -- *
 * ---------------------- */

/* initialize global (static) data */
void uzlib_init(void)
{
#ifdef RUNTIME_BITS_TABLES
   /* build extra bits and base tables */
   tinf_build_bits_base(length_bits, length_base, 4, 3);
   tinf_build_bits_base(dist_bits, dist_base, 2, 1);

   /* fix a special case */
   length_bits[28] = 0;
   length_base[28] = 258;
#endif
}

/* initialize decompression structure */
void uzlib_uncompress_init(TINF_DATA *d, void *dict, unsigned int dictLen)
{
   d->eof = 0;
   d->source_limit = NULL;
   d->readSource = NULL;
   d->bitcount = 0;
   d->bfinal = 0;
   d->btype = -1;
   d->dict_size = dictLen;
   d->dict_ring = (unsigned char *)dict;
   d->dict_idx = 0;
   d->curlen = 0;
}

/* inflate next byte of compressed stream */
int uzlib_uncompress(TINF_DATA *d)
{
    do {
        int res;

        /* start a new block */
        if (d->btype == -1) {
next_blk:
            /* read final block flag */
            d->bfinal = tinf_getbit(d);
            /* read block type (2 bits) */
            d->btype = tinf_read_bits(d, 2, 0);

            //printf("Started new block: type=%d final=%d\n", d->btype, d->bfinal);

            if (d->btype == 1) {
                /* build fixed huffman trees */
                tinf_build_fixed_trees(&d->ltree, &d->dtree);
            } else if (d->btype == 2) {
                /* decode trees from stream */
                res = tinf_decode_trees(d, &d->ltree, &d->dtree);
                if (res != TINF_OK) {
                    return res;
                }
            }
        }

        /* process current block */
        switch (d->btype)
        {
        case 0:
            /* decompress uncompressed block */
            res = tinf_inflate_uncompressed_block(d);
            break;
        case 1:
        case 2:
            /* decompress block with fixed/dynamic huffman trees */
            /* trees were decoded previously, so it's the same routine for both */
            res = tinf_inflate_block_data(d, &d->ltree, &d->dtree);
            break;
        default:
            return TINF_DATA_ERROR;
        }

        if (res == TINF_DONE && !d->bfinal) {
            /* the block has ended (without producing more data), but we
               can't return without data, so start procesing next block */
            goto next_blk;
        }

        if (res != TINF_OK) {
            return res;
        }

    } while (--d->destSize);

    return TINF_OK;
}

#if 0
int uzlib_uncompress_chksum(TINF_DATA *d)
{
    int res;
    unsigned char *data = d->dest;

    res = uzlib_uncompress(d);

    if (res < 0) return res;

    switch (d->checksum_type) {

    case TINF_CHKSUM_ADLER:
        d->checksum = uzlib_adler32(data, d->dest - data, d->checksum);
        break;

    case TINF_CHKSUM_CRC:
        d->checksum = uzlib_crc32(data, d->dest - data, d->checksum);
        break;
    }

    if (res == TINF_DONE) {
        unsigned int val;

        switch (d->checksum_type) {

        case TINF_CHKSUM_ADLER:
            val = tinf_get_be_uint32(d);
            if (d->checksum != val) {
                return TINF_CHKSUM_ERROR;
            }
            break;

        case TINF_CHKSUM_CRC:
            val = tinf_get_le_uint32(d);
            if (~d->checksum != val) {
                return TINF_CHKSUM_ERROR;
            }
            // Uncompressed size. TODO: Check
            val = tinf_get_le_uint32(d);
            break;
        }
    }

    return res;
}
#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                /*
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include "AP_RPM.h"

#if AP_RPM_ENABLED

#include "RPM_Backend.h"
#include "RPM_Pin.h"
#include "RPM_SITL.h"
#include "RPM_EFI.h"
#include "RPM_Generator.h"
#include "RPM_HarmonicNotch.h"
#include "RPM_ESC_Telem.h"
#include "RPM_DroneCAN.h"

#include <AP_Logger/AP_Logger.h>

extern const AP_HAL::HAL& hal;

// table of user settable parameters
const AP_Param::GroupInfo AP_RPM::var_info[] = {
    // 0-13 used by old param indexes before being moved to AP_RPM_Params

    // @Group: 1_
    // @Path: AP_RPM_Params.cpp
    AP_SUBGROUPINFO(_params[0], "1_", 14, AP_RPM, AP_RPM_Params),

#if RPM_MAX_INSTANCES > 1
    // @Group: 2_
    // @Path: AP_RPM_Params.cpp
    AP_SUBGROUPINFO(_params[1], "2_", 15, AP_RPM, AP_RPM_Params),
#endif

#if RPM_MAX_INSTANCES > 2
    // @Group: 3_
    // @Path: AP_RPM_Params.cpp
    AP_SUBGROUPINFO(_params[2], "3_", 16, AP_RPM, AP_RPM_Params),
#endif

#if RPM_MAX_INSTANCES > 3
    // @Group: 4_
    // @Path: AP_RPM_Params.cpp
    AP_SUBGROUPINFO(_params[3], "4_", 17, AP_RPM, AP_RPM_Params),
#endif

    AP_GROUPEND
};

AP_RPM::AP_RPM(void)
{
    AP_Param::setup_object_defaults(this, var_info);

    if (_singleton != nullptr) {
        AP_HAL::panic("AP_RPM must be singleton");
    }
    _singleton = this;
}

/*
  initialise the AP_RPM class.
 */
void AP_RPM::init(void)
{
    if (num_instances != 0) {
        // init called a 2nd time?
        return;
    }

    convert_params();

    for (uint8_t i=0; i<RPM_MAX_INSTANCES; i++) {
        switch (_params[i].type) {
#if AP_RPM_PIN_ENABLED
        case RPM_TYPE_PWM:
        case RPM_TYPE_PIN:
            // PWM option same as PIN option, for upgrade
            drivers[i] = NEW_NOTHROW AP_RPM_Pin(*this, i, state[i]);
            break;
#endif  // AP_RPM_PIN_ENABLED
#if AP_RPM_ESC_TELEM_ENABLED
        case RPM_TYPE_ESC_TELEM:
            drivers[i] = NEW_NOTHROW AP_RPM_ESC_Telem(*this, i, state[i]);
            break;
#endif  // AP_RPM_ESC_TELEM_ENABLED
#if AP_RPM_EFI_ENABLED
        case RPM_TYPE_EFI:
            drivers[i] = NEW_NOTHROW AP_RPM_EFI(*this, i, state[i]);
            break;
#endif  // AP_RPM_EFI_ENABLED
#if AP_RPM_GENERATOR_ENABLED
        case RPM_TYPE_GENERATOR:
            drivers[i] = NEW_NOTHROW AP_RPM_Generator(*this, i, state[i]);
            break;
#endif  // AP_RPM_GENERATOR_ENABLED
#if AP_RPM_HARMONICNOTCH_ENABLED
        // include harmonic notch last
        // this makes whatever process is driving the dynamic notch appear as an RPM value
        case RPM_TYPE_HNTCH:
            drivers[i] = NEW_NOTHROW AP_RPM_HarmonicNotch(*this, i, state[i]);
            break;
#endif  // AP_RPM_HARMONICNOTCH_ENABLED
#if AP_RPM_DRONECAN_ENABLED
        case RPM_TYPE_DRONECAN:
            drivers[i] = NEW_NOTHROW AP_RPM_DroneCAN(*this, i, state[i]);
            break;
#endif // AP_RPM_DRONECAN_ENABLED
#if AP_RPM_SIM_ENABLED
        case RPM_TYPE_SITL:
            drivers[i] = NEW_NOTHROW AP_RPM_SITL(*this, i, state[i]);
            break;
#endif  // AP_RPM_SIM_ENABLED
        }
        if (drivers[i] != nullptr) {
            // we loaded a driver for this instance, so it must be
            // present (although it may not be healthy)
            num_instances = i+1; // num_instances is a high-water-mark
        }
    }
}

/* 
PARAMETER_CONVERSION - Added: Aug-2021
*/
void AP_RPM::convert_params(void)
{
    if (_params[0].type.configured()) {
        // _params[0].type will always be configured after conversion is done the first time
        return;
    }

    // don't do conversion if neither RPM types were set
    bool type_set;
    uint8_t rpm_type = 0;
    uint8_t rpm2_type = 0;
    type_set = AP_Param::get_param_by_index(this, 0, AP_PARAM_INT8, &rpm_type);
    type_set |= AP_Param::get_param_by_index(this, 10, AP_PARAM_INT8, &rpm2_type);

    if (!type_set || (rpm_type == 0 && rpm2_type == 0)) {
        return;
    }

    struct ConversionTable {
        uint8_t old_element;
        uint8_t new_index;
        uint8_t instance;
    };

    const struct ConversionTable conversionTable[] = {
            // RPM 1
            {0, 0, 0}, // TYPE
            {1, 1, 0}, // SCALING
            {2, 2, 0}, // MAX
            {3, 3, 0}, // MIN
            {4, 4, 0}, // MIN_QUAL
            {5, 5, 0}, // PIN
            {6, 6, 0}, // ESC_MASK

            // RPM 2
            {10, 0, 1}, // TYPE
            {11, 1, 1}, // SCALING
            // MAX (Previous bug meant RPM2_MAX param was never accesible to users. No conversion required.)
            // MIN (Previous bug meant RPM2_MIN param was never accesible to users. No conversion required.)
            {4, 4, 1}, // MIN_QUAL (Previously the min quality of the 1st RPM instance was used for all RPM instances.)
            {12, 5, 1}, // PIN
            {13, 6, 1}, // ESC_MASK
    };

    char param_name[17] = {0};
    AP_Param::ConversionInfo info;
    info.new_name = param_name;

    if (!AP_Param::find_top_level_key_by_pointer(this, info.old_key)) {
        _params[0].type.save(true);
        return; // no conversion is supported on this platform
    }

    for (uint8_t i = 0; i < ARRAY_SIZE(conversionTable); i++) {
        uint8_t param_instance = conversionTable[i].instance + 1;
        uint8_t destination_index = conversionTable[i].new_index;
        info.old_group_element = conversionTable[i].old_element;

        // The var type of the params has not changed in the conversion so this is ok:
        info.type = (ap_var_type)AP_RPM_Params::var_info[destination_index].type;
        hal.util->snprintf(param_name, sizeof(param_name), "RPM%X_%s", param_instance, AP_RPM_Params::var_info[destination_index].name);
        param_name[sizeof(param_name)-1] = '\0';

        AP_Param::convert_old_parameter(&info, 1.0f, 0);
    }

    // force _params[0].type into storage to flag that conversion has been done
    _params[0].type.save(true);
}

/*
  update RPM state for all instances. This should be called by main loop
 */
void AP_RPM::update(void)
{
    for (uint8_t i=0; i<num_instances; i++) {
        if (drivers[i] != nullptr) {
            if (_params[i].type == RPM_TYPE_NONE) {
                // allow user to disable an RPM sensor at runtime and force it to re-learn the quality if re-enabled.
                state[i].signal_quality = 0;
                continue;
            }

            drivers[i]->update();

#if AP_RPM_ESC_TELEM_OUTBOUND_ENABLED
            drivers[i]->update_esc_telem_outbound();
#endif
        }
    }

#if HAL_LOGGING_ENABLED
    Log_RPM();
#endif
}

/*
  check if an instance is healthy
 */
bool AP_RPM::healthy(uint8_t instance) const
{
    if (instance >= num_instances || _params[instance].type == RPM_TYPE_NONE) {
        return false;
    }

    // check that data quality is above minimum required
    if (state[instance].signal_quality < _params[instance].quality_min) {
        return false;
    }

    return true;
}

/*
  check if an instance is activated
 */
bool AP_RPM::enabled(uint8_t instance) const
{
    if (instance >= num_instances) {
        return false;
    }
    // if no sensor type is selected, the sensor is not activated.
    if (_params[instance].type == RPM_TYPE_NONE) {
        return false;
    }
    return true;
}

/*
  get RPM value, return true on success
 */
bool AP_RPM::get_rpm(uint8_t instance, float &rpm_value) const
{
    if (!healthy(instance)) {
        return false;
    }
    rpm_value = state[instance].rate_rpm;
    return true;
}

// check settings are valid
bool AP_RPM::arming_checks(size_t buflen, char *buffer) const
{
    for (uint8_t i=0; i<RPM_MAX_INSTANCES; i++) {
        switch (_params[i].type) {
#if AP_RPM_PIN_ENABLED
        case RPM_TYPE_PWM:
        case RPM_TYPE_PIN:
            if (_params[i].pin == -1) {
                hal.util->snprintf(buffer, buflen, "RPM%u_PIN not set", unsigned(i + 1));
                return false;
            }
            if (!hal.gpio->valid_pin(_params[i].pin)) {
                uint8_t servo_ch;
                if (hal.gpio->pin_to_servo_channel(_params[i].pin, servo_ch)) {
                    hal.util->snprintf(buffer, buflen, "RPM%u_PIN=%d, set SERVO%u_FUNCTION=-1", unsigned(i + 1), int(_params[i].pin.get()), unsigned(servo_ch+1));
                } else {
                    hal.util->snprintf(buffer, buflen, "RPM%u_PIN=%d invalid", unsigned(i + 1), int(_params[i].pin.get()));
                }
                return false;
            }
            break;
#endif
        }
    }
    return true;
}

#if HAL_LOGGING_ENABLED
void AP_RPM::Log_RPM() const
{
    // update logging for each instance
    for (uint8_t i=0; i<num_instances; i++) {
        if (drivers[i] == nullptr || !enabled(i)) {
            // don't log unused instances
            continue;
        }

        const struct log_RPM pkt{
            LOG_PACKET_HEADER_INIT(LOG_RPM_MSG),
            time_us     : AP_HAL::micros64(),
            inst        : i,
            rpm         : state[i].rate_rpm,
            quality     : get_signal_quality(i),
            health      : uint8_t(healthy(i))
        };
        AP::logger().WriteBlock(&pkt, sizeof(pkt));
    }
}
#endif

#ifdef HAL_PERIPH_ENABLE_RPM_STREAM
// Return the sensor id to use for streaming over DroneCAN, negative number disables
int8_t AP_RPM::get_dronecan_sensor_id(uint8_t instance) const
{
    if (!enabled(instance)) {
        return -1;
    }
    return _params[instance].dronecan_sensor_id;
}
#endif


// singleton instance
AP_RPM *AP_RPM::_singleton;

namespace AP {

AP_RPM *rpm()
{
    return AP_RPM::get_singleton();
}

}

#endif  // AP_RPM_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               /*
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
#pragma once

#include "AP_RPM_config.h"

#if AP_RPM_ENABLED

#include <AP_Common/AP_Common.h>
#include <AP_HAL/AP_HAL_Boards.h>
#include <AP_Param/AP_Param.h>
#include <AP_Math/AP_Math.h>
#include "AP_RPM_Params.h"

class AP_RPM_Backend;

class AP_RPM
{
    friend class AP_RPM_Backend;

public:
    AP_RPM();

    CLASS_NO_COPY(AP_RPM);  /* Do not allow copies */

    // RPM driver types
    enum RPM_Type {
        RPM_TYPE_NONE    = 0,
#if AP_RPM_PIN_ENABLED
        RPM_TYPE_PWM     = 1,
        RPM_TYPE_PIN     = 2,
#endif
#if AP_RPM_EFI_ENABLED
        RPM_TYPE_EFI     = 3,
#endif
#if AP_RPM_HARMONICNOTCH_ENABLED
        RPM_TYPE_HNTCH   = 4,
#endif
#if AP_RPM_ESC_TELEM_ENABLED
        RPM_TYPE_ESC_TELEM  = 5,
#endif
#if AP_RPM_GENERATOR_ENABLED
        RPM_TYPE_GENERATOR  = 6,
#endif
#if AP_RPM_DRONECAN_ENABLED
        RPM_TYPE_DRONECAN = 7,
#endif
#if AP_RPM_SIM_ENABLED
        RPM_TYPE_SITL   = 10,
#endif
    };

    // The RPM_State structure is filled in by the backend driver
    struct RPM_State {
        uint8_t                instance;        // the instance number of this RPM
        float                  rate_rpm;        // measured rate in revs per minute
        uint32_t               last_reading_ms; // time of last reading
        float                  signal_quality;  // synthetic quality metric 
    };

    // parameters for each instance
    AP_RPM_Params _params[RPM_MAX_INSTANCES];

    static const struct AP_Param::GroupInfo var_info[];

    // Return the number of rpm sensor instances
    uint8_t num_sensors(void) const {
        return num_instances;
    }

    // detect and initialise any available rpm sensors
    void init(void);

    // update state of all rpm sensors. Should be called from main loop
    void update(void);

    /*
      return RPM for a sensor. Return -1 if not healthy
     */
    bool get_rpm(uint8_t instance, float &rpm_value) const;

    /*
      return signal quality for a sensor.
     */
    float get_signal_quality(uint8_t instance) const {
        return state[instance].signal_quality;
    }

    bool healthy(uint8_t instance) const;

    bool enabled(uint8_t instance) const;

    static AP_RPM *get_singleton() { return _singleton; }

    // check settings are valid
    bool arming_checks(size_t buflen, char *buffer) const;

#ifdef HAL_PERIPH_ENABLE_RPM_STREAM
    // Return the sensor id to use for streaming over DroneCAN, negative number disables
    int8_t get_dronecan_sensor_id(uint8_t instance) const;
#endif

private:
    void convert_params(void);

    static AP_RPM *_singleton;

    RPM_State state[RPM_MAX_INSTANCES];
    AP_RPM_Backend *drivers[RPM_MAX_INSTANCES];
    uint8_t num_instances;

    void Log_RPM() const;
};

namespace AP {
    AP_RPM *rpm();
};

#endif  // AP_RPM_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              /*
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include "AP_RangeFinder_BLPing.h"

#if AP_RANGEFINDER_BLPING_ENABLED

#include <AP_HAL/AP_HAL.h>

void AP_RangeFinder_BLPing::update(void)
{
    if (uart == nullptr) {
        return;
    }
    AP_RangeFinder_Backend_Serial::update();

    if (status() == RangeFinder::Status::NoData) {
        const uint32_t now = AP_HAL::millis();
        // initialise sensor if no distances recently
        if (now - last_init_ms > read_timeout_ms()) {
            last_init_ms = now;
            init_sensor();
        }
    }
}

void AP_RangeFinder_BLPing::init_sensor()
{
    // Set message interval between pings in ms
    uint16_t ping_interval = _sensor_rate_ms;
    protocol.send_message(uart, PingProtocol::MessageId::SET_PING_INTERVAL, reinterpret_cast<uint8_t*>(&ping_interval), sizeof(ping_interval));

    // Send a message requesting a continuous
    uint16_t continuous_message = static_cast<uint16_t>(PingProtocol::MessageId::DISTANCE_SIMPLE);
    protocol.send_message(uart, PingProtocol::MessageId::CONTINUOUS_START, reinterpret_cast<uint8_t*>(&continuous_message), sizeof(continuous_message));
}

// distance returned in reading_m, signal_ok is set to true if sensor reports a strong signal
bool AP_RangeFinder_BLPing::get_reading(float &reading_m)
{
    if (uart == nullptr) {
        return false;
    }

    struct {
        float sum_cm = 0;
        uint16_t count = 0;
        float mean() const { return sum_cm / count; };
    } averageStruct;

    // read any available lines from the lidar
    for (auto i=0; i<8192; i++) {
        uint8_t b;
        if (!uart->read(b)) {
            break;
        }
        if (protocol.parse_byte(b) == PingProtocol::MessageId::DISTANCE_SIMPLE) {
            averageStruct.count++;
            averageStruct.sum_cm += protocol.get_distance_mm()/10.0f;
        }
    }

    if (averageStruct.count > 0) {
        // return average distance of readings
        reading_m = averageStruct.mean() * 0.01f;
        return true;
    }

    // no readings so return false
    return false;
}

int8_t AP_RangeFinder_BLPing::get_signal_quality_pct() const
{
    if (status() != RangeFinder::Status::Good) {
        return RangeFinder::SIGNAL_QUALITY_UNKNOWN;
    }
    return protocol.get_confidence();
}

uint8_t PingProtocol::get_confidence() const
{
    return msg.payload[4];
}

uint32_t PingProtocol::get_distance_mm() const
{
    return (uint32_t)msg.payload[0] |
            (uint32_t)msg.payload[1] << 8 |
            (uint32_t)msg.payload[2] << 16 |
            (uint32_t)msg.payload[3] << 24;
}

void PingProtocol::send_message(AP_HAL::UARTDriver *uart, PingProtocol::MessageId msg_id, const uint8_t *payload, uint16_t payload_len) const
{
    if (uart == nullptr) {
        return;
    }

    // check for sufficient space in outgoing buffer
    if (uart->txspace() < payload_len + 10U) {
        return;
    }

    // write header
    uart->write(_frame_header1);
    uart->write(_frame_header2);
    uint16_t crc = _frame_header1 + _frame_header2;

    // write payload length
    uart->write(LOWBYTE(payload_len));
    uart->write(HIGHBYTE(payload_len));
    crc += LOWBYTE(payload_len) + HIGHBYTE(payload_len);

    // message id
    uart->write(LOWBYTE(msg_id));
    uart->write(HIGHBYTE(msg_id));
    crc += LOWBYTE(msg_id) + HIGHBYTE(msg_id);

    // src dev id
    uart->write(_src_id);
    crc += _src_id;

    // destination dev id
    uart->write(_dst_id);
    crc += _dst_id;

    // payload
    if (payload != nullptr) {
        for (uint16_t i = 0; i<payload_len; i++) {
            uart->write(payload[i]);
            crc += payload[i];
        }
    }

    // checksum
    uart->write(LOWBYTE(crc));
    uart->write(HIGHBYTE(crc));
}

PingProtocol::MessageId PingProtocol::parse_byte(uint8_t b)
{
    // process byte depending upon current state
    switch (msg.state) {

    case ParserState::HEADER1:
        if (b == _frame_header1) {
            msg.crc_expected = _frame_header1;
            msg.state = ParserState::HEADER2;
            msg.done = false;
        }
        break;

    case ParserState::HEADER2:
        if (b == _frame_header2) {
            msg.crc_expected += _frame_header2;
            msg.state = ParserState::LEN_L;
        } else {
            msg.state = ParserState::HEADER1;
        }
        break;

    case ParserState::LEN_L:
        msg.payload_len = b;
        msg.crc_expected += b;
        msg.state = ParserState::LEN_H;
        break;

    case ParserState::LEN_H:
        msg.payload_len |= ((uint16_t)b << 8);
        msg.payload_recv = 0;
        msg.crc_expected += b;
        msg.state = ParserState::MSG_ID_L;
        break;

    case ParserState::MSG_ID_L:
        msg.id = b;
        msg.crc_expected += b;
        msg.state = ParserState::MSG_ID_H;
        break;

    case ParserState::MSG_ID_H:
        msg.id |= ((uint16_t)b << 8);
        msg.crc_expected += b;
        msg.state = ParserState::SRC_ID;
        break;

    case ParserState::SRC_ID:
        msg.crc_expected += b;
        msg.state = ParserState::DST_ID;
        break;

    case ParserState::DST_ID:
        msg.crc_expected += b;
        msg.state = ParserState::PAYLOAD;
        break;

    case ParserState::PAYLOAD:
        if (msg.payload_recv < msg.payload_len) {
            if (msg.payload_recv < ARRAY_SIZE(msg.payload)) {
                msg.payload[msg.payload_recv] = b;
            }
            msg.payload_recv++;
            msg.crc_expected += b;
        }
        if (msg.payload_recv == msg.payload_len) {
            msg.state = ParserState::CRC_L;
        }
        break;

    case ParserState::CRC_L:
        msg.crc = b;
        msg.state = ParserState::CRC_H;
        break;

    case ParserState::CRC_H:
        msg.crc |= ((uint16_t)b << 8);
        msg.state = ParserState::HEADER1;
        msg.done = msg.crc_expected == msg.crc;
        break;
    }


    return msg.done ? get_message_id() : MessageId::INVALID;
}

#endif  // AP_RANGEFINDER_BLPING_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         #pragma once

#include "AP_RangeFinder_config.h"

#if AP_RANGEFINDER_BLPING_ENABLED

#include "AP_RangeFinder_Backend_Serial.h"

/**
 * @brief Simple class to deal with Ping Protocol
 *
 *  Protocol documentation can be found here: https:* github.com/bluerobotics/ping-protocol
 *
 *  Byte     Type        Name            Description
 *  --------------------------------------------------------------------------------------------------------------
 *  0        uint8_t     start1          'B'
 *  1        uint8_t     start2          'R'
 *  2-3      uint16_t    payload_length  number of bytes in payload (low byte, high byte)
 *  4-5      uint16_t    message id      message id (low byte, high byte)
 *  6        uint8_t     src_device_id   id of device sending the message
 *  7        uint8_t     dst_device_id   id of device of the intended recipient
 *  8-n      uint8_t[]   payload         message payload
 *  (n+1)-(n+2)  uint16_t    checksum    the sum of all the non-checksum bytes in the message (low byte, high byte)
 */
class PingProtocol {
    static constexpr uint8_t _frame_header1 = 0x42; // // header first byte ('B')
    static constexpr uint8_t _frame_header2 = 0x52; // // header first byte ('R')
    static constexpr uint16_t _src_id = 0; // vehicle's source id
    static constexpr uint16_t _dst_id = 1; // sensor's id

public:
    enum class MessageId {
        INVALID = 0,
        SET_PING_INTERVAL = 1004,
        DISTANCE_SIMPLE = 1211,
        CONTINUOUS_START = 1400,
    };

    /**
     * @brief Process a single byte received on serial port
     *  return a valid MessageId if there is a message in buffer.
     *
     * @param byte
     * @return MessageId
     */
    MessageId parse_byte(uint8_t b);

    /**
     * @brief Send a message with a defined payload
     *
     * @param uart
     * @param msgid
     * @param payload
     * @param payload_len
     */
    void send_message(AP_HAL::UARTDriver *uart, PingProtocol::MessageId msg_id, const uint8_t *payload, uint16_t payload_len) const;

    /**
     * @brief Get distance from message
     *
     * @return uint32_t
     */
    uint32_t get_distance_mm() const;

    /**
     * @brief Get confidence from message
     *
     * @return uint8_t
     */
    uint8_t get_confidence() const;

    /**
     * @brief Get the message id available in bufffer
     *
     * @return MessageId
     */
    MessageId get_message_id() const { return static_cast<MessageId>(msg.id); };

protected:
    /**
     * @brief State for the parser logic
     *
     */
    enum class ParserState {
        HEADER1 = 0,
        HEADER2,
        LEN_L,
        LEN_H,
        MSG_ID_L,
        MSG_ID_H,
        SRC_ID,
        DST_ID,
        PAYLOAD,
        CRC_L,
        CRC_H
    };

    /**
     * @brief Structure holding the last message available with its state
     *
     */
    struct {
        ParserState state;      // state of incoming message processing
        bool done;              // inform if the message is complete or not
        uint8_t payload[20];    // payload
        uint16_t payload_len;   // latest message payload length
        uint16_t id;            // latest message's message id
        uint16_t payload_recv;  // number of message's payload bytes received so far
        uint16_t crc;           // latest message's crc
        uint16_t crc_expected;  // latest message's expected crc
    } msg;
};

/**
 * @brief Class for Blue Robotics Ping1D sensor
 *
 */
class AP_RangeFinder_BLPing : public AP_RangeFinder_Backend_Serial
{
    static constexpr uint16_t _sensor_rate_ms = 50; // initialise sensor at no more than 20hz

public:

    static AP_RangeFinder_Backend_Serial *create(
        RangeFinder::RangeFinder_State &_state,
        AP_RangeFinder_Params &_params) {
        return NEW_NOTHROW AP_RangeFinder_BLPing(_state, _params);
    }

    /**
     * @brief Update class state
     *
     */
    void update(void) override;

    /**
     * @brief Get the reading confidence
     * 100 is best quality, 0 is worst
     *
     */
    int8_t get_signal_quality_pct() const override WARN_IF_UNUSED;

protected:
    /**
     * @brief Return the sensor type
     *
     * @return MAV_DISTANCE_SENSOR
     */
    MAV_DISTANCE_SENSOR _get_mav_distance_sensor_type() const override {
        return MAV_DISTANCE_SENSOR_ULTRASOUND;
    }

    /**
     * @brief Sensor protocol class
     *
     */
    PingProtocol protocol;

private:

    using AP_RangeFinder_Backend_Serial::AP_RangeFinder_Backend_Serial;

    /**
     * @brief Do the necessary sensor initiation
     *
     */
    void init_sensor();

    /**
     * @brief Read serial interface and calculate new distance
     *
     * @param reading_m
     * @return true
     * @return false
     */
    bool get_reading(float &reading_m) override;

    /**
     * @brief Timeout between messages
     *
     * @return uint16_t
     */
    uint16_t read_timeout_ms() const override { return 1000; }

    /**
     * @brief system time that sensor was last initialised
     *
     */
    uint32_t last_init_ms;
};

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              /*
 * Copyright (C) 2019  Lucas De Marchi <lucas.de.marchi@gmail.com>
 *
 * This file is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This file is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
#include "AP_RangeFinder_Benewake_TFMiniPlus.h"

#if AP_RANGEFINDER_BENEWAKE_TFMINIPLUS_ENABLED

#include <utility>

#include <GCS_MAVLink/GCS.h>
#include <AP_HAL/AP_HAL.h>

extern const AP_HAL::HAL& hal;

#define DRIVER "TFMiniPlus"
#define BENEWAKE_OUT_OF_RANGE_ADD_CM 100

/*
 * Command format:
 *
 * uint8_t header;
 * uint8_t len;
 * uint8_t id;
 * uint8_t data[];
 * uint8_t checksum;
 */

AP_RangeFinder_Benewake_TFMiniPlus::AP_RangeFinder_Benewake_TFMiniPlus(
        RangeFinder::RangeFinder_State &_state,
        AP_RangeFinder_Params &_params,
        AP_HAL::OwnPtr<AP_HAL::I2CDevice> dev)
    : AP_RangeFinder_Backend(_state, _params)
    , _dev(std::move(dev))
{
}

AP_RangeFinder_Backend *AP_RangeFinder_Benewake_TFMiniPlus::detect(
        RangeFinder::RangeFinder_State &_state, AP_RangeFinder_Params &_params,
        AP_HAL::OwnPtr<AP_HAL::I2CDevice> dev)
{
    if (!dev) {
        return nullptr;
    }

    AP_RangeFinder_Benewake_TFMiniPlus *sensor
        = NEW_NOTHROW AP_RangeFinder_Benewake_TFMiniPlus(_state, _params, std::move(dev));

    if (!sensor || !sensor->init()) {
        delete sensor;
        return nullptr;
    }

    return sensor;
}

bool AP_RangeFinder_Benewake_TFMiniPlus::init()
{
    const uint8_t CMD_FW_VERSION[] =         { 0x5A, 0x04, 0x01, 0x5F };
    const uint8_t CMD_SYSTEM_RESET[] =       { 0x5A, 0x04, 0x04, 0x62 };
    const uint8_t CMD_OUTPUT_FORMAT_CM[] =   { 0x5A, 0x05, 0x05, 0x01, 0x65 };
    const uint8_t CMD_ENABLE_DATA_OUTPUT[] = { 0x5A, 0x05, 0x07, 0x01, 0x67 };
    const uint8_t CMD_FRAME_RATE_250HZ[] =   { 0x5A, 0x06, 0x03, 0xFA, 0x00, 0x5D };
    const uint8_t CMD_SAVE_SETTINGS[] =      { 0x5A, 0x04, 0x11, 0x6F };
    const uint8_t *cmds[] = {
        CMD_OUTPUT_FORMAT_CM,
        CMD_FRAME_RATE_250HZ,
        CMD_ENABLE_DATA_OUTPUT,
        CMD_SAVE_SETTINGS,
    };
    uint8_t val[12], i;
    bool ret;

    _dev->get_semaphore()->take_blocking();

    _dev->set_retries(0);

    /*
     * Check we get a response for firmware version to detect if sensor is there
     */
    ret = _dev->transfer(CMD_FW_VERSION, sizeof(CMD_FW_VERSION), nullptr, 0);
    if (!ret) {
        goto fail;
    }

    hal.scheduler->delay(100);

    ret = _dev->transfer(nullptr, 0, val, 7);
    if (!ret || val[0] != 0x5A || val[1] != 0x07 || val[2] != 0x01 ||
        !check_checksum(val, 7)) {
        goto fail;
    }

    if (val[5] * 10000 + val[4] * 100 + val[3] < 20003) {
        GCS_SEND_TEXT(MAV_SEVERITY_ERROR, "TFMini: FW ver %u.%u.%u (need>=2.0.3)",
                            (unsigned)val[5],(unsigned)val[4],(unsigned)val[3]);
        goto fail;
    }

    DEV_PRINTF(DRIVER ": found fw version %u.%u.%u\n",
                        val[5], val[4], val[3]);

    for (i = 0; i < ARRAY_SIZE(cmds); i++) {
        ret = _dev->transfer(cmds[i], cmds[i][1], nullptr, 0);
        if (!ret) {
            DEV_PRINTF(DRIVER ": Unable to set configuration register %u\n",
                                cmds[i][2]);
            goto fail;
        }
        hal.scheduler->delay(100);
    }

    _dev->transfer(CMD_SYSTEM_RESET, sizeof(CMD_SYSTEM_RESET), nullptr, 0);

    _dev->get_semaphore()->give();

    hal.scheduler->delay(100);

    _dev->register_periodic_callback(20000,
                                     FUNCTOR_BIND_MEMBER(&AP_RangeFinder_Benewake_TFMiniPlus::timer, void));

    return true;

fai