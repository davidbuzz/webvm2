#include <AP_HAL/AP_HAL.h>

#include "AP_NavEKF2_core.h"
#include <GCS_MAVLink/GCS.h>
#include <AP_Logger/AP_Logger.h>
#include <AP_Vehicle/AP_Vehicle_Type.h>
#include <new>

/*
  parameter defaults for different types of vehicle. The
  APM_BUILD_DIRECTORY is taken from the main vehicle directory name
  where the code is built.
 */
#if APM_BUILD_COPTER_OR_HELI || APM_BUILD_TYPE(APM_BUILD_Replay)
// copter defaults
#define VELNE_M_NSE_DEFAULT     0.3f
#define VELD_M_NSE_DEFAULT      0.5f
#define POSNE_M_NSE_DEFAULT     1.0f
#define ALT_M_NSE_DEFAULT       3.0f
#define MAG_M_NSE_DEFAULT       0.05f
#define GYRO_P_NSE_DEFAULT      3.0E-02f
#define ACC_P_NSE_DEFAULT       6.0E-01f
#define GBIAS_P_NSE_DEFAULT     1.0E-04f
#define GSCALE_P_NSE_DEFAULT    5.0E-04f
#define ABIAS_P_NSE_DEFAULT     5.0E-03f
#define MAGB_P_NSE_DEFAULT      1.0E-04f
#define MAGE_P_NSE_DEFAULT      1.0E-03f
#define VEL_I_GATE_DEFAULT      500
#define POS_I_GATE_DEFAULT      500
#define HGT_I_GATE_DEFAULT      500
#define MAG_I_GATE_DEFAULT      300
#define MAG_CAL_DEFAULT         3
#define GLITCH_RADIUS_DEFAULT   25
#define FLOW_MEAS_DELAY         10
#define FLOW_M_NSE_DEFAULT      0.25f
#define FLOW_I_GATE_DEFAULT     300
#define CHECK_SCALER_DEFAULT    100
#define FLOW_USE_DEFAULT        1

#elif APM_BUILD_TYPE(APM_BUILD_Rover)
// rover defaults
#define VELNE_M_NSE_DEFAULT     0.5f
#define VELD_M_NSE_DEFAULT      0.7f
#define POSNE_M_NSE_DEFAULT     1.0f
#define ALT_M_NSE_DEFAULT       3.0f
#define MAG_M_NSE_DEFAULT       0.05f
#define GYRO_P_NSE_DEFAULT      3.0E-02f
#define ACC_P_NSE_DEFAULT       6.0E-01f
#define GBIAS_P_NSE_DEFAULT     1.0E-04f
#define GSCALE_P_NSE_DEFAULT    5.0E-04f
#define ABIAS_P_NSE_DEFAULT     5.0E-03f
#define MAGB_P_NSE_DEFAULT      1.0E-04f
#define MAGE_P_NSE_DEFAULT      1.0E-03f
#define VEL_I_GATE_DEFAULT      500
#define POS_I_GATE_DEFAULT      500
#define HGT_I_GATE_DEFAULT      500
#define MAG_I_GATE_DEFAULT      300
#define MAG_CAL_DEFAULT         2
#define GLITCH_RADIUS_DEFAULT   25
#define FLOW_MEAS_DELAY         10
#define FLOW_M_NSE_DEFAULT      0.25f
#define FLOW_I_GATE_DEFAULT     300
#define CHECK_SCALER_DEFAULT    100
#define FLOW_USE_DEFAULT        1

#elif APM_BUILD_TYPE(APM_BUILD_ArduPlane)
// plane defaults
#define VELNE_M_NSE_DEFAULT     0.5f
#define VELD_M_NSE_DEFAULT      0.7f
#define POSNE_M_NSE_DEFAULT     1.0f
#define ALT_M_NSE_DEFAULT       3.0f
#define MAG_M_NSE_DEFAULT       0.05f
#define GYRO_P_NSE_DEFAULT      3.0E-02f
#define ACC_P_NSE_DEFAULT       6.0E-01f
#define GBIAS_P_NSE_DEFAULT     1.0E-04f
#define GSCALE_P_NSE_DEFAULT    5.0E-04f
#define ABIAS_P_NSE_DEFAULT     5.0E-03f
#define MAGB_P_NSE_DEFAULT      1.0E-04f
#define MAGE_P_NSE_DEFAULT      1.0E-03f
#define VEL_I_GATE_DEFAULT      500
#define POS_I_GATE_DEFAULT      500
#define HGT_I_GATE_DEFAULT      500
#define MAG_I_GATE_DEFAULT      300
#define MAG_CAL_DEFAULT         0
#define GLITCH_RADIUS_DEFAULT   25
#define FLOW_MEAS_DELAY         10
#define FLOW_M_NSE_DEFAULT      0.15f
#define FLOW_I_GATE_DEFAULT     500
#define CHECK_SCALER_DEFAULT    150
#define FLOW_USE_DEFAULT        2

#else
// build type not specified, use copter defaults
#define VELNE_M_NSE_DEFAULT     0.5f
#define VELD_M_NSE_DEFAULT      0.7f
#define POSNE_M_NSE_DEFAULT     1.0f
#define ALT_M_NSE_DEFAULT       3.0f
#define MAG_M_NSE_DEFAULT       0.05f
#define GYRO_P_NSE_DEFAULT      3.0E-02f
#define ACC_P_NSE_DEFAULT       6.0E-01f
#define GBIAS_P_NSE_DEFAULT     1.0E-04f
#define GSCALE_P_NSE_DEFAULT    5.0E-04f
#define ABIAS_P_NSE_DEFAULT     5.0E-03f
#define MAGB_P_NSE_DEFAULT      1.0E-04f
#define MAGE_P_NSE_DEFAULT      1.0E-03f
#define VEL_I_GATE_DEFAULT      500
#define POS_I_GATE_DEFAULT      500
#define HGT_I_GATE_DEFAULT      500
#define MAG_I_GATE_DEFAULT      300
#define MAG_CAL_DEFAULT         3
#define GLITCH_RADIUS_DEFAULT   25
#define FLOW_MEAS_DELAY         10
#define FLOW_M_NSE_DEFAULT      0.25f
#define FLOW_I_GATE_DEFAULT     300
#define CHECK_SCALER_DEFAULT    100
#define FLOW_USE_DEFAULT        1

#endif // APM_BUILD_DIRECTORY

// This allows boards to default to using a specified number of IMUs and EKF lanes
#ifndef HAL_EKF_IMU_MASK_DEFAULT
#define HAL_EKF_IMU_MASK_DEFAULT 3       // Default to using two IMUs
#endif

extern const AP_HAL::HAL& hal;

// Define tuning parameters
const AP_Param::GroupInfo NavEKF2::var_info[] = {

    // @Param: ENABLE
    // @DisplayName: Enable EKF2
    // @Description: This enables EKF2. Enabling EKF2 only makes the maths run, it does not mean it will be used for flight control. To use it for flight control set AHRS_EKF_TYPE=2. A reboot or restart will need to be performed after changing the value of EK2_ENABLE for it to take effect.
    // @Values: 0:Disabled, 1:Enabled
    // @User: Advanced
    // @RebootRequired: True
    AP_GROUPINFO_FLAGS("ENABLE", 0, NavEKF2, _enable, 0, AP_PARAM_FLAG_ENABLE),

    // GPS measurement parameters

    // @Param: GPS_TYPE
    // @DisplayName: GPS mode control
    // @Description: This controls use of GPS measurements : 0 = use 3D velocity & 2D position, 1 = use 2D velocity and 2D position, 2 = use 2D position, 3 = Inhibit GPS use - this can be useful when flying with an optical flow sensor in an environment where GPS quality is poor and subject to large multipath errors.
    // @Values: 0:GPS 3D Vel and 2D Pos, 1:GPS 2D vel and 2D pos, 2:GPS 2D pos, 3:No GPS
    // @User: Advanced
    AP_GROUPINFO("GPS_TYPE", 1, NavEKF2, _fusionModeGPS, 0),

    // @Param: VELNE_M_NSE
    // @DisplayName: GPS horizontal velocity measurement noise (m/s)
    // @Description: This sets a lower limit on the speed accuracy reported by the GPS receiver that is used to set horizontal velocity observation noise. If the model of receiver used does not provide a speed accurcy estimate, then the parameter value will be used. Increasing it reduces the weighting of the GPS horizontal velocity measurements.
    // @Range: 0.05 5.0
    // @Increment: 0.05
    // @User: Advanced
    // @Units: m/s
    AP_GROUPINFO("VELNE_M_NSE", 2, NavEKF2, _gpsHorizVelNoise, VELNE_M_NSE_DEFAULT),

    // @Param: VELD_M_NSE
    // @DisplayName: GPS vertical velocity measurement noise (m/s)
    // @Description: This sets a lower limit on the speed accuracy reported by the GPS receiver that is used to set vertical velocity observation noise. If the model of receiver used does not provide a speed accurcy estimate, then the parameter value will be used. Increasing it reduces the weighting of the GPS vertical velocity measurements.
    // @Range: 0.05 5.0
    // @Increment: 0.05
    // @User: Advanced
    // @Units: m/s
    AP_GROUPINFO("VELD_M_NSE", 3, NavEKF2, _gpsVertVelNoise, VELD_M_NSE_DEFAULT),

    // @Param: VEL_I_GATE
    // @DisplayName: GPS velocity innovation gate size
    // @Description: This sets the percentage number of standard deviations applied to the GPS velocity measurement innovation consistency check. Decreasing it makes it more likely that good measurements will be rejected. Increasing it makes it more likely that bad measurements will be accepted.
    // @Range: 100 1000
    // @Increment: 25
    // @User: Advanced
    AP_GROUPINFO("VEL_I_GATE", 4, NavEKF2, _gpsVelInnovGate, VEL_I_GATE_DEFAULT),

    // @Param: POSNE_M_NSE
    // @DisplayName: GPS horizontal position measurement noise (m)
    // @Description: This sets the GPS horizontal position observation noise. Increasing it reduces the weighting of GPS horizontal position measurements.
    // @Range: 0.1 10.0
    // @Increment: 0.1
    // @User: Advanced
    // @Units: m
    AP_GROUPINFO("POSNE_M_NSE", 5, NavEKF2, _gpsHorizPosNoise, POSNE_M_NSE_DEFAULT),

    // @Param: POS_I_GATE
    // @DisplayName: GPS position measurement gate size
    // @Description: This sets the percentage number of standard deviations applied to the GPS position measurement innovation consistency check. Decreasing it makes it more likely that good measurements will be rejected. Increasing it makes it more likely that bad measurements will be accepted.
    // @Range: 100 1000
    // @Increment: 25
    // @User: Advanced
    AP_GROUPINFO("POS_I_GATE", 6, NavEKF2, _gpsPosInnovGate, POS_I_GATE_DEFAULT),

    // @Param: GLITCH_RAD
    // @DisplayName: GPS glitch radius gate size (m)
    // @Description: This controls the maximum radial uncertainty in position between the value predicted by the filter and the value measured by the GPS before the filter position and velocity states are reset to the GPS. Making this value larger allows the filter to ignore larger GPS glitches but also means that non-GPS errors such as IMU and compass can create a larger error in position before the filter is forced back to the GPS position.
    // @Range: 10 100
    // @Increment: 5
    // @User: Advanced
    // @Units: m
    AP_GROUPINFO("GLITCH_RAD", 7, NavEKF2, _gpsGlitchRadiusMax, GLITCH_RADIUS_DEFAULT),

    // 8 was used for GPS_DELAY

    // Height measurement parameters

    // @Param: ALT_SOURCE
    // @DisplayName: Primary altitude sensor source
    // @Description: Primary height sensor used by the EKF. If a sensor other than Baro is selected and becomes unavailable, then the Baro sensor will be used as a fallback. NOTE: The EK2_RNG_USE_HGT parameter can be used to switch to range-finder when close to the ground in conjunction with EK2_ALT_SOURCE = 0 or 2 (Baro or GPS).
    // @Values: 0:Use Baro, 1:Use Range Finder, 2:Use GPS, 3:Use Range Beacon
    // @User: Advanced
    // @RebootRequired: True
    AP_GROUPINFO("ALT_SOURCE", 9, NavEKF2, _altSource, 0),

    // @Param: ALT_M_NSE
    // @DisplayName: Altitude measurement noise (m)
    // @Description: This is the RMS value of noise in the altitude measurement. Increasing it reduces the weighting of the baro measurement and will make the filter respond more slowly to baro measurement errors, but will make it more sensitive to GPS and accelerometer errors.
    // @Range: 0.1 10.0
    // @Increment: 0.1
    // @User: Advanced
    // @Units: m
    AP_GROUPINFO("ALT_M_NSE", 10, NavEKF2, _baroAltNoise, ALT_M_NSE_DEFAULT),

    // @Param: HGT_I_GATE
    // @DisplayName: Height measurement gate size
    // @Description: This sets the percentage number of standard deviations applied to the height measurement innovation consistency check. Decreasing it makes it more likely that good measurements will be rejected. Increasing it makes it more likely that bad measurements will be accepted.
    // @Range: 100 1000
    // @Increment: 25
    // @User: Advanced
    AP_GROUPINFO("HGT_I_GATE", 11, NavEKF2, _hgtInnovGate, HGT_I_GATE_DEFAULT),

    // @Param: HGT_DELAY
    // @DisplayName: Height measurement delay (msec)
    // @Description: This is the number of msec that the Height measurements lag behind the inertial measurements.
    // @Range: 0 250
    // @Increment: 10
    // @User: Advanced
    // @Units: ms
    // @RebootRequired: True
    AP_GROUPINFO("HGT_DELAY", 12, NavEKF2, _hgtDelay_ms, 60),

    // Magnetometer measurement parameters

    // @Param: MAG_M_NSE
    // @DisplayName: Magnetometer measurement noise (Gauss)
    // @Description: This is the RMS value of noise in magnetometer measurements. Increasing it reduces the weighting on these measurements.
    // @Range: 0.01 0.5
    // @Increment: 0.01
    // @User: Advanced
    // @Units: Gauss
    AP_GROUPINFO("MAG_M_NSE", 13, NavEKF2, _magNoise, MAG_M_NSE_DEFAULT),

    // @Param: MAG_CAL
    // @DisplayName: Magnetometer default fusion mode
    // @Description: This determines when the filter will use the 3-axis magnetometer fusion model that estimates both earth and body fixed magnetic field states, when it will use a simpler magnetic heading fusion model that does not use magnetic field states and when it will use an alternative method of yaw determination to the magnetometer. The 3-axis magnetometer fusion is only suitable for use when the external magnetic field environment is stable. EK2_MAG_CAL = 0 uses heading fusion on ground, 3-axis fusion in-flight, and is the default setting for Plane users. EK2_MAG_CAL = 1 uses 3-axis fusion only when manoeuvring. EK2_MAG_CAL = 2 uses heading fusion at all times, is recommended if the external magnetic field is varying and is the default for rovers. EK2_MAG_CAL = 3 uses heading fusion on the ground and 3-axis fusion after the first in-air field and yaw reset has completed, and is the default for copters. EK2_MAG_CAL = 4 uses 3-axis fusion at all times. NOTE: The fusion mode can be forced to 2 for specific EKF cores using the EK2_MAG_MASK parameter. NOTE: limited operation without a magnetometer or any other yaw sensor is possible by setting all COMPASS_USE, COMPASS_USE2, COMPASS_USE3, etc parameters to 0 with COMPASS_ENABLE set to 1. If this is done, the EK2_GSF_RUN and EK2_GSF_USE masks must be set to the same as EK2_IMU_MASK.
    // @Values: 0:When flying,1:When manoeuvring,2:Never,3:After first climb yaw reset,4:Always
    // @User: Advanced
    AP_GROUPINFO("MAG_CAL", 14, NavEKF2, _magCal, MAG_CAL_DEFAULT),

    // @Param: MAG_I_GATE
    // @DisplayName: Magnetometer measurement gate size
    // @Description: This sets the percentage number of standard deviations applied to the magnetometer measurement innovation consistency check. Decreasing it makes it more likely that good measurements will be rejected. Increasing it makes it more likely that bad measurements will be accepted.
    // @Range: 100 1000
    // @Increment: 25
    // @User: Advanced
    AP_GROUPINFO("MAG_I_GATE", 15, NavEKF2, _magInnovGate, MAG_I_GATE_DEFAULT),

    // Airspeed measurement parameters

    // @Param: EAS_M_NSE
    // @DisplayName: Equivalent airspeed measurement noise (m/s)
    // @Description: This is the RMS value of noise in equivalent airspeed measurements used by planes. Increasing it reduces the weighting of airspeed measurements and will make wind speed estimates less noisy and slower to converge. Increasing also increases navigation errors when dead-reckoning without GPS measurements.
    // @Range: 0.5 5.0
    // @Increment: 0.1
    // @User: Advanced
    // @Units: m/s
    AP_GROUPINFO("EAS_M_NSE", 16, NavEKF2, _easNoise, 1.4f),

    // @Param: EAS_I_GATE
    // @DisplayName: Airspeed measurement gate size
    // @Description: This sets the percentage number of standard deviations applied to the airspeed measurement innovation consistency check. Decreasing it makes it more likely that good measurements will be rejected. Increasing it makes it more likely that bad measurements will be accepted.
    // @Range: 100 1000
    // @Increment: 25
    // @User: Advanced
    AP_GROUPINFO("EAS_I_GATE", 17, NavEKF2, _tasInnovGate, 400),

    // Rangefinder measurement parameters

    // @Param: RNG_M_NSE
    // @DisplayName: Range finder measurement noise (m)
    // @Description: This is the RMS value of noise in the range finder measurement. Increasing it reduces the weighting on this measurement.
    // @Range: 0.1 10.0
    // @Increment: 0.1
    // @User: Advanced
    // @Units: m
    AP_GROUPINFO("RNG_M_NSE", 18, NavEKF2, _rngNoise, 0.5f),

    // @Param: RNG_I_GATE
    // @DisplayName: Range finder measurement gate size
    // @Description: This sets the percentage number of standard deviations applied to the range finder innovation consistency check. Decreasing it makes it more likely that good measurements will be rejected. Increasing it makes it more likely that bad measurements will be accepted.
    // @Range: 100 1000
    // @Increment: 25
    // @User: Advanced
    AP_GROUPINFO("RNG_I_GATE", 19, NavEKF2, _rngInnovGate, 500),

    // Optical flow measurement parameters

    // @Param: MAX_FLOW
    // @DisplayName: Maximum valid optical flow rate
    // @Description: This sets the magnitude maximum optical flow rate in rad/sec that will be accepted by the filter
    // @Range: 1.0 4.0
    // @Increment: 0.1
    // @User: Advanced
    // @Units: rad/s
    AP_GROUPINFO("MAX_FLOW", 20, NavEKF2, _maxFlowRate, 2.5f),

    // @Param: FLOW_M_NSE
    // @DisplayName: Optical flow measurement noise (rad/s)
    // @Description: This is the RMS value of noise and errors in optical flow measurements. Increasing it reduces the weighting on these measurements.
    // @Range: 0.05 1.0
    // @Increment: 0.05
    // @User: Advanced
    // @Units: rad/s
    AP_GROUPINFO("FLOW_M_NSE", 21, NavEKF2, _flowNoise, FLOW_M_NSE_DEFAULT),

    // @Param: FLOW_I_GATE
    // @DisplayName: Optical Flow measurement gate size
    // @Description: This sets the percentage number of standard deviations applied to the optical flow innovation consistency check. Decreasing it makes it more likely that good measurements will be rejected. Increasing it makes it more likely that bad measurements will be accepted.
    // @Range: 100 1000
    // @Increment: 25
    // @User: Advanced
    AP_GROUPINFO("FLOW_I_GATE", 22, NavEKF2, _flowInnovGate, FLOW_I_GATE_DEFAULT),

    // @Param: FLOW_DELAY
    // @DisplayName: Optical Flow measurement delay (msec)
    // @Description: This is the number of msec that the optical flow measurements lag behind the inertial measurements. It is the time from the end of the optical flow averaging period and does not include the time delay due to the 100msec of averaging within the flow sensor.
    // @Range: 0 127
    // @Increment: 10
    // @User: Advanced
    // @Units: ms
    // @RebootRequired: True
    AP_GROUPINFO("FLOW_DELAY", 23, NavEKF2, _flowDelay_ms, FLOW_MEAS_DELAY),

    // State and Covariance Predition Parameters

    // @Param: GYRO_P_NSE
    // @DisplayName: Rate gyro noise (rad/s)
    // @Description: This control disturbance noise controls the growth of estimated error due to gyro measurement errors excluding bias. Increasing it makes the flter trust the gyro measurements less and other measurements more.
    // @Range: 0.0001 0.1
    // @Increment: 0.0001
    // @User: Advanced
    // @Units: rad/s
    AP_GROUPINFO("GYRO_P_NSE", 24, NavEKF2, _gyrNoise, GYRO_P_NSE_DEFAULT),

    // @Param: ACC_P_NSE
    // @DisplayName: Accelerometer noise (m/s^2)
    // @Description: This control disturbance noise controls the growth of estimated error due to accelerometer measurement errors excluding bias. Increasing it makes the flter trust the accelerometer measurements less and other measurements more.
    // @Range: 0.01 1.0
    // @Increment: 0.01
    // @User: Advanced
    // @Units: m/s/s
    AP_GROUPINFO("ACC_P_NSE", 25, NavEKF2, _accNoise, ACC_P_NSE_DEFAULT),

    // @Param: GBIAS_P_NSE
    // @DisplayName: Rate gyro bias stability (rad/s/s)
    // @Description: This state  process noise controls growth of the gyro delta angle bias state error estimate. Increasing it makes rate gyro bias estimation faster and noisier.
    // @Range: 0.00001 0.001
    // @User: Advanced
    // @Units: rad/s/s
    AP_GROUPINFO("GBIAS_P_NSE", 26, NavEKF2, _gyroBiasProcessNoise, GBIAS_P_NSE_DEFAULT),

    // @Param: GSCL_P_NSE
    // @DisplayName: Rate gyro scale factor stability (1/s)
    // @Description: This noise controls the rate of gyro scale factor learning. Increasing it makes rate gyro scale factor estimation faster and noisier.
    // @Range: 0.000001 0.001
    // @User: Advanced
    // @Units: Hz
    AP_GROUPINFO("GSCL_P_NSE", 27, NavEKF2, _gyroScaleProcessNoise, GSCALE_P_NSE_DEFAULT),

    // @Param: ABIAS_P_NSE
    // @DisplayName: Accelerometer bias stability (m/s^3)
    // @Description: This noise controls the growth of the vertical accelerometer delta velocity bias state error estimate. Increasing it makes accelerometer bias estimation faster and noisier.
    // @Range: 0.00001 0.005
    // @User: Advanced
    // @Units: m/s/s/s
    AP_GROUPINFO("ABIAS_P_NSE", 28, NavEKF2, _accelBiasProcessNoise, ABIAS_P_NSE_DEFAULT),

    // 29 previously used for EK2_MAG_P_NSE parameter that has been replaced with EK2_MAGE_P_NSE and EK2_MAGB_P_NSE

    // @Param: WIND_P_NSE
    // @DisplayName: Wind velocity process noise (m/s^2)
    // @Description: This state process noise controls the growth of wind state error estimates. Increasing it makes wind estimation faster and noisier.
    // @Range: 0.01 1.0
    // @Increment: 0.1
    // @User: Advanced
    // @Units: m/s/s
    AP_GROUPINFO("WIND_P_NSE", 30, NavEKF2, _windVelProcessNoise, 0.1f),

    // @Param: WIND_PSCALE
    // @DisplayName: Height rate to wind process noise scaler
    // @Description: This controls how much the process noise on the wind states is increased when gaining or losing altitude to take into account changes in wind speed and direction with altitude. Increasing this parameter increases how rapidly the wind states adapt when changing altitude, but does make wind velocity estimation noiser.
    // @Range: 0.0 1.0
    // @Increment: 0.1
    // @User: Advanced
    AP_GROUPINFO("WIND_PSCALE", 31, NavEKF2, _wndVarHgtRateScale, 0.5f),

    // @Param: GPS_CHECK
    // @DisplayName: GPS preflight check
    // @Description: This is a 1 byte bitmap controlling which GPS preflight checks are performed. Set to 0 to bypass all checks. Set to 255 perform all checks. Set to 3 to check just the number of satellites and HDoP. Set to 31 for the most rigorous checks that will still allow checks to pass when the copter is moving, eg launch from a boat.
    // @Bitmask: 0:NSats,1:HDoP,2:speed error,3:position error,4:yaw error,5:pos drift,6:vert speed,7:horiz speed
    // @User: Advanced
    AP_GROUPINFO("GPS_CHECK",    32, NavEKF2, _gpsCheck, 31),

    // @Param: IMU_MASK
    // @DisplayName: Bitmask of active IMUs
    // @Description: 1 byte bitmap of IMUs to use in EKF2. A separate instance of EKF2 will be started for each IMU selected. Set to 1 to use the first IMU only (default), set to 2 to use the second IMU only, set to 3 to use the first and second IMU. Additional IMU's can be used up to a maximum of 6 if memory and processing resources permit. There may be insufficient memory and processing resources to run multiple instances. If this occurs EKF2 will fail to start.
    // @Bitmask: 0:FirstIMU,1:SecondIMU,2:ThirdIMU,3:FourthIMU,4:FifthIMU,5:SixthIMU
    // @User: Advanced
    // @RebootRequired: True
    AP_GROUPINFO("IMU_MASK",     33, NavEKF2, _imuMask, HAL_EKF_IMU_MASK_DEFAULT),
    
    // @Param: CHECK_SCALE
    // @DisplayName: GPS accuracy check scaler (%)
    // @Description: This scales the thresholds that are used to check GPS accuracy before it is used by the EKF. A value of 100 is the default. Values greater than 100 increase and values less than 100 reduce the maximum GPS error the EKF will accept. A value of 200 will double the allowable GPS error.
    // @Range: 50 200
    // @User: Advanced
    // @Units: %
    AP_GROUPINFO("CHECK_SCALE", 34, NavEKF2, _gpsCheckScaler, CHECK_SCALER_DEFAULT),

    // @Param: NOAID_M_NSE
    // @DisplayName: Non-GPS operation position uncertainty (m)
    // @Description: This sets the amount of position variation that the EKF allows for when operating without external measurements (eg GPS or optical flow). Increasing this parameter makes the EKF attitude estimate less sensitive to vehicle manoeuvres but more sensitive to IMU errors.
    // @Range: 0.5 50.0
    // @User: Advanced
    // @Units: m
    AP_GROUPINFO("NOAID_M_NSE", 35, NavEKF2, _noaidHorizNoise, 10.0f),

    // 36 was LOG_MASK, used for specifying which IMUs/cores to log
    // replay data for

    // control of magnetic yaw angle fusion

    // @Param: YAW_M_NSE
    // @DisplayName: Yaw measurement noise (rad)
    // @Description: This is the RMS value of noise in yaw measurements from the magnetometer. Increasing it reduces the weighting on these measurements.
    // @Range: 0.05 1.0
    // @Increment: 0.05
    // @User: Advanced
    // @Units: rad
    AP_GROUPINFO("YAW_M_NSE", 37, NavEKF2, _yawNoise, 0.5f),

    // @Param: YAW_I_GATE
    // @DisplayName: Yaw measurement gate size
    // @Description: This sets the percentage number of standard deviations applied to the magnetometer yaw measurement innovation consistency check. Decreasing it makes it more likely that good measurements will be rejected. Increasing it makes it more likely that bad measurements will be accepted.
    // @Range: 100 1000
    // @Increment: 25
    // @User: Advanced
    AP_GROUPINFO("YAW_I_GATE", 38, NavEKF2, _yawInnovGate, 300),

    // @Param: TAU_OUTPUT
    // @DisplayName: Output complementary filter time constant (centi-sec)
    // @Description: Sets the time constant of the output complementary filter/predictor in centi-seconds.
    // @Range: 10 50
    // @Increment: 5
    // @User: Advanced
    // @Units: cs
    AP_GROUPINFO("TAU_OUTPUT", 39, NavEKF2, _tauVelPosOutput, 25),

    // @Param: MAGE_P_NSE
    // @DisplayName: Earth magnetic field process noise (gauss/s)
    // @Description: This state process noise controls the growth of earth magnetic field state error estimates. Increasing it makes earth magnetic field estimation faster and noisier.
    // @Range: 0.00001 0.01
    // @User: Advanced
    // @Units: Gauss/s
    AP_GROUPINFO("MAGE_P_NSE", 40, NavEKF2, _magEarthProcessNoise, MAGE_P_NSE_DEFAULT),

    // @Param: MAGB_P_NSE
    // @DisplayName: Body magnetic field process noise (gauss/s)
    // @Description: This state process noise controls the growth of body magnetic field state error estimates. Increasing it makes magnetometer bias error estimation faster and noisier.
    // @Range: 0.00001 0.01
    // @User: Advanced
    // @Units: Gauss/s
    AP_GROUPINFO("MAGB_P_NSE", 41, NavEKF2, _magBodyProcessNoise, MAGB_P_NSE_DEFAULT),

    // @Param: RNG_USE_HGT
    // @DisplayName: Range finder switch height percentage
    // @Description: Range finder can be used as the primary height source when below this percentage of its maximum range (see RNGFND_MAX_CM). This will not work unless Baro or GPS height is selected as the primary height source vis EK2_ALT_SOURCE = 0 or 2 respectively.  This feature should not be used for terrain following as it is designed  for vertical takeoff and landing with climb above  the range finder use height before commencing the mission, and with horizontal position changes below that height being limited to a flat region around the takeoff and landing point.
    // @Range: -1 70
    // @Increment: 1
    // @User: Advanced
    // @Units: %
    AP_GROUPINFO("RNG_USE_HGT", 42, NavEKF2, _useRngSwHgt, -1),

    // @Param: TERR_GRAD
    // @DisplayName: Maximum terrain gradient
    // @Description: Specifies the maximum gradient of the terrain below the vehicle assumed when it is fusing range finder or optical flow to estimate terrain height.
    // @Range: 0 0.2
    // @Increment: 0.01
    // @User: Advanced
    AP_GROUPINFO("TERR_GRAD", 43, NavEKF2, _terrGradMax, 0.1f),

    // @Param: BCN_M_NSE
    // @DisplayName: Range beacon measurement noise (m)
    // @Description: This is the RMS value of noise in the range beacon measurement. Increasing it reduces the weighting on this measurement.
    // @Range: 0.1 10.0
    // @Increment: 0.1
    // @User: Advanced
    // @Units: m
    AP_GROUPINFO("BCN_M_NSE", 44, NavEKF2, _rngBcnNoise, 1.0f),

    // @Param: BCN_I_GTE
    // @DisplayName: Range beacon measurement gate size
    // @Description: This sets the percentage number of standard deviations applied to the range beacon measurement innovation consistency check. Decreasing it makes it more likely that good measurements will be rejected. Increasing it makes it more likely that bad measurements will be accepted.
    // @Range: 100 1000
    // @Increment: 25
    // @User: Advanced
    AP_GROUPINFO("BCN_I_GTE", 45, NavEKF2, _rngBcnInnovGate, 500),

    // @Param: BCN_DELAY
    // @DisplayName: Range beacon measurement delay (msec)
    // @Description: This is the number of msec that the range beacon measurements lag behind the inertial measurements. It is the time from the end of the optical flow averaging period and does not include the time delay due to the 100msec of averaging within the flow sensor.
    // @Range: 0 127
    // @Increment: 10
    // @User: Advanced
    // @Units: ms
    // @RebootRequired: True
    AP_GROUPINFO("BCN_DELAY", 46, NavEKF2, _rngBcnDelay_ms, 50),

    // @Param: RNG_USE_SPD
    // @DisplayName: Range finder max ground speed
    // @Description: The range finder will not be used as the primary height source when the horizontal ground speed is greater than this value.
    // @Range: 2.0 6.0
    // @Increment: 0.5
    // @User: Advanced
    // @Units: m/s
    AP_GROUPINFO("RNG_USE_SPD", 47, NavEKF2, _useRngSwSpd, 2.0f),

    // @Param: MAG_MASK
    // @DisplayName: Bitmask of active EKF cores that will always use heading fusion
    // @Description: 1 byte bitmap of EKF cores that will disable magnetic field states and use simple magnetic heading fusion at all times. This parameter enables specified cores to be used as a backup for flight into an environment with high levels of external magnetic interference which may degrade the EKF attitude estimate when using 3-axis magnetometer fusion. NOTE : Use of a different magnetometer fusion algorithm on different cores makes unwanted EKF core switches due to magnetometer errors more likely.
    // @Bitmask: 0:FirstEKF,1:SecondEKF,2:ThirdEKF,3:FourthEKF,4:FifthEKF,5:SixthEKF
    // @User: Advanced
    // @RebootRequired: True
    AP_GROUPINFO("MAG_MASK", 48, NavEKF2, _magMask, 0),

    // @Param: OGN_HGT_MASK
    // @DisplayName: Bitmask control of EKF reference height correction
    // @Description: When a height sensor other than GPS is used as the primary height source by the EKF, the position of the zero height datum is defined by that sensor and its frame of reference. If a GPS height measurement is also available, then the height of the WGS-84 height datum used by the EKF can be corrected so that the height returned by the getLLH() function is compensated for primary height sensor drift and change in datum over time. The first two bit positions control when the height datum will be corrected. Correction is performed using a Bayes filter and only operates when GPS quality permits. The third bit position controls where the corrections to the GPS reference datum are applied. Corrections can be applied to the local vertical position or to the reported EKF origin height (default).
    // @Bitmask: 0:Correct when using Baro height,1:Correct when using range finder height,2:Apply corrections to local position
    // @User: Advanced
    // @RebootRequired: True
    AP_GROUPINFO("OGN_HGT_MASK", 49, NavEKF2, _originHgtMode, 0),

    // EXTNAV_DELAY was 50

    // @Param: FLOW_USE
    // @DisplayName: Optical flow use bitmask
    // @Description: Controls if the optical flow data is fused into the 24-state navigation estimator OR the 1-state terrain height estimator.
    // @User: Advanced
    // @Values: 0:None,1:Navigation,2:Terrain
    // @RebootRequired: True
    AP_GROUPINFO("FLOW_USE", 51, NavEKF2, _flowUse, FLOW_USE_DEFAULT),

    // @Param: MAG_EF_LIM
    // @DisplayName: EarthField error limit
    // @Description: This limits the difference between the learned earth magnetic field and the earth field from the world magnetic model tables. A value of zero means to disable the use of the WMM tables.
    // @User: Advanced
    // @Range: 0 500
    // @Units: mGauss
    AP_GROUPINFO("MAG_EF_LIM", 52, NavEKF2, _mag_ef_limit, 50),
    
    // @Param: HRT_FILT
    // @DisplayName: Height rate filter crossover frequency
    // @Description: Specifies the crossover frequency of the complementary filter used to calculate the output predictor height rate derivative.
    // @Range: 0.1 30.0
    // @Units: Hz
    AP_GROUPINFO("HRT_FILT", 53, NavEKF2, _hrt_filt_freq, 2.0f),

    // @Param: GSF_RUN_MASK
    // @DisplayName: Bitmask of which EKF-GSF yaw estimators run
    // @Description: A bitmask of which EKF2 instances run an independant EKF-GSF yaw estimator to provide a backup yaw estimate that doesn't rely on magnetometer data. This estimator uses IMU, GPS and, if available, airspeed data. EKF-GSF yaw estimator data for the primary EKF2 instance will be logged as GSF0 and GSF1 messages. Use of the yaw estimate generated by this algorithm is controlled by the EK2_GSF_USE_MASK and EK2_GSF_RST_MAX parameters. To run the EKF-GSF yaw estimator in ride-along and logging only, set EK2_GSF_USE_MASK to 0. 
    // @Bitmask: 0:FirstEKF,1:SecondEKF,2:ThirdEKF,3:FourthEKF,4:FifthEKF,5:SixthEKF
    // @User: Advanced
    // @RebootRequired: True
    AP_GROUPINFO("GSF_RUN_MASK", 54, NavEKF2, _gsfRunMask, 3),

    // @Param: GSF_USE_MASK
    // @DisplayName: Bitmask of which EKF-GSF yaw estimators are used
    // @Description: 1 byte bitmap of which EKF2 instances will use the output from the EKF-GSF yaw estimator that has been turned on by the EK2_GSF_RUN_MASK parameter. If the inertial navigation calculation stops following the GPS, then the vehicle code can request EKF2 to attempt to resolve the issue, either by performing a yaw reset if enabled by this parameter by switching to another EKF2 instance.
    // @Bitmask: 0:FirstEKF,1:SecondEKF,2:ThirdEKF,3:FourthEKF,4:FifthEKF,5:SixthEKF
    // @User: Advanced
    // @RebootRequired: True
    AP_GROUPINFO("GSF_USE_MASK", 55, NavEKF2, _gsfUseMask, 3),

    // 56 was GSF_DELAY which was never released in a stable version

    // @Param: GSF_RST_MAX
    // @DisplayName: Maximum number of resets to the EKF-GSF yaw estimate allowed
    // @Description: Sets the maximum number of times the EKF2 will be allowed to reset its yaw to the estimate from the EKF-GSF yaw estimator. No resets will be allowed unless the use of the EKF-GSF yaw estimate is enabled via the EK2_GSF_USE_MASK parameter.
    // @Range: 1 10
    // @Increment: 1
    // @User: Advanced
    // @RebootRequired: True
    AP_GROUPINFO("GSF_RST_MAX", 57, NavEKF2, _gsfResetMaxCount, 2),

    // @Param: OPTIONS
    // @DisplayName: Optional EKF behaviour
    // @Description: optional EKF2 behaviour. Disabling external navigation prevents use of external vision data in the EKF2 solution
    // @Bitmask: 0:DisableExternalNavigation
    // @User: Advanced
    AP_GROUPINFO("OPTIONS",  58, NavEKF2, _options, 0),
    
    AP_GROUPEND
};

NavEKF2::NavEKF2()
{
    AP_Param::setup_object_defaults(this, var_info);
}


// Initialise the filter
bool NavEKF2::InitialiseFilter(void)
{
    AP::dal().start_frame(AP_DAL::FrameType::InitialiseFilterEKF2);

    // Return immediately if there is insufficient memory
    if (core_malloc_failed) {
        return false;
    }

    initFailure = InitFailures::UNKNOWN;
    if (_enable == 0) {
        if (AP::dal().get_ekf_type() == 2) {
            initFailure = InitFailures::NO_ENABLE;
        }
        return false;
    }
    const auto &ins = AP::dal().ins();

    imuSampleTime_us = AP::dal().micros64();

    // remember expected frame time
    const float loop_rate = ins.get_loop_rate_hz();
    if (!is_positive(loop_rate)) {
        return false;
    }
    _frameTimeUsec = 1e6 / loop_rate;

    // expected number of IMU frames per prediction
    _framesPerPrediction = uint8_t((EKF_TARGET_DT / (_frameTimeUsec * 1.0e-6) + 0.5));

    if (core == nullptr) {

        // don't allow more filters than IMUs
        uint8_t mask = (1U<<ins.get_accel_count())-1;
        _imuMask.set_and_default(_imuMask.get() & mask);
        
        // count IMUs from mask
        num_cores = __builtin_popcount(_imuMask);

        // abort if num_cores is zero
        if (num_cores == 0) {
            if (ins.get_accel_count() == 0) {
                initFailure = InitFailures::NO_IMUS;
            } else {
                initFailure = InitFailures::NO_MASK;
            }
            return false;
        }

        // check if there is enough memory to create the EKF cores
        if (AP::dal().available_memory() < sizeof(NavEKF2_core)*num_cores + 4096) {
            initFailure = InitFailures::NO_MEM;
            core_malloc_failed = true;
            num_cores = 0;
            GCS_SEND_TEXT(MAV_SEVERITY_CRITICAL, "NavEKF2: not enough memory available");
            return false;
        }

        // try to allocate from CCM RAM, fallback to Normal RAM if not available or full
        core = (NavEKF2_core*)AP::dal().malloc_type(sizeof(NavEKF2_core)*num_cores, AP_DAL::MEM_FAST);
        if (core == nullptr) {
            initFailure = InitFailures::NO_MEM;
            core_malloc_failed = true;
            num_cores = 0;
            GCS_SEND_TEXT(MAV_SEVERITY_CRITICAL, "NavEKF2: memory allocation failed");
            return false;
        }

        //Call Constructors on all cores
        for (uint8_t i = 0; i < num_cores; i++) {
            new (&core[i]) NavEKF2_core(this);
        }

        // set the IMU index for the cores
        num_cores = 0;
        for (uint8_t i=0; i<7; i++) {
            if (_imuMask & (1U<<i)) {
                if(!core[num_cores].setup_core(i, num_cores)) {
                    // if any core setup fails, free memory, zero the core pointer and abort
                    hal.util->free_type(core, sizeof(NavEKF2_core)*num_cores, AP_HAL::Util::MEM_FAST);
                    core = nullptr;
                    initFailure = InitFailures::NO_SETUP;
                    GCS_SEND_TEXT(MAV_SEVERITY_WARNING, "NavEKF2: core %d setup failed", num_cores);
                    return false;
                }
                num_cores++;
            }
        }

        // Set the primary initially to be the lowest index
        primary = 0;
    }

    // invalidate shared origin
    common_origin_valid = false;
    
    // initialise the cores. We return success only if all cores
    // initialise successfully
    bool ret = true;
    for (uint8_t i=0; i<num_cores; i++) {
        ret &= core[i].InitialiseFilterBootstrap();
    }

    // zero the structs used capture reset events
    memset(&yaw_reset_data, 0, sizeof(yaw_reset_data));
    memset((void *)&pos_reset_data, 0, sizeof(pos_reset_data));
    memset(&pos_down_reset_data, 0, sizeof(pos_down_reset_data));

    return ret;
}

/*
  return true if a new core index has a better score than the current
  core
 */
bool NavEKF2::coreBetterScore(uint8_t new_core, uint8_t current_core) const
{
    const NavEKF2_core &oldCore = core[current_core];
    const NavEKF2_core &newCore = core[new_core];
    if (!newCore.healthy()) {
        // never consider a new core that isn't healthy
        return false;
    }
    if (newCore.have_aligned_tilt() != oldCore.have_aligned_tilt()) {
        // tilt alignment is most critical, if one is tilt aligned and
        // the other isn't then use the tilt aligned lane
        return newCore.have_aligned_tilt();
    }
    if (newCore.have_aligned_yaw() != oldCore.have_aligned_yaw()) {
        // yaw alignment is next most critical, if one is yaw aligned
        // and the other isn't then use the yaw aligned lane
        return newCore.have_aligned_yaw();
    }
    // if both cores are aligned then look at error scores
    return newCore.errorScore() < oldCore.errorScore();
}

// Update Filter States - this should be called whenever new IMU data is available
void NavEKF2::UpdateFilter(void)
{
    AP::dal().start_frame(AP_DAL::FrameType::UpdateFilterEKF2);

    if (!core) {
        return;
    }

    imuSampleTime_us = AP::dal().micros64();
    
    bool statePredictEnabled[num_cores];
    for (uint8_t i=0; i<num_cores; i++) {
        // if we have not overrun by more than 3 IMU frames, and we
        // have already used more than 1/3 of the CPU budget for this
        // loop then suppress the prediction step. This allows
        // multiple EKF instances to cooperate on scheduling
        if (core[i].getFramesSincePredict() < (_framesPerPrediction+3) &&
            AP::dal().ekf_low_time_remaining(AP_DAL::EKFType::EKF2, i)) {
            statePredictEnabled[i] = false;
        } else {
            statePredictEnabled[i] = true;
        }
        core[i].UpdateFilter(statePredictEnabled[i]);
    }

    // If the current core selected has a bad error score or is unhealthy, switch to a healthy core with the lowest fault score
    // Don't start running the check until the primary core has started returned healthy for at least 10 seconds to avoid switching
    // due to initial alignment fluctuations and race conditions
    if (!runCoreSelection) {
        static uint64_t lastUnhealthyTime_us = 0;
        if (!core[primary].healthy() || lastUnhealthyTime_us == 0) {
            lastUnhealthyTime_us = imuSampleTime_us;
        }
        runCoreSelection = (imuSampleTime_us - lastUnhealthyTime_us) > 1E7;
    }
    float primaryErrorScore = core[primary].errorScore();
    if ((primaryErrorScore > 1.0f || !core[primary].healthy()) && runCoreSelection) {
        float lowestErrorScore = 0.67f * primaryErrorScore;
        uint8_t newPrimaryIndex = primary; // index for new primary
        for (uint8_t coreIndex=0; coreIndex<num_cores; coreIndex++) {

            if (coreIndex != primary) {
                // an alternative core is available for selection only if healthy and if states have been updated on this time step
                bool altCoreAvailable = statePredictEnabled[coreIndex] && coreBetterScore(coreIndex, newPrimaryIndex);

                // If the primary core is unhealthy and another core is available, then switch now
                // If the primary core is still healthy,then switching is optional and will only be done if
                // a core with a significantly lower error score can be found
                float altErrorScore = core[coreIndex].errorScore();
                if (altCoreAvailable && (!core[newPrimaryIndex].healthy() || altErrorScore < lowestErrorScore)) {
                    newPrimaryIndex = coreIndex;
                    lowestErrorScore = altErrorScore;
                }
            }
        }
        // update the yaw and position reset data to capture changes due to the lane switch
        if (newPrimaryIndex != primary) {
            updateLaneSwitchYawResetData(newPrimaryIndex, primary);
            updateLaneSwitchPosResetData(newPrimaryIndex, primary);
            updateLaneSwitchPosDownResetData(newPrimaryIndex, primary);
            primary = newPrimaryIndex;
            lastLaneSwitch_ms = AP::dal().millis();
        }
    }

    if (primary != 0 && core[0].healthy() && !AP::dal().get_armed()) {
        // when on the ground and disarmed force the first lane. This
        // avoids us ending with with a lottery for which IMU is used
        // in each flight. Otherwise the alignment of the timing of
        // the lane updates with the timing of GPS updates can lead to
        // a lane other than the first one being used as primary for
        // some flights. As different IMUs may have quite different
        // noise characteristics this leads to inconsistent
        // performance
        primary = 0;
    }
}

/*
  check if switching lanes will reduce the normalised
  innovations. This is called when the vehicle code is about to
  trigger an EKF failsafe, and it would like to avoid that by
  using a different EKF lane
*/
void NavEKF2::checkLaneSwitch(void)
{
    AP::dal().log_event2(AP_DAL::Event::checkLaneSwitch);
    const uint32_t now = AP::dal().millis();
    if (lastLaneSwitch_ms != 0 && now - lastLaneSwitch_ms < 5000) {
        // don't switch twice in 5 seconds
        return;
    }
    uint8_t newPrimaryIndex = primary;
    for (uint8_t coreIndex=0; coreIndex<num_cores; coreIndex++) {
        if (coreIndex != primary) {
            const NavEKF2_core &newCore = core[coreIndex];
            // an alternative core is available for selection only if healthy and if states have been updated on this time step
            bool altCoreAvailable = coreBetterScore(coreIndex, newPrimaryIndex);
            if (altCoreAvailable && newCore.errorScore() < 0.9) {
                newPrimaryIndex = coreIndex;
            }
        }
    }

    // update the yaw and position reset data to capture changes due to the lane switch
    if (newPrimaryIndex != primary) {
        updateLaneSwitchYawResetData(newPrimaryIndex, primary);
        updateLaneSwitchPosResetData(newPrimaryIndex, primary);
        updateLaneSwitchPosDownResetData(newPrimaryIndex, primary);
        primary = newPrimaryIndex;
        lastLaneSwitch_ms = now;
        GCS_SEND_TEXT(MAV_SEVERITY_CRITICAL, "NavEKF2: lane switch %u", primary);
    }
}

// Check basic filter health metrics and return a consolidated health status
bool NavEKF2::healthy(void) const
{
    if (!core) {
        return false;
    }
    return core[primary].healthy();
}

// returns false if we fail arming checks, in which case the buffer will be populated with a failure message
bool NavEKF2::pre_arm_check(char *failure_msg, uint8_t failure_msg_len) const
{
    if (!core) {
        AP::dal().snprintf(failure_msg, failure_msg_len, "no EKF2 cores");
        return false;
    }
    for (uint8_t i = 0; i < num_cores; i++) {
        if (!core[i].healthy()) {
            const char *failure = core[i].prearm_failure_reason();
            if (failure != nullptr) {
                AP::dal().snprintf(failure_msg, failure_msg_len, failure);
            } else {
                AP::dal().snprintf(failure_msg, failure_msg_len, "EKF2 core %d unhealthy", (int)i);
            }
            return false;
        }
    }
    return true;
}

// returns the index of the primary core
// return -1 if no primary core selected
int8_t NavEKF2::getPrimaryCoreIndex(void) const
{
    if (!core) {
        return -1;
    }
    return primary;
}

// returns the index of the IMU of the primary core
// return -1 if no primary core selected
int8_t NavEKF2::getPrimaryCoreIMUIndex(void) const
{
    if (!core) {
        return -1;
    }
    return core[primary].getIMUIndex();
}

// Write the last calculated NE position relative to the reference point (m).
// If a calculated solution is not available, use the best available data and return false
// If false returned, do not use for flight control
bool NavEKF2::getPosNE(Vector2f &posNE) const
{
    if (!core) {
        return false;
    }
    return core[primary].getPosNE(posNE);
}

// Write the last calculated D position relative to the reference point (m).
// If a calculated solution is not available, use the best available data and return false
// If false returned, do not use for flight control
bool NavEKF2::getPosD(float &posD) const
{
    if (!core) {
        return false;
    }
    return core[primary].getPosD(posD);
}

// return NED velocity in m/s
void NavEKF2::getVelNED(Vector3f &vel) const
{
    if (core) {
        core[primary].getVelNED(vel);
    }
}

// return estimate of true airspeed vector in body frame in m/s for the specified instance
// An out of range instance (eg -1) returns data for the primary instance
// returns false if estimate is unavailable
bool NavEKF2::getAirSpdVec(Vector3f &vel) const
{
    if (core) {
        return core[primary].getAirSpdVec(vel);
    }
    return false;
}

// Return the rate of change of vertical position in the down direction (dPosD/dt) in m/s
float NavEKF2::getPosDownDerivative() const
{
    // return the value calculated from a complementary filter applied to the EKF height and vertical acceleration
    if (core) {
        return core[primary].getPosDownDerivative();
    }
    return 0.0f;
}

// return body axis gyro bias estimates in rad/sec
void NavEKF2::getGyroBias(Vector3f &gyroBias) const
{
    if (core) {
        core[primary].getGyroBias(gyroBias);
    }
}

// reset body axis gyro bias estimates
void NavEKF2::resetGyroBias(void)
{
    AP::dal().log_event2(AP_DAL::Event::resetGyroBias);

    if (core) {
        for (uint8_t i=0; i<num_cores; i++) {
            core[i].resetGyroBias();
        }
    }
}

// Resets the baro so that it reads zero at the current height
// Resets the EKF height to zero
// Adjusts the EKf origin height so that the EKF height + origin height is the same as before
// Returns true if the height datum reset has been performed
// If using a range finder for height no reset is performed and it returns false
bool NavEKF2::resetHeightDatum(void)
{
    AP::dal().log_event2(AP_DAL::Event::resetHeightDatum);

    bool status = true;
    if (core) {
        for (uint8_t i=0; i<num_cores; i++) {
            if (!core[i].resetHeightDatum()) {
                status = false;
            }
        }
    } else {
        status = false;
    }
    return status;
}

// return the horizontal speed limit in m/s set by optical flow sensor limits
// return the scale factor to be applied to navigation velocity gains to compensate for increase in velocity noise with height when using optical flow
void NavEKF2::getEkfControlLimits(float &ekfGndSpdLimit, float &ekfNavVelGainScaler) const
{
    if (core) {
        core[primary].getEkfControlLimits(ekfGndSpdLimit, ekfNavVelGainScaler);
    } else {
        ekfGndSpdLimit = 400.0f; //return 80% of max filter speed
        ekfNavVelGainScaler = 1.0f;
    }
}

// return the individual Z-accel bias estimates in m/s^2
void NavEKF2::getAccelZBias(float &zbias) const
{
    if (core) {
        core[primary].getAccelZBias(zbias);
    }
}

// return the NED wind speed estimates in m/s (positive is air moving in the direction of the axis)
void NavEKF2::getWind(Vector3f &wind) const
{
    if (core) {
        core[primary].getWind(wind);
    }
}

// return earth magnetic field estimates in measurement units / 1000
void NavEKF2::getMagNED(Vector3f &magNED) const
{
    if (core) {
        core[primary].getMagNED(magNED);
    }
}

// return body magnetic field estimates in measurement units / 1000
void NavEKF2::getMagXYZ(Vector3f &magXYZ) const
{
    if (core) {
        core[primary].getMagXYZ(magXYZ);
    }
}

// Return estimated magnetometer offsets
// Return true if magnetometer offsets are valid
bool NavEKF2::getMagOffsets(uint8_t mag_idx, Vector3f &magOffsets) const
{
    if (!core) {
        return false;
    }
    // try the primary first, else loop through all of the cores and return when one has offsets for this mag instance
    if (core[primary].getMagOffsets(mag_idx, magOffsets)) {
        return true;
    }
    for (uint8_t i=0; i<num_cores; i++) {
        if(core[i].getMagOffsets(mag_idx, magOffsets)) {
            return true;
        }
    }
    return false;
}

// Return the last calculated latitude, longitude and height in WGS-84
// If a calculated location isn't available, return a raw GPS measurement
// The status will return true if a calculation or raw measurement is available
// The getFilterStatus() function provides a more detailed description of data health and must be checked if data is to be used for flight control
bool NavEKF2::getLLH(Location &loc) const
{
    if (!core) {
        return false;
    }
    return core[primary].getLLH(loc);
}

// Return the latitude and longitude and height used to set the NED origin for the specified instance
// An out of range instance (eg -1) returns data for the primary instance
// All NED positions calculated by the filter are relative to this location
// Returns false if the origin has not been set
bool NavEKF2::getOriginLLH(Location &loc) const
{
    if (!core) {
        return false;
    }
    return core[primary].getOriginLLH(loc);
}

// set the latitude and longitude and height used to set the NED origin
// All NED positions calculated by the filter will be relative to this location
// The origin cannot be set if the filter is in a flight mode (eg vehicle armed)
// Returns false if the filter has rejected the attempt to set the origin
bool NavEKF2::setOriginLLH(const Location &loc)
{
    AP::dal().log_SetOriginLLH2(loc);

    if (!core) {
        return false;
    }
    if (_fusionModeGPS != 3 || common_origin_valid) {
        // we don't allow setting of the EKF origin if using GPS
        // or if the EKF origin has already been set.
        // This is to prevent accidental setting of EKF origin with an
        // invalid position or height or causing upsets from a shifting origin.
        GCS_SEND_TEXT(MAV_SEVERITY_WARNING, "EKF2 refusing set origin");
        return false;
    }
    bool ret = false;
    for (uint8_t i=0; i<num_cores; i++) {
        ret |= core[i].setOriginLLH(loc);
    }
    // return true if any core accepts the new origin
    return ret;
}

// return estimated height above ground level
// return false if ground height is not being estimated.
bool NavEKF2::getHAGL(float &HAGL) const
{
    if (!core) {
        return false;
    }
    return core[primary].getHAGL(HAGL);
}

// return the Euler roll, pitch and yaw angle in radians for the specified instance
void NavEKF2::getEulerAngles(Vector3f &eulers) const
{
    if (core) {
        core[primary].getEulerAngles(eulers);
    }
}

// return the transformation matrix from XYZ (body) to NED axes
void NavEKF2::getRotationBodyToNED(Matrix3f &mat) const
{
    if (core) {
        core[primary].getRotationBodyToNED(mat);
    }
}

// return the quaternions defining the rotation from NED to XYZ (body) axes
void NavEKF2::getQuaternionBodyToNED(int8_t instance, Quaternion &quat) const
{
    if (instance < 0 || instance >= num_cores) instance = primary;
    if (core) {
        Matrix3f mat;
        core[instance].getRotationBodyToNED(mat);
        quat.from_rotation_matrix(mat);
    }
}

// return the quaternions defining the rotation from NED to XYZ (autopilot) axes
void NavEKF2::getQuaternion(Quaternion &quat) const
{
    if (core) {
        core[primary].getQuaternion(quat);
    }
}

// return the innovations for the specified instance
bool NavEKF2::getInnovations(Vector3f &velInnov, Vector3f &posInnov, Vector3f &magInnov, float &tasInnov, float &yawInnov) const
{
    if (core == nullptr) {
        return false;
    }

    return core[primary].getInnovations(velInnov, posInnov, magInnov, tasInnov, yawInnov);
}

// return the innovation consistency test ratios for the velocity, position, magnetometer and true airspeed measurements
bool NavEKF2::getVariances(float &velVar, float &posVar, float &hgtVar, Vector3f &magVar, float &tasVar, Vector2f &offset) const
{
    if (core == nullptr) {
        return false;
    }

    return core[primary].getVariances(velVar, posVar, hgtVar, magVar, tasVar, offset);
}

// should we use the compass? This is public so it can be used for
// reporting via ahrs.use_compass()
bool NavEKF2::use_compass(void) const
{
    if (!core) {
        return false;
    }
    return core[primary].use_compass();
}

// write the raw optical flow measurements
// rawFlowQuality is a measured of quality between 0 and 255, with 255 being the best quality
// rawFlowRates are the optical flow rates in rad/sec about the X and Y sensor axes.
// rawGyroRates are the sensor rotation rates in rad/sec measured by the sensors internal gyro
// The sign convention is that a RH physical rotation of the sensor about an axis produces both a positive flow and gyro rate
// msecFlowMeas is the scheduler time in msec when the optical flow data was received from the sensor.
// posOffset is the XYZ flow sensor position in the body frame in m
// heightOverride is the fixed height of the sensor above ground in m, when on rover vehicles. 0 if not used
void NavEKF2::writeOptFlowMeas(const uint8_t rawFlowQuality, const Vector2f &rawFlowRates, const Vector2f &rawGyroRates, const uint32_t msecFlowMeas, const Vector3f &posOffset, float heightOverride)
{
    AP::dal().writeOptFlowMeas(rawFlowQuality, rawFlowRates, rawGyroRates, msecFlowMeas, posOffset, heightOverride);

    if (core) {
        for (uint8_t i=0; i<num_cores; i++) {
            core[i].writeOptFlowMeas(rawFlowQuality, rawFlowRates, rawGyroRates, msecFlowMeas, posOffset, heightOverride);
        }
    }
}

// Set to true if the terrain underneath is stable enough to be used as a height reference
// in combination with a range finder. Set to false if the terrain underneath the vehicle
// cannot be used as a height reference. Use to prevent range finder operation otherwise
// enabled by the combination of EK2_RNG_AID_HGT and EK2_RNG_USE_SPD parameters.
void NavEKF2::setTerrainHgtStable(bool val)
{
    if (val) {
        AP::dal().log_event2(AP_DAL::Event::setTerrainHgtStable);
    } else {
        AP::dal().log_event2(AP_DAL::Event::unsetTerrainHgtStable);
    }
    if (core) {
        for (uint8_t i=0; i<num_cores; i++) {
            core[i].setTerrainHgtStable(val);
        }
    }

}

/*
  return the filter fault status as a bitmasked integer
  0 = quaternions are NaN
  1 = velocities are NaN
  2 = badly conditioned X magnetometer fusion
  3 = badly conditioned Y magnetometer fusion
  4 = badly conditioned Z magnetometer fusion
  5 = badly conditioned airspeed fusion
  6 = badly conditioned synthetic sideslip fusion
  7 = filter is not initialised
*/
void NavEKF2::getFilterFaults(uint16_t &faults) const
{
    if (core) {
        core[primary].getFilterFaults(faults);
    } else {
        faults = 0;
    }
}

/*
  return filter status flags
*/
void NavEKF2::getFilterStatus(nav_filter_status &status) const
{
    if (core) {
        core[primary].getFilterStatus(status);
    } else {
        memset(&status, 0, sizeof(status));
    }
}

/*
return filter gps quality check status
*/
void  NavEKF2::getFilterGpsStatus(nav_gps_status &status) const
{
    if (core) {
        core[primary].getFilterGpsStatus(status);
    } else {
        memset(&status, 0, sizeof(status));
    }
}

// send an EKF_STATUS_REPORT message to GCS
void NavEKF2::send_status_report(GCS_MAVLINK &link) const
{
    if (core) {
        core[primary].send_status_report(link);
    }
}

// provides the height limit to be observed by the control loops
// returns false if no height limiting is required
// this is needed to ensure the vehicle does not fly too high when using optical flow navigation
bool NavEKF2::getHeightControlLimit(float &height) const
{
    if (!core) {
        return false;
    }
    return core[primary].getHeightControlLimit(height);
}

// Returns the amount of yaw angle change (in radians) due to the last yaw angle reset or core selection switch
// Returns the time of the last yaw angle reset or 0 if no reset or core switch has ever occurred
// Where there are multiple consumers, they must access this function on the same frame as each other
uint32_t NavEKF2::getLastYawResetAngle(float &yawAngDelta)
{
    if (!core) {
        return 0;
    }

    yawAngDelta = 0.0f;

    // Do the conversion to msec in one place
    uint32_t now_time_ms = imuSampleTime_us / 1000;

    // The last time we switched to the current primary core is the first reset event
    uint32_t lastYawReset_ms = yaw_reset_data.last_primary_change;

    // There has been a change notification in the primary core that the controller has not consumed
    // or this is a repeated access
    if (yaw_reset_data.core_changed || yaw_reset_data.last_function_call == now_time_ms) {
        yawAngDelta = yaw_reset_data.core_delta;
        yaw_reset_data.core_changed = false;
    }

    // Record last time controller got the yaw reset
    yaw_reset_data.last_function_call = now_time_ms;

    // There has been a reset inside the core since we switched so update the time and delta
    float temp_yawAng;
    uint32_t lastCoreYawReset_ms = core[primary].getLastYawResetAngle(temp_yawAng);
    if (lastCoreYawReset_ms > lastYawReset_ms) {
        yawAngDelta = wrap_PI(yawAngDelta + temp_yawAng);
        lastYawReset_ms = lastCoreYawReset_ms;
    }

    return lastYawReset_ms;
}

// Returns the amount of NE position change due to the last position reset or core switch in metres
// Returns the time of the last reset or 0 if no reset or core switch has ever occurred
// Where there are multiple consumers, they must access this function on the same frame as each other
uint32_t NavEKF2::getLastPosNorthEastReset(Vector2f &posDelta)
{
    if (!core) {
        return 0;
    }

    posDelta.zero();

    // Do the conversion to msec in one place
    uint32_t now_time_ms = imuSampleTime_us / 1000;

    // The last time we switched to the current primary core is the first reset event
    uint32_t lastPosReset_ms = pos_reset_data.last_primary_change;

    // There has been a change in the primary core that the controller has not consumed
    // allow for multiple consumers on the same frame
    if (pos_reset_data.core_changed || pos_reset_data.last_function_call == now_time_ms) {
        posDelta = pos_reset_data.core_delta;
        pos_reset_data.core_changed = false;
    }

    // Record last time controller got the position reset
    pos_reset_data.last_function_call = now_time_ms;

    // There has been a reset inside the core since we switched so update the time and delta
    Vector2f tempPosDelta;
    uint32_t lastCorePosReset_ms = core[primary].getLastPosNorthEastReset(tempPosDelta);
    if (lastCorePosReset_ms > lastPosReset_ms) {
        posDelta = posDelta + tempPosDelta;
        lastPosReset_ms = lastCorePosReset_ms;
    }

    return lastPosReset_ms;
}

// return the amount of NE velocity change due to the last velocity reset in metres/sec
// returns the time of the last reset or 0 if no reset has ever occurred
uint32_t NavEKF2::getLastVelNorthEastReset(Vector2f &vel) const
{
    if (!core) {
        return 0;
    }
    return core[primary].getLastVelNorthEastReset(vel);
}

// Returns the amount of vertical position change due to the last reset or core switch in metres
// Returns the time of the last reset or 0 if no reset or core switch has ever occurred
// Where there are multiple consumers, they must access this function on the same frame as each other
uint32_t NavEKF2::getLastPosDownReset(float &posDelta)
{
    if (!core) {
        return 0;
    }

    posDelta = 0.0f;

    // Do the conversion to msec in one place
    uint32_t now_time_ms = imuSampleTime_us / 1000;

    // The last time we switched to the current primary core is the first reset event
    uint32_t lastPosReset_ms = pos_down_reset_data.last_primary_change;

    // There has been a change in the primary core that the controller has not consumed
    // allow for multiple consumers on the same frame
    if (pos_down_reset_data.core_changed || pos_down_reset_data.last_function_call == now_time_ms) {
        posDelta = pos_down_reset_data.core_delta;
        pos_down_reset_data.core_changed = false;
    }

    // Record last time controller got the position reset
    pos_down_reset_data.last_function_call = now_time_ms;

    // There has been a reset inside the core since we switched so update the time and delta
    float tempPosDelta;
    uint32_t lastCorePosReset_ms = core[primary].getLastPosDownReset(tempPosDelta);
    if (lastCorePosReset_ms > lastPosReset_ms) {
        posDelta += tempPosDelta;
        lastPosReset_ms = lastCorePosReset_ms;
    }

    return lastPosReset_ms;
}

// update the yaw reset data to capture changes due to a lane switch
void NavEKF2::updateLaneSwitchYawResetData(uint8_t new_primary, uint8_t old_primary)
{
    Vector3f eulers_old_primary, eulers_new_primary;
    float old_yaw_delta;

    // If core yaw reset data has been consumed reset delta to zero
    if (!yaw_reset_data.core_changed) {
        yaw_reset_data.core_delta = 0;
    }

    // If current primary has reset yaw after controller got it, add it to the delta
    if (core[old_primary].getLastYawResetAngle(old_yaw_delta) > yaw_reset_data.last_function_call) {
        yaw_reset_data.core_delta += old_yaw_delta;
    }

    // Record the yaw delta between current core and new primary core and the timestamp of the core change
    // Add current delta in case it hasn't been consumed yet
    core[old_primary].getEulerAngles(eulers_old_primary);
    core[new_primary].getEulerAngles(eulers_new_primary);
    yaw_reset_data.core_delta = wrap_PI(eulers_new_primary.z - eulers_old_primary.z + yaw_reset_data.core_delta);
    yaw_reset_data.last_primary_change = imuSampleTime_us / 1000;
    yaw_reset_data.core_changed = true;

}

// update the position reset data to capture changes due to a lane switch
void NavEKF2::updateLaneSwitchPosResetData(uint8_t new_primary, uint8_t old_primary)
{
    Vector2f pos_old_primary, pos_new_primary, old_pos_delta;

    // If core position reset data has been consumed reset delta to zero
    if (!pos_reset_data.core_changed) {
        pos_reset_data.core_delta.zero();
    }

    // If current primary has reset position after controller got it, add it to the delta
    if (core[old_primary].getLastPosNorthEastReset(old_pos_delta) > pos_reset_data.last_function_call) {
        pos_reset_data.core_delta += old_pos_delta;
    }

    // Record the position delta between current core and new primary core and the timestamp of the core change
    // Add current delta in case it hasn't been consumed yet
    core[old_primary].getPosNE(pos_old_primary);
    core[new_primary].getPosNE(pos_new_primary);
    pos_reset_data.core_delta = pos_new_primary - pos_old_primary + pos_reset_data.core_delta;
    pos_reset_data.last_primary_change = imuSampleTime_us / 1000;
    pos_reset_data.core_changed = true;

}

// Update the vertical position reset data to capture changes due to a core switch
// This should be called after the decision to switch cores has been made, but before the
// new primary EKF update has been run
void NavEKF2::updateLaneSwitchPosDownResetData(uint8_t new_primary, uint8_t old_primary)
{
    float posDownOldPrimary, posDownNewPrimary, oldPosDownDelta;

    // If core position reset data has been consumed reset delta to zero
   #include <AP_HAL/AP_HAL_Boards.h>
#include <AP_SerialManager/AP_SerialManager_config.h>

#if defined(AP_NETWORKING_BACKEND_PPP) && !defined(AP_NETWORKING_ENABLED)
// allow --enable-ppp to enable networking
#define AP_NETWORKING_ENABLED AP_NETWORKING_BACKEND_PPP
#endif


#ifndef AP_NETWORKING_ENABLED
#if !defined(__APPLE__) && defined(__clang__)
// clang fails on linux
#define AP_NETWORKING_ENABLED 0
#else
#define AP_NETWORKING_ENABLED ((CONFIG_HAL_BOARD == HAL_BOARD_LINUX) || (CONFIG_HAL_BOARD == HAL_BOARD_SITL))
#endif
#endif

#ifndef AP_NETWORKING_BACKEND_DEFAULT_ENABLED
#define AP_NETWORKING_BACKEND_DEFAULT_ENABLED AP_NETWORKING_ENABLED
#endif

// ---------------------------
// Backends
// ---------------------------
#ifndef AP_NETWORKING_BACKEND_CHIBIOS
#ifndef HAL_USE_MAC
#define HAL_USE_MAC 0
#endif
#define AP_NETWORKING_BACKEND_CHIBIOS (AP_NETWORKING_BACKEND_DEFAULT_ENABLED && (CONFIG_HAL_BOARD == HAL_BOARD_CHIBIOS) && HAL_USE_MAC)
#endif

#ifndef AP_NETWORKING_BACKEND_PPP
#define AP_NETWORKING_BACKEND_PPP 0
#endif

#ifndef AP_NETWORKING_BACKEND_SITL
#define AP_NETWORKING_BACKEND_SITL (AP_NETWORKING_BACKEND_DEFAULT_ENABLED && (CONFIG_HAL_BOARD == HAL_BOARD_SITL))
#endif

#ifndef AP_NETWORKING_SOCKETS_ENABLED
#define AP_NETWORKING_SOCKETS_ENABLED AP_NETWORKING_ENABLED
#endif

#ifndef AP_NETWORKING_CONTROLS_HOST_IP_SETTINGS_ENABLED
// AP_NETWORKING_CONTROLS_HOST_IP_SETTINGS_ENABLED should only be true if we have the ability to
// change the IP address. If not then the IP, GW, NetMask, MAC and DHCP params are hidden. 
// This does not mean that the system/OS does not have the ability to set the IP, just that
// we have no control from this scope. For example, Linux systems (including SITL) have
// their own DHCP client running but we have no control over it.
#define AP_NETWORKING_CONTROLS_HOST_IP_SETTINGS_ENABLED AP_NETWORKING_BACKEND_CHIBIOS
#endif

#define AP_NETWORKING_NEED_LWIP (AP_NETWORKING_BACKEND_CHIBIOS || AP_NETWORKING_BACKEND_PPP)

// ---------------------------
// IP Features
// ---------------------------
#ifndef AP_NETWORKING_DHCP_AVAILABLE
// AP_NETWORKING_DHCP_AVAILABLE should only be true if, by setting the NET_DHCP parameter,
// we have the ability to turn on/off the DHCP client which effects the assigned IP address.
// Otherwise, param NET_DHCP will be hidden. This does not mean that the system/OS does not
// have DHCP, just that we have no control from this scope. For example, Linux systems
// (including SITL) have their own DHCP client running but we have no control over it.
#define AP_NETWORKING_DHCP_AVAILABLE (AP_NETWORKING_CONTROLS_HOST_IP_SETTINGS_ENABLED || AP_NETWORKING_BACKEND_CHIBIOS)
#endif


// ---------------------------
// Below are default params
// ---------------------------

// Default DHCP
#ifndef AP_NETWORKING_DEFAULT_DHCP_ENABLE
#define AP_NETWORKING_DEFAULT_DHCP_ENABLE AP_NETWORKING_DHCP_AVAILABLE
#endif

// Default Static IP Address: 192.168.13.14
#ifndef AP_NETWORKING_DEFAULT_STATIC_IP_ADDR
#define AP_NETWORKING_DEFAULT_STATIC_IP_ADDR "192.168.13.14"
#endif

// Default Netmask: 24
// Note, the netmask is the number of consecutive bits
#ifndef AP_NETWORKING_DEFAULT_NETMASK
#define AP_NETWORKING_DEFAULT_NETMASK       24 // 255.255.255.0 (for 10.0.xxx.xxx or 172.xxx.xxx.xxx type networks)
// #define AP_NETWORKING_DEFAULT_NETMASK    16 // 255.255.0.0 (for 192.168.xxx.xxxx type networks)
#endif


// Default Static IP Address: 192.168.13.1
#ifndef AP_NETWORKING_DEFAULT_STATIC_GW_ADDR
#define AP_NETWORKING_DEFAULT_STATIC_GW_ADDR "192.168.13.1"
#endif

// Default MAC Address: C2:AF:51:03:CF:46
// Note, lower 3 bytes (ADDR3,4,5) will be replaced with the platform UUID
#ifndef AP_NETWORKING_DEFAULT_MAC_ADDR
#define AP_NETWORKING_DEFAULT_MAC_ADDR "C2:AF:51:03:CF:46"
#endif

#ifndef AP_NETWORKING_TESTS_ENABLED
#define AP_NETWORKING_TESTS_ENABLED 0
#endif

#if AP_NETWORKING_TESTS_ENABLED
#ifndef AP_NETWORKING_TEST_IP
#define AP_NETWORKING_TEST_IP "192.168.13.2"
#endif
#endif

#ifndef AP_NETWORKING_NUM_PORTS
#define AP_NETWORKING_NUM_PORTS 4
#endif

#ifndef AP_NETWORKING_NUM_SENDFILES
#define AP_NETWORKING_NUM_SENDFILES 20
#endif

#ifndef AP_NETWORKING_SENDFILE_BUFSIZE
#define AP_NETWORKING_SENDFILE_BUFSIZE (64*512)
#endif

#ifndef AP_NETWORKING_PPP_GATEWAY_ENABLED
#define AP_NETWORKING_PPP_GATEWAY_ENABLED (AP_NETWORKING_BACKEND_CHIBIOS && AP_NETWORKING_BACKEND_PPP)
#endif

/*
  the IP address given to the remote end of the PPP link when running
  as a PPP<->ethernet gateway. If this is on the same subnet as the
  ethernet interface IP then proxyarp will be used
 */
#ifndef AP_NETWORKING_REMOTE_PPP_IP
#define AP_NETWORKING_REMOTE_PPP_IP "0.0.0.0"
#endif

#ifndef AP_NETWORKING_REGISTER_PORT_ENABLED
#define AP_NETWORKING_REGISTER_PORT_ENABLED AP_NETWORKING_ENABLED && AP_SERIALMANAGER_REGISTER_ENABLED
#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    
#include "AP_Networking_Config.h"

#if AP_NETWORKING_BACKEND_PPP

#include "AP_Networking_PPP.h"
#include <GCS_MAVLink/GCS.h>

#include <lwip/udp.h>
#include <lwip/ip_addr.h>
#include <netif/ppp/ppp_opts.h>
#include <netif/ppp/pppapi.h>
#include <netif/ppp/pppos.h>
#include <lwip/tcpip.h>
#include <stdio.h>


extern const AP_HAL::HAL& hal;

#if LWIP_TCPIP_CORE_LOCKING
#define LWIP_TCPIP_LOCK() sys_lock_tcpip_core()
#define LWIP_TCPIP_UNLOCK() sys_unlock_tcpip_core()
#else
#define LWIP_TCPIP_LOCK()
#define LWIP_TCPIP_UNLOCK()
#endif

#define PPP_DEBUG_TX 0
#define PPP_DEBUG_RX 0

/*
  output some data to the uart
 */
uint32_t AP_Networking_PPP::ppp_output_cb(ppp_pcb *pcb, const void *data, uint32_t len, void *ctx)
{
    auto &driver = *(AP_Networking_PPP *)ctx;
    LWIP_UNUSED_ARG(pcb);
    uint32_t remaining = len;
    const uint8_t *ptr = (const uint8_t *)data;
#if PPP_DEBUG_TX
    bool flag_end = false;
    if (ptr[len-1] == 0x7E) {
        flag_end = true;
        remaining--;
    }
    if (ptr[0] == 0x7E) {
        // send byte size
        if (pkt_size > 0) {
            printf("PPP: tx[%lu] %u\n", tx_index++,  pkt_size);
        }
        // dump the packet
        if (!(tx_index % 10)) {
            for (uint32_t i = 0; i < pkt_size; i++) {
                printf(" %02X", tx_bytes[i]);
            }
            printf("\n");
        }
        pkt_size = 0;
    }
#endif
    while (remaining > 0) {
        const auto n = driver.uart->write(ptr, remaining);
        if (n > 0) {
            remaining -= n;
            ptr += n;
        } else {
            hal.scheduler->delay_microseconds(100);
        }
    }
#if PPP_DEBUG_TX
    memcpy(&tx_bytes[pkt_size], data, len);
    pkt_size += len;
    if (flag_end) {
        driver.uart->write(0x7E);
        printf("PPP: tx[%lu] %u\n", tx_index++,  pkt_size);
        // dump the packet
        if (!(tx_index % 10)) {
            for (uint32_t i = 0; i < pkt_size; i++) {
                printf(" %02X", tx_bytes[i]);
            }
            printf("\n");
        }
        pkt_size = 0;
    }
#endif
    return len;
}

/*
  callback on link status change
 */
void AP_Networking_PPP::ppp_status_callback(struct ppp_pcb_s *pcb, int code, void *ctx)
{
    auto &driver = *(AP_Networking_PPP *)ctx;
    struct netif *pppif = ppp_netif(pcb);

    switch (code) {
    case PPPERR_NONE:
        // got new addresses for the link
#if AP_NETWORKING_PPP_GATEWAY_ENABLED
        if (driver.frontend.option_is_set(AP_Networking::OPTION::PPP_ETHERNET_GATEWAY)) {
            GCS_SEND_TEXT(MAV_SEVERITY_INFO, "PPP: got addresses");
        } else
#endif
        {
            driver.activeSettings.ip = ntohl(netif_ip4_addr(pppif)->addr);
            driver.activeSettings.gw = ntohl(netif_ip4_gw(pppif)->addr);
            driver.activeSettings.nm = ntohl(netif_ip4_netmask(pppif)->addr);
            driver.activeSettings.last_change_ms = AP_HAL::millis();
        }
        break;

    case PPPERR_OPEN:
    case PPPERR_CONNECT:
    case PPPERR_PEERDEAD:
    case PPPERR_IDLETIMEOUT:
    case PPPERR_CONNECTTIME:
        driver.need_restart = true;
        break;

    default:
        GCS_SEND_TEXT(MAV_SEVERITY_INFO, "PPP: error %d", code);
        break;
    }
}


/*
  initialise PPP network backend using LWIP
 */
bool AP_Networking_PPP::init()
{
    auto &sm = AP::serialmanager();
    uart = sm.find_serial(AP_SerialManager::SerialProtocol_PPP, 0);
    if (uart == nullptr) {
        return false;
    }

    pppif = NEW_NOTHROW netif;
    if (pppif == nullptr) {
        return false;
    }

    const bool ethernet_gateway = frontend.option_is_set(AP_Networking::OPTION::PPP_ETHERNET_GATEWAY);
    if (!ethernet_gateway) {
        // initialise TCP/IP thread
        LWIP_TCPIP_LOCK();
        tcpip_init(NULL, NULL);
        LWIP_TCPIP_UNLOCK();
    }

    hal.scheduler->delay(100);
    
    // create ppp connection
    LWIP_TCPIP_LOCK();

    ppp = pppos_create(pppif, ppp_output_cb, ppp_status_callback, this);
    if (ppp == nullptr) {
        GCS_SEND_TEXT(MAV_SEVERITY_INFO, "PPP: failed to create link");
        return false;
    }
    LWIP_TCPIP_UNLOCK();

    GCS_SEND_TEXT(MAV_SEVERITY_INFO, "PPP: started");
    hal.scheduler->thread_create(FUNCTOR_BIND_MEMBER(&AP_Networking_PPP::ppp_loop, void),
                                 "ppp",
                                 2048, AP_HAL::Scheduler::PRIORITY_NET, 0);

    return true;
}

/*
  main loop for PPP
 */
void AP_Networking_PPP::ppp_loop(void)
{
    while (!hal.scheduler->is_system_initialized()) {
        hal.scheduler->delay_microseconds(1000);
    }
    const bool ppp_gateway = frontend.option_is_set(AP_Networking::OPTION::PPP_ETHERNET_GATEWAY);
    if (ppp_gateway) {
        // wait for the ethernet interface to be up
        AP::network().startup_wait();
    }

    // ensure this thread owns the uart
    uart->begin(AP::serialmanager().find_baudrate(AP_SerialManager::SerialProtocol_PPP, 0));
    uart->set_unbuffered_writes(true);

    while (true) {
        uint8_t buf[1024];

        // connect and set as default route
        LWIP_TCPIP_LOCK();

#if AP_NETWORKING_PPP_GATEWAY_ENABLED
        if (ppp_gateway) {
            /*
              when bridging setup the ppp interface with the same IP
              as the ethernet interface, and set the remote IP address
              as the local address + 1
             */
            ip4_addr_t our_ip, his_ip;
            const uint32_t ip = frontend.get_ip_active();
            uint32_t rem_ip = frontend.param.remote_ppp_ip.get_uint32();
            if (rem_ip == 0) {
                // use ethernet IP +1 by default
                rem_ip = ip+1;
            }
            our_ip.addr = htonl(ip);
            his_ip.addr = htonl(rem_ip);
            ppp_set_ipcp_ouraddr(ppp, &our_ip);
            ppp_set_ipcp_hisaddr(ppp, &his_ip);
            if (netif_list != nullptr) {
                const uint32_t nmask = frontend.get_netmask_param();
                if ((ip & nmask) == (rem_ip & nmask)) {
                    // remote PPP IP is on the same subnet as the
                    // local ethernet IP, so enable proxyarp to avoid
                    // users having to setup routes in all devices
                    netif_set_proxyarp(netif_list, &his_ip);
                }
            }
        }

        // connect to the remote end
        ppp_connect(ppp, 0);

        if (ppp_gateway) {
            extern struct netif *netif_list;
            /*
              when we are setup as a PPP gateway we want the pppif to be
              first in the list so routing works if it is on the same
              subnet
            */
            if (netif_list != nullptr &&
                netif_list->next != nullptr &&
                netif_list->next->next == pppif) {
                netif_list->next->next = nullptr;
                pppif->next = netif_list;
                netif_list = pppif;
            }
        } else {
            netif_set_default(pppif);
        }
#else
        // normal PPP link, connect to the remote end and set as the
        // default route
        ppp_connect(ppp, 0);
        netif_set_default(pppif);
#endif // AP_NETWORKING_PPP_GATEWAY_ENABLED

        LWIP_TCPIP_UNLOCK();

        need_restart = false;

        GCS_SEND_TEXT(MAV_SEVERITY_INFO, "PPP: connected");

        while (!need_restart) {
            auto n = uart->read(buf, sizeof(buf));
            if (n > 0) {
                LWIP_TCPIP_LOCK();
                pppos_input(ppp, buf, n);
                LWIP_TCPIP_UNLOCK();
            } else {
                hal.scheduler->delay_microseconds(200);
            }
#if PPP_DEBUG_RX
            auto pppos = (pppos_pcb *)ppp->link_ctx_cb;
            for (uint32_t i = 0; i < n; i++) {
                if (buf[i] == 0x7E && last_ppp_frame_size != 1) {
                    // dump the packet
                    if (pppos->bad_pkt) {
                        printf("PPP: rx[%lu] %u\n", rx_index, last_ppp_frame_size);
                        for (uint32_t j = 0; j < last_ppp_frame_size; j++) {
                            printf("0x%02X,", rx_bytes[j]);
                        }
                        printf("\n");
                        hal.scheduler->delay(1);
                    }
                    rx_index++;
                    last_ppp_frame_size = 0;
                }
                rx_bytes[last_ppp_frame_size++] = buf[i];
            }
#endif
        }
    }
}

#endif // AP_NETWORKING_BACKEND_PPP
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    #pragma once

#include "AP_Networking_Config.h"

#ifdef AP_NETWORKING_BACKEND_PPP
#include "AP_Networking_Backend.h"

class AP_Networking_PPP : public AP_Networking_Backend
{
public:
    using AP_Networking_Backend::AP_Networking_Backend;

    /* Do not allow copies */
    CLASS_NO_COPY(AP_Networking_PPP);

    bool init() override;

private:
    void ppp_loop(void);

    AP_HAL::UARTDriver *uart;
    struct netif *pppif;
    struct ppp_pcb_s *ppp;
    bool need_restart;

    static void ppp_status_callback(struct ppp_pcb_s *pcb, int code, void *ctx);
    static uint32_t ppp_output_cb(struct ppp_pcb_s *pcb, const void *data, uint32_t len, void *ctx);
};

#endif // AP_NETWORKING_BACKEND_PPP
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     #pragma once

#include "AP_OpticalFlow_config.h"

#if AP_OPTICALFLOW_HEREFLOW_ENABLED

#include "AP_OpticalFlow_Backend.h"
#include <AP_DroneCAN/AP_DroneCAN.h>

class AP_OpticalFlow_HereFlow : public OpticalFlow_backend {
public:
    AP_OpticalFlow_HereFlow(AP_OpticalFlow &flow);

    void init() override {}

    void update() override;

    static void subscribe_msgs(AP_DroneCAN* ap_dronecan);

    static void handle_measurement(AP_DroneCAN *ap_dronecan, const CanardRxTransfer& transfer, const com_hex_equipment_flow_Measurement &msg);

private:

    Vector2f flow_integral, rate_gyro_integral;
    uint8_t surface_quality;
    float integral_time;
    bool new_data;
    static uint8_t _node_id;

    static AP_OpticalFlow_HereFlow* _driver;
    static AP_DroneCAN* _ap_dronecan;
    void _push_state(void);

};

#endif  // AP_OPTICALFLOW_HEREFLOW_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 /*
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include "AP_OpticalFlow_MAV.h"

#if AP_OPTICALFLOW_MAV_ENABLED

#include <AP_HAL/AP_HAL.h>
#include <AP_AHRS/AP_AHRS.h>

#define OPTFLOW_MAV_TIMEOUT_SEC 0.5f

// detect the device
AP_OpticalFlow_MAV *AP_OpticalFlow_MAV::detect(AP_OpticalFlow &_frontend)
{
    // we assume mavlink messages will be sent into this driver
    AP_OpticalFlow_MAV *sensor = NEW_NOTHROW AP_OpticalFlow_MAV(_frontend);
    return sensor;
}

// read latest values from sensor and fill in x,y and totals.
void AP_OpticalFlow_MAV::update(void)
{
    // record gyro values as long as they are being used
    // the sanity check of dt below ensures old gyro values are not used
    if (gyro_sum_count < 1000) {
        const Vector3f& gyro = AP::ahrs().get_gyro();
        gyro_sum.x += gyro.x;
        gyro_sum.y += gyro.y;
        gyro_sum_count++;
    }

    // return without updating state if no readings
    if (count == 0) {
        return;
    }

    struct AP_OpticalFlow::OpticalFlow_state state {};

    state.surface_quality = quality_sum / count;

    // calculate dt
    const float dt = (latest_frame_us - prev_frame_us) * 1.0e-6;
    prev_frame_us = latest_frame_us;

    // sanity check dt
    if (is_positive(dt) && (dt < OPTFLOW_MAV_TIMEOUT_SEC)) {
        // calculate flow values
        const float flow_scale_factor_x = 1.0f + 0.001f * _flowScaler().x;
        const float flow_scale_factor_y = 1.0f + 0.001f * _flowScaler().y;

        // copy flow rates to state structure
        state.flowRate = { ((float)flow_sum.x / count) * flow_scale_factor_x * dt,
                           ((float)flow_sum.y / count) * flow_scale_factor_y * dt };

        // copy average body rate to state structure
        state.bodyRate = { gyro_sum.x / gyro_sum_count, gyro_sum.y / gyro_sum_count };

        // we only apply yaw to flowRate as body rate comes from AHRS
        _applyYaw(state.flowRate);
    } else {
        // first frame received in some time so cannot calculate flow values
        state.flowRate.zero();
        state.bodyRate.zero();
    }

    _update_frontend(state);

    // reset local buffers
    flow_sum.zero();
    quality_sum = 0;
    count = 0;

    // reset gyro sum
    gyro_sum.zero();
    gyro_sum_count = 0;
}

// handle OPTICAL_FLOW mavlink messages
void AP_OpticalFlow_MAV::handle_msg(const mavlink_message_t &msg)
{
    mavlink_optical_flow_t packet;
    mavlink_msg_optical_flow_decode(&msg, &packet);

    // record time message was received
    // ToDo: add jitter correction
    latest_frame_us = AP_HAL::micros64();

    // add sensor values to sum
    flow_sum.x += packet.flow_x;
    flow_sum.y += packet.flow_y;
    quality_sum += packet.quality;
    count++;

    // take sensor id from message
    sensor_id = packet.sensor_id;
}

#endif  // AP_OPTICALFLOW_MAV_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     fi channel 1,2,3,4,5 (2457..2472MHz)
    62,10,67,72,63,68,11,64, 69,60,65,70,12,61,66,71, // Wifi channel 6
    10,67,11,72,12,68,13,69, 14,65,15,70,16,66,17,71, // Wifi channel 7
    10,70,15,20,14,71,16,21, 12,17,22,72,13,18,11,19, // Wifi channel 8
    10,15,20,25,11,16,21,12, 17,22,13,18,23,14,19,24, // Wifi channel 9,10,11
    46,41,31,52,36,13,72,69, 21,56,16,26,61,66,10,43, // Test mode channels
    46,41,31,52,36,13,72,69, 21,56,16,26,61,66,10,43, // Reserved
    // Alternative frequencies
    17,11,63,19,67,44,43,38, 50,54,70,58,29,35,25,14, // Normal
    18,10,23,21,33,44,41,38, 52,45,47,25,30,35,49,14, // Wifi channel 1,2,3,4,5
    18,56,23,21,33,44,41,38, 52,45,47,25,30,35,49,14, // Wifi channel 6
    18,56,23,21,33,44,41,38, 52,45,47,25,30,35,49,61, // Wifi channel 7
    68,56,24,53,33,44,41,38, 28,45,47,65,30,35,49,61, // Wifi channel 8
    68,56,72,53,33,44,41,38, 28,45,47,65,30,35,49,61, // Wifi channel 9,10,11
    46,41,31,52,36,13,72,69, 21,56,16,26,61,66,10,43, // Test mode channels (as normal)
    46,41,31,52,36,13,72,69, 21,56,16,26,61,66,10,43, // Reserved (as normal)
#endif
};

void AP_Radio_beken::nextChannel(uint8_t skip)
{
    if (skip) {
        syncch.NextChannel();
    }
    setChannel(bindHopData[syncch.channel]);
}

/*
  save bind info
 */
void AP_Radio_beken::save_bind_info(void)
{
    // access to storage for bind information
    StorageAccess bind_storage(StorageManager::StorageBindInfo);
    struct bind_info info;

    info.magic = bind_magic;
    info.bindTxId[0] = beken.TX_Address[0];
    info.bindTxId[1] = beken.TX_Address[1];
    info.bindTxId[2] = beken.TX_Address[2];
    info.bindTxId[3] = beken.TX_Address[3];
    info.bindTxId[4] = beken.TX_Address[4];
    bind_storage.write_block(0, &info, sizeof(info));
}

/*
  load bind info
 */
bool AP_Radio_beken::load_bind_info(void)
{
    // access to storage for bind information
    StorageAccess bind_storage(StorageManager::StorageBindInfo);
    struct bind_info info;

    if (!bind_storage.read_block(&info, 0, sizeof(info)) || info.magic != bind_magic) {
        return false;
    }

    beken.SetAddresses(&info.bindTxId[0]);

    return true;
}

// ----------------------------------------------------------------------------
void AP_Radio_beken::BadDroneId(void)
{
    if (stats.recv_packets >= 1000) { // We are already chatting to this TX for some time.
        return; // Do not disconnect from it.
    }

    // clear the current bind information
    valid_connection = false;
    // with luck we will connect to another tx
    beken.SwitchToIdleMode();
    beken.SetFactoryMode(0); // Reset the tx address
    adaptive.Invalidate();
    syncch.SetHopping(0,0);
    already_bound = false; // Not already solidly bound to a drone
    stats.recv_packets = 0;
    beken.WriteReg(BK_WRITE_REG|BK_EN_RXADDR, 0x02);
    have_tx_pps = false;
}

// ----------------------------------------------------------------------------
// Which bits correspond to each channel within a table, for adaptive frequencies
static const uint8_t channel_bit_table[CHANNEL_COUNT_LOGICAL] = {
    0x01, 0, 0x02, 0, 0x04, 0, 0x08, 0,
    0x10, 0, 0x20, 0, 0x40, 0, 0x80, 0
};

// Step through the channels
void SyncChannel::NextChannel(void)
{
    channel &= 0x7f;
    if (channel >= CHANNEL_COUNT_LOGICAL*CHANNEL_NUM_TABLES) {
        // We are in the factory test modes. Keep the channel as is.
    } else {
        if (countdown != countdown_invalid) {
            if (--countdown == 0) {
                channel = countdown_chan;
                countdown = countdown_invalid;
                hopping_current = hopping_wanted = 0;
                return;
            }
        } else if (hopping_countdown != countdown_invalid) {
            if (--hopping_countdown == 0) {
                hopping_current = hopping_wanted;
                hopping_countdown = countdown_invalid;
                //              printf("{Use %d} ", hopping_current);
            }
        }
        uint8_t table = channel / CHANNEL_COUNT_LOGICAL;
        channel = (channel + 1) % CHANNEL_COUNT_LOGICAL;
        channel += table * CHANNEL_COUNT_LOGICAL;
        // Support adaptive frequency hopping
        if (hopping_current & channel_bit_table[channel % CHANNEL_COUNT_LOGICAL]) {
            channel |= 0x80;
        }
    }
}

// If we have not received any packets for ages, try a WiFi table that covers all frequencies
void SyncChannel::SafeTable(void)
{
    channel &= 0x7f;
    if (channel >= CHANNEL_COUNT_LOGICAL*CHANNEL_NUM_TABLES) {
        // We are in the factory test modes. Reset to default table.
        channel = 0;
    } else {
        uint8_t table = channel / CHANNEL_COUNT_LOGICAL;
        if ((table != CHANNEL_BASE_TABLE) && (table != CHANNEL_SAFE_TABLE)) { // Are we using a table that is high end or low end only?
            channel %= CHANNEL_COUNT_LOGICAL;
            channel += CHANNEL_SAFE_TABLE * CHANNEL_COUNT_LOGICAL;
        }
    }
}

// Check if valid channel index; we have received a packet describing the current channel index
void SyncChannel::SetChannelIfSafe(uint8_t chan)
{
    if (channel != chan) {
        DebugPrintf(2, "{{%d}} ", chan);
    }
    chan &= 0x7f; // Disregard hopping
    if (chan >= CHANNEL_COUNT_LOGICAL*CHANNEL_NUM_TABLES) {
        if (chan == lastchan) {
            channel = chan; // Allow test mode channels if two in a row
        } else {
            chan = 0; // Disallow test mode tables unless followed by each other
        }
        lastchan = chan;
    } else {
        lastchan = 0;
    }
    channel = chan;
}

// We have received a packet on this channel
void SyncAdaptive::Get(uint8_t channel)
{
    uint8_t f = bindHopData[channel];
    rx[f]++;
}

enum { ADAPT_THRESHOLD = 50 }; // Missed packets threshold for adapting the hopping

// We have missed a packet on this channel. Consider adapting.
void SyncAdaptive::Miss(uint8_t channel)
{
    uint8_t f1 = bindHopData[channel];
    missed[f1]++;
    uint8_t f2 = bindHopData[channel ^ 0x80];
    int32_t delta1 = missed[f1] - rx[f1];
    int32_t delta2 = missed[f2] - rx[f2];
    if ((delta1 > ADAPT_THRESHOLD) && // Worse than 50% reception on this channel
        (delta1 > delta2)) {
        // Ok consider swapping this channel
        uint8_t bit = channel_bit_table[channel % CHANNEL_COUNT_LOGICAL];
        if (bit) { // Is an even packet
            uint8_t oh = hopping;
            if (channel & 0x80) { // Swap back from alternative
                hopping &= ~bit;
            } else { // Swap to alternative
                hopping |= bit;
            }
            if (hopping != oh) { // Have we changed?
                missed[f2] = rx[f2] = 0; // Reset the values
                //              printf("{%d->%d:%d} ", f1+2400, f2+2400, hopping);
            }
        }
    }
}

#endif // AP_RADIO_BK2425_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        /*
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
#pragma once

/*
  AP_Radio implementation for CC2500 2.4GHz radio.

  With thanks to cleanflight and betaflight projects
 */

#include "AP_Radio_config.h"

#if AP_RADIO_BK2425_ENABLED

#include "AP_Radio_backend.h"

#include "hal.h"
#include "telem_structure.h"
#include "driver_bk2425.h"

#define BEKEN_MAX_CHANNELS 16
// Documentation of the expected RSSI values. These are determined by the Cypress chip.
enum {
    BK_RSSI_MIN = 0, // Minimum value for RSSI
    BK_RSSI_DEFAULT = 16, // The default value for RSSI for chips that do not support it.
    BK_RSSI_MAX = 31 // Maximum value for RSSI
};

// This helper struct estimates the times (in microseconds) between packets,
// according to the STM32 clock which may well be 2% different from the STM8 clock.
// For instance it may be 5108 instead of the nominal 5000 microseconds.
struct SyncTiming {
    enum { TARGET_DELTA_RX = 5000,               // Nominal 5ms between packets is expected
           SLOP_DELTA_RX = TARGET_DELTA_RX / 10,    // +/- 500us i.e. 10% skew each way is accepted.
           DIFF_DELTA_RX = TARGET_DELTA_RX / 100
         }; // Two consequetive deltas must be very close together (50us)
    uint32_t packet_timer; // Time we last received a valid control packet
    uint32_t rx_time_us; // Time we last received a packet
    uint32_t tx_time_us; // Time we last finished transmitting a packet
    uint32_t delta_rx_time_us; // Time between last rx packets
    uint32_t last_delta_rx_time_us; // previous version of the delta
    uint32_t sync_time_us; // Estimate of base time in microseconds between packets. 5000 +/- 500
    SyncTiming() : // Constructor to setup sensible initial conditions
        delta_rx_time_us(TARGET_DELTA_RX),
        last_delta_rx_time_us(TARGET_DELTA_RX),
        sync_time_us(TARGET_DELTA_RX)
    {}
    void Rx(uint32_t when); // Adjust the timing based on a new packet
};

// Helper struct for synchronising channels when we change hopping table (e.g. learn of a WiFi channel change).
struct SyncChannel {
    enum { countdown_invalid = 0 }; // When countdown is this value, no change is pending
    uint8_t channel; // Index within the channel hopping sequence. Corresponds to txChannel on the button board
    uint8_t lastchan; // Last requested index, if it is a factory test channel.
    uint8_t countdown; // How many packet slots until a pending table change occurs?
    uint8_t countdown_chan; // Which channel do we jump to when the table change happens?
    uint8_t hopping_current; // Which alternative channels are we on now
    uint8_t hopping_wanted; //  Which alternative channels will we be on when Tx changes over?
    uint8_t hopping_countdown; // How many packet slots until a pending table change occurs?
    SyncChannel() : // Constructor to setup sensible initial conditions
        channel(0),
        lastchan(0),
        countdown(countdown_invalid),
        countdown_chan(0),
        hopping_current(0),
        hopping_wanted(0),
        hopping_countdown(countdown_invalid)
    {}
    void SetChannelIfSafe(uint8_t chan); // Check if valid channel index; we have received a packet describing the current channel index
    void SetChannel(uint8_t chan) // Already safe. We have received a packet describing the current channel index
    {
        channel = chan;
    }
    void SetCountdown(uint8_t cnt, uint8_t nextCh) // We receive a countdown to a non-normal channel change in the future
    {
        countdown = cnt;
        countdown_chan = nextCh;
    }
    void SetHopping(uint8_t cnt, uint8_t nextHopping) // We receive a countdown to a change in the adaptive table in the future/now
    {
        hopping_countdown = cnt;
        hopping_wanted = nextHopping;
        if (cnt == 0) {
            hopping_current = nextHopping;
        }
    }
    void NextChannel(void); // Step through the channels normally (taking countdowns into account)
    void SafeTable(void); // Give up on this WiFi table as packets have not been received
};

// This helper struct determines which physical channels are better
struct SyncAdaptive {
    uint32_t missed[CHANNEL_FCC_HIGH+1]; // Missed
    uint32_t rx[CHANNEL_FCC_HIGH+1]; // Received
    uint8_t hopping; // Currently wanted hopping state. Send this to the tx.
    SyncAdaptive() : // Constructor to setup sensible initial conditions
        hopping(0)
    {}
    void Miss(uint8_t channel);
    void Get(uint8_t channel);
    void Invalidate()
    {
        hopping = 0;    // e.g. if we have jumped tables
    }
};

// Support OTA upload. Assumes that mavlink offsets go from zero upwards contiguously
struct FwUpload {
    enum { SZ_BUFFER = 128 }; // Must be a power of two
    mavlink_channel_t chan; // Reference for talking to mavlink subsystem
    uint8_t counter; // Used to throttle the upload, to prevent starvation of telemetry
    enum telem_type fw_type; // Whether we are uploading program code or a test tune

    // Data that is reset by reset()
    bool need_ack; // When true, we need to talk to mavlink subsystem (ask for more firmware)
    uint32_t added;  // The number of bytes added to the queue
    uint32_t sent;   // The number of bytes sent to the tx
    uint32_t acked;  // The number of bytes acked by the tx
    bool rx_ack;     // True each time we receive a non-zero ack from the tx
    bool rx_reboot;  // True when we are in the rebooting process
    uint8_t pending_data[SZ_BUFFER]; // Pending data (from mavlink packets) circular buffer
    uint8_t pending_head; // Where mavlink packets are added (relative to pending_data[0])
    uint8_t pending_tail; // Where DFU packets are taken from (relative to pending_data[0])
    uint16_t file_length; // The length of the file, six more than the value stored in the first 16 bit word
    uint16_t file_length_round; // file_length rounded up to 0x80

    // Helper functions
    uint8_t pending_length()
    {
        return (pending_head - pending_tail) & (SZ_BUFFER-1);
    }
    uint8_t free_length()
    {
        return SZ_BUFFER - 1 - pending_length();    // Do not fill in the last byte in the circular buffer
    }
    void queue(const uint8_t *pSrc, uint8_t len); // Assumes sufficient room has been checked for
    void dequeue(uint8_t *pDst, uint8_t len); // Assumes sufficient data has been checked for
    void reset()
    {
        file_length = file_length_round = 0;
        added = sent = acked = 0;
        pending_head = pending_tail = 0;
        rx_reboot = rx_ack = need_ack = false;
    }
};

// Main class for receiving (and replying) to Beken radio packets
class AP_Radio_beken : public AP_Radio_backend
{
public:
    // Override base class functions
    AP_Radio_beken(AP_Radio &radio); // Normal constructore
    bool init(void) override; // initialise the radio
    bool reset(void) override; // reset the radio
    bool send(const uint8_t *pkt, uint16_t len) override; // send a packet
    void start_recv_bind(void) override; // start bind process as a receiver
    uint32_t last_recv_us(void) override; // return time in microseconds of last received R/C packet
    uint8_t num_channels(void) override; // return number of input channels
    uint16_t read(uint8_t chan) override; // return current "PWM" (value) of a channel
    void handle_data_packet(mavlink_channel_t chan, const mavlink_data96_t &m) override; // handle a data96 mavlink packet for fw upload
    void update(void) override; // update status

    uint32_t get_tx_version(void) override   // get TX fw version
    {
        // pack date into 16 bits for vendor_id in AUTOPILOT_VERSION
        return (uint16_t(tx_date.firmware_year)<<12) + (uint16_t(tx_date.firmware_month)<<8) + tx_date.firmware_day;
    }
    const AP_Radio::stats &get_stats(void) override; // get radio statistics structure

    // Extra public functions
    void set_wifi_channel(uint8_t channel) override
    {
        t_status.wifi_chan = channel;    // set the 2.4GHz wifi channel used by companion computer, so it can be avoided
    }

private:
    // Static functions, for interrupt support
    static void irq_handler_thd(void* arg);
    static void trigger_irq_radio_event(void);
    static void trigger_timeout_event(virtual_timer_t* vt, void *arg);

    //  Private functions
    void radio_init(void);
    uint8_t ProcessPacket(const uint8_t* packet, uint8_t rxaddr);
    uint8_t ProcessBindPacket(const packetFormatRx * rx);
    void BadDroneId(void); // The tx we are listening to wants to talk to another drone
    void setChannel(uint8_t channel);
    void nextChannel(uint8_t skip);
    uint16_t calc_crc(uint8_t *data, uint8_t len);
    void irq_handler(uint32_t when);
    void irq_timeout(uint32_t when);
    void save_bind_info(void);
    bool load_bind_info(void);
    void UpdateFccScan(void);
    bool UpdateTxData(void);
    void map_stick_mode(void); // Support mode1,2,3,4 for stick mapping
    void update_SRT_telemetry(void);
    void check_fw_ack(void);

    // Static data, for interrupt support
    friend class SyncChannel; // For DebugPrintf support
    static AP_Radio_beken *radio_singleton; // Singleton pointer to the Beken radio instance
    static thread_t *_irq_handler_ctx;
    static virtual_timer_t timeout_vt;
    static uint32_t isr_irq_time_us; // Time the Beken IRQ was last triggered, in the handler interrupts (in microseconds)
    static uint32_t isr_timeout_time_us; // Time the timeout was last triggered (copied from irq_time_us via irq_when_us) (in microseconds)
    static uint32_t next_switch_us; // Time when we next want to switch radio channels (in microseconds)
    static uint32_t bind_time_ms; // Rough time in ms (milliseconds) when the last BIND command was received

    // Class data
    AP_HAL::OwnPtr<AP_HAL::SPIDevice> dev; // Low level support of SPI device
    HAL_Semaphore sem;  // semaphore between ISR and main thread to protect fwupload

    AP_Radio::stats stats; // Radio stats (live) for the current time-period
    AP_Radio::stats last_stats; // Radio stats (snapshot) for the previous time-period
    uint16_t pwm_channels[BEKEN_MAX_CHANNELS]; // Channel data
    uint8_t chan_count; // Number of valid channels

    Radio_Beken beken; // The low level class for communicating to the Beken chip
    SyncChannel syncch; // Index within the channel hopping sequence. Corresponds to txChannel on the button board
    static SyncTiming synctm; // Timing between packets, according to the local clock (not the tx clock).
    uint32_t already_bound; // True when we have received packets from a tx after bootup. Prevent auto-binding to something else.
    FwUpload fwupload; // Support OTA upload
    SyncAdaptive adaptive; // Support adaptive hopping
    struct {
        uint8_t firmware_year;
        uint8_t firmware_month;
        uint8_t firmware_day;
    } tx_date;

    // Bind structure saved to storage
    static const uint16_t bind_magic = 0x120a;
    struct PACKED bind_info {
        uint16_t magic;
        uint8_t bindTxId[5]; // The transmission address I last used
    };

    // Received
    struct telem_status t_status; // Keep track of certain data that can be sent as telemetry to the tx.
    uint32_t last_pps_ms; // Timestamp of the last PPS (packets per second) calculation, in milliseconds.
    uint32_t tx_pps; // Last telemetry PPS received from Tx
    uint32_t have_tx_pps; // 0=never received, 1=received at least one, 2=received recently
    uint32_t valid_connection; // Take some time before admitting to ardupilot we have a connection
    uint32_t telem_send_count; // How many telemetry packets have i sent?

    // Parameters
    ITX_SPEED spd; // Speed of radio modulation.
    uint8_t myDroneId[4]; // CRC of the flight boards UUID, to inform the tx
};

#endif // AP_RADIO_BK2425_ENABLED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                /*
  driver for TI CC2500 radio

  Many thanks to the cleanflight and betaflight projects
 */
#include "AP_Radio_config.h"

#if AP_RADIO_CC2500_ENABLED

#include <AP_HAL/AP_HAL.h>

// #pragma GCC optimize("O0")

#include <AP_Math/AP_Math.h>
#include "AP_Radio_cc2500.h"
#include <utility>
#include <stdio.h>
#include <StorageManager/StorageManager.h>
#include <AP_Notify/AP_Notify.h>
#include <GCS_MAVLink/GCS.h>
#include <AP_Math/crc.h>
#include <AP_Param/AP_Param.h>

#if CONFIG_HAL_BOARD == HAL_BOARD_CHIBIOS
#define TIMEOUT_PRIORITY 185
#define EVT_TIMEOUT EVENT_MASK(0)
#define EVT_IRQ EVENT_MASK(1)
#define EVT_BIND EVENT_MASK(2)
#endif

extern const AP_HAL::HAL& hal;

#define Debug(level, fmt, args...)   do { if ((level) <= get_debug_level()) { GCS_SEND_TEXT(MAV_SEVERITY_INFO, fmt, ##args); }} while (0)

// object instance for trampoline
AP_Radio_cc2500 *AP_Radio_cc2500::radio_singleton;
#if CONFIG_HAL_BOARD == HAL_BOARD_CHIBIOS
thread_t *AP_Radio_cc2500::_irq_handler_ctx;
virtual_timer_t AP_Radio_cc2500::timeout_vt;
uint32_t AP_Radio_cc2500::irq_time_us;
#endif

#define USE_D16_FORMAT 0

/*
  we are setup for a channel spacing of 0.3MHz, with channel 0 being 2403.6MHz

  For D16 protocol we select 47 channels from a max of 235 channels

  For SRT protocol we select 23 channels from a max of 235 channels,
  and avoid channels near to the WiFi channel of the Sonix video board
 */
#if USE_D16_FORMAT
#define NUM_CHANNELS 47
#define MAX_CHANNEL_NUMBER 0xEB
#define INTER_PACKET_MS 9
#define INTER_PACKET_INITIAL_MS (INTER_PACKET_MS+2)
#define PACKET_SENT_DELAY_US 3300
#else
#define NUM_CHANNELS 23
#define MAX_CHANNEL_NUMBER 0xEB
#define INTER_PACKET_MS 9
#define INTER_PACKET_INITIAL_MS (INTER_PACKET_MS+5)
#define PACKET_SENT_DELAY_US 2800
#endif

#define SEARCH_START_PKTS 40
#define AUTOBIND_CHANNEL 100

/*
  constructor
 */
AP_Radio_cc2500::AP_Radio_cc2500(AP_Radio &_radio) :
    AP_Radio_backend(_radio),
    cc2500(hal.spi->get_device("cc2500"))
{
    // link to instance for irq_trampoline
    radio_singleton = this;
}

/*
  initialise radio
 */
bool AP_Radio_cc2500::init(void)
{
#if CONFIG_HAL_BOARD == HAL_BOARD_CHIBIOS
    if (_irq_handler_ctx != nullptr) {
        AP_HAL::panic("AP_Radio_cc2500: double instantiation of irq_handler\n");
    }
    chVTObjectInit(&timeout_vt);
    _irq_handler_ctx = chThdCreateFromHeap(NULL,
                                           THD_WORKING_AREA_SIZE(2048),
                                           "radio_cc2500",
                                           TIMEOUT_PRIORITY,
                                           irq_handler_thd,
                                           NULL);
#endif

    return reset();
}

/*
  reset radio
 */
bool AP_Radio_cc2500::reset(void)
{
    if (!cc2500.lock_bus()) {
        return false;
    }

    radio_init();
    cc2500.unlock_bus();

    return true;
}

/*
  return statistics structure from radio
 */
const AP_Radio::stats &AP_Radio_cc2500::get_stats(void)
{
    return stats;
}

/*
  read one pwm channel from radio
 */
uint16_t AP_Radio_cc2500::read(uint8_t chan)
{
    if (chan >= CC2500_MAX_PWM_CHANNELS) {
        return 0;
    }
    return pwm_channels[chan];
}

/*
  update status - called from main thread
 */
void AP_Radio_cc2500::update(void)
{
    check_fw_ack();
}


/*
  return number of active channels
 */
uint8_t AP_Radio_cc2500::num_channels(void)
{
    uint32_t now = AP_HAL::millis();
    uint8_t chan = get_rssi_chan();
    if (chan > 0) {
        pwm_channels[chan-1] = t_status.rssi;
        chan_count = MAX(chan_count, chan);
    }

    chan = get_pps_chan();
    if (chan > 0) {
        pwm_channels[chan-1] = t_status.pps;
        chan_count = MAX(chan_count, chan);
    }

    chan = get_tx_rssi_chan();
    if (chan > 0) {
        pwm_channels[chan-1] = tx_rssi;
        chan_count = MAX(chan_count, chan);
    }

    chan = get_tx_pps_chan();
    if (chan > 0) {
        pwm_channels[chan-1] = tx_pps;
        chan_count = MAX(chan_count, chan);
    }
    pwm_channels[11] = (stats.recv_packets % 1000);
    chan_count = MAX(chan_count, 12);

    if (now - last_pps_ms > 1000) {
        last_pps_ms = now;
        t_status.pps = stats.recv_packets - last_stats.recv_packets;
        last_stats = stats;
        if (lost != 0 || timeouts != 0) {
            Debug(timeouts!=0?2:3,"lost=%u timeouts=%u TS=%u\n",
                  unsigned(lost), unsigned(timeouts), sizeof(struct telem_packet_cc2500));
        }
        lost=0;
        timeouts=0;
    }
    return chan_count;
}

/*
  return time of last receive in microseconds
 */
uint32_t AP_Radio_cc2500::last_recv_us(void)
{
    return packet_timer;
}

/*
  send len bytes as a single packet
 */
bool AP_Radio_cc2500::send(const uint8_t *pkt, uint16_t len)
{
    // disabled for now
    return false;
}

const AP_Radio_cc2500::config AP_Radio_cc2500::radio_config_GFSK[] = {
    /*
      radio config for GFSK with 57kHz deviation
    */
    {CC2500_00_IOCFG2,   0x01}, // GD2 high on RXFIFO filled or end of packet
    {CC2500_17_MCSM1,    0x03}, // RX->IDLE, CCA always, TX -> IDLE
    {CC2500_18_MCSM0,    0x08}, // XOSC expire 64, cal never
    {CC2500_06_PKTLEN,   0x0D}, // packet length 13
    {CC2500_07_PKTCTRL1, 0x0C}, // enable RSSI+LQI, no addr check, CRC autoflush, PQT=0
    {CC2500_08_PKTCTRL0, 0x44}, // fixed length mode, CRC, FIFO enable, whitening
    {CC2500_3E_PATABLE,  0xFF}, // initially max power
    {CC2500_0B_FSCTRL1,  0x0A}, // IF=253.90625kHz assuming 26MHz crystal
    {CC2500_0C_FSCTRL0,  0x00}, // freqoffs = 0
    {CC2500_0D_FREQ2,    0x5C}, // freq control high
    {CC2500_0E_FREQ1,    0x76}, // freq control middle
    {CC2500_0F_FREQ0,    0x27}, // freq control low
    {CC2500_10_MDMCFG4,  0x8C}, // filter bandwidth 203kHz
    {CC2500_11_MDMCFG3,  0x2F}, // data rate 120kbaud
    {CC2500_12_MDMCFG2,  0x13}, // 30/32 sync word bits, no manchester, GFSK, DC filter enabled
    {CC2500_13_MDMCFG1,  0xA3}, // chan spacing exponent 3, preamble 4 bytes, FEC enabled
    {CC2500_14_MDMCFG0,  0x7A}, // chan spacing 299.926757kHz for 26MHz crystal
    {CC2500_15_DEVIATN,  0x51}, // modem deviation 57kHz for 26MHz crystal
    {CC2500_19_FOCCFG,   0x16}, // frequency offset compensation
    {CC2500_1A_BSCFG,    0x6C}, // bit sync config
    {CC2500_1B_AGCCTRL2, 0x43}, // target amplitude 33dB
    {CC2500_1C_AGCCTRL1, 0x40}, // AGC control 2
    {CC2500_1D_AGCCTRL0, 0x91}, // AGC control 0
    {CC2500_21_FREND1,   0x56}, // frontend config1
    {CC2500_22_FREND0,   0x10}, // frontend config0
    {CC2500_23_FSCAL3,   0xA9}, // frequency synth cal3
    {CC2500_24_FSCAL2,   0x0A}, // frequency synth cal2
    {CC2500_25_FSCAL1,   0x00}, // frequency synth cal1
    {CC2500_26_FSCAL0,   0x11}, // frequency synth cal0
    {CC2500_29_FSTEST,   0x59}, // test bits
    {CC2500_2C_TEST2,    0x88}, // test settings
    {CC2500_2D_TEST1,    0x31}, // test settings
    {CC2500_2E_TEST0,    0x0B}, // test settings
    {CC2500_03_FIFOTHR,  0x07}, // TX fifo threashold 33, RX fifo threshold 32
    {CC2500_09_ADDR,     0x00}, // device address 0 (broadcast)
};

const AP_Radio_cc2500::config AP_Radio_cc2500::radio_config[] = {
    /* config for both TX and RX (from SmartRF Studio)
       setup for MSK at 120kbaud, FEC enabled, whitening enabled, base freq 2403.999756MHz
       channel spacing 299.926758, crystal 26MHz, RX filter bw 203.125kHz
    */
    {CC2500_06_PKTLEN,   0x0D},
    {CC2500_07_PKTCTRL1, 0x0C},
    {CC2500_08_PKTCTRL0, 0x44},
    {CC2500_0B_FSCTRL1,  0x0A},
    {CC2500_0D_FREQ2,    0x5C},
    {CC2500_0E_FREQ1,    0x76},
    {CC2500_0F_FREQ0,    0x27},
    {CC2500_11_MDMCFG3,  0x2F},
    {CC2500_12_MDMCFG2,  0x73},
    {CC2500_13_MDMCFG1,  0xA3},
    {CC2500_14_MDMCFG0,  0x7A},
    {CC2500_15_DEVIATN,  0x70},
    {CC2500_17_MCSM1,    0x03},
    {CC2500_18_MCSM0,    0x08},
    {CC2500_19_FOCCFG,   0x16},
    {CC2500_1B_AGCCTRL2, 0x43},
    {CC2500_23_FSCAL3,   0xEA},
    {CC2500_25_FSCAL1,   0x00},
    {CC2500_26_FSCAL0,   0x11},
    {CC2500_2B_AGCTEST,  0x3E},
    {CC2500_03_FIFOTHR,  0x07}, // TX fifo threashold 33, RX fifo threshold 32

    // config specific to RX
    {CC2500_00_IOCFG2,   0x01}, // GD2 high on RX